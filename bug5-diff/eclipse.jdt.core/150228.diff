commit a49b0379fae683770f815e7e32d76b4ebea892ec
Author: David Audel <daudel>
Date:   Thu Oct 19 14:24:36 2006 +0000

    HEAD - bug 150228

472	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
10	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
110	13	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
302	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
44	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
75	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index b2cbc95..9d18a31 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -9990,6 +9990,478 @@ public void testCompletionVariableName15() throws JavaModelException {
 		JavaCore.setOptions(options);
 	}
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName16() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		Object ;\n"+
+            "		foo = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo[VARIABLE_DECLARATION]{foo, null, Ljava.lang.Object;, foo, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName17() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		Object foo1;\n"+
+            "		/*here*/Object ;\n"+
+            "		Object foo3;\n"+
+            "		foo1 = null;\n"+
+            "		foo2 = null;\n"+
+            "		foo3 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName18() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		Object ;\n"+
+            "		foo = Test.class;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo[VARIABLE_DECLARATION]{foo, null, Ljava.lang.Object;, foo, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName19() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		Object ;\n"+
+            "		object = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName20() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		class X {\n"+
+            "		  Object foo1 = foo2;\n"+
+            "		  void bar() {\n"+
+            "		    foo1 = null;\n"+
+            "		    Object foo3 = foo4;\n"+
+            "		    foo3 = null;\n"+
+            "		  }\n"+
+            "		}\n"+
+            "		foo5 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+    		"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo4[VARIABLE_DECLARATION]{foo4, null, Ljava.lang.Object;, foo4, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo5[VARIABLE_DECLARATION]{foo5, null, Ljava.lang.Object;, foo5, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName21() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		{\n"+
+            "		  /*here*/Object ;\n"+
+            "		  foo1 = null;\n"+
+            "		}\n"+
+            "		foo2 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+    		"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo1[VARIABLE_DECLARATION]{foo1, null, Ljava.lang.Object;, foo1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName22() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		Object foo1;\n"+
+            "		/*here*/Object ;\n"+
+            "		{\n"+
+            "		  Object foo3;\n"+
+            "		  foo1 = null;\n"+
+            "		  foo2 = null;\n"+
+            "		  foo3 = null;\n"+
+            "		}\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName23() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		foo1 = null;\n"+
+            "		#\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo1[VARIABLE_DECLARATION]{foo1, null, Ljava.lang.Object;, foo1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName24() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		#\n"+
+            "		foo1 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo1[VARIABLE_DECLARATION]{foo1, null, Ljava.lang.Object;, foo1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName25() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		#\n"+
+            "		foo1 = null;\n"+
+            "		#\n"+
+            "		foo2 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo1[VARIABLE_DECLARATION]{foo1, null, Ljava.lang.Object;, foo1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName26() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		#\n"+
+            "		foo1 = null;\n"+
+            "		#\n"+
+            "		foo2 = null;\n"+
+            "		#\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo1[VARIABLE_DECLARATION]{foo1, null, Ljava.lang.Object;, foo1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName27() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		Object foo0 = null;\n"+
+            "		foo0 = null;\n"+
+            "		#\n"+
+            "		class X {\n"+
+            "		  Object foo1 = foo2;\n"+
+            "		  void bar() {\n"+
+            "		    foo1 = null;\n"+
+            "		    Object foo3 = foo4;\n"+
+            "		    foo3 = null;\n"+
+            "		  }\n"+
+            "		}\n"+
+            "		foo5 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+    		"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo2[VARIABLE_DECLARATION]{foo2, null, Ljava.lang.Object;, foo2, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo4[VARIABLE_DECLARATION]{foo4, null, Ljava.lang.Object;, foo4, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo5[VARIABLE_DECLARATION]{foo5, null, Ljava.lang.Object;, foo5, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName28() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		Object foo1 = null;\n"+
+            "		foo1.foo2 = null;\n"+
+            "		foo3.foo4 = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+    		"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"foo3[VARIABLE_DECLARATION]{foo3, null, Ljava.lang.Object;, foo3, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName29() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void foo(){\n"+
+            "		/*here*/Object ;\n"+
+            "		class X {\n"+
+            "			void bar1() {\n"+
+            "				var1 = null;\n"+
+            "			}\n"+
+            "			void bar2() {\n"+
+            "				Object var2 = null;\n"+
+            "				var2 = null;\n"+
+            "			}\n"+
+            "			void bar3() {\n"+
+            "				Object var3 = null;\n"+
+            "				{\n"+
+            "					var3 = null;\n"+
+            "					Object var4 = null;\n"+
+            "				}\n"+
+            "				var4 = null;\n"+
+            "			}\n"+
+            "		}\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "/*here*/Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+    		"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+    		"var1[VARIABLE_DECLARATION]{var1, null, Ljava.lang.Object;, var1, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"var4[VARIABLE_DECLARATION]{var4, null, Ljava.lang.Object;, var4, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName30() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	public Test(){\n"+
+            "		Object ;\n"+
+            "		foo = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo[VARIABLE_DECLARATION]{foo, null, Ljava.lang.Object;, foo, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName31() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	{\n"+
+            "		Object ;\n"+
+            "		foo = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo[VARIABLE_DECLARATION]{foo, null, Ljava.lang.Object;, foo, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
+public void testCompletionVariableName32() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+            "/Completion/src/test/Test.java",
+            "package test;\n"+
+            "public class Test {\n"+
+            "	void bar(Object ) {\n"+
+            "		foo = null;\n"+
+            "	}\n"+
+            "}");
+    
+    CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+    String str = this.workingCopies[0].getSource();
+    String completeBehind = "Object ";
+    int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+    this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+    assertResults(
+			"object[VARIABLE_DECLARATION]{object, null, Ljava.lang.Object;, object, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"}\n"+
+			"foo[VARIABLE_DECLARATION]{foo, null, Ljava.lang.Object;, foo, null, "+(R_DEFAULT + R_INTERESTING + R_NAME_FIRST_SUFFIX + R_NAME_FIRST_PREFIX + R_NAME_LESS_NEW_CHARACTERS + R_CASE + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
 public void testCompletionNonEmptyToken1() throws JavaModelException {
 	CompletionTestsRequestor requestor = new CompletionTestsRequestor();
 	ICompilationUnit cu= getCompilationUnit("Completion", "src", "", "CompletionNonEmptyToken1.java");
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 33e9a62..59c43f1 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -54,10 +54,19 @@ Eclipse SDK 3.3M3 - ?th October 2006
 <ul>
 <li>New compiler warning to detect overriding of a method without a super invocation has been added.
 See bug <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=156736">156736</a> for further details.</li>
+<li>Code Assist propose unresolved names as possible local variable name<br>
+<pre>
+int f<code assist>
+System.out.print(foo);
+</pre>
+In this example foo is proposed as a possible completion.
+</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=161204">161204</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=150228">150228</a>
+Code assist for unresolved local variables
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=161204">161204</a>
 code assist with unresolved types does not work when using 5.0 rt.jar
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=161554">161554</a>
 org.eclipse.jdt.core.tests.compiler.regression.GenericTypeTest#test1050 fails on IBM JDK 1.5 VM
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 679eb15..5f2e63e 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist;
 
+import java.util.ArrayList;
 import java.util.Locale;
 import java.util.Map;
 
@@ -37,6 +38,7 @@ import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
+import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
@@ -1258,7 +1260,7 @@ public final class CompletionEngine
 				
 				this.completionToken = method.selector;
 				
-				findVariableNames(this.completionToken, method.returnType, excludeNames, FIELD, method.modifiers);
+				findVariableNames(this.completionToken, method.returnType, excludeNames, null, FIELD, method.modifiers);
 			}
 		} else if (astNode instanceof CompletionOnFieldName) {
 			if (!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
@@ -1272,29 +1274,31 @@ public final class CompletionEngine
 				
 				this.completionToken = field.realName;
 				
-				findVariableNames(field.realName, field.type, excludeNames, FIELD, field.modifiers);
+				findVariableNames(field.realName, field.type, excludeNames, null, FIELD, field.modifiers);
 			}
 		} else if (astNode instanceof CompletionOnLocalName || astNode instanceof CompletionOnArgumentName) {
 			if (!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
 				LocalDeclaration variable = (LocalDeclaration) astNode;
 				
 				LocalVariableBinding[] locals = ((BlockScope)scope).locals;
-				char[][] excludeNames = new char[locals.length][];
+				char[][] discouragedNames = new char[locals.length][];
 				int localCount = 0;
 				for(int i = 0 ; i < locals.length ; i++){
 					if (locals[i] != null) {
-						excludeNames[localCount++] = locals[i].name;
+						discouragedNames[localCount++] = locals[i].name;
 					}
 				}
-				System.arraycopy(excludeNames, 0, excludeNames = new char[localCount][], 0, localCount);
+				System.arraycopy(discouragedNames, 0, discouragedNames = new char[localCount][], 0, localCount);
 				
 				if (variable instanceof CompletionOnLocalName){
 					this.completionToken = ((CompletionOnLocalName) variable).realName;
-					findVariableNames(this.completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);
+					char[][] forbiddenNames = findVariableFromUnresolvedReference(variable, (BlockScope)scope, discouragedNames);
+					findVariableNames(this.completionToken, variable.type, discouragedNames, forbiddenNames, LOCAL, variable.modifiers);
 				} else {
 					CompletionOnArgumentName arg = (CompletionOnArgumentName) variable;
 					this.completionToken = arg.realName;
-					findVariableNames(this.completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);
+					char[][] forbiddenNames = findVariableFromUnresolvedReference(variable, (BlockScope)scope, discouragedNames);
+					findVariableNames(this.completionToken, variable.type, discouragedNames, forbiddenNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);
 				}
 			}
 		} else if (astNode instanceof CompletionOnKeyword) {
@@ -6232,6 +6236,92 @@ public final class CompletionEngine
 			}
 		}
 	}
+	private char[][] findVariableFromUnresolvedReference(LocalDeclaration variable, BlockScope scope, final char[][] discouragedNames) {
+		final TypeReference type = variable.type;
+		if(type != null &&
+				type.resolvedType != null &&
+				type.resolvedType.problemId() == ProblemReasons.NoError){
+			
+			final int discouragedNamesCount = discouragedNames == null ? 0 : discouragedNames.length;
+			final ArrayList proposedNames = new ArrayList();
+			
+			UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor nameRequestor = 
+				new UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor() {
+					public void acceptName(char[] name) {
+						for (int i = 0; i < discouragedNamesCount; i++) {
+							if (CharOperation.equals(discouragedNames[i], name, false)) return;
+						}
+						
+						int relevance = computeBaseRelevance();
+						relevance += computeRelevanceForInterestingProposal();
+						relevance += computeRelevanceForCaseMatching(completionToken, name);
+						relevance += R_NAME_FIRST_PREFIX;
+						relevance += R_NAME_FIRST_SUFFIX;
+						relevance += R_NAME_LESS_NEW_CHARACTERS;
+						relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for variable name
+						
+						// accept result
+						CompletionEngine.this.noProposal = false;
+						if(!CompletionEngine.this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
+							CompletionProposal proposal = CompletionEngine.this.createProposal(CompletionProposal.VARIABLE_DECLARATION, CompletionEngine.this.actualCompletionPosition);
+							proposal.setSignature(getSignature(type.resolvedType));
+							proposal.setPackageName(type.resolvedType.qualifiedPackageName());
+							proposal.setTypeName(type.resolvedType.qualifiedSourceName());
+							proposal.setName(name);
+							proposal.setCompletion(name);
+							//proposal.setFlags(Flags.AccDefault);
+							proposal.setReplaceRange(CompletionEngine.this.startPosition - CompletionEngine.this.offset, CompletionEngine.this.endPosition - CompletionEngine.this.offset);
+							proposal.setRelevance(relevance);
+							CompletionEngine.this.requestor.accept(proposal);
+							if(DEBUG) {
+								CompletionEngine.this.printDebug(proposal);
+							}
+						}
+						proposedNames.add(name);
+					}
+				};
+			
+			ReferenceContext referenceContext = scope.referenceContext();
+			if (referenceContext instanceof AbstractMethodDeclaration) {
+				AbstractMethodDeclaration md = (AbstractMethodDeclaration)referenceContext;
+				
+				UnresolvedReferenceNameFinder nameFinder = new UnresolvedReferenceNameFinder(this);
+				nameFinder.find(
+						completionToken,
+						md,
+						variable.declarationSourceEnd + 1,
+						nameRequestor);
+			} else if (referenceContext instanceof TypeDeclaration) {
+				TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
+				FieldDeclaration[] fields = typeDeclaration.fields;
+				if (fields != null) {
+					done : for (int i = 0; i < fields.length; i++) {
+						if (fields[i] instanceof Initializer) {
+							Initializer initializer = (Initializer) fields[i];
+							if (initializer.bodyStart <= variable.sourceStart &&
+									variable.sourceStart < initializer.bodyEnd) {
+								UnresolvedReferenceNameFinder nameFinder = new UnresolvedReferenceNameFinder(this);
+								nameFinder.find(
+										completionToken,
+										initializer,
+										typeDeclaration.scope,
+										variable.declarationSourceEnd + 1,
+										nameRequestor);
+								break done;
+							}
+						}
+					}
+				}
+			}
+			
+			int proposedNamesCount = proposedNames.size();
+			if (proposedNamesCount > 0) {
+				return (char[][])proposedNames.toArray(new char[proposedNamesCount][]);
+			}
+		}
+		
+		return null;
+	}
 		// Helper method for private void findVariableNames(char[] name, TypeReference type )
 	private void findVariableName(
 		char[] token,
@@ -6239,7 +6329,8 @@ public final class CompletionEngine
 		char[] qualifiedSourceName,
 		char[] sourceName,
 		final TypeBinding typeBinding,
-		char[][] excludeNames,
+		char[][] discouragedNames,
+		final char[][] forbiddenNames,
 		int dim,
 		int kind,
 		int modifiers){
@@ -6283,6 +6374,11 @@ public final class CompletionEngine
 				accept(name, 0, reusedCharacters);
 			}
 			void accept(char[] name, int prefixAndSuffixRelevance, int reusedCharacters){
+				int l = forbiddenNames == null ? 0 : forbiddenNames.length;
+				for (int i = 0; i < l; i++) {
+					if (CharOperation.equals(forbiddenNames[i], name, false)) return;
+				}
+				
 				if (CharOperation.prefixEquals(t, name, false)) {
 					int relevance = computeBaseRelevance();
 					relevance += computeRelevanceForInterestingProposal();
@@ -6321,7 +6417,7 @@ public final class CompletionEngine
 					dim,
 					modifiers,
 					token,
-					excludeNames,
+					discouragedNames,
 					namingRequestor);
 				break;
 			case LOCAL :
@@ -6331,7 +6427,7 @@ public final class CompletionEngine
 					qualifiedSourceName,
 					dim,
 					token,
-					excludeNames,
+					discouragedNames,
 					namingRequestor);
 				break;
 			case ARGUMENT :
@@ -6341,13 +6437,13 @@ public final class CompletionEngine
 					qualifiedSourceName,
 					dim,
 					token,
-					excludeNames,
+					discouragedNames,
 					namingRequestor);
 				break;
 		}
 	}
 
-	private void findVariableNames(char[] name, TypeReference type , char[][] excludeNames, int kind, int modifiers){
+	private void findVariableNames(char[] name, TypeReference type , char[][] discouragedNames, char[][] forbiddenNames, int kind, int modifiers){
 
 		if(type != null &&
 			type.resolvedType != null &&
@@ -6359,7 +6455,8 @@ public final class CompletionEngine
 				tb.leafComponentType().qualifiedSourceName(),
 				tb.leafComponentType().sourceName(),
 				tb,
-				excludeNames,
+				discouragedNames,
+				forbiddenNames,
 				type.dimensions(),
 				kind,
 				modifiers);
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
new file mode 100644
index 0000000..e5173c2
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
@@ -0,0 +1,302 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionParser;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionScanner;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.Block;
+import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
+import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Statement;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.util.SimpleSet;
+
+public class UnresolvedReferenceNameFinder extends ASTVisitor {
+	public static interface UnresolvedReferenceNameRequestor {
+		public void acceptName(char[] name);
+	}
+	
+	private UnresolvedReferenceNameRequestor requestor;
+	
+	private CompletionParser parser;
+	private CompletionScanner completionScanner;
+	
+	private int parentsPtr;
+	private ASTNode[] parentsz;
+	
+	private int potentialVariableNamesPtr;
+	private char[][] potentialVariableNames;
+	private int[] potentialVariableNameStarts;
+	
+	private SimpleSet acceptedNames = new SimpleSet();
+	
+	public UnresolvedReferenceNameFinder(CompletionEngine completionEngine) {
+		this.parser = completionEngine.parser;
+		this.completionScanner = (CompletionScanner) parser.scanner;
+	} 
+	
+	private void acceptName(char[] name) {
+		if (acceptedNames.includes(name)) return;
+		
+		this.acceptedNames.add(name);
+		
+		// accept result
+		this.requestor.acceptName(name);
+	}
+	
+	public void find(char[] startWith, Initializer initializer, ClassScope scope, int from, UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod = this.find(startWith, scope, from, initializer.bodyEnd, nameRequestor);
+		fakeMethod.traverse(this, scope);
+	}
+	
+	public void find(char[] startWith, AbstractMethodDeclaration methodDeclaration, int from, UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod = this.find(startWith, methodDeclaration.scope, from, methodDeclaration.bodyEnd, nameRequestor);
+		fakeMethod.traverse(this, methodDeclaration.scope.classScope());
+	}
+	
+	private MethodDeclaration find(char[] startWith, Scope s, int from, int to, UnresolvedReferenceNameRequestor nameRequestor) {
+		this.requestor = nameRequestor;
+		
+		// reinitialize completion scanner to be usable as a normal scanner
+		this.completionScanner.cursorLocation = 0;
+		
+		// reinitialize completionIdentifier
+		this.completionScanner.prefix = startWith;
+		
+		// compute location of the end of the current block
+		this.completionScanner.resetTo(from + 1, to);
+		this.completionScanner.jumpOverBlock();
+		
+		this.completionScanner.startRecordingIdentifiers();
+		
+		MethodDeclaration fakeMethod = this.parser.parseStatementsAfterCompletion(
+				from,
+				this.completionScanner.startPosition - 1,
+				s.compilationUnitScope().referenceContext);
+		
+		this.completionScanner.stopRecordingIdentifiers();
+		
+		this.potentialVariableNames = this.completionScanner.potentialVariableNames;
+		this.potentialVariableNameStarts = this.completionScanner.potentialVariableNameStarts;
+		this.potentialVariableNamesPtr = this.completionScanner.potentialVariableNamesPtr;
+		
+		this.parentsPtr = -1;
+		this.parentsz = new ASTNode[10];
+		
+		return fakeMethod;
+	}
+	
+	private void popParent() {
+		this.parentsPtr--;
+	}
+	private void pushParent(ASTNode parent) {
+		int length = this.parentsz.length;
+		if (this.parentsPtr >= length - 1) {
+			System.arraycopy(this.parentsz, 0, this.parentsz = new ASTNode[length * 2], 0, length);
+		}
+		this.parentsz[++this.parentsPtr] = parent;
+	}
+	
+	private ASTNode getEnclosingDeclaration() {
+		int i = this.parentsPtr;
+		while (i > -1) {
+			ASTNode parent = parentsz[i];
+			if (parent instanceof AbstractMethodDeclaration) {
+				return parent;
+			} else if (parent instanceof Initializer) {
+				return parent;
+			} else if (parent instanceof FieldDeclaration) {
+				return parent;
+			} else if (parent instanceof TypeDeclaration) {
+				return parent;
+			}
+			i--;
+		}
+		return null;
+	} 
+	
+	public boolean visit(Block block, BlockScope blockScope) {
+		pushParent(block);
+		return true;
+	}
+	
+	public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
+		pushParent(constructorDeclaration);
+		return true;
+	}
+	
+	public boolean visit(FieldDeclaration fieldDeclaration, MethodScope methodScope) {
+		pushParent(fieldDeclaration);
+		return true;
+	}
+	
+	public boolean visit(Initializer initializer, MethodScope methodScope) {
+		pushParent(initializer);
+		return true;
+	}
+	
+	public boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {
+		pushParent(methodDeclaration);
+		return true;
+	}
+	
+	public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope blockScope) {
+		removeFields(localTypeDeclaration);
+		pushParent(localTypeDeclaration);
+		return true;
+	}
+	
+	public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
+		removeFields(memberTypeDeclaration);
+		pushParent(memberTypeDeclaration);
+		return true;
+	}
+	
+	public void endVisit(Block block, BlockScope blockScope) {
+		ASTNode enclosingDeclaration = getEnclosingDeclaration();
+		removeLocals(block.statements, enclosingDeclaration.sourceStart, block.sourceEnd);
+		popParent();
+	}
+	
+	public void endVisit(Argument argument, BlockScope blockScope) {
+		endVisitRemoved(argument.declarationSourceStart, argument.sourceEnd);
+	}
+	
+	public void endVisit(Argument argument, ClassScope classScope) {
+		endVisitRemoved(argument.declarationSourceStart, argument.sourceEnd);
+	}
+	
+	public void endVisit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
+		if (!constructorDeclaration.isDefaultConstructor && !constructorDeclaration.isClinit()) {
+			endVisitPreserved(constructorDeclaration.bodyStart, constructorDeclaration.bodyEnd);
+		}
+		popParent();
+	}
+	
+	public void endVisit(FieldDeclaration fieldDeclaration, MethodScope methodScope) {
+		endVisitRemoved(fieldDeclaration.declarationSourceStart, fieldDeclaration.sourceEnd);
+		endVisitPreserved(fieldDeclaration.sourceEnd, fieldDeclaration.declarationEnd);
+		popParent();
+	}
+	
+	public void endVisit(Initializer initializer, MethodScope methodScope) {
+		endVisitPreserved(initializer.bodyStart, initializer.bodyEnd);
+		popParent();
+	}
+	
+	public void endVisit(LocalDeclaration localDeclaration, BlockScope blockScope) {
+		endVisitRemoved(localDeclaration.declarationSourceStart, localDeclaration.sourceEnd);
+	}
+	
+	public void endVisit(MethodDeclaration methodDeclaration, ClassScope classScope) {
+		removeLocals(
+				methodDeclaration.arguments,
+				methodDeclaration.declarationSourceStart,
+				methodDeclaration.declarationSourceEnd);
+		removeLocals(
+				methodDeclaration.statements,
+				methodDeclaration.declarationSourceStart,
+				methodDeclaration.declarationSourceEnd);
+		endVisitPreserved(
+				methodDeclaration.bodyStart,
+				methodDeclaration.bodyEnd);
+		popParent();
+	}
+	
+	public void endVisit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+		removeFields(typeDeclaration);
+		endVisitRemoved(typeDeclaration.sourceStart, typeDeclaration.declarationSourceEnd);
+		popParent();
+	}
+	
+	public void endVisit(TypeDeclaration typeDeclaration, ClassScope classScope) {
+		endVisitRemoved(typeDeclaration.sourceStart, typeDeclaration.declarationSourceEnd);
+		popParent();
+	}
+	
+	private void endVisitPreserved(int start, int end) {
+		for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
+			char[] name = this.potentialVariableNames[i];
+			if (name != null) {
+				int nameStart = this.potentialVariableNameStarts[i];
+				if (start < nameStart && nameStart < end) {
+					this.potentialVariableNames[i] = null;
+					this.acceptName(name);
+				}
+			}
+		}
+	}
+	
+	private void endVisitRemoved(int start, int end) {
+		for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
+			if (this.potentialVariableNames[i] != null) {
+				int nameStart = this.potentialVariableNameStarts[i];
+				if (start < nameStart && nameStart < end) {
+					this.potentialVariableNames[i] = null;
+				}
+			}
+		}
+	}
+	
+	private void removeLocals(Statement[] statements, int start, int end) {
+		if (statements != null) {
+			for (int i = 0; i < statements.length; i++) {
+				if (statements[i] instanceof LocalDeclaration) {
+					LocalDeclaration localDeclaration = (LocalDeclaration) statements[i];
+					for (int j = 0; j <= this.potentialVariableNamesPtr; j++) {
+						char[] name = this.potentialVariableNames[j];
+						if (name != null) {
+							int nameStart = this.potentialVariableNameStarts[j];
+							if(start <= nameStart && nameStart <= end) {
+								if (CharOperation.equals(name, localDeclaration.name, false)) {
+									this.potentialVariableNames[j] = null;
+								}
+							}
+						}
+					}
+				}
+			}
+			
+		}
+	}
+	
+	private void removeFields(TypeDeclaration typeDeclaration) {
+		FieldDeclaration[] fieldDeclarations = typeDeclaration.fields;
+		if (fieldDeclarations != null) {
+			for (int i = 0; i < fieldDeclarations.length; i++) {
+				for (int j = 0; j <= this.potentialVariableNamesPtr; j++) {
+					char[] name = this.potentialVariableNames[j];
+					if (name != null) {
+						int nameStart = this.potentialVariableNameStarts[j];
+						if(typeDeclaration.declarationSourceStart <= nameStart &&
+								nameStart <= typeDeclaration.declarationSourceEnd) {
+							if (CharOperation.equals(name, fieldDeclarations[i].name, false)) {
+								this.potentialVariableNames[j] = null;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 208cd91..ce91c34 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -73,6 +73,7 @@ public class CompletionParser extends AssistParser {
 	protected static final int K_LABEL = COMPLETION_PARSER + 36;
 	
 	public final static char[] FAKE_TYPE_NAME = new char[]{' '};
+	public final static char[] FAKE_METHOD_NAME = new char[]{' '};
 	public final static char[] VALUE = new char[]{'v', 'a', 'l', 'u', 'e'};
 	
 	/* public fields */
@@ -3601,6 +3602,49 @@ public void parseBlockStatements(
 	canBeExplicitConstructor = 1;
 	super.parseBlockStatements(cd, unit);
 }
+public MethodDeclaration parseStatementsAfterCompletion(int start, int end, CompilationUnitDeclaration unit) {
+	this.methodRecoveryActivated = true;
+	
+	initialize();
+
+	// simulate goForMethodBody except that we don't want to balance brackets because they are not going to be balanced
+	goForBlockStatementsopt();
+
+	MethodDeclaration fakeMethod = new MethodDeclaration(unit.compilationResult());
+	fakeMethod.selector = FAKE_METHOD_NAME;
+	fakeMethod.bodyStart = start;
+	fakeMethod.bodyEnd = end;
+	fakeMethod.declarationSourceStart = start;
+	fakeMethod.declarationSourceEnd = end;
+	fakeMethod.sourceStart = start;
+	fakeMethod.sourceEnd = start; //fake method must ignore the method header
+	
+	referenceContext = fakeMethod;
+	compilationUnit = unit;
+	
+	scanner.resetTo(start, end);
+	consumeNestedMethod();
+	try {
+		parse();
+	} catch (AbortCompilation ex) {
+		lastAct = ERROR_ACTION;
+	} finally {
+		nestedMethod[nestedType]--;		
+	}
+	if (!this.hasError) {
+		int length;
+		if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) != 0) {
+			System.arraycopy(
+				this.astStack, 
+				(this.astPtr -= length) + 1, 
+				fakeMethod.statements = new Statement[length], 
+				0, 
+				length); 
+		}
+	}
+	
+	return fakeMethod;
+}
 /*
  * Prepares the state of the parser to go for BlockStatements.
  */
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
index 9beaf5d..b083ed5 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
@@ -40,6 +40,14 @@ public class CompletionScanner extends Scanner {
 
 	public static final char[] EmptyCompletionIdentifier = {};
 	
+	private boolean record = false;
+	public char[] prefix;
+	private int currentToken;
+	private int currentTokenStart;
+	public int potentialVariableNamesPtr; 
+	public char[][] potentialVariableNames;
+	public int[] potentialVariableNameStarts;
+	
 public CompletionScanner(long sourceLevel) {
 	super(
 		false /*comment*/, 
@@ -50,6 +58,25 @@ public CompletionScanner(long sourceLevel) {
 		null/*taskPriorities*/,
 		true/*taskCaseSensitive*/);
 }
+private void addPotentialName(char[] name, int start) {
+	int length = this.potentialVariableNames.length;
+	if (this.potentialVariableNamesPtr >= length - 1) {
+		System.arraycopy(
+				this.potentialVariableNames, 
+				0,
+				this.potentialVariableNames = new char[length * 2][],
+				0,
+				length);
+		System.arraycopy(
+				this.potentialVariableNameStarts,
+				0,
+				this.potentialVariableNameStarts = new int[length * 2],
+				0,
+				length);
+	}
+	this.potentialVariableNames[++this.potentialVariableNamesPtr] = name;
+	this.potentialVariableNameStarts[this.potentialVariableNamesPtr] = start;
+}
 /* 
  * Truncate the current identifier if it is containing the cursor location. Since completion is performed
  * on an identifier prefix.
@@ -102,6 +129,32 @@ public char[] getCurrentTokenSourceString() {
 	return super.getCurrentTokenSourceString();
 }
 public int getNextToken() throws InvalidInputException {
+	int nextToken = this.getNextToken0();
+	if (this.record) {
+		switch (nextToken) {
+			case TokenNameIdentifier:
+				if (this.currentToken != TokenNameDOT) {
+					char[] identifier = this.getCurrentIdentifierSource();
+					if (!Character.isUpperCase(identifier[0]) && 
+							CharOperation.prefixEquals(this.prefix, identifier, true)) {
+						this.addPotentialName(identifier, this.startPosition);
+					}
+				}
+				break;
+			case TokenNameLPAREN :
+			case TokenNameLBRACE :
+				if (this.currentToken == TokenNameIdentifier) {
+					this.removePotentialNamesAt(this.currentTokenStart);
+					
+				}
+				break;
+		}
+	}
+	this.currentToken = nextToken;
+	this.currentTokenStart = this.startPosition;
+	return nextToken;
+}
+private int getNextToken0() throws InvalidInputException {
 
 	this.wasAcr = false;
 	this.unicodeCharSize = 0;
@@ -807,6 +860,17 @@ public final void getNextUnicodeChar() throws InvalidInputException {
 		throw new InvalidCursorLocation(InvalidCursorLocation.NO_COMPLETION_INSIDE_UNICODE);
 	}
 }
+public final void jumpOverBlock() {
+	this.jumpOverMethodBody();
+}
+public void removePotentialNamesAt(int position) {
+	for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
+		int namePosition = this.potentialVariableNameStarts[i];
+		if (namePosition == position) {
+			this.potentialVariableNames[i] = null;
+		}
+	}
+}
 ///*
 // * In case we actually read a keyword, but the cursor is located inside,
 // * we pretend we read an identifier.
@@ -834,4 +898,15 @@ public int scanNumber(boolean dotPrefix) throws InvalidInputException {
 	}
 	return token;
 }
+
+public void startRecordingIdentifiers() {
+	this.record = true;
+	
+	this.potentialVariableNamesPtr = -1; 
+	this.potentialVariableNames = new char[10][];
+	this.potentialVariableNameStarts = new int[10];
+}
+public void stopRecordingIdentifiers() {
+	this.record = true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index cfa8baa..d3b82af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -184,7 +184,7 @@ public class Parser implements  ParserBasicInformation, TerminalTokens, Operator
 	
 	// statement recovery
 //	public boolean statementRecoveryEnabled = true;
-	protected boolean methodRecoveryActivated = false;
+	public boolean methodRecoveryActivated = false;
 	protected boolean statementRecoveryActivated = false;
 	protected TypeDeclaration[] recoveredTypes;
 	protected int recoveredTypePtr;
commit 084792986a184eb522c2b0979d8faf076d06bee4
Author: David Audel <daudel>
Date:   Mon Oct 23 16:43:24 2006 +0000

    HEAD - bug 150228 (performance fix)

224	44	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
8	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
10	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
index e5173c2..14ee9b7 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
@@ -32,6 +32,8 @@ import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 
 public class UnresolvedReferenceNameFinder extends ASTVisitor {
+	private static final int MAX_LINE_COUNT = 100;
+	
 	public static interface UnresolvedReferenceNameRequestor {
 		public void acceptName(char[] name);
 	}
@@ -42,7 +44,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	private CompletionScanner completionScanner;
 	
 	private int parentsPtr;
-	private ASTNode[] parentsz;
+	private ASTNode[] parents;
 	
 	private int potentialVariableNamesPtr;
 	private char[][] potentialVariableNames;
@@ -66,12 +68,12 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	
 	public void find(char[] startWith, Initializer initializer, ClassScope scope, int from, UnresolvedReferenceNameRequestor nameRequestor) {
 		MethodDeclaration fakeMethod = this.find(startWith, scope, from, initializer.bodyEnd, nameRequestor);
-		fakeMethod.traverse(this, scope);
+		if (fakeMethod != null) fakeMethod.traverse(this, scope);
 	}
 	
 	public void find(char[] startWith, AbstractMethodDeclaration methodDeclaration, int from, UnresolvedReferenceNameRequestor nameRequestor) {
 		MethodDeclaration fakeMethod = this.find(startWith, methodDeclaration.scope, from, methodDeclaration.bodyEnd, nameRequestor);
-		fakeMethod.traverse(this, methodDeclaration.scope.classScope());
+		if (fakeMethod != null) fakeMethod.traverse(this, methodDeclaration.scope.classScope());
 	}
 	
 	private MethodDeclaration find(char[] startWith, Scope s, int from, int to, UnresolvedReferenceNameRequestor nameRequestor) {
@@ -87,40 +89,132 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		this.completionScanner.resetTo(from + 1, to);
 		this.completionScanner.jumpOverBlock();
 		
+		int blockEnd = this.completionScanner.startPosition - 1;
+		
+		int maxEnd =
+			this.completionScanner.getLineEnd(
+					this.completionScanner.getLineNumber(from) + MAX_LINE_COUNT);
+		
+		int end;
+		if (maxEnd < 0) {
+			end = blockEnd;
+		} else {
+			end = maxEnd < blockEnd ? maxEnd : blockEnd;
+		}
+		
 		this.completionScanner.startRecordingIdentifiers();
 		
 		MethodDeclaration fakeMethod = this.parser.parseStatementsAfterCompletion(
 				from,
-				this.completionScanner.startPosition - 1,
+				end,
 				s.compilationUnitScope().referenceContext);
 		
 		this.completionScanner.stopRecordingIdentifiers();
 		
-		this.potentialVariableNames = this.completionScanner.potentialVariableNames;
-		this.potentialVariableNameStarts = this.completionScanner.potentialVariableNameStarts;
-		this.potentialVariableNamesPtr = this.completionScanner.potentialVariableNamesPtr;
+		if(!this.initPotentialNamesTables()) return null;
 		
 		this.parentsPtr = -1;
-		this.parentsz = new ASTNode[10];
+		this.parents = new ASTNode[10];
 		
 		return fakeMethod;
 	}
 	
+	private boolean initPotentialNamesTables() {
+		char[][] pvns = this.completionScanner.potentialVariableNames;
+		int[] pvnss = this.completionScanner.potentialVariableNameStarts;
+		int pvnsPtr = this.completionScanner.potentialVariableNamesPtr;
+		
+		if (pvnsPtr < 0) return false; // there is no potential names
+		
+		// remove null
+		int j = -1;
+		for (int i = 0; i <= pvnsPtr; i++) {
+			if (pvns[i] != null) {
+				char[] temp = pvns[i];
+				pvns[i] = null;
+				pvns[++j] = temp;
+				pvnss[j] = pvnss[i];
+				
+			}
+		}
+		pvnsPtr = j;
+		
+		if (pvnsPtr < 0) return false; // there is no potential names
+		
+		if (pvnsPtr > 0) {
+			// sort by position
+			quickSort(pvnss, pvns, 0, pvnsPtr);
+			
+			// remove double
+			j = 0;
+			for (int i = 1; i <= pvnsPtr; i++) {
+				if (pvnss[i] != pvnss[j]) {
+					char[] temp = pvns[i];
+					pvns[i] = null;
+					pvns[++j] = temp;
+					pvnss[j] = pvnss[i];
+				} else {
+					pvns[i] = null;
+				}
+			}
+			
+			pvnsPtr = j;
+		}
+		
+		this.potentialVariableNames = pvns;
+		this.potentialVariableNameStarts = pvnss;
+		this.potentialVariableNamesPtr = pvnsPtr;
+		
+		return true;
+	}
+	
+	private static void quickSort(int[] list1, char[][] list2, int left, int right) {
+		int original_left= left;
+		int original_right= right;
+		int mid= list1[(left + right) / 2];
+		do {
+			while (list1[left] < mid) {
+				left++;
+			}
+			while (mid < list1[right]) {
+				right--;
+			}
+			if (left <= right) {
+				int tmp1= list1[left];
+				list1[left]= list1[right];
+				list1[right]= tmp1;
+				
+				char[] tmp2= list2[left];
+				list2[left]= list2[right];
+				list2[right]= tmp2;
+				
+				left++;
+				right--;
+			}
+		} while (left <= right);
+		if (original_left < right) {
+			quickSort(list1, list2, original_left, right);
+		}
+		if (left < original_right) {
+			quickSort(list1, list2, left, original_right);
+		}
+	}
+	
 	private void popParent() {
 		this.parentsPtr--;
 	}
 	private void pushParent(ASTNode parent) {
-		int length = this.parentsz.length;
+		int length = this.parents.length;
 		if (this.parentsPtr >= length - 1) {
-			System.arraycopy(this.parentsz, 0, this.parentsz = new ASTNode[length * 2], 0, length);
+			System.arraycopy(this.parents, 0, this.parents = new ASTNode[length * 2], 0, length);
 		}
-		this.parentsz[++this.parentsPtr] = parent;
+		this.parents[++this.parentsPtr] = parent;
 	}
 	
 	private ASTNode getEnclosingDeclaration() {
 		int i = this.parentsPtr;
 		while (i > -1) {
-			ASTNode parent = parentsz[i];
+			ASTNode parent = parents[i];
 			if (parent instanceof AbstractMethodDeclaration) {
 				return parent;
 			} else if (parent instanceof Initializer) {
@@ -234,27 +328,109 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		popParent();
 	}
 	
-	private void endVisitPreserved(int start, int end) {
-		for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
-			char[] name = this.potentialVariableNames[i];
-			if (name != null) {
-				int nameStart = this.potentialVariableNameStarts[i];
-				if (start < nameStart && nameStart < end) {
-					this.potentialVariableNames[i] = null;
-					this.acceptName(name);
+	private int indexOfFisrtNameAfter(int position) {
+		int left = 0;
+		int right = this.potentialVariableNamesPtr;
+		
+		next : while (true) {
+			if (right < left) return -1;
+			
+			int mid = (left + right) / 2;
+			int midPosition = this.potentialVariableNameStarts[mid];
+			if (midPosition < 0) {
+				int nextMid = indexOfNextName(mid);
+				if (nextMid < 0 || right < nextMid) { // no next index or next index is after 'right'
+					right = mid - 1;
+					continue next;
+				}
+				mid = nextMid;
+				midPosition = this.potentialVariableNameStarts[nextMid];
+				
+				if (mid == right) { // mid and right are at the same index, we must move 'left'
+					int leftPosition = this.potentialVariableNameStarts[left];
+					if (leftPosition < 0 || leftPosition < position) { // 'left' is empty or 'left' is before the position
+						int nextLeft = indexOfNextName(left);
+						if (nextLeft < 0) return - 1;
+						
+						left = nextLeft;
+						continue next;
+					}
+					
+					return left;
+				}
+			}
+			
+			if (left != right) {
+				if (midPosition < position) {
+					left = mid + 1;
+				} else {
+					right = mid;
 				}
+			} else {
+				if (midPosition < position) {
+					return -1;
+				}
+				return mid;
 			}
 		}
 	}
 	
+	private int indexOfNextName(int index) {
+		int nextIndex = index + 1;
+		while (nextIndex <= this.potentialVariableNamesPtr &&
+				this.potentialVariableNames[nextIndex] == null) {
+			int jumpIndex = -this.potentialVariableNameStarts[nextIndex];
+			if (jumpIndex > 0) {
+				nextIndex = jumpIndex;
+			} else {
+				nextIndex++;
+			}
+		}
+		
+		if (this.potentialVariableNamesPtr < nextIndex) {
+			this.potentialVariableNamesPtr = index;
+			return -1;
+		}
+		if (index + 1 < nextIndex) {
+			this.potentialVariableNameStarts[index + 1] = -nextIndex;
+		}
+		return nextIndex;
+	}
+	
+	private void removeNameAt(int index) {
+		this.potentialVariableNames[index] = null;
+		int nextIndex = indexOfNextName(index);
+		if (nextIndex != -1) {
+			this.potentialVariableNameStarts[index] = -nextIndex;
+		} else {
+			this.potentialVariableNamesPtr = index - 1;
+		}
+	}
+	
+	private void endVisitPreserved(int start, int end) {
+		int i = indexOfFisrtNameAfter(start);
+		done : while (i != -1) {
+			int nameStart = this.potentialVariableNameStarts[i];
+			if (start < nameStart && nameStart < end) {
+				this.acceptName(this.potentialVariableNames[i]);
+				this.removeNameAt(i);
+			}
+			
+			if (end < nameStart) break done;
+			i = indexOfNextName(i);
+		}
+	}
+
 	private void endVisitRemoved(int start, int end) {
-		for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
-			if (this.potentialVariableNames[i] != null) {
-				int nameStart = this.potentialVariableNameStarts[i];
-				if (start < nameStart && nameStart < end) {
-					this.potentialVariableNames[i] = null;
-				}
+		int i = indexOfFisrtNameAfter(start);
+		done : while (i != -1) {
+			int nameStart = this.potentialVariableNameStarts[i];
+			if (start < nameStart && nameStart < end) {
+				this.removeNameAt(i);
 			}
+			
+			if (end < nameStart) break done;
+			i = indexOfNextName(i);
 		}
 	}
 	
@@ -262,17 +438,18 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		if (statements != null) {
 			for (int i = 0; i < statements.length; i++) {
 				if (statements[i] instanceof LocalDeclaration) {
-					LocalDeclaration localDeclaration = (LocalDeclaration) statements[i];
-					for (int j = 0; j <= this.potentialVariableNamesPtr; j++) {
-						char[] name = this.potentialVariableNames[j];
-						if (name != null) {
-							int nameStart = this.potentialVariableNameStarts[j];
-							if(start <= nameStart && nameStart <= end) {
-								if (CharOperation.equals(name, localDeclaration.name, false)) {
-									this.potentialVariableNames[j] = null;
-								}
+					LocalDeclaration localDeclaration = (LocalDeclaration) statements[i];					
+					int j = indexOfFisrtNameAfter(start);
+					done : while (j != -1) {
+						int nameStart = this.potentialVariableNameStarts[j];
+						if (start <= nameStart && nameStart <= end) {
+							if (CharOperation.equals(this.potentialVariableNames[j], localDeclaration.name, false)) {
+								this.removeNameAt(j);
 							}
 						}
+						
+						if (end < nameStart) break done;
+						j = indexOfNextName(j);
 					}
 				}
 			}
@@ -281,20 +458,23 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	}
 	
 	private void removeFields(TypeDeclaration typeDeclaration) {
+		int start = typeDeclaration.declarationSourceStart;
+		int end = typeDeclaration.declarationSourceEnd;
+		
 		FieldDeclaration[] fieldDeclarations = typeDeclaration.fields;
 		if (fieldDeclarations != null) {
 			for (int i = 0; i < fieldDeclarations.length; i++) {
-				for (int j = 0; j <= this.potentialVariableNamesPtr; j++) {
-					char[] name = this.potentialVariableNames[j];
-					if (name != null) {
-						int nameStart = this.potentialVariableNameStarts[j];
-						if(typeDeclaration.declarationSourceStart <= nameStart &&
-								nameStart <= typeDeclaration.declarationSourceEnd) {
-							if (CharOperation.equals(name, fieldDeclarations[i].name, false)) {
-								this.potentialVariableNames[j] = null;
-							}
+				int j = indexOfFisrtNameAfter(start);
+				done : while (j != -1) {
+					int nameStart = this.potentialVariableNameStarts[j];
+					if (start <= nameStart && nameStart <= end) {
+						if (CharOperation.equals(this.potentialVariableNames[j], fieldDeclarations[i].name, false)) {
+							this.removeNameAt(j);
 						}
 					}
+					
+					if (end < nameStart) break done;
+					j = indexOfNextName(j);
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 0f7b5ce..feeef43 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -3699,6 +3699,14 @@ private void pushCompletionOnMemberAccessOnExpressionStack(boolean isSuperAccess
 		expressionStack[expressionPtr] = fr;
 	}
 }
+protected boolean moveRecoveryCheckpoint() {
+	CompletionScanner completionScanner = (CompletionScanner) this.scanner;
+	if (completionScanner.record) {
+		completionScanner.currentToken = -1;
+		completionScanner.currentTokenStart = 0;
+	}
+	return super.moveRecoveryCheckpoint();
+}
 public void recordCompletionOnReference(){
 
 	if (currentElement instanceof RecoveredType){
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
index b083ed5..add2a3b 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
@@ -40,10 +40,10 @@ public class CompletionScanner extends Scanner {
 
 	public static final char[] EmptyCompletionIdentifier = {};
 	
-	private boolean record = false;
+	public boolean record = false;
 	public char[] prefix;
-	private int currentToken;
-	private int currentTokenStart;
+	public int currentToken;
+	public int currentTokenStart;
 	public int potentialVariableNamesPtr; 
 	public char[][] potentialVariableNames;
 	public int[] potentialVariableNameStarts;
@@ -871,6 +871,13 @@ public void removePotentialNamesAt(int position) {
 		}
 	}
 }
+public void resetTo(int begin, int end) {
+	if (this.record) {
+		this.currentToken = -1;
+		this.currentTokenStart = 0;
+	}
+	super.resetTo(begin, end);
+}
 ///*
 // * In case we actually read a keyword, but the cursor is located inside,
 // * we pretend we read an identifier.
