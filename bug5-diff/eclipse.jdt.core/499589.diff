commit 1725710ebecc1e82db190ecf9469ee8dcfd38b44
Author: Till Brychcy <register.eclipse@brychcy.de>
Date:   Sat Aug 13 10:37:39 2016 +0200

    Bug 499589 - [null][1.8] Implement DefaultLocation.ARRAY_CONTENTS
    
    Change-Id: I046d83d390a456ffb3beee2c99043702fe3c392f
    Also-By: Stephan Herrmann <stephan.herrmann@berlin.de>

767	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
75	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
46	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ExternalAnnotationSuperimposer.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 64e800d..1811432 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -14225,6 +14225,773 @@ public void testBug490403typeArgAnnotationMismatch() {
 		"----------\n"
 	);
 }
+public void testBug499589() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void a(String[] array) {\n" +
+			"		x(array[0]); // <----- bogus warning\n" +
+			"	}\n" +
+			"\n" +
+			"	static void x(String s) {\n" +
+			"		System.out.println(s);\n" +
+			"	}\n" +
+			"\n" +
+			"	static void b(String[][] array) {\n" +
+			"		y(array[0]); // <----- bogus warning\n" +
+			"	}\n" +
+			"\n" +
+			"	static void y(String[] s) {\n" +
+			"		System.out.println(s[0]);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
+public void testBug499589multidim() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void foo(String[] @Nullable [] array) {\n" +
+			"		x(array[0]);\n" +
+			"	}\n" +
+			"	static void x(String[] s) {\n" +
+			"		System.out.println(s[0]);\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BogusWarning.java (at line 11)\n" + 
+		"	x(array[0]);\n" + 
+		"	  ^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[]\' but this expression has type \'@NonNull String @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+
+public void testBug499589leafTypeNullable() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void foo(@Nullable String[] array) {\n" +
+			"		x(array[0]);\n" +
+			"	}\n" +
+			"\n" +
+			"	static void x(String s) {\n" +
+			"		System.out.println(s);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BogusWarning.java (at line 11)\n" + 
+		"	x(array[0]);\n" + 
+		"	  ^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String\' but this expression has type \'@Nullable String\'\n" + 
+		"----------\n"
+	);
+}
+
+public void testBug499589qualified() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void foo(java.lang.String[] array) {\n" +
+			"		x(array[0]);\n" +
+			"	}\n" +
+			"\n" +
+			"	static void x(String s) {\n" +
+			"		System.out.println(s);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
+
+public void testBug499589qualified_leafTypeNullable() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void foo(java.lang.@Nullable String[] array) {\n" +
+			"		x(array[0]);\n" +
+			"	}\n" +
+			"\n" +
+			"	static void x(String s) {\n" +
+			"		System.out.println(s);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BogusWarning.java (at line 11)\n" + 
+		"	x(array[0]);\n" + 
+		"	  ^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String\' but this expression has type \'@Nullable String\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589qualified_multidim() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BogusWarning.java",
+			"package test;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"\n" +
+			"@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })\n" +
+			"class BogusWarning {\n" +
+			"	static void foo(java.lang.String[] @Nullable [] array) {\n" +
+			"		x(array[0]);\n" +
+			"	}\n" +
+			"	static void x(java.lang.String[] s) {\n" +
+			"		System.out.println(s[0]);\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BogusWarning.java (at line 11)\n" + 
+		"	x(array[0]);\n" + 
+		"	  ^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[]\' but this expression has type \'@NonNull String @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589STB() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/Ref.java",
+			"package test;\n" +
+			"\n" +
+			"public class Ref<T> {\n" +
+			"	T get() {\n" +
+			"		throw new RuntimeException();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/X.java",
+			"package test;\n" +
+			"\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.*;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"@SuppressWarnings({ \"unchecked\" })\n" +
+			"@NonNullByDefault({ FIELD, RETURN_TYPE, PARAMETER, ARRAY_CONTENTS, TYPE_ARGUMENT })\n" +
+			"public abstract class X {\n" +
+			"	public final String[][] field = {};\n" +
+			"	public final @Nullable String[][] fieldWithNullable1 = {};\n" +
+			"	public final String[] @Nullable [] fieldWithNullable2 = {};\n" +
+			"\n" +
+			"	public final Ref<String[][]> list = new Ref<>();\n" +
+			"	public final Ref<@Nullable String[][]> listWithNullable1 = new Ref<>();\n" +
+			"	public final Ref<String[] @Nullable []> listWithNullable2 = new Ref<>();\n" +
+			"\n" +
+			"	public abstract String[][] method();\n" +
+			"	public abstract @Nullable String[][] methodWithNullable1();\n" +
+			"	public abstract String[] @Nullable [] methodWithNullable2();\n" +
+			"\n" +
+			"	public final Ref<String[][]>[][] genericField = new Ref[0][];\n" +
+			"	public final @Nullable Ref<@Nullable String[][]>[][] genericFieldWithNullable1 = new Ref[0][];\n" +
+			"	public final Ref<String[] @Nullable []>[] @Nullable [] genericFieldWithNullable2 = new Ref[0][];\n" +
+			"}\n" +
+			"\n" +
+			"class SourceUsage {\n" +
+			"	void check(@NonNull String @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void checkGeneric(@NonNull Ref<@NonNull String @NonNull [] @NonNull []> @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void f(X x) {\n" +
+			"		check(x.field);\n" +
+			"		check(x.fieldWithNullable1);\n" +
+			"		check(x.fieldWithNullable2);\n" +
+			"		check(x.list.get());\n" +
+			"		check(x.listWithNullable1.get());\n" +
+			"		check(x.listWithNullable2.get());\n" +
+			"		check(x.method());\n" +
+			"		check(x.methodWithNullable1());\n" +
+			"		check(x.methodWithNullable2());\n" +
+			"		checkGeneric(x.genericField);\n" +
+			"		checkGeneric(x.genericFieldWithNullable1);\n" +
+			"		checkGeneric(x.genericFieldWithNullable2);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\X.java (at line 36)\n" + 
+		"	check(x.fieldWithNullable1);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\X.java (at line 37)\n" + 
+		"	check(x.fieldWithNullable2);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\X.java (at line 39)\n" + 
+		"	check(x.listWithNullable1.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\X.java (at line 40)\n" + 
+		"	check(x.listWithNullable2.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\X.java (at line 42)\n" + 
+		"	check(x.methodWithNullable1());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\X.java (at line 43)\n" + 
+		"	check(x.methodWithNullable2());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\X.java (at line 45)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable1);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<@NonNull String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@Nullable Ref<@Nullable String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\X.java (at line 46)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable2);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<@NonNull String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@NonNull Ref<@NonNull String @NonNull[] @Nullable[]> @NonNull[] @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589BTB() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/Ref.java",
+			"package test;\n" +
+			"\n" +
+			"public class Ref<T> {\n" +
+			"	T get() {\n" +
+			"		throw new RuntimeException();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/X.java",
+			"package test;\n" +
+			"\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.FIELD;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.PARAMETER;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.RETURN_TYPE;\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.TYPE_ARGUMENT;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"@SuppressWarnings({ \"unchecked\" })\n" +
+			"@NonNullByDefault({ FIELD, RETURN_TYPE, PARAMETER, ARRAY_CONTENTS, TYPE_ARGUMENT })\n" +
+			"public abstract class X {\n" +
+			"	public final String[][] field = {};\n" +
+			"	public final @Nullable String[][] fieldWithNullable1 = {};\n" +
+			"	public final String[] @Nullable [] fieldWithNullable2 = {};\n" +
+			"\n" +
+			"	public final Ref<String[][]> list = new Ref<>();\n" +
+			"	public final Ref<@Nullable String[][]> listWithNullable1 = new Ref<>();\n" +
+			"	public final Ref<String[] @Nullable []> listWithNullable2 = new Ref<>();\n" +
+			"\n" +
+			"	public abstract String[][] method();\n" +
+			"	public abstract @Nullable String[][] methodWithNullable1();\n" +
+			"	public abstract String[] @Nullable [] methodWithNullable2();\n" +
+			"\n" +
+			"	public final Ref<String[][]>[][] genericField = new Ref[0][];\n" +
+			"	public final @Nullable Ref<@Nullable String[][]>[][] genericFieldWithNullable1 = new Ref[0][];\n" +
+			"	public final Ref<String[] @Nullable []>[] @Nullable [] genericFieldWithNullable2 = new Ref[0][];\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BinaryUsage.java",
+			"package test;\n" +
+			"\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"\n" +
+			"class BinaryUsage {\n" +
+			"	void check(@NonNull String @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void checkGeneric(@NonNull Ref<@NonNull String @NonNull [] @NonNull []> @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void f(X x) {\n" +
+			"		check(x.field);\n" +
+			"		check(x.fieldWithNullable1);\n" +
+			"		check(x.fieldWithNullable2);\n" +
+			"		check(x.list.get());\n" +
+			"		check(x.listWithNullable1.get());\n" +
+			"		check(x.listWithNullable2.get());\n" +
+			"		check(x.method());\n" +
+			"		check(x.methodWithNullable1());\n" +
+			"		check(x.methodWithNullable2());\n" +
+			"		checkGeneric(x.genericField);\n" +
+			"		checkGeneric(x.genericFieldWithNullable1);\n" +
+			"		checkGeneric(x.genericFieldWithNullable2);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BinaryUsage.java (at line 15)\n" + 
+		"	check(x.fieldWithNullable1);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\BinaryUsage.java (at line 16)\n" + 
+		"	check(x.fieldWithNullable2);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\BinaryUsage.java (at line 18)\n" + 
+		"	check(x.listWithNullable1.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\BinaryUsage.java (at line 19)\n" + 
+		"	check(x.listWithNullable2.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\BinaryUsage.java (at line 21)\n" + 
+		"	check(x.methodWithNullable1());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@Nullable String @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\BinaryUsage.java (at line 22)\n" + 
+		"	check(x.methodWithNullable2());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull String @NonNull[] @NonNull[]\' but this expression has type \'@NonNull String @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\BinaryUsage.java (at line 24)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable1);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<@NonNull String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@Nullable Ref<@Nullable String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\BinaryUsage.java (at line 25)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable2);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<@NonNull String @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@NonNull Ref<@NonNull String @NonNull[] @Nullable[]> @NonNull[] @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+
+public void testBug499589STBqualified() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/Ref.java",
+			"package test;\n" +
+			"\n" +
+			"public class Ref<T> {\n" +
+			"	T get() {\n" +
+			"		throw new RuntimeException();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/A.java",
+			"package test;\n" +
+			"\n" +
+			"public class A {\n" +
+			"	class B {\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/X.java",
+			"package test;\n" +
+			"\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.*;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"@SuppressWarnings({ \"unchecked\" })\n" +
+			"@NonNullByDefault({ FIELD, RETURN_TYPE, PARAMETER, ARRAY_CONTENTS, TYPE_ARGUMENT })\n" +
+			"public abstract class X {\n" +
+			"	public final test.A.B[][] field = {};\n" +
+			"	public final test.A.@Nullable B[][] fieldWithNullable1 = {};\n" +
+			"	public final test.A.B[] @Nullable [] fieldWithNullable2 = {};\n" +
+			"\n" +
+			"	public final test.Ref<test.A.B[][]> list = new Ref<>();\n" +
+			"	public final test.Ref<test.A.@Nullable B[][]> listWithNullable1 = new Ref<>();\n" +
+			"	public final test.Ref<test.A.B[] @Nullable []> listWithNullable2 = new Ref<>();\n" +
+			"\n" +
+			"	public abstract test.A.B[][] method();\n" +
+			"	public abstract test.A.@Nullable B[][] methodWithNullable1();\n" +
+			"	public abstract test.A.B[] @Nullable [] methodWithNullable2();\n" +
+			"\n" +
+			"	public final test.Ref<test.A.B[][]>[][] genericField = new Ref[0][];\n" +
+			"	public final test.@Nullable Ref<test.A.@Nullable B[][]>[][] genericFieldWithNullable1 = new Ref[0][];;\n" +
+			"	public final test.Ref<test.A.B[] @Nullable []>[] @Nullable[] genericFieldWithNullable2 = new Ref[0][];;\n" +
+			"}\n" +
+			"\n" +
+			"class SourceUsage {\n" +
+			"	void check(test.A.@NonNull B @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"	void checkGeneric(test.@NonNull Ref<test.A.@NonNull B @NonNull [] @NonNull []> @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void f(X x) {\n" +
+			"		check(x.field);\n" +
+			"		check(x.fieldWithNullable1);\n" +
+			"		check(x.fieldWithNullable2);\n" +
+			"		check(x.list.get());\n" +
+			"		check(x.listWithNullable1.get());\n" +
+			"		check(x.listWithNullable2.get());\n" +
+			"		check(x.method());\n" +
+			"		check(x.methodWithNullable1());\n" +
+			"		check(x.methodWithNullable2());\n" +
+			"		checkGeneric(x.genericField);\n" +
+			"		checkGeneric(x.genericFieldWithNullable1);\n" +
+			"		checkGeneric(x.genericFieldWithNullable2);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\X.java (at line 35)\n" + 
+		"	check(x.fieldWithNullable1);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\X.java (at line 36)\n" + 
+		"	check(x.fieldWithNullable2);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\X.java (at line 38)\n" + 
+		"	check(x.listWithNullable1.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\X.java (at line 39)\n" + 
+		"	check(x.listWithNullable2.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\X.java (at line 41)\n" + 
+		"	check(x.methodWithNullable1());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\X.java (at line 42)\n" + 
+		"	check(x.methodWithNullable2());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\X.java (at line 44)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable1);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<A.@NonNull B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@Nullable Ref<A.@Nullable B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\X.java (at line 45)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable2);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<A.@NonNull B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@NonNull Ref<A.@NonNull B @NonNull[] @Nullable[]> @NonNull[] @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589BTBqualified() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/Ref.java",
+			"package test;\n" +
+			"\n" +
+			"public class Ref<T> {\n" +
+			"	T get() {\n" +
+			"		throw new RuntimeException();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/A.java",
+			"package test;\n" +
+			"\n" +
+			"public class A {\n" +
+			"	class B {\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"test/X.java",
+			"package test;\n" +
+			"\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.*;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"@SuppressWarnings({ \"unchecked\" })\n" +
+			"@NonNullByDefault({ FIELD, RETURN_TYPE, PARAMETER, ARRAY_CONTENTS, TYPE_ARGUMENT })\n" +
+			"public abstract class X {\n" +
+			"	public final test.A.B[][] field = {};\n" +
+			"	public final test.A.@Nullable B[][] fieldWithNullable1 = {};\n" +
+			"	public final test.A.B[] @Nullable [] fieldWithNullable2 = {};\n" +
+			"\n" +
+			"	public final test.Ref<test.A.B[][]> list = new Ref<>();\n" +
+			"	public final test.Ref<test.A.@Nullable B[][]> listWithNullable1 = new Ref<>();\n" +
+			"	public final test.Ref<test.A.B[] @Nullable []> listWithNullable2 = new Ref<>();\n" +
+			"\n" +
+			"	public abstract test.A.B[][] method();\n" +
+			"	public abstract test.A.@Nullable B[][] methodWithNullable1();\n" +
+			"	public abstract test.A.B[] @Nullable [] methodWithNullable2();\n" +
+			"\n" +
+			"	public final test.Ref<test.A.B[][]>[][] genericField = new Ref[0][];\n" +
+			"	public final test.@Nullable Ref<test.A.@Nullable B[][]>[][] genericFieldWithNullable1 = new Ref[0][];;\n" +
+			"	public final test.Ref<test.A.B[] @Nullable []>[] @Nullable[] genericFieldWithNullable2 = new Ref[0][];;\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/BinaryUsage.java",
+			"package test;\n" +
+			"\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"\n" +
+			"class BinaryUsage {\n" +
+			"	void check(test.A.@NonNull B @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"	void checkGeneric(test.@NonNull Ref<test.A.@NonNull B @NonNull [] @NonNull []> @NonNull [] @NonNull [] s) {\n" +
+			"	}\n" +
+			"\n" +
+			"	void f(X x) {\n" +
+			"		check(x.field);\n" +
+			"		check(x.fieldWithNullable1);\n" +
+			"		check(x.fieldWithNullable2);\n" +
+			"		check(x.list.get());\n" +
+			"		check(x.listWithNullable1.get());\n" +
+			"		check(x.listWithNullable2.get());\n" +
+			"		check(x.method());\n" +
+			"		check(x.methodWithNullable1());\n" +
+			"		check(x.methodWithNullable2());\n" +
+			"		checkGeneric(x.genericField);\n" +
+			"		checkGeneric(x.genericFieldWithNullable1);\n" +
+			"		checkGeneric(x.genericFieldWithNullable2);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\BinaryUsage.java (at line 14)\n" + 
+		"	check(x.fieldWithNullable1);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\BinaryUsage.java (at line 15)\n" + 
+		"	check(x.fieldWithNullable2);\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\BinaryUsage.java (at line 17)\n" + 
+		"	check(x.listWithNullable1.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\BinaryUsage.java (at line 18)\n" + 
+		"	check(x.listWithNullable2.get());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\BinaryUsage.java (at line 20)\n" + 
+		"	check(x.methodWithNullable1());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@Nullable B @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\BinaryUsage.java (at line 21)\n" + 
+		"	check(x.methodWithNullable2());\n" + 
+		"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'A.@NonNull B @NonNull[] @NonNull[]\' but this expression has type \'A.@NonNull B @NonNull[] @Nullable[]\'\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\BinaryUsage.java (at line 23)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable1);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<A.@NonNull B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@Nullable Ref<A.@Nullable B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\'\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\BinaryUsage.java (at line 24)\n" + 
+		"	checkGeneric(x.genericFieldWithNullable2);\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Ref<A.@NonNull B @NonNull[] @NonNull[]> @NonNull[] @NonNull[]\' but this expression has type \'@NonNull Ref<A.@NonNull B @NonNull[] @Nullable[]> @NonNull[] @Nullable[]\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589arrayAllocation() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/ArrayAllocation.java",
+			"package test;\n" +
+			"\n" +
+			"import static org.eclipse.jdt.annotation.DefaultLocation.ARRAY_CONTENTS;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"@NonNullByDefault({ ARRAY_CONTENTS })\n" +
+			"public class ArrayAllocation {\n" +
+			"	public Integer[] x1 = { 1, 2, 3, null };\n" +
+			"	public Integer[] x2 = new Integer[] { 1, 2, 3 };\n" +
+			"	public Integer[] x3 = new Integer[] { 1, 2, 3, null };\n" +
+			"	public Integer[] x4 = new Integer[3];\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\ArrayAllocation.java (at line 9)\n" + 
+		"	public Integer[] x1 = { 1, 2, 3, null };\n" + 
+		"	                                 ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Integer\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\ArrayAllocation.java (at line 11)\n" + 
+		"	public Integer[] x3 = new Integer[] { 1, 2, 3, null };\n" + 
+		"	                                               ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Integer\' but the provided value is null\n" + 
+		"----------\n" + 
+		"3. WARNING in test\\ArrayAllocation.java (at line 12)\n" + 
+		"	public Integer[] x4 = new Integer[3];\n" + 
+		"	                      ^^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'Integer[]\' needs unchecked conversion to conform to \'@NonNull Integer []\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug499589generics() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/Methods.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.DefaultLocation;\n" +
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"\n" +
+			"@org.eclipse.jdt.annotation.NonNullByDefault({ DefaultLocation.TYPE_ARGUMENT, DefaultLocation.ARRAY_CONTENTS })\n" +
+			"public class Methods {\n" +
+			"	static interface List<T> {\n" +
+			"		T get(int i);\n" +
+			"	}\n" +
+			"\n" +
+			"	public static List<String> f0(List<String> list) {\n" +
+			"		@NonNull\n" +
+			"		Object o = list.get(0);\n" +
+			"		return list;\n" +
+			"	}\n" +
+			"\n" +
+			"	public static String[] f1(String[] array) {\n" +
+			"		@NonNull\n" +
+			"		Object o = array[0];\n" +
+			"		return array;\n" +
+			"	}\n" +
+			"\n" +
+			"	public static <T> List<T> g0(List<T> list) {\n" +
+			"		@NonNull\n" +
+			"		Object o = list.get(0); // problem\n" +
+			"		return list;\n" +
+			"	}\n" +
+			"\n" +
+			"	public static <T> T[] g1(T[] array) {\n" +
+			"		@NonNull\n" +
+			"		Object o = array[0]; // problem\n" +
+			"		return array;\n" +
+			"	}\n" +
+			"\n" +
+			"	public static <@NonNull T> List<@NonNull T> h0(List<T> list) {\n" +
+			"		@NonNull\n" +
+			"		Object o = list.get(0);\n" +
+			"		return list;\n" +
+			"	}\n" +
+			"\n" +
+			"	public static <@NonNull T> @NonNull T[] h1(T[] array) {\n" +
+			"		@NonNull\n" +
+			"		Object o = array[0];\n" +
+			"		return array;\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\Methods.java (at line 26)\n" + 
+		"	Object o = list.get(0); // problem\n" + 
+		"	           ^^^^^^^^^^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\Methods.java (at line 32)\n" + 
+		"	Object o = array[0]; // problem\n" + 
+		"	           ^^^^^^^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
 public void testBug511723() {
 	runNegativeTestWithLibs(
 		new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 496a5dc..856a911 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -1089,6 +1089,14 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		
 		// for arrays: @T X[] SE7 associates @T to the type, but in SE8 it affects the leaf component type
 		TypeBinding oldLeafType = (unionRef == null) ? existingType.leafComponentType() : unionRef.resolvedType;
+		if (se8nullBits != 0) {
+			if (typeRef instanceof ArrayTypeReference) { // NOTE: no corresponding code for ArrayQualifiedTypeReference is necessary
+				ArrayTypeReference arrayTypeReference = (ArrayTypeReference) typeRef;
+				if(arrayTypeReference.leafComponentTypeWithoutDefaultNullness != null) {
+					oldLeafType=arrayTypeReference.leafComponentTypeWithoutDefaultNullness;
+				}
+			}
+		}
 		if (se8nullBits != 0 && oldLeafType.isBaseType()) {
 			scope.problemReporter().illegalAnnotationForBaseType(typeRef, new Annotation[] { se8NullAnnotation }, se8nullBits);
 			return existingType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index 656c770..a2b32ec 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -192,6 +192,7 @@ public class ArrayAllocationExpression extends Expression {
 
 			// check the initializer
 			if (this.initializer != null) {
+				this.resolvedType = ArrayTypeReference.maybeMarkArrayContentsNonNull(scope, this.resolvedType, this.sourceStart, this.dimensions.length, null);
 				if ((this.initializer.resolveTypeExpecting(scope, this.resolvedType)) != null)
 					this.initializer.binding = (ArrayBinding)this.resolvedType;
 			}
@@ -202,7 +203,6 @@ public class ArrayAllocationExpression extends Expression {
 		return this.resolvedType;
 	}
 
-
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
 		if (visitor.visit(this, scope)) {
 			int dimensionsLength = this.dimensions.length;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
index 8176963..ecd1613 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -105,6 +105,8 @@ public class ArrayQualifiedTypeReference extends QualifiedTypeReference {
 
 	protected TypeBinding internalResolveType(Scope scope, int location) {
 		TypeBinding internalResolveType = super.internalResolveType(scope, location);
+		internalResolveType = ArrayTypeReference.maybeMarkArrayContentsNonNull(scope, internalResolveType, this.sourceStart, this.dimensions, null);
+
 		return internalResolveType;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
index 4de0c4a..9594247 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,18 +14,26 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.function.Consumer;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
 public class ArrayTypeReference extends SingleTypeReference {
 	public int dimensions;
 	private Annotation[][] annotationsOnDimensions; // jsr308 style type annotations on dimensions.
 	public int originalSourceEnd;
 	public int extendedDimensions;
+	public TypeBinding leafComponentTypeWithoutDefaultNullness;
 
 	/**
 	 * ArrayTypeReference constructor comment.
@@ -179,8 +187,74 @@ public class ArrayTypeReference extends SingleTypeReference {
 
 	protected TypeBinding internalResolveType(Scope scope, int location) {
 		TypeBinding internalResolveType = super.internalResolveType(scope, location);
+		internalResolveType = maybeMarkArrayContentsNonNull(scope, internalResolveType, this.sourceStart, this.dimensions,
+									leafType -> this.leafComponentTypeWithoutDefaultNullness = leafType);
+
 		return internalResolveType;
 	}
+
+	static TypeBinding maybeMarkArrayContentsNonNull(Scope scope, TypeBinding typeBinding, int sourceStart, int dimensions, Consumer<TypeBinding> leafConsumer) {
+		LookupEnvironment environment = scope.environment();
+		if (environment.usesNullTypeAnnotations()
+				&& scope.hasDefaultNullnessFor(Binding.DefaultLocationArrayContents, sourceStart)) {
+			AnnotationBinding nonNullAnnotation = environment.getNonNullAnnotation();
+			typeBinding = addNonNullToDimensions(scope, typeBinding, nonNullAnnotation, dimensions);
+
+			TypeBinding leafComponentType = typeBinding.leafComponentType();
+			if ((leafComponentType.tagBits & TagBits.AnnotationNullMASK) == 0 && leafComponentType.acceptsNonNullDefault()) {
+				if (leafConsumer != null)
+					leafConsumer.accept(leafComponentType);
+				TypeBinding nonNullLeafComponentType = scope.environment().createAnnotatedType(leafComponentType,
+						new AnnotationBinding[] { nonNullAnnotation });
+				typeBinding = scope.createArrayType(nonNullLeafComponentType, typeBinding.dimensions(),
+						typeBinding.getTypeAnnotations());
+			}
+		}
+		return typeBinding;
+	}
+
+	static TypeBinding addNonNullToDimensions(Scope scope, TypeBinding typeBinding,
+			AnnotationBinding nonNullAnnotation, int dimensions2) {
+		AnnotationBinding[][] newAnnots = new AnnotationBinding[dimensions2][];
+		AnnotationBinding[] oldAnnots = typeBinding.getTypeAnnotations();
+		if (oldAnnots == null) {
+			for (int i = 1; i < dimensions2; i++) {
+				newAnnots[i] = new AnnotationBinding[] { nonNullAnnotation };
+			}
+		} else {
+			int j = 0;
+			for (int i = 0; i < dimensions2; i++) {
+				if (j >= oldAnnots.length || oldAnnots[j] == null) {
+					if (i != 0) {
+						newAnnots[i] = new AnnotationBinding[] { nonNullAnnotation };
+					}
+					j++;
+				} else {
+					int k = j;
+					boolean seen = false;
+					while (oldAnnots[k] != null) {
+						seen |= oldAnnots[k].getAnnotationType()
+								.hasNullBit(TypeIds.BitNonNullAnnotation | TypeIds.BitNullableAnnotation);
+						k++;
+					}
+					if (seen || i == 0) {
+						if (k > j) {
+							AnnotationBinding[] annotationsForDimension = new AnnotationBinding[k - j];
+							System.arraycopy(oldAnnots, j, annotationsForDimension, 0, k - j);
+							newAnnots[i] = annotationsForDimension;
+						}
+					} else {
+						AnnotationBinding[] annotationsForDimension = new AnnotationBinding[k - j + 1];
+						annotationsForDimension[0] = nonNullAnnotation;
+						System.arraycopy(oldAnnots, j, annotationsForDimension, 1, k - j);
+						newAnnots[i] = annotationsForDimension;
+					}
+					j = k + 1;
+				}
+			}
+		}
+		return scope.environment().createAnnotatedType(typeBinding, newAnnots);
+	}
 	
 	@Override
 	public boolean hasNullTypeAnnotation(AnnotationPosition position) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index c23ab21..a210240 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -200,6 +200,10 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		TypeBinding type = internalResolveLeafType(scope, checkBounds);
 		createArrayType(scope);
 		resolveAnnotations(scope, location);
+		if(this.dimensions > 0) {
+			this.resolvedType = ArrayTypeReference.maybeMarkArrayContentsNonNull(scope, this.resolvedType, this.sourceStart, this.dimensions, null);
+		}
+
 		if (this.typeArguments != null)
 			// relevant null annotations are on the inner most type:
 			checkIllegalNullAnnotations(scope, this.typeArguments[this.typeArguments.length-1]);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 42bad6b..fc32e3d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -177,6 +177,10 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 			} else {
 				this.resolvedType = type; 			// (3) no complaint, keep fully resolved type (incl. dimensions)
 				resolveAnnotations(scope, location);
+				if(this.dimensions > 0) {
+					this.resolvedType = ArrayTypeReference.maybeMarkArrayContentsNonNull(scope, this.resolvedType, this.sourceStart, this.dimensions,
+																leafType -> this.leafComponentTypeWithoutDefaultNullness = leafType);
+				}
 				return this.resolvedType; // pick up any annotated type.
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index 7734b5a..4dffadf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -279,7 +279,7 @@ public class ExternalAnnotationProvider {
 		public ITypeAnnotationWalker toWildcardBound() { return this; }
 		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
 		public ITypeAnnotationWalker toNextNestedType() { return this; }
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) { return NO_ANNOTATIONS; }
 	}
 
 	abstract class BasicAnnotationWalker implements ITypeAnnotationWalker {
@@ -381,7 +381,7 @@ public class ExternalAnnotationProvider {
 		}
 
 		@Override
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) {
 			if (this.pos != -1 && this.pos < this.source.length-2) {
 				switch (this.source[this.pos]) {
 					case 'T':
@@ -534,7 +534,7 @@ public class ExternalAnnotationProvider {
 		}
 
 		@Override
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) {
 			if (this.pos != -1 && this.pos < this.source.length-1) {
 				switch (this.source[this.pos]) {
 					case NULLABLE:
@@ -543,7 +543,7 @@ public class ExternalAnnotationProvider {
 						return new IBinaryAnnotation[]{ ExternalAnnotationProvider.this.NONNULL_ANNOTATION };
 				}				
 			}
-			return super.getAnnotationsAtCursor(currentTypeId);
+			return super.getAnnotationsAtCursor(currentTypeId, mayApplyArrayContentsDefaultNullness);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
index cb13247..21e2d5a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2014, 2016 GK Software AG.
+ * Copyright (c) 2014, 2017 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -24,15 +24,19 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
  */
 public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalker {
 
-	private int defaultNullness;
-	private boolean atDefaultLocation;
+	private final int defaultNullness;
+	private final boolean atDefaultLocation;
+	private final boolean atTypeBound;
+	private final boolean currentArrayContentIsNonNull;
+	private final boolean isEmpty;
+	private final IBinaryAnnotation nonNullAnnotation;
+	private final LookupEnvironment environment;
+	
 	private boolean nextIsDefaultLocation;
-	private boolean atTypeBound;
 	private boolean nextIsTypeBound;
-	private boolean isEmpty;
-	IBinaryAnnotation nonNullAnnotation;
-	LookupEnvironment environment;
+	private boolean nextArrayContentIsNonNull;
 
+	
 	/** Create initial walker with non-empty type annotations. */
 	public NonNullDefaultAwareTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations,
 						int defaultNullness, LookupEnvironment environment) {
@@ -40,28 +44,34 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 		this.nonNullAnnotation = getNonNullAnnotation(environment);
 		this.defaultNullness = defaultNullness;
 		this.environment = environment;
+		this.atDefaultLocation = false;
+		this.atTypeBound = false;
+		this.isEmpty = false;
+		this.currentArrayContentIsNonNull = false;
 	}
 	
 	/** Create an initial walker without 'real' type annotations, but with a nonnull default. */
 	public NonNullDefaultAwareTypeAnnotationWalker(int defaultNullness, LookupEnvironment environment) {
-		this(defaultNullness, getNonNullAnnotation(environment), false, false, environment);
+		this(defaultNullness, getNonNullAnnotation(environment), false, false, environment, false);
 	}
 
 	/** Get restricted walker, still with non-empty type annotations. */
 	NonNullDefaultAwareTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long newMatches, int newPathPtr,
 						int defaultNullness, IBinaryAnnotation nonNullAnnotation, boolean atDefaultLocation, boolean atTypeBound,
-						LookupEnvironment environment) {
+						LookupEnvironment environment, boolean currentArrayContentIsNonNull) {
 		super(typeAnnotations, newMatches, newPathPtr);
 		this.defaultNullness = defaultNullness;
 		this.nonNullAnnotation = nonNullAnnotation;
 		this.atDefaultLocation = atDefaultLocation;
 		this.atTypeBound = atTypeBound;
 		this.environment = environment;
+		this.currentArrayContentIsNonNull = this.nextArrayContentIsNonNull = currentArrayContentIsNonNull;
+		this.isEmpty = false;
 	}
 
 	/** Create a restricted walker without 'real' type annotations, but with a nonnull default. */
 	NonNullDefaultAwareTypeAnnotationWalker(int defaultNullness, IBinaryAnnotation nonNullAnnotation,
-						boolean atDefaultLocation, boolean atTypeBound, LookupEnvironment environment) {
+						boolean atDefaultLocation, boolean atTypeBound, LookupEnvironment environment, boolean currentArrayContentIsNonNull) {
 		super(null, 0, 0);
 		this.nonNullAnnotation = nonNullAnnotation;
 		this.defaultNullness = defaultNullness;
@@ -69,6 +79,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 		this.atTypeBound = atTypeBound;
 		this.isEmpty = true;
 		this.environment = environment;
+		this.currentArrayContentIsNonNull = this.nextArrayContentIsNonNull = currentArrayContentIsNonNull;
 	}
 	
 	private static IBinaryAnnotation getNonNullAnnotation(LookupEnvironment environment) {
@@ -92,19 +103,20 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 		try {
 			// do we have any change at all?
 			if (this.matches == newMatches && this.pathPtr == newPathPtr
-					&& this.atDefaultLocation == this.nextIsDefaultLocation && this.atTypeBound == this.nextIsTypeBound)
+					&& this.atDefaultLocation == this.nextIsDefaultLocation && this.atTypeBound == this.nextIsTypeBound && this.currentArrayContentIsNonNull == this.nextArrayContentIsNonNull)
 				return this;
 			// are we running out of real type annotations?
 			if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
 				return new NonNullDefaultAwareTypeAnnotationWalker(this.defaultNullness, this.nonNullAnnotation, 
-												this.nextIsDefaultLocation, this.nextIsTypeBound, this.environment);
+												this.nextIsDefaultLocation, this.nextIsTypeBound, this.environment, this.nextArrayContentIsNonNull);
 			// proceed as normal, but pass on our specific fields, too:
 			return new NonNullDefaultAwareTypeAnnotationWalker(this.typeAnnotations, newMatches, newPathPtr,
 												this.defaultNullness, this.nonNullAnnotation, this.nextIsDefaultLocation,
-												this.nextIsTypeBound, this.environment);
+												this.nextIsTypeBound, this.environment, this.nextArrayContentIsNonNull);
 		} finally {
 			this.nextIsDefaultLocation = false; // expire
 			this.nextIsTypeBound = false;
+			this.nextArrayContentIsNonNull = this.currentArrayContentIsNonNull;
 		}
 	}
 	
@@ -139,6 +151,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
+		this.nextArrayContentIsNonNull = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toTypeBound(boundIndex);
 	}
@@ -147,6 +160,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	public ITypeAnnotationWalker toWildcardBound() {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
+		this.nextArrayContentIsNonNull = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toWildcardBound();
 	}
@@ -155,6 +169,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
+		this.nextArrayContentIsNonNull = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toTypeParameterBounds(isClassTypeParameter, parameterRank);
 	}
@@ -163,6 +178,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	public ITypeAnnotationWalker toTypeArgument(int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeArgument) != 0;
 		this.nextIsTypeBound = false;
+		this.nextArrayContentIsNonNull = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toTypeArgument(rank);
 	}
@@ -171,6 +187,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeParameter) != 0;
 		this.nextIsTypeBound = false;
+		this.nextArrayContentIsNonNull = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toTypeParameter(isClassTypeParameter, rank);
 	}
@@ -182,9 +199,9 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
-		IBinaryAnnotation[] normalAnnotations = this.isEmpty ? NO_ANNOTATIONS : super.getAnnotationsAtCursor(currentTypeId);
-		if (this.atDefaultLocation &&
+	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) {
+		IBinaryAnnotation[] normalAnnotations = this.isEmpty ? NO_ANNOTATIONS : super.getAnnotationsAtCursor(currentTypeId, mayApplyArrayContentsDefaultNullness);
+		if ((this.atDefaultLocation || (mayApplyArrayContentsDefaultNullness && this.currentArrayContentIsNonNull)) &&
 				!(currentTypeId == -1) && // never apply default on type variable use or wildcard
 				!(this.atTypeBound && currentTypeId == TypeIds.T_JavaLangObject)) // for CLIMB-to-top consider a j.l.Object type bound as no explicit type bound
 		{
@@ -204,4 +221,17 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 		}
 		return normalAnnotations;
 	}
+	
+	@Override
+	public ITypeAnnotationWalker toNextArrayDimension() {
+		boolean hasNNBDForArrayContents = (this.defaultNullness & Binding.DefaultLocationArrayContents) != 0;
+		if (hasNNBDForArrayContents) {
+			this.nextArrayContentIsNonNull = true;
+		}
+		this.nextIsDefaultLocation = false;
+		this.nextIsTypeBound = false;
+		if (this.isEmpty)
+			return restrict(this.matches, this.pathPtr);
+		return super.toNextArrayDimension();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index eba1da2..be1280b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013, 2015 GK Software AG.
+ * Copyright (c) 2013, 2017 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -235,7 +235,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	protected ITypeAnnotationWalker toNextDetail(int detailKind) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
-			return EMPTY_ANNOTATION_WALKER;
+			return restrict(newMatches, this.pathPtr+2);
 		int length = this.typeAnnotations.length;
 		long mask = 1;
 		for (int i = 0; i < length; i++, mask = mask << 1) {
@@ -251,7 +251,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	// ==== leaves: the actual annotations: ====
 	
 	@Override
-	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) {
 		int length = this.typeAnnotations.length;
 		IBinaryAnnotation[] filtered = new IBinaryAnnotation[length];
 		long ptr = 1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
index 1f595ae..867a389 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 GK Software AG.
+ * Copyright (c) 2015, 2017 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -40,7 +40,7 @@ public interface ITypeAnnotationWalker {
 		public ITypeAnnotationWalker toWildcardBound() { return this; }
 		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
 		public ITypeAnnotationWalker toNextNestedType() { return this; }
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness) { return NO_ANNOTATIONS; }
 	};
 
 	/** Walk to a field. */
@@ -114,6 +114,6 @@ public interface ITypeAnnotationWalker {
 	 * @param currentTypeId the id of the type being annotated; 0 signals don't care / unknown;
 	 * 		 -1 signals if annotating a wildcard or a use of a type variable.
 	 */
-	public abstract IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId);
+	public abstract IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId, boolean mayApplyArrayContentsDefaultNullness);
 
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index a01bd08..601dd60 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -829,7 +829,7 @@ private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType,
 		? new MethodBinding(methodModifiers, parameters, exceptions, this)
 		: new MethodBinding(methodModifiers, method.getSelector(), returnType, parameters, exceptions, this);
 	
-	IBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor(this.id);
+	IBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor(this.id, false);
 	if (receiverAnnotations != null && receiverAnnotations.length > 0) {
 		result.receiver = this.environment.createAnnotatedType(this, createAnnotations(receiverAnnotations, this.environment, missingTypeNames));
 	}
@@ -838,7 +838,7 @@ private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType,
 		IBinaryAnnotation[] annotations = method.getAnnotations();
 	    if (annotations == null || annotations.length == 0)
 	    	if (method.isConstructor())
-	    		annotations = walker.toMethodReturn().getAnnotationsAtCursor(this.id); // FIXME: When both exist, order could become an issue.
+	    		annotations = walker.toMethodReturn().getAnnotationsAtCursor(this.id, false); // FIXME: When both exist, order could become an issue.
 		result.setAnnotations(
 			createAnnotations(annotations, this.environment, missingTypeNames),
 			paramAnnotations,
@@ -952,7 +952,7 @@ private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, bool
 						int colon = CharOperation.indexOf(Util.C_COLON, typeSignature, i);
 						char[] variableName = CharOperation.subarray(typeSignature, i, colon);
 						TypeVariableBinding typeVariable = new TypeVariableBinding(variableName, this, rank, this.environment);
-						AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.toTypeParameter(isClassTypeParameter, rank++).getAnnotationsAtCursor(0), 
+						AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.toTypeParameter(isClassTypeParameter, rank++).getAnnotationsAtCursor(0, false), 
 																										this.environment, missingTypeNames);
 						if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 							typeVariable.setTypeAnnotations(annotations, this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled);
@@ -1587,7 +1587,7 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 
 	boolean explicitNullness = false;
 	IBinaryAnnotation[] annotations = externalAnnotationWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
-											? externalAnnotationWalker.getAnnotationsAtCursor(fieldBinding.type.id) 
+											? externalAnnotationWalker.getAnnotationsAtCursor(fieldBinding.type.id, false) 
 											: field.getAnnotations();
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
@@ -1640,7 +1640,7 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 	// return:
 	ITypeAnnotationWalker returnWalker = externalAnnotationWalker.toMethodReturn();
 	IBinaryAnnotation[] annotations = returnWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
-								? returnWalker.getAnnotationsAtCursor(methodBinding.returnType.id)
+								? returnWalker.getAnnotationsAtCursor(methodBinding.returnType.id, false)
 								: method.getAnnotations();
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
@@ -1691,7 +1691,7 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 				int startIndex = numParamAnnotations - numVisibleParams;
 				ITypeAnnotationWalker parameterWalker = externalAnnotationWalker.toMethodParameter((short) (j+startIndex));
 				IBinaryAnnotation[] paramAnnotations = parameterWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
-															? parameterWalker.getAnnotationsAtCursor(parameters[j].id)
+															? parameterWalker.getAnnotationsAtCursor(parameters[j].id, false)
 															: method.getParameterAnnotations(j+startIndex, this.fileName);
 				if (paramAnnotations != null) {
 					for (int i = 0; i < paramAnnotations.length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index e8b4820..46fc51b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -97,7 +97,6 @@ public abstract class Binding {
 	public static final int DefaultLocationTypeBound = ASTNode.Bit9;
 	/**
 	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#ARRAY_CONTENTS
-	 * TODO: this constant is not yet used, due to difficulty to discern these annotations between SE5 / SE8
 	 */
 	public static final int DefaultLocationArrayContents = ASTNode.Bit10;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ExternalAnnotationSuperimposer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ExternalAnnotationSuperimposer.java
index 781a451..e97a67d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ExternalAnnotationSuperimposer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ExternalAnnotationSuperimposer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 GK Software AG.
+ * Copyright (c) 2016, 2017 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -179,7 +179,7 @@ class ExternalAnnotationSuperimposer extends TypeBindingVisitor {
 			AnnotationBinding[][] annotsOnDims = new AnnotationBinding[dims][];
 			ITypeAnnotationWalker walker = this.currentWalker;
 			for (int i = 0; i < dims; i++) {
-				IBinaryAnnotation[] binaryAnnotations = walker.getAnnotationsAtCursor(arrayBinding.id);
+				IBinaryAnnotation[] binaryAnnotations = walker.getAnnotationsAtCursor(arrayBinding.id, false);
 				if (binaryAnnotations != ITypeAnnotationWalker.NO_ANNOTATIONS) {
 					annotsOnDims[i] = BinaryTypeBinding.createAnnotations(binaryAnnotations, this.environment, null);
 					this.isReplacing = true;
@@ -209,7 +209,7 @@ class ExternalAnnotationSuperimposer extends TypeBindingVisitor {
 	public boolean visit(ParameterizedTypeBinding parameterizedTypeBinding) {
 		ExternalAnnotationSuperimposer memento = snapshot();
 		try {
-			IBinaryAnnotation[] binaryAnnotations = this.currentWalker.getAnnotationsAtCursor(parameterizedTypeBinding.id);
+			IBinaryAnnotation[] binaryAnnotations = this.currentWalker.getAnnotationsAtCursor(parameterizedTypeBinding.id, false);
 			AnnotationBinding[] annotations = Binding.NO_ANNOTATIONS;
 			if (binaryAnnotations != ITypeAnnotationWalker.NO_ANNOTATIONS) {
 				annotations = BinaryTypeBinding.createAnnotations(binaryAnnotations, this.environment, null);
@@ -234,7 +234,7 @@ class ExternalAnnotationSuperimposer extends TypeBindingVisitor {
 	}
 	@Override
 	public boolean visit(ReferenceBinding referenceBinding) {
-		IBinaryAnnotation[] binaryAnnotations = this.currentWalker.getAnnotationsAtCursor(referenceBinding.id);
+		IBinaryAnnotation[] binaryAnnotations = this.currentWalker.getAnnotationsAtCursor(referenceBinding.id, false);
 		if (binaryAnnotations != ITypeAnnotationWalker.NO_ANNOTATIONS)
 			this.typeReplacement = this.environment.createAnnotatedType(referenceBinding, BinaryTypeBinding.createAnnotations(binaryAnnotations, this.environment, null));
 		return false;
@@ -251,7 +251,7 @@ class ExternalAnnotationSuperimposer extends TypeBindingVisitor {
 			if (bound != null) {
 				bound = goAndSuperimpose(memento.currentWalker.toWildcardBound(), bound);
 			}
-			IBinaryAnnotation[] binaryAnnotations = memento.currentWalker.getAnnotationsAtCursor(-1); 
+			IBinaryAnnotation[] binaryAnnotations = memento.currentWalker.getAnnotationsAtCursor(-1, false); 
 			if (this.isReplacing || binaryAnnotations != ITypeAnnotationWalker.NO_ANNOTATIONS) {
 				TypeBinding[] otherBounds = wildcardBinding.otherBounds;
 				if (binaryAnnotations != ITypeAnnotationWalker.NO_ANNOTATIONS) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 64480df..7bc411b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1384,7 +1384,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	AnnotationBinding [][] annotationsOnDimensions = null;
 	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
-			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
+			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0, true), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
 				if (annotationsOnDimensions == null)
 					annotationsOnDimensions = new AnnotationBinding[dimension][];
@@ -1462,7 +1462,7 @@ private TypeBinding annotateType(TypeBinding binding, ITypeAnnotationWalker walk
 	}
 	AnnotationBinding [][] annotations = null;
 	for (int i = 0; i < depth; i++) {
-		AnnotationBinding[] annots = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(binding.id), this, missingTypeNames);
+		AnnotationBinding[] annots = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(binding.id, i == depth - 1), this, missingTypeNames);
 		if (annots != null && annots.length > 0) {
 			if (annotations == null)
 				annotations = new AnnotationBinding[depth][];
@@ -1523,7 +1523,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	AnnotationBinding [][] annotationsOnDimensions = null;
 	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
-			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
+			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0, true), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
 				if (annotationsOnDimensions == null)
 					annotationsOnDimensions = new AnnotationBinding[dimension][];
@@ -1616,7 +1616,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 }
 
 private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, ITypeAnnotationWalker walker, char [][][] missingTypeNames) {
-	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1), this, missingTypeNames);
+	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1, false), this, missingTypeNames);
 	if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 		typeVariableBinding = (TypeVariableBinding) createAnnotatedType(typeVariableBinding, new AnnotationBinding [][] { annotations });
 
@@ -1643,18 +1643,18 @@ TypeBinding getTypeFromVariantTypeSignature(
 			// ? super aType
 			wrapper.start++;
 			TypeBinding bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker.toWildcardBound());
-			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1), this, missingTypeNames);
+			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1, false), this, missingTypeNames);
 			return this.typeSystem.getWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.SUPER, annotations);
 		case '+' :
 			// ? extends aType
 			wrapper.start++;
 			bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker.toWildcardBound());
-			annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1), this, missingTypeNames);
+			annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1, false), this, missingTypeNames);
 			return this.typeSystem.getWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.EXTENDS, annotations);
 		case '*' :
 			// ?
 			wrapper.start++;
-			annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1), this, missingTypeNames);
+			annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1, false), this, missingTypeNames);
 			return this.typeSystem.getWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND, annotations);
 		default :
 			return getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker);
