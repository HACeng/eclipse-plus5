commit 757f19ed428d31dbfa31c00cff42cd33fb3902ce
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Nov 24 13:33:04 2013 +0530

    Fixed Bug 402080 - [1.8][code select] Unable to navigate to method
    declaration from method reference

2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
6	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
1	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
696	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
3	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
52	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpressionName.java
46	8	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
13	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
14	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
index 7b618e4..e7713cb 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
@@ -35,6 +35,7 @@ import org.eclipse.jdt.core.tests.dom.TypeBindingTests308;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR308Tests;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR335Tests;
 import org.eclipse.jdt.core.tests.model.JavaSearchBugs8Tests;
+import org.eclipse.jdt.core.tests.model.ResolveTests18;
 import org.eclipse.jdt.core.tests.rewrite.describing.ASTRewritingTest;
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
 
@@ -49,6 +50,7 @@ public class RunAllJava8Tests extends TestCase {
 			FormatterJSR335Tests.class,
 			FormatterJSR308Tests.class,
 			JavaSearchBugs8Tests.class,
+			ResolveTests18.class,
 			org.eclipse.jdt.compiler.apt.tests.AllTests.class,
 		};
 	}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
index b2c008c..5dcdc44 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
@@ -55,6 +55,7 @@ import org.eclipse.jdt.core.tests.dom.TypeBindingTests308;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR308Tests;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR335Tests;
 import org.eclipse.jdt.core.tests.model.JavaSearchBugs8Tests;
+import org.eclipse.jdt.core.tests.model.ResolveTests18;
 import org.eclipse.jdt.core.tests.rewrite.describing.ASTRewritingTest;
 
 public class RunOnlyJava8Tests extends TestCase {
@@ -88,6 +89,7 @@ public class RunOnlyJava8Tests extends TestCase {
 			MethodParametersAttributeTest.class,
 			ClassFileReaderTest_1_8.class,
 			RepeatableAnnotationTest.class,
+			ResolveTests18.class,
 		};
 	}
 	
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 603f641..62e8b56 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -2724,7 +2724,11 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 		String jclLibString;
 		String newJclLibString;
 		String newJclSrcString;
-		if (compliance.charAt(2) > '4') {
+		if (compliance.charAt(2) > '7') {
+			jclLibString = "JCL_LIB";
+			newJclLibString = "JCL18_LIB";
+			newJclSrcString = "JCL18_SRC";
+		} else if (compliance.charAt(2) > '4') {
 			jclLibString = "JCL_LIB";
 			newJclLibString = "JCL15_LIB";
 			newJclSrcString = "JCL15_SRC";
@@ -2733,6 +2737,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 			newJclLibString = "JCL_LIB";
 			newJclSrcString = "JCL_SRC";
 		}
+		
 
 		// ensure variables are set
 		setUpJCLClasspathVariables(compliance);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index e33db13..b309072 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -88,6 +88,7 @@ private static Class[] getAllTestClasses() {
 		ResolveTests.class,
 		ResolveTests2.class,
 		ResolveTests_1_5.class,
+		ResolveTests18.class,
 		SelectionJavadocModelTests.class,
 
 		// Support for completion tests
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
new file mode 100644
index 0000000..e62e8dc
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
@@ -0,0 +1,696 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.tests.model;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.WorkingCopyOwner;
+
+public class ResolveTests18 extends AbstractJavaModelTests {
+	ICompilationUnit wc = null;
+
+static {
+	// TESTS_NAMES = new String[] { "test0023" };
+	// TESTS_NUMBERS = new int[] { 124 };
+	// TESTS_RANGE = new int[] { 16, -1 };
+}
+public static Test suite() {
+	return buildModelTestSuite(ResolveTests18.class);
+}
+public ResolveTests18(String name) {
+	super(name);
+}
+public ICompilationUnit getWorkingCopy(String path, String source) throws JavaModelException {
+	return super.getWorkingCopy(path, source, this.wcOwner);
+}
+public void setUpSuite() throws Exception {
+	super.setUpSuite();
+
+	setUpJavaProject("Resolve", "1.8");
+
+	waitUntilIndexesReady();
+}
+protected void setUp() throws Exception {
+	super.setUp();
+	this.wcOwner = new WorkingCopyOwner(){};
+}
+public void tearDownSuite() throws Exception {
+	deleteProject("Resolve");
+
+	super.tearDownSuite();
+}
+
+protected void tearDown() throws Exception {
+	if (this.wc != null) {
+		this.wc.discardWorkingCopy();
+	}
+	super.tearDown();
+}
+// Test (positive): self static methods can be targetted by references.
+public void test0001() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"goo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (negative): no valid target
+public void test0002() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static void goo() {}\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// test negative, super method targetted is not visible
+public void test0003() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	private static void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// test (positive) that method references can target super static methods.
+public void test0004() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"goo() [in Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (positive) method reference with primaries can target self methods.
+public void test0005() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = new X()::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"goo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (positive) method reference with primaries can target super methods.
+public void test0006() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = new X()::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"goo() [in Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test that static method cannot be invoked with a receiver.
+public void test0007() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = new X()::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Negative test
+public void test0008() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = new X()::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test (negative) method references: +ve test below
+public void test0009() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test positive that metod references can target super methods
+public void test0010() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	void goo() {}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"goo() [in Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (negative) method references
+public void test0011() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	static void goo(X x) {}\n" +
+			"	void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "goo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test positive that lhs of method reference is selectable.
+public void test0012() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	static void goo(X x) {}\n" +
+			"	void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "X";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]",
+		elements
+	);
+}
+// Test positive that type arguments of method reference are selectable
+public void test0013() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	void foo(X x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	static void goo(X x) {}\n" +
+			"	void goo() {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>goo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "Y";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]",
+		elements
+	);
+}
+// Test (negative) constructor references: +ve test below
+public void test0014() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	X foo(int x);\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "new";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test (positive) constructor references.
+public void test0015() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	X foo(int x);\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"   X(long i) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "new";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"X(long) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (negative) type mismatch. Positive test with correction below.
+public void test0016() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	Y foo(int x);\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"   X(long i) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "new";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test (positive) that the type arguments are selectable.
+public void test0017() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	Y foo(int x);\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X extends Y {\n" +
+			"   X(long i) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "Y";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]",
+		elements
+	);
+}
+// Test (positive) that the LHS type is selectable.
+public void test0018() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	X foo(int x);\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"   X(Integer i) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = X::<Y>new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "X";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]",
+		elements
+	);
+}
+// Test (positive) that super type methods can be targetted via a primary.
+public void test0019() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = new X()::<Y>hashCode;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "hashCode";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"hashCode() [in Object [in Object.class [in java.lang [in "+ getExternalPath() + "jclMin1.8.jar]]]]",
+		elements
+	);
+}
+// Test (positive) that interface types on the LHS can refer to object methods.
+public void test0020() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"class Y {}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = ((I)()->0)::<Y>hashCode;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "hashCode";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"hashCode() [in Object [in Object.class [in java.lang [in "+ getExternalPath() + "jclMin1.8.jar]]]]",
+		elements
+	);
+}
+// Test (negative) super:: style method references - such constructor references are not grammatical.
+public void test0021() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    int foo() { return 10;}\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public void main(String[] args) {\n" +
+			"		I i = super::foo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "foo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+// Test (positive) super:: style method references - such constructor references are not grammatical.
+public void test0022() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    int foo() { return 10;}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public void main(String[] args) {\n" +
+			"		I i = super::foo;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "super::foo";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"foo() [in Y [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]",
+		elements
+	);
+}
+// Test (negative) that the synthesized array constructor is NOT selectable - it is fabricated out of nowhere, no where to navigate to !
+public void test0023() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int [] foo(int x);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    int foo() { return 10;}\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public void main(String[] args) {\n" +
+			"		I i = int []::new;\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "new";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"",
+		elements
+	);
+}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index 43b69e2..b102dfc 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -578,6 +578,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				switch (token) {
 					case TerminalTokens.TokenNamethis:
 					case TerminalTokens.TokenNamesuper:
+					case TerminalTokens.TokenNamenew:
 					case TerminalTokens.TokenNameIdentifier:
 						if (scanner.startPosition <= selectionStart && selectionStart <= scanner.currentPosition) {
 							if (scanner.currentPosition == scanner.eofPosition) {
@@ -607,6 +608,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				switch (token) {
 					case TerminalTokens.TokenNamethis :
 					case TerminalTokens.TokenNamesuper :
+					case TerminalTokens.TokenNamenew :
 					case TerminalTokens.TokenNameIdentifier :
 						if (!expectingIdentifier)
 							return false;
@@ -619,6 +621,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 						}
 						expectingIdentifier = false;
 						break;
+					case TerminalTokens.TokenNameCOLON_COLON:	
 					case TerminalTokens.TokenNameDOT :
 						if (expectingIdentifier)
 							return false;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpressionName.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpressionName.java
new file mode 100644
index 0000000..0b56753
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpressionName.java
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.select;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+
+public class SelectionOnReferenceExpressionName extends ReferenceExpression {
+
+	public SelectionOnReferenceExpressionName() {
+		super();
+	}
+
+	public StringBuffer printExpression(int indent, StringBuffer output) {
+		output.append("<SelectionOnReferenceExpressionName:"); //$NON-NLS-1$
+		super.printExpression(indent, output);
+		return output.append('>');
+	}
+	
+	// See SelectionScanner#scanIdentifierOrKeyword
+	public boolean isConstructorReference() {
+		return CharOperation.equals(this.selector, "new".toCharArray()); //$NON-NLS-1$
+	}
+	
+	// See SelectionScanner#scanIdentifierOrKeyword
+	public boolean isMethodReference() {
+		return !CharOperation.equals(this.selector, "new".toCharArray()); //$NON-NLS-1$
+	}
+
+	public TypeBinding resolveType(BlockScope scope) {
+		super.resolveType(scope);
+		MethodBinding method = getMethodBinding();
+		if (method != null && method.isValidBinding() && !method.isSynthetic())
+			throw new SelectionNodeFound(this.actualMethodBinding);
+		throw new SelectionNodeFound();
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
index 642f941..69f6f84 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
@@ -24,17 +24,46 @@ package org.eclipse.jdt.internal.codeassist.select;
  *  n  means completion behind the n-th character
  */
 
-import org.eclipse.jdt.internal.compiler.*;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.env.*;
-
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.codeassist.impl.*;
-import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.codeassist.impl.AssistParser;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
+import org.eclipse.jdt.internal.compiler.ast.CastExpression;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.FieldReference;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
+import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.NameReference;
+import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.Reference;
+import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
+import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
+import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
+import org.eclipse.jdt.internal.compiler.ast.Statement;
+import org.eclipse.jdt.internal.compiler.ast.SuperReference;
+import org.eclipse.jdt.internal.compiler.ast.SwitchStatement;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
-import org.eclipse.jdt.internal.compiler.parser.*;
-import org.eclipse.jdt.internal.compiler.problem.*;
+import org.eclipse.jdt.internal.compiler.parser.JavadocParser;
+import org.eclipse.jdt.internal.compiler.parser.RecoveredType;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class SelectionParser extends AssistParser {
@@ -1309,6 +1338,15 @@ protected NameReference getUnspecifiedReferenceOptimized() {
 public void initializeScanner(){
 	this.scanner = new SelectionScanner(this.options.sourceLevel);
 }
+public ReferenceExpression newReferenceExpression() {
+	char[] selector = this.identifierStack[this.identifierPtr];
+	if (selector != assistIdentifier()){
+		return super.newReferenceExpression();
+	}
+	ReferenceExpression referenceExpression = new SelectionOnReferenceExpressionName();
+	this.assistNode = referenceExpression;
+	return referenceExpression;
+}
 protected MessageSend newMessageSend() {
 	// '(' ArgumentListopt ')'
 	// the arguments are on the expression stack
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 1a346c2..3d8b608 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -51,6 +51,15 @@ public abstract class FunctionalExpression extends Expression {
 	public FunctionalExpression(CompilationResult compilationResult) {
 		this.compilationResult = compilationResult;
 	}
+	
+	public FunctionalExpression() {
+		super();
+	}
+	
+	public void setCompilationResult(CompilationResult compilationResult) {
+		this.compilationResult = compilationResult;
+	}
+	
 	// Return the actual (non-code generation) method binding that is void of synthetics.
 	public MethodBinding getMethodBinding() {
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index ace6e3a..221de19 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -71,13 +71,17 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	private int depth;
 	private MethodBinding exactMethodBinding; // != null ==> exact method reference.
 	
-	public ReferenceExpression(CompilationResult compilationResult, Expression lhs, TypeReference [] typeArguments, char [] selector, int sourceEnd) {
-		super(compilationResult);
-		this.lhs = lhs;
-		this.typeArguments = typeArguments;
-		this.selector = selector;
-		this.sourceStart = lhs.sourceStart;
-		this.sourceEnd = sourceEnd;
+	public ReferenceExpression() {
+		super();
+	}
+	
+	public void initialize(CompilationResult result, Expression expression, TypeReference [] optionalTypeArguments, char [] identifierOrNew, int sourceEndPosition) {
+		super.setCompilationResult(result);
+		this.lhs = expression;
+		this.typeArguments = optionalTypeArguments;
+		this.selector = identifierOrNew;
+		this.sourceStart = expression.sourceStart;
+		this.sourceEnd = sourceEndPosition;
 	}
  
 	public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
@@ -510,7 +514,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
     	return this.resolvedType; // Phew !
 	}
 
-	public final boolean isConstructorReference() {
+	public boolean isConstructorReference() {
 		return CharOperation.equals(this.selector,  ConstantPool.Init);
 	}
 	
@@ -518,7 +522,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		return this.exactMethodBinding != null;
 	}
 	
-	public final boolean isMethodReference() {
+	public boolean isMethodReference() {
 		return !CharOperation.equals(this.selector,  ConstantPool.Init);
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index f6ebc13..a622fad 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -2116,7 +2116,7 @@ public abstract class Scope {
 			TypeBinding leafType = receiverType.leafComponentType();
 			if (!leafType.canBeSeenBy(this) || !leafType.isReifiable())
 				return null;
-			return new MethodBinding(ClassFileConstants.AccPublic, TypeConstants.INIT,
+			return new MethodBinding(ClassFileConstants.AccPublic | ClassFileConstants.AccSynthetic, TypeConstants.INIT,
 								receiverType,
 								new TypeBinding[] { TypeBinding.INT },
 								Binding.NO_EXCEPTIONS,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index ee16b6d..dbfbc8e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -7970,12 +7970,17 @@ protected void consumeEmptyTypeArguments() {
 	// NonWildTypeArgumentsopt ::= $empty
 	pushOnGenericsLengthStack(0); // signal absence of type arguments.
 }
+
+public ReferenceExpression newReferenceExpression() {
+	return new ReferenceExpression();
+}
+
 protected void consumeReferenceExpressionTypeForm(boolean isPrimitive) { // actually Name or Type form.
 	
 	// ReferenceExpression ::= PrimitiveType Dims '::' NonWildTypeArgumentsopt IdentifierOrNew
 	// ReferenceExpression ::= Name Dimsopt '::' NonWildTypeArgumentsopt IdentifierOrNew
 
-	ReferenceExpression referenceExpression;
+	ReferenceExpression referenceExpression = newReferenceExpression();
 	TypeReference [] typeArguments = null;
 	char [] selector;
 	int sourceEnd;
@@ -8006,9 +8011,9 @@ protected void consumeReferenceExpressionTypeForm(boolean isPrimitive) { // actu
 			pushOnGenericsLengthStack(0);
 			pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
 		}
-		referenceExpression = new ReferenceExpression(this.compilationUnit.compilationResult, getTypeReference(dimension), typeArguments, selector, sourceEnd);
+		referenceExpression.initialize(this.compilationUnit.compilationResult, getTypeReference(dimension), typeArguments, selector, sourceEnd);
 	} else {
-		referenceExpression = new ReferenceExpression(this.compilationUnit.compilationResult, getUnspecifiedReference(), typeArguments, selector, sourceEnd);
+		referenceExpression.initialize(this.compilationUnit.compilationResult, getUnspecifiedReference(), typeArguments, selector, sourceEnd);
 	}
 	pushOnExpressionStack(referenceExpression);
 
@@ -8019,7 +8024,7 @@ protected void consumeReferenceExpressionTypeForm(boolean isPrimitive) { // actu
 protected void consumeReferenceExpressionPrimaryForm() {
 	// ReferenceExpression ::= Primary '::' NonWildTypeArgumentsopt Identifier
 
-	ReferenceExpression referenceExpression;
+	ReferenceExpression referenceExpression = newReferenceExpression();
 	TypeReference [] typeArguments = null;
 	char [] selector;
 	int sourceEnd;
@@ -8037,7 +8042,7 @@ protected void consumeReferenceExpressionPrimaryForm() {
 	
 	Expression primary = this.expressionStack[this.expressionPtr--];
 	this.expressionLengthPtr--;
-	referenceExpression = new ReferenceExpression(this.compilationUnit.compilationResult, primary, typeArguments, selector, sourceEnd);
+	referenceExpression.initialize(this.compilationUnit.compilationResult, primary, typeArguments, selector, sourceEnd);
 	pushOnExpressionStack(referenceExpression);
 	if (!this.parsingJava8Plus) {
 		problemReporter().referenceExpressionsNotBelow18(referenceExpression);
@@ -8046,7 +8051,7 @@ protected void consumeReferenceExpressionPrimaryForm() {
 protected void consumeReferenceExpressionSuperForm() {
 	// ReferenceExpression ::= 'super' '::' NonWildTypeArgumentsopt Identifier
 
-	ReferenceExpression referenceExpression;
+	ReferenceExpression referenceExpression = newReferenceExpression();
 	TypeReference [] typeArguments = null;
 	char [] selector;
 	int sourceEnd;
@@ -8063,7 +8068,7 @@ protected void consumeReferenceExpressionSuperForm() {
 	}
 	
 	SuperReference superReference = new SuperReference(this.intStack[this.intPtr--], this.endPosition);
-	referenceExpression = new ReferenceExpression(this.compilationUnit.compilationResult, superReference, typeArguments, selector, sourceEnd);
+	referenceExpression.initialize(this.compilationUnit.compilationResult, superReference, typeArguments, selector, sourceEnd);
 	pushOnExpressionStack(referenceExpression);
 	if (!this.parsingJava8Plus) {
 		problemReporter().referenceExpressionsNotBelow18(referenceExpression);
@@ -8079,7 +8084,7 @@ protected void consumeReferenceExpressionGenericTypeForm() {
 
 	// ReferenceExpression ::= Name BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
 	
-	ReferenceExpression referenceExpression;
+	ReferenceExpression referenceExpression = newReferenceExpression();
 	TypeReference type;
 	TypeReference [] typeArguments = null;
 	char [] selector;
@@ -8110,7 +8115,7 @@ protected void consumeReferenceExpressionGenericTypeForm() {
 	this.intPtr--; // pop '<' position
 	type.sourceEnd = typeSourceEnd;
 	
-	referenceExpression = new ReferenceExpression(this.compilationUnit.compilationResult, type, typeArguments, selector, sourceEnd);
+	referenceExpression.initialize(this.compilationUnit.compilationResult, type, typeArguments, selector, sourceEnd);
 
 	pushOnExpressionStack(referenceExpression);
 	if (!this.parsingJava8Plus) {
