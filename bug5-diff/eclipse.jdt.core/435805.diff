commit 7530e9811f8e0b012d59fd23237f75cdb4977fd6
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Nov 2 01:47:27 2014 +0100

    Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize
    declaration style null annotations
    
    Change-Id: I3e69dc7364bcbb83720619263238b6a066182255
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>

59	8	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
24	17	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
20	21	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
2	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
48	82	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
10	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
23	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
27	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
8	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 5e23a1f..7efc4c5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -890,13 +890,15 @@ public void test_parameter_specification_inheritance_003() {
 // a method adds a @NonNull annotation, super interface has no null annotation
 // changing other from unconstrained to @Nullable is OK
 public void test_parameter_specification_inheritance_004() {
-	runConformTest(
+	runConformTestWithLibs(
 		new String[] {
 			"IX.java",
 			"public interface IX {\n" +
 			"    void foo(Object o, Object other);\n" +
 			"}\n"
-		});
+		},
+		getCompilerOptions(),
+		"");
 	runNegativeTestWithLibs(
 		false, // don't flush
 		new String[] {
@@ -947,13 +949,15 @@ public void test_parameter_specification_inheritance_005() {
 
 // super has no constraint for return, sub method confirms the null contract as @Nullable
 public void test_parameter_specification_inheritance_006() {
-	runConformTest(
+	runConformTestWithLibs(
 		new String[] {
 			"Lib.java",
 			"public class Lib {\n" +
 			"    Object getObject() { return null; }\n" +
 			"}\n"
-		});
+		},
+		getCompilerOptions(),
+		"");
 	runConformTestWithLibs(
 		false, // don't flush
 		new String[] {
@@ -2574,6 +2578,7 @@ public void test_default_nullness_005() {
 	Map customOptions = getCompilerOptions();
 //	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
 	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -2589,7 +2594,9 @@ public void test_default_nullness_005() {
 			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
 			"package p1;\n",
 	CUSTOM_NONNULL_NAME,
-			CUSTOM_NONNULL_CONTENT
+			CUSTOM_NONNULL_CONTENT,
+	CUSTOM_NULLABLE_NAME,
+			CUSTOM_NULLABLE_CONTENT
 		},
 		customOptions,
 		"----------\n" +
@@ -2605,6 +2612,7 @@ public void test_default_nullness_006() {
 	Map customOptions = getCompilerOptions();
 //	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
 	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/package-info.java",
@@ -2620,7 +2628,9 @@ public void test_default_nullness_006() {
 			"    }\n" +
 			"}\n",
 	CUSTOM_NONNULL_NAME,
-			CUSTOM_NONNULL_CONTENT
+			CUSTOM_NONNULL_CONTENT,
+	CUSTOM_NULLABLE_NAME,
+			CUSTOM_NULLABLE_CONTENT
 		},
 		customOptions,
 		"----------\n" +
@@ -3795,7 +3805,7 @@ public void test_nesting_1() {
 // Test a regression incurred to the OT/J based implementation
 // by the fix in Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
 public void test_constructor_with_nested_class() {
-	runConformTest(
+	runConformTestWithLibs(
 		new String[] {
 			"X.java",
 			"public class X {\n" +
@@ -3803,12 +3813,14 @@ public void test_constructor_with_nested_class() {
 			"    final Object o2;\n" +
 			"    public X() {\n" +
 			"         this.o1 = new Object() {\n" +
+			"             @Override\n" +
 			"             public String toString() { return \"O1\"; }\n" +
 			"         };\n" +
 			"         this.o2 = new Object();" +
 			"    }\n" +
 			"}\n"
 		},
+		null,//options
 		"");
 }
 // test analysis disablement, binary type contains annotation
@@ -6500,7 +6512,7 @@ public void testBug413460() {
 
 // missing type in constructor declaration must not cause NPE in QAE#resolveType(..)
 public void testBug415850_a() {
-	this.runNegativeTest(
+	this.runNegativeTestWithLibs(
 			new String[] {
 				"X.java", //-----------------------------------------------------------------------
 				"public class X {\n" +
@@ -7601,4 +7613,43 @@ public void _test444024() {
 		   },
 		   "");
 }
+public void testBug435805() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	options.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+	runNegativeTest(
+		true/*flush*/,
+		new String[] {
+			"org/foo/Nullable.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" + 
+			"@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\n" + 
+			"public @interface Nullable {}\n",
+			"org/foo/NonNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" + 
+			"@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\n" + 
+			"public @interface NonNull {}\n",
+			"TestNulls.java",
+			"import org.foo.*;\n" + 
+			"\n" + 
+			"public class TestNulls {\n" + 
+			"	public void testCase(@Nullable String theValue) {\n" + 
+			"		int len = theValue.length();					// Is nullable, so should report error here.\n" + 
+			"	}\n" + 
+			"\n" + 
+			"}"
+		},
+		null/*libs*/,
+		options,
+		"----------\n" + 
+		"1. ERROR in TestNulls.java (at line 5)\n" + 
+		"	int len = theValue.length();					// Is nullable, so should report error here.\n" + 
+		"	          ^^^^^^^^\n" + 
+		"Potential null pointer access: The variable theValue may be null at this location\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 8752742..c7fbc4c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -378,7 +378,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 
 	public void testMissingAnnotationTypes_01() {
-		runNegativeTest(
+		runNegativeTestWithLibs(
 			new String[] {
 				"X.java",
 				"public class X {\n" +
@@ -775,7 +775,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	
 	// https://bugs.eclipse.org/403216 - [1.8][null] TypeReference#captureTypeAnnotations treats type annotations as type argument annotations 
 	public void testBug403216_1() {
-		runConformTest(
+		runConformTestWithLibs(
 			new String[] {
 				"Test.java",
 				"import java.lang.annotation.ElementType;\n" + 
@@ -792,7 +792,9 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"@interface A {}\n" + 
 				"@Target(value={ElementType.TYPE_USE})\n" + 
 				"@interface B {}\n"
-			});
+			},
+			null,
+			"");
 	}
 
 	// issue from https://bugs.eclipse.org/bugs/show_bug.cgi?id=403216#c7
@@ -4024,7 +4026,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 		
 		// Without annotations.
-		runConformTest(
+		runConformTestWithLibs(
 				new String[] {
 					"X.java",
 					"public class X {\n" +
@@ -4036,7 +4038,9 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"       System.out.println(\"Done\");\n" +
 					"   }\n" +
 					"}\n"
-				}, 
+				},
+				getCompilerOptions(),
+				"",
 				"Done");
 	}
 	public void testRawType() {
@@ -4077,7 +4081,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420456, [1.8][null] AIOOB in null analysis code.
 	public void test420456() {
-		runConformTest(
+		runConformTestWithLibs(
 			new String[] {
 				"X.java",
 				"import java.util.Arrays;\n" +
@@ -4089,12 +4093,13 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	}\n" +
 				"}\n"
 			}, 
-			getCompilerOptions(), 
+			getCompilerOptions(),
+			"",
 			"78912345678");		
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422134, [1.8] NPE in NullAnnotationMatching with inlined lambda expression used with a raw type
 	public void test422134() {
-		runNegativeTest(
+		runNegativeTestWithLibs(
 			new String[] {
 				"X.java",
 				"import java.util.ArrayList;\n" +
@@ -4107,6 +4112,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	}\n" +
 				"}\n"
 			},
+			getCompilerOptions(),
 			"----------\n" + 
 			"1. WARNING in X.java (at line 5)\n" + 
 			"	Collections.sort(new ArrayList(), (o1, o2) -> {\n" + 
@@ -4130,15 +4136,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"	return o1.compareToIgnoreCase(o1);\n" + 
 			"	          ^^^^^^^^^^^^^^^^^^^\n" + 
 			"The method compareToIgnoreCase(Object) is undefined for the type Object\n" + 
-			"----------\n",
-			null,
-			true,
-			getCompilerOptions());		
+			"----------\n");		
 	}
 
 	// should not try to analyze arguments of a polymorphic method call
 	public void testBug424725() {
-		runConformTest(
+		runConformTestWithLibs(
 			new String[] {
 				"AnnotatedRecordMapper.java",
 				"import java.lang.invoke.MethodHandle;\n" + 
@@ -4157,7 +4160,9 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"    }\n" + 
 				"  }\n" + 
 				"}"
-			});
+			},
+			null,
+			"");
 	}
 
 	public void testBug424727() {
@@ -4247,17 +4252,19 @@ public void testBug424637a() {
 }
 
 public void testBug424637_comment3() {
-	runConformTest(
+	runConformTestWithLibs(
 		new String[] {
 			"VarArgsMethodReferenceTest.java",
 			"import java.util.function.Consumer;\n" + 
 			"public class VarArgsMethodReferenceTest {\n" + 
-			"  @SuppressWarnings(\"unused\") public static void main(String[] argv) {\n" + 
+			"  public static void main(String[] argv) {\n" + 
 			"    Consumer<String> printffer;\n" + 
 			"    printffer = System.out::printf;\n" + 
 			"  }\n" + 
 			"}"
-		});
+		},
+		null,
+		"");
 }
 public void testBug427163() {
 	runConformTestWithLibs(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index d5213d3..c754c83 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -22,6 +22,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 435570 - [1.8][null] @NonNullByDefault illegally tries to affect "throws E"
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -97,7 +98,7 @@ public abstract class AbstractMethodDeclaration
 	}
 	// version for invocation from LambdaExpression:
 	static void createArgumentBindings(Argument[] arguments, MethodBinding binding, MethodScope scope) {
-		boolean useTypeAnnotations = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
+		boolean useTypeAnnotations = scope.environment().usesNullTypeAnnotations();
 		if (arguments != null && binding != null) {
 			for (int i = 0, length = arguments.length; i < length; i++) {
 				Argument argument = arguments[i];
@@ -525,7 +526,7 @@ public abstract class AbstractMethodDeclaration
 			resolveAnnotations(this.scope, this.annotations, this.binding);
 			
 			long sourceLevel = this.scope.compilerOptions().sourceLevel;
-			validateNullAnnotations(sourceLevel);
+			validateNullAnnotations(this.scope.environment().usesNullTypeAnnotations());
 
 			resolveStatements();
 			// check @Deprecated annotation presence
@@ -644,10 +645,10 @@ public abstract class AbstractMethodDeclaration
 	    return null;
 	}
 
-	void validateNullAnnotations(long sourceLevel) {
+	void validateNullAnnotations(boolean useTypeAnnotations) {
 		if (this.binding == null) return;
 		// null annotations on parameters?
-		if (sourceLevel < ClassFileConstants.JDK1_8) {
+		if (!useTypeAnnotations) {
 			if (this.binding.parameterNonNullness != null) {
 				int length = this.binding.parameters.length;
 				for (int i=0; i<length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 423a447..b9fdecb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -19,6 +19,7 @@
  *								Bug 424728 - [1.8][null] Unexpected error: The nullness annotation 'XXXX' is not applicable at this location
  *								Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409517 - [1.8][compiler] Type annotation problems on more elaborate array references
@@ -38,6 +39,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
+import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
@@ -394,26 +396,21 @@ public abstract class Annotation extends Expression {
 				// seeing this id implies that null annotation analysis is enabled
 				Object value = null;
 				if (valueAttribute != null) {
-					if (valueAttribute.value instanceof FalseLiteral) {
-						// parameter 'false' means: this annotation cancels any defaults
-						tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-						break;
-					} else if (valueAttribute.compilerElementPair != null) {
+					if (valueAttribute.compilerElementPair != null)
 						value = valueAttribute.compilerElementPair.value;
-					}
-				} else if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) { // fetch default value  - TODO: cache it?
+				} else { // fetch default value  - TODO: cache it?
 					MethodBinding[] methods = annotationType.methods();
-					if (methods != null && methods.length == 1) {
-						Object defaultValue = methods[0].getDefaultValue();
-						if (defaultValue instanceof Object[])
-							value = defaultValue;
-					}
+					if (methods != null && methods.length == 1)
+						value = methods[0].getDefaultValue();
+					else
+						tagBits |= TagBits.AnnotationNonNullByDefault; // custom unconfigurable NNBD
 				}
-				if (value != null) {
-					tagBits |= nullTagBitsFromAnnotationValue(value);
-				} else {
-					// neither explicit value, nor default value from DefaultLocation (1.8)
-					tagBits |= TagBits.AnnotationNonNullByDefault;
+				if (value instanceof BooleanConstant) {
+					// boolean value is used for declaration annotations, signal using the annotation tag bit:
+					tagBits |= ((BooleanConstant)value).booleanValue() ? TagBits.AnnotationNonNullByDefault : TagBits.AnnotationNullUnspecifiedByDefault;
+				} else if (value != null) {
+					// non-boolean value signals type annotations, evaluate from DefaultLocation[] to bitvector a la Binding#NullnessDefaultMASK:
+					tagBits |= nullLocationBitsFromAnnotationValue(value);
 				}
 				break;
 		}
@@ -426,17 +423,17 @@ public abstract class Annotation extends Expression {
 	 * 
 	 * <b>pre:</b> null annotation analysis is enabled
 	 */
-	public static int nullTagBitsFromAnnotationValue(Object value) {
+	public static int nullLocationBitsFromAnnotationValue(Object value) {
 		if (value instanceof Object[]) {
-			if (((Object[]) value).length == 0) {
+			if (((Object[]) value).length == 0) {					// ({})
 				return Binding.NULL_UNSPECIFIED_BY_DEFAULT;
-			} else {
+			} else {												// ({vals...})
 				int bits = 0;
 				for (Object single : (Object[])value)
 					bits |= evaluateDefaultNullnessLocation(single);
 				return bits;
 			}
-		} else {
+		} else {													// (val)
 			return evaluateDefaultNullnessLocation(value);
 		}
 	}
@@ -449,6 +446,8 @@ public abstract class Annotation extends Expression {
 			name = ((EnumConstantSignature) value).getEnumConstantName();
 		} else if (value instanceof ElementValuePair.UnresolvedEnumConstant) {
 			name = ((ElementValuePair.UnresolvedEnumConstant) value).getEnumConstantName();
+		} else if (value instanceof BooleanConstant) {
+			return ((BooleanConstant)value).booleanValue() ? Binding.NONNULL_BY_DEFAULT : Binding.NULL_UNSPECIFIED_BY_DEFAULT;
 		}
 		if (name != null) {
 			switch (name.length) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index 6cfafac..d35d710 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -13,6 +13,7 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								Bug 417758 - [1.8][null] Null safety compromise during array creation.
  *								Bug 427438 - [1.8][compiler] NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280)
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -21,7 +22,6 @@ package org.eclipse.jdt.internal.compiler.ast;
 import static org.eclipse.jdt.internal.compiler.ast.ExpressionContext.ASSIGNMENT_CONTEXT;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -46,8 +46,7 @@ public class ArrayInitializer extends Expression {
 		if (this.expressions != null) {
 			CompilerOptions compilerOptions = currentScope.compilerOptions();
 			boolean analyseResources = compilerOptions.analyseResourceLeaks;
-			boolean evalNullTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 
-												&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;
+			boolean evalNullTypeAnnotations = currentScope.environment().usesNullTypeAnnotations();
 			for (int i = 0, max = this.expressions.length; i < max; i++) {
 				flowInfo = this.expressions[i].analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index db59433..f882caf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -21,6 +21,7 @@
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 427438 - [1.8][compiler] NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280)
  *								Bug 430150 - [1.8][null] stricter checking against type variables
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415541 - [1.8][compiler] Type annotations in the body of static initializer get dropped
  *******************************************************************************/
@@ -89,7 +90,7 @@ public static void checkNeedForAssignedCast(BlockScope scope, TypeBinding expect
 	if (castedExpressionType == null || rhs.resolvedType.isBaseType()) return;
 	//if (castedExpressionType.id == T_null) return; // tolerate null expression cast
 	if (castedExpressionType.isCompatibleWith(expectedType, scope)) {
-		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+		if (scope.environment().usesNullTypeAnnotations()) {
 			// are null annotations compatible, too?
 			if (NullAnnotationMatching.analyse(expectedType, castedExpressionType, -1).isAnyMismatch())
 				return; // already reported unchecked cast (nullness), say no more.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index d3ec909..664dea0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,6 +19,7 @@
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415399 - [1.8][compiler] Type annotations on constructor results dropped by the code generator
  *******************************************************************************/
@@ -142,10 +143,10 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 		}
 
 		// nullity and mark as assigned
-		if (classScope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)
-			analyseArguments(flowInfo, this.arguments, this.binding);
-		else
+		if (classScope.environment().usesNullTypeAnnotations())
 			analyseArguments18(flowInfo, this.arguments, this.binding);
+		else
+			analyseArguments(flowInfo, this.arguments, this.binding);
 
 		// propagate to constructor call
 		if (this.constructorCall != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index f7c18c0..a8e0381 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -18,6 +18,7 @@
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *								Bug 438012 - [1.8][null] Bogus Warning: The nullness annotation is redundant with a default that applies to this location
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -106,10 +107,10 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 					FlowInfo.DEAD_END);
 
 			// nullity and mark as assigned
-			if (classScope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)
-				analyseArguments(flowInfo, this.arguments, this.binding);
-			else
+			if (classScope.environment().usesNullTypeAnnotations())
 				analyseArguments18(flowInfo, this.arguments, this.binding);
+			else
+				analyseArguments(flowInfo, this.arguments, this.binding);
 
 			if (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {
 				// method of a non-static member type can't be static.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index ca0929a..270349c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -10,7 +10,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -82,7 +81,7 @@ public class NullAnnotationMatching {
 	{
 		long lhsTagBits = 0L;
 		boolean hasReported = false;
-		if (currentScope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {
+		if (!currentScope.environment().usesNullTypeAnnotations()) {
 			lhsTagBits = var.tagBits & TagBits.AnnotationNullMASK;
 		} else {
 			if (expression instanceof ConditionalExpression && expression.isPolyExpression()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 038e860..0aafbc1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -30,6 +30,7 @@
  *								Bug 417758 - [1.8][null] Null safety compromise during array creation.
  *								Bug 427438 - [1.8][compiler] NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280)
  *								Bug 430150 - [1.8][null] stricter checking against type variables
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -38,7 +39,6 @@ package org.eclipse.jdt.internal.compiler.ast;
 import static org.eclipse.jdt.internal.compiler.ast.ExpressionContext.ASSIGNMENT_CONTEXT;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
@@ -174,7 +174,7 @@ void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, FlowI
 	int nullStatus = this.expression.nullStatus(flowInfo, flowContext);
 	long tagBits;
 	MethodBinding methodBinding = null;
-	boolean useTypeAnnotations = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
+	boolean useTypeAnnotations = scope.environment().usesNullTypeAnnotations();
 	try {
 		methodBinding = scope.methodScope().referenceMethodBinding();
 		tagBits = (useTypeAnnotations) ? methodBinding.returnType.tagBits : methodBinding.tagBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 1eab49a..bfa50da 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -29,6 +29,7 @@
  *								Bug 418537 - [1.8][null] Fix null type annotation analysis for poly conditional expressions
  *								Bug 428352 - [1.8][compiler] Resolution errors don't always surface
  *								Bug 429430 - [1.8] Lambdas and method reference infer wrong exception type with generics (RuntimeException instead of IOException)
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
@@ -90,8 +91,7 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 		CompilerOptions compilerOptions = currentScope.compilerOptions();
 		if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_7 && methodBinding.isPolymorphic())
 			return;
-		boolean considerTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8
-				&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;
+		boolean considerTypeAnnotations = currentScope.environment().usesNullTypeAnnotations();
 		boolean hasJDK15NullAnnotations = methodBinding.parameterNonNullness != null;
 		int numParamsToCheck = methodBinding.parameters.length;
 		int varArgPos = -1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 6a8a37c..0a2d8f1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -21,6 +21,7 @@
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 435570 - [1.8][null] @NonNullByDefault illegally tries to affect "throws E"
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -33,7 +34,6 @@ import java.util.List;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationContext;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
@@ -651,9 +651,7 @@ public int getAnnotatableLevels() {
 }
 /** Check all typeArguments against null constraints on their corresponding type variables. */
 protected void checkNullConstraints(Scope scope, TypeReference[] typeArguments) {
-	CompilerOptions compilerOptions = scope.compilerOptions();
-	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled
-			&& compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8
+	if (scope.environment().usesNullTypeAnnotations()
 			&& typeArguments != null)
 	{
 		TypeVariableBinding[] typeVariables = this.resolvedType.original().typeVariables();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index e85734b..7c5f157 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,6 +19,7 @@
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
@@ -456,6 +457,9 @@ public class CompilerOptions {
 	public boolean complainOnUninternedIdentityComparison;
 	public boolean emulateJavacBug8031744 = true;
 
+	/** Not directly configurable, derived from other options by LookupEnvironment.usesNullTypeAnnotations() */
+	public Boolean useNullTypeAnnotations = null;
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 332b272..08b6e63 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -30,6 +30,7 @@
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
  *								Bug 441693 - [1.8][null] Bogus warning for type argument annotated with @NonNull
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -45,7 +46,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.NonNullDefaultAwareTypeAnnotat
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.env.*;
-import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
@@ -402,7 +402,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		 */
 		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
 			// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
-			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage, this);
+			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage);
 		}
 		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
@@ -1523,10 +1523,6 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 
 private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
 	if (!isPrototype()) throw new IllegalStateException();
-	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
-		return;
-	boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
-	// in 1.8 we only need @NonNullByDefault, see below and exit further down.
 	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
 	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
 	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
@@ -1535,7 +1531,6 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 
 	// return:
 	IBinaryAnnotation[] annotations = method.getAnnotations();
-	boolean explicitNullness = false;
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
 			char[] annotationTypeName = annotations[i].getTypeName();
@@ -1543,25 +1538,19 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 				continue;
 			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
 			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
-				methodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
-				if (useTypeAnnotations)
-					methodBinding.defaultNullness = getNonNullByDefaultValue(annotations[i]);
-			}
-			if (!useTypeAnnotations && !explicitNullness) {
-				if (CharOperation.equals(typeName, nonNullAnnotationName)) {
-					methodBinding.tagBits |= TagBits.AnnotationNonNull;
-					explicitNullness = true;
-				} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
-					methodBinding.tagBits |= TagBits.AnnotationNullable;
-					explicitNullness = true;
-				}
+				methodBinding.defaultNullness = getNonNullByDefaultValue(annotations[i]);
+				if (methodBinding.defaultNullness == Binding.NULL_UNSPECIFIED_BY_DEFAULT)
+					methodBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+				else if (methodBinding.defaultNullness != 0)
+					methodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
+			} else if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				methodBinding.tagBits |= TagBits.AnnotationNonNull;
+			} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				methodBinding.tagBits |= TagBits.AnnotationNullable;
 			}
 		}
 	}
 
-	if (useTypeAnnotations)
-		return;
-
 	// parameters:
 	TypeBinding[] parameters = methodBinding.parameters;
 	int numVisibleParams = parameters.length;
@@ -1595,15 +1584,14 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 	}
 }
 // pre: null annotation analysis is enabled
-private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBinding packageBinding, BinaryTypeBinding binaryBinding) {
+private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBinding packageBinding) {
 	if (!isPrototype()) throw new IllegalStateException();
 	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
 	if (nonNullByDefaultAnnotationName == null)
 		return; // not well-configured to use null annotations
 
 	IBinaryAnnotation[] annotations = binaryType.getAnnotations();
-	boolean isPackageInfo = CharOperation.equals(binaryBinding.sourceName(), TypeConstants.PACKAGE_INFO_NAME);
-	boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+	boolean isPackageInfo = CharOperation.equals(sourceName(), TypeConstants.PACKAGE_INFO_NAME);
 	if (annotations != null) {
 		long annotationBit = 0L;
 		int nullness = NO_NULL_DEFAULT;
@@ -1614,37 +1602,19 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 				continue;
 			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
 			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
-				IBinaryElementValuePair[] elementValuePairs = annotations[i].getElementValuePairs();
-				if (!useTypeAnnotations) {
-					if (elementValuePairs != null && elementValuePairs.length == 1) {
-						Object value = elementValuePairs[0].getValue();
-						if (value instanceof BooleanConstant
-							&& !((BooleanConstant)value).booleanValue())
-						{
-							// parameter is 'false': this means we cancel defaults from outer scopes:
-							annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
-							nullness = NULL_UNSPECIFIED_BY_DEFAULT;
-							break;
-						}
-					}
-				} else {
-					// using NonNullByDefault we need to inspect the details of the value() attribute:
-					nullness = getNonNullByDefaultValue(annotations[i]);
-					if (nullness == NULL_UNSPECIFIED_BY_DEFAULT) {
-						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
-					} else if (nullness != 0) {
-						annotationBit = TagBits.AnnotationNonNullByDefault;
-					}	
-					this.defaultNullness = nullness;
-					break;
+				// using NonNullByDefault we need to inspect the details of the value() attribute:
+				nullness = getNonNullByDefaultValue(annotations[i]);
+				if (nullness == NULL_UNSPECIFIED_BY_DEFAULT) {
+					annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
+				} else if (nullness != 0) {
+					annotationBit = TagBits.AnnotationNonNullByDefault;
 				}
-				annotationBit = TagBits.AnnotationNonNullByDefault;
-				nullness = NONNULL_BY_DEFAULT;
+				this.defaultNullness = nullness;
 				break;
 			}
 		}
 		if (annotationBit != 0L) {
-			binaryBinding.tagBits |= annotationBit;
+			this.tagBits |= annotationBit;
 			if (isPackageInfo)
 				packageBinding.defaultNullness = nullness;
 			return;
@@ -1652,25 +1622,13 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 	}
 	if (isPackageInfo) {
 		// no default annotations found in package-info
-		packageBinding.defaultNullness = Binding.NULL_UNSPECIFIED_BY_DEFAULT;
+		packageBinding.defaultNullness = Binding.NO_NULL_DEFAULT;
 		return;
 	}
-	ReferenceBinding enclosingTypeBinding = binaryBinding.enclosingType;
+	ReferenceBinding enclosingTypeBinding = this.enclosingType;
 	if (enclosingTypeBinding != null) {
-		if (useTypeAnnotations) {
-			binaryBinding.defaultNullness = enclosingTypeBinding.getNullDefault();
-			if (binaryBinding.defaultNullness != 0) {
-				return;
-			}
-		} else {
-			if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
-				binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
-				return;
-			} else if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
-				binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-				return;
-			}
-		}
+		if (setNullDefault(enclosingTypeBinding.tagBits, enclosingTypeBinding.getNullDefault()))
+			return;
 	}
 	// no annotation found on the type or its enclosing types
 	// check the package-info for default annotation if not already done before
@@ -1678,22 +1636,30 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 		// this will scan the annotations in package-info
 		ReferenceBinding packageInfo = packageBinding.getType(TypeConstants.PACKAGE_INFO_NAME);
 		if (packageInfo == null) {
-			packageBinding.defaultNullness = Binding.NULL_UNSPECIFIED_BY_DEFAULT;
+			packageBinding.defaultNullness = Binding.NO_NULL_DEFAULT;
 		}
 	}
 	// no @NonNullByDefault at type level, check containing package:
-	if (useTypeAnnotations) {
-		binaryBinding.defaultNullness = packageBinding.defaultNullness;
-	} else {
-		switch (packageBinding.defaultNullness) {
-			case Binding.NONNULL_BY_DEFAULT : 
-				binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
-				break;
-			case Binding.NULL_UNSPECIFIED_BY_DEFAULT :
-				binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-				break;
-		}
+	setNullDefault(0L, packageBinding.defaultNullness);
+}
+
+boolean setNullDefault(long oldNullTagBits, int newNullDefault) {
+	this.defaultNullness = newNullDefault;
+	if (newNullDefault != 0) {
+		if (newNullDefault == Binding.NULL_UNSPECIFIED_BY_DEFAULT)
+			this.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+		else
+			this.tagBits |= TagBits.AnnotationNonNullByDefault;
+		return true;
+	}
+	if ((oldNullTagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+		this.tagBits |= TagBits.AnnotationNonNullByDefault;
+		return true;
+	} else if ((oldNullTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
+		this.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+		return true;
 	}
+	return false;
 }
 
 /** given an application of @NonNullByDefault convert the annotation argument (if any) into a bitvector a la {@link Binding#NullnessDefaultMASK} */
@@ -1711,19 +1677,19 @@ int getNonNullByDefaultValue(IBinaryAnnotation annotation) {
 		MethodBinding[] annotationMethods = annotationType.methods();
 		if (annotationMethods != null && annotationMethods.length == 1) {
 			Object value = annotationMethods[0].getDefaultValue();
-			return Annotation.nullTagBitsFromAnnotationValue(value);
+			return Annotation.nullLocationBitsFromAnnotationValue(value);
 		}
+		return NONNULL_BY_DEFAULT; // custom unconfigurable NNBD
 	} else if (elementValuePairs.length > 0) {
 		// evaluate the contained EnumConstantSignatures:
 		int nullness = 0;
 		for (int i = 0; i < elementValuePairs.length; i++)
-			nullness |= Annotation.nullTagBitsFromAnnotationValue(elementValuePairs[i].getValue());
+			nullness |= Annotation.nullLocationBitsFromAnnotationValue(elementValuePairs[i].getValue());
 		return nullness;
 	} else {
 		// empty argument: cancel all defaults from enclosing scopes
 		return NULL_UNSPECIFIED_BY_DEFAULT;
 	}
-	return 0;
 }
 
 @Override
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index a11f3ea..e905582 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -12,6 +12,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 447088 - [null] @Nullable on fully qualified field type is ignored
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -234,10 +235,10 @@ public void fillInDefaultNonNullness(FieldDeclaration sourceField, Scope scope)
 		&& (this.tagBits & TagBits.AnnotationNullMASK) == 0 		// declaration annotation?
 		&& (this.type.tagBits & TagBits.AnnotationNullMASK) == 0)	// type annotation? (java.lang.@Nullable String)
 	{
-		if (environment.globalOptions.sourceLevel < ClassFileConstants.JDK1_8)
-			this.tagBits |= TagBits.AnnotationNonNull;
-		else
+		if (environment.usesNullTypeAnnotations())
 			this.type = environment.createAnnotatedType(this.type, new AnnotationBinding[]{environment.getNonNullAnnotation()});
+		else
+			this.tagBits |= TagBits.AnnotationNonNull;
 	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
 		scope.problemReporter().nullAnnotationIsRedundant(sourceField);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 366e3b7..36e08a6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -21,7 +21,6 @@ import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 /**
@@ -75,11 +74,11 @@ public class ImplicitNullAnnotationVerifier {
 			if (currentType.id == TypeIds.T_JavaLangObject) {
 				return;
 			}
-			long sourceLevel = scope.compilerOptions().sourceLevel;
+			boolean usesTypeAnnotations = scope.environment().usesNullTypeAnnotations();
 			boolean needToApplyReturnNonNullDefault =
-					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, sourceLevel >= ClassFileConstants.JDK1_8);
+					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, usesTypeAnnotations);
 			boolean needToApplyParameterNonNullDefault =
-					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, sourceLevel >= ClassFileConstants.JDK1_8);
+					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, usesTypeAnnotations);
 			boolean needToApplyNonNullDefault = needToApplyReturnNonNullDefault | needToApplyParameterNonNullDefault;
 			// compatibility & inheritance do not consider constructors / static methods:
 			boolean isInstanceMethod = !currentMethod.isConstructor() && !currentMethod.isStatic();
@@ -127,7 +126,7 @@ public class ImplicitNullAnnotationVerifier {
 						tagBits = TagBits.AnnotationNullable;
 					}
 					if (tagBits != 0) {
-						if (sourceLevel < ClassFileConstants.JDK1_8) {
+						if (!usesTypeAnnotations) {
 							currentMethod.tagBits |= tagBits;
 						} else {
 							if (!currentMethod.returnType.isBaseType()) {
@@ -141,7 +140,7 @@ public class ImplicitNullAnnotationVerifier {
 					info = inheritedNonNullnessInfos[i+1];
 					if (!info.complained && info.inheritedNonNullness != null) {
 						Argument currentArg = srcMethod == null ? null : srcMethod.arguments[i];
-						if (sourceLevel < ClassFileConstants.JDK1_8)
+						if (!usesTypeAnnotations)
 							recordArgNonNullness(currentMethod, paramLen, i, currentArg, info.inheritedNonNullness);
 						else
 							recordArgNonNullness18(currentMethod, i, currentArg, info.inheritedNonNullness, scope.environment());
@@ -150,7 +149,7 @@ public class ImplicitNullAnnotationVerifier {
 
 			}
 			if (needToApplyNonNullDefault) {
-				if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)
+				if (!usesTypeAnnotations)
 					currentMethod.fillInDefaultNonNullness(srcMethod);
 				else
 					currentMethod.fillInDefaultNonNullness18(srcMethod, scope.environment());
@@ -237,7 +236,7 @@ public class ImplicitNullAnnotationVerifier {
 			// TODO (stephan): even here we may need to report problems? How to discriminate?
 			this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(inheritedMethod, null, false, scope);
 		}
-		boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+		boolean useTypeAnnotations = this.environment.usesNullTypeAnnotations();
 		long inheritedNullnessBits = getReturnTypeNullnessTagBits(inheritedMethod, useTypeAnnotations);
 		long currentNullnessBits = getReturnTypeNullnessTagBits(currentMethod, useTypeAnnotations);
 		
@@ -427,12 +426,12 @@ public class ImplicitNullAnnotationVerifier {
 	}
 
 	void applyReturnNullBits(MethodBinding method, long nullnessBits) {
-		if (this.environment.globalOptions.sourceLevel < ClassFileConstants.JDK1_8) {
-			method.tagBits |= nullnessBits;
-		} else {
+		if (this.environment.usesNullTypeAnnotations()) {
 			if (!method.returnType.isBaseType()) {
 				method.returnType = this.environment.createAnnotatedType(method.returnType, this.environment.nullAnnotationsFromTagBits(nullnessBits));
 			}
+		} else {
+			method.tagBits |= nullnessBits;
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
index e7a42f0..85c20b3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
@@ -11,6 +11,7 @@
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations 
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -107,13 +108,13 @@ public ReferenceBinding anonymousOriginalSuperType() {
 	return this.superclass; // default answer
 }
 
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
 	long outerDefault = 0;
 	if (this.enclosingMethod != null) {
-		outerDefault = isJdk18 
+		outerDefault = useNullTypeAnnotations 
 				? this.enclosingMethod.defaultNullness 
 				: this.enclosingMethod.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
 	}
@@ -123,7 +124,7 @@ protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation
 		}
 		return;
 	}
-	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, isJdk18);
+	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, useNullTypeAnnotations);
 }
 
 public char[] computeUniqueKey(boolean isLeaf) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 087adab..889f3ea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -27,6 +27,7 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1075,6 +1076,28 @@ public char[][] getNonNullByDefaultAnnotationName() {
 	return this.globalOptions.nonNullByDefaultAnnotationName;
 }
 
+public boolean usesNullTypeAnnotations() {
+	if (this.globalOptions.useNullTypeAnnotations != null)
+		return this.globalOptions.useNullTypeAnnotations;
+
+	this.globalOptions.useNullTypeAnnotations = Boolean.FALSE;
+	if (!this.globalOptions.isAnnotationBasedNullAnalysisEnabled || this.globalOptions.sourceLevel < ClassFileConstants.JDK1_8)
+		return false;
+	ReferenceBinding nullable = this.nullableAnnotation != null ? this.nullableAnnotation.getAnnotationType() : getType(this.getNullableAnnotationName());
+	ReferenceBinding nonNull = this.nonNullAnnotation != null ? this.nonNullAnnotation.getAnnotationType() : getType(this.getNonNullAnnotationName());
+	if (nullable == null && nonNull == null)
+		return false;
+	if (nullable == null || nonNull == null)
+		return false; // TODO should report an error about inconsistent setup
+	long nullableMetaBits = nullable.getAnnotationTagBits() & TagBits.AnnotationForTypeUse;
+	long nonNullMetaBits = nonNull.getAnnotationTagBits() & TagBits.AnnotationForTypeUse;
+	if (nullableMetaBits != nonNullMetaBits)
+		return false; // TODO should report an error about inconsistent setup
+	if (nullableMetaBits == 0)
+		return false;
+	return this.globalOptions.useNullTypeAnnotations = Boolean.TRUE;
+}
+
 /* Answer the top level package named name if it exists in the cache.
 * Answer theNotFoundPackage if it could not be resolved the first time
 * it was looked up, otherwise answer null.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 38b5808..34a48dc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -23,6 +23,7 @@
  *								Bug 438012 - [1.8][null] Bogus Warning: The nullness annotation is redundant with a default that applies to this location
  *								Bug 440759 - [1.8][null] @NonNullByDefault should never affect wildcards and uses of a type variable
  *								Bug 443347 - [1.8][null] @NonNullByDefault should not affect constructor arguments of an anonymous instantiation
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *     Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *******************************************************************************/
@@ -635,13 +636,13 @@ public long getAnnotationTagBits() {
 				ASTNode.resolveAnnotations(methodDecl.scope, methodDecl.annotations, originalMethod);
 			CompilerOptions options = scope.compilerOptions();
 			if (options.isAnnotationBasedNullAnalysisEnabled) {
-				boolean isJdk18 = options.sourceLevel >= ClassFileConstants.JDK1_8;
-				long nullDefaultBits = isJdk18 ? this.defaultNullness
+				boolean usesNullTypeAnnotations = scope.environment().usesNullTypeAnnotations();
+				long nullDefaultBits = usesNullTypeAnnotations ? this.defaultNullness
 						: this.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
 				if (nullDefaultBits != 0 && this.declaringClass instanceof SourceTypeBinding) {
 					SourceTypeBinding declaringSourceType = (SourceTypeBinding) this.declaringClass;
-					if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits, isJdk18)) {
-						declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits, isJdk18);
+					if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations)) {
+						declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index aa7c1e3..359f71e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -27,6 +27,7 @@
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *								Bug 390889 - [1.8][compiler] Evaluate options to support 1.7- projects against 1.8 JRE.
  *								Bug 440773 - [1.8][null]DefaultLocation.RETURN_TYPE erroneously affects method parameters in @NonNullByDefault
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -77,7 +78,7 @@ void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[]
 	AbstractMethodDeclaration srcMethod = null;
 	if (analyseNullAnnotations && this.type.equals(concreteMethod.declaringClass)) // is currentMethod from the current type?
 		srcMethod = concreteMethod.sourceMethod();
-	boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+	boolean useTypeAnnotations = this.environment.usesNullTypeAnnotations();
 	boolean hasReturnNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations);
 	boolean hasParameterNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations);
 
@@ -394,7 +395,7 @@ void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] m
 		AbstractMethodDeclaration srcMethod = null;
 		if (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?
 			srcMethod = currentMethod.sourceMethod();
-		boolean useTypeAnnotations = options.sourceLevel >= ClassFileConstants.JDK1_8;
+		boolean useTypeAnnotations = this.environment.usesNullTypeAnnotations();
 		boolean hasReturnNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations);
 		boolean hasParameterNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations);
 		for (int i = length; --i >= 0;)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
index ec4ef6c..ea05b96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								Bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations 
  *     Keigo Imai - Contribution for  bug 388903 - Cannot extend inner class as an anonymous class when it extends the outer class
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
@@ -125,16 +126,16 @@ public SyntheticArgumentBinding addSyntheticArgumentAndField(ReferenceBinding ta
 	return synthLocal;
 }
 
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
 	if (!isPrototype()) throw new IllegalStateException();
 	ReferenceBinding currentType = this.enclosingType;
 	do {
-		if (!((SourceTypeBinding)currentType).checkRedundantNullnessDefaultOne(location, annotations, nullBits, isJdk18)) {
+		if (!((SourceTypeBinding)currentType).checkRedundantNullnessDefaultOne(location, annotations, nullBits, useNullTypeAnnotations)) {
 			return;
 		}
 		currentType = currentType.enclosingType();
 	} while (currentType instanceof SourceTypeBinding);
-	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, isJdk18);
+	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, useNullTypeAnnotations);
 }
 
 /* Answer the receiver's enclosing type... null if the receiver is a top level type.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 489ad06..4a836e0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -36,6 +36,7 @@
  *								Bug 438179 - [1.8][null] 'Contradictory null annotations' error on type variable with explicit null-annotation.
  *								Bug 441693 - [1.8][null] Bogus warning for type argument annotated with @NonNull
  *								Bug 446434 - [1.8][null] Enable interned captures also when analysing null type annotations
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -680,8 +681,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		    if (length == 0) return Binding.NO_METHODS;
 
 		    parameterizedMethods = new MethodBinding[length];
-		    CompilerOptions options = this.environment.globalOptions;
-			boolean useNullTypeAnnotations = options.isAnnotationBasedNullAnalysisEnabled && options.sourceLevel >= ClassFileConstants.JDK1_8;
+			boolean useNullTypeAnnotations = this.environment.usesNullTypeAnnotations();
 		    for (int i = 0; i < length; i++) {
 		    	// substitute methods, so as to get updated declaring class at least
 	            parameterizedMethods[i] = createParameterizedMethod(originalMethods[i]);
@@ -962,8 +962,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		    MethodBinding[] originalMethods = this.type.methods();
 		    int length = originalMethods.length;
 		    MethodBinding[] parameterizedMethods = new MethodBinding[length];
-		    CompilerOptions options = this.environment.globalOptions;
-			boolean useNullTypeAnnotations = options.isAnnotationBasedNullAnalysisEnabled && options.sourceLevel >= ClassFileConstants.JDK1_8;
+			boolean useNullTypeAnnotations = this.environment.usesNullTypeAnnotations();
 		    for (int i = 0; i < length; i++) {
 		    	// substitute all methods, so as to get updated declaring class at least
 	            parameterizedMethods[i] = createParameterizedMethod(originalMethods[i]);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 4dc56a8..e55ba4b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -35,6 +35,7 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 435570 - [1.8][null] @NonNullByDefault illegally tries to affect "throws E"
  *								Bug 441693 - [1.8][null] Bogus warning for type argument annotated with @NonNull
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *      Till Brychcy - Contributions for
@@ -1955,16 +1956,16 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 			long nullTagBits = method.tagBits & TagBits.AnnotationNullMASK;
 			if (nullTagBits != 0) {
 				TypeReference returnTypeRef = ((MethodDeclaration)methodDecl).returnType;
-				if (compilerOptions.sourceLevel < ClassFileConstants.JDK1_8) {
-					if (!this.scope.validateNullAnnotation(nullTagBits, returnTypeRef, methodDecl.annotations))
-						method.tagBits &= ~TagBits.AnnotationNullMASK;
-				} else {
+				if (this.scope.environment().usesNullTypeAnnotations()) {
 					if (nullTagBits != (method.returnType.tagBits & TagBits.AnnotationNullMASK)) {
 						if (!this.scope.validateNullAnnotation(nullTagBits, returnTypeRef, methodDecl.annotations)) {
 							method.returnType.tagBits &= ~TagBits.AnnotationNullMASK;
 						}
 						method.tagBits &= ~TagBits.AnnotationNullMASK;
 					}
+				} else {
+					if (!this.scope.validateNullAnnotation(nullTagBits, returnTypeRef, methodDecl.annotations))
+						method.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
 			}
 		}
@@ -2035,14 +2036,14 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 		}
 	}
 	this.nullnessDefaultInitialized = 1;
-	boolean isJdk18 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
-	if (isJdk18) {
+	boolean usesNullTypeAnnotations = this.scope.environment().usesNullTypeAnnotations();
+	if (usesNullTypeAnnotations) {
 		if (this.defaultNullness != 0) {
 			if (isPackageInfo) {
 				pkg.defaultNullness = this.defaultNullness;
 			} else {
 				TypeDeclaration typeDecl = this.scope.referenceContext;
-				checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, this.defaultNullness, isJdk18);
+				checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, this.defaultNullness, true);
 			}
 		} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
 			this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
@@ -2050,12 +2051,22 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 				pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
 		}
 	} else {
-		// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
+		// transfer nullness info from tagBits to this.defaultNullness
 		int newDefaultNullness = NO_NULL_DEFAULT;
-		if ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+		if ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
 			newDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
-		else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)
+		} else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0) {
 			newDefaultNullness = NONNULL_BY_DEFAULT;
+		} else if (this.defaultNullness != 0) {
+			 // NNBD with argument while NN & NU are SE5 annotations, revert to old default & encoding.
+			if (this.defaultNullness == NULL_UNSPECIFIED_BY_DEFAULT) {
+				annotationTagBits = TagBits.AnnotationNullUnspecifiedByDefault;
+				newDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+			} else {
+				annotationTagBits = TagBits.AnnotationNonNullByDefault;
+				newDefaultNullness = NONNULL_BY_DEFAULT;
+			}
+		}
 		if (newDefaultNullness != NO_NULL_DEFAULT) {
 			if (isPackageInfo) {
 				pkg.defaultNullness = newDefaultNullness;
@@ -2092,17 +2103,17 @@ private void maybeMarkTypeParametersNonNull() {
  * Recursively check if the given annotations are redundant with equal annotations at an enclosing level.
  * @param location fallback location to report the warning against (if we can't blame a specific annotation)
  * @param annotations search these for the annotation that should be blamed in warning messages
- * @param nullBits in 1.7- times these are the annotationTagBits, in 1.8+ the bitvector from {@link Binding#NullnessDefaultMASK}
- * @param isJdk18 toggles the interpretation of 'nullBits'
+ * @param nullBits when using declaration annotations these are the annotationTagBits, for type annotations the bitvector from {@link Binding#NullnessDefaultMASK}
+ * @param useNullTypeAnnotations toggles the interpretation of 'nullBits'
  * 
  * @pre null annotation analysis is enabled
  */
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
 	if (this.fPackage.defaultNullness != NO_NULL_DEFAULT) {
-		boolean isRedundant = isJdk18
+		boolean isRedundant = useNullTypeAnnotations
 				? this.fPackage.defaultNullness == nullBits
 				: (this.fPackage.defaultNullness == NONNULL_BY_DEFAULT
 						&& ((nullBits & TagBits.AnnotationNonNullByDefault) != 0));
@@ -2114,13 +2125,13 @@ protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation
 }
 
 // return: should caller continue searching?
-protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
+protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
 	int thisDefault = getNullDefault();
 	if (thisDefault != NO_NULL_DEFAULT) {
-		boolean isRedundant = isJdk18
+		boolean isRedundant = useNullTypeAnnotations
 				? thisDefault == nullBits
 				: (nullBits & TagBits.AnnotationNonNullByDefault) != 0;
 		if (isRedundant) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index ddc9502..6e9767b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -53,6 +53,7 @@
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
  *								Bug 439298 - [null] "Missing code implementation in the compiler" when using @NonNullByDefault in package-info.java
+ *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -9184,15 +9185,15 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 		nullityMismatchPotentiallyNull(expression, requiredType, annotationName);
 		return;
 	}
-	if (this.options.sourceLevel < ClassFileConstants.JDK1_8)
-		nullityMismatchIsUnknown(expression, providedType, requiredType, annotationName);
-	else
+	if (this.options.useNullTypeAnnotations == Boolean.TRUE)
 		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, NullAnnotationMatching.NULL_ANNOTATIONS_UNCHECKED);
+	else
+		nullityMismatchIsUnknown(expression, providedType, requiredType, annotationName);
 }
 public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType) {
 	int problemId = IProblem.RequiredNonNullButProvidedNull;
-	boolean below18 = this.options.sourceLevel < ClassFileConstants.JDK1_8;
-	if (!below18 && requiredType.isTypeVariable() && !requiredType.hasNullTypeAnnotations())
+	boolean useNullTypeAnnotations = this.options.useNullTypeAnnotations == Boolean.TRUE;
+	if (useNullTypeAnnotations && requiredType.isTypeVariable() && !requiredType.hasNullTypeAnnotations())
 		problemId = IProblem.NullNotCompatibleToFreeTypeVariable;
 	if (requiredType instanceof CaptureBinding) {
 		CaptureBinding capture = (CaptureBinding) requiredType;
@@ -9201,7 +9202,7 @@ public void nullityMismatchIsNull(Expression expression, TypeBinding requiredTyp
 	}
 	String[] arguments;
 	String[] argumentsShort;
-	if (below18) {
+	if (!useNullTypeAnnotations) {
 		arguments      = new String[] { annotatedTypeName(requiredType, this.options.nonNullAnnotationName) };
 		argumentsShort = new String[] { shortAnnotatedTypeName(requiredType, this.options.nonNullAnnotationName) };
 	} else {
@@ -9349,7 +9350,7 @@ public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDe
 	TypeBinding inheritedReturnType = inheritedMethod.returnType;
 	String[] arguments;
 	String[] argumentsShort;
-	if (this.options.complianceLevel < ClassFileConstants.JDK1_8) {
+	if (this.options.useNullTypeAnnotations != Boolean.TRUE) {
 		StringBuilder returnType = new StringBuilder();
 		returnType.append('@').append(CharOperation.concatWith(nonNullAnnotationName, '.'));
 		returnType.append(' ').append(inheritedReturnType.readableName());
