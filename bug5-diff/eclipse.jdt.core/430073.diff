commit 6917637e4d94d6b430f2f9b2341abe83418f5e26
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Wed Apr 23 13:44:05 2014 +0530

    Bug 430073 - [1.8][model] Lambda model elements hierarchy needs rewiring

43	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
35	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaMethod.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
9	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
103	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
1	62	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
new file mode 100644
index 0000000..f39b00a
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.jdt.core.IJavaElement;
+
+
+public class BinaryLambdaExpression extends LambdaExpression {
+
+	BinaryLambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
+		super(parent, lambdaExpression);
+	}
+
+	BinaryLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+		super(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+	}
+
+	BinaryLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
+		super(parent, name, interphase, sourceStart, sourceEnd, arrowPosition, lambdaMethod);
+	}
+
+	/*
+	 * @see JavaElement#getPrimaryElement(boolean)
+	 */
+	public IJavaElement getPrimaryElement(boolean checkOwner) {
+		return this;
+	}
+
+	/*
+	 * @see IMember#isBinary()
+	 */
+	public boolean isBinary() {
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaMethod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaMethod.java
new file mode 100644
index 0000000..ee19f6c
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaMethod.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.jdt.core.IJavaElement;
+
+public class BinaryLambdaMethod extends LambdaMethod {
+
+	BinaryLambdaMethod(JavaElement parent, String name, String key, int sourceStart, String [] parameterTypes, String [] parameterNames, String returnType, SourceMethodElementInfo elementInfo) {
+		super(parent, name, key, sourceStart, parameterTypes, parameterNames, returnType, elementInfo);
+	}
+
+	/*
+	 * @see JavaElement#getPrimaryElement(boolean)
+	 */
+	public IJavaElement getPrimaryElement(boolean checkOwner) {
+		return this;
+	}
+
+	/*
+	 * @see IMember#isBinary()
+	 */
+	public boolean isBinary() {
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
index 2206781..a2ced80 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
@@ -391,6 +391,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			params.toArray(parameters);
 			JavaElement method = (JavaElement)getMethod(selector, parameters);
 			switch (token.charAt(0)) {
+				case JEM_LAMBDA_EXPRESSION:
 				case JEM_TYPE:
 				case JEM_TYPE_PARAMETER:
 				case JEM_LOCALVARIABLE:
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
index 8930995..4ce643f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
@@ -14,6 +14,7 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.ILocalVariable;
 import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.WorkingCopyOwner;
@@ -36,7 +37,7 @@ public class LambdaExpression extends SourceType {
 	
 	
 	// Construction from AST node
-	public LambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
+	LambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
 		super(parent, new String(CharOperation.NO_CHAR));
 		this.resolvedTypeName = new String(lambdaExpression.resolvedType.sourceName());
 		this.sourceStart = lambdaExpression.sourceStart;
@@ -44,12 +45,12 @@ public class LambdaExpression extends SourceType {
 		this.arrowPosition = lambdaExpression.arrowPosition;
 		this.interphase = new String(CharOperation.replaceOnCopy(lambdaExpression.resolvedType.genericTypeSignature(), '/', '.'));
 		this.elementInfo = makeTypeElementInfo(this, this.interphase, this.sourceStart, this.sourceEnd, this.arrowPosition); 
-		this.lambdaMethod = LambdaMethod.make(this, lambdaExpression);
+		this.lambdaMethod = LambdaFactory.createLambdaMethod(this, lambdaExpression);
 		this.elementInfo.children = new IJavaElement[] { this.lambdaMethod };
 	}
 	
 	// Construction from memento
-	public LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+	LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
 		super(parent, new String(CharOperation.NO_CHAR));
 		this.resolvedTypeName = resolvedTypeName;
 		this.sourceStart = sourceStart;
@@ -61,7 +62,7 @@ public class LambdaExpression extends SourceType {
 	}
 	
 	// Construction from subtypes.
-	public LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
+	LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
 		super(parent, new String(CharOperation.NO_CHAR));
 		this.resolvedTypeName = resolvedTypeName;
 		this.sourceStart = sourceStart;
@@ -108,9 +109,9 @@ public class LambdaExpression extends SourceType {
 			LambdaExpression that = (LambdaExpression) o;
 			if (this.sourceStart != that.sourceStart)
 				return false;
-			CompilationUnit thisCU = (CompilationUnit) this.getCompilationUnit();
-			CompilationUnit thatCU = (CompilationUnit) that.getCompilationUnit();
-			return thisCU.getElementName().equals(thatCU.getElementName()) && thisCU.parent.equals(thatCU.parent);
+			ITypeRoot thisTR = this.getTypeRoot();
+			ITypeRoot thatTR = that.getTypeRoot();
+			return thisTR.getElementName().equals(thatTR.getElementName()) && thisTR.getParent().equals(thatTR.getParent());
 		}
 		return false;
 	}
@@ -176,7 +177,7 @@ public class LambdaExpression extends SourceType {
 		String returnType = memento.nextToken();
 		if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;
 		String key = memento.nextToken();
-		this.lambdaMethod = LambdaMethod.make(this, selector, key, this.sourceStart, this.sourceEnd, this.arrowPosition, parameterTypes, parameterNames, returnType);
+		this.lambdaMethod = LambdaFactory.createLambdaMethod(this, selector, key, this.sourceStart, this.sourceEnd, this.arrowPosition, parameterTypes, parameterNames, returnType);
 		ILocalVariable [] parameters = new ILocalVariable[length];
 		for (int i = 0; i < length; i++) {
 			parameters[i] = (ILocalVariable) this.lambdaMethod.getHandleFromMemento(memento, workingCopyOwner);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
new file mode 100644
index 0000000..a5eeab1
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.jdt.core.ILocalVariable;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+
+public class LambdaFactory {
+
+	public static LambdaExpression createLambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
+		if (isBinaryMember(parent)){
+			return new BinaryLambdaExpression(parent, lambdaExpression);
+		} else {
+			return new LambdaExpression(parent, lambdaExpression);
+		}
+	}
+
+	public static LambdaExpression createLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+		if (isBinaryMember(parent)){
+			return new BinaryLambdaExpression(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+		} else {
+			return new LambdaExpression(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+		}
+	}
+
+	public static LambdaMethod createLambdaMethod(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
+		int length;
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		String [] parameterTypes = new String[length = lambdaExpression.descriptor.parameters.length];
+		for (int i = 0; i < length; i++)
+			parameterTypes[i] = getTypeSignature(manager, lambdaExpression.descriptor.parameters[i]);
+		String [] parameterNames = new String[length];
+		for (int i = 0; i < length; i++)
+			parameterNames[i] = manager.intern(new String(lambdaExpression.arguments[i].name));
+		String returnType = getTypeSignature(manager, lambdaExpression.descriptor.returnType);
+		String selector = manager.intern(new String(lambdaExpression.descriptor.selector));
+		String key = new String(lambdaExpression.descriptor.computeUniqueKey());
+		LambdaMethod lambdaMethod = createLambdaMethod(parent, selector, key, lambdaExpression.sourceStart, lambdaExpression.sourceEnd, lambdaExpression.arrowPosition, parameterTypes, parameterNames, returnType);
+		ILocalVariable [] parameters = new ILocalVariable[length = lambdaExpression.arguments.length];
+		for (int i = 0; i < length; i++) {
+			Argument argument = lambdaExpression.arguments[i];
+			String signature = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));
+			parameters[i] = new LocalVariable(
+					lambdaMethod,
+					new String(argument.name),
+					argument.declarationSourceStart,
+					argument.declarationSourceEnd,
+					argument.sourceStart,
+					argument.sourceEnd,
+					signature,
+					null, // we are not hooking up argument.annotations ATM,
+					argument.modifiers,
+					true);
+		}
+		lambdaMethod.elementInfo.arguments = parameters;
+		return lambdaMethod;
+	}
+
+	public static LambdaMethod createLambdaMethod(JavaElement parent, String selector, String key, int sourceStart, int sourceEnd, int arrowPosition, String [] parameterTypes, String [] parameterNames, String returnType) {
+		SourceMethodInfo info = null;
+		boolean isBinary = (parent instanceof BinaryLambdaExpression);
+		info = new SourceMethodInfo();
+		info.setSourceRangeStart(sourceStart);
+		info.setSourceRangeEnd(sourceEnd);
+		info.setFlags(0);
+		info.setNameSourceStart(sourceStart);
+		info.setNameSourceEnd(arrowPosition);
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		int length;
+		char[][] argumentNames = new char[length = parameterNames.length][];
+		for (int i = 0; i < length; i++)
+			argumentNames[i] = manager.intern(parameterNames[i].toCharArray());
+		info.setArgumentNames(argumentNames);
+		info.setReturnType(manager.intern(Signature.toCharArray(returnType.toCharArray())));
+		info.setExceptionTypeNames(CharOperation.NO_CHAR_CHAR);
+		info.arguments = null; // will be updated shortly, parent has to come into existence first.
+
+		return isBinary ? new BinaryLambdaMethod(parent, selector, key, sourceStart, parameterTypes, parameterNames, returnType, info) : 
+				new LambdaMethod(parent, selector, key, sourceStart, parameterTypes, parameterNames, returnType, info);
+	}
+
+	private static String getTypeSignature(JavaModelManager manager, TypeBinding type) {
+		char[] signature = type.genericTypeSignature();
+		signature = CharOperation.replaceOnCopy(signature, '/', '.');
+		return manager.intern(new String(signature));
+	}
+
+	private static boolean isBinaryMember(JavaElement element) {
+		return element instanceof BinaryMember;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
index 6abf2a2..7d56d35 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
@@ -16,10 +16,7 @@ import org.eclipse.jdt.core.ILocalVariable;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.Signature;
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class LambdaMethod extends SourceMethod {
@@ -30,7 +27,7 @@ public class LambdaMethod extends SourceMethod {
 	SourceMethodElementInfo elementInfo;
 	private String key;
 	
-	public LambdaMethod(JavaElement parent, String name, String key, int sourceStart, String [] parameterTypes, String [] parameterNames, String returnType, SourceMethodElementInfo elementInfo) {
+	LambdaMethod(JavaElement parent, String name, String key, int sourceStart, String [] parameterTypes, String [] parameterNames, String returnType, SourceMethodElementInfo elementInfo) {
 		super(parent, name, parameterTypes);
 		this.sourceStart = sourceStart;
 		this.parameterNameStrings = parameterNames;
@@ -39,64 +36,6 @@ public class LambdaMethod extends SourceMethod {
 		this.key = key;
 	}
 	
-	public static LambdaMethod make(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
-		int length;
-		JavaModelManager manager = JavaModelManager.getJavaModelManager();
-		String [] parameterTypes = new String[length = lambdaExpression.descriptor.parameters.length];
-		for (int i = 0; i < length; i++)
-			parameterTypes[i] = getTypeSignature(manager, lambdaExpression.descriptor.parameters[i]);
-		String [] parameterNames = new String[length];
-		for (int i = 0; i < length; i++)
-			parameterNames[i] = manager.intern(new String(lambdaExpression.arguments[i].name));
-		String returnType = getTypeSignature(manager, lambdaExpression.descriptor.returnType);
-		String selector = manager.intern(new String(lambdaExpression.descriptor.selector));
-		String key = new String(lambdaExpression.descriptor.computeUniqueKey());
-		LambdaMethod lambdaMethod = make(parent, selector, key, lambdaExpression.sourceStart, lambdaExpression.sourceEnd, lambdaExpression.arrowPosition, parameterTypes, parameterNames, returnType);
-		ILocalVariable [] parameters = new ILocalVariable[length = lambdaExpression.arguments.length];
-		for (int i = 0; i < length; i++) {
-			Argument argument = lambdaExpression.arguments[i];
-			String signature = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));
-			parameters[i] = new LocalVariable(
-					lambdaMethod,
-					new String(argument.name),
-					argument.declarationSourceStart,
-					argument.declarationSourceEnd,
-					argument.sourceStart,
-					argument.sourceEnd,
-					signature,
-					null, // we are not hooking up argument.annotations ATM,
-					argument.modifiers,
-					true);
-		}
-		lambdaMethod.elementInfo.arguments = parameters;
-		return lambdaMethod;
-	}
-	
-	public static LambdaMethod make(JavaElement parent, String selector, String key, int sourceStart, int sourceEnd, int arrowPosition, String [] parameterTypes, String [] parameterNames, String returnType) {
-		SourceMethodInfo info = new SourceMethodInfo();
-		info.setSourceRangeStart(sourceStart);
-		info.setSourceRangeEnd(sourceEnd);
-		info.setFlags(0);
-		info.setNameSourceStart(sourceStart);
-		info.setNameSourceEnd(arrowPosition);
-		JavaModelManager manager = JavaModelManager.getJavaModelManager();
-		int length;
-		char[][] argumentNames = new char[length = parameterNames.length][];
-		for (int i = 0; i < length; i++)
-			argumentNames[i] = manager.intern(parameterNames[i].toCharArray());
-		info.setArgumentNames(argumentNames);
-		info.setReturnType(manager.intern(Signature.toCharArray(returnType.toCharArray())));
-		info.setExceptionTypeNames(CharOperation.NO_CHAR_CHAR);
-		info.arguments = null; // will be updated shortly, parent has to come into existence first.
-		return new LambdaMethod(parent, selector, key, sourceStart, parameterTypes, parameterNames, returnType, info);
-	}
-
-	public static String getTypeSignature(JavaModelManager manager, TypeBinding type) {
-		char[] signature = type.genericTypeSignature();
-		signature = CharOperation.replaceOnCopy(signature, '/', '.');
-		return manager.intern(new String(signature));
-	}
-
 	/**
 	 * @see IMethod
 	 */
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
index 504ce79..973ad9f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
@@ -188,7 +188,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) 
 				return this;
 			int arrowPosition = Integer.parseInt(memento.nextToken());
-			LambdaExpression expression = new LambdaExpression(this, resolvedType, interphase, sourceStart, sourceEnd, arrowPosition);
+			LambdaExpression expression = LambdaFactory.createLambdaExpression(this, resolvedType, interphase, sourceStart, sourceEnd, arrowPosition);
 			if (!memento.hasMoreTokens() || (token = memento.nextToken()) != MementoTokenizer.LAMBDA_METHOD) 
 				return expression;
 			return expression.getHandleFromMemento(token, memento, workingCopyOwner);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
index e9c522e..8c7ebc2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
@@ -863,7 +863,7 @@ protected IJavaElement findLocalElement(int pos, MethodScope scope) {
 		IJavaElement parent = findLocalElement(pos, scope.enclosingMethodScope());
 		LambdaExpression expression = (LambdaExpression) scope.originalReferenceContext();
 		if (expression != null && expression.resolvedType != null && expression.resolvedType.isValidBinding()) {
-			org.eclipse.jdt.internal.core.LambdaExpression lambdaElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parent, expression);
+			org.eclipse.jdt.internal.core.LambdaExpression lambdaElement = LambdaFactory.createLambdaExpression((JavaElement) parent, expression);
 			return lambdaElement.getMethod();
 		}
 		return parent;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
index 5f5b847..0cfc4b9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
@@ -212,7 +212,8 @@ public class HandleFactory {
 					LambdaExpression expression = (LambdaExpression) scope.originalReferenceContext();
 					if (expression.resolvedType != null && expression.resolvedType.isValidBinding() && 
 							!(expression.descriptor instanceof ProblemMethodBinding)) { // chain in lambda element only if resolved properly.
-						newElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parentElement, expression).getMethod();
+						//newElement = new org.eclipse.jdt.internal.core.SourceLambdaExpression((JavaElement) parentElement, expression).getMethod();
+						newElement = LambdaFactory.createLambdaExpression((JavaElement) parentElement, expression).getMethod();
 						knownScopes.put(scope, newElement);
 						return newElement;
 					}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 8e0c323..9c80563 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -64,6 +64,7 @@ import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
 import org.eclipse.jdt.internal.core.JavaElement;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.JavaProject;
+import org.eclipse.jdt.internal.core.LambdaFactory;
 import org.eclipse.jdt.internal.core.LocalVariable;
 import org.eclipse.jdt.internal.core.NameLookup;
 import org.eclipse.jdt.internal.core.Openable;
@@ -450,7 +451,7 @@ protected char[][][] computeSuperTypeNames(IType focusType) {
  * Creates an IMethod from the given lambda declaration and type.
  */
 protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent) {
-	org.eclipse.jdt.internal.core.LambdaExpression lambdaElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parent, lambdaExpression);
+	org.eclipse.jdt.internal.core.LambdaExpression lambdaElement = LambdaFactory.createLambdaExpression((JavaElement) parent, lambdaExpression);
 	IMethod lambdaMethodElement = lambdaElement.getMethod();
 	this.methodHandles.add(lambdaMethodElement);
 	return lambdaMethodElement;
commit 99697e231d7abf709bf21ed4dc6a92bbb307b9f9
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Apr 25 17:23:34 2014 +0530

    Bug 430073 - Removing field LambdaExpression#resolvedTypeName

13	13	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
8	8	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElement8Tests.java
49	49	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
36	36	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
5	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
1	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
index e8aad2d..e013ddd 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
@@ -344,9 +344,9 @@ public void test400905b() throws CoreException, IOException {
 							"Focus: I [in [Working copy] A.java [in x.y [in src [in P]]]]\n" + 
 							"Super types:\n" + 
 							"Sub types:\n" + 
-							"  Lambda(I) [in i [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
+							"  <lambda #1> [in i [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
 				h);
 		} finally {
 			primaryCu.discardWorkingCopy();
@@ -410,12 +410,12 @@ public void test429435() throws CoreException, IOException {
 					"Focus: I [in [Working copy] A.java [in x.y [in src [in P]]]]\n" + 
 							"Super types:\n" + 
 							"Sub types:\n" + 
-							"  Lambda(I) [in doit() [in <anonymous #1> [in doit() [in Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]\n" + 
-							"  Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]]]]]\n" + 
-							"  Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]]]\n" + 
-							"  Lambda(I) [in doit() [in Lambda(I) [in doit() [in Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]\n" + 
-							"  Lambda(I) [in doit() [in Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]\n" + 
-							"  Lambda(I) [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in doit() [in <anonymous #1> [in doit() [in <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]\n" + 
+							"  <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]]]]]\n" + 
+							"  <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]]]\n" + 
+							"  <lambda #1> [in doit() [in <lambda #1> [in doit() [in <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]]]\n" + 
+							"  <lambda #1> [in doit() [in <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]]]\n" + 
+							"  <lambda #1> [in zoo() [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
 							"  Y [in [Working copy] A.java [in x.y [in src [in P]]]]\n",
 				h);
 		} finally {
@@ -466,10 +466,10 @@ public void test429537() throws CoreException, IOException {
 							"Focus: I [in [Working copy] A.java [in x.y [in src [in P]]]]\n" + 
 							"Super types:\n" + 
 							"Sub types:\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  <lambda #1> [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
 				h);
 		} finally {
 			primaryCu.discardWorkingCopy();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElement8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElement8Tests.java
index 541b982..b03bc24 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElement8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElement8Tests.java
@@ -268,8 +268,8 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 					"Focus: Runnable [in X.java [in <default> [in src [in Bug429966]]]]\n" + 
 					"Super types:\n" + 
 					"Sub types:\n" + 
-					"  Lambda(Runnable) [in get() [in Lambda(Supplier) [in main(String[]) [in X [in X.java [in <default> [in src [in Bug429966]]]]]]]]\n" + 
-					"  Lambda(Runnable) [in run() [in Lambda(Runnable) [in get() [in Lambda(Supplier) [in main(String[]) [in X [in X.java [in <default> [in src [in Bug429966]]]]]]]]]]\n",
+					"  <lambda #1> [in get() [in <lambda #1> [in main(String[]) [in X [in X.java [in <default> [in src [in Bug429966]]]]]]]]\n" + 
+					"  <lambda #1> [in run() [in <lambda #1> [in get() [in <lambda #1> [in main(String[]) [in X [in X.java [in <default> [in src [in Bug429966]]]]]]]]]]\n",
 					h);
 		}
 		finally {
@@ -361,7 +361,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 			ICompilationUnit unit = getCompilationUnit(fileName);
 			int start = fileContent.indexOf("v");
 			IJavaElement[] elements = unit.codeSelect(start, 1);
-			assertElementEquals("Wrong element", "v [in apply(V) [in Lambda(MyFunction) [in compose(MyFunction<? super V,? extends T>) [in MyFunction [in X.java [in <default> [in src [in Bug429966]]]]]]]]", elements[0]);
+			assertElementEquals("Wrong element", "v [in apply(V) [in <lambda #1> [in compose(MyFunction<? super V,? extends T>) [in MyFunction [in X.java [in <default> [in src [in Bug429966]]]]]]]]", elements[0]);
 		}
 		finally {
 			deleteProject(projectName);
@@ -386,7 +386,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 			ICompilationUnit unit = getCompilationUnit(fileName);
 			int start = fileContent.indexOf("v");
 			IJavaElement[] elements = unit.codeSelect(start, 1);
-			assertElementEquals("Wrong element", "v [in apply(V) [in Lambda(MyFunction) [in compose(MyFunction<? super V,? extends T>) [in MyFunction [in X.java [in <default> [in src [in Bug429966]]]]]]]]", elements[0]);
+			assertElementEquals("Wrong element", "v [in apply(V) [in <lambda #1> [in compose(MyFunction<? super V,? extends T>) [in MyFunction [in X.java [in <default> [in src [in Bug429966]]]]]]]]", elements[0]);
 		}
 		finally {
 			deleteProject(projectName);
@@ -422,7 +422,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 			IPackageFragment packageFragment = packageFragmentRoots[2].getPackageFragment("");
 			IClassFile classFile = packageFragment.getClassFile("IntPredicate.class");
 			IJavaElement[] elements = classFile.codeSelect(128, 5);
-			assertElementEquals("Wrong element", "value [in test(int) [in Lambda(IntPredicate) [in and(IntPredicate) [in IntPredicate [in IntPredicate.class [in <default> [in Elements.jar [in Bug430033]]]]]]]]", elements[0]);
+			assertElementEquals("Wrong element", "value [in test(int) [in <lambda #1> [in and(IntPredicate) [in IntPredicate [in IntPredicate.class [in <default> [in Elements.jar [in Bug430033]]]]]]]]", elements[0]);
 		}
 		finally {
 			if (project != null) {
@@ -456,7 +456,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 							"Super types:\n" + 
 							"Sub types:\n" + 
 							"  J [in X.java [in <default> [in src [in Bug430141]]]]\n" + 
-							"    Lambda(J) [in main(String[]) [in X [in X.java [in <default> [in src [in Bug430141]]]]]]\n",
+							"    <lambda #1> [in main(String[]) [in X [in X.java [in <default> [in src [in Bug430141]]]]]]\n",
 					h);
 		}
 		finally {
@@ -488,7 +488,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 							"Super types:\n" + 
 							"  I [in X.java [in <default> [in src [in Bug430141]]]]\n" + 
 							"Sub types:\n" + 
-							"  Lambda(J) [in main(String[]) [in X [in X.java [in <default> [in src [in Bug430141]]]]]]\n",
+							"  <lambda #1> [in main(String[]) [in X [in X.java [in <default> [in src [in Bug430141]]]]]]\n",
 					h);
 		}
 		finally {
@@ -517,7 +517,7 @@ public class JavaElement8Tests extends AbstractJavaModelTests {
 			assertEquals("Incorrect java element", IJavaElement.LOCAL_VARIABLE, elements[0].getElementType());
 			IType lambda = (IType) elements[0].getParent().getParent();
 			String mem = lambda.getHandleIdentifier();
-			String expected = "=\\(\\[Bug430136\\])/src<{X.java[MyFunction~compose~QMyFunction\\<-QV;+QT;>;=)MyFunction=\"LMyFunction\\<TV;TR;>;!148!174!151=&apply!1=\"TV;=\"v=\"TR;=\"LX\\~MyFunction\\<LX\\~MyFunction;:1TV;LX\\~MyFunction;:TR;>;.apply\\(TV;)TR;@v!148!148!148!148!Ljava\\/lang\\/Object;!0!true=)";
+			String expected = "=\\(\\[Bug430136\\])/src<{X.java[MyFunction~compose~QMyFunction\\<-QV;+QT;>;=)=\"LMyFunction\\<TV;TR;>;!148!174!151=&apply!1=\"TV;=\"v=\"TR;=\"LX\\~MyFunction\\<LX\\~MyFunction;:1TV;LX\\~MyFunction;:TR;>;.apply\\(TV;)TR;@v!148!148!148!148!Ljava\\/lang\\/Object;!0!true=)";
 			assertEquals("Incorrect memento", expected, mem);
 			IJavaElement result = JavaCore.create(expected);
 			assertEquals("Incorrect element created", lambda, result);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
index 210a802..bde0de9 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
@@ -2404,8 +2404,8 @@ public void testBug400905_0001() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/X.java int b400905.I.foo() [foo] EXACT_MATCH\n" +
-			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [() ->] EXACT_MATCH\n" +			
-			"src/b400905/X.java int void b400905.X.doit():Lambda(I).foo() [() ->] EXACT_MATCH");	
+			"src/b400905/X.java int void b400905.X.main(String[]):<lambda #1>.foo() [() ->] EXACT_MATCH\n" +			
+			"src/b400905/X.java int void b400905.X.doit():<lambda #1>.foo() [() ->] EXACT_MATCH");	
 }
 /**
  * @bug 400905
@@ -2445,10 +2445,10 @@ public void testBug400905_0002() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/I.java int b400905.I.foo() [foo] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [() ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [()  ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [()->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int I b400905.X.bar():Lambda(I).foo() [() ->] EXACT_MATCH");	
+			"src/b400905/X.java int void b400905.X.main(String[]):<lambda #1>.foo() [() ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int void b400905.X.main(String[]):<lambda #1>.foo() [()  ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int void b400905.X.main(String[]):<lambda #1>.foo() [()->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int I b400905.X.bar():<lambda #1>.foo() [() ->] EXACT_MATCH");	
 }
 /**
  * @bug 400905
@@ -2482,9 +2482,9 @@ public void testBug400905_0003() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/I.java boolean b400905.I.foo(Y) [foo] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905.Y) [y->] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905.Y) [y ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905.Y) [y  ->] EXACT_MATCH"
+			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda #1>.foo(b400905.Y) [y->] EXACT_MATCH\n" + 
+			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda #1>.foo(b400905.Y) [y ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda #1>.foo(b400905.Y) [y  ->] EXACT_MATCH"
 	);	
 }
 /**
@@ -2519,10 +2519,10 @@ public void testBug400905_0004() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 					"src/b400905/I.java T b400905.I.foo() [foo] EXACT_MATCH\n" + 
-					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):Lambda(I).foo() [() /* foo */ ->] EXACT_MATCH\n" + 
-					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):Lambda(I).foo() [() /* true */->] EXACT_MATCH\n" + 
-					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):Lambda(I).foo() [() /* false */ ->] EXACT_MATCH\n" + 
-					"src/b400905/X.java java.lang.Object void b400905.X.main(String[]):Lambda(I).foo() [() /* cast */ ->] EXACT_MATCH"
+					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):<lambda #1>.foo() [() /* foo */ ->] EXACT_MATCH\n" + 
+					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):<lambda #1>.foo() [() /* true */->] EXACT_MATCH\n" + 
+					"src/b400905/X.java b400905.Y void b400905.X.main(String[]):<lambda #1>.foo() [() /* false */ ->] EXACT_MATCH\n" + 
+					"src/b400905/X.java java.lang.Object void b400905.X.main(String[]):<lambda #1>.foo() [() /* cast */ ->] EXACT_MATCH"
 	);	
 }
 /**
@@ -2555,7 +2555,7 @@ public void testBug400905_0005() throws CoreException {
 	IMethod method = type.getMethod("bar", new String[] {});
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-					"src/b400905/X.java void b400905.Y void b400905.X.main(String[]):Lambda(I).foo():Lambda(Y).bar() [() /* bar */ ->] EXACT_MATCH\n" + 
+					"src/b400905/X.java void b400905.Y void b400905.X.main(String[]):<lambda #1>.foo():<lambda #1>.bar() [() /* bar */ ->] EXACT_MATCH\n" + 
 					"src/b400905/Y.java void b400905.Y.bar() [bar] EXACT_MATCH"
 	);	
 }
@@ -2594,7 +2594,7 @@ public void testBug400905_0006() throws CoreException {
 		search(method, DECLARATIONS, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
 		assertSearchResults(
 						"src/I.java void I.foo() [foo] EXACT_MATCH\n" + 
-						"src/X.java void void X.main(String[]):Lambda(I).foo() [()->] EXACT_MATCH"
+						"src/X.java void void X.main(String[]):<lambda #1>.foo() [()->] EXACT_MATCH"
 		);
 	}
 	finally {
@@ -2836,7 +2836,7 @@ public void testBug400905_0012() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java void I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java void X.i:Lambda(I).doit() [() ->] EXACT_MATCH\n" + 
+				"src/X.java void X.i:<lambda #1>.doit() [() ->] EXACT_MATCH\n" + 
 				"src/X.java void X.i2:<anonymous>#1.doit() [doit] EXACT_MATCH");
 	}
 	finally {
@@ -2871,7 +2871,7 @@ public void testBug400905_0013() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit() [() ->] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit() [() ->] EXACT_MATCH\n" + 
 				"src/X.java int void X.zoo():<anonymous>#1.doit() [doit] EXACT_MATCH");
 	}
 	finally {
@@ -2905,8 +2905,8 @@ public void testBug400905_0013a() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit() [() /*1*/->] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():Lambda(I).doit():Lambda(I).doit() [() /*2*/->] EXACT_MATCH");
+				"src/X.java int void X.zoo():<lambda #1>.doit() [() /*1*/->] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():<lambda #1>.doit():<lambda #1>.doit() [() /*2*/->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -2937,8 +2937,8 @@ public void testBug400905_0013b() throws CoreException {
 		
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
-		assertSearchResults("src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
+		assertSearchResults("src/X.java int int void X.zoo():<lambda #1>.doit(X):<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -2969,8 +2969,8 @@ public void testBug400905_0013c() throws CoreException {
 		
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {type}), this.resultCollector);
-		assertSearchResults("src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
+		assertSearchResults("src/X.java int int void X.zoo():<lambda #1>.doit(X):<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3002,8 +3002,8 @@ public void testBug400905_0013d() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():<lambda #1>.doit(X):<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3038,9 +3038,9 @@ public void testBug400905_0013e() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X):Q#1.x [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():<lambda #1>.doit(X):<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3076,10 +3076,10 @@ public void testBug400905_0013f() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X):Q#1.x [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():<lambda #1>.doit(X):<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda #1>.doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3112,7 +3112,7 @@ public void testBug400905_0014() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[] {"I"});
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(int) [doit] EXACT_MATCH\n" + 
-							"src/X.java int void X.zoo():Lambda(I).doit(int) [(x) ->] EXACT_MATCH");
+							"src/X.java int void X.zoo():<lambda #1>.doit(int) [(x) ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3191,7 +3191,7 @@ public void testBug400905_0016() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[] {"I"});
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(int) [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():Lambda(I).doit(int) [(x) ->] EXACT_MATCH");
+				"src/X.java int void X.zoo():<lambda #1>.doit(int) [(x) ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3219,7 +3219,7 @@ public void testBug400905_0017() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/Function.java R Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/Y.java R Function<I,R> Collectors.castingIdentity():Lambda(Function).apply(I) [i ->] EXACT_MATCH");
+				"src/Y.java R Function<I,R> Collectors.castingIdentity():<lambda #1>.apply(I) [i ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3247,7 +3247,7 @@ public void testBug400905_0018() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/Function.java R Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/Y.java java.lang.String Function<String,String> Collectors.castingIdentity():Lambda(Function).apply(java.lang.String) [i ->] EXACT_MATCH");
+				"src/Y.java java.lang.String Function<String,String> Collectors.castingIdentity():<lambda #1>.apply(java.lang.String) [i ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3321,7 +3321,7 @@ public void testBug400905_0021() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/p400905/Function.java R p400905.Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/p400905/Collectors.java R Function<I,R> p400905.Collectors.castingIdentity():Lambda(Function).apply(I) [i ->] EXACT_MATCH");
+				"src/p400905/Collectors.java R Function<I,R> p400905.Collectors.castingIdentity():<lambda #1>.apply(I) [i ->] EXACT_MATCH");
 	} finally { 
 		deleteFolder(path);
 	}
@@ -3345,7 +3345,7 @@ public void testBug400905_0022() throws CoreException {
 	search("thrice", METHOD, DECLARATIONS, ERASURE_RULE, getJavaSearchScope(), this.resultCollector);
 	assertSearchResults(
 			"src/test/Test.java int test.FunctionalInterface.thrice(int) [thrice] EXACT_MATCH\n" + 
-			"src/test/Test.java int test.X.i:Lambda(FunctionalInterface).thrice(int) [(x) ->] EXACT_MATCH"
+			"src/test/Test.java int test.X.i:<lambda #1>.thrice(int) [(x) ->] EXACT_MATCH"
 	);
 }
 public void testBug400905_0023() throws CoreException {
@@ -3380,9 +3380,9 @@ public void testBug400905_0023() throws CoreException {
 	search("thrice", METHOD, DECLARATIONS, ERASURE_RULE, getJavaSearchScope(), this.resultCollector);
 	assertSearchResults(
 					"src/test/Test.java int test.I.thrice(int) [thrice] EXACT_MATCH\n" + 
-					"src/test/Test.java int test.X.i:Lambda(I).thrice(int) [(x) /* field */ ->] EXACT_MATCH\n" + 
-					"src/test/Test.java int void test.X.main(String[]):Lambda(I).thrice(int) [(x) /*call*/ ->] EXACT_MATCH\n" + 
-					"src/test/Test.java int void test.X.main(String[]):Lambda(I).thrice(int) [(x) /* local */ ->] EXACT_MATCH"
+					"src/test/Test.java int test.X.i:<lambda #1>.thrice(int) [(x) /* field */ ->] EXACT_MATCH\n" + 
+					"src/test/Test.java int void test.X.main(String[]):<lambda #1>.thrice(int) [(x) /*call*/ ->] EXACT_MATCH\n" + 
+					"src/test/Test.java int void test.X.main(String[]):<lambda #1>.thrice(int) [(x) /* local */ ->] EXACT_MATCH"
 	);
 }
 public void testBug400905_0024() throws CoreException {
@@ -3553,7 +3553,7 @@ public void test429738() throws CoreException {
 	ILocalVariable local = (ILocalVariable) elements[0];
 	search(local, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-			"src/b400905/X.java int b400905.X.f1:Lambda(Foo).foo(int).x [x] EXACT_MATCH");	
+			"src/b400905/X.java int b400905.X.f1:<lambda #1>.foo(int).x [x] EXACT_MATCH");	
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=429738, [1.8][search] Find Declarations (Ctrl + G) shows no result for type-less lambda parameter 
 public void test429738a() throws CoreException {
@@ -3579,7 +3579,7 @@ public void test429738a() throws CoreException {
 	ILocalVariable local = (ILocalVariable) elements[0];
 	search(local, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-			"src/b400905/X.java int b400905.X.f2:Lambda(Foo).foo(int).x [x] EXACT_MATCH");	
+			"src/b400905/X.java int b400905.X.f2:<lambda #1>.foo(int).x [x] EXACT_MATCH");	
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=429836, [1.8][search] Search implementors in workspace does not show lambda expressions. 
 public void testBug429836() throws CoreException {
@@ -3601,10 +3601,10 @@ public void testBug429836() throws CoreException {
 	IType type = this.workingCopies[0].getType("I");
 	search(type, IMPLEMENTORS);
 	assertSearchResults(
-		"src/b429836/X.java int b429836.X.f1:Lambda(I).foo(int) [x ->] EXACT_MATCH\n" +
-		"src/b429836/X.java int b429836.X.f2:Lambda(I).foo(int) [(int x) ->] EXACT_MATCH\n"+
-		"src/b429836/X.java int void b429836.X.main(String[]):Lambda(I).foo(int) [x ->] EXACT_MATCH\n"+
-		"src/b429836/X.java int void b429836.X.main(String[]):Lambda(I).foo(int) [(int x) ->] EXACT_MATCH"
+		"src/b429836/X.java int b429836.X.f1:<lambda #1>.foo(int) [x ->] EXACT_MATCH\n" +
+		"src/b429836/X.java int b429836.X.f2:<lambda #1>.foo(int) [(int x) ->] EXACT_MATCH\n"+
+		"src/b429836/X.java int void b429836.X.main(String[]):<lambda #1>.foo(int) [x ->] EXACT_MATCH\n"+
+		"src/b429836/X.java int void b429836.X.main(String[]):<lambda #1>.foo(int) [(int x) ->] EXACT_MATCH"
 	);
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=429934, [1.8][search] for references to type of lambda with 'this' parameter throws AIIOBE
@@ -3671,7 +3671,7 @@ public void test430159a() throws CoreException {
 			null);
 	assertSearchResults(
 		"src/b429498/X.java void b429498.I.doit(int) [doit] EXACT_MATCH\n" + 
-		"src/b429498/X.java void b429498.X.i:Lambda(I).doit(int) [(int xyz) ->] EXACT_MATCH"
+		"src/b429498/X.java void b429498.X.i:<lambda #1>.doit(int) [(int xyz) ->] EXACT_MATCH"
 	);	
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=430159, [1.8][search] Lambda Expression not found when searching using OrPattern or AndPattern 
@@ -3709,7 +3709,7 @@ public void test430159b() throws CoreException {	// this test basically checks t
 			null);
 	assertSearchResults(
 		"src/b429498/X.java void b429498.I.doit() [doit] EXACT_MATCH\n" + 
-		"src/b429498/X.java void b429498.X.i:Lambda(I).doit() [() ->] EXACT_MATCH"
+		"src/b429498/X.java void b429498.X.i:<lambda #1>.doit() [() ->] EXACT_MATCH"
 	);	
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=430159, [1.8][search] Lambda Expression not found when searching using OrPattern or AndPattern 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
index 9fe3b20..290a64a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
@@ -719,7 +719,7 @@ public void test0024() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in foo(int) [in Lambda(I) [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"xyz [in foo(int) [in <lambda #1> [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -744,7 +744,7 @@ public void test0025() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in foo(int) [in Lambda(I) [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"abc [in foo(int) [in <lambda #1> [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -767,7 +767,7 @@ public void test0026() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in foo(int) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"abc [in foo(int) [in <lambda #1> [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -795,7 +795,7 @@ public void test0027() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
+		"abc [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
 		elements
 	);
 }
@@ -823,7 +823,7 @@ public void test0028() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"xyz [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -889,7 +889,7 @@ public void test0030() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"zyx [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in fx [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"zyx [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in fx [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -922,7 +922,7 @@ public void test0031() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"xyz [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -957,7 +957,7 @@ public void test0032() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"hij [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"hij [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -993,7 +993,7 @@ public void test0033() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"hij [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"hij [in doit(I) [in <lambda #1> [in doit(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1432,7 +1432,7 @@ public void testFieldInit() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"first [in foo(int, int) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"first [in foo(int, int) [in <lambda #1> [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1455,7 +1455,7 @@ public void test422468() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"first [in foo(X, java.lang.Object) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"first [in foo(X, java.lang.Object) [in <lambda #1> [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1478,7 +1478,7 @@ public void test422468a() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"second [in foo(X, java.lang.Object) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"second [in foo(X, java.lang.Object) [in <lambda #1> [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1504,7 +1504,7 @@ public void test422468b() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"y [in foo(I) [in Lambda(I) [in foo(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"y [in foo(I) [in <lambda #1> [in foo(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1530,7 +1530,7 @@ public void test422468c() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"y [in foo(I) [in Lambda(I) [in foo(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"y [in foo(I) [in <lambda #1> [in foo(I) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1594,7 +1594,7 @@ public void test422468e() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"q [in foo(java.lang.String, int) [in Lambda(K) [in foo(java.lang.String, java.lang.String) [in Lambda(J) [in foo(java.lang.String, java.lang.String) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
+		"q [in foo(java.lang.String, int) [in <lambda #1> [in foo(java.lang.String, java.lang.String) [in <lambda #1> [in foo(java.lang.String, java.lang.String) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
 		elements
 	);
 }
@@ -1629,7 +1629,7 @@ public void testParser() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"x [in foo(java.lang.String, java.lang.Integer) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"x [in foo(java.lang.String, java.lang.Integer) [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1788,7 +1788,7 @@ public void test424198() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"v1 [in apply(java.lang.String) [in Lambda(Function) [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"v1 [in apply(java.lang.String) [in <lambda #1> [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1853,7 +1853,7 @@ public void test424198a() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"v2 [in apply(? extends java.lang.String) [in Lambda(Function) [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"v2 [in apply(? extends java.lang.String) [in <lambda #1> [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1918,7 +1918,7 @@ public void test424198b() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"s1 [in accept(? extends java.lang.String) [in Lambda(Consumer) [in withWildcard(Stream<? extends String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"s1 [in accept(? extends java.lang.String) [in <lambda #1> [in withWildcard(Stream<? extends String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1983,7 +1983,7 @@ public void test424198c() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"s2 [in accept(java.lang.String) [in Lambda(Consumer) [in withoutWildcard(Stream<String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"s2 [in accept(java.lang.String) [in <lambda #1> [in withoutWildcard(Stream<String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -2298,7 +2298,7 @@ public void test429845() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"ex [in foo() [in Lambda(FI) [in fun1(int) [in C1 [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+		"ex [in foo() [in <lambda #1> [in fun1(int) [in C1 [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements, true
 	);
 }
@@ -2337,7 +2337,7 @@ public void test429948() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xxx [in run() [in Lambda(Runnable) [in get() [in Lambda(Supplier) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
+		"xxx [in run() [in <lambda #1> [in get() [in <lambda #1> [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements, true
 	);
 }
@@ -2392,7 +2392,7 @@ public void test429812() throws CoreException {
 	IJavaElement[] elements = this.workingCopies[0].codeSelect(start, length);
 	assertElementsEqual(
 			"Unexpected elements",
-			"x [in get(java.util.List<U>, int) [in Lambda(Getter) [in foo(List<U>) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
+			"x [in get(java.util.List<U>, int) [in <lambda #1> [in foo(List<U>) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 			elements, true
 			);
 	IMethod lambda = (IMethod) elements[0].getParent();
@@ -2422,14 +2422,14 @@ public void test430136() throws CoreException {
 	IMethod lambda = (IMethod) elements[0].getParent();
 	String memento = lambda.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&", 
 			memento);
 	IJavaElement result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", lambda, result);
 	LambdaExpression expression = (LambdaExpression) lambda.getParent();
 	memento = expression.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=)", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=)", 
 			memento);
 	result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", expression, result);
@@ -2439,14 +2439,14 @@ public void test430136() throws CoreException {
 	lambda = (IMethod) elements[0].getParent();
 	memento = lambda.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!180!197!188=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!181!181!181!181!Ljava\\/util\\/List;!0!true@i!184!184!184!184!I!0!true=&", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!180!197!188=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!181!181!181!181!Ljava\\/util\\/List;!0!true@i!184!184!184!184!I!0!true=&", 
 			memento);
 	result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", lambda, result);
 	expression = (LambdaExpression) lambda.getParent();
 	memento = expression.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!180!197!188=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!181!181!181!181!Ljava\\/util\\/List;!0!true@i!184!184!184!184!I!0!true=)", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!180!197!188=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!181!181!181!181!Ljava\\/util\\/List;!0!true@i!184!184!184!184!I!0!true=)", 
 			memento);
 	result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", expression, result);
@@ -2474,7 +2474,7 @@ public void test430307() throws CoreException {
 	ILocalVariable local = (ILocalVariable) elements[0];
 	String memento = local.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&@x!145!145!145!145!Ljava.util.List\\<LU;>;!0!true", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&@x!145!145!145!145!Ljava.util.List\\<LU;>;!0!true", 
 			memento);
 	IJavaElement result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", local, result);
@@ -2484,7 +2484,7 @@ public void test430307() throws CoreException {
 	IMethod lambda = (IMethod) elements[0].getParent();
 	memento = lambda.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=&", 
 			memento);
 	result = JavaCore.create(memento);
 	assertEquals("Java elements should be equal", lambda, result);
@@ -2492,7 +2492,7 @@ public void test430307() throws CoreException {
 	LambdaExpression expression = (LambdaExpression) lambda.getParent();
 	memento = expression.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)Getter=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=)", 
+			"=Resolve/src<{X.java[X~foo~QList\\<QU;>;=)=\"LGetter\\<TU;>;!144!161!152=&get!2=\"Ljava.util.List\\<TU;>;=\"x=\"I=\"i=\"TU;=\"LX\\~Getter\\<LX;:TU;>;.get\\(Ljava\\/util\\/List\\<TU;>;I)TU;@x!145!145!145!145!Ljava\\/util\\/List;!0!true@i!148!148!148!148!I!0!true=)", 
 			memento);
 	LambdaExpression recreatedType = (LambdaExpression) JavaCore.create(memento);
 	assertEquals("Java elements should be equal", expression, recreatedType);
@@ -2524,9 +2524,9 @@ public void test430307a() throws JavaModelException {
 	String memento = local.getHandleIdentifier();
 		assertEquals(
 				"Incorrect memento string",
-				"=Resolve/src<{X.java[X~main~\\[QString;=)I=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
-				+ "LI;@pqr!104!106!104!106!LI;!0!true=&=)I=\"LI;!124!164!131=&doit!1=\"LI;=\"xyz=\"LI;=\"LX\\~I;.doit\\(LI;)"
-				+ "LI;@xyz!125!127!125!127!LI;!0!true=&=)I=\"LI;!146!157!153=&doit!1=\"LI;=\"abc=\"LI;=\"LX\\~I;.doit\\(LI;)"
+				"=Resolve/src<{X.java[X~main~\\[QString;=)=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
+				+ "LI;@pqr!104!106!104!106!LI;!0!true=&=)=\"LI;!124!164!131=&doit!1=\"LI;=\"xyz=\"LI;=\"LX\\~I;.doit\\(LI;)"
+				+ "LI;@xyz!125!127!125!127!LI;!0!true=&=)=\"LI;!146!157!153=&doit!1=\"LI;=\"abc=\"LI;=\"LX\\~I;.doit\\(LI;)"
 				+ "LI;@abc!147!149!147!149!LI;!0!true=&@abc!147!149!147!149!LI;!0!true",
 				memento);
 	IJavaElement result = JavaCore.create(memento);
@@ -2543,8 +2543,8 @@ public void test430307a() throws JavaModelException {
 	local = (ILocalVariable) elements[0];
 	memento = local.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~main~\\[QString;=)I=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
-			+ "LI;@pqr!104!106!104!106!LI;!0!true=&=)I=\"LI;!124!164!131=&doit!1=\"LI;=\"xyz=\"LI;=\"LX\\~I;.doit\\(LI;)"
+			"=Resolve/src<{X.java[X~main~\\[QString;=)=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
+			+ "LI;@pqr!104!106!104!106!LI;!0!true=&=)=\"LI;!124!164!131=&doit!1=\"LI;=\"xyz=\"LI;=\"LX\\~I;.doit\\(LI;)"
 			+ "LI;@xyz!125!127!125!127!LI;!0!true=&@xyz!125!127!125!127!LI;!0!true", 
 			memento);
 	result = JavaCore.create(memento);
@@ -2561,7 +2561,7 @@ public void test430307a() throws JavaModelException {
 	local = (ILocalVariable) elements[0];
 	memento = local.getHandleIdentifier();
 	assertEquals("Incorrect memento string", 
-			"=Resolve/src<{X.java[X~main~\\[QString;=)I=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
+			"=Resolve/src<{X.java[X~main~\\[QString;=)=\"LI;!103!169!110=&doit!1=\"LI;=\"pqr=\"LI;=\"LX\\~I;.doit\\(LI;)"
 			+ "LI;@pqr!104!106!104!106!LI;!0!true=&@pqr!104!106!104!106!LI;!0!true", 
 			memento);
 	result = JavaCore.create(memento);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
index f39b00a..fad0f59 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryLambdaExpression.java
@@ -19,12 +19,12 @@ public class BinaryLambdaExpression extends LambdaExpression {
 		super(parent, lambdaExpression);
 	}
 
-	BinaryLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
-		super(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+	BinaryLambdaExpression(JavaElement parent, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+		super(parent, interphase, sourceStart, sourceEnd, arrowPosition);
 	}
 
-	BinaryLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
-		super(parent, name, interphase, sourceStart, sourceEnd, arrowPosition, lambdaMethod);
+	BinaryLambdaExpression(JavaElement parent, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
+		super(parent, interphase, sourceStart, sourceEnd, arrowPosition, lambdaMethod);
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
index 4ce643f..327b07b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
@@ -33,13 +33,11 @@ public class LambdaExpression extends SourceType {
 	protected int sourceEnd;
 	protected int arrowPosition;
 	protected String interphase;
-	String resolvedTypeName;
 	
 	
 	// Construction from AST node
 	LambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
 		super(parent, new String(CharOperation.NO_CHAR));
-		this.resolvedTypeName = new String(lambdaExpression.resolvedType.sourceName());
 		this.sourceStart = lambdaExpression.sourceStart;
 		this.sourceEnd = lambdaExpression.sourceEnd;
 		this.arrowPosition = lambdaExpression.arrowPosition;
@@ -50,9 +48,8 @@ public class LambdaExpression extends SourceType {
 	}
 	
 	// Construction from memento
-	LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+	LambdaExpression(JavaElement parent, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
 		super(parent, new String(CharOperation.NO_CHAR));
-		this.resolvedTypeName = resolvedTypeName;
 		this.sourceStart = sourceStart;
 		this.sourceEnd = sourceEnd;
 		this.arrowPosition = arrowPosition;
@@ -62,9 +59,8 @@ public class LambdaExpression extends SourceType {
 	}
 	
 	// Construction from subtypes.
-	LambdaExpression(JavaElement parent, String resolvedTypeName, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
+	LambdaExpression(JavaElement parent, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
 		super(parent, new String(CharOperation.NO_CHAR));
-		this.resolvedTypeName = resolvedTypeName;
 		this.sourceStart = sourceStart;
 		this.sourceEnd = sourceEnd;
 		this.arrowPosition = arrowPosition;
@@ -141,7 +137,6 @@ public class LambdaExpression extends SourceType {
 		if (serializeParent) 
 			((JavaElement)getParent()).getHandleMemento(buff);
 		appendEscapedDelimiter(buff, getHandleMementoDelimiter());
-		escapeMementoName(buff, this.resolvedTypeName);
 		appendEscapedDelimiter(buff, JEM_STRING);
 		escapeMementoName(buff, this.interphase);
 		buff.append(JEM_COUNT);
@@ -226,13 +221,9 @@ public class LambdaExpression extends SourceType {
 
 	public void toStringName(StringBuffer buffer) {
 		super.toStringName(buffer);
-		buffer.append("Lambda("); //$NON-NLS-1$
-		buffer.append(this.resolvedTypeName);
-		buffer.append(')');
-		if (this.occurrenceCount > 1) {
-			buffer.append("#"); //$NON-NLS-1$
-			buffer.append(this.occurrenceCount);
-		}
+		buffer.append("<lambda #"); //$NON-NLS-1$
+		buffer.append(this.occurrenceCount);
+		buffer.append(">"); //$NON-NLS-1$
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
index a5eeab1..ff8bc0e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaFactory.java
@@ -27,11 +27,11 @@ public class LambdaFactory {
 		}
 	}
 
-	public static LambdaExpression createLambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+	public static LambdaExpression createLambdaExpression(JavaElement parent, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
 		if (isBinaryMember(parent)){
-			return new BinaryLambdaExpression(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+			return new BinaryLambdaExpression(parent, interphase, sourceStart, sourceEnd, arrowPosition);
 		} else {
-			return new LambdaExpression(parent, name, interphase, sourceStart, sourceEnd, arrowPosition);
+			return new LambdaExpression(parent, interphase, sourceStart, sourceEnd, arrowPosition);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
index 973ad9f..10ce6ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
@@ -173,8 +173,6 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 		case JEM_COUNT:
 			return getHandleUpdatingCountFromMemento(memento, workingCopyOwner);
 		case JEM_LAMBDA_EXPRESSION:
-			if (!memento.hasMoreTokens()) return this;
-			String resolvedType = memento.nextToken();
 			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.STRING)
 				return this;
 			if (!memento.hasMoreTokens()) return this;
@@ -188,7 +186,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) 
 				return this;
 			int arrowPosition = Integer.parseInt(memento.nextToken());
-			LambdaExpression expression = LambdaFactory.createLambdaExpression(this, resolvedType, interphase, sourceStart, sourceEnd, arrowPosition);
+			LambdaExpression expression = LambdaFactory.createLambdaExpression(this, interphase, sourceStart, sourceEnd, arrowPosition);
 			if (!memento.hasMoreTokens() || (token = memento.nextToken()) != MementoTokenizer.LAMBDA_METHOD) 
 				return expression;
 			return expression.getHandleFromMemento(token, memento, workingCopyOwner);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
index 8475492..0fa4c89 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
@@ -18,7 +18,7 @@ public class ResolvedLambdaExpression extends LambdaExpression {
 	LambdaExpression unresolved;
 
 	public ResolvedLambdaExpression(JavaElement parent, LambdaExpression unresolved, String uniqueKey) {
-		super(parent, unresolved.resolvedTypeName, unresolved.interphase, unresolved.sourceStart, unresolved.sourceEnd, unresolved.arrowPosition, unresolved.lambdaMethod);
+		super(parent, unresolved.interphase, unresolved.sourceStart, unresolved.sourceEnd, unresolved.arrowPosition, unresolved.lambdaMethod);
 		this.uniqueKey = uniqueKey;
 		this.unresolved = unresolved;
 	}
