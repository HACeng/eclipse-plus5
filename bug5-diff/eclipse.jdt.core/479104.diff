commit 6acdb4510909317e02bb4ba566a6d0b5f09916da
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Oct 6 09:43:24 2015 +0530

    Bug 479104 - [api] Provide API to compare two versions of Java Platform
    
    Change-Id: If9adb643f36fbdf1095f0bd01b208c4e4e40c125

18	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index fa4d46b..f9aa393 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -293,7 +293,7 @@ public final class JavaCore extends Plugin {
 	 * <p><code>"cldc1.1"</code> requires the source version to be <code>"1.3"</code> and the compliance version to be <code>"1.4"</code> or lower.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.codegen.targetPlatform"</code></dd>
-	 * <dt>Possible values:</dt><dd><code>{ "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "cldc1.1" }</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "1.1", "cldc1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8" }</code></dd>
 	 * <dt>Default:</dt><dd><code>"1.2"</code></dd>
 	 * </dl>
 	 * @category CompilerOptionID
@@ -5678,6 +5678,23 @@ public final class JavaCore extends Plugin {
 		JavaModelManager.getJavaModelManager().setOptions(newOptions);
 	}
 
+	/**
+	 * Compares two given versions of the Java platform. The versions being compared must both be
+	 * one of the supported values mentioned in
+	 * {@link #COMPILER_CODEGEN_TARGET_PLATFORM COMPILER_CODEGEN_TARGET_PLATFORM},
+	 * both values from {@link #COMPILER_COMPLIANCE},  or both values from {@link #COMPILER_SOURCE}.
+	 *
+	 * @param first first version to be compared
+	 * @param second second version to be compared
+	 * @return the value {@code 0} if both versions are the same;
+	 * 			a value less than {@code 0} if <code>first</code> is smaller than <code>second</code>; and
+	 * 			a value greater than {@code 0} if <code>first</code> is higher than <code>second</code>
+	 * @since 3.12
+	 */
+	public static int compareJavaVersions(String first, String second) {
+		return Long.compare(CompilerOptions.versionToJdkLevel(first), CompilerOptions.versionToJdkLevel(second));
+	}
+
 	/* (non-Javadoc)
 	 * Shutdown the JavaCore plug-in.
 	 * <p>
commit 9b7b19bdcdbcea831580c60277f290356f5e2da7
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Oct 27 19:39:27 2015 +0530

    Bug 479104 - Generify CompilerOptions and related code
    
    Change-Id: I38e7b62564d52b783f4bd7c1554e2a928de37a97

0	1	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
1	1	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnclosingMethodAttributeTest.java
11	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaCoreOptionsTests.java
42	46	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
1	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
64	74	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
1	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEvaluator.java
6	7	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
2	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/Evaluator.java
1	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/VariablesEvaluator.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CorrectionEngine.java
1	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
1	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/jdom/SimpleDOMBuilder.java
7	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
index 3081318..60a7f06 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
@@ -87,7 +87,6 @@ public class EclipseCompiler implements JavaCompiler {
 	 *      java.lang.Iterable, java.lang.Iterable, java.lang.Iterable)
 	 */
 	@Override
-	@SuppressWarnings("unchecked")
 	public CompilationTask getTask(Writer out, JavaFileManager fileManager, DiagnosticListener<? super JavaFileObject> someDiagnosticListener, Iterable<String> options, Iterable<String> classes, Iterable<? extends JavaFileObject> compilationUnits) {
 		PrintWriter writerOut = null;
 		PrintWriter writerErr = null;
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
index 21c7efe..80a391a 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
@@ -312,7 +312,7 @@ public class EclipseCompilerImpl extends Main {
 	}
 
 	@Override
-	protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map customDefaultOptions, CompilationProgress compilationProgress) {
+	protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map<String, String> customDefaultOptions, CompilationProgress compilationProgress) {
 		super.initialize(outWriter, errWriter, systemExit, customDefaultOptions, compilationProgress);
 		this.javaFileObjectMap = new HashMap<>();
 	}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnclosingMethodAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnclosingMethodAttributeTest.java
index 0be8f04..a75ae52 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnclosingMethodAttributeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnclosingMethodAttributeTest.java
@@ -239,7 +239,7 @@ public class EnclosingMethodAttributeTest extends AbstractComparableTest {
 		requestor.outputPath = OUTPUT_DIR.endsWith(File.separator) ? OUTPUT_DIR : OUTPUT_DIR + File.separator;
 				// WORK should not have to test a constant?
 
-		Map options = getCompilerOptions();
+		Map<String, String> options = getCompilerOptions();
 		CompilerOptions compilerOptions = new CompilerOptions(options);
 		compilerOptions.performMethodsFullRecovery = true;
 		compilerOptions.performStatementsRecovery = true;
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaCoreOptionsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaCoreOptionsTests.java
index fff0c21..7522813 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaCoreOptionsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaCoreOptionsTests.java
@@ -105,5 +105,16 @@ public void test4() {
 		JavaCore.setOptions(options);
 	}
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=464845
+public void test5() {
+	assertTrue(JavaCore.compareJavaVersions("1.1", "1.3") < 0);
+	assertTrue(JavaCore.compareJavaVersions("1.4", "1.1") > 0);
+	assertTrue(JavaCore.compareJavaVersions("1.8", "cldc1.1") > 0);
+	assertTrue(JavaCore.compareJavaVersions("cldc1.1", "1.1") > 0);
+	assertTrue(JavaCore.compareJavaVersions("1.1", "cldc1.1") < 0);
+	assertTrue(JavaCore.compareJavaVersions("1.8", "1.8") == 0);
+	assertTrue(JavaCore.compareJavaVersions("1.8", "1.9") < 0);
+	assertTrue(JavaCore.compareJavaVersions("1.9", "1.8") > 0);
+}
 }
 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index d2608ad..55ebdfc 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -727,21 +727,21 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		/**
 		 * @param options the given compiler options
 		 */
-		public void logOptions(Map options) {
+		public void logOptions(Map<String, String> options) {
 			if ((this.tagBits & Logger.XML) != 0) {
 				printTag(Logger.OPTIONS, null, true, false);
-				final Set entriesSet = options.entrySet();
-				Object[] entries = entriesSet.toArray();
-				Arrays.sort(entries, new Comparator() {
-					public int compare(Object o1, Object o2) {
-						Map.Entry entry1 = (Map.Entry) o1;
-						Map.Entry entry2 = (Map.Entry) o2;
-						return ((String) entry1.getKey()).compareTo((String) entry2.getKey());
+				final Set<Map.Entry<String, String>> entriesSet = options.entrySet();
+				Map.Entry<String, String>[] entries = entriesSet.toArray(new Map.Entry[entriesSet.size()]);
+				Arrays.sort(entries, new Comparator<Map.Entry<String, String>>() {
+					public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
+						Map.Entry<String, String> entry1 = o1;
+						Map.Entry<String, String> entry2 = o2;
+						return entry1.getKey().compareTo(entry2.getKey());
 					}
 				});
 				for (int i = 0, max = entries.length; i < max; i++) {
-					Map.Entry entry = (Map.Entry) entries[i];
-					String key = (String) entry.getKey();
+					Map.Entry<String, String> entry = entries[i];
+					String key = entry.getKey();
 					this.parameters.put(Logger.KEY, key);
 					this.parameters.put(Logger.VALUE, entry.getValue());
 					printTag(Logger.OPTION, this.parameters, true, true);
@@ -1349,7 +1349,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 
 	public Logger logger;
 	public int maxProblems;
-	public Map options;
+	public Map<String, String> options;
 	public char[][] ignoreOptionalProblemsFromFolders;
 	protected PrintWriter out;
 	public boolean proceed = true;
@@ -1493,7 +1493,7 @@ public Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhen
 	this(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, null /* progress */);
 }
 
-public Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, Map customDefaultOptions, CompilationProgress compilationProgress) {
+public Main(PrintWriter outWriter, PrintWriter errWriter, boolean systemExitWhenFinished, Map<String, String> customDefaultOptions, CompilationProgress compilationProgress) {
 	this.initialize(outWriter, errWriter, systemExitWhenFinished, customDefaultOptions, compilationProgress);
 	this.relocalize();
 }
@@ -2858,7 +2858,7 @@ public void configure(String[] argv) {
 
 	if (specifiedEncodings != null && specifiedEncodings.size() > 1) {
 		this.logger.logWarning(this.bind("configure.multipleencodings", //$NON-NLS-1$
-				(String) this.options.get(CompilerOptions.OPTION_Encoding),
+				this.options.get(CompilerOptions.OPTION_Encoding),
 				getAllEncodings(specifiedEncodings)));
 	}
 	if (this.pendingErrors != null) {
@@ -2934,9 +2934,9 @@ private void initializeWarnings(String propertiesFile) {
 	}
 	for (Iterator iterator = properties.entrySet().iterator(); iterator.hasNext(); ) {
 		Map.Entry entry = (Map.Entry) iterator.next();
-		final String key = (String) entry.getKey();
+		final String key = entry.getKey().toString();
 		if (key.startsWith("org.eclipse.jdt.core.compiler.")) { //$NON-NLS-1$
-			this.options.put(key, entry.getValue());
+			this.options.put(key, entry.getValue().toString());
 		}
 	}
 	// when using a properties file mimic relevant defaults from JavaCorePreferenceInitializer:
@@ -2963,14 +2963,10 @@ protected void enableAll(int severity) {
 			newValue = CompilerOptions.WARNING;
 			break;
 	}
-	Object[] entries = this.options.entrySet().toArray();
+	Map.Entry<String, String>[] entries = this.options.entrySet().toArray(new Map.Entry[this.options.size()]);
 	for (int i = 0, max = entries.length; i < max; i++) {
-		Map.Entry entry = (Map.Entry) entries[i];
-		if (!(entry.getKey() instanceof String))
-			continue;
-		if (!(entry.getValue() instanceof String))
-			continue;
-		if (((String) entry.getValue()).equals(CompilerOptions.IGNORE)) {
+		Map.Entry<String, String> entry = entries[i];
+		if (entry.getValue().equals(CompilerOptions.IGNORE)) {
 			this.options.put(entry.getKey(), newValue);
 		}
 	}
@@ -2994,7 +2990,7 @@ protected void disableAll(int severity) {
 		if (!(entry.getValue() instanceof String))
 			continue;
 		if (((String) entry.getValue()).equals(checkedValue)) {
-			this.options.put(entry.getKey(), CompilerOptions.IGNORE);
+			this.options.put((String) entry.getKey(), CompilerOptions.IGNORE);
 		}
 	}
 }
@@ -3027,7 +3023,7 @@ public CompilationUnit[] getCompilationUnits() {
 	CompilationUnit[] units = new CompilationUnit[fileCount];
 	HashtableOfObject knownFileNames = new HashtableOfObject(fileCount);
 
-	String defaultEncoding = (String) this.options.get(CompilerOptions.OPTION_Encoding);
+	String defaultEncoding = this.options.get(CompilerOptions.OPTION_Encoding);
 	if (Util.EMPTY_STRING.equals(defaultEncoding))
 		defaultEncoding = null;
 
@@ -3336,13 +3332,13 @@ private void setSeverity(String compilerOptions, int severity, boolean isEnablin
 	} else {
 		switch(severity) {
 			case ProblemSeverities.Error :
-				String currentValue = (String) this.options.get(compilerOptions);
+				String currentValue = this.options.get(compilerOptions);
 				if (CompilerOptions.ERROR.equals(currentValue)) {
 					this.options.put(compilerOptions, CompilerOptions.IGNORE);
 				}
 				break;
 			case ProblemSeverities.Warning :
-				currentValue = (String) this.options.get(compilerOptions);
+				currentValue = this.options.get(compilerOptions);
 				if (CompilerOptions.WARNING.equals(currentValue)) {
 					this.options.put(compilerOptions, CompilerOptions.IGNORE);
 				}
@@ -4001,7 +3997,7 @@ protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean
 protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map customDefaultOptions) {
 	this.initialize(outWriter, errWriter, systemExit, customDefaultOptions, null /* progress */);
 }
-protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map customDefaultOptions, CompilationProgress compilationProgress) {
+protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map<String, String> customDefaultOptions, CompilationProgress compilationProgress) {
 	this.logger = new Logger(this, outWriter, errWriter);
 	this.proceed = true;
 	this.out = outWriter;
@@ -4014,8 +4010,8 @@ protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean
 	if (customDefaultOptions != null) {
 		this.didSpecifySource = customDefaultOptions.get(CompilerOptions.OPTION_Source) != null;
 		this.didSpecifyTarget = customDefaultOptions.get(CompilerOptions.OPTION_TargetPlatform) != null;
-		for (Iterator iter = customDefaultOptions.entrySet().iterator(); iter.hasNext();) {
-			Map.Entry entry = (Map.Entry) iter.next();
+		for (Iterator<Map.Entry<String, String>> iter = customDefaultOptions.entrySet().iterator(); iter.hasNext();) {
+			Map.Entry<String, String> entry = iter.next();
 			this.options.put(entry.getKey(), entry.getValue());
 		}
 	} else {
@@ -4723,75 +4719,75 @@ protected void validateOptions(boolean didSpecifyCompliance) {
 		}
 	}
 
-	final Object sourceVersion = this.options.get(CompilerOptions.OPTION_Source);
-	final Object compliance = this.options.get(CompilerOptions.OPTION_Compliance);
+	final String sourceVersion = this.options.get(CompilerOptions.OPTION_Source);
+	final String compliance = this.options.get(CompilerOptions.OPTION_Compliance);
 	if (sourceVersion.equals(CompilerOptions.VERSION_1_8)
 			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_8) {
 		// compliance must be 1.8 if source is 1.8
-		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_8)); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_8)); //$NON-NLS-1$
 	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_7)
 			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_7) {
 		// compliance must be 1.7 if source is 1.7
-		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_7)); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_7)); //$NON-NLS-1$
 	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_6)
 			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_6) {
 		// compliance must be 1.6 if source is 1.6
-		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
 	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_5)
 			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_5) {
 		// compliance must be 1.5 if source is 1.5
-		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
 	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_4)
 			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_4) {
 		// compliance must be 1.4 if source is 1.4
-		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForSource", this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
 	}
 
 	// check and set compliance/source/target compatibilities
 	if (this.didSpecifyTarget) {
-		final Object targetVersion = this.options.get(CompilerOptions.OPTION_TargetPlatform);
+		final String targetVersion = this.options.get(CompilerOptions.OPTION_TargetPlatform);
 		// tolerate jsr14 target
 		if (CompilerOptions.VERSION_JSR14.equals(targetVersion)) {
 			// expecting source >= 1.5
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) < ClassFileConstants.JDK1_5) {
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForGenericSource", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForGenericSource", targetVersion, sourceVersion)); //$NON-NLS-1$
 			}
 		} else if (CompilerOptions.VERSION_CLDC1_1.equals(targetVersion)) {
 			if (this.didSpecifySource && CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_4) {
-				throw new IllegalArgumentException(this.bind("configure.incompatibleSourceForCldcTarget", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleSourceForCldcTarget", targetVersion, sourceVersion)); //$NON-NLS-1$
 			}
 			if (CompilerOptions.versionToJdkLevel(compliance) >= ClassFileConstants.JDK1_5) {
-				throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForCldcTarget", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForCldcTarget", targetVersion, sourceVersion)); //$NON-NLS-1$
 			}
 		} else {
 			// target must be 1.8 if source is 1.8
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_8
 					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_8){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_8)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", targetVersion, CompilerOptions.VERSION_1_8)); //$NON-NLS-1$
 			}
 			// target must be 1.7 if source is 1.7
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_7
 					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_7){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_7)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", targetVersion, CompilerOptions.VERSION_1_7)); //$NON-NLS-1$
 			}
 			// target must be 1.6 if source is 1.6
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_6
 					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_6){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", targetVersion, CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
 			}
 			// target must be 1.5 if source is 1.5
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_5
 					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_5){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", targetVersion, CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
 			}
 			// target must be 1.4 if source is 1.4
 			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_4
 					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_4){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleTargetForSource", targetVersion, CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
 			}
 			// target cannot be greater than compliance level
 			if (CompilerOptions.versionToJdkLevel(compliance) < CompilerOptions.versionToJdkLevel(targetVersion)){
-				throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForTarget", (String)this.options.get(CompilerOptions.OPTION_Compliance), (String) targetVersion)); //$NON-NLS-1$
+				throw new IllegalArgumentException(this.bind("configure.incompatibleComplianceForTarget", this.options.get(CompilerOptions.OPTION_Compliance), targetVersion)); //$NON-NLS-1$
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
index 3570dce..b69e6fe 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
@@ -25,7 +25,6 @@ import org.eclipse.jdt.internal.compiler.impl.*;
 import org.eclipse.jdt.internal.core.NameLookup;
 import org.eclipse.jdt.internal.core.SearchableEnvironment;
 
-@SuppressWarnings("rawtypes")
 public abstract class Engine implements ITypeRequestor {
 
 	public LookupEnvironment lookupEnvironment;
@@ -45,7 +44,7 @@ public abstract class Engine implements ITypeRequestor {
 	public int onDemandImportCacheCount = 0;
 	public char[] currentPackageName = null;
 
-	public Engine(Map settings){
+	public Engine(Map<String, String> settings){
 		this.options = new AssistOptions(settings);
 		this.compilerOptions = new CompilerOptions(settings);
 		this.forbiddenReferenceIsError =
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
index c27ea90..f613515 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
@@ -106,7 +106,7 @@ public class Compiler implements ITypeRequestor, ProblemSeverities {
 	public Compiler(
 			INameEnvironment environment,
 			IErrorHandlingPolicy policy,
-			Map settings,
+			Map<String, String> settings,
 			final ICompilerRequestor requestor,
 			IProblemFactory problemFactory) {
 		this(environment, policy, new CompilerOptions(settings), requestor, problemFactory, null /* printwriter */, null /* progress */);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index e66fac3..09e7892 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -511,7 +511,7 @@ public class CompilerOptions {
 	 * Initializing the compiler options with external settings
 	 * @param settings
 	 */
-	public CompilerOptions(Map settings){
+	public CompilerOptions(Map<String, String> settings){
 		resetDefaults();
 		if (settings != null) {
 			set(settings);
@@ -733,41 +733,39 @@ public class CompilerOptions {
 		return Util.EMPTY_STRING; // unknown version
 	}
 
-	public static long versionToJdkLevel(Object versionID) {
-		if (versionID instanceof String) {
-			String version = (String) versionID;
-			// verification is optimized for all versions with same length and same "1." prefix
-			if (version.length() == 3 && version.charAt(0) == '1' && version.charAt(1) == '.') {
-				switch (version.charAt(2)) {
-					case '1':
-						return ClassFileConstants.JDK1_1;
-					case '2':
-						return ClassFileConstants.JDK1_2;
-					case '3':
-						return ClassFileConstants.JDK1_3;
-					case '4':
-						return ClassFileConstants.JDK1_4;
-					case '5':
-						return ClassFileConstants.JDK1_5;
-					case '6':
-						return ClassFileConstants.JDK1_6;
-					case '7':
-						return ClassFileConstants.JDK1_7;
-					case '8':
-						return ClassFileConstants.JDK1_8;
-					case '9':
-						return ClassFileConstants.JDK1_9;
-					default:
-						return 0; // unknown
-				}
-			}
-			if (VERSION_JSR14.equals(versionID)) {
-				return ClassFileConstants.JDK1_4;
-			}
-			if (VERSION_CLDC1_1.equals(versionID)) {
-				return ClassFileConstants.CLDC_1_1;
+	public static long versionToJdkLevel(String versionID) {
+		String version = versionID;
+		// verification is optimized for all versions with same length and same "1." prefix
+		if (version.length() == 3 && version.charAt(0) == '1' && version.charAt(1) == '.') {
+			switch (version.charAt(2)) {
+				case '1':
+					return ClassFileConstants.JDK1_1;
+				case '2':
+					return ClassFileConstants.JDK1_2;
+				case '3':
+					return ClassFileConstants.JDK1_3;
+				case '4':
+					return ClassFileConstants.JDK1_4;
+				case '5':
+					return ClassFileConstants.JDK1_5;
+				case '6':
+					return ClassFileConstants.JDK1_6;
+				case '7':
+					return ClassFileConstants.JDK1_7;
+				case '8':
+					return ClassFileConstants.JDK1_8;
+				case '9':
+					return ClassFileConstants.JDK1_9;
+				default:
+					return 0; // unknown
 			}
 		}
+		if (VERSION_JSR14.equals(versionID)) {
+			return ClassFileConstants.JDK1_4;
+		}
+		if (VERSION_CLDC1_1.equals(versionID)) {
+			return ClassFileConstants.CLDC_1_1;
+		}
 		return 0; // unknown
 	}
 
@@ -1056,8 +1054,8 @@ public class CompilerOptions {
 	}
 
 	
-	public Map getMap() {
-		Map optionsMap = new HashMap(30);
+	public Map<String, String> getMap() {
+		Map<String, String> optionsMap = new HashMap<>(30);
 		optionsMap.put(OPTION_LocalVariableAttribute, (this.produceDebugAttributes & ClassFileConstants.ATTR_VARS) != 0 ? GENERATE : DO_NOT_GENERATE);
 		optionsMap.put(OPTION_LineNumberAttribute, (this.produceDebugAttributes & ClassFileConstants.ATTR_LINES) != 0 ? GENERATE : DO_NOT_GENERATE);
 		optionsMap.put(OPTION_SourceFileAttribute, (this.produceDebugAttributes & ClassFileConstants.ATTR_SOURCE) != 0 ? GENERATE : DO_NOT_GENERATE);
@@ -1369,8 +1367,8 @@ public class CompilerOptions {
 		this.complainOnUninternedIdentityComparison = false;
 	}
 
-	public void set(Map optionsMap) {
-		Object optionValue;
+	public void set(Map<String, String> optionsMap) {
+		String optionValue;
 		if ((optionValue = optionsMap.get(OPTION_LocalVariableAttribute)) != null) {
 			if (GENERATE.equals(optionValue)) {
 				this.produceDebugAttributes |= ClassFileConstants.ATTR_VARS;
@@ -1450,16 +1448,14 @@ public class CompilerOptions {
 			if (this.targetJDK >= ClassFileConstants.JDK1_5) this.inlineJsrBytecode = true; // forced from 1.5 mode on
 		}
 		if ((optionValue = optionsMap.get(OPTION_Encoding)) != null) {
-			if (optionValue instanceof String) {
-				this.defaultEncoding = null;
-				String stringValue = (String) optionValue;
-				if (stringValue.length() > 0){
-					try {
-						new InputStreamReader(new ByteArrayInputStream(new byte[0]), stringValue);
-						this.defaultEncoding = stringValue;
-					} catch(UnsupportedEncodingException e){
-						// ignore unsupported encoding
-					}
+			this.defaultEncoding = null;
+			String stringValue = optionValue;
+			if (stringValue.length() > 0){
+				try {
+					new InputStreamReader(new ByteArrayInputStream(new byte[0]), stringValue);
+					this.defaultEncoding = stringValue;
+				} catch(UnsupportedEncodingException e){
+					// ignore unsupported encoding
 				}
 			}
 		}
@@ -1506,34 +1502,28 @@ public class CompilerOptions {
 			}
 		}		
 		if ((optionValue = optionsMap.get(OPTION_MaxProblemPerUnit)) != null) {
-			if (optionValue instanceof String) {
-				String stringValue = (String) optionValue;
-				try {
-					int val = Integer.parseInt(stringValue);
-					if (val >= 0) this.maxProblemsPerUnit = val;
-				} catch(NumberFormatException e){
-					// ignore ill-formatted limit
-				}
+			String stringValue = optionValue;
+			try {
+				int val = Integer.parseInt(stringValue);
+				if (val >= 0) this.maxProblemsPerUnit = val;
+			} catch(NumberFormatException e){
+				// ignore ill-formatted limit
 			}
 		}
 		if ((optionValue = optionsMap.get(OPTION_TaskTags)) != null) {
-			if (optionValue instanceof String) {
-				String stringValue = (String) optionValue;
-				if (stringValue.length() == 0) {
-					this.taskTags = null;
-				} else {
-					this.taskTags = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());
-				}
+			String stringValue = optionValue;
+			if (stringValue.length() == 0) {
+				this.taskTags = null;
+			} else {
+				this.taskTags = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());
 			}
 		}
 		if ((optionValue = optionsMap.get(OPTION_TaskPriorities)) != null) {
-			if (optionValue instanceof String) {
-				String stringValue = (String) optionValue;
-				if (stringValue.length() == 0) {
-					this.taskPriorities = null;
-				} else {
-					this.taskPriorities = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());
-				}
+			String stringValue = optionValue;
+			if (stringValue.length() == 0) {
+				this.taskPriorities = null;
+			} else {
+				this.taskPriorities = CharOperation.splitAndTrimOn(',', stringValue.toCharArray());
 			}
 		}
 		if ((optionValue = optionsMap.get(OPTION_TaskCaseSensitive)) != null) {
@@ -1707,13 +1697,13 @@ public class CompilerOptions {
 			if ((optionValue = optionsMap.get(OPTION_ReportNullUncheckedConversion)) != null) updateSeverity(NullUncheckedConversion, optionValue);
 			if ((optionValue = optionsMap.get(OPTION_ReportRedundantNullAnnotation)) != null) updateSeverity(RedundantNullAnnotation, optionValue);
 			if ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {
-				this.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+				this.nullableAnnotationName = CharOperation.splitAndTrimOn('.', optionValue.toCharArray());
 			}
 			if ((optionValue = optionsMap.get(OPTION_NonNullAnnotationName)) != null) {
-				this.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+				this.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', optionValue.toCharArray());
 			}
 			if ((optionValue = optionsMap.get(OPTION_NonNullByDefaultAnnotationName)) != null) {
-				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', optionValue.toCharArray());
 			}
 			if ((optionValue = optionsMap.get(OPTION_ReportMissingNonNullByDefaultAnnotation)) != null) updateSeverity(MissingNonNullByDefaultAnnotation, optionValue);
 			if ((optionValue = optionsMap.get(OPTION_SyntacticNullAnalysisForFields)) != null) {
@@ -1800,7 +1790,7 @@ public class CompilerOptions {
 			updateSeverity(MissingJavadocComments, optionValue);
 		}
 		if ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocTagDescription)) != null) {
-			this.reportMissingJavadocTagDescription = (String) optionValue;
+			this.reportMissingJavadocTagDescription = optionValue;
 		}
 		if ((optionValue = optionsMap.get(OPTION_ReportMissingJavadocCommentsVisibility)) != null) {
 			if (PUBLIC.equals(optionValue)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index bf46194..b7746b8 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -84,10 +84,10 @@ class ASTConverter {
 	Scanner scanner;
 	private DefaultCommentMapper commentMapper;
 
-	public ASTConverter(Map options, boolean resolveBindings, IProgressMonitor monitor) {
+	public ASTConverter(Map<String, String> options, boolean resolveBindings, IProgressMonitor monitor) {
 		this.resolveBindings = resolveBindings;
 		this.referenceContext = null;
-		Object sourceModeSetting = options.get(JavaCore.COMPILER_SOURCE);
+		String sourceModeSetting = options.get(JavaCore.COMPILER_SOURCE);
 		long sourceLevel = CompilerOptions.versionToJdkLevel(sourceModeSetting);
 		if (sourceLevel == 0) {
 			// unknown sourceModeSetting
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEvaluator.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEvaluator.java
index fa32de9..1080cbe 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEvaluator.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEvaluator.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
  * A code snippet evaluator compiles and returns class file for a code snippet.
  * Or it reports problems against the code snippet.
  */
-@SuppressWarnings({ "rawtypes" })
 public class CodeSnippetEvaluator extends Evaluator implements EvaluationConstants {
 	/**
 	 * Whether the code snippet support classes should be found in the provided name environment
@@ -49,7 +48,7 @@ public class CodeSnippetEvaluator extends Evaluator implements EvaluationConstan
 /**
  * Creates a new code snippet evaluator.
  */
-CodeSnippetEvaluator(char[] codeSnippet, EvaluationContext context, INameEnvironment environment, Map options, IRequestor requestor, IProblemFactory problemFactory) {
+CodeSnippetEvaluator(char[] codeSnippet, EvaluationContext context, INameEnvironment environment, Map<String, String> options, IRequestor requestor, IProblemFactory problemFactory) {
 	super(context, environment, options, requestor, problemFactory);
 	this.codeSnippet = codeSnippet;
 }
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
index b868fd2..b38d05b 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
@@ -39,7 +39,6 @@ import org.eclipse.jdt.internal.core.util.Util;
 /**
  * @see org.eclipse.jdt.core.eval.IEvaluationContext
  */
-@SuppressWarnings("rawtypes")
 public class EvaluationContext implements EvaluationConstants, SuffixConstants {
 	/**
 	 * Global counters so that several evaluation context can deploy on the same runtime.
@@ -112,7 +111,7 @@ public void complete(
 		int completionPosition,
 		SearchableEnvironment environment,
 		CompletionRequestor requestor,
-		Map options,
+		Map<String, String> options,
 		final IJavaProject project,
 		WorkingCopyOwner owner,
 		IProgressMonitor monitor) {
@@ -241,7 +240,7 @@ public void evaluate(
 	boolean contextIsStatic,
 	boolean contextIsConstructorCall,
 	INameEnvironment environment,
-	Map options,
+	Map<String, String> options,
 	final IRequestor requestor,
 	IProblemFactory problemFactory) throws InstallException {
 
@@ -312,7 +311,7 @@ public void evaluate(
  * @see org.eclipse.jdt.core.eval.IEvaluationContext
  * @exception org.eclipse.jdt.internal.eval.InstallException if the code snippet class files could not be deployed.
  */
-public void evaluate(char[] codeSnippet, INameEnvironment environment, Map options, final IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
+public void evaluate(char[] codeSnippet, INameEnvironment environment, Map<String, String> options, final IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
 	this.evaluate(
 		codeSnippet,
 		null,
@@ -375,14 +374,14 @@ public void evaluateImports(INameEnvironment environment, IRequestor requestor,
  * @exception org.eclipse.jdt.internal.eval.InstallException if the code snippet class files could not be deployed.
  * @exception java.lang.IllegalArgumentException if the global has not been installed yet.
  */
-public void evaluateVariable(GlobalVariable variable, INameEnvironment environment, Map options, IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
+public void evaluateVariable(GlobalVariable variable, INameEnvironment environment, Map<String, String> options, IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
 	this.evaluate(variable.getName(), environment, options, requestor, problemFactory);
 }
 /**
  * @see org.eclipse.jdt.core.eval.IEvaluationContext
  * @exception org.eclipse.jdt.internal.eval.InstallException if the code snippet class files could not be deployed.
  */
-public void evaluateVariables(INameEnvironment environment, Map options, IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
+public void evaluateVariables(INameEnvironment environment, Map<String, String> options, IRequestor requestor, IProblemFactory problemFactory) throws InstallException {
 	deployCodeSnippetClassIfNeeded(requestor);
 	VariablesEvaluator evaluator = new VariablesEvaluator(this, environment, options, requestor, problemFactory);
 	ClassFile[] classes = evaluator.getClasses();
@@ -574,7 +573,7 @@ public void select(
 	int selectionSourceEnd,
 	SearchableEnvironment environment,
 	ISelectionRequestor requestor,
-	Map options,
+	Map<String, String> options,
 	WorkingCopyOwner owner) {
 
 	final char[] className = "CodeSnippetSelection".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/Evaluator.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/Evaluator.java
index 837d0e9..cd78ef9 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/Evaluator.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/Evaluator.java
@@ -36,13 +36,13 @@ import org.eclipse.jdt.internal.core.util.Util;
 public abstract class Evaluator {
 	EvaluationContext context;
 	INameEnvironment environment;
-	Map options;
+	Map<String, String> options;
 	IRequestor requestor;
 	IProblemFactory problemFactory;
 /**
  * Creates a new evaluator.
  */
-Evaluator(EvaluationContext context, INameEnvironment environment, Map options, IRequestor requestor, IProblemFactory problemFactory) {
+Evaluator(EvaluationContext context, INameEnvironment environment, Map<String, String> options, IRequestor requestor, IProblemFactory problemFactory) {
 	this.context = context;
 	this.environment = environment;
 	this.options = options;
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/VariablesEvaluator.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/VariablesEvaluator.java
index 59554fb..4c6771e 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/VariablesEvaluator.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/VariablesEvaluator.java
@@ -26,12 +26,11 @@ import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
  * A variables evaluator compiles the global variables of an evaluation context and returns
  * the corresponding class files. Or it reports problems against these variables.
  */
-@SuppressWarnings({"rawtypes"})
 public class VariablesEvaluator extends Evaluator implements EvaluationConstants {
 /**
  * Creates a new global variables evaluator.
  */
-VariablesEvaluator(EvaluationContext context, INameEnvironment environment, Map options, IRequestor requestor, IProblemFactory problemFactory) {
+VariablesEvaluator(EvaluationContext context, INameEnvironment environment, Map<String, String> options, IRequestor requestor, IProblemFactory problemFactory) {
 	super(context, environment, options, requestor, problemFactory);
 }
 /**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CorrectionEngine.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CorrectionEngine.java
index 55545b1..e783c72 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CorrectionEngine.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CorrectionEngine.java
@@ -236,7 +236,7 @@ public class CorrectionEngine {
 	private void correct(char[] argument) {
 		try {
 			String source = this.compilationUnit.getSource();
-			Map currentProjectOptions = this.compilationUnit.getJavaProject().getOptions(true);
+			Map<String,String> currentProjectOptions = this.compilationUnit.getJavaProject().getOptions(true);
 			long sourceLevel = CompilerOptions.versionToJdkLevel(currentProjectOptions.get(JavaCore.COMPILER_SOURCE));
 			long complianceLevel = CompilerOptions.versionToJdkLevel(currentProjectOptions.get(JavaCore.COMPILER_COMPLIANCE));
 			
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
index 2adaa8c..f18b0e1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
@@ -23,7 +23,6 @@ import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 import org.eclipse.jdt.internal.compiler.util.SimpleSetOfCharArray;
 
-@SuppressWarnings("rawtypes")
 public class InternalNamingConventions {
 	private static final char[] DEFAULT_NAME = "name".toCharArray(); //$NON-NLS-1$
 
@@ -549,7 +548,7 @@ public class InternalNamingConventions {
 		if(baseName == null || baseName.length == 0)
 			return;
 		
-		Map options;
+		Map<String, String> options;
 		if (javaProject != null) {
 			options = javaProject.getOptions(true);
 		} else {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index e03896a..49b71ab 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -2227,7 +2227,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 
 	// Do not modify without modifying getDefaultOptions()
 	private Hashtable getDefaultOptionsNoInitialization() {
-		Map defaultOptionsMap = new CompilerOptions().getMap(); // compiler defaults
+		Map<String, String> defaultOptionsMap = new CompilerOptions().getMap(); // compiler defaults
 
 		// Override some compiler defaults
 		defaultOptionsMap.put(JavaCore.COMPILER_LOCAL_VARIABLE_ATTR, JavaCore.GENERATE);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/jdom/SimpleDOMBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/jdom/SimpleDOMBuilder.java
index b8d38c9..f7fd842 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/jdom/SimpleDOMBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/jdom/SimpleDOMBuilder.java
@@ -30,7 +30,6 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
  * powerful, fine-grained DOM/AST API found in the
  * org.eclipse.jdt.core.dom package.
  */
-@SuppressWarnings({"rawtypes"})
 public class SimpleDOMBuilder extends AbstractDOMBuilder implements ISourceElementRequestor {
 
 /**
@@ -188,7 +187,7 @@ public void exitType(int declarationEnd) {
 /**
  * Creates a new parser.
  */
-protected SourceElementParser getParser(Map settings) {
+protected SourceElementParser getParser(Map<String, String> settings) {
 	return new SourceElementParser(this, new DefaultProblemFactory(), new CompilerOptions(settings), false/*don't report local declarations*/, true/*optimize string literals*/);
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
index 29f5553..7b8593d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 /**
  * Utility class to parse different code snippets
  */
-@SuppressWarnings("rawtypes")
 public class CodeSnippetParsingUtil {
 
 	public RecordedParsingInformation recordedParsingInformation;
@@ -57,7 +56,7 @@ public class CodeSnippetParsingUtil {
 		return new RecordedParsingInformation(problems, compilationResult.getLineSeparatorPositions(), commentPositions);
 	}
 
-	public ASTNode[] parseClassBodyDeclarations(char[] source, Map settings, boolean recordParsingInformation) {
+	public ASTNode[] parseClassBodyDeclarations(char[] source, Map<String, String> settings, boolean recordParsingInformation) {
 		return parseClassBodyDeclarations(source, 0, source.length, settings, recordParsingInformation, false);
 	}
 
@@ -65,7 +64,7 @@ public class CodeSnippetParsingUtil {
 			char[] source,
 			int offset,
 			int length,
-			Map settings,
+			Map<String, String> settings,
 			boolean recordParsingInformation,
 			boolean enabledStatementRecovery) {
 		if (source == null) {
@@ -98,7 +97,7 @@ public class CodeSnippetParsingUtil {
 		return result;
 	}
 
-	public CompilationUnitDeclaration parseCompilationUnit(char[] source, Map settings, boolean recordParsingInformation) {
+	public CompilationUnitDeclaration parseCompilationUnit(char[] source, Map<String, String> settings, boolean recordParsingInformation) {
 		if (source == null) {
 			throw new IllegalArgumentException();
 		}
@@ -146,11 +145,11 @@ public class CodeSnippetParsingUtil {
 		return compilationUnitDeclaration;
 	}
 
-	public Expression parseExpression(char[] source, Map settings, boolean recordParsingInformation) {
+	public Expression parseExpression(char[] source, Map<String, String> settings, boolean recordParsingInformation) {
 		return parseExpression(source, 0, source.length, settings, recordParsingInformation);
 	}
 
-	public Expression parseExpression(char[] source, int offset, int length, Map settings, boolean recordParsingInformation) {
+	public Expression parseExpression(char[] source, int offset, int length, Map<String, String> settings, boolean recordParsingInformation) {
 
 		if (source == null) {
 			throw new IllegalArgumentException();
@@ -180,7 +179,7 @@ public class CodeSnippetParsingUtil {
 		return result;
 	}
 
-	public ConstructorDeclaration parseStatements(char[] source, Map settings, boolean recordParsingInformation, boolean enabledStatementRecovery) {
+	public ConstructorDeclaration parseStatements(char[] source, Map<String, String> settings, boolean recordParsingInformation, boolean enabledStatementRecovery) {
 		return parseStatements(source, 0, source.length, settings, recordParsingInformation, enabledStatementRecovery);
 	}
 
@@ -188,7 +187,7 @@ public class CodeSnippetParsingUtil {
 			char[] source,
 			int offset,
 			int length,
-			Map settings,
+			Map<String, String> settings,
 			boolean recordParsingInformation,
 			boolean enabledStatementRecovery) {
 		if (source == null) {
