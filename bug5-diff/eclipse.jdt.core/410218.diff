commit 689526016f6ab442680e718d2760fc44e79dd9b5
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Mar 8 20:25:37 2015 +0100

    Bug 410218 - Optional warning for arguments of "unexpected" types to
    Map#get(Object), Collection#remove(Object) et al.
    
    Change-Id: I15dfb4968b955cbcd7c8ede1dee4c02d2be4ce3d
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>

4	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
243	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
92	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
31	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
6	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
17	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
68	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
18	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
29	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
39	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index d47c9cc..f38226f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1983,6 +1983,8 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecation\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod\" value=\"disabled\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.emptyStatement\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.enumIdentifier\" value=\"warning\"/>\n" + 
@@ -2961,7 +2963,7 @@ public void test032(){
 				"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		p1.putAll(m1);\n" +
 				"	}\n" +
-				"\n" +
+				"	@SuppressWarnings(\"unlikely-arg-type\")\n" +
 				"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		m1.keySet().retainAll(p1.keySet());\n" +
 				"		m2.keySet().retainAll(p1.keySet());\n" +
@@ -3142,7 +3144,7 @@ public void test032(){
 			"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		p1.putAll(m1);\n" +
 			"	}\n" +
-			"\n" +
+			"	@SuppressWarnings(\"unlikely-arg-type\")\n" +
 			"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		m1.keySet().retainAll(p1.keySet());\n" +
 			"		m2.keySet().retainAll(p1.keySet());\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 6dc56dd..0595ea0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -458,6 +458,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("DisallowedTargetForContainerAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DisallowedExplicitThisParameter", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("DiscouragedInvocationIncompatibleArgument", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(CategorizedProblem.CAT_RESTRICTION));
 		expectedProblemAttributes.put("DuplicateAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateAnnotationNotMarkedRepeatable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -1284,6 +1286,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForContainerAnnotationType", SKIP);
+		expectedProblemAttributes.put("DiscouragedInvocationIncompatibleArgument", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE));
+		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE));
 		expectedProblemAttributes.put("DuplicateAnnotation", SKIP);
 		expectedProblemAttributes.put("DuplicateAnnotationNotMarkedRepeatable", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index b97333c..fd3b222 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2001, 2014 IBM Corporation and others.
+ * Copyright (c) 2001, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *     						bug 185682 - Increment/decrement operators mark local variables as read
  *     						bug 328281 - visibility leaks not detected when analyzing unused field in private class
+ *							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -2703,4 +2704,245 @@ public void test0063() throws Exception {
 		true/*shouldFlushOutputDirectory*/,
 		customOptions);
 }
+// Collection: contains & remove & get
+public void testBug410218a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  void test() {\n" +
+			"	Set<Short> set = new HashSet<Short>();\n" + 
+			"	short one = 1;\n" + 
+			"	set.add(one);\n" + 
+			"\n" + 
+			"	if (set.contains(\"ONE\")) // bad\n" +
+			"		set.remove(\"ONE\"); // bad\n" + 
+			"	if (set.contains(1)) // bad\n" +
+			"		set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
+			"	System.out.println(set); // shows that the \"Short 1\" is still in!\n" + 
+			"\n" + 
+			"	if (set.contains(one)) // ok\n" +
+			"		set.remove(one); // ok\n" + 
+			"	if (set.contains(Short.valueOf(one))) // ok\n" +
+			"		set.remove(Short.valueOf(one)); // ok\n" + 
+			"	System.out.println(set);\n" +
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 8)\n" + 
+		"	if (set.contains(\"ONE\")) // bad\n" + 
+		"	                 ^^^^^\n" + 
+		"Discouraged invocation of method contains(Object). Argument type String cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	set.remove(\"ONE\"); // bad\n" + 
+		"	           ^^^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 10)\n" + 
+		"	if (set.contains(1)) // bad\n" + 
+		"	                 ^\n" + 
+		"Discouraged invocation of method contains(Object). Argument type int cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 11)\n" + 
+		"	set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
+		"	           ^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type int cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
+		"----------\n");
+}
+// HashSet vs. TreeSet or: to be castable or not
+public void testBug410218b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts) {\n" +
+			"	if (hss.contains(ts)) // bad\n" +
+			"		hss.remove(ts); // bad\n" + 
+			"	if (hss.contains((Set<T>)ts)) // less bad\n" +
+			"		hss.remove((Set<T>)ts); // less bad\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (hss.contains(ts)) // bad\n" + 
+		"	                 ^^\n" + 
+		"Discouraged invocation of method contains(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	hss.remove(ts); // bad\n" + 
+		"	           ^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 6)\n" + 
+		"	if (hss.contains((Set<T>)ts)) // less bad\n" + 
+		"	                 ^^^^^^^^^^\n" + 
+		"Discouraged invocation of method contains(Object). Argument type Set<T> is incompatible with the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 7)\n" + 
+		"	hss.remove((Set<T>)ts); // less bad\n" + 
+		"	           ^^^^^^^^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type Set<T> is incompatible with the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n");
+}
+// Map: contains* & remove & get
+public void testBug410218c() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  Number test(Map<? extends Number, Number> m, boolean f) {\n" +
+			"	if (m.containsKey(\"ONE\")) // bad\n" + 
+			"		m.remove(\"ONE\"); // bad\n" +
+			"	if (m.containsValue(\"ONE\")) // bad\n" + 
+			"		m.remove(\"ONE\"); // bad\n" + 
+			"	short one = 1;\n" +
+			"	if (m.containsKey(one)) // almost ok\n" +
+			"		m.remove(one); // almost ok\n" +
+			"	if (m.containsValue(Short.valueOf(one))) // ok\n" + 
+			"		m.remove(Short.valueOf(one)); // almost ok\n" + 
+			"	if (f)\n" +
+			"		return m.get(\"ONE\"); // bad\n" +
+			"	return m.get(one);\n // almost ok\n" +
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (m.containsKey(\"ONE\")) // bad\n" + 
+		"	                  ^^^^^\n" + 
+		"Discouraged invocation of method containsKey(Object). Argument type String cannot be cast to the likely type capture#1-of ? extends Number according to the declaring type Map<capture#1-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	m.remove(\"ONE\"); // bad\n" + 
+		"	         ^^^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type capture#2-of ? extends Number according to the declaring type Map<capture#2-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 6)\n" + 
+		"	if (m.containsValue(\"ONE\")) // bad\n" + 
+		"	                    ^^^^^\n" + 
+		"Discouraged invocation of method containsValue(Object). Argument type String cannot be cast to the likely type Number according to the declaring type Map<capture#3-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 7)\n" + 
+		"	m.remove(\"ONE\"); // bad\n" + 
+		"	         ^^^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type capture#4-of ? extends Number according to the declaring type Map<capture#4-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"5. WARNING in X.java (at line 9)\n" + 
+		"	if (m.containsKey(one)) // almost ok\n" + 
+		"	                  ^^^\n" + 
+		"Discouraged invocation of method containsKey(Object). Argument type short is incompatible with the likely type capture#5-of ? extends Number according to the declaring type Map<capture#5-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"6. WARNING in X.java (at line 10)\n" + 
+		"	m.remove(one); // almost ok\n" + 
+		"	         ^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type short is incompatible with the likely type capture#6-of ? extends Number according to the declaring type Map<capture#6-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"7. WARNING in X.java (at line 12)\n" + 
+		"	m.remove(Short.valueOf(one)); // almost ok\n" + 
+		"	         ^^^^^^^^^^^^^^^^^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type Short is incompatible with the likely type capture#8-of ? extends Number according to the declaring type Map<capture#8-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 14)\n" + 
+		"	return m.get(\"ONE\"); // bad\n" + 
+		"	             ^^^^^\n" + 
+		"Discouraged invocation of method get(Object). Argument type String cannot be cast to the likely type capture#9-of ? extends Number according to the declaring type Map<capture#9-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"9. WARNING in X.java (at line 15)\n" + 
+		"	return m.get(one);\n" + 
+		"	             ^^^\n" + 
+		"Discouraged invocation of method get(Object). Argument type short is incompatible with the likely type capture#10-of ? extends Number according to the declaring type Map<capture#10-of ? extends Number,Number>\n" + 
+		"----------\n");
+}
+// Collection: {contains,remove,retain}All, non-generic sub type of Collection, configured to be ERROR
+public void testBug410218d() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE, JavaCore.ERROR);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"interface NumberCollection extends Collection<Number> {}\n" +
+			"class X {\n" +
+			"  void test(NumberCollection numbers, List<Integer> ints, Set<Number> numberSet) {\n" +
+			"	if (numbers.containsAll(ints)) // bad\n" +
+			"		numbers.removeAll(ints); // bad\n" + 
+			"	else\n" +
+			"		numbers.retainAll(ints); // bad\n" + 
+			"\n" + 
+			"	numbers.removeAll(numberSet); // ok\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (numbers.containsAll(ints)) // bad\n" + 
+		"	                        ^^^^\n" + 
+		"Discouraged invocation of method containsAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	numbers.removeAll(ints); // bad\n" + 
+		"	                  ^^^^\n" + 
+		"Discouraged invocation of method removeAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 8)\n" + 
+		"	numbers.retainAll(ints); // bad\n" + 
+		"	                  ^^^^\n" + 
+		"Discouraged invocation of method retainAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// List.indexOf: w/ and w/o @SuppressWarnings
+public void testBug410218e() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE, JavaCore.WARNING);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  int test1(List<Integer> ints, Object o) {\n" +
+			"	return ints.indexOf(\"ONE\"); // bad\n" + 
+			"  }\n" +
+			"  @SuppressWarnings(\"unlikely-arg-type\")\n" +
+			"  int test2(List<Integer> ints, boolean f, Object o) {\n" +
+			"	if (f)\n" +
+			"		return ints.indexOf(\"ONE\"); // bad but suppressed\n" +
+			"	return ints.indexOf(o); // not suppressable error\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	return ints.indexOf(\"ONE\"); // bad\n" + 
+		"	                    ^^^^^\n" + 
+		"Discouraged invocation of method indexOf(Object). Argument type String cannot be cast to the likely type Integer according to the declaring type List<Integer>\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	return ints.indexOf(o); // not suppressable error\n" + 
+		"	                    ^\n" + 
+		"Discouraged invocation of method indexOf(Object). Argument type Object is incompatible with the likely type Integer according to the declaring type List<Integer>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index d30135f..afb7ecd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -196,6 +196,8 @@
  *									IllegalParameterNullityRedefinition
  *									ContradictoryNullAnnotationsInferredFunctionType
  *									IllegalReturnNullityRedefinitionFreeTypeVariable
+ *									DiscouragedInvocationIncompatibleArgument
+ *									DiscouragedInvocationArgumentNotCastable
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1845,4 +1847,9 @@ void setSourceStart(int sourceStart);
 	/** @deprecated - problem is no longer generated (implementation issue has been resolved)
 	 * @since 3.10 */
 	int LambdaShapeComputationError = 1101;
+	
+	/** @since 3.11 */
+	int DiscouragedInvocationIncompatibleArgument = 1200;
+	/** @since 3.11 */
+	int DiscouragedInvocationArgumentNotCastable = 1201;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 6c2ade9..25d7364 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -50,6 +50,7 @@
  *								Bug 441734 - [1.8][inference] Generic method with nested parameterized type argument fails on method reference
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
  *								Bug 456487 - [1.8][null] @Nullable type variant of @NonNull-constrained type parameter causes grief
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -72,6 +73,7 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
@@ -84,6 +86,7 @@ import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolymorphicMethodBinding;
@@ -159,6 +162,23 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			}
 		}
 	}
+	if (compilerOptions.isAnyEnabled(IrritantSet.UNLIKELY_ARGUMENT_TYPE) && this.binding.isValidBinding()) {
+		TypeBinding[] signatureReplacement = detectAndReplaceDangerousSignature(currentScope);
+		if (signatureReplacement != null) {
+			int len = this.argumentTypes.length;
+			for (int i = 0; i < len; i++) {
+				TypeBinding expectedArgumentType = signatureReplacement[i];
+				TypeBinding argumentType = this.argumentTypes[i];
+				if (argumentType.isBaseType())
+					argumentType = currentScope.boxing(argumentType);
+				if (!argumentType.isCompatibleWith(expectedArgumentType, currentScope)) {
+					boolean castable = checkCastTypesCompatibility(currentScope, expectedArgumentType, argumentType, this.arguments[i]);
+					currentScope.problemReporter().discouragedInvocationIncompatibleArgument(this.binding, this.arguments[i],
+								expectedArgumentType, signatureReplacement[len], castable);
+				}
+			}
+		}
+	}
 
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
@@ -294,6 +314,78 @@ private int detectAssertionUtility(int argumentIdx) {
 	}
 	return 0;
 }
+// when targeting a well-known dangerous method, returns the "expected" signature plus the declaring type (as the last array element)
+TypeBinding[] detectAndReplaceDangerousSignature(Scope scope) {
+
+	// detecting only methods with a single argument, typed either as Object or as Collection:
+	TypeBinding[] parameters = this.binding.parameters;
+	if (parameters.length != 1)
+		return null;
+	int paramTypeId = parameters[0].original().id;
+	if (paramTypeId != TypeIds.T_JavaLangObject && paramTypeId != TypeIds.T_JavaUtilCollection)
+		return null;
+
+	// check selectors before typeBits as to avoid unnecessary super-traversals for the receiver type
+	DangerousMethod suspect = DangerousMethod.detectSelector(this.selector);
+	if (suspect == null) 
+		return null;
+
+	if (this.actualReceiverType.hasTypeBit(TypeIds.BitMap)) {
+		if (paramTypeId == TypeIds.T_JavaLangObject) {
+			switch (suspect) {
+				case ContainsKey:
+				case Get:
+				case Remove:
+					// map operations taking a key
+					ReferenceBinding mapType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
+					if (mapType != null && mapType.isParameterizedType())
+						return new TypeBinding[] { ((ParameterizedTypeBinding)mapType).typeArguments()[0], mapType };
+					break;
+				case ContainsValue:
+					// map operation taking a value
+					mapType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
+					if (mapType != null && mapType.isParameterizedType())
+						return new TypeBinding[] { ((ParameterizedTypeBinding)mapType).typeArguments()[1], mapType };
+			}
+		}
+	}
+	if (this.actualReceiverType.hasTypeBit(TypeIds.BitCollection)) {
+		if (paramTypeId == TypeIds.T_JavaLangObject) {
+			switch (suspect) {
+				case Remove:
+				case Contains:
+					// collection operations taking a single element
+					ReferenceBinding collectionType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
+					if (collectionType != null && collectionType.isParameterizedType())
+						return new TypeBinding[] { ((ParameterizedTypeBinding)collectionType).typeArguments()[0], collectionType };
+			}
+		} else if (paramTypeId == TypeIds.T_JavaUtilCollection) {
+			switch (suspect) {
+				case RemoveAll:
+				case ContainsAll:
+				case RetainAll:
+					// collection operations taking another collection
+					ReferenceBinding collectionType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
+					if (collectionType != null)
+						return new TypeBinding[] { collectionType, collectionType };
+			}
+		}
+		if (this.actualReceiverType.hasTypeBit(TypeIds.BitList)) {
+			if (paramTypeId == TypeIds.T_JavaLangObject) {
+				switch (suspect) {
+					case IndexOf:
+					case LastIndexOf:
+						// list operations taking a single element
+						ReferenceBinding listType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilList, false);
+						if (listType != null && listType.isParameterizedType())
+							return new TypeBinding[] { ((ParameterizedTypeBinding)listType).typeArguments()[0], listType };
+				}
+			}
+		}
+	} 
+	return null; // not replacing
+}
+
 private FlowInfo analyseBooleanAssertion(BlockScope currentScope, Expression argument,
 		FlowContext flowContext, FlowInfo flowInfo, boolean wasInsideAssert, boolean passOnTrue)
 {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index a1c2a24..be604fd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -20,6 +20,7 @@
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
@@ -161,9 +162,11 @@ public class CompilerOptions {
 	public static final String OPTION_ReportMethodCanBeStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportMethodCanBePotentiallyStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportRedundantSpecificationOfTypeArguments =  "org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments"; //$NON-NLS-1$
+
 	public static final String OPTION_ReportUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.unclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportPotentiallyUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportExplicitlyClosedAutoCloseable = "org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+
 	public static final String OPTION_ReportNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.nullSpecViolation";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullAnnotationInferenceConflict = "org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullUncheckedConversion = "org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion";  //$NON-NLS-1$
@@ -181,6 +184,10 @@ public class CompilerOptions {
 	public static final String OPTION_SyntacticNullAnalysisForFields = "org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
+
+	public static final String OPTION_ReportDiscouragedInvocationIncompatibleArgument = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
+	public static final String OPTION_ReportDiscouragedInvocationArgumenNotCastable = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable"; //$NON-NLS-1$
+
 	/**
 	 * Possible values for configurable options
 	 */
@@ -298,6 +305,8 @@ public class CompilerOptions {
 	public static final int UnusedTypeParameter = IrritantSet.GROUP2 | ASTNode.Bit17;
 	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
+	public static final int UnlikelyArgumentType = IrritantSet.GROUP2 | ASTNode.Bit20;
+	public static final int UnlikelyArgumentTypeNotCastable = IrritantSet.GROUP2 | ASTNode.Bit21;
 
 	// Severity level for handlers
 	/** 
@@ -312,12 +321,12 @@ public class CompilerOptions {
 	protected IrritantSet warningThreshold;
 	
 	/**
-	 * Default settings are to be defined in {@lnk CompilerOptions#resetDefaults()}
+	 * Default settings are to be defined in {@link CompilerOptions#resetDefaults()}
 	 */
 	
 	/** Classfile debug information, may contain source file name, line numbers, local variable tables, etc... */
 	public int produceDebugAttributes; 
-	/** Classfile method patameters information as per JEP 118... */
+	/** Classfile method parameters information as per JEP 118... */
 	public boolean produceMethodParameters;
 	/** Indicates whether generic signature should be generated for lambda expressions */
 	public boolean generateGenericSignatureForLambdaExpressions;
@@ -490,6 +499,7 @@ public class CompilerOptions {
 		"synthetic-access", //$NON-NLS-1$
 		"sync-override",	//$NON-NLS-1$
 		"unchecked", //$NON-NLS-1$
+		"unlikely-arg-type",  //$NON-NLS-1$
 		"unqualified-field-access", //$NON-NLS-1$
 		"unused", //$NON-NLS-1$
 	};
@@ -681,6 +691,10 @@ public class CompilerOptions {
 				return OPTION_ReportRedundantNullAnnotation;
 			case NonnullParameterAnnotationDropped:
 				return OPTION_ReportNonnullParameterAnnotationDropped;
+			case UnlikelyArgumentType:
+				return OPTION_ReportDiscouragedInvocationIncompatibleArgument;
+			case UnlikelyArgumentTypeNotCastable:
+				return OPTION_ReportDiscouragedInvocationArgumenNotCastable;
 		}
 		return null;
 	}
@@ -874,7 +888,9 @@ public class CompilerOptions {
 			OPTION_SyntacticNullAnalysisForFields,
 			OPTION_ReportUnusedTypeParameter,
 			OPTION_InheritNullAnnotations,
-			OPTION_ReportNonnullParameterAnnotationDropped
+			OPTION_ReportNonnullParameterAnnotationDropped,
+			OPTION_ReportDiscouragedInvocationIncompatibleArgument,
+			OPTION_ReportDiscouragedInvocationArgumenNotCastable
 		};
 		return result;
 	}
@@ -964,6 +980,9 @@ public class CompilerOptions {
 				return "javadoc"; //$NON-NLS-1$
 			case MissingSynchronizedModifierInInheritedMethod:
 				return "sync-override";	 //$NON-NLS-1$
+			case UnlikelyArgumentType:
+			case UnlikelyArgumentTypeNotCastable:
+				return "unlikely-arg-type"; //$NON-NLS-1$
 		}
 		return null;
 	}
@@ -1044,6 +1063,8 @@ public class CompilerOptions {
 					return IrritantSet.UNCHECKED;
 				if ("unqualified-field-access".equals(warningToken)) //$NON-NLS-1$
 					return IrritantSet.UNQUALIFIED_FIELD_ACCESS;
+				if ("unlikely-arg-type".equals(warningToken)) //$NON-NLS-1$
+					return IrritantSet.UNLIKELY_ARGUMENT_TYPE;
 				break;
 		}
 		return null;
@@ -1184,6 +1205,8 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportDiscouragedInvocationIncompatibleArgument, getSeverityString(UnlikelyArgumentType));
+		optionsMap.put(OPTION_ReportDiscouragedInvocationArgumenNotCastable, getSeverityString(UnlikelyArgumentTypeNotCastable));
 		return optionsMap;
 	}
 
@@ -1667,6 +1690,8 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportPotentiallyUnclosedCloseable)) != null) updateSeverity(PotentiallyUnclosedCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportExplicitlyClosedAutoCloseable)) != null) updateSeverity(ExplicitlyClosedAutoCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedTypeParameter)) != null) updateSeverity(UnusedTypeParameter, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationIncompatibleArgument)) != null) updateSeverity(UnlikelyArgumentType, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationArgumenNotCastable)) != null) updateSeverity(UnlikelyArgumentTypeNotCastable, optionValue);
 		if (getSeverity(UnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(PotentiallyUnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(ExplicitlyClosedAutoCloseable) == ProblemSeverities.Ignore) {
@@ -1956,6 +1981,8 @@ public class CompilerOptions {
 		buf.append("\n\t- resource may not be closed: ").append(getSeverityString(PotentiallyUnclosedCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- resource should be handled by try-with-resources: ").append(getSeverityString(ExplicitlyClosedAutoCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
+		buf.append("\n\t- discouraged invocation, unlikely argument: ").append(getSeverityString(UnlikelyArgumentType)); //$NON-NLS-1$
+		buf.append("\n\t- discouraged invocation, unlikely argument, not castable: ").append(getSeverityString(UnlikelyArgumentTypeNotCastable)); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index b4d0330..c4bd9d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								Bug 441208 - [1.8][null]SuppressWarnings("null") does not suppress / marked Unnecessary
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -67,6 +68,7 @@ public class IrritantSet {
 	public static final IrritantSet UNCHECKED = new IrritantSet(CompilerOptions.UncheckedTypeOperation);
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 	public static final IrritantSet RESOURCE = new IrritantSet(CompilerOptions.UnclosedCloseable);
+	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyArgumentType|CompilerOptions.UnlikelyArgumentTypeNotCastable);
 
 	public static final IrritantSet JAVADOC = new IrritantSet(CompilerOptions.InvalidJavadoc);
 	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
@@ -114,7 +116,9 @@ public class IrritantSet {
 				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation
-				|CompilerOptions.NonnullParameterAnnotationDropped);
+				|CompilerOptions.NonnullParameterAnnotationDropped
+				|CompilerOptions.UnlikelyArgumentType
+				|CompilerOptions.UnlikelyArgumentTypeNotCastable);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 949bd2e..3afdb1d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -87,6 +87,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		if (enclosingType != null && enclosingType.hasNullTypeAnnotations())
 			this.tagBits |= TagBits.HasNullTypeAnnotation;
 		this.tagBits |=  TagBits.HasUnresolvedTypeVariables; // cleared in resolve()
+		this.typeBits = type.typeBits;
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 61cb9f9..a2e7723 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,6 +34,7 @@
  *								Bug 440759 - [1.8][null] @NonNullByDefault should never affect wildcards and uses of a type variable
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
  *								Bug 446442 - [1.8] merge null annotations from super methods
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -497,13 +498,27 @@ public void computeId() {
 						if (CharOperation.equals(packageName, TypeConstants.UTIL)) {
 							switch (typeName[0]) {
 								case 'C' :
-									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2]))
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2])) {
 										this.id = TypeIds.T_JavaUtilCollection;
+										this.typeBits |= TypeIds.BitCollection;
+									}										
 									return;
 								case 'I' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_ITERATOR[2]))
 										this.id = TypeIds.T_JavaUtilIterator;
 									return;
+								case 'L' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_LIST[2])) {
+										this.id = TypeIds.T_JavaUtilList;
+										this.typeBits |= TypeIds.BitList;
+									}										
+									return;
+								case 'M' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_MAP[2])) {
+										this.id = TypeIds.T_JavaUtilMap;
+										this.typeBits |= TypeIds.BitMap;
+									}
+									return;
 								case 'O' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_OBJECTS[2]))
 										this.id = TypeIds.T_JavaUtilObjects;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 4cc9bda..d048a2b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,7 @@
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 425183 - [1.8][inference] make CaptureBinding18 safe
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *    Jesper S Moller - Contributions for
  *								Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -25,6 +26,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
+
 // TODO should rename into TypeNames (once extracted last non name constants)
 public interface TypeConstants {
 
@@ -156,6 +159,7 @@ public interface TypeConstants {
 	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_OBJECTS = {JAVA, UTIL, "Objects".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_LIST = {JAVA, UTIL, "List".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
@@ -329,6 +333,69 @@ public interface TypeConstants {
 	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {COM, GOOGLE, INJECT_PACKAGE, INJECT_TYPE };
 	//    detail for the above:
 	char[] OPTIONAL = "optional".toCharArray(); //$NON-NLS-1$
+	
+	// well-known methods with "dangerous" signatures:
+	char[][] JAVA_UTIL_MAP = new char[][] { JAVA, UTIL, "Map".toCharArray() }; //$NON-NLS-1$
+	char[] GET = "get".toCharArray(); //$NON-NLS-1$
+	char[] REMOVE = "remove".toCharArray(); //$NON-NLS-1$
+	char[] REMOVE_ALL = "removeAll".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_ALL = "containsAll".toCharArray(); //$NON-NLS-1$
+	char[] RETAIN_ALL = "retainAll".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_KEY = "containsKey".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_VALUE = "containsValue".toCharArray(); //$NON-NLS-1$
+	// for Collection.contains:
+	char[] CONTAINS = "contains".toCharArray(); //$NON-NLS-1$
+	// for List.*indexOf:
+	char[] INDEX_OF = "indexOf".toCharArray(); //$NON-NLS-1$
+	char[] LAST_INDEX_OF = "lastIndexOf".toCharArray(); //$NON-NLS-1$
+	enum DangerousMethod {
+		// Collection:
+		Contains, Remove, RemoveAll, ContainsAll, RetainAll,
+		// Map:
+		Get, ContainsKey, ContainsValue,
+		// List:
+		IndexOf, LastIndexOf;
+
+		public static DangerousMethod detectSelector(char[] selector) {
+			switch (selector[0]) {
+				case 'r':
+					if (CharOperation.prefixEquals(TypeConstants.REMOVE, selector)) {
+						if (CharOperation.equals(selector, TypeConstants.REMOVE))
+							return DangerousMethod.Remove;
+						else if (CharOperation.equals(selector, TypeConstants.REMOVE_ALL))
+							return DangerousMethod.RemoveAll;
+					} else if (CharOperation.equals(selector, TypeConstants.RETAIN_ALL)) {
+						return DangerousMethod.RetainAll;
+					}
+					break;
+				case 'c':
+					if (CharOperation.prefixEquals(TypeConstants.CONTAINS, selector)) {
+						if (CharOperation.equals(selector, TypeConstants.CONTAINS))
+							return DangerousMethod.Contains;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_ALL))
+							return DangerousMethod.ContainsAll;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_KEY))
+							return DangerousMethod.ContainsKey;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_VALUE))
+							return DangerousMethod.ContainsValue;
+					}
+					break;
+				case 'g':
+					if (CharOperation.equals(selector, TypeConstants.GET))
+						return DangerousMethod.Get;
+					break;
+				case 'i':
+					if (CharOperation.equals(selector, TypeConstants.INDEX_OF))
+						return DangerousMethod.IndexOf;
+					break;
+				case 'l':
+					if (CharOperation.equals(selector, TypeConstants.LAST_INDEX_OF))
+						return DangerousMethod.LastIndexOf;
+					break;
+			}
+			return null;
+		}
+	}
 
 	// Constraints for generic type argument inference
 	int CONSTRAINT_EQUAL = 0;		// Actual = Formal
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index cc71148..6605b96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *******************************************************************************/
@@ -129,6 +130,11 @@ public interface TypeIds {
 	final int T_ComGoogleInjectInject = 81;
 	// Java 8 - JEP 120
 	final int T_JavaLangAnnotationRepeatable = 90;
+	
+	// classes with methods with "dangerous" signatures:
+	final int T_JavaUtilMap = 91;
+	final int T_JavaUtilList = 92;
+
 	// If you add new type id, make sure to bump up T_LastWellKnownTypeId if there is a cross over.
 	final int T_LastWellKnownTypeId = 128;
 	
@@ -240,8 +246,18 @@ public interface TypeIds {
 	final int BitResourceFreeCloseable = 8;
 	
 	final int BitUninternedType = 16;
+	
+	/** Mark subtypes of Map to analyze dangerous get/remove et al. */
+	final int BitMap = 0x10;
+
+	/** Mark subtypes of Collection to analyze dangerous contains/remove. */
+	final int BitCollection = 0x20;
+
+	/** Mark subtypes of List to analyze dangerous indexOf. */
+	final int BitList = 0x40;
+
 	/**
 	 * Set of type bits that should be inherited by any sub types.
 	 */
-	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType;
+	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType | BitMap | BitCollection | BitList ;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 78e4705..308e873 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -57,6 +57,7 @@
  *								Bug 446442 - [1.8] merge null annotations from super methods
  *								Bug 455723 - Nonnull argument not correctly inferred in loop
  *								Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -590,6 +591,11 @@ public static int getIrritant(int problemID) {
 			
 		case IProblem.UnusedTypeParameter:
 			return CompilerOptions.UnusedTypeParameter;
+
+		case IProblem.DiscouragedInvocationIncompatibleArgument:
+			return CompilerOptions.UnlikelyArgumentType;
+		case IProblem.DiscouragedInvocationArgumentNotCastable:
+			return CompilerOptions.UnlikelyArgumentTypeNotCastable;
 }
 	return 0;
 }
@@ -647,6 +653,8 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.UnusedObjectAllocation :
 			case CompilerOptions.UnclosedCloseable :
 			case CompilerOptions.PotentiallyUnclosedCloseable :
+			case CompilerOptions.UnlikelyArgumentType :
+			case CompilerOptions.UnlikelyArgumentTypeNotCastable :
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10227,4 +10235,25 @@ public void invalidTypeArguments(TypeReference[] typeReference) {
 			typeReference[0].sourceStart,
 			typeReference[typeReference.length - 1].sourceEnd);
 }
+
+public void discouragedInvocationIncompatibleArgument(MethodBinding method, Expression argument,
+							TypeBinding expectedType, TypeBinding declaringType, boolean castable)
+{
+	this.handle(
+			castable ? IProblem.DiscouragedInvocationIncompatibleArgument : IProblem.DiscouragedInvocationArgumentNotCastable,
+			new String[] {
+				new String(method.readableName()),
+				new String(argument.resolvedType.readableName()),
+				new String(expectedType.readableName()),
+				new String(declaringType.readableName())
+			}, 
+			new String[] {
+				new String(method.shortReadableName()),
+				new String(argument.resolvedType.shortReadableName()),
+				new String(expectedType.shortReadableName()),
+				new String(declaringType.shortReadableName())
+			}, 
+			argument.sourceStart, 
+			argument.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 70ac81b..7d5bca8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2014 IBM Corporation and others.
+# Copyright (c) 2000, 2015 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -42,6 +42,7 @@
 #							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
 #							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
 #							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
+#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -851,6 +852,10 @@
 
 1100 = Problem detected during type inference: {0}
 
+# more programming problems:
+1200 = Discouraged invocation of method {0}. Argument type {1} is incompatible with the likely type {2} according to the declaring type {3}
+1201 = Discouraged invocation of method {0}. Argument type {1} cannot be cast to the likely type {2} according to the declaring type {3}
+
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 2c0c02c..54d12b6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -98,6 +98,8 @@
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
+ *									COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE
+ *									COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE
  *     Jesper S Moller   - Contributions for bug 381345 : [1.8] Take care of the Java 8 major version
  *                       - added the following constants:
  *									COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR
@@ -1496,6 +1498,42 @@ public final class JavaCore extends Plugin {
 	 * @category CompilerOptionID
 	 */
 	public static final String COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE = PLUGIN_ID + ".compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+
+	/**
+	 * Compiler option ID: Reporting a method invocation providing an argument of an unlikely type.
+	 * <p>When enabled, the compiler will issue an error or a warning against certain invocations
+	 *    of well-known methods with error-prone signatures, like {@link Map#get(Object)}.
+	 * 	  These methods of generic types have very general parameters, whereas in typical use 
+	 *    the argument should be of the type of one of the declaring type's type arguments,
+	 *    because values will be compared to values typed by that type argument.
+	 *    The error or warning is raised when the provided argument is compatible by the
+	 *    declared signature but not compatible with the corresponding type argument.
+	 *    In these cases the intended effect of the invocation is unlikely to be achieved.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.11
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
+
+	/**
+	 * Compiler option ID: Reporting a method invocation providing an argument of a very unlikely type.
+	 * <p>This option is stronger variant of {@link #COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE}.
+	 *    The error or waring is reported when the provided argument is not only incompatible with the expected type
+	 *    (in accordance with the declaring type's type argument) but even a cast to the expected type would not be possible.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.11
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE = PLUGIN_ID + ".compiler.problem.discouragedInvocationArgumentNotCastable"; //$NON-NLS-1$
+
 	/**
 	 * Compiler option ID: Annotation-based Null Analysis.
 	 * <p>This option controls whether the compiler will use null annotations for
commit 27e2724327c75ddbe7646447a4af212947b149ed
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Mar 14 15:27:41 2015 +0100

    Bug 410218 - Optional warning for arguments of "unexpected" types to
    Map#get(Object), Collection#remove(Object) et al.
    - change one option from [E/W/I] to [Enable/Disable]
    
    Change-Id: Ib7007954b541c29e41782ab755893df19c30fdb0
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>

1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
38	10	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
9	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
10	9	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index f38226f..a4c3c1d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1983,7 +1983,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecation\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod\" value=\"disabled\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.emptyStatement\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 0595ea0..ff92764 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1287,7 +1287,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForContainerAnnotationType", SKIP);
 		expectedProblemAttributes.put("DiscouragedInvocationIncompatibleArgument", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE));
-		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE));
+		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE));
 		expectedProblemAttributes.put("DuplicateAnnotation", SKIP);
 		expectedProblemAttributes.put("DuplicateAnnotationNotMarkedRepeatable", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index fd3b222..9a77356 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -2793,6 +2793,40 @@ public void testBug410218b() {
 		"Discouraged invocation of method remove(Object). Argument type Set<T> is incompatible with the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
 		"----------\n");
 }
+// HashSet vs. TreeSet or: to be castable or not - accept castable cases
+public void testBug410218b2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT, JavaCore.ENABLED);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts) {\n" +
+			"	if (hss.contains(ts)) // bad\n" +
+			"		hss.remove(ts); // bad\n" + 
+			"	if (hss.contains((Set<T>)ts)) // less bad\n" +
+			"		hss.remove((Set<T>)ts); // less bad\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (hss.contains(ts)) // bad\n" + 
+		"	                 ^^\n" + 
+		"Discouraged invocation of method contains(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	hss.remove(ts); // bad\n" + 
+		"	           ^^\n" + 
+		"Discouraged invocation of method remove(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
 // Map: contains* & remove & get
 public void testBug410218c() {
 	if (this.complianceLevel < ClassFileConstants.JDK1_5)
@@ -2870,7 +2904,7 @@ public void testBug410218d() {
 	if (this.complianceLevel < ClassFileConstants.JDK1_5)
 		return;
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.ERROR);
 	runNegativeTest(
 		new String[] {
 			"X.java",
@@ -2912,8 +2946,7 @@ public void testBug410218e() {
 	if (this.complianceLevel < ClassFileConstants.JDK1_5)
 		return;
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.ERROR);
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE, JavaCore.WARNING);
+	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.WARNING);
 	runNegativeTest(
 		new String[] {
 			"X.java",
@@ -2925,8 +2958,8 @@ public void testBug410218e() {
 			"  @SuppressWarnings(\"unlikely-arg-type\")\n" +
 			"  int test2(List<Integer> ints, boolean f, Object o) {\n" +
 			"	if (f)\n" +
-			"		return ints.indexOf(\"ONE\"); // bad but suppressed\n" +
-			"	return ints.indexOf(o); // not suppressable error\n" + 
+			"		return ints.indexOf(\"ONE\"); // really bad but suppressed\n" +
+			"	return ints.indexOf(o); // bad but suppressed\n" + 
 			"  }\n" +
 			"}\n"
 		},
@@ -2935,11 +2968,6 @@ public void testBug410218e() {
 		"	return ints.indexOf(\"ONE\"); // bad\n" + 
 		"	                    ^^^^^\n" + 
 		"Discouraged invocation of method indexOf(Object). Argument type String cannot be cast to the likely type Integer according to the declaring type List<Integer>\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 10)\n" + 
-		"	return ints.indexOf(o); // not suppressable error\n" + 
-		"	                    ^\n" + 
-		"Discouraged invocation of method indexOf(Object). Argument type Object is incompatible with the likely type Integer according to the declaring type List<Integer>\n" + 
 		"----------\n",
 		null/*classLibraries*/,
 		true/*shouldFlushOutputDirectory*/,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index be604fd..7d76aa0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -186,7 +186,7 @@ public class CompilerOptions {
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 
 	public static final String OPTION_ReportDiscouragedInvocationIncompatibleArgument = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
-	public static final String OPTION_ReportDiscouragedInvocationArgumenNotCastable = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable"; //$NON-NLS-1$
+	public static final String OPTION_ReportDiscouragedInvocationAcceptCastableArgument = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument"; //$NON-NLS-1$
 
 	/**
 	 * Possible values for configurable options
@@ -306,7 +306,6 @@ public class CompilerOptions {
 	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
 	public static final int UnlikelyArgumentType = IrritantSet.GROUP2 | ASTNode.Bit20;
-	public static final int UnlikelyArgumentTypeNotCastable = IrritantSet.GROUP2 | ASTNode.Bit21;
 
 	// Severity level for handlers
 	/** 
@@ -455,6 +454,9 @@ public class CompilerOptions {
 	/** Should missing enum cases be reported even if a default case exists in the same switch? */
 	public boolean reportMissingEnumCaseDespiteDefault;
 	
+	/** In a discouraged invocation to Map.get() et al, should args castable to the likely type be accepted? */
+	public boolean acceptCastableArgInDiscouragedInvocation;
+
 	/** Should the compiler tolerate illegal ambiguous varargs invocation in compliance < 1.7 
 	 * to be bug compatible with javac? (bug 383780) */
 	public static boolean tolerateIllegalAmbiguousVarargsInvocation;
@@ -693,8 +695,6 @@ public class CompilerOptions {
 				return OPTION_ReportNonnullParameterAnnotationDropped;
 			case UnlikelyArgumentType:
 				return OPTION_ReportDiscouragedInvocationIncompatibleArgument;
-			case UnlikelyArgumentTypeNotCastable:
-				return OPTION_ReportDiscouragedInvocationArgumenNotCastable;
 		}
 		return null;
 	}
@@ -890,7 +890,6 @@ public class CompilerOptions {
 			OPTION_InheritNullAnnotations,
 			OPTION_ReportNonnullParameterAnnotationDropped,
 			OPTION_ReportDiscouragedInvocationIncompatibleArgument,
-			OPTION_ReportDiscouragedInvocationArgumenNotCastable
 		};
 		return result;
 	}
@@ -981,7 +980,6 @@ public class CompilerOptions {
 			case MissingSynchronizedModifierInInheritedMethod:
 				return "sync-override";	 //$NON-NLS-1$
 			case UnlikelyArgumentType:
-			case UnlikelyArgumentTypeNotCastable:
 				return "unlikely-arg-type"; //$NON-NLS-1$
 		}
 		return null;
@@ -1206,7 +1204,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportDiscouragedInvocationIncompatibleArgument, getSeverityString(UnlikelyArgumentType));
-		optionsMap.put(OPTION_ReportDiscouragedInvocationArgumenNotCastable, getSeverityString(UnlikelyArgumentTypeNotCastable));
+		optionsMap.put(OPTION_ReportDiscouragedInvocationAcceptCastableArgument, this.acceptCastableArgInDiscouragedInvocation ? ENABLED : DISABLED);
 		return optionsMap;
 	}
 
@@ -1691,7 +1689,9 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportExplicitlyClosedAutoCloseable)) != null) updateSeverity(ExplicitlyClosedAutoCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedTypeParameter)) != null) updateSeverity(UnusedTypeParameter, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationIncompatibleArgument)) != null) updateSeverity(UnlikelyArgumentType, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationArgumenNotCastable)) != null) updateSeverity(UnlikelyArgumentTypeNotCastable, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationAcceptCastableArgument)) != null) {
+			this.acceptCastableArgInDiscouragedInvocation = ENABLED.equals(optionValue);
+		}
 		if (getSeverity(UnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(PotentiallyUnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(ExplicitlyClosedAutoCloseable) == ProblemSeverities.Ignore) {
@@ -1982,7 +1982,7 @@ public class CompilerOptions {
 		buf.append("\n\t- resource should be handled by try-with-resources: ").append(getSeverityString(ExplicitlyClosedAutoCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
 		buf.append("\n\t- discouraged invocation, unlikely argument: ").append(getSeverityString(UnlikelyArgumentType)); //$NON-NLS-1$
-		buf.append("\n\t- discouraged invocation, unlikely argument, not castable: ").append(getSeverityString(UnlikelyArgumentTypeNotCastable)); //$NON-NLS-1$
+		buf.append("\n\t- discouraged invocation, accept castable argument: ").append(this.acceptCastableArgInDiscouragedInvocation ? ENABLED : DISABLED); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index c4bd9d3..78c0e38 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -68,7 +68,7 @@ public class IrritantSet {
 	public static final IrritantSet UNCHECKED = new IrritantSet(CompilerOptions.UncheckedTypeOperation);
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 	public static final IrritantSet RESOURCE = new IrritantSet(CompilerOptions.UnclosedCloseable);
-	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyArgumentType|CompilerOptions.UnlikelyArgumentTypeNotCastable);
+	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyArgumentType);
 
 	public static final IrritantSet JAVADOC = new IrritantSet(CompilerOptions.InvalidJavadoc);
 	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
@@ -117,8 +117,7 @@ public class IrritantSet {
 				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation
 				|CompilerOptions.NonnullParameterAnnotationDropped
-				|CompilerOptions.UnlikelyArgumentType
-				|CompilerOptions.UnlikelyArgumentTypeNotCastable);
+				|CompilerOptions.UnlikelyArgumentType);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 308e873..4efd6f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -593,9 +593,8 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.UnusedTypeParameter;
 
 		case IProblem.DiscouragedInvocationIncompatibleArgument:
-			return CompilerOptions.UnlikelyArgumentType;
 		case IProblem.DiscouragedInvocationArgumentNotCastable:
-			return CompilerOptions.UnlikelyArgumentTypeNotCastable;
+			return CompilerOptions.UnlikelyArgumentType;
 }
 	return 0;
 }
@@ -654,7 +653,6 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.UnclosedCloseable :
 			case CompilerOptions.PotentiallyUnclosedCloseable :
 			case CompilerOptions.UnlikelyArgumentType :
-			case CompilerOptions.UnlikelyArgumentTypeNotCastable :
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10239,6 +10237,8 @@ public void invalidTypeArguments(TypeReference[] typeReference) {
 public void discouragedInvocationIncompatibleArgument(MethodBinding method, Expression argument,
 							TypeBinding expectedType, TypeBinding declaringType, boolean castable)
 {
+	if (castable && this.options.acceptCastableArgInDiscouragedInvocation)
+		return;
 	this.handle(
 			castable ? IProblem.DiscouragedInvocationIncompatibleArgument : IProblem.DiscouragedInvocationArgumentNotCastable,
 			new String[] {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 54d12b6..6dcb669 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1503,12 +1503,14 @@ public final class JavaCore extends Plugin {
 	 * Compiler option ID: Reporting a method invocation providing an argument of an unlikely type.
 	 * <p>When enabled, the compiler will issue an error or a warning against certain invocations
 	 *    of well-known methods with error-prone signatures, like {@link Map#get(Object)}.
-	 * 	  These methods of generic types have very general parameters, whereas in typical use 
+	 *    These methods of generic types have very general parameters, whereas in typical use
 	 *    the argument should be of the type of one of the declaring type's type arguments,
 	 *    because values will be compared to values typed by that type argument.
 	 *    The error or warning is raised when the provided argument is compatible by the
 	 *    declared signature but not compatible with the corresponding type argument.
 	 *    In these cases the intended effect of the invocation is unlikely to be achieved.</p>
+	 * <p>This option is further tuned by the option
+	 *    {@link #COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT}.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
@@ -1520,19 +1522,18 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
 
 	/**
-	 * Compiler option ID: Reporting a method invocation providing an argument of a very unlikely type.
-	 * <p>This option is stronger variant of {@link #COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE}.
-	 *    The error or waring is reported when the provided argument is not only incompatible with the expected type
-	 *    (in accordance with the declaring type's type argument) but even a cast to the expected type would not be possible.</p>
+	 * Compiler option ID: Exempt castable types from reporting a method invocation providing an argument of a unlikely type.
+	 * <p>When enabled, suppresses errors or warnings raised on behalf of {@link #COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE}
+	 *    where the actual argument type could be made compatible to the likely type using a cast.</p>
 	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationArgumentNotCastable"</code></dd>
-	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
-	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "enable", "disable" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disable"</code></dd>
 	 * </dl>
 	 * @since 3.11
 	 * @category CompilerOptionID
 	 */
-	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE = PLUGIN_ID + ".compiler.problem.discouragedInvocationArgumentNotCastable"; //$NON-NLS-1$
+	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT = PLUGIN_ID + ".compiler.problem.discouragedInvocationAcceptCastableArgument"; //$NON-NLS-1$
 
 	/**
 	 * Compiler option ID: Annotation-based Null Analysis.
commit e6d8789df9b4566a0124edc04d16cdf543582e67
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Mar 16 21:49:08 2015 +0100

    Revert "Bug 410218 - Optional warning for arguments of "unexpected"
    types to Map#get(Object), Collection#remove(Object) et al.
    
    This reverts commit 27e2724327c75ddbe7646447a4af212947b149ed and commit
    689526016f6ab442680e718d2760fc44e79dd9b5 and part of commit
    d516022cc45faaf269239c9a3eb11f62f3444f69

2	28	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
0	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
1	271	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
0	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
0	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
0	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
0	100	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
4	31	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
2	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
1	68	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
2	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
0	29	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
1	40	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index ae38a2c..75714f4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1869,7 +1869,6 @@ public void test012b(){
         "      unavoidableGenericProblems + ignore unavoidable type safety problems\n" + 
         "                                   due to raw APIs\n" + 
         "      unchecked          + unchecked type operation\n" + 
-        "      unlikelyArgumentType invoking Map.get() et al with an unlikely argument\n" + 
         "      unnecessaryElse      unnecessary else clause\n" + 
         "      unqualifiedField     unqualified reference to field\n" + 
         "      unused               macro for unusedAllocation, unusedArgument,\n" + 
@@ -1986,8 +1985,6 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecation\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod\" value=\"disabled\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument\" value=\"disabled\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.discouragedReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.emptyStatement\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.enumIdentifier\" value=\"warning\"/>\n" + 
@@ -2966,7 +2963,7 @@ public void test032(){
 				"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		p1.putAll(m1);\n" +
 				"	}\n" +
-				"	@SuppressWarnings(\"unlikely-arg-type\")\n" +
+				"\n" +
 				"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		m1.keySet().retainAll(p1.keySet());\n" +
 				"		m2.keySet().retainAll(p1.keySet());\n" +
@@ -3147,7 +3144,7 @@ public void test032(){
 			"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		p1.putAll(m1);\n" +
 			"	}\n" +
-			"	@SuppressWarnings(\"unlikely-arg-type\")\n" +
+			"\n" +
 			"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		m1.keySet().retainAll(p1.keySet());\n" +
 			"		m2.keySet().retainAll(p1.keySet());\n" +
@@ -13421,29 +13418,6 @@ public void test329_nowarn_options() {
 			true);
 }
 
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408815
-// -warn option - regression tests to check option unlikelyArgumentType
-public void test330_warn_options() {
-	this.runConformTest(
-		new String[] {
-				"p/X.java",
-				"package p;\n" +
-				"import java.util.Map;\n" +
-				"public class X {\n" +
-				"  Integer foo(Map<String,Integer> map) {\n" +
-				"	 return map.get(3);\n" +
-				"  }\n" +
-				"}\n",
-		},
-		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
-		+ " -sourcepath \"" + OUTPUT_DIR + "\""
-		+ " -1.5"
-		+ " -warn:-unlikelyArgumentType -proc:none -d \"" + OUTPUT_DIR + "\"",
-		"",
-		"",
-		true);
-}
-
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=375409
 public void testBug375409a() {
 	this.runConformTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index ff92764..6dc56dd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -458,8 +458,6 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("DisallowedTargetForContainerAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DisallowedExplicitThisParameter", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
-		expectedProblemAttributes.put("DiscouragedInvocationIncompatibleArgument", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
-		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(CategorizedProblem.CAT_RESTRICTION));
 		expectedProblemAttributes.put("DuplicateAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateAnnotationNotMarkedRepeatable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -1286,8 +1284,6 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForContainerAnnotationType", SKIP);
-		expectedProblemAttributes.put("DiscouragedInvocationIncompatibleArgument", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE));
-		expectedProblemAttributes.put("DiscouragedInvocationArgumentNotCastable", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE));
 		expectedProblemAttributes.put("DuplicateAnnotation", SKIP);
 		expectedProblemAttributes.put("DuplicateAnnotationNotMarkedRepeatable", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index 9a77356..b97333c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2001, 2015 IBM Corporation and others.
+ * Copyright (c) 2001, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,7 +10,6 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *     						bug 185682 - Increment/decrement operators mark local variables as read
  *     						bug 328281 - visibility leaks not detected when analyzing unused field in private class
- *							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -2704,273 +2703,4 @@ public void test0063() throws Exception {
 		true/*shouldFlushOutputDirectory*/,
 		customOptions);
 }
-// Collection: contains & remove & get
-public void testBug410218a() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"class X {\n" +
-			"  void test() {\n" +
-			"	Set<Short> set = new HashSet<Short>();\n" + 
-			"	short one = 1;\n" + 
-			"	set.add(one);\n" + 
-			"\n" + 
-			"	if (set.contains(\"ONE\")) // bad\n" +
-			"		set.remove(\"ONE\"); // bad\n" + 
-			"	if (set.contains(1)) // bad\n" +
-			"		set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
-			"	System.out.println(set); // shows that the \"Short 1\" is still in!\n" + 
-			"\n" + 
-			"	if (set.contains(one)) // ok\n" +
-			"		set.remove(one); // ok\n" + 
-			"	if (set.contains(Short.valueOf(one))) // ok\n" +
-			"		set.remove(Short.valueOf(one)); // ok\n" + 
-			"	System.out.println(set);\n" +
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 8)\n" + 
-		"	if (set.contains(\"ONE\")) // bad\n" + 
-		"	                 ^^^^^\n" + 
-		"Discouraged invocation of method contains(Object). Argument type String cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
-		"----------\n" + 
-		"2. WARNING in X.java (at line 9)\n" + 
-		"	set.remove(\"ONE\"); // bad\n" + 
-		"	           ^^^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
-		"----------\n" + 
-		"3. WARNING in X.java (at line 10)\n" + 
-		"	if (set.contains(1)) // bad\n" + 
-		"	                 ^\n" + 
-		"Discouraged invocation of method contains(Object). Argument type int cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
-		"----------\n" + 
-		"4. WARNING in X.java (at line 11)\n" + 
-		"	set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
-		"	           ^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type int cannot be cast to the likely type Short according to the declaring type Collection<Short>\n" + 
-		"----------\n");
-}
-// HashSet vs. TreeSet or: to be castable or not
-public void testBug410218b() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"class X {\n" +
-			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts) {\n" +
-			"	if (hss.contains(ts)) // bad\n" +
-			"		hss.remove(ts); // bad\n" + 
-			"	if (hss.contains((Set<T>)ts)) // less bad\n" +
-			"		hss.remove((Set<T>)ts); // less bad\n" + 
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 4)\n" + 
-		"	if (hss.contains(ts)) // bad\n" + 
-		"	                 ^^\n" + 
-		"Discouraged invocation of method contains(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n" + 
-		"2. WARNING in X.java (at line 5)\n" + 
-		"	hss.remove(ts); // bad\n" + 
-		"	           ^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n" + 
-		"3. WARNING in X.java (at line 6)\n" + 
-		"	if (hss.contains((Set<T>)ts)) // less bad\n" + 
-		"	                 ^^^^^^^^^^\n" + 
-		"Discouraged invocation of method contains(Object). Argument type Set<T> is incompatible with the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n" + 
-		"4. WARNING in X.java (at line 7)\n" + 
-		"	hss.remove((Set<T>)ts); // less bad\n" + 
-		"	           ^^^^^^^^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type Set<T> is incompatible with the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n");
-}
-// HashSet vs. TreeSet or: to be castable or not - accept castable cases
-public void testBug410218b2() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT, JavaCore.ENABLED);
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"class X {\n" +
-			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts) {\n" +
-			"	if (hss.contains(ts)) // bad\n" +
-			"		hss.remove(ts); // bad\n" + 
-			"	if (hss.contains((Set<T>)ts)) // less bad\n" +
-			"		hss.remove((Set<T>)ts); // less bad\n" + 
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 4)\n" + 
-		"	if (hss.contains(ts)) // bad\n" + 
-		"	                 ^^\n" + 
-		"Discouraged invocation of method contains(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n" + 
-		"2. WARNING in X.java (at line 5)\n" + 
-		"	hss.remove(ts); // bad\n" + 
-		"	           ^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type TreeSet<T> cannot be cast to the likely type HashSet<T> according to the declaring type Collection<HashSet<T>>\n" + 
-		"----------\n",
-		null/*classLibraries*/,
-		true/*shouldFlushOutputDirectory*/,
-		customOptions);
-}
-// Map: contains* & remove & get
-public void testBug410218c() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"class X {\n" +
-			"  Number test(Map<? extends Number, Number> m, boolean f) {\n" +
-			"	if (m.containsKey(\"ONE\")) // bad\n" + 
-			"		m.remove(\"ONE\"); // bad\n" +
-			"	if (m.containsValue(\"ONE\")) // bad\n" + 
-			"		m.remove(\"ONE\"); // bad\n" + 
-			"	short one = 1;\n" +
-			"	if (m.containsKey(one)) // almost ok\n" +
-			"		m.remove(one); // almost ok\n" +
-			"	if (m.containsValue(Short.valueOf(one))) // ok\n" + 
-			"		m.remove(Short.valueOf(one)); // almost ok\n" + 
-			"	if (f)\n" +
-			"		return m.get(\"ONE\"); // bad\n" +
-			"	return m.get(one);\n // almost ok\n" +
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 4)\n" + 
-		"	if (m.containsKey(\"ONE\")) // bad\n" + 
-		"	                  ^^^^^\n" + 
-		"Discouraged invocation of method containsKey(Object). Argument type String cannot be cast to the likely type capture#1-of ? extends Number according to the declaring type Map<capture#1-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"2. WARNING in X.java (at line 5)\n" + 
-		"	m.remove(\"ONE\"); // bad\n" + 
-		"	         ^^^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type capture#2-of ? extends Number according to the declaring type Map<capture#2-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"3. WARNING in X.java (at line 6)\n" + 
-		"	if (m.containsValue(\"ONE\")) // bad\n" + 
-		"	                    ^^^^^\n" + 
-		"Discouraged invocation of method containsValue(Object). Argument type String cannot be cast to the likely type Number according to the declaring type Map<capture#3-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"4. WARNING in X.java (at line 7)\n" + 
-		"	m.remove(\"ONE\"); // bad\n" + 
-		"	         ^^^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type String cannot be cast to the likely type capture#4-of ? extends Number according to the declaring type Map<capture#4-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"5. WARNING in X.java (at line 9)\n" + 
-		"	if (m.containsKey(one)) // almost ok\n" + 
-		"	                  ^^^\n" + 
-		"Discouraged invocation of method containsKey(Object). Argument type short is incompatible with the likely type capture#5-of ? extends Number according to the declaring type Map<capture#5-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"6. WARNING in X.java (at line 10)\n" + 
-		"	m.remove(one); // almost ok\n" + 
-		"	         ^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type short is incompatible with the likely type capture#6-of ? extends Number according to the declaring type Map<capture#6-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"7. WARNING in X.java (at line 12)\n" + 
-		"	m.remove(Short.valueOf(one)); // almost ok\n" + 
-		"	         ^^^^^^^^^^^^^^^^^^\n" + 
-		"Discouraged invocation of method remove(Object). Argument type Short is incompatible with the likely type capture#8-of ? extends Number according to the declaring type Map<capture#8-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"8. WARNING in X.java (at line 14)\n" + 
-		"	return m.get(\"ONE\"); // bad\n" + 
-		"	             ^^^^^\n" + 
-		"Discouraged invocation of method get(Object). Argument type String cannot be cast to the likely type capture#9-of ? extends Number according to the declaring type Map<capture#9-of ? extends Number,Number>\n" + 
-		"----------\n" + 
-		"9. WARNING in X.java (at line 15)\n" + 
-		"	return m.get(one);\n" + 
-		"	             ^^^\n" + 
-		"Discouraged invocation of method get(Object). Argument type short is incompatible with the likely type capture#10-of ? extends Number according to the declaring type Map<capture#10-of ? extends Number,Number>\n" + 
-		"----------\n");
-}
-// Collection: {contains,remove,retain}All, non-generic sub type of Collection, configured to be ERROR
-public void testBug410218d() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.ERROR);
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"interface NumberCollection extends Collection<Number> {}\n" +
-			"class X {\n" +
-			"  void test(NumberCollection numbers, List<Integer> ints, Set<Number> numberSet) {\n" +
-			"	if (numbers.containsAll(ints)) // bad\n" +
-			"		numbers.removeAll(ints); // bad\n" + 
-			"	else\n" +
-			"		numbers.retainAll(ints); // bad\n" + 
-			"\n" + 
-			"	numbers.removeAll(numberSet); // ok\n" + 
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 5)\n" + 
-		"	if (numbers.containsAll(ints)) // bad\n" + 
-		"	                        ^^^^\n" + 
-		"Discouraged invocation of method containsAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 6)\n" + 
-		"	numbers.removeAll(ints); // bad\n" + 
-		"	                  ^^^^\n" + 
-		"Discouraged invocation of method removeAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 8)\n" + 
-		"	numbers.retainAll(ints); // bad\n" + 
-		"	                  ^^^^\n" + 
-		"Discouraged invocation of method retainAll(Collection<?>). Argument type List<Integer> cannot be cast to the likely type Collection<Number> according to the declaring type Collection<Number>\n" + 
-		"----------\n",
-		null/*classLibraries*/,
-		true/*shouldFlushOutputDirectory*/,
-		customOptions);
-}
-// List.indexOf: w/ and w/o @SuppressWarnings
-public void testBug410218e() {
-	if (this.complianceLevel < ClassFileConstants.JDK1_5)
-		return;
-	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE, JavaCore.WARNING);
-	runNegativeTest(
-		new String[] {
-			"X.java",
-			"import java.util.*;\n" +
-			"class X {\n" +
-			"  int test1(List<Integer> ints, Object o) {\n" +
-			"	return ints.indexOf(\"ONE\"); // bad\n" + 
-			"  }\n" +
-			"  @SuppressWarnings(\"unlikely-arg-type\")\n" +
-			"  int test2(List<Integer> ints, boolean f, Object o) {\n" +
-			"	if (f)\n" +
-			"		return ints.indexOf(\"ONE\"); // really bad but suppressed\n" +
-			"	return ints.indexOf(o); // bad but suppressed\n" + 
-			"  }\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 4)\n" + 
-		"	return ints.indexOf(\"ONE\"); // bad\n" + 
-		"	                    ^^^^^\n" + 
-		"Discouraged invocation of method indexOf(Object). Argument type String cannot be cast to the likely type Integer according to the declaring type List<Integer>\n" + 
-		"----------\n",
-		null/*classLibraries*/,
-		true/*shouldFlushOutputDirectory*/,
-		customOptions);
-}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 2dc326d..498799d 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3888,9 +3888,6 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("unchecked") || token.equals("unsafe")) {//$NON-NLS-1$ //$NON-NLS-2$
 				setSeverity(CompilerOptions.OPTION_ReportUncheckedTypeOperation, severity, isEnabling);
 				return;
-			} else if (token.equals("unlikelyArgumentType")) { //$NON-NLS-1$
-				setSeverity(CompilerOptions.OPTION_ReportDiscouragedInvocationIncompatibleArgument, severity, isEnabling);
-				return;
 			} else if (token.equals("unnecessaryElse")) {//$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportUnnecessaryElse, severity, isEnabling);
 				return;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index ced9ca1..71cc92b 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -392,7 +392,6 @@ misc.usage.warn = {1} {2}\n\
 \      unavoidableGenericProblems + ignore unavoidable type safety problems\n\
 \                                   due to raw APIs\n\
 \      unchecked          + unchecked type operation\n\
-\      unlikelyArgumentType invoking Map.get() et al with an unlikely argument\n\
 \      unnecessaryElse      unnecessary else clause\n\
 \      unqualifiedField     unqualified reference to field\n\
 \      unused               macro for unusedAllocation, unusedArgument,\n\
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index afb7ecd..d30135f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -196,8 +196,6 @@
  *									IllegalParameterNullityRedefinition
  *									ContradictoryNullAnnotationsInferredFunctionType
  *									IllegalReturnNullityRedefinitionFreeTypeVariable
- *									DiscouragedInvocationIncompatibleArgument
- *									DiscouragedInvocationArgumentNotCastable
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1847,9 +1845,4 @@ void setSourceStart(int sourceStart);
 	/** @deprecated - problem is no longer generated (implementation issue has been resolved)
 	 * @since 3.10 */
 	int LambdaShapeComputationError = 1101;
-	
-	/** @since 3.11 */
-	int DiscouragedInvocationIncompatibleArgument = 1200;
-	/** @since 3.11 */
-	int DiscouragedInvocationArgumentNotCastable = 1201;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index ccc9923..6c2ade9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -50,7 +50,6 @@
  *								Bug 441734 - [1.8][inference] Generic method with nested parameterized type argument fails on method reference
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
  *								Bug 456487 - [1.8][null] @Nullable type variant of @NonNull-constrained type parameter causes grief
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -73,7 +72,6 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
-import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
@@ -86,7 +84,6 @@ import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolymorphicMethodBinding;
@@ -162,23 +159,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			}
 		}
 	}
-	if (compilerOptions.isAnyEnabled(IrritantSet.UNLIKELY_ARGUMENT_TYPE) && this.binding.isValidBinding()) {
-		TypeBinding[] signatureReplacement = detectAndReplaceDangerousSignature(currentScope);
-		if (signatureReplacement != null) {
-			int len = this.argumentTypes.length;
-			for (int i = 0; i < len; i++) {
-				TypeBinding expectedArgumentType = signatureReplacement[i];
-				TypeBinding argumentType = this.argumentTypes[i];
-				if (argumentType.isBaseType())
-					argumentType = currentScope.boxing(argumentType);
-				if (!argumentType.isCompatibleWith(expectedArgumentType, currentScope)) {
-					boolean castable = checkCastTypesCompatibility(currentScope, expectedArgumentType, argumentType, this.arguments[i]);
-					currentScope.problemReporter().discouragedInvocationIncompatibleArgument(this.binding, this.arguments[i],
-								expectedArgumentType, signatureReplacement[len], castable);
-				}
-			}
-		}
-	}
 
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
@@ -314,86 +294,6 @@ private int detectAssertionUtility(int argumentIdx) {
 	}
 	return 0;
 }
-// when targeting a well-known dangerous method, returns the "expected" signature plus the declaring type (as the last array element)
-TypeBinding[] detectAndReplaceDangerousSignature(Scope scope) {
-
-	// detecting only methods with a single argument, typed either as Object or as Collection:
-	TypeBinding[] parameters = this.binding.parameters;
-	if (parameters.length != 1)
-		return null;
-	int paramTypeId = parameters[0].original().id;
-	if (paramTypeId != TypeIds.T_JavaLangObject && paramTypeId != TypeIds.T_JavaUtilCollection)
-		return null;
-
-	// check selectors before typeBits as to avoid unnecessary super-traversals for the receiver type
-	DangerousMethod suspect = DangerousMethod.detectSelector(this.selector);
-	if (suspect == null) 
-		return null;
-
-	if (this.actualReceiverType.hasTypeBit(TypeIds.BitMap)) {
-		if (paramTypeId == TypeIds.T_JavaLangObject) {
-			switch (suspect) {
-				case ContainsKey:
-				case Get:
-				case Remove:
-					// map operations taking a key
-					ReferenceBinding mapType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
-					if (mapType != null && mapType.isParameterizedType())
-						return new TypeBinding[] { ((ParameterizedTypeBinding)mapType).typeArguments()[0], mapType };
-					break;
-				case ContainsValue:
-					// map operation taking a value
-					mapType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
-					if (mapType != null && mapType.isParameterizedType())
-						return new TypeBinding[] { ((ParameterizedTypeBinding)mapType).typeArguments()[1], mapType };
-					break;
-				default: // no other suspects are detected in java.util.Map
-			}
-		}
-	}
-	if (this.actualReceiverType.hasTypeBit(TypeIds.BitCollection)) {
-		if (paramTypeId == TypeIds.T_JavaLangObject) {
-			switch (suspect) {
-				case Remove:
-				case Contains:
-					// collection operations taking a single element
-					ReferenceBinding collectionType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
-					if (collectionType != null && collectionType.isParameterizedType())
-						return new TypeBinding[] { ((ParameterizedTypeBinding)collectionType).typeArguments()[0], collectionType };
-					break;
-				default: // no other suspects with Object-parameter are detected in java.util.Collection
-			}
-		} else if (paramTypeId == TypeIds.T_JavaUtilCollection) {
-			switch (suspect) {
-				case RemoveAll:
-				case ContainsAll:
-				case RetainAll:
-					// collection operations taking another collection
-					ReferenceBinding collectionType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
-					if (collectionType != null)
-						return new TypeBinding[] { collectionType, collectionType };
-					break;
-				default: // no other suspects with Collection-parameter are detected in java.util.Collection
-			}
-		}
-		if (this.actualReceiverType.hasTypeBit(TypeIds.BitList)) {
-			if (paramTypeId == TypeIds.T_JavaLangObject) {
-				switch (suspect) {
-					case IndexOf:
-					case LastIndexOf:
-						// list operations taking a single element
-						ReferenceBinding listType = this.actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilList, false);
-						if (listType != null && listType.isParameterizedType())
-							return new TypeBinding[] { ((ParameterizedTypeBinding)listType).typeArguments()[0], listType };
-						break;
-					default: // no other suspects are detected in java.util.List
-				}
-			}
-		}
-	} 
-	return null; // not replacing
-}
-
 private FlowInfo analyseBooleanAssertion(BlockScope currentScope, Expression argument,
 		FlowContext flowContext, FlowInfo flowInfo, boolean wasInsideAssert, boolean passOnTrue)
 {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 7d76aa0..a1c2a24 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -20,7 +20,6 @@
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
@@ -162,11 +161,9 @@ public class CompilerOptions {
 	public static final String OPTION_ReportMethodCanBeStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportMethodCanBePotentiallyStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportRedundantSpecificationOfTypeArguments =  "org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments"; //$NON-NLS-1$
-
 	public static final String OPTION_ReportUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.unclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportPotentiallyUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportExplicitlyClosedAutoCloseable = "org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
-
 	public static final String OPTION_ReportNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.nullSpecViolation";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullAnnotationInferenceConflict = "org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullUncheckedConversion = "org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion";  //$NON-NLS-1$
@@ -184,10 +181,6 @@ public class CompilerOptions {
 	public static final String OPTION_SyntacticNullAnalysisForFields = "org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
-
-	public static final String OPTION_ReportDiscouragedInvocationIncompatibleArgument = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
-	public static final String OPTION_ReportDiscouragedInvocationAcceptCastableArgument = "org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument"; //$NON-NLS-1$
-
 	/**
 	 * Possible values for configurable options
 	 */
@@ -305,7 +298,6 @@ public class CompilerOptions {
 	public static final int UnusedTypeParameter = IrritantSet.GROUP2 | ASTNode.Bit17;
 	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
-	public static final int UnlikelyArgumentType = IrritantSet.GROUP2 | ASTNode.Bit20;
 
 	// Severity level for handlers
 	/** 
@@ -320,12 +312,12 @@ public class CompilerOptions {
 	protected IrritantSet warningThreshold;
 	
 	/**
-	 * Default settings are to be defined in {@link CompilerOptions#resetDefaults()}
+	 * Default settings are to be defined in {@lnk CompilerOptions#resetDefaults()}
 	 */
 	
 	/** Classfile debug information, may contain source file name, line numbers, local variable tables, etc... */
 	public int produceDebugAttributes; 
-	/** Classfile method parameters information as per JEP 118... */
+	/** Classfile method patameters information as per JEP 118... */
 	public boolean produceMethodParameters;
 	/** Indicates whether generic signature should be generated for lambda expressions */
 	public boolean generateGenericSignatureForLambdaExpressions;
@@ -454,9 +446,6 @@ public class CompilerOptions {
 	/** Should missing enum cases be reported even if a default case exists in the same switch? */
 	public boolean reportMissingEnumCaseDespiteDefault;
 	
-	/** In a discouraged invocation to Map.get() et al, should args castable to the likely type be accepted? */
-	public boolean acceptCastableArgInDiscouragedInvocation;
-
 	/** Should the compiler tolerate illegal ambiguous varargs invocation in compliance < 1.7 
 	 * to be bug compatible with javac? (bug 383780) */
 	public static boolean tolerateIllegalAmbiguousVarargsInvocation;
@@ -501,7 +490,6 @@ public class CompilerOptions {
 		"synthetic-access", //$NON-NLS-1$
 		"sync-override",	//$NON-NLS-1$
 		"unchecked", //$NON-NLS-1$
-		"unlikely-arg-type",  //$NON-NLS-1$
 		"unqualified-field-access", //$NON-NLS-1$
 		"unused", //$NON-NLS-1$
 	};
@@ -693,8 +681,6 @@ public class CompilerOptions {
 				return OPTION_ReportRedundantNullAnnotation;
 			case NonnullParameterAnnotationDropped:
 				return OPTION_ReportNonnullParameterAnnotationDropped;
-			case UnlikelyArgumentType:
-				return OPTION_ReportDiscouragedInvocationIncompatibleArgument;
 		}
 		return null;
 	}
@@ -888,8 +874,7 @@ public class CompilerOptions {
 			OPTION_SyntacticNullAnalysisForFields,
 			OPTION_ReportUnusedTypeParameter,
 			OPTION_InheritNullAnnotations,
-			OPTION_ReportNonnullParameterAnnotationDropped,
-			OPTION_ReportDiscouragedInvocationIncompatibleArgument,
+			OPTION_ReportNonnullParameterAnnotationDropped
 		};
 		return result;
 	}
@@ -979,8 +964,6 @@ public class CompilerOptions {
 				return "javadoc"; //$NON-NLS-1$
 			case MissingSynchronizedModifierInInheritedMethod:
 				return "sync-override";	 //$NON-NLS-1$
-			case UnlikelyArgumentType:
-				return "unlikely-arg-type"; //$NON-NLS-1$
 		}
 		return null;
 	}
@@ -1061,8 +1044,6 @@ public class CompilerOptions {
 					return IrritantSet.UNCHECKED;
 				if ("unqualified-field-access".equals(warningToken)) //$NON-NLS-1$
 					return IrritantSet.UNQUALIFIED_FIELD_ACCESS;
-				if ("unlikely-arg-type".equals(warningToken)) //$NON-NLS-1$
-					return IrritantSet.UNLIKELY_ARGUMENT_TYPE;
 				break;
 		}
 		return null;
@@ -1203,8 +1184,6 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
-		optionsMap.put(OPTION_ReportDiscouragedInvocationIncompatibleArgument, getSeverityString(UnlikelyArgumentType));
-		optionsMap.put(OPTION_ReportDiscouragedInvocationAcceptCastableArgument, this.acceptCastableArgInDiscouragedInvocation ? ENABLED : DISABLED);
 		return optionsMap;
 	}
 
@@ -1688,10 +1667,6 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportPotentiallyUnclosedCloseable)) != null) updateSeverity(PotentiallyUnclosedCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportExplicitlyClosedAutoCloseable)) != null) updateSeverity(ExplicitlyClosedAutoCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedTypeParameter)) != null) updateSeverity(UnusedTypeParameter, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationIncompatibleArgument)) != null) updateSeverity(UnlikelyArgumentType, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportDiscouragedInvocationAcceptCastableArgument)) != null) {
-			this.acceptCastableArgInDiscouragedInvocation = ENABLED.equals(optionValue);
-		}
 		if (getSeverity(UnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(PotentiallyUnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(ExplicitlyClosedAutoCloseable) == ProblemSeverities.Ignore) {
@@ -1981,8 +1956,6 @@ public class CompilerOptions {
 		buf.append("\n\t- resource may not be closed: ").append(getSeverityString(PotentiallyUnclosedCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- resource should be handled by try-with-resources: ").append(getSeverityString(ExplicitlyClosedAutoCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
-		buf.append("\n\t- discouraged invocation, unlikely argument: ").append(getSeverityString(UnlikelyArgumentType)); //$NON-NLS-1$
-		buf.append("\n\t- discouraged invocation, accept castable argument: ").append(this.acceptCastableArgInDiscouragedInvocation ? ENABLED : DISABLED); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 78c0e38..b4d0330 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,7 +15,6 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								Bug 441208 - [1.8][null]SuppressWarnings("null") does not suppress / marked Unnecessary
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -68,7 +67,6 @@ public class IrritantSet {
 	public static final IrritantSet UNCHECKED = new IrritantSet(CompilerOptions.UncheckedTypeOperation);
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 	public static final IrritantSet RESOURCE = new IrritantSet(CompilerOptions.UnclosedCloseable);
-	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyArgumentType);
 
 	public static final IrritantSet JAVADOC = new IrritantSet(CompilerOptions.InvalidJavadoc);
 	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
@@ -116,8 +114,7 @@ public class IrritantSet {
 				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation
-				|CompilerOptions.NonnullParameterAnnotationDropped
-				|CompilerOptions.UnlikelyArgumentType);
+				|CompilerOptions.NonnullParameterAnnotationDropped);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 3afdb1d..949bd2e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -87,7 +87,6 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		if (enclosingType != null && enclosingType.hasNullTypeAnnotations())
 			this.tagBits |= TagBits.HasNullTypeAnnotation;
 		this.tagBits |=  TagBits.HasUnresolvedTypeVariables; // cleared in resolve()
-		this.typeBits = type.typeBits;
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index a2e7723..61cb9f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,7 +34,6 @@
  *								Bug 440759 - [1.8][null] @NonNullByDefault should never affect wildcards and uses of a type variable
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
  *								Bug 446442 - [1.8] merge null annotations from super methods
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -498,27 +497,13 @@ public void computeId() {
 						if (CharOperation.equals(packageName, TypeConstants.UTIL)) {
 							switch (typeName[0]) {
 								case 'C' :
-									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2])) {
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2]))
 										this.id = TypeIds.T_JavaUtilCollection;
-										this.typeBits |= TypeIds.BitCollection;
-									}										
 									return;
 								case 'I' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_ITERATOR[2]))
 										this.id = TypeIds.T_JavaUtilIterator;
 									return;
-								case 'L' :
-									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_LIST[2])) {
-										this.id = TypeIds.T_JavaUtilList;
-										this.typeBits |= TypeIds.BitList;
-									}										
-									return;
-								case 'M' :
-									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_MAP[2])) {
-										this.id = TypeIds.T_JavaUtilMap;
-										this.typeBits |= TypeIds.BitMap;
-									}
-									return;
 								case 'O' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_OBJECTS[2]))
 										this.id = TypeIds.T_JavaUtilObjects;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index d048a2b..4cc9bda 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,6 @@
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 425183 - [1.8][inference] make CaptureBinding18 safe
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *    Jesper S Moller - Contributions for
  *								Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -26,8 +25,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
-import org.eclipse.jdt.core.compiler.CharOperation;
-
 // TODO should rename into TypeNames (once extracted last non name constants)
 public interface TypeConstants {
 
@@ -159,7 +156,6 @@ public interface TypeConstants {
 	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_OBJECTS = {JAVA, UTIL, "Objects".toCharArray()}; //$NON-NLS-1$
-	char[][] JAVA_UTIL_LIST = {JAVA, UTIL, "List".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
@@ -333,69 +329,6 @@ public interface TypeConstants {
 	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {COM, GOOGLE, INJECT_PACKAGE, INJECT_TYPE };
 	//    detail for the above:
 	char[] OPTIONAL = "optional".toCharArray(); //$NON-NLS-1$
-	
-	// well-known methods with "dangerous" signatures:
-	char[][] JAVA_UTIL_MAP = new char[][] { JAVA, UTIL, "Map".toCharArray() }; //$NON-NLS-1$
-	char[] GET = "get".toCharArray(); //$NON-NLS-1$
-	char[] REMOVE = "remove".toCharArray(); //$NON-NLS-1$
-	char[] REMOVE_ALL = "removeAll".toCharArray(); //$NON-NLS-1$
-	char[] CONTAINS_ALL = "containsAll".toCharArray(); //$NON-NLS-1$
-	char[] RETAIN_ALL = "retainAll".toCharArray(); //$NON-NLS-1$
-	char[] CONTAINS_KEY = "containsKey".toCharArray(); //$NON-NLS-1$
-	char[] CONTAINS_VALUE = "containsValue".toCharArray(); //$NON-NLS-1$
-	// for Collection.contains:
-	char[] CONTAINS = "contains".toCharArray(); //$NON-NLS-1$
-	// for List.*indexOf:
-	char[] INDEX_OF = "indexOf".toCharArray(); //$NON-NLS-1$
-	char[] LAST_INDEX_OF = "lastIndexOf".toCharArray(); //$NON-NLS-1$
-	enum DangerousMethod {
-		// Collection:
-		Contains, Remove, RemoveAll, ContainsAll, RetainAll,
-		// Map:
-		Get, ContainsKey, ContainsValue,
-		// List:
-		IndexOf, LastIndexOf;
-
-		public static DangerousMethod detectSelector(char[] selector) {
-			switch (selector[0]) {
-				case 'r':
-					if (CharOperation.prefixEquals(TypeConstants.REMOVE, selector)) {
-						if (CharOperation.equals(selector, TypeConstants.REMOVE))
-							return DangerousMethod.Remove;
-						else if (CharOperation.equals(selector, TypeConstants.REMOVE_ALL))
-							return DangerousMethod.RemoveAll;
-					} else if (CharOperation.equals(selector, TypeConstants.RETAIN_ALL)) {
-						return DangerousMethod.RetainAll;
-					}
-					break;
-				case 'c':
-					if (CharOperation.prefixEquals(TypeConstants.CONTAINS, selector)) {
-						if (CharOperation.equals(selector, TypeConstants.CONTAINS))
-							return DangerousMethod.Contains;
-						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_ALL))
-							return DangerousMethod.ContainsAll;
-						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_KEY))
-							return DangerousMethod.ContainsKey;
-						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_VALUE))
-							return DangerousMethod.ContainsValue;
-					}
-					break;
-				case 'g':
-					if (CharOperation.equals(selector, TypeConstants.GET))
-						return DangerousMethod.Get;
-					break;
-				case 'i':
-					if (CharOperation.equals(selector, TypeConstants.INDEX_OF))
-						return DangerousMethod.IndexOf;
-					break;
-				case 'l':
-					if (CharOperation.equals(selector, TypeConstants.LAST_INDEX_OF))
-						return DangerousMethod.LastIndexOf;
-					break;
-			}
-			return null;
-		}
-	}
 
 	// Constraints for generic type argument inference
 	int CONSTRAINT_EQUAL = 0;		// Actual = Formal
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 6605b96..cc71148 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,7 +14,6 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *******************************************************************************/
@@ -130,11 +129,6 @@ public interface TypeIds {
 	final int T_ComGoogleInjectInject = 81;
 	// Java 8 - JEP 120
 	final int T_JavaLangAnnotationRepeatable = 90;
-	
-	// classes with methods with "dangerous" signatures:
-	final int T_JavaUtilMap = 91;
-	final int T_JavaUtilList = 92;
-
 	// If you add new type id, make sure to bump up T_LastWellKnownTypeId if there is a cross over.
 	final int T_LastWellKnownTypeId = 128;
 	
@@ -246,18 +240,8 @@ public interface TypeIds {
 	final int BitResourceFreeCloseable = 8;
 	
 	final int BitUninternedType = 16;
-	
-	/** Mark subtypes of Map to analyze dangerous get/remove et al. */
-	final int BitMap = 0x10;
-
-	/** Mark subtypes of Collection to analyze dangerous contains/remove. */
-	final int BitCollection = 0x20;
-
-	/** Mark subtypes of List to analyze dangerous indexOf. */
-	final int BitList = 0x40;
-
 	/**
 	 * Set of type bits that should be inherited by any sub types.
 	 */
-	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType | BitMap | BitCollection | BitList ;
+	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 4efd6f9..78e4705 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -57,7 +57,6 @@
  *								Bug 446442 - [1.8] merge null annotations from super methods
  *								Bug 455723 - Nonnull argument not correctly inferred in loop
  *								Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
- *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -591,10 +590,6 @@ public static int getIrritant(int problemID) {
 			
 		case IProblem.UnusedTypeParameter:
 			return CompilerOptions.UnusedTypeParameter;
-
-		case IProblem.DiscouragedInvocationIncompatibleArgument:
-		case IProblem.DiscouragedInvocationArgumentNotCastable:
-			return CompilerOptions.UnlikelyArgumentType;
 }
 	return 0;
 }
@@ -652,7 +647,6 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.UnusedObjectAllocation :
 			case CompilerOptions.UnclosedCloseable :
 			case CompilerOptions.PotentiallyUnclosedCloseable :
-			case CompilerOptions.UnlikelyArgumentType :
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10233,27 +10227,4 @@ public void invalidTypeArguments(TypeReference[] typeReference) {
 			typeReference[0].sourceStart,
 			typeReference[typeReference.length - 1].sourceEnd);
 }
-
-public void discouragedInvocationIncompatibleArgument(MethodBinding method, Expression argument,
-							TypeBinding expectedType, TypeBinding declaringType, boolean castable)
-{
-	if (castable && this.options.acceptCastableArgInDiscouragedInvocation)
-		return;
-	this.handle(
-			castable ? IProblem.DiscouragedInvocationIncompatibleArgument : IProblem.DiscouragedInvocationArgumentNotCastable,
-			new String[] {
-				new String(method.readableName()),
-				new String(argument.resolvedType.readableName()),
-				new String(expectedType.readableName()),
-				new String(declaringType.readableName())
-			}, 
-			new String[] {
-				new String(method.shortReadableName()),
-				new String(argument.resolvedType.shortReadableName()),
-				new String(expectedType.shortReadableName()),
-				new String(declaringType.shortReadableName())
-			}, 
-			argument.sourceStart, 
-			argument.sourceEnd);
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 7d5bca8..70ac81b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2015 IBM Corporation and others.
+# Copyright (c) 2000, 2014 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -42,7 +42,6 @@
 #							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
 #							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
 #							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
-#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -852,10 +851,6 @@
 
 1100 = Problem detected during type inference: {0}
 
-# more programming problems:
-1200 = Discouraged invocation of method {0}. Argument type {1} is incompatible with the likely type {2} according to the declaring type {3}
-1201 = Discouraged invocation of method {0}. Argument type {1} cannot be cast to the likely type {2} according to the declaring type {3}
-
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 6dcb669..2c0c02c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -98,8 +98,6 @@
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
- *									COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE
- *									COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_NOT_CASTABLE
  *     Jesper S Moller   - Contributions for bug 381345 : [1.8] Take care of the Java 8 major version
  *                       - added the following constants:
  *									COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR
@@ -1498,43 +1496,6 @@ public final class JavaCore extends Plugin {
 	 * @category CompilerOptionID
 	 */
 	public static final String COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE = PLUGIN_ID + ".compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
-
-	/**
-	 * Compiler option ID: Reporting a method invocation providing an argument of an unlikely type.
-	 * <p>When enabled, the compiler will issue an error or a warning against certain invocations
-	 *    of well-known methods with error-prone signatures, like {@link Map#get(Object)}.
-	 *    These methods of generic types have very general parameters, whereas in typical use
-	 *    the argument should be of the type of one of the declaring type's type arguments,
-	 *    because values will be compared to values typed by that type argument.
-	 *    The error or warning is raised when the provided argument is compatible by the
-	 *    declared signature but not compatible with the corresponding type argument.
-	 *    In these cases the intended effect of the invocation is unlikely to be achieved.</p>
-	 * <p>This option is further tuned by the option
-	 *    {@link #COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT}.</p>
-	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationIncompatibleArgument"</code></dd>
-	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
-	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
-	 * </dl>
-	 * @since 3.11
-	 * @category CompilerOptionID
-	 */
-	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.discouragedInvocationIncompatibleArgument"; //$NON-NLS-1$
-
-	/**
-	 * Compiler option ID: Exempt castable types from reporting a method invocation providing an argument of a unlikely type.
-	 * <p>When enabled, suppresses errors or warnings raised on behalf of {@link #COMPILER_PB_DISCOURAGED_INVOCATION_UNLIKELY_ARGUMENT_TYPE}
-	 *    where the actual argument type could be made compatible to the likely type using a cast.</p>
-	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.discouragedInvocationAcceptCastableArgument"</code></dd>
-	 * <dt>Possible values:</dt><dd><code>{ "enable", "disable" }</code></dd>
-	 * <dt>Default:</dt><dd><code>"disable"</code></dd>
-	 * </dl>
-	 * @since 3.11
-	 * @category CompilerOptionID
-	 */
-	public static final String COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT = PLUGIN_ID + ".compiler.problem.discouragedInvocationAcceptCastableArgument"; //$NON-NLS-1$
-
 	/**
 	 * Compiler option ID: Annotation-based Null Analysis.
 	 * <p>This option controls whether the compiler will use null annotations for
commit e7d6d8a91612da3f3cae0b22ddd55df43d4ee554
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Oct 17 23:38:07 2016 +0200

    Bug 410218 - Optional warning for arguments of "unexpected" types to
    Map#get(Object), Collection#remove(Object) et al.
    
    Also-By: Till Brychcy <register.eclipse@brychcy.de>
    
    Change-Id: I171086d745e1ba15f64cf66264ac35c1a07ef437

49	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
519	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
6	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
3	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
25	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
28	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
186	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnlikelyArgumentCheck.java
39	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
13	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
74	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
28	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
57	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index f5e7ec2..ea86675 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -872,6 +872,9 @@ public void test012b(){
         "      unavoidableGenericProblems + ignore unavoidable type safety problems\n" + 
         "                                   due to raw APIs\n" + 
         "      unchecked          + unchecked type operation\n" + 
+        "      unlikelyCollectionMethodArgumentType unlikely argument type for collection\n" + 
+        "                           methods using Object\n" + 
+        "      unlikelyEqualsArgumentType unlikely argument type for equals()\n" + 
         "      unnecessaryElse      unnecessary else clause\n" + 
         "      unqualifiedField     unqualified reference to field\n" + 
         "      unused               macro for unusedAllocation, unusedArgument,\n" + 
@@ -1066,6 +1069,9 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unhandledWarningToken\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison\" value=\"disabled\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentType\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict\" value=\"disabled\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType\" value=\"info\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryElse\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess\" value=\"ignore\"/>\n" + 
@@ -1971,7 +1977,6 @@ public void test032(){
 				"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		p1.putAll(m1);\n" +
 				"	}\n" +
-				"\n" +
 				"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 				"		m1.keySet().retainAll(p1.keySet());\n" +
 				"		m2.keySet().retainAll(p1.keySet());\n" +
@@ -2152,7 +2157,6 @@ public void test032(){
 			"	public void foo5(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		p1.putAll(m1);\n" +
 			"	}\n" +
-			"\n" +
 			"	public void foo6(final Map<XX<?, ?>, XY> p1) {\n" +
 			"		m1.keySet().retainAll(p1.keySet());\n" +
 			"		m2.keySet().retainAll(p1.keySet());\n" +
@@ -12120,6 +12124,49 @@ public void test329_nowarn_options() {
 			true);
 }
 
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408815
+// -warn option - regression tests to check option unlikelyCollectionMethodArgumentType
+public void test330_warn_options() {
+	this.runConformTest(
+		new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"import java.util.Map;\n" +
+				"public class X {\n" +
+				"  Integer foo(Map<String,Integer> map) {\n" +
+				"	 return map.get(3);\n" +
+				"  }\n" +
+				"}\n",
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -warn:-unlikelyCollectionMethodArgumentType -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"",
+		true);
+}//https://bugs.eclipse.org/bugs/show_bug.cgi?id=408815
+//-warn option - regression tests to check option unlikelyEqualsArgumentType
+public void test331_warn_options() {
+	this.runConformTest(
+		new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"public class X {\n" +
+				"  boolean foo() {\n" +
+				"	 return \"three\".equals(3);\n" +
+				"  }\n" +
+				"}\n",
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -info:-unlikelyEqualsArgumentType -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"",
+		true);
+}
+
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=375409
 public void testBug375409a() {
 	this.runConformTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 1d93cb4..fad307e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1046,6 +1046,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UninternedIdentityComparison", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("UnlikelyCollectionMethodArgumentType", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UnlikelyEqualsArgumentType", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1887,6 +1889,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninternedIdentityComparison", SKIP);
+		expectedProblemAttributes.put("UnlikelyCollectionMethodArgumentType", new ProblemAttributes(JavaCore.COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE));
+		expectedProblemAttributes.put("UnlikelyEqualsArgumentType", new ProblemAttributes(JavaCore.COMPILER_PB_UNLIKELY_EQUALS_ARGUMENT_TYPE));
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index b97333c..46de727 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2001, 2014 IBM Corporation and others.
+ * Copyright (c) 2001, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *     						bug 185682 - Increment/decrement operators mark local variables as read
  *     						bug 328281 - visibility leaks not detected when analyzing unused field in private class
+ *							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -2703,4 +2704,521 @@ public void test0063() throws Exception {
 		true/*shouldFlushOutputDirectory*/,
 		customOptions);
 }
+// Collection: contains & remove & get
+public void testBug410218a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  void test() {\n" +
+			"	Set<Short> set = new HashSet<Short>();\n" + 
+			"	short one = 1;\n" + 
+			"	set.add(one);\n" + 
+			"\n" + 
+			"	if (set.contains(\"ONE\")) // bad\n" +
+			"		set.remove(\"ONE\"); // bad\n" + 
+			"	if (set.contains(1)) // bad\n" +
+			"		set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
+			"	System.out.println(set); // shows that the \"Short 1\" is still in!\n" + 
+			"\n" + 
+			"	if (set.contains(one)) // ok\n" +
+			"		set.remove(one); // ok\n" + 
+			"	if (set.contains(Short.valueOf(one))) // ok\n" +
+			"		set.remove(Short.valueOf(one)); // ok\n" + 
+			"	System.out.println(set);\n" +
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 8)\n" + 
+		"	if (set.contains(\"ONE\")) // bad\n" + 
+		"	                 ^^^^^\n" + 
+		"Unlikely argument type String for contains(Object) on a Collection<Short>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	set.remove(\"ONE\"); // bad\n" + 
+		"	           ^^^^^\n" + 
+		"Unlikely argument type String for remove(Object) on a Collection<Short>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 10)\n" + 
+		"	if (set.contains(1)) // bad\n" + 
+		"	                 ^\n" + 
+		"Unlikely argument type int for contains(Object) on a Collection<Short>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 11)\n" + 
+		"	set.remove(1); // bad (tries to remove \"Integer 1\")\n" + 
+		"	           ^\n" + 
+		"Unlikely argument type int for remove(Object) on a Collection<Short>\n" + 
+		"----------\n");
+}
+// HashSet vs. TreeSet
+public void testBug410218b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts, LinkedHashSet<T> lhs) {\n" +
+			"	if (hss.contains(ts)) // bad\n" +
+			"		hss.remove(ts); // bad\n" + 
+			"	if (hss.contains((Set<T>)ts)) // ok\n" +
+			"		hss.remove((Set<T>)ts); // ok\n" + 
+			"	if (hss.contains(lhs)) // ok\n" +
+			"		hss.remove(lhs); // ok\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (hss.contains(ts)) // bad\n" + 
+		"	                 ^^\n" + 
+		"Unlikely argument type TreeSet<T> for contains(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	hss.remove(ts); // bad\n" + 
+		"	           ^^\n" + 
+		"Unlikely argument type TreeSet<T> for remove(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n");
+}
+// HashSet vs. TreeSet or: strict
+public void testBug410218b2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE_STRICT, JavaCore.ENABLED);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  <T> void test(Set<HashSet<T>> hss, TreeSet<T> ts, LinkedHashSet<T> lhs) {\n" +
+			"	if (hss.contains(ts)) // bad\n" +
+			"		hss.remove(ts); // bad\n" + 
+			"	if (hss.contains((Set<T>)ts)) // bad (because of strict check)\n" +
+			"		hss.remove((Set<T>)ts); // bad (because of strict check)\n" + 
+			"	if (hss.contains(lhs)) // ok\n" +
+			"		hss.remove(lhs); // ok\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (hss.contains(ts)) // bad\n" + 
+		"	                 ^^\n" + 
+		"Unlikely argument type TreeSet<T> for contains(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	hss.remove(ts); // bad\n" + 
+		"	           ^^\n" + 
+		"Unlikely argument type TreeSet<T> for remove(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 6)\n" + 
+		"	if (hss.contains((Set<T>)ts)) // bad (because of strict check)\n" + 
+		"	                 ^^^^^^^^^^\n" + 
+		"Unlikely argument type Set<T> for contains(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 7)\n" + 
+		"	hss.remove((Set<T>)ts); // bad (because of strict check)\n" + 
+		"	           ^^^^^^^^^^\n" + 
+		"Unlikely argument type Set<T> for remove(Object) on a Collection<HashSet<T>>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// Map: contains* & remove & get
+public void testBug410218c() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  Number test(Map<? extends Number, Number> m, boolean f) {\n" +
+			"	if (m.containsKey(\"ONE\")) // bad\n" + 
+			"		m.remove(\"ONE\"); // bad\n" +
+			"	if (m.containsValue(\"ONE\")) // bad\n" + 
+			"		m.remove(\"ONE\"); // bad\n" + 
+			"	short one = 1;\n" +
+			"	if (m.containsKey(one)) // almost ok\n" +
+			"		m.remove(one); // almost ok\n" +
+			"	if (m.containsValue(Short.valueOf(one))) // ok\n" + 
+			"		m.remove(Short.valueOf(one)); // almost ok\n" + 
+			"	if (f)\n" +
+			"		return m.get(\"ONE\"); // bad\n" +
+			"	return m.get(one);\n // almost ok\n" +
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	if (m.containsKey(\"ONE\")) // bad\n" + 
+		"	                  ^^^^^\n" + 
+		"Unlikely argument type String for containsKey(Object) on a Map<capture#1-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	m.remove(\"ONE\"); // bad\n" + 
+		"	         ^^^^^\n" + 
+		"Unlikely argument type String for remove(Object) on a Map<capture#2-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 6)\n" + 
+		"	if (m.containsValue(\"ONE\")) // bad\n" + 
+		"	                    ^^^^^\n" + 
+		"Unlikely argument type String for containsValue(Object) on a Map<capture#3-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"4. WARNING in X.java (at line 7)\n" + 
+		"	m.remove(\"ONE\"); // bad\n" + 
+		"	         ^^^^^\n" + 
+		"Unlikely argument type String for remove(Object) on a Map<capture#4-of ? extends Number,Number>\n" + 
+		"----------\n" + 
+		"5. WARNING in X.java (at line 14)\n" + 
+		"	return m.get(\"ONE\"); // bad\n" + 
+		"	             ^^^^^\n" + 
+		"Unlikely argument type String for get(Object) on a Map<capture#9-of ? extends Number,Number>\n" + 
+		"----------\n");
+}
+// Collection: {contains,remove,retain}All, non-generic sub type of Collection, configured to be ERROR
+public void testBug410218d() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE, JavaCore.ERROR);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"interface NumberCollection extends Collection<Number> {}\n" +
+			"class X {\n" +
+			"  void test(NumberCollection numbers, List<Integer> ints, Set<String> stringSet) {\n" +
+			"	if (numbers.containsAll(ints)) // ok\n" +
+			"		numbers.removeAll(ints); // ok\n" + 
+			"	else\n" +
+			"		numbers.retainAll(ints); // ok\n" + 
+			"\n" + 
+			"	numbers.removeAll(stringSet); // bad\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	numbers.removeAll(stringSet); // bad\n" + 
+		"	                  ^^^^^^^^^\n" + 
+		"Unlikely argument type Set<String> for removeAll(Collection<?>) on a Collection<Number>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// List.indexOf: w/ and w/o @SuppressWarnings
+public void testBug410218e() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE, JavaCore.WARNING);
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"class X {\n" +
+			"  int test1(List<Integer> ints, Object o) {\n" +
+			"	return ints.indexOf(\"ONE\"); // bad\n" + 
+			"  }\n" +
+			"  @SuppressWarnings(\"unlikely-arg-type\")\n" +
+			"  int test2(List<Integer> ints, boolean f, Object o) {\n" +
+			"	if (f)\n" +
+			"		return ints.indexOf(\"ONE\"); // bad but suppressed\n" +
+			"	return ints.indexOf(o); // supertype\n" + 
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	return ints.indexOf(\"ONE\"); // bad\n" + 
+		"	                    ^^^^^\n" + 
+		"Unlikely argument type String for indexOf(Object) on a List<Integer>\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+
+// Method references, equals, wildcards
+public void testBug410218f() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_8)
+		return;
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE, JavaCore.WARNING);
+	customOptions.put(JavaCore.COMPILER_PB_UNLIKELY_EQUALS_ARGUMENT_TYPE, JavaCore.INFO);
+	runNegativeTest(
+		new String[] {
+			"test/TestUnlikely.java",
+			"package test;\n" +
+			"\n" +
+			"import java.util.Collection;\n" +
+			"import java.util.Iterator;\n" +
+			"import java.util.List;\n" +
+			"import java.util.Map;\n" +
+			"import java.util.Objects;\n" +
+			"import java.util.Set;\n" +
+			"import java.util.function.BiPredicate;\n" +
+			"import java.util.function.Predicate;\n" +
+			"\n" +
+			"public class TestUnlikely {\n" +
+			"	interface Interface {\n" +
+			"	}\n" +
+			"\n" +
+			"	interface OtherInterface {\n" +
+			"	}\n" +
+			"\n" +
+			"	static class NonFinal implements Interface {\n" +
+			"	}\n" +
+			"\n" +
+			"	static class Sub extends NonFinal implements OtherInterface {\n" +
+			"	}\n" +
+			"\n" +
+			"	static final class Final implements Interface {\n" +
+			"	}\n" +
+			"\n" +
+			"	void f1(List<Interface> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		c.remove(i);\n" +
+			"		c.remove(o); // warning: unrelated interface\n" +
+			"		c.remove(f);\n" +
+			"		c.remove(nf);\n" +
+			"		c.remove(s);\n" +
+			"	}\n" +
+			"\n" +
+			"	void f2(List<OtherInterface> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		c.remove(i); // warning: unrelated interface\n" +
+			"		c.remove(o);\n" +
+			"		c.remove(f); // warning: impossible\n" +
+			"		c.remove(nf); // warning: castable, but not supertype\n" +
+			"		c.remove(s);\n" +
+			"	}\n" +
+			"\n" +
+			"	void f3(List<Final> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		c.remove(i); // supertype\n" +
+			"		c.remove(o); // warning: impossible\n" +
+			"		c.remove(f);\n" +
+			"		c.remove(nf); // warning: impossible\n" +
+			"		c.remove(s); // warning: impossible\n" +
+			"	}\n" +
+			"\n" +
+			"	void f4(List<NonFinal> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		c.remove(i); // supertype\n" +
+			"		c.remove(o); // warning: unrelated interface\n" +
+			"		c.remove(f); // warning: impossible\n" +
+			"		c.remove(nf);\n" +
+			"		c.remove(s);\n" +
+			"	}\n" +
+			"\n" +
+			"	void f5(List<Sub> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		c.remove(i); // supertype\n" +
+			"		c.remove(o); // supertype\n" +
+			"		c.remove(f); // warning: impossible\n" +
+			"		c.remove(nf); // supertype\n" +
+			"		c.remove(s);\n" +
+			"	}\n" +
+			"\n" +
+			"	<K, V> void map(Map<K, V> map, K key, V value) {\n" +
+			"		map.containsKey(key);\n" +
+			"		map.containsKey(value); // warning\n" +
+			"		map.containsValue(key); // warning\n" +
+			"		map.containsValue(value);\n" +
+			"	}\n" +
+			"\n" +
+			"	boolean wildcards(Collection<?> c, Iterable<?> s) {\n" +
+			"		for (Iterator<?> iterator = s.iterator(); iterator.hasNext();) {\n" +
+			"			if (c.contains(iterator.next())) {\n" +
+			"				return true;\n" +
+			"			}\n" +
+			"		}\n" +
+			"		return false;\n" +
+			"	}\n" +
+			"\n" +
+			"	<T, U extends T> boolean relatedTypeVariables(Collection<T> c, Iterable<U> s) {\n" +
+			"		for (Iterator<?> iterator = s.iterator(); iterator.hasNext();) {\n" +
+			"			if (c.contains(iterator.next())) {\n" +
+			"				return true;\n" +
+			"			}\n" +
+			"		}\n" +
+			"		return false;\n" +
+			"	}\n" +
+			"\n" +
+			"	<T, U> boolean unrelatedTypeVariables(Collection<T> c, Iterable<U> s) {\n" +
+			"		for (Iterator<U> iterator = s.iterator(); iterator.hasNext();) {\n" +
+			"			if (c.contains(iterator.next())) { // warning\n" +
+			"				return true;\n" +
+			"			}\n" +
+			"		}\n" +
+			"		return false;\n" +
+			"	}\n" +
+			"\n" +
+			"	void all(List<NonFinal> c, Collection<Sub> s, Set<Final> other) {\n" +
+			"		c.removeAll(s);\n" +
+			"		s.removeAll(c);\n" +
+			"		c.removeAll(other); // warning\n" +
+			"	}\n" +
+			"\n" +
+			"	void methodRef(Set<Interface> c, Interface i, OtherInterface o, Final f, NonFinal nf, Sub s) {\n" +
+			"		Predicate<Interface> p1 = c::contains;\n" +
+			"		BiPredicate<Collection<Interface>, Interface> bp1 = Collection<Interface>::contains;\n" +
+			"		Predicate<OtherInterface> p2 = c::contains; // warning\n" +
+			"		BiPredicate<Collection<Interface>, OtherInterface> bp2 = Collection<Interface>::contains; // warning\n" +
+			"		p1.test(i);\n" +
+			"		bp1.test(c, i);\n" +
+			"		p2.test(o);\n" +
+			"		bp2.test(c, o);\n" +
+			"	}\n" +
+			"\n" +
+			"	void equals(String s, Integer i, Number n) {\n" +
+			"		s.equals(i); // info\n" +
+			"		i.equals(s); // info\n" +
+			"		i.equals(n);\n" +
+			"		n.equals(i);\n" +
+			"\n" +
+			"		Predicate<String> p1 = i::equals; // info\n" +
+			"		p1.test(s);\n" +
+			"\n" +
+			"		BiPredicate<String, Integer> bp2 = Object::equals; // info\n" +
+			"		bp2.test(s, i);\n" +
+			"\n" +
+			"		Objects.equals(s, i); // info\n" +
+			"		Objects.equals(i, s); // info\n" +
+			"		Objects.equals(n, i);\n" +
+			"		Objects.equals(i, n);\n" +
+			"\n" +
+			"		BiPredicate<String, Integer> bp3 = Objects::equals; // info\n" +
+			"		bp3.test(s, i);\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"",
+		}, 
+		"----------\n" + 
+		"1. WARNING in test\\TestUnlikely.java (at line 30)\n" + 
+		"	c.remove(o); // warning: unrelated interface\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.OtherInterface for remove(Object) on a Collection<TestUnlikely.Interface>\n" + 
+		"----------\n" + 
+		"2. WARNING in test\\TestUnlikely.java (at line 37)\n" + 
+		"	c.remove(i); // warning: unrelated interface\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.Interface for remove(Object) on a Collection<TestUnlikely.OtherInterface>\n" + 
+		"----------\n" + 
+		"3. WARNING in test\\TestUnlikely.java (at line 39)\n" + 
+		"	c.remove(f); // warning: impossible\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.Final for remove(Object) on a Collection<TestUnlikely.OtherInterface>\n" + 
+		"----------\n" + 
+		"4. WARNING in test\\TestUnlikely.java (at line 40)\n" + 
+		"	c.remove(nf); // warning: castable, but not supertype\n" + 
+		"	         ^^\n" + 
+		"Unlikely argument type TestUnlikely.NonFinal for remove(Object) on a Collection<TestUnlikely.OtherInterface>\n" + 
+		"----------\n" + 
+		"5. WARNING in test\\TestUnlikely.java (at line 46)\n" + 
+		"	c.remove(o); // warning: impossible\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.OtherInterface for remove(Object) on a Collection<TestUnlikely.Final>\n" + 
+		"----------\n" + 
+		"6. WARNING in test\\TestUnlikely.java (at line 48)\n" + 
+		"	c.remove(nf); // warning: impossible\n" + 
+		"	         ^^\n" + 
+		"Unlikely argument type TestUnlikely.NonFinal for remove(Object) on a Collection<TestUnlikely.Final>\n" + 
+		"----------\n" + 
+		"7. WARNING in test\\TestUnlikely.java (at line 49)\n" + 
+		"	c.remove(s); // warning: impossible\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.Sub for remove(Object) on a Collection<TestUnlikely.Final>\n" + 
+		"----------\n" + 
+		"8. WARNING in test\\TestUnlikely.java (at line 54)\n" + 
+		"	c.remove(o); // warning: unrelated interface\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.OtherInterface for remove(Object) on a Collection<TestUnlikely.NonFinal>\n" + 
+		"----------\n" + 
+		"9. WARNING in test\\TestUnlikely.java (at line 55)\n" + 
+		"	c.remove(f); // warning: impossible\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.Final for remove(Object) on a Collection<TestUnlikely.NonFinal>\n" + 
+		"----------\n" + 
+		"10. WARNING in test\\TestUnlikely.java (at line 63)\n" + 
+		"	c.remove(f); // warning: impossible\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type TestUnlikely.Final for remove(Object) on a Collection<TestUnlikely.Sub>\n" + 
+		"----------\n" + 
+		"11. WARNING in test\\TestUnlikely.java (at line 70)\n" + 
+		"	map.containsKey(value); // warning\n" + 
+		"	                ^^^^^\n" + 
+		"Unlikely argument type V for containsKey(Object) on a Map<K,V>\n" + 
+		"----------\n" + 
+		"12. WARNING in test\\TestUnlikely.java (at line 71)\n" + 
+		"	map.containsValue(key); // warning\n" + 
+		"	                  ^^^\n" + 
+		"Unlikely argument type K for containsValue(Object) on a Map<K,V>\n" + 
+		"----------\n" + 
+		"13. WARNING in test\\TestUnlikely.java (at line 95)\n" + 
+		"	if (c.contains(iterator.next())) { // warning\n" + 
+		"	               ^^^^^^^^^^^^^^^\n" + 
+		"Unlikely argument type U for contains(Object) on a Collection<T>\n" + 
+		"----------\n" + 
+		"14. WARNING in test\\TestUnlikely.java (at line 105)\n" + 
+		"	c.removeAll(other); // warning\n" + 
+		"	            ^^^^^\n" + 
+		"Unlikely argument type Set<TestUnlikely.Final> for removeAll(Collection<?>) on a Collection<TestUnlikely.NonFinal>\n" + 
+		"----------\n" + 
+		"15. WARNING in test\\TestUnlikely.java (at line 111)\n" + 
+		"	Predicate<OtherInterface> p2 = c::contains; // warning\n" + 
+		"	                               ^^^^^^^^^^^\n" + 
+		"Unlikely argument type TestUnlikely.OtherInterface for contains(Object) on a Collection<TestUnlikely.Interface>\n" + 
+		"----------\n" + 
+		"16. WARNING in test\\TestUnlikely.java (at line 112)\n" + 
+		"	BiPredicate<Collection<Interface>, OtherInterface> bp2 = Collection<Interface>::contains; // warning\n" + 
+		"	                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unlikely argument type TestUnlikely.OtherInterface for contains(Object) on a Collection<TestUnlikely.Interface>\n" + 
+		"----------\n" + 
+		"17. INFO in test\\TestUnlikely.java (at line 120)\n" + 
+		"	s.equals(i); // info\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type for equals(): Integer seems to be unrelated to String\n" + 
+		"----------\n" + 
+		"18. INFO in test\\TestUnlikely.java (at line 121)\n" + 
+		"	i.equals(s); // info\n" + 
+		"	         ^\n" + 
+		"Unlikely argument type for equals(): String seems to be unrelated to Integer\n" + 
+		"----------\n" + 
+		"19. INFO in test\\TestUnlikely.java (at line 125)\n" + 
+		"	Predicate<String> p1 = i::equals; // info\n" + 
+		"	                       ^^^^^^^^^\n" + 
+		"Unlikely argument type for equals(): String seems to be unrelated to Integer\n" + 
+		"----------\n" + 
+		"20. INFO in test\\TestUnlikely.java (at line 128)\n" + 
+		"	BiPredicate<String, Integer> bp2 = Object::equals; // info\n" + 
+		"	                                   ^^^^^^^^^^^^^^\n" + 
+		"Unlikely argument type for equals(): Integer seems to be unrelated to String\n" + 
+		"----------\n" + 
+		"21. INFO in test\\TestUnlikely.java (at line 131)\n" + 
+		"	Objects.equals(s, i); // info\n" + 
+		"	                  ^\n" + 
+		"Unlikely argument type for equals(): Integer seems to be unrelated to String\n" + 
+		"----------\n" + 
+		"22. INFO in test\\TestUnlikely.java (at line 132)\n" + 
+		"	Objects.equals(i, s); // info\n" + 
+		"	                  ^\n" + 
+		"Unlikely argument type for equals(): String seems to be unrelated to Integer\n" + 
+		"----------\n" + 
+		"23. INFO in test\\TestUnlikely.java (at line 136)\n" + 
+		"	BiPredicate<String, Integer> bp3 = Objects::equals; // info\n" + 
+		"	                                   ^^^^^^^^^^^^^^^\n" + 
+		"Unlikely argument type for equals(): Integer seems to be unrelated to String\n" + 
+		"----------\n"
+		,
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index f95d7c8..0f4bb64 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -4012,6 +4012,12 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("unchecked") || token.equals("unsafe")) {//$NON-NLS-1$ //$NON-NLS-2$
 				setSeverity(CompilerOptions.OPTION_ReportUncheckedTypeOperation, severity, isEnabling);
 				return;
+			} else if (token.equals("unlikelyCollectionMethodArgumentType")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportUnlikelyCollectionMethodArgumentType, severity, isEnabling);
+				return;
+			} else if (token.equals("unlikelyEqualsArgumentType")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportUnlikelyEqualsArgumentType, severity, isEnabling);
+				return;
 			} else if (token.equals("unnecessaryElse")) {//$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportUnnecessaryElse, severity, isEnabling);
 				return;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index c56494d..5f2f54f 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -412,6 +412,9 @@ misc.usage.warn = {1} {2}\n\
 \      unavoidableGenericProblems + ignore unavoidable type safety problems\n\
 \                                   due to raw APIs\n\
 \      unchecked          + unchecked type operation\n\
+\      unlikelyCollectionMethodArgumentType unlikely argument type for collection\n\
+\                           methods using 'Object'\n\
+\      unlikelyEqualsArgumentType unlikely argument type for equals()\n\
 \      unnecessaryElse      unnecessary else clause\n\
 \      unqualifiedField     unqualified reference to field\n\
 \      unused               macro for unusedAllocation, unusedArgument,\n\
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index c0ac572..12f6fe0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -196,6 +196,8 @@
  *									IllegalParameterNullityRedefinition
  *									ContradictoryNullAnnotationsInferredFunctionType
  *									IllegalReturnNullityRedefinitionFreeTypeVariable
+ *									UnlikelyCollectionMethodArgumentType
+ *									UnlikelyEqualsArgumentType
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1889,4 +1891,9 @@ void setSourceStart(int sourceStart);
 	int LambdaShapeComputationError = 1101;
 	/** @since 3.13 */
 	int ProblemNotAnalysed = 1102;
+	
+	/** @since 3.13 */
+	int UnlikelyCollectionMethodArgumentType = 1200;
+	/** @since 3.13 */
+	int UnlikelyEqualsArgumentType = 1201;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 44c2ad0..a1be3fd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -53,6 +53,7 @@
  *								Bug 407414 - [compiler][null] Incorrect warning on a primitive type being null
  *								Bug 472618 - [compiler][null] assertNotNull vs. Assert.assertNotNull
  *								Bug 470958 - [1.8] Unable to convert lambda 
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -75,6 +76,7 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -164,6 +166,27 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			}
 		}
 	}
+	if (compilerOptions.isAnyEnabled(IrritantSet.UNLIKELY_ARGUMENT_TYPE) && this.binding.isValidBinding()
+			&& this.arguments != null) {
+		if (this.arguments.length == 1 && !this.binding.isStatic()) {
+			UnlikelyArgumentCheck argumentChecks = UnlikelyArgumentCheck.determineCheckForNonStaticSingleArgumentMethod(
+				this.argumentTypes[0], currentScope, this.selector, this.actualReceiverType, this.binding.parameters);
+
+			if (argumentChecks != null && argumentChecks.isDangerous(currentScope)) {
+				currentScope.problemReporter().unlikelyArgumentType(this.arguments[0], this.binding,
+						this.argumentTypes[0], argumentChecks.typeToReport, argumentChecks.dangerousMethod);
+			}
+ 		} else if (this.arguments.length == 2 && this.binding.isStatic()) {
+			UnlikelyArgumentCheck argumentChecks = UnlikelyArgumentCheck.determineCheckForStaticTwoArgumentMethod(
+				this.argumentTypes[1], currentScope, this.selector, this.argumentTypes[0],
+				this.binding.parameters, this.actualReceiverType);
+
+			if (argumentChecks != null && argumentChecks.isDangerous(currentScope)) {
+				currentScope.problemReporter().unlikelyArgumentType(this.arguments[1], this.binding,
+						this.argumentTypes[1], argumentChecks.typeToReport, argumentChecks.dangerousMethod);
+			}
+ 		}
+	}
 
 	if (nonStatic) {
 		int timeToLive = ((this.bits & ASTNode.InsideExpressionStatement) != 0) ? 3 : 2;
@@ -301,6 +324,7 @@ private int detectAssertionUtility(int argumentIdx) {
 	}
 	return 0;
 }
+
 private FlowInfo analyseBooleanAssertion(BlockScope currentScope, Expression argument,
 		FlowContext flowContext, FlowInfo flowInfo, boolean wasInsideAssert, boolean passOnTrue)
 {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index fcd74c4..b572490 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -61,6 +61,7 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -432,6 +433,33 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
 				}
 			}
 		}
+		if (currentScope.compilerOptions().isAnyEnabled(IrritantSet.UNLIKELY_ARGUMENT_TYPE) && this.binding.isValidBinding()
+				&& this.binding != null && this.binding.parameters != null) {
+			if (this.binding.parameters.length == 1
+					&& this.descriptor.parameters.length == (this.receiverPrecedesParameters ? 2 : 1)
+					&& !this.binding.isStatic()) {
+				final TypeBinding argumentType = this.descriptor.parameters[this.receiverPrecedesParameters ? 1 : 0];
+				final TypeBinding actualReceiverType = this.receiverPrecedesParameters ? this.descriptor.parameters[0] : this.binding.declaringClass;
+				UnlikelyArgumentCheck argumentCheck = UnlikelyArgumentCheck
+						.determineCheckForNonStaticSingleArgumentMethod(argumentType, currentScope, this.selector,
+								actualReceiverType, this.binding.parameters);
+				if (argumentCheck != null && argumentCheck.isDangerous(currentScope)) {
+					currentScope.problemReporter().unlikelyArgumentType(this, this.binding, argumentType,
+							argumentCheck.typeToReport, argumentCheck.dangerousMethod);
+				}
+			} else if (this.binding.parameters.length == 2 && this.descriptor.parameters.length == 2 && this.binding.isStatic()) {
+				final TypeBinding argumentType1 = this.descriptor.parameters[0];
+				final TypeBinding argumentType2 = this.descriptor.parameters[1];
+				UnlikelyArgumentCheck argumentCheck = UnlikelyArgumentCheck
+						.determineCheckForStaticTwoArgumentMethod(argumentType2, currentScope, this.selector,
+								argumentType1, this.binding.parameters, this.receiverType);
+				if (argumentCheck != null && argumentCheck.isDangerous(currentScope)) {
+					currentScope.problemReporter().unlikelyArgumentType(this, this.binding, argumentType2,
+							argumentCheck.typeToReport, argumentCheck.dangerousMethod);
+				}			
+			}
+		}
+		
 		manageSyntheticAccessIfNecessary(currentScope, flowInfo);
 		return flowInfo;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnlikelyArgumentCheck.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnlikelyArgumentCheck.java
new file mode 100644
index 0000000..de80f94
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnlikelyArgumentCheck.java
@@ -0,0 +1,186 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2017 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DangerousMethod;
+import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+
+/* @NonNullByDefault */
+public class UnlikelyArgumentCheck {
+	public final DangerousMethod dangerousMethod;
+	public final TypeBinding typeToCheck;
+	public final TypeBinding expectedType;
+	public final TypeBinding typeToReport;
+
+	private UnlikelyArgumentCheck(DangerousMethod dangerousMethod, TypeBinding typeToCheck, TypeBinding expectedType,
+			TypeBinding typeToReport) {
+		this.dangerousMethod = dangerousMethod;
+		this.typeToCheck = typeToCheck;
+		this.expectedType = expectedType;
+		this.typeToReport = typeToReport;
+	}
+
+	/**
+	 * Check if the invocation is likely a bug.
+	 * @param currentScope
+	 * @return false, if the typeToCheck does not seem to related to the expectedType
+	 */
+	public boolean isDangerous(BlockScope currentScope) {
+		TypeBinding typeToCheck2 = this.typeToCheck;
+		// take autoboxing into account
+		if (typeToCheck2.isBaseType()) {
+			typeToCheck2 = currentScope.boxing(typeToCheck2);
+		}
+		TypeBinding expectedType2 = this.expectedType;
+		if (expectedType2.isBaseType()) { // can happen for the first parameter of java.util.Object.equals
+			expectedType2 = currentScope.boxing(expectedType2);
+		}
+		if(this.dangerousMethod != DangerousMethod.Equals && currentScope.compilerOptions().reportUnlikelyCollectionMethodArgumentTypeStrict) {
+			return !typeToCheck2.isCompatibleWith(expectedType2, currentScope);
+		}
+		// unless both types are true type variables (not captures), take the erasure of both.
+		if (typeToCheck2.isCapture() || !typeToCheck2.isTypeVariable() || expectedType2.isCapture()
+				|| !expectedType2.isTypeVariable()) {
+			typeToCheck2 = typeToCheck2.erasure();
+			expectedType2 = expectedType2.erasure();
+		}
+		return !typeToCheck2.isCompatibleWith(expectedType2, currentScope)
+				&& !expectedType2.isCompatibleWith(typeToCheck2, currentScope);
+	}
+
+	/**
+	 * When targeting a well-known dangerous method, returns an UnlikelyArgumentCheck object that contains the types to
+	 * check against each other and to report
+	 */
+	public static /* @Nullable */ UnlikelyArgumentCheck determineCheckForNonStaticSingleArgumentMethod(
+			TypeBinding argumentType, Scope scope, char[] selector, TypeBinding actualReceiverType,
+			TypeBinding[] parameters) {
+		// detecting only methods with a single argument, typed either as Object or as Collection:
+		if (parameters.length != 1)
+			return null;
+		int paramTypeId = parameters[0].original().id;
+		if (paramTypeId != TypeIds.T_JavaLangObject && paramTypeId != TypeIds.T_JavaUtilCollection)
+			return null;
+
+		// check selectors before typeBits as to avoid unnecessary super-traversals for the receiver type
+		DangerousMethod suspect = DangerousMethod.detectSelector(selector);
+		if (suspect == null)
+			return null;
+
+		if (actualReceiverType.hasTypeBit(TypeIds.BitMap)) {
+			if (paramTypeId == TypeIds.T_JavaLangObject) {
+				switch (suspect) {
+					case ContainsKey:
+					case Get:
+					case Remove:
+						// map operations taking a key
+						ReferenceBinding mapType = actualReceiverType
+								.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
+						if (mapType != null && mapType.isParameterizedType())
+							return new UnlikelyArgumentCheck(suspect, argumentType,
+									((ParameterizedTypeBinding) mapType).typeArguments()[0], mapType);
+						break;
+					case ContainsValue:
+						// map operation taking a value
+						mapType = actualReceiverType.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilMap, false);
+						if (mapType != null && mapType.isParameterizedType())
+							return new UnlikelyArgumentCheck(suspect, argumentType,
+									((ParameterizedTypeBinding) mapType).typeArguments()[1], mapType);
+						break;
+					default: // no other suspects are detected in java.util.Map
+				}
+			}
+		}
+		if (actualReceiverType.hasTypeBit(TypeIds.BitCollection)) {
+			if (paramTypeId == TypeIds.T_JavaLangObject) {
+				switch (suspect) {
+					case Remove:
+					case Contains:
+						// collection operations taking a single element
+						ReferenceBinding collectionType = actualReceiverType
+								.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
+						if (collectionType != null && collectionType.isParameterizedType())
+							return new UnlikelyArgumentCheck(suspect, argumentType,
+									((ParameterizedTypeBinding) collectionType).typeArguments()[0], collectionType);
+						break;
+					default: // no other suspects with Object-parameter are detected in java.util.Collection
+				}
+			} else if (paramTypeId == TypeIds.T_JavaUtilCollection) {
+				switch (suspect) {
+					case RemoveAll:
+					case ContainsAll:
+					case RetainAll:
+						// collection operations taking another collection
+						ReferenceBinding collectionType = actualReceiverType
+								.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
+						ReferenceBinding argumentCollectionType = argumentType
+								.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false);
+						if (collectionType != null && argumentCollectionType != null
+								&& argumentCollectionType.isParameterizedTypeWithActualArguments()) {
+							return new UnlikelyArgumentCheck(suspect,
+									((ParameterizedTypeBinding) argumentCollectionType).typeArguments()[0],
+									((ParameterizedTypeBinding) collectionType).typeArguments()[0], collectionType);
+						}
+						break;
+					default: // no other suspects with Collection-parameter are detected in java.util.Collection
+				}
+			}
+			if (actualReceiverType.hasTypeBit(TypeIds.BitList)) {
+				if (paramTypeId == TypeIds.T_JavaLangObject) {
+					switch (suspect) {
+						case IndexOf:
+						case LastIndexOf:
+							// list operations taking a single element
+							ReferenceBinding listType = actualReceiverType
+									.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilList, false);
+							if (listType != null && listType.isParameterizedType())
+								return new UnlikelyArgumentCheck(suspect, argumentType,
+										((ParameterizedTypeBinding) listType).typeArguments()[0], listType);
+							break;
+						default: // no other suspects are detected in java.util.List
+					}
+				}
+			}
+		}
+		if (paramTypeId == TypeIds.T_JavaLangObject && suspect == DangerousMethod.Equals) {
+			return new UnlikelyArgumentCheck(suspect, argumentType, actualReceiverType, actualReceiverType);
+		}
+		return null; // not replacing
+	}
+	public static /* @Nullable */ UnlikelyArgumentCheck determineCheckForStaticTwoArgumentMethod(
+			TypeBinding secondParameter, Scope scope, char[] selector, TypeBinding firstParameter,
+			TypeBinding[] parameters, TypeBinding actualReceiverType) {
+		// detecting only methods with two arguments, both typed as Object:
+		if (parameters.length != 2)
+			return null;
+		int paramTypeId1 = parameters[0].original().id;
+		int paramTypeId2 = parameters[1].original().id;
+
+		if (paramTypeId1 != TypeIds.T_JavaLangObject || paramTypeId2 != TypeIds.T_JavaLangObject)
+			return null;
+
+		// check selectors before typeBits as to avoid unnecessary super-traversals for the receiver type
+		DangerousMethod suspect = DangerousMethod.detectSelector(selector);
+		if (suspect == null)
+			return null;
+
+		if (actualReceiverType.id == TypeIds.T_JavaUtilObjects && suspect == DangerousMethod.Equals) {
+			return new UnlikelyArgumentCheck(suspect, secondParameter, firstParameter, firstParameter);
+		}
+		return null;
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 22c2272..a0cc71d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -20,6 +20,7 @@
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
@@ -161,9 +162,11 @@ public class CompilerOptions {
 	public static final String OPTION_ReportMethodCanBeStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportMethodCanBePotentiallyStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportRedundantSpecificationOfTypeArguments =  "org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments"; //$NON-NLS-1$
+
 	public static final String OPTION_ReportUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.unclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportPotentiallyUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportExplicitlyClosedAutoCloseable = "org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+
 	public static final String OPTION_ReportNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.nullSpecViolation";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullAnnotationInferenceConflict = "org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict";  //$NON-NLS-1$
 	public static final String OPTION_ReportNullUncheckedConversion = "org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion";  //$NON-NLS-1$
@@ -187,6 +190,10 @@ public class CompilerOptions {
 	public static final String OPTION_PessimisticNullAnalysisForFreeTypeVariables = "org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonNullTypeVariableFromLegacyInvocation = "org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation"; //$NON-NLS-1$
 	
+	public static final String OPTION_ReportUnlikelyCollectionMethodArgumentType = "org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentType"; //$NON-NLS-1$
+	public static final String OPTION_ReportUnlikelyCollectionMethodArgumentTypeStrict = "org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict"; //$NON-NLS-1$
+	public static final String OPTION_ReportUnlikelyEqualsArgumentType = "org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType"; //$NON-NLS-1$
+
 	/**
 	 * Possible values for configurable options
 	 */
@@ -309,6 +316,8 @@ public class CompilerOptions {
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
 	public static final int PessimisticNullAnalysisForFreeTypeVariables = IrritantSet.GROUP2 | ASTNode.Bit20;
 	public static final int NonNullTypeVariableFromLegacyInvocation = IrritantSet.GROUP2 | ASTNode.Bit21;
+	public static final int UnlikelyCollectionMethodArgumentType = IrritantSet.GROUP2 | ASTNode.Bit22;
+	public static final int UnlikelyEqualsArgumentType = IrritantSet.GROUP2 | ASTNode.Bit23;
 
 	// Severity level for handlers
 	/** 
@@ -328,12 +337,12 @@ public class CompilerOptions {
 	protected IrritantSet infoThreshold;
 	
 	/**
-	 * Default settings are to be defined in {@lnk CompilerOptions#resetDefaults()}
+	 * Default settings are to be defined in {@link CompilerOptions#resetDefaults()}
 	 */
 	
 	/** Classfile debug information, may contain source file name, line numbers, local variable tables, etc... */
 	public int produceDebugAttributes; 
-	/** Classfile method patameters information as per JEP 118... */
+	/** Classfile method parameters information as per JEP 118... */
 	public boolean produceMethodParameters;
 	/** Indicates whether generic signature should be generated for lambda expressions */
 	public boolean generateGenericSignatureForLambdaExpressions;
@@ -468,6 +477,9 @@ public class CompilerOptions {
 	/** Should missing enum cases be reported even if a default case exists in the same switch? */
 	public boolean reportMissingEnumCaseDespiteDefault;
 	
+	/** When checking for unlikely argument types of of Map.get() et al, perform strict analysis against the expected type */
+	public boolean reportUnlikelyCollectionMethodArgumentTypeStrict;
+
 	/** Should the compiler tolerate illegal ambiguous varargs invocation in compliance < 1.7 
 	 * to be bug compatible with javac? (bug 383780) */
 	public static boolean tolerateIllegalAmbiguousVarargsInvocation;
@@ -493,7 +505,6 @@ public class CompilerOptions {
 
 	/** Not directly configurable, derived from other options by LookupEnvironment.usesNullTypeAnnotations() */
 	public Boolean useNullTypeAnnotations = null;
-	
 
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
@@ -519,6 +530,7 @@ public class CompilerOptions {
 		"synthetic-access", //$NON-NLS-1$
 		"sync-override",	//$NON-NLS-1$
 		"unchecked", //$NON-NLS-1$
+		"unlikely-arg-type", //$NON-NLS-1$
 		"unqualified-field-access", //$NON-NLS-1$
 		"unused", //$NON-NLS-1$
 	};
@@ -714,6 +726,10 @@ public class CompilerOptions {
 				return OPTION_PessimisticNullAnalysisForFreeTypeVariables;
 			case NonNullTypeVariableFromLegacyInvocation:
 				return OPTION_ReportNonNullTypeVariableFromLegacyInvocation;
+			case UnlikelyCollectionMethodArgumentType:
+				return OPTION_ReportUnlikelyCollectionMethodArgumentType;
+			case UnlikelyEqualsArgumentType:
+				return OPTION_ReportUnlikelyEqualsArgumentType;
 		}
 		return null;
 	}
@@ -905,7 +921,9 @@ public class CompilerOptions {
 			OPTION_SyntacticNullAnalysisForFields,
 			OPTION_ReportUnusedTypeParameter,
 			OPTION_InheritNullAnnotations,
-			OPTION_ReportNonnullParameterAnnotationDropped
+			OPTION_ReportNonnullParameterAnnotationDropped,
+			OPTION_ReportUnlikelyCollectionMethodArgumentType,
+			OPTION_ReportUnlikelyEqualsArgumentType,
 		};
 		return result;
 	}
@@ -997,6 +1015,9 @@ public class CompilerOptions {
 				return "javadoc"; //$NON-NLS-1$
 			case MissingSynchronizedModifierInInheritedMethod:
 				return "sync-override";	 //$NON-NLS-1$
+			case UnlikelyEqualsArgumentType:
+			case UnlikelyCollectionMethodArgumentType:
+				return "unlikely-arg-type"; //$NON-NLS-1$
 		}
 		return null;
 	}
@@ -1077,6 +1098,8 @@ public class CompilerOptions {
 					return IrritantSet.UNCHECKED;
 				if ("unqualified-field-access".equals(warningToken)) //$NON-NLS-1$
 					return IrritantSet.UNQUALIFIED_FIELD_ACCESS;
+				if ("unlikely-arg-type".equals(warningToken)) //$NON-NLS-1$
+					return IrritantSet.UNLIKELY_ARGUMENT_TYPE;
 				break;
 		}
 		return null;
@@ -1222,6 +1245,9 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_PessimisticNullAnalysisForFreeTypeVariables, getSeverityString(PessimisticNullAnalysisForFreeTypeVariables));
 		optionsMap.put(OPTION_ReportNonNullTypeVariableFromLegacyInvocation, getSeverityString(NonNullTypeVariableFromLegacyInvocation));
+		optionsMap.put(OPTION_ReportUnlikelyCollectionMethodArgumentType, getSeverityString(UnlikelyCollectionMethodArgumentType));
+		optionsMap.put(OPTION_ReportUnlikelyCollectionMethodArgumentTypeStrict, this.reportUnlikelyCollectionMethodArgumentTypeStrict ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportUnlikelyEqualsArgumentType, getSeverityString(UnlikelyEqualsArgumentType));
 		return optionsMap;
 	}
 
@@ -1726,6 +1752,11 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportPotentiallyUnclosedCloseable)) != null) updateSeverity(PotentiallyUnclosedCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportExplicitlyClosedAutoCloseable)) != null) updateSeverity(ExplicitlyClosedAutoCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedTypeParameter)) != null) updateSeverity(UnusedTypeParameter, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportUnlikelyCollectionMethodArgumentType)) != null) updateSeverity(UnlikelyCollectionMethodArgumentType, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportUnlikelyCollectionMethodArgumentTypeStrict)) != null) {
+			this.reportUnlikelyCollectionMethodArgumentTypeStrict = ENABLED.equals(optionValue);
+		}
+		if ((optionValue = optionsMap.get(OPTION_ReportUnlikelyEqualsArgumentType)) != null) updateSeverity(UnlikelyEqualsArgumentType, optionValue);
 		if (getSeverity(UnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(PotentiallyUnclosedCloseable) == ProblemSeverities.Ignore
 				&& getSeverity(ExplicitlyClosedAutoCloseable) == ProblemSeverities.Ignore) {
@@ -2053,6 +2084,9 @@ public class CompilerOptions {
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
 		buf.append("\n\t- pessimistic null analysis for free type variables: ").append(getSeverityString(PessimisticNullAnalysisForFreeTypeVariables)); //$NON-NLS-1$
 		buf.append("\n\t- report unsafe nonnull return from legacy method: ").append(getSeverityString(NonNullTypeVariableFromLegacyInvocation)); //$NON-NLS-1$
+		buf.append("\n\t- unlikely argument type for collection methods: ").append(getSeverityString(UnlikelyCollectionMethodArgumentType)); //$NON-NLS-1$
+		buf.append("\n\t- unlikely argument type for collection methods, strict check against expected type: ").append(this.reportUnlikelyCollectionMethodArgumentTypeStrict ? ENABLED : DISABLED); //$NON-NLS-1$
+		buf.append("\n\t- unlikely argument types for equals(): ").append(getSeverityString(UnlikelyEqualsArgumentType)); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 280a502..8ba156b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								Bug 441208 - [1.8][null]SuppressWarnings("null") does not suppress / marked Unnecessary
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -67,12 +68,18 @@ public class IrritantSet {
 	public static final IrritantSet UNCHECKED = new IrritantSet(CompilerOptions.UncheckedTypeOperation);
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 	public static final IrritantSet RESOURCE = new IrritantSet(CompilerOptions.UnclosedCloseable);
+	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyCollectionMethodArgumentType);
 
 	public static final IrritantSet JAVADOC = new IrritantSet(CompilerOptions.InvalidJavadoc);
 	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
 	public static final IrritantSet COMPILER_DEFAULT_WARNINGS = new IrritantSet(0); // see static initializer below
 	public static final IrritantSet COMPILER_DEFAULT_INFOS = new IrritantSet(0); // As of now, no default values
 	static {
+		COMPILER_DEFAULT_INFOS
+		// group-2 infos enabled by default
+		.set(
+			CompilerOptions.UnlikelyEqualsArgumentType);
+		
 		COMPILER_DEFAULT_WARNINGS
 			// group-0 warnings enabled by default
 			.set(
@@ -117,7 +124,8 @@ public class IrritantSet {
 				|CompilerOptions.RedundantNullAnnotation
 				|CompilerOptions.NonnullParameterAnnotationDropped
 				|CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables
-				|CompilerOptions.NonNullTypeVariableFromLegacyInvocation);
+				|CompilerOptions.NonNullTypeVariableFromLegacyInvocation
+				|CompilerOptions.UnlikelyCollectionMethodArgumentType);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
@@ -169,6 +177,9 @@ public class IrritantSet {
 		JAVADOC
 			.set(CompilerOptions.MissingJavadocComments)
 			.set(CompilerOptions.MissingJavadocTags);
+
+		UNLIKELY_ARGUMENT_TYPE
+			.set(CompilerOptions.UnlikelyEqualsArgumentType);
 	}
 
 	// Internal state
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 96ba4af..a128e23 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -35,6 +35,7 @@
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
  *								Bug 446442 - [1.8] merge null annotations from super methods
  *								Bug 456532 - [1.8][null] ReferenceBinding.appendNullAnnotation() includes phantom annotations in error messages
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -503,13 +504,27 @@ public void computeId() {
 						if (CharOperation.equals(packageName, TypeConstants.UTIL)) {
 							switch (typeName[0]) {
 								case 'C' :
-									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2]))
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_COLLECTION[2])) {
 										this.id = TypeIds.T_JavaUtilCollection;
+										this.typeBits |= TypeIds.BitCollection;
+									}										
 									return;
 								case 'I' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_ITERATOR[2]))
 										this.id = TypeIds.T_JavaUtilIterator;
 									return;
+								case 'L' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_LIST[2])) {
+										this.id = TypeIds.T_JavaUtilList;
+										this.typeBits |= TypeIds.BitList;
+									}										
+									return;
+								case 'M' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_MAP[2])) {
+										this.id = TypeIds.T_JavaUtilMap;
+										this.typeBits |= TypeIds.BitMap;
+									}
+									return;
 								case 'O' :
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_OBJECTS[2]))
 										this.id = TypeIds.T_JavaUtilObjects;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index d37a9d0..5f5360a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,7 @@
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 425183 - [1.8][inference] make CaptureBinding18 safe
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *    Jesper S Moller - Contributions for
  *								Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -27,6 +28,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
+
 // TODO should rename into TypeNames (once extracted last non name constants)
 public interface TypeConstants {
 
@@ -160,6 +163,7 @@ public interface TypeConstants {
 	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_OBJECTS = {JAVA, UTIL, "Objects".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_LIST = {JAVA, UTIL, "List".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
@@ -333,6 +337,75 @@ public interface TypeConstants {
 	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {COM, GOOGLE, INJECT_PACKAGE, INJECT_TYPE };
 	//    detail for the above:
 	char[] OPTIONAL = "optional".toCharArray(); //$NON-NLS-1$
+	
+	// well-known methods with "dangerous" signatures:
+	char[][] JAVA_UTIL_MAP = new char[][] { JAVA, UTIL, "Map".toCharArray() }; //$NON-NLS-1$
+	char[] GET = "get".toCharArray(); //$NON-NLS-1$
+	char[] REMOVE = "remove".toCharArray(); //$NON-NLS-1$
+	char[] REMOVE_ALL = "removeAll".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_ALL = "containsAll".toCharArray(); //$NON-NLS-1$
+	char[] RETAIN_ALL = "retainAll".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_KEY = "containsKey".toCharArray(); //$NON-NLS-1$
+	char[] CONTAINS_VALUE = "containsValue".toCharArray(); //$NON-NLS-1$
+	// for Collection.contains:
+	char[] CONTAINS = "contains".toCharArray(); //$NON-NLS-1$
+	// for List.*indexOf:
+	char[] INDEX_OF = "indexOf".toCharArray(); //$NON-NLS-1$
+	char[] LAST_INDEX_OF = "lastIndexOf".toCharArray(); //$NON-NLS-1$
+	enum DangerousMethod {
+		// Collection:
+		Contains, Remove, RemoveAll, ContainsAll, RetainAll,
+		// Map:
+		Get, ContainsKey, ContainsValue,
+		// List:
+		IndexOf, LastIndexOf,
+		// Object:
+		Equals;
+
+		public static DangerousMethod detectSelector(char[] selector) {
+			switch (selector[0]) {
+				case 'r':
+					if (CharOperation.prefixEquals(TypeConstants.REMOVE, selector)) {
+						if (CharOperation.equals(selector, TypeConstants.REMOVE))
+							return DangerousMethod.Remove;
+						else if (CharOperation.equals(selector, TypeConstants.REMOVE_ALL))
+							return DangerousMethod.RemoveAll;
+					} else if (CharOperation.equals(selector, TypeConstants.RETAIN_ALL)) {
+						return DangerousMethod.RetainAll;
+					}
+					break;
+				case 'c':
+					if (CharOperation.prefixEquals(TypeConstants.CONTAINS, selector)) {
+						if (CharOperation.equals(selector, TypeConstants.CONTAINS))
+							return DangerousMethod.Contains;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_ALL))
+							return DangerousMethod.ContainsAll;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_KEY))
+							return DangerousMethod.ContainsKey;
+						else if (CharOperation.equals(selector, TypeConstants.CONTAINS_VALUE))
+							return DangerousMethod.ContainsValue;
+					}
+					break;
+				case 'g':
+					if (CharOperation.equals(selector, TypeConstants.GET))
+						return DangerousMethod.Get;
+					break;
+				case 'i':
+					if (CharOperation.equals(selector, TypeConstants.INDEX_OF))
+						return DangerousMethod.IndexOf;
+					break;
+				case 'l':
+					if (CharOperation.equals(selector, TypeConstants.LAST_INDEX_OF))
+						return DangerousMethod.LastIndexOf;
+					break;
+				case 'e':
+					if (CharOperation.equals(selector, TypeConstants.EQUALS))
+						return DangerousMethod.Equals;
+					break;
+			}
+			return null;
+		}
+	}
 
 	// Spring @Autowired annotation
 	char [] AUTOWIRED = "Autowired".toCharArray();  //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 7749b66..425672f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -14,6 +14,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *     Ulrich Grave <ulrich.grave@gmx.de> - Contributions for
@@ -132,6 +133,11 @@ public interface TypeIds {
 
 	// Java 8 - JEP 120
 	final int T_JavaLangAnnotationRepeatable = 90;
+	
+	// classes with methods with "dangerous" signatures:
+	final int T_JavaUtilMap = 91;
+	final int T_JavaUtilList = 92;
+
 	// If you add new type id, make sure to bump up T_LastWellKnownTypeId if there is a cross over.
 	final int T_LastWellKnownTypeId = 128;
 	
@@ -253,8 +259,17 @@ public interface TypeIds {
 	final int BitNonNullByDefaultAnnotation = 128;
 	final int BitAnyNullAnnotation = BitNonNullAnnotation | BitNullableAnnotation | BitNonNullByDefaultAnnotation;
 
+	/** Mark subtypes of Map to analyze dangerous get/remove et al. */
+	final int BitMap = 256;
+
+	/** Mark subtypes of Collection to analyze dangerous contains/remove. */
+	final int BitCollection = 512;
+
+	/** Mark subtypes of List to analyze dangerous indexOf. */
+	final int BitList = 1024;
+
 	/**
 	 * Set of type bits that should be inherited by any sub types.
 	 */
-	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType;
+	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType | BitMap | BitCollection | BitList ;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 3773f15..5d40ddf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -59,6 +59,7 @@
  *								Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
  *								Bug 459967 - [null] compiler should know about nullness of special methods like MyEnum.valueOf()
  *								Bug 461878 - [1.7][1.8][compiler][null] ECJ compiler does not allow to use null annotations on annotations
+ *								Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -177,6 +178,7 @@ import org.eclipse.jdt.internal.compiler.lookup.SyntheticArgumentBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DangerousMethod;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
@@ -609,6 +611,11 @@ public static int getIrritant(int problemID) {
 			
 		case IProblem.UnusedTypeParameter:
 			return CompilerOptions.UnusedTypeParameter;
+
+		case IProblem.UnlikelyCollectionMethodArgumentType:
+			return CompilerOptions.UnlikelyCollectionMethodArgumentType;
+		case IProblem.UnlikelyEqualsArgumentType:
+			return CompilerOptions.UnlikelyEqualsArgumentType;
 }
 	return 0;
 }
@@ -668,6 +675,8 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.PotentiallyUnclosedCloseable :
 			case CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables :
 			case CompilerOptions.NonNullTypeVariableFromLegacyInvocation :
+			case CompilerOptions.UnlikelyCollectionMethodArgumentType :
+			case CompilerOptions.UnlikelyEqualsArgumentType:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10472,4 +10481,23 @@ public void invalidTypeArguments(TypeReference[] typeReference) {
 			typeReference[0].sourceStart,
 			typeReference[typeReference.length - 1].sourceEnd);
 }
+
+public void unlikelyArgumentType(Expression argument, MethodBinding method, TypeBinding argumentType,
+							TypeBinding receiverType, DangerousMethod dangerousMethod)
+{
+	this.handle(
+			dangerousMethod == DangerousMethod.Equals ? IProblem.UnlikelyEqualsArgumentType : IProblem.UnlikelyCollectionMethodArgumentType,
+			new String[] {
+				new String(argumentType.readableName()),
+				new String(method.readableName()),
+				new String(receiverType.readableName())
+			}, 
+			new String[] {
+				new String(argumentType.shortReadableName()),
+				new String(method.shortReadableName()),
+				new String(receiverType.shortReadableName())
+			}, 
+			argument.sourceStart, 
+			argument.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index fbd87c9..9467acc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -42,6 +42,7 @@
 #							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
 #							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
 #							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
+#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -867,6 +868,10 @@
 1100 = Problem detected during type inference: {0}
 #1101 is already used up but deprecated
 1102 = At least one of the problems in category ''{0}'' is not analysed due to a compiler option being ignored
+# more programming problems:
+1200 = Unlikely argument type {0} for {1} on a {2}
+1201 = Unlikely argument type for equals(): {0} seems to be unrelated to {2}
+
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
@@ -880,4 +885,4 @@
 78602 = The constructor ''{1}'' is not API (restriction on required library ''{0}'')
 78604 = The method ''{2}.{1}'' is not API (restriction on classpath entry ''{0}'')
 78606 = The method ''{2}.{1}'' is not API (restriction on required library ''{0}'')
-78605 = The method ''{2}.{1}'' is not API (restriction on required project ''{0}'')
\ No newline at end of file
+78605 = The method ''{2}.{1}'' is not API (restriction on required project ''{0}'')
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 89a651a..ffb80ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -98,6 +98,8 @@
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
+ *									COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE
+ *									COMPILER_PB_UNLIKELY_EQUALS_ARGUMENT_TYPE
  *     Jesper S Moller   - Contributions for bug 381345 : [1.8] Take care of the Java 8 major version
  *                       - added the following constants:
  *									COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR
@@ -1514,6 +1516,60 @@ public final class JavaCore extends Plugin {
 	 * @category CompilerOptionID
 	 */
 	public static final String COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE = PLUGIN_ID + ".compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+
+	/**
+	 * Compiler option ID: Reporting a method invocation providing an argument of an unlikely type.
+	 * <p>When enabled, the compiler will issue an error or warning when certain well-known Collection methods
+	 *    that take an 'Object', like e.g. {@link Map#get(Object)}, are used with an argument type
+	 *    that seems to be not related to the corresponding type argument of the Collection.</p>
+	 * <p>By default, this analysis will apply some heuristics to determine whether or not two
+	 *    types may or may not be related, which can be changed via option
+	 *    {@link #COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE_STRICT}.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentType"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "info", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.13
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.unlikelyCollectionMethodArgumentType"; //$NON-NLS-1$
+
+	/**
+	 * Compiler option ID: Perform strict analysis against the expected type of collection methods.
+	 * <p>This is a sub-option of {@link #COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE},
+	 *    which will replace the heuristics with strict compatibility checks,
+	 *    i.e., each argument that is not strictly compatible with the expected type will trigger an error or warning.</p>
+	 * <p>This option has no effect if {@link #COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE} is set to <code>"ignore"</code>.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "enabled", "disabled" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
+	 * @since 3.13
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_UNLIKELY_COLLECTION_METHOD_ARGUMENT_TYPE_STRICT = PLUGIN_ID + ".compiler.problem.unlikelyCollectionMethodArgumentTypeStrict"; //$NON-NLS-1$
+
+	/**
+	 * Compiler option ID: Reporting a method invocation providing an argument of an unlikely type to method 'equals'.
+	 * <p>
+	 * When enabled, the compiler will issue an error or warning when {@link java.lang.Object#equals(Object)} is used with an argument type 
+	 * that seems to be not related to the receiver's type, or correspondingly when the arguments of {@link java.util.Objects#equals(Object, Object)}
+	 * have types that seem to be not related to each other.
+	 * </p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType"</code></dd>
+	 * <dt>Possible values:</dt>
+	 * <dd><code>{ "error", "warning", "info", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"info"</code></dd>
+	 * </dl>
+	 * 
+	 * @since 3.13
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_UNLIKELY_EQUALS_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.unlikelyEqualsArgumentType"; //$NON-NLS-1$
+
 	/**
 	 * Compiler option ID: Annotation-based Null Analysis.
 	 * <p>This option controls whether the compiler will use null annotations for
