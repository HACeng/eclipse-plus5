commit 4e6bb96b0e120539a45cc4860f508bf12e097d37
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Jul 29 00:11:46 2015 +0200

    Bug 473657 - [1.8][compile] Bad type inference applied to raw type
    arguments when javac compiles code just fine
    
    Change-Id: I07bc7f17bbc6dec97ed0fca213ecc0d6ba8afdd6

69	152	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
40	66	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
30	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
1	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
22	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 60fbfd6..c230094 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -16827,7 +16827,9 @@ public void test0500(){
 			"6. WARNING in X.java (at line 10)\n" + 
 			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" + 
 			"	                                   ^\n" + 
-			"Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			? "Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum>\n"
+			: "Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>\n") + 
 			"----------\n");
 	}
 	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
@@ -32091,7 +32093,9 @@ public void test0961() {
 		"5. WARNING in X.java (at line 7)\n" +
 		"	Comparable c = newInstance2(x);\n" +
 		"	                            ^\n" +
-		"Type safety: The expression of type X needs unchecked conversion to conform to X<Comparable>\n" +
+		(this.complianceLevel < ClassFileConstants.JDK1_8
+		? "Type safety: The expression of type X needs unchecked conversion to conform to X<Comparable>\n"
+		: "Type safety: The expression of type X needs unchecked conversion to conform to X<Comparable<Comparable<B>>>\n") +
 		"----------\n" +
 		"6. ERROR in X.java (at line 9)\n" +
 		"	Zork z;\n" +
@@ -33467,7 +33471,9 @@ public void test0999() {
 			"4. WARNING in X.java (at line 9)\n" + 
 			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" + 
 			"	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-			"Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Number>[]\n" +
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			? "Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Number>[]\n"
+			: "Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Object>[]\n") +
 			"----------\n" + 
 			"5. ERROR in X.java (at line 14)\n" + 
 			"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" + 
@@ -33605,7 +33611,7 @@ public void test1000() {
 			"4. WARNING in X.java (at line 9)\n" + 
 			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" + 
 			"	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<? extends Number>[]\n" + 
+			"Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<? extends Object>[]\n" + 
 			"----------\n" + 
 			"5. WARNING in X.java (at line 14)\n" + 
 			"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" + 
@@ -50350,10 +50356,23 @@ public void test1436() {
 			"	^^^^^^^^^^^\n" + 
 			"Type safety: Unchecked invocation foo(List, IllegalArgumentException) of the generic method foo(List<U>, T) of type X\n" + 
 			"----------\n" +
-			"3. WARNING in X.java (at line 8)\n" + 
-			"	foo(l, iae);\n" + 
-			"	    ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			?
+				"3. WARNING in X.java (at line 8)\n" + 
+				"	foo(l, iae);\n" + 
+				"	    ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"
+			:
+				"3. ERROR in X.java (at line 8)\n" + 
+				"	foo(l, iae);\n" + 
+				"	^^^^^^^^^^^\n" + 
+				"Unhandled exception type Throwable\n" + // new error since 1.8 (bug 473657)
+				"----------\n" + 
+				"4. WARNING in X.java (at line 8)\n" + 
+				"	foo(l, iae);\n" + 
+				"	    ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"				
+			) +
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
@@ -50385,10 +50404,23 @@ public void test1437() {
 			"	^^^^^^^^^^^^^\n" + 
 			"Type safety: Unchecked invocation X(List, IllegalArgumentException) of the generic constructor X(List<U>, T) of type X\n" + 
 			"----------\n" +
-			"3. WARNING in X.java (at line 8)\n" + 
-			"	new X(l, iae);\n" + 
-			"	      ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			?
+				"3. WARNING in X.java (at line 8)\n" + 
+				"	new X(l, iae);\n" + 
+				"	      ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"
+			:
+				"3. ERROR in X.java (at line 8)\n" + 
+				"	new X(l, iae);\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"Unhandled exception type Throwable\n" + // new error since 1.8 (bug 473657)
+				"----------\n" + 
+				"4. WARNING in X.java (at line 8)\n" + 
+				"	new X(l, iae);\n" + 
+				"	      ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"				
+			) +
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
@@ -50420,10 +50452,23 @@ public void test1438() {
 			"	^^^^^^^^^^^^^^^\n" + 
 			"Type safety: Unchecked invocation X(List, IllegalArgumentException) of the generic constructor X(List<U>, T) of type X\n" + 
 			"----------\n" +
-			"3. WARNING in X.java (at line 8)\n" + 
-			"	new X(l, iae){};\n" + 
-			"	      ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			?
+				"3. WARNING in X.java (at line 8)\n" + 
+				"	new X(l, iae){};\n" + 
+				"	      ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"
+			:
+				"3. ERROR in X.java (at line 8)\n" + 
+				"	new X(l, iae){};\n" + 
+				"	^^^^^^^^^^^^^^^\n" + 
+				"Unhandled exception type Throwable\n" + // new error since 1.8 (bug 473657)
+				"----------\n" + 
+				"4. WARNING in X.java (at line 8)\n" + 
+				"	new X(l, iae){};\n" + 
+				"	      ^\n" + 
+				"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n"				
+			) +
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
@@ -50446,7 +50491,6 @@ public void test1439() {
 				"	}\n" + 
 				"}\n",//-----------------------------------------------------------------------
 			},
-			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
 			"----------\n" + 
 			"1. WARNING in X.java (at line 7)\n" + 
 			"	this((List) null, null);\n" + 
@@ -50487,44 +50531,7 @@ public void test1439() {
 			"	super((List)lu, t);\n" + 
 			"	       ^^^^\n" + 
 			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n"
-			: // 1.8 infers T in this((List) null, null) to RuntimeException, hence no error here (2. above)
-			"----------\n" + 
-			"1. WARNING in X.java (at line 7)\n" + 
-			"	this((List) null, null);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List, null) of the generic constructor X(List<U>, T) of type X\n" + 
-			"----------\n" + 
-			"2. WARNING in X.java (at line 7)\n" + 
-			"	this((List) null, null);\n" + 
-			"	     ^^^^^^^^^^^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" + 
-			"----------\n" + 
-			"3. WARNING in X.java (at line 7)\n" + 
-			"	this((List) null, null);\n" + 
-			"	      ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n" + 
-			"4. WARNING in X.java (at line 12)\n" + 
-			"	super((List)lu, t);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List, T) of the generic constructor X(List<U>, T) of type X\n" + 
-			"----------\n" + 
-			"5. ERROR in X.java (at line 12)\n" + 
-			"	super((List)lu, t);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^\n" + 
-			"Unhandled exception type Throwable\n" + 
-			"----------\n" + 
-			"6. WARNING in X.java (at line 12)\n" + 
-			"	super((List)lu, t);\n" + 
-			"	      ^^^^^^^^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" + 
-			"----------\n" + 
-			"7. WARNING in X.java (at line 12)\n" + 
-			"	super((List)lu, t);\n" + 
-			"	       ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n"));
+			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=260567
 public void test1440() {
@@ -50762,7 +50769,6 @@ public void test1445() {
 				"\n" + 
 				"}\n",
 			},
-			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
 			"----------\n" + 
 			"1. WARNING in X.java (at line 8)\n" + 
 			"	static void bar(List l) {\n" + 
@@ -50792,12 +50798,16 @@ public void test1445() {
 			"6. WARNING in X.java (at line 9)\n" + 
 			"	new X(l).foo(l);\n" + 
 			"	      ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			? "Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n"
+			: "Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" ) +
 			"----------\n" + 
 			"7. WARNING in X.java (at line 9)\n" + 
 			"	new X(l).foo(l);\n" + 
 			"	             ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			? "Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n"
+			: "Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" ) +
 			"----------\n" + 
 			"8. WARNING in X.java (at line 11)\n" + 
 			"	static void baz(List l) throws IOException {\n" + 
@@ -50863,100 +50873,7 @@ public void test1445() {
 			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
 			"	                                            ^\n" + 
 			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n"
-			: // 1.8 infers type parameters in throws clauses to RuntimeException, hence no errors
-			"----------\n" + 
-			"1. WARNING in X.java (at line 8)\n" + 
-			"	static void bar(List l) {\n" + 
-			"	                ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n" + 
-			"2. WARNING in X.java (at line 9)\n" + 
-			"	new X(l).foo(l);\n" + 
-			"	^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
-			"----------\n" + 
-			"3. WARNING in X.java (at line 9)\n" + 
-			"	new X(l).foo(l);\n" + 
-			"	^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
-			"----------\n" + 
-			"4. WARNING in X.java (at line 9)\n" + 
-			"	new X(l).foo(l);\n" + 
-			"	      ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" + 
-			"----------\n" + 
-			"5. WARNING in X.java (at line 9)\n" + 
-			"	new X(l).foo(l);\n" + 
-			"	             ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" + 
-			"----------\n" + 
-			"6. WARNING in X.java (at line 11)\n" + 
-			"	static void baz(List l) throws IOException {\n" + 
-			"	                ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n" + 
-			"7. WARNING in X.java (at line 12)\n" + 
-			"	new <IOException> X(l). <IOException> foo(l);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
-			"----------\n" + 
-			"8. WARNING in X.java (at line 12)\n" + 
-			"	new <IOException> X(l). <IOException> foo(l);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
-			"----------\n" + 
-			"9. WARNING in X.java (at line 12)\n" + 
-			"	new <IOException> X(l). <IOException> foo(l);\n" + 
-			"	                    ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n" + 
-			"10. WARNING in X.java (at line 12)\n" + 
-			"	new <IOException> X(l). <IOException> foo(l);\n" + 
-			"	                                          ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n" + 
-			"11. WARNING in X.java (at line 15)\n" + 
-			"	X(List l, long l2) throws IOException {\n" + 
-			"	  ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n" + 
-			"12. WARNING in X.java (at line 16)\n" + 
-			"	<IOException> this(l);\n" + 
-			"	              ^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
-			"----------\n" + 
-			"13. WARNING in X.java (at line 16)\n" + 
-			"	<IOException> this(l);\n" + 
-			"	                   ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n" + 
-			"14. WARNING in X.java (at line 19)\n" + 
-			"	static void baz2(List l) throws IOException {\n" + 
-			"	                 ^^^^\n" + 
-			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
-			"----------\n" + 
-			"15. WARNING in X.java (at line 20)\n" + 
-			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
-			"----------\n" + 
-			"16. WARNING in X.java (at line 20)\n" + 
-			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
-			"----------\n" + 
-			"17. WARNING in X.java (at line 20)\n" + 
-			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
-			"	                    ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n" + 
-			"18. WARNING in X.java (at line 20)\n" + 
-			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
-			"	                                            ^\n" + 
-			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n"
-			));
+			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=202393
 public void test1446() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
index 30c5d06..3f85381 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
@@ -5453,7 +5453,7 @@ public void testBug452194() {
 		"The method addUnique(Map.Entry) in the type EcoreEMap is not applicable for the arguments (Object)\n" + 
 		"----------\n");
 }
-public void testBug453253() {
+public void testBug454644() {
 	runNegativeTest(
 		new String[] {
 			"example/CollectionFactory.java",
@@ -5561,71 +5561,45 @@ public void testBug453253() {
 			"\n" + 
 			"}\n"
 		},
-		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
-			"----------\n" + 
-			"1. WARNING in example\\CollectionFactory.java (at line 42)\n" + 
-			"	@SuppressWarnings({ \"unchecked\", \"cast\" })\n" + 
-			"	                                 ^^^^^^\n" + 
-			"Unnecessary @SuppressWarnings(\"cast\")\n" + 
-			"----------\n" + 
-			"2. WARNING in example\\CollectionFactory.java (at line 55)\n" + 
-			"	return EnumSet.copyOf((EnumSet) collection);\n" + 
-			"	                       ^^^^^^^\n" + 
-			"EnumSet is a raw type. References to generic type EnumSet<E> should be parameterized\n" + 
-			"----------\n" + 
-			"3. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked invocation noneOf(Class) of the generic method noneOf(Class<E>) of type EnumSet\n" + 
-			"----------\n" + 
-			"4. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: The expression of type EnumSet needs unchecked conversion to conform to Collection<E>\n" + 
-			"----------\n" + 
-			"5. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	                      ^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: The expression of type Class needs unchecked conversion to conform to Class<E>\n" + 
-			"----------\n" + 
-			"6. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	                       ^^^^^\n" + 
-			"Class is a raw type. References to generic type Class<T> should be parameterized\n" + 
-			"----------\n" + 
-			"7. WARNING in example\\CollectionFactory.java (at line 94)\n" + 
-			"	return (Collection<E>) collectionClass.newInstance();\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked cast from capture#13-of ? to Collection<E>\n" + 
-			"----------\n"
-		:
-			"----------\n" + 
-			"1. ERROR in example\\CollectionFactory.java (at line 55)\n" + 
-			"	return EnumSet.copyOf((EnumSet) collection);\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type mismatch: cannot convert from EnumSet<Enum<Enum<E>>> to Collection<E>\n" + 
-			"----------\n" + 
-			"2. WARNING in example\\CollectionFactory.java (at line 55)\n" + 
-			"	return EnumSet.copyOf((EnumSet) collection);\n" + 
-			"	                       ^^^^^^^\n" + 
-			"EnumSet is a raw type. References to generic type EnumSet<E> should be parameterized\n" + 
-			"----------\n" + 
-			"3. ERROR in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type mismatch: cannot convert from EnumSet<Enum<Enum<E>>> to Collection<E>\n" + 
-			"----------\n" + 
-			"4. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
-			"	return EnumSet.noneOf((Class) elementType);\n" + 
-			"	                       ^^^^^\n" + 
-			"Class is a raw type. References to generic type Class<T> should be parameterized\n" + 
-			"----------\n" + 
-			"5. WARNING in example\\CollectionFactory.java (at line 94)\n" + 
-			"	return (Collection<E>) collectionClass.newInstance();\n" + 
-			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type safety: Unchecked cast from capture#13-of ? to Collection<E>\n" + 
-			"----------\n"
-			));
+		"----------\n" + 
+		"1. WARNING in example\\CollectionFactory.java (at line 42)\n" + 
+		"	@SuppressWarnings({ \"unchecked\", \"cast\" })\n" + 
+		"	                                 ^^^^^^\n" + 
+		"Unnecessary @SuppressWarnings(\"cast\")\n" + 
+		"----------\n" + 
+		"2. WARNING in example\\CollectionFactory.java (at line 55)\n" + 
+		"	return EnumSet.copyOf((EnumSet) collection);\n" + 
+		"	                       ^^^^^^^\n" + 
+		"EnumSet is a raw type. References to generic type EnumSet<E> should be parameterized\n" + 
+		"----------\n" + 
+		"3. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
+		"	return EnumSet.noneOf((Class) elementType);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type safety: Unchecked invocation noneOf(Class) of the generic method noneOf(Class<E>) of type EnumSet\n" + 
+		"----------\n" + 
+		"4. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
+		"	return EnumSet.noneOf((Class) elementType);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type safety: The expression of type EnumSet needs unchecked conversion to conform to Collection<E>\n" + 
+		"----------\n" + 
+		"5. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
+		"	return EnumSet.noneOf((Class) elementType);\n" + 
+		"	                      ^^^^^^^^^^^^^^^^^^^\n" + 
+		(this.complianceLevel < ClassFileConstants.JDK1_8 
+		? "Type safety: The expression of type Class needs unchecked conversion to conform to Class<E>\n"
+		: "Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>\n") + 
+		"----------\n" + 
+		"6. WARNING in example\\CollectionFactory.java (at line 87)\n" + 
+		"	return EnumSet.noneOf((Class) elementType);\n" + 
+		"	                       ^^^^^\n" + 
+		"Class is a raw type. References to generic type Class<T> should be parameterized\n" + 
+		"----------\n" + 
+		"7. WARNING in example\\CollectionFactory.java (at line 94)\n" + 
+		"	return (Collection<E>) collectionClass.newInstance();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type safety: Unchecked cast from capture#13-of ? to Collection<E>\n" + 
+		"----------\n"
+		);
 }
 // original test case, documenting existing compiler behavior
 public void testBug456459a() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index 5aeb1d7..08798bc 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -5567,4 +5567,34 @@ public void testBug464496() {
 		},
 		"42");
 }
+public void testBug473657() {
+	runConformTest(
+		new String[] {
+			"T2.java",
+			"interface I<T> {\n" + 
+			"}\n" + 
+			"\n" + 
+			"@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n" + 
+			"abstract class T1<T> implements I<T> {\n" + 
+			"    public I<T> t(I<? extends Number> l2) {\n" + 
+			"        return T2.m((I) this, (I) l2);\n" + 
+			"    }\n" + 
+			"    public I<T> t(Number l2) {\n" + 
+			"        return T2.m((I) this, (I) T2.t(l2));\n" + 
+			"    }\n" + 
+			"}\n" + 
+			"\n" + 
+			"public abstract class T2 {\n" + 
+			"    public static <T> I<T> t(T t) {\n" + 
+			"        return null;\n" + 
+			"    }\n" + 
+			"    public static <T extends Number> I<T> m(I<T> l1, I<? extends Number> l2) {\n" + 
+			"        return null;\n" + 
+			"    }\n" + 
+			"    public static <T extends Number> I<T> m(T l1, Number l2) {\n" + 
+			"        return null;\n" + 
+			"    }\n" + 
+			"}\n"
+		});
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 9b4b32e..908d43b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -362,11 +362,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				// spec says erasure, but we don't really have compatibility rules for erasure, use raw type instead:
 				TypeBinding erasure = inferenceContext.environment.convertToRawType(returnType, false);
 				ConstraintTypeFormula newConstraint = ConstraintTypeFormula.create(erasure, targetType, COMPATIBLE);
-				if (!inferenceContext.reduceAndIncorporate(newConstraint))
-					return false;
-				// continuing at true is not spec'd but needed for javac-compatibility,
-				// see org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8.testBug428198()
-				// and org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8.testBug428264()
+				return inferenceContext.reduceAndIncorporate(newConstraint);
 			}
 			TypeBinding rTheta = inferenceContext.substitute(returnType);
 			ParameterizedTypeBinding parameterizedType = InferenceContext18.parameterizedWithWildcard(rTheta);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 3b5083d..8882848 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -810,6 +810,11 @@ public ParameterizedGenericMethodBinding createParameterizedGenericMethod(Method
 }
 
 public ParameterizedGenericMethodBinding createParameterizedGenericMethod(MethodBinding genericMethod, TypeBinding[] typeArguments) {
+	return createParameterizedGenericMethod(genericMethod, typeArguments, false, false);
+}
+public ParameterizedGenericMethodBinding createParameterizedGenericMethod(MethodBinding genericMethod, TypeBinding[] typeArguments,
+																			boolean inferredWithUncheckedConversion, boolean hasReturnProblem)
+{
 	// cached info is array of already created parameterized types for this type
 	ParameterizedGenericMethodBinding[] cachedInfo = (ParameterizedGenericMethodBinding[])this.uniqueParameterizedGenericMethodBindings.get(genericMethod);
 	int argLength = typeArguments == null ? 0: typeArguments.length;
@@ -828,6 +833,12 @@ public ParameterizedGenericMethodBinding createParameterizedGenericMethod(Method
 				for (int j = 0; j < cachedArgLength; j++){
 					if (typeArguments[j] != cachedArguments[j]) continue nextCachedMethod; //$IDENTITY-COMPARISON$
 				}
+				if (inferredWithUncheckedConversion) { // JSL 18.5.2: "If unchecked conversion was necessary..."
+					// don't tolerate remaining parameterized types / type variables, should have been eliminated by erasure:
+					if (cachedMethod.returnType.isParameterizedType() || cachedMethod.returnType.isTypeVariable()) continue;
+					for (TypeBinding exc : cachedMethod.thrownExceptions)
+						if (exc.isParameterizedType() || exc.isTypeVariable()) continue nextCachedMethod;
+				}
 				// all arguments match, reuse current
 				return cachedMethod;
 		}
@@ -843,7 +854,8 @@ public ParameterizedGenericMethodBinding createParameterizedGenericMethod(Method
 		this.uniqueParameterizedGenericMethodBindings.put(genericMethod, cachedInfo);
 	}
 	// add new binding
-	ParameterizedGenericMethodBinding parameterizedGenericMethod = new ParameterizedGenericMethodBinding(genericMethod, typeArguments, this);
+	ParameterizedGenericMethodBinding parameterizedGenericMethod =
+			new ParameterizedGenericMethodBinding(genericMethod, typeArguments, this, inferredWithUncheckedConversion, hasReturnProblem);
 	cachedInfo[index] = parameterizedGenericMethod;
 	return parameterizedGenericMethod;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 6c22117..f7ab036 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -263,7 +263,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 				// assemble the solution etc:
 				TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
 				if (solutions != null) {
-					methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
+					methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions, infCtx18.usesUncheckedConversion, hasReturnProblem);
 					if (invocationSite instanceof Invocation)
 						infCtx18.forwardResults(result, (Invocation) invocationSite, methodSubstitute, expectedType);
 					if (hasReturnProblem) { // illegally working from the provisional result?
@@ -529,7 +529,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
     /**
      * Create method of parameterized type, substituting original parameters with type arguments.
      */
-	public ParameterizedGenericMethodBinding(MethodBinding originalMethod, TypeBinding[] typeArguments, LookupEnvironment environment) {
+	public ParameterizedGenericMethodBinding(MethodBinding originalMethod, TypeBinding[] typeArguments, LookupEnvironment environment, boolean inferredWithUncheckConversion, boolean hasReturnProblem) {
 	    this.environment = environment;
 		this.modifiers = originalMethod.modifiers;
 		this.selector = originalMethod.selector;
@@ -541,8 +541,16 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    this.originalMethod = originalMethod;
 	    this.parameters = Scope.substitute(this, originalMethod.parameters);
 	    // error case where exception type variable would have been substituted by a non-reference type (207573)
-	    this.returnType = Scope.substitute(this, originalMethod.returnType);
-	    this.thrownExceptions = Scope.substitute(this, originalMethod.thrownExceptions);
+	    if (inferredWithUncheckConversion) { // JSL 18.5.2: "If unchecked conversion was necessary..."
+	    	this.returnType = getErasure18_5_2(originalMethod.returnType, environment, hasReturnProblem); // propagate simulation of Bug JDK_8026527
+	    	this.thrownExceptions = new ReferenceBinding[originalMethod.thrownExceptions.length];
+	    	for (int i = 0; i < originalMethod.thrownExceptions.length; i++) {
+	    		this.thrownExceptions[i] = (ReferenceBinding) getErasure18_5_2(originalMethod.thrownExceptions[i], environment, false); // no excuse for exceptions
+			}
+	    } else {
+	    	this.returnType = Scope.substitute(this, originalMethod.returnType);
+	    	this.thrownExceptions = Scope.substitute(this, originalMethod.thrownExceptions);
+	    }
 	    if (this.thrownExceptions == null) this.thrownExceptions = Binding.NO_EXCEPTIONS;
 		checkMissingType: {
 			if ((this.tagBits & TagBits.HasMissingType) != 0)
@@ -582,6 +590,16 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    }
 	}
 
+	TypeBinding getErasure18_5_2(TypeBinding type, LookupEnvironment env, boolean substitute) {
+		// opportunistic interpretation of (JLS 18.5.2):
+		// "If unchecked conversion was necessary ..., then ... 
+		// the return type and thrown types of the invocation type of m are given by
+		// the erasure of the return type and thrown types of m's type."
+		if (substitute)
+			type = Scope.substitute(this, type);
+		return env.convertToRawType(type, true);
+	}
+
 	/*
 	 * parameterizedDeclaringUniqueKey dot selector originalMethodGenericSignature percent typeArguments
 	 * p.X<U> { <T> void bar(T t, U u) { new X<String>().bar(this, "") } } --> Lp/X<Ljava/lang/String;>;.bar<T:Ljava/lang/Object;>(TT;Ljava/lang/String;)V%<Lp/X;>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
index 3a5f6c4..29ed92b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
@@ -14,7 +14,7 @@ public class PolyParameterizedGenericMethodBinding extends ParameterizedGenericM
 
 	private ParameterizedGenericMethodBinding wrappedBinding; 
 	public PolyParameterizedGenericMethodBinding(ParameterizedGenericMethodBinding applicableMethod) {
-		super(applicableMethod.originalMethod, applicableMethod.typeArguments, applicableMethod.environment);
+		super(applicableMethod.originalMethod, applicableMethod.typeArguments, applicableMethod.environment, false, false);
 		this.wrappedBinding = applicableMethod;
 	}
 	
commit adcded225fcfb954dab39f46336b535d8fbfb952
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Apr 19 19:18:20 2016 +0200

    Bug 473657: [1.8][compile] Bad type inference applied to raw type
    arguments when javac compiles code just fine
    
    Change-Id: Ia2244cd03657c2d5857a8bb537e82ade9ffef9dc

26	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index bba4d0b..c0bdf6b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -6088,4 +6088,30 @@ public void testBug489976() {
 			"}\n"
 		});
 }
+public void testBug491934() {
+	runConformTest(
+		new String[] {
+			"Main.java",
+			"import java.util.Arrays;\n" + 
+			"import java.util.HashSet;\n" + 
+			"import java.util.Set;\n" + 
+			"\n" + 
+			"public class Main {\n" + 
+			"\n" + 
+			"	public static void main(String[] args) {\n" +
+			"		// gives compile error in Neon\n" + 
+			"		// was warning \"unchecked\" in Mars\n" + 
+			"		Set<String> genericSet = new HashSet<>(oldApiReturningUntypedSet());\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n" + 
+			"	private static Set oldApiReturningUntypedSet() {\n" + 
+			"		HashSet set = new HashSet();\n" + 
+			"		set.add(\"one\");\n" + 
+			"		return set;\n" + 
+			"	}\n" + 
+			"\n" + 
+			"}\n"
+		});
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index a7ac6a8..08c699a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -575,7 +575,7 @@ public MethodBinding inferConstructorOfElidedParameterizedType(final Scope scope
 		if (constructorTypeArguments.length > 0)
 			System.arraycopy(((ParameterizedGenericMethodBinding)factory).typeArguments, sfmb.typeVariables().length - constructorTypeArguments.length , 
 												constructorTypeArguments, 0, constructorTypeArguments.length);
-		MethodBinding constructor = sfmb.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments, constructorTypeArguments);
+		MethodBinding constructor = sfmb.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments, constructorTypeArguments, genericFactory.inferredWithUncheckedConversion);
 		if (constructor instanceof ParameterizedGenericMethodBinding && scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
 			// force an inference context to be established for nested poly allocations (to be able to transfer b2), but avoid tunneling through overload resolution. We know this is the MSMB.
 			if (this.expressionContext == INVOCATION_CONTEXT && this.typeExpected == null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index e55dec8..3ea56bb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -542,6 +542,9 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		this.modifiers = originalMethod.modifiers;
 		this.selector = originalMethod.selector;
 		this.declaringClass = originalMethod.declaringClass;
+		if (inferredWithUncheckConversion && originalMethod.isConstructor() && this.declaringClass.isParameterizedType()) {
+			this.declaringClass = (ReferenceBinding) environment.convertToRawType(this.declaringClass.erasure(), false); // for diamond invocations
+		}
 	    this.typeVariables = Binding.NO_TYPE_VARIABLES;
 	    this.typeArguments = typeArguments;
 	    this.isRaw = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
index 38ee5be..7183878 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2014 GK Software AG.
+ * Copyright (c) 2014, 2016 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -36,13 +36,14 @@ public class SyntheticFactoryMethodBinding extends MethodBinding {
 	/** Apply the given type arguments on the (declaring class of the) actual constructor being represented by this factory method and
 	    if method type arguments is not empty materialize the parameterized generic constructor 
 	*/
-	public ParameterizedMethodBinding applyTypeArgumentsOnConstructor(TypeBinding[] typeArguments, TypeBinding[] constructorTypeArguments) {
+	public ParameterizedMethodBinding applyTypeArgumentsOnConstructor(TypeBinding[] typeArguments, TypeBinding[] constructorTypeArguments, boolean inferredWithUncheckedConversion) {
 		ReferenceBinding parameterizedType = this.environment.createParameterizedType(this.declaringClass, typeArguments,
 																						this.enclosingType);
 		for (MethodBinding parameterizedMethod : parameterizedType.methods()) {
 			if (parameterizedMethod.original() == this.staticFactoryFor)
-				return constructorTypeArguments.length > 0 ? this.environment.createParameterizedGenericMethod(parameterizedMethod, constructorTypeArguments) :
-													         (ParameterizedMethodBinding) parameterizedMethod;
+				return (constructorTypeArguments.length > 0 || inferredWithUncheckedConversion)
+						? this.environment.createParameterizedGenericMethod(parameterizedMethod, constructorTypeArguments, inferredWithUncheckedConversion, false)
+						: (ParameterizedMethodBinding) parameterizedMethod;
 			if (parameterizedMethod instanceof ProblemMethodBinding) {
 				MethodBinding closestMatch = ((ProblemMethodBinding)parameterizedMethod).closestMatch;
 				if (closestMatch instanceof ParameterizedMethodBinding && closestMatch.original() == this.staticFactoryFor)
