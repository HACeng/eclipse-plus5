commit d85ef445439a7932d1fe7c7dafa9bf16e2d2dd51
Author: David Audel <daudel>
Date:   Tue Jan 17 18:44:30 2006 +0000

    HEAD - Robust AST - bug 42253

3478	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
1	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
2	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
2	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
15	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
600	56	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
186	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
65	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
445	216	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
30	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
7	17	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
11	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
14	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
81	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
8	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
2	2	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
16	3	org.eclipse.jdt.core/grammar/java_1_5.g
7	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
2	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
6	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
new file mode 100644
index 0000000..7300ac9
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
@@ -0,0 +1,3478 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2004 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.parser;
+
+import java.util.Locale;
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
+import org.eclipse.jdt.core.tests.util.Util;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+
+public class StatementRecoveryTest extends AbstractCompilerTest {
+	public static final boolean ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY = false;
+	
+	public static boolean optimizeStringLiterals = false;
+	public static long sourceLevel = ClassFileConstants.JDK1_3; //$NON-NLS-1$
+	
+static {
+//	TESTS_NAMES = new String[] { "test0037"};
+//	TESTS_RANGE = new int[] {10, 20};
+}
+public static Test suite() {
+	return buildTestSuite(StatementRecoveryTest.class);
+}
+public StatementRecoveryTest(String testName){
+	super(testName);
+}
+protected Map getCompilerOptions() {
+	Map options = super.getCompilerOptions();
+	
+	options.put(CompilerOptions.OPTION_StatementsRecovery, CompilerOptions.ENABLED); //TODO temporary option
+	
+	return options;
+}
+public void checkParse(
+	char[] source, 
+	String expectedDietUnitToString,
+	String expectedDietWithStatementRecoveryUnitToString,
+	String expectedDietPlusBodyUnitToString,	
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString,	
+	String expectedFullUnitToString,
+	String expectedFullWithStatementRecoveryUnitToString,
+	String testName) {
+
+	/* using regular parser in DIET mode */
+	if(!ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY){
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+		parser.setStatementsRecovery(false);
+		
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.dietParse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedDietUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit diet structure" + testName,
+			expectedDietUnitToString,
+			computedUnitToString);
+	}
+	/* using regular parser in DIET mode and statementRecoveryEnabled */
+	if(!ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY){
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.dietParse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedDietWithStatementRecoveryUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit diet structure with statement recovery enabled" + testName,
+			expectedDietWithStatementRecoveryUnitToString,
+			computedUnitToString);
+	}
+	/* using regular parser in DIET mode + getMethodBodies */
+	if(!ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY){
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+		parser.setStatementsRecovery(false);
+
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.dietParse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedDietUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit diet structure" + testName,
+			expectedDietUnitToString,
+			computedUnitToString);
+		if (computedUnit.types != null) {
+			for (int i = computedUnit.types.length; --i >= 0;){
+				computedUnit.types[i].parseMethod(parser, computedUnit);
+			}
+		}
+		computedUnitToString = computedUnit.toString();
+		if (!expectedDietPlusBodyUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		
+		assertEquals(
+			"Invalid unit diet+body structure" + testName,
+			expectedDietPlusBodyUnitToString,
+			computedUnitToString);
+	}
+	/* using regular parser in DIET mode + getMethodBodies and statementRecoveryEnabled */
+	{
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.dietParse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedDietWithStatementRecoveryUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit diet structure" + testName,
+			expectedDietWithStatementRecoveryUnitToString,
+			computedUnitToString);
+		if (computedUnit.types != null) {
+			for (int i = computedUnit.types.length; --i >= 0;){
+				computedUnit.types[i].parseMethod(parser, computedUnit);
+			}
+		}
+		computedUnitToString = computedUnit.toString();
+		if (!expectedDietPlusBodyWithStatementRecoveryUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		
+		assertEquals(
+			"Invalid unit diet+body structure with statement recovery enabled" + testName,
+			expectedDietPlusBodyWithStatementRecoveryUnitToString,
+			computedUnitToString);
+	}
+	/* using regular parser in FULL mode */
+	if(!ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY){
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+		parser.setStatementsRecovery(false);
+
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.parse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedFullUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit full structure" + testName,
+			expectedFullUnitToString,
+			computedUnitToString);
+
+	}
+	/* using regular parser in FULL mode and statementRecoveryEnabled */
+	if(!ONLY_DIET_PLUS_BODY_WITH_STATEMENT_RECOVERY){
+		Parser parser = 
+			new Parser(
+				new ProblemReporter(
+					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
+					new CompilerOptions(getCompilerOptions()), 
+					new DefaultProblemFactory(Locale.getDefault())),
+				optimizeStringLiterals);
+
+		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
+		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
+		
+		CompilationUnitDeclaration computedUnit = parser.parse(sourceUnit, compilationResult);
+		String computedUnitToString = computedUnit.toString();
+		if (!expectedFullWithStatementRecoveryUnitToString.equals(computedUnitToString)){
+			System.out.println(Util.displayString(computedUnitToString));
+		}
+		assertEquals(
+			"Invalid unit full structure with statement recovery enabled" + testName,
+			expectedFullWithStatementRecoveryUnitToString,
+			computedUnitToString);
+
+	}
+}
+
+public void test0001() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		expectedDietPlusBodyUnitToString;
+	
+	String expectedFullUnitToString =
+		expectedDietPlusBodyUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0002() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #                    					\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0003() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    #                    					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0004() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #                    					\n"
+			+ "    System.out.println();					\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0005() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    System.out.println();					\n"
+			+ "    #                    					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0006() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    System.out.println();					\n"
+			+ "    #                    					\n"
+			+ "    System.out.println();					\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0007() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #                    					\n"
+			+ "    System.out.println();					\n"
+			+ "    if(true) {								\n"
+			+ "      System.out.println();					\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0008() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    if(true) {								\n"
+			+ "      System.out.println();					\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #                    					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0009() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    if(true) {								\n"
+			+ "      System.out.println();					\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #                    					\n"
+			+ "    System.out.println();					\n"
+			+ "    if(true) {								\n"
+			+ "      System.out.println();					\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0010() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {}							\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietPlusBodyUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietPlusBodyUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0011() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {}							\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0012() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {}							\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0013() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {}							\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Y {								\n"
+			+ "      void foo() {}							\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0014() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0015() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0016() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0017() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0018() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0019() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0020() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0021() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {}							\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietPlusBodyUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietPlusBodyUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0022() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {}							\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0023() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void bar() {}							\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void bar() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0024() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void bar() {}							\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void bar() {}							\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void bar() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void bar() {\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0025() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0026() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0027() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0028() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0029() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0030() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0031() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"        System.out.println();\n" + 
+		"        if (true)\n" + 
+		"            {\n" + 
+		"              System.out.println();\n" + 
+		"            }\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0032() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    System.out.println();					\n"
+			+ "    bar(new Object() {						\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "        #									\n"
+			+ "        System.out.println();				\n"
+			+ "        if(true) {							\n"
+			+ "          System.out.println();				\n"
+			+ "        }									\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    });										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    bar(new Object() {\n" + 
+		"  () {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"    System.out.println();\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          System.out.println();\n" + 
+		"        }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"});\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0033() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    class Z {								\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    class Z {\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0034() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    #										\n"
+			+ "    new Object() {							\n"
+			+ "      void foo() {							\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    };										\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    new Object() {\n" + 
+		"      () {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"      void foo() {\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"    };\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0035() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    bar(\\u0029								\n"
+			+ "  }											\n"
+			+ "}											\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    bar();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0036() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    if(true) {								\n"
+			+ "      foo();									\n"
+			+ "    }										\n"
+			+ "    for(;									\n"
+			+ "    if(true) {								\n"
+			+ "      foo();									\n"
+			+ "    }										\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          foo();\n" + 
+		"        }\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0037() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    if() {									\n"
+			+ "      foo();									\n"
+			+ "    }										\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    if ()\n" + 
+		"        {\n" + 
+		"          foo();\n" + 
+		"        }\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0038() {
+	String s = 
+		"package p1;										\n"+
+			"public class A {									\n"+
+			"	public interface B {							\n"+
+			"		public abstract void aMethod (int A);		\n"+
+			"		public interface C {						\n"+
+			"			public abstract void anotherMethod(int A);\n"+
+			"		}											\n"+
+			"	}												\n"+
+			"	public class aClass implements B, B.C {			\n"+
+			"		public void aMethod (int A) {				\n"+
+			"			public void anotherMethod(int A) {};	\n"+
+			"		}											\n"+
+			"	}												\n"+
+			"   	public static void main (String argv[]) {	\n"+
+			"		System.out.println(\"SUCCESS\");			\n"+
+			"	}												\n"+
+			"}";
+
+	String expectedDietUnitToString = 
+		"package p1;\n" + 
+		"public class A {\n" + 
+		"  public interface B {\n" + 
+		"    public interface C {\n" + 
+		"      public abstract void anotherMethod(int A);\n" + 
+		"    }\n" + 
+		"    public abstract void aMethod(int A);\n" + 
+		"  }\n" + 
+		"  public class aClass implements B, B.C {\n" + 
+		"    public aClass() {\n" + 
+		"    }\n" + 
+		"    public void aMethod(int A) {\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"  public A() {\n" + 
+		"  }\n" + 
+		"  public static void main(String[] argv) {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package p1;\n" + 
+		"public class A {\n" + 
+		"  public interface B {\n" + 
+		"    public interface C {\n" + 
+		"      public abstract void anotherMethod(int A);\n" + 
+		"    }\n" + 
+		"    public abstract void aMethod(int A);\n" + 
+		"  }\n" + 
+		"  public class aClass implements B, B.C {\n" + 
+		"    public aClass() {\n" + 
+		"      super();\n" + 
+		"    }\n" + 
+		"    public void aMethod(int A) {\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] argv) {\n" + 
+		"    System.out.println(\"SUCCESS\");\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package p1;\n" + 
+		"public class A {\n" + 
+		"  public interface B {\n" + 
+		"    public interface C {\n" + 
+		"      public abstract void anotherMethod(int A);\n" + 
+		"    }\n" + 
+		"    public abstract void aMethod(int A);\n" + 
+		"  }\n" + 
+		"  public class aClass implements B, B.C {\n" + 
+		"    public aClass() {\n" + 
+		"      super();\n" + 
+		"    }\n" + 
+		"    public void aMethod(int A) {\n" + 
+		"      public void anotherMethod;\n" + 
+		"      int A;\n" + 
+		"      ;\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] argv) {\n" + 
+		"    System.out.println(\"SUCCESS\");\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		"package p1;\n" + 
+		"public class A {\n" + 
+		"  public interface B {\n" + 
+		"    public interface C {\n" + 
+		"      public abstract void anotherMethod(int A);\n" + 
+		"    }\n" + 
+		"    public abstract void aMethod(int A);\n" + 
+		"  }\n" + 
+		"  public class aClass implements B, B.C {\n" + 
+		"    public aClass() {\n" + 
+		"    }\n" + 
+		"    public void aMethod(int A) {\n" + 
+		"    }\n" + 
+		"    public void anotherMethod(int A) {\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public A() {\n" + 
+		"  }\n" + 
+		"  public static void main(String[] argv) {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0039() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  {											\n"
+			+ "    System.out.println();					\n"
+			+ "    foo()									\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"    System.out.println();\n" + 
+		"    foo();\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0040() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  {											\n"
+			+ "    System.out.println();					\n"
+			+ "    class Y {								\n"
+			+ "      {										\n"
+			+ "        System.out.println();				\n"
+			+ "        foo()								\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"    System.out.println();\n" + 
+		"    class Y {\n" + 
+		"      {\n" + 
+		"        System.out.println();\n" + 
+		"        foo();\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+public void test0041() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  {											\n"
+			+ "    System.out.println();					\n"
+			+ "    class Y {								\n"
+			+ "      {										\n"
+			+ "        System.out.println();				\n"
+			+ "        foo()								\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    class Z {								\n"
+			+ "      {										\n"
+			+ "        System.out.println();				\n"
+			+ "        foo()								\n"
+			+ "        System.out.println();				\n"
+			+ "      }										\n"
+			+ "    }										\n"
+			+ "    System.out.println();					\n"
+			+ "    foo()									\n"
+			+ "    System.out.println();					\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  {\n" + 
+		"    System.out.println();\n" + 
+		"    class Y {\n" + 
+		"      {\n" + 
+		"        System.out.println();\n" + 
+		"        foo();\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"    class Z {\n" + 
+		"      {\n" + 
+		"        System.out.println();\n" + 
+		"        foo();\n" + 
+		"        System.out.println();\n" + 
+		"      }\n" + 
+		"      Z() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    System.out.println();\n" + 
+		"    foo();\n" + 
+		"    System.out.println();\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
index 0d67cb3..91682bb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
@@ -47,6 +47,7 @@ public class TestAll extends TestCase {
 		testClasses.add(GenericDietRecoveryTest.class);
 		testClasses.add(EnumDietRecoveryTest.class);
 		testClasses.add(AnnotationDietRecoveryTest.class);
+		testClasses.add(StatementRecoveryTest.class);
 		
 		/* source element parser tests */
 		testClasses.add(SourceElementParserTest.class);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
index c42a532..ad457cb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
@@ -129,6 +129,7 @@ public class AbstractComparableTest extends AbstractRegressionTest {
 		options.put(CompilerOptions.OPTION_ReportMissingDeprecatedAnnotation, CompilerOptions.WARNING);
 		options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.WARNING);
 		options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.WARNING);
+		options.put(CompilerOptions.OPTION_StatementsRecovery, CompilerOptions.DISABLED); //TODO temporary option
 		return options;
 	}
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
index 39673eb..62c2dab 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
@@ -207,6 +207,7 @@ public abstract class AbstractRegressionTest extends AbstractCompilerTest implem
 		defaultOptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.WARNING);
 		defaultOptions.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.PRESERVE);
 		defaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryElse, CompilerOptions.WARNING );
+		defaultOptions.put(CompilerOptions.OPTION_StatementsRecovery, CompilerOptions.DISABLED); //TODO temporary option
 		return defaultOptions;
 	}
 	protected String[] getDefaultClassPaths() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
index f4ca863..e058fa6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
@@ -216,6 +216,7 @@ public class AbstractCompilerTest extends TestCase {
 			options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
 			options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);
 		}
+		options.put(CompilerOptions.OPTION_StatementsRecovery, CompilerOptions.DISABLED); //TODO temporary option
 		return options;
 	}
 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 9b521a0..051ac62 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -2795,6 +2795,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		// set the non-externally configurable options.
 		this.compilerOptions.verbose = this.verbose;
 		this.compilerOptions.produceReferenceInfo = this.produceRefInfo;
+		this.compilerOptions.performStatementsRecovery = false;
 		try {
 			this.logger.startLoggingSources();
 			batchCompiler.compile(getCompilationUnits());
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index fd06777..6eca6b3 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -58,6 +58,8 @@ What's new in this drop</h2>
      extra attribute. The possible values for this attribute are <code>"true"</code> or <code>"false"</code>. 
 	 When not present, <code>"false"</code> is assumed. If the value of this attribute is <code>"true"</code>, 
 	 the classpath entry is optional. </li>
+<li>Added support for statement recovery in Parser<br>
+	 Currently this new behavior is incomplete (mapping non-terminals -> terminals) and disabled. The option JavaCore.COMPILER_STATEMENTS_RECOVERY must be set to ENABLED to use it (It's a temporary option).</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index f118b9f..1d9c747 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -75,6 +75,8 @@ public abstract class AssistParser extends Parser {
 public AssistParser(ProblemReporter problemReporter) {
 	super(problemReporter, true);
 	this.javadocParser.checkDocComment = false;
+	
+	this.setStatementsRecovery(false);
 }
 public abstract char[] assistIdentifier();
 public int bodyEnd(AbstractMethodDeclaration method){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java
index f98a8d2..f77c3ba 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java
@@ -42,6 +42,7 @@ import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScannerData;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 
 public class CompilationResult {
@@ -60,6 +61,7 @@ public class CompilationResult {
 	public boolean hasAnnotations = false;
 
 	public int lineSeparatorPositions[];
+	public RecoveryScannerData recoveryScannerData;
 	public Map compiledTypes = new Hashtable(11);
 	public int unitIndex, totalUnitsKnown;
 	public boolean hasBeenAccepted = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index fd20550..33e52fe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -130,6 +130,9 @@ public class CompilationUnitDeclaration
 				localType.enclosingCase = null;
 			}
 		}
+		
+		compilationResult.recoveryScannerData = null; // recovery is already done
+		
 		ClassFile[] classFiles = compilationResult.getClassFiles();
 		for (int i = 0, max = classFiles.length; i < max; i++) {
 			// clear the classFile back pointer to the bindings
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 6f3540d..084118e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -178,6 +178,8 @@ public abstract class Expression extends Statement {
 	
 	public Constant constant;
 	
+	public int statementEnd = -1;
+	
 	//Some expression may not be used - from a java semantic point
 	//of view only - as statements. Other may. In order to avoid the creation
 	//of wrappers around expression in order to tune them as expression
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
index 91f16c5..329489c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
@@ -329,7 +329,7 @@ public class ForeachStatement extends Statement {
 		scope = new BlockScope(upperScope);
 		this.elementVariable.resolve(scope); // collection expression can see itemVariable
 		TypeBinding elementType = this.elementVariable.type.resolvedType;
-		TypeBinding collectionType = this.collection.resolveType(scope);
+		TypeBinding collectionType = this.collection == null ? null : this.collection.resolveType(scope);
 		boolean hasError = elementType == null || collectionType == null;
 
 		if (!hasError) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 98fa39e..ddca4e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -113,6 +113,9 @@ public class CompilerOptions {
 	/* should surface ??? */
 	public static final String OPTION_PrivateConstructorAccess = "org.eclipse.jdt.core.compiler.codegen.constructorAccessEmulation"; //$NON-NLS-1$
 
+	//TODO temporary option
+	public static final String OPTION_StatementsRecovery = "org.eclipse.jdt.core.compiler.statementsRecovery"; //$NON-NLS-1$
+
 	/**
 	 * Possible values for configurable options
 	 */
@@ -187,7 +190,7 @@ public class CompilerOptions {
 	public static final long RawTypeReference = ASTNode.Bit46L;
 	public static final long UnusedLabel = ASTNode.Bit47L;
 	public static final long ParameterAssignment = ASTNode.Bit48L;
-
+	
 	// Default severity level for handlers
 	public long errorThreshold = 0;
 		
@@ -296,9 +299,12 @@ public class CompilerOptions {
 	// treat optional error as fatal or just like warning?
 	public boolean treatOptionalErrorAsFatal = true;
 	
+	// parser perform statements recovery 
+	public boolean performStatementsRecovery = true;
+	
 	// store annotations
 	public boolean storeAnnotations = false;
-
+	
 	/** 
 	 * Initializing the compiler options with defaults
 	 */
@@ -726,6 +732,13 @@ public class CompilerOptions {
 				this.reportMissingJavadocCommentsOverriding = false;
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_StatementsRecovery)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.performStatementsRecovery = true;
+			} else if (DISABLED.equals(optionValue)) {
+				this.performStatementsRecovery = false;
+			}
+		}
 	}
 
 	public String toString() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 1ca4799..d40347c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -22,14 +22,18 @@ import java.util.ResourceBundle;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser;
@@ -76,6 +80,11 @@ public class Parser implements  ParserBasicInformation, TerminalTokens, Operator
 	
 	public static byte rhs[] = null;
 	
+	public static int[] reverse_index = null;
+	public static char[] recovery_templates_index = null;
+	public static char[] recovery_templates = null;
+	public static char[] statements_recovery_filter = null;
+	
 	public static long rules_compliance[] =  null;
 	
 	public static final int RoundBracket = 0;
@@ -171,6 +180,17 @@ public class Parser implements  ParserBasicInformation, TerminalTokens, Operator
 	public boolean reportOnlyOneSyntaxError = false;
 	public boolean reportSyntaxErrorIsRequired = true;
 	protected boolean restartRecovery;
+	
+	// statement recovery
+//	public boolean statementRecoveryEnabled = true;
+	protected boolean methodRecoveryActivated = false;
+	protected boolean statementRecoveryActivated = false;
+	protected TypeDeclaration[] recoveredTypes;
+	protected int recoveredTypePtr;
+	protected int nextTypeStart;
+	
+	public RecoveryScanner recoveryScanner;
+	
 	//scanner token 
 	public Scanner scanner;
 	protected int[] stack = new int[StackIncrement];
@@ -298,6 +318,76 @@ private static void buildFileForReadableName(
 	Collections.sort(entries);
 	buildFile(file, entries);
 }
+private static void buildFilesForRecoveryTemplates(
+	String indexFilename,
+	String templatesFilename,
+	char[] newTerminalIndex,
+	char[] newNonTerminalIndex,
+	String[] newName,
+	char[] newLhs,
+	String[] tokens) throws IOException {
+	
+	int[] newReverse = computeReverseTable(newTerminalIndex, newNonTerminalIndex, newName);
+	
+	char[] newRecoveyTemplatesIndex = new char[newNonTerminalIndex.length];
+	char[] newRecoveyTemplates = new char[newNonTerminalIndex.length];
+	int newRecoveyTemplatesPtr = 0;
+	
+	for (int i = 0; i < tokens.length; i = i + 3) {
+		if("3".equals(tokens[i])) { //$NON-NLS-1$
+			int length = newRecoveyTemplates.length;
+			if(length == newRecoveyTemplatesPtr + 1) {
+				System.arraycopy(newRecoveyTemplates, 0, newRecoveyTemplates = new char[length * 2], 0, length);
+			}
+			newRecoveyTemplates[newRecoveyTemplatesPtr++] = 0;
+			
+			int index = newLhs[Integer.parseInt(tokens[i + 1])];
+			
+			newRecoveyTemplatesIndex[index] = (char)newRecoveyTemplatesPtr;
+			
+			String token = tokens[i + 2].trim();
+			java.util.StringTokenizer st = new java.util.StringTokenizer(new String(token), " ");  //$NON-NLS-1$
+			String[] terminalNames = new String[st.countTokens()];
+			int t = 0;
+			while (st.hasMoreTokens()) {
+				terminalNames[t++] = st.nextToken();
+			}
+			
+			for (int j = 0; j < terminalNames.length; j++) {
+				int symbol = getSymbol(terminalNames[j], newName, newReverse);
+				if(symbol > -1) {
+					length = newRecoveyTemplates.length;
+					if(length == newRecoveyTemplatesPtr + 1) {
+						System.arraycopy(newRecoveyTemplates, 0, newRecoveyTemplates = new char[length * 2], 0, length);
+					}
+					newRecoveyTemplates[newRecoveyTemplatesPtr++] = (char)symbol;
+				}
+			}
+		}
+	}
+	newRecoveyTemplates[newRecoveyTemplatesPtr++] = 0;
+	System.arraycopy(newRecoveyTemplates, 0, newRecoveyTemplates = new char[newRecoveyTemplatesPtr], 0, newRecoveyTemplatesPtr);
+	
+	buildFileForTable(indexFilename, newRecoveyTemplatesIndex);
+	buildFileForTable(templatesFilename, newRecoveyTemplates);
+}
+private static void buildFilesForStatementsRecoveryFilter(
+		String filename,
+		char[] newNonTerminalIndex,
+		char[] newLhs,
+		String[] tokens) throws IOException {
+		
+		char[] newStatementsRecoveryFilter = new char[newNonTerminalIndex.length];
+		
+		for (int i = 0; i < tokens.length; i = i + 3) {
+			if("4".equals(tokens[i])) { //$NON-NLS-1$
+				int index = newLhs[Integer.parseInt(tokens[i + 1])];
+				
+				newStatementsRecoveryFilter[index] = 1;
+			}
+		}
+		buildFileForTable(filename, newStatementsRecoveryFilter);
+	}
 private static void buildFileForCompliance(
 		String file,
 		int length,
@@ -450,7 +540,7 @@ public final static void buildFilesFromLPG(String dataFilename, String dataFilen
 	buildFileOfIntFor(prefix + (++i) + ".rsc", "asr", tokens); //$NON-NLS-2$ //$NON-NLS-1$
 	buildFileOfIntFor(prefix + (++i) + ".rsc", "nasb", tokens); //$NON-NLS-2$ //$NON-NLS-1$
 	buildFileOfIntFor(prefix + (++i) + ".rsc", "nasr", tokens); //$NON-NLS-2$ //$NON-NLS-1$
-	buildFileOfIntFor(prefix + (++i) + ".rsc", "terminal_index", tokens); //$NON-NLS-2$ //$NON-NLS-1$
+	char[] newTerminalIndex = buildFileOfIntFor(prefix + (++i) + ".rsc", "terminal_index", tokens); //$NON-NLS-2$ //$NON-NLS-1$
 	char[] newNonTerminalIndex = buildFileOfIntFor(prefix + (++i) + ".rsc", "non_terminal_index", tokens); //$NON-NLS-1$ //$NON-NLS-2$
 	buildFileOfIntFor(prefix + (++i) + ".rsc", "term_action", tokens); //$NON-NLS-2$ //$NON-NLS-1$
 	
@@ -475,7 +565,7 @@ public final static void buildFilesFromLPG(String dataFilename, String dataFilen
 		System.out.println(Messages.parser_incorrectPath); 
 		return;
 	}
-	st = new java.util.StringTokenizer(new String(contents), "\t\n\r=#");  //$NON-NLS-1$
+	st = new java.util.StringTokenizer(new String(contents), "\t\n\r#");  //$NON-NLS-1$
 	tokens = new String[st.countTokens()];
 	j = 0;
 	while (st.hasMoreTokens()) {
@@ -485,6 +575,22 @@ public final static void buildFilesFromLPG(String dataFilename, String dataFilen
 	buildFileForCompliance(prefix + (++i) + ".rsc", newRhs.length, tokens);//$NON-NLS-1$
 	buildFileForReadableName(READABLE_NAMES_FILE+".properties", newLhs, newNonTerminalIndex, newName, tokens);//$NON-NLS-1$
 	
+	buildFilesForRecoveryTemplates(
+			prefix + (++i) + ".rsc", //$NON-NLS-1$
+			prefix + (++i) + ".rsc", //$NON-NLS-1$
+			newTerminalIndex,
+			newNonTerminalIndex,
+			newName,
+			newLhs,
+			tokens);
+	
+	buildFilesForStatementsRecoveryFilter(
+			prefix + (++i) + ".rsc", //$NON-NLS-1$
+			newNonTerminalIndex,
+			newLhs,
+			tokens);
+
+	
 	System.out.println(Messages.parser_moveFiles); 
 }
 public static int in_symbol(int state) {
@@ -526,6 +632,13 @@ public final static void initTables() throws java.io.IOException {
 	
 	readableName = readReadableNameTable(READABLE_NAMES_FILE_NAME);
 	
+	reverse_index = computeReverseTable(terminal_index, non_terminal_index, name);
+	
+	recovery_templates_index = readTable(prefix + (++i) + ".rsc"); //$NON-NLS-1$
+	recovery_templates = readTable(prefix + (++i) + ".rsc"); //$NON-NLS-1$
+	
+	statements_recovery_filter = readTable(prefix + (++i) + ".rsc"); //$NON-NLS-1$
+	
 	base_action = lhs;
 }
 public static int nasi(int state) {
@@ -537,6 +650,36 @@ public static int ntAction(int state, int sym) {
 protected static int original_state(int state) {
 	return -base_check(state);
 }
+protected static int[] computeReverseTable(char[] newTerminalIndex, char[] newNonTerminalIndex, String[] newName) {
+	int[] newReverseTable = new int[newName.length];
+	for (int j = 0; j < newName.length; j++) {
+		found : {
+			for (int k = 0; k < newTerminalIndex.length; k++) {
+				if(newTerminalIndex[k] == j) {
+					newReverseTable[j] = k;
+					break found;
+				}
+			}
+			for (int k = 0; k < newNonTerminalIndex.length; k++) {
+				if(newNonTerminalIndex[k] == j) {
+					newReverseTable[j] = -k;
+					break found;
+				}
+			}
+		}
+	}
+	return newReverseTable;
+}
+
+private static int getSymbol(String terminalName, String[] newName, int[] newReverse) {
+	for (int j = 0; j < newName.length; j++) {
+		if(terminalName.equals(newName[j])) {
+			return newReverse[j];
+		}
+	}
+	return -1;
+}
+
 protected static byte[] readByteTable(String filename) throws java.io.IOException {
 
 	//files are located at Parser.class directory
@@ -703,6 +846,8 @@ public Parser(ProblemReporter problemReporter, boolean optimizeStringLiterals) {
 	
 	// javadoc support
 	this.javadocParser = new JavadocParser(this);	
+	
+//	this.statementRecoveryEnabled = this.options.performStatementsRecovery;
 }
 protected void annotationRecoveryCheckPoint(int start, int end) {
 	if(this.lastCheckPoint > start && this.lastCheckPoint < end) {
@@ -768,6 +913,9 @@ public RecoveredElement buildInitialRecoveryState(){
 		if (this.referenceContext instanceof AbstractMethodDeclaration){
 			element = new RecoveredMethod((AbstractMethodDeclaration) this.referenceContext, null, 0, this);
 			this.lastCheckPoint = ((AbstractMethodDeclaration) this.referenceContext).bodyStart;
+			if(this.statementRecoveryActivated) {
+				element = element.add(new Block(0), 0);
+			}
 		} else {
 			/* Initializer bodies are parsed in the context of the type declaration, we must thus search it inside */
 			if (this.referenceContext instanceof TypeDeclaration){
@@ -845,6 +993,29 @@ public RecoveredElement buildInitialRecoveryState(){
 			element = element.add(importRef, 0);
 			this.lastCheckPoint = importRef.declarationSourceEnd + 1;
 		}
+		if(this.statementRecoveryActivated) {
+			if(node instanceof Block) {
+				Block block = (Block) node;
+				element = element.add(block, 0);
+				this.lastCheckPoint = block.sourceEnd + 1;
+			} else if(node instanceof LocalDeclaration) {
+				LocalDeclaration statement = (LocalDeclaration) node;
+				element = element.add(statement, 0);
+				this.lastCheckPoint = statement.sourceEnd + 1;
+			} else if(node instanceof Expression) {
+				Expression statement = (Expression) node;
+				element = element.add(statement, 0);
+				if(statement.statementEnd != -1) {
+					this.lastCheckPoint = statement.statementEnd + 1;
+				} else {
+					this.lastCheckPoint = statement.sourceEnd + 1;
+				}
+			} else if(node instanceof Statement) {
+				Statement statement = (Statement) node;
+				element = element.add(statement, 0);
+				this.lastCheckPoint = statement.sourceEnd + 1;
+			}
+		}
 	}
 	return element;
 }
@@ -1133,7 +1304,8 @@ protected void consumeAnnotationTypeDeclarationHeaderName() {
 	annotationTypeDeclaration.javadoc = this.javadoc;
 	this.javadoc = null;	
 	pushOnAstStack(annotationTypeDeclaration);
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		this.problemReporter().invalidUsageOfAnnotationDeclarations(annotationTypeDeclaration);
 	}	
@@ -2421,7 +2593,7 @@ protected void consumeEmptyClassBodyDeclarationsopt() {
 protected void consumeEmptyClassMemberDeclaration() {
 	// ClassMemberDeclaration ::= ';'
 	pushOnAstLengthStack(0);
-	problemReporter().superfluousSemicolon(this.endPosition+1, this.endStatementPosition);
+	if(!this.statementRecoveryActivated) problemReporter().superfluousSemicolon(this.endPosition+1, this.endStatementPosition);
 	flushCommentsDefinedPriorTo(this.endStatementPosition);
 }
 protected void consumeEmptyMethodHeaderDefaultValue() {
@@ -2489,7 +2661,7 @@ protected void consumeEmptySwitchBlock() {
 protected void consumeEmptyTypeDeclaration() {
 	// TypeDeclaration ::= ';' 
 	pushOnAstLengthStack(0);
-	problemReporter().superfluousSemicolon(this.endPosition+1, this.endStatementPosition);
+	if(!this.statementRecoveryActivated) problemReporter().superfluousSemicolon(this.endPosition+1, this.endStatementPosition);
 	flushCommentsDefinedPriorTo(this.endStatementPosition);
 }
 protected void consumeEnhancedForStatementHeaderInit(boolean hasModifiers) {
@@ -2539,6 +2711,8 @@ protected void consumeEnhancedForStatementHeaderInit(boolean hasModifiers) {
 			localDeclaration,
 			this.intStack[this.intPtr--]); 
 	pushOnAstStack(iteratorForStatement);
+	
+	iteratorForStatement.sourceEnd = localDeclaration.declarationSourceEnd;
 }
 protected void consumeEnhancedForStatementHeader(){
 	// EnhancedForStatementHeader ::= EnhancedForStatementHeaderInit ':' Expression ')'
@@ -2547,7 +2721,10 @@ protected void consumeEnhancedForStatementHeader(){
 	this.expressionLengthPtr--;
 	final Expression collection = this.expressionStack[this.expressionPtr--];
 	statement.collection = collection;
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	statement.sourceEnd = this.rParenPos;
+	
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		this.problemReporter().invalidUsageOfForeachStatements(statement.elementVariable, collection);
 	}	
@@ -2986,7 +3163,8 @@ protected void consumeEnumHeaderName() {
 
 	this.listLength = 0; // will be updated when reading super-interfaces
 	
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		//TODO this code will be never run while 'enum' is an identifier in 1.3 scanner 
 		this.problemReporter().invalidUsageOfEnumDeclarations(enumDeclaration);
@@ -3146,7 +3324,9 @@ protected void consumeExplicitConstructorInvocationWithTypeArguments(int flag, i
 protected void consumeExpressionStatement() {
 	// ExpressionStatement ::= StatementExpression ';'
 	this.expressionLengthPtr--;
-	pushOnAstStack(this.expressionStack[this.expressionPtr--]);
+	Expression expression = this.expressionStack[this.expressionPtr--];
+	expression.statementEnd = this.endStatementPosition;
+	pushOnAstStack(expression);
 }
 protected void consumeFieldAccess(boolean isSuperAccess) {
 	// FieldAccess ::= Primary '.' 'Identifier'
@@ -3290,10 +3470,12 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 	this.listLength++; 	
 	
 	if(isVarArgs) {
-		if (options.sourceLevel < ClassFileConstants.JDK1_5 &&
+		if (!this.statementRecoveryActivated &&
+				options.sourceLevel < ClassFileConstants.JDK1_5 &&
 				this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 				this.problemReporter().invalidUsageOfVarargs(arg);
-		} else if (extendedDimensions > 0) {
+		} else if (!this.statementRecoveryActivated &&
+				extendedDimensions > 0) {
 			this.problemReporter().illegalExtendedDimensions(arg);
 		}
 	}
@@ -3570,7 +3752,7 @@ protected void consumeInternalCompilationUnitWithTypes() {
 protected void consumeInvalidAnnotationTypeDeclaration() {
 	// BlockStatement ::= AnnotationTypeDeclaration
 	TypeDeclaration typeDecl = (TypeDeclaration) this.astStack[this.astPtr];
-	problemReporter().illegalLocalTypeDeclaration(typeDecl);
+	if(!this.statementRecoveryActivated) problemReporter().illegalLocalTypeDeclaration(typeDecl);
 	// remove the ast node created in interface header
 	this.astPtr--;
 	pushOnAstLengthStack(-1);
@@ -3623,7 +3805,7 @@ protected void consumeInvalidInterfaceDeclaration() {
 	// BlockStatement ::= InvalidInterfaceDeclaration
 	//InterfaceDeclaration ::= Modifiersopt 'interface' 'Identifier' ExtendsInterfacesopt InterfaceHeader InterfaceBody
 	TypeDeclaration typeDecl = (TypeDeclaration) this.astStack[this.astPtr];
-	problemReporter().illegalLocalTypeDeclaration(typeDecl);
+	if(!this.statementRecoveryActivated) problemReporter().illegalLocalTypeDeclaration(typeDecl);
 	// remove the ast node created in interface header
 	this.astPtr--;
 	pushOnAstLengthStack(-1);
@@ -3632,7 +3814,7 @@ protected void consumeInvalidInterfaceDeclaration() {
 protected void consumeInvalidEnumDeclaration() {
 	// BlockStatement ::= EnumDeclaration
 	TypeDeclaration typeDecl = (TypeDeclaration) this.astStack[this.astPtr];
-	problemReporter().illegalLocalTypeDeclaration(typeDecl);
+	if(!this.statementRecoveryActivated) problemReporter().illegalLocalTypeDeclaration(typeDecl);
 	// remove the ast node created in interface header
 	this.astPtr--;
 	pushOnAstLengthStack(-1);
@@ -3668,7 +3850,7 @@ protected void consumeInvalidMethodDeclaration() {
 	md.declarationSourceEnd = flushCommentsDefinedPriorTo(this.endStatementPosition);
 
 	// report the problem and continue the parsing - narrowing the problem onto the method
-	problemReporter().abstractMethodNeedingNoBody(md);
+	if(!this.statementRecoveryActivated) problemReporter().abstractMethodNeedingNoBody(md);
 }
 protected void consumeLabel() {
 	// Do nothing
@@ -3728,7 +3910,8 @@ protected void consumeMarkerAnnotation() {
 	markerAnnotation = new MarkerAnnotation(typeReference, this.intStack[this.intPtr--]);
 	markerAnnotation.declarationSourceEnd = markerAnnotation.sourceEnd;
 	pushOnExpressionStack(markerAnnotation);
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		this.problemReporter().invalidUsageOfAnnotation(markerAnnotation);
 	}
@@ -4244,7 +4427,8 @@ protected void consumeNormalAnnotation() {
 		annotationRecoveryCheckPoint(normalAnnotation.sourceStart, normalAnnotation.declarationSourceEnd);
 	}
 	
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		this.problemReporter().invalidUsageOfAnnotation(normalAnnotation);
 	}
@@ -4261,7 +4445,8 @@ protected void consumeOnlySynchronized() {
 	this.expressionLengthPtr--;
 }
 protected void consumeOnlyTypeArguments() {
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		int length = this.genericsLengthStack[this.genericsLengthPtr];
 		this.problemReporter().invalidUsageOfTypeArguments(
@@ -6259,7 +6444,8 @@ protected void consumeSingleMemberAnnotation() {
 		annotationRecoveryCheckPoint(singleMemberAnnotation.sourceStart, singleMemberAnnotation.declarationSourceEnd);
 	}
 	
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		this.problemReporter().invalidUsageOfAnnotation(singleMemberAnnotation);
 	}
@@ -6291,7 +6477,8 @@ protected void consumeSingleStaticImportDeclarationName() {
 	//this.endPosition is just before the ;
 	impt.declarationSourceStart = this.intStack[this.intPtr--];
 
-	if(this.options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			this.options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		impt.modifiers = ClassFileConstants.AccDefault; // convert the static import reference to a non-static importe reference
 		this.problemReporter().invalidUsageOfStaticImports(impt);
@@ -6660,7 +6847,8 @@ protected void consumeStaticImportOnDemandDeclarationName() {
 	//this.endPosition is just before the ;
 	impt.declarationSourceStart = this.intStack[this.intPtr--];
 
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		impt.modifiers = ClassFileConstants.AccDefault; // convert the static import reference to a non-static importe reference
 		this.problemReporter().invalidUsageOfStaticImports(impt);
@@ -6762,12 +6950,12 @@ protected void consumeToken(int type) {
 			if (this.scanner.useAssertAsAnIndentifier  &&
 					this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 				long positions = this.identifierPositionStack[this.identifierPtr];
-				problemReporter().useAssertAsAnIdentifier((int) (positions >>> 32), (int) positions);
+				if(!this.statementRecoveryActivated) problemReporter().useAssertAsAnIdentifier((int) (positions >>> 32), (int) positions);
 			}
 			if (this.scanner.useEnumAsAnIndentifier  &&
 					this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 				long positions = this.identifierPositionStack[this.identifierPtr];
-				problemReporter().useEnumAsAnIdentifier((int) (positions >>> 32), (int) positions);
+				if(!this.statementRecoveryActivated) problemReporter().useEnumAsAnIdentifier((int) (positions >>> 32), (int) positions);
 			}
 			break;
 		case TokenNameinterface :
@@ -7091,7 +7279,8 @@ protected void consumeTypeArguments() {
 	concatGenericsLists();
 	intPtr--;
 
-	if(options.sourceLevel < ClassFileConstants.JDK1_5 &&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		int length = this.genericsLengthStack[this.genericsLengthPtr];
 		this.problemReporter().invalidUsageOfTypeArguments(
@@ -7202,7 +7391,8 @@ protected void consumeTypeParameters() {
 	}
 	
 	
-	if(options.sourceLevel < ClassFileConstants.JDK1_5&&
+	if(!this.statementRecoveryActivated &&
+			options.sourceLevel < ClassFileConstants.JDK1_5&&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 		int length = this.genericsLengthStack[this.genericsLengthPtr];
 		this.problemReporter().invalidUsageOfTypeParameters(
@@ -7298,7 +7488,7 @@ protected void consumeUnaryExpression(int op, boolean post) {
 		if (!post) {
 			this.intPtr--;
 		}
-		problemReporter().invalidUnaryExpression(leftHandSide);
+		if(!this.statementRecoveryActivated) problemReporter().invalidUnaryExpression(leftHandSide);
 	}
 }
 protected void consumeVariableDeclarators() {
@@ -7678,14 +7868,18 @@ protected CompilationUnitDeclaration endParse(int act) {
 
 	this.lastAct = act;
 
-	if (this.currentElement != null){
-		this.currentElement.topElement().updateParseTree();
+	if(this.statementRecoveryActivated) {
+		RecoveredElement recoveredElement = this.buildInitialRecoveryState();
+		recoveredElement.topElement().updateParseTree();
+		if(this.hasError) this.resetStacks();
+	} else if (this.currentElement != null){
 		if (VERBOSE_RECOVERY){
 			System.out.print(Messages.parser_syntaxRecovery); 
 			System.out.println("--------------------------");		 //$NON-NLS-1$
 			System.out.println(this.compilationUnit);		
 			System.out.println("----------------------------------"); //$NON-NLS-1$
 		}
+		this.currentElement.topElement().updateParseTree();
 	} else {
 		if (this.diet & VERBOSE_RECOVERY){
 			System.out.print(Messages.parser_regularParse); 
@@ -7696,7 +7890,7 @@ protected CompilationUnitDeclaration endParse(int act) {
 	}
 	persistLineSeparatorPositions();
 	for (int i = 0; i < this.scanner.foundTaskCount; i++){
-		problemReporter().task(
+		if(!this.statementRecoveryActivated) problemReporter().task(
 			new String(this.scanner.foundTaskTags[i]), 
 			new String(this.scanner.foundTaskMessages[i]),
 			this.scanner.foundTaskPriorities[i] == null ? null : new String(this.scanner.foundTaskPriorities[i]), 
@@ -8187,7 +8381,7 @@ protected void ignoreExpressionAssignment() {
 	ArrayInitializer arrayInitializer = (ArrayInitializer) this.expressionStack[this.expressionPtr--];
 	this.expressionLengthPtr -- ;
 	// report a syntax error and abort parsing
-	problemReporter().arrayConstantsOnlyInArrayInitializers(arrayInitializer.sourceStart, arrayInitializer.sourceEnd); 	
+	if(!this.statementRecoveryActivated) problemReporter().arrayConstantsOnlyInArrayInitializers(arrayInitializer.sourceStart, arrayInitializer.sourceEnd); 	
 }
 public void initialize() {
 	this.initialize(false);
@@ -8281,6 +8475,51 @@ public void jumpOverMethodBody() {
 	if (this.diet && (this.dietInt == 0))
 		this.scanner.diet = true;
 }
+private void jumpOverType(){
+	if (this.recoveredTypes != null && this.nextTypeStart > -1 && this.nextTypeStart < this.scanner.currentPosition) {
+		TypeDeclaration typeDeclaration = this.recoveredTypes[this.recoveredTypePtr];
+		boolean isAnonymous = typeDeclaration.allocation != null;
+		
+		int end = this.scanner.eofPosition;
+		this.scanner.resetTo(typeDeclaration.declarationSourceEnd + 1, end  - 1);
+		if(!isAnonymous) {
+			pushOnAstStack(typeDeclaration);
+			if(this.astLengthPtr > 0) {
+				concatNodeLists();
+			}
+			
+			if(this.currentElement != null) {
+				this.currentElement = this.currentElement.add(typeDeclaration, 0);
+			}
+			
+			try {
+				this.currentToken = this.scanner.getNextToken();
+			} catch(InvalidInputException e){
+				if (!this.hasReportedError){
+					this.problemReporter().scannerError(this, e.getMessage());
+					this.hasReportedError = true;
+				}
+				this.lastCheckPoint = this.scanner.currentPosition;
+			}
+		} else {
+			if(this.astPtr > -1 && this.astStack[this.astPtr] instanceof TypeDeclaration) {
+				this.astStack[astPtr] = typeDeclaration;
+				this.expressionStack[this.expressionPtr] = typeDeclaration.allocation;
+			}
+			this.currentToken = TokenNameRBRACE;
+		}
+		
+		if(++this.recoveredTypePtr < this.recoveredTypes.length) {
+			TypeDeclaration nextTypeDeclaration = this.recoveredTypes[this.recoveredTypePtr];
+			this.nextTypeStart =
+				nextTypeDeclaration.allocation == null
+					? nextTypeDeclaration.declarationSourceStart
+							: nextTypeDeclaration.bodyStart;
+		} else {
+			this.nextTypeStart = Integer.MAX_VALUE;
+		}
+	}
+}
 protected void markEnclosingMemberWithLocalType() {
 	if (this.currentElement != null) return; // this is already done in the recovery code
 	for (int i = this.astPtr; i >= 0; i--) {
@@ -8485,6 +8724,7 @@ called in order to remember (when needed) the consumed token */
 protected void parse() {
 	if (DEBUG) System.out.println("-- ENTER INSIDE PARSE METHOD --");  //$NON-NLS-1$
 	boolean isDietParse = this.diet;
+	boolean jumpOverTypeAfterReduce = false;
 	int oldFirstToken = getFirstToken();
 	this.hasError = false;
 	
@@ -8533,7 +8773,10 @@ protected void parse() {
 				}
 				this.lastCheckPoint = this.scanner.currentPosition;
 				this.restartRecovery = true;
-			}					
+			}				
+			if(this.statementRecoveryActivated) {
+				jumpOverTypeAfterReduce = true;
+			}
 			act -= ERROR_ACTION;
 			
 		} else {
@@ -8550,6 +8793,9 @@ protected void parse() {
 					this.lastCheckPoint = this.scanner.currentPosition;
 					this.restartRecovery = true;
 				}					
+				if(this.statementRecoveryActivated) {
+					this.jumpOverType();
+				}
 				continue ProcessTerminals;
 			}
 			break ProcessTerminals;
@@ -8560,6 +8806,12 @@ protected void parse() {
 			consumeRule(act);
 			this.stateStackTop -= (rhs[act] - 1);
 			act = ntAction(this.stack[this.stateStackTop], lhs[act]);
+			if(this.statementRecoveryActivated && act > NUM_RULES) {
+				if(jumpOverTypeAfterReduce) {
+					this.jumpOverType();
+					jumpOverTypeAfterReduce = false;
+				}
+			}
 		} while (act <= NUM_RULES);
 	}
 	endParse(act);
@@ -8568,10 +8820,41 @@ protected void parse() {
 	if (tags != null) {
 		this.compilationUnit.nlsTags = tags;
 	}
+	
 	this.scanner.checkNonExternalizedStringLiterals = false;
-	if (this.reportSyntaxErrorIsRequired && this.hasError) {
-		reportSyntaxErrors(isDietParse, oldFirstToken);
-	}	
+	if (this.reportSyntaxErrorIsRequired && this.hasError && !this.statementRecoveryActivated) {
+		if(!this.options.performStatementsRecovery) {
+			reportSyntaxErrors(isDietParse, oldFirstToken);
+		} else {
+			RecoveryScannerData data = this.referenceContext.compilationResult().recoveryScannerData;
+			
+			if(this.recoveryScanner == null) {
+				this.recoveryScanner = new RecoveryScanner(this.scanner, data);
+			} else {
+				this.recoveryScanner.setData(data);
+			}
+			
+			this.recoveryScanner.setSource(scanner.source);
+			this.recoveryScanner.lineEnds = this.scanner.lineEnds;
+			this.recoveryScanner.linePtr = this.scanner.linePtr;
+			
+			reportSyntaxErrors(isDietParse, oldFirstToken);
+			
+			if(data == null) {
+				this.referenceContext.compilationResult().recoveryScannerData =
+					this.recoveryScanner.getData();
+			}
+			
+			if (this.methodRecoveryActivated) {
+				this.methodRecoveryActivated = false;
+				this.recoverStatements();
+				this.methodRecoveryActivated = true;
+
+				this.lastAct = ERROR_ACTION;
+			}
+		}
+	}
+	
 	if (DEBUG) System.out.println("-- EXIT FROM PARSE METHOD --");  //$NON-NLS-1$
 }
 public void parse(ConstructorDeclaration cd, CompilationUnitDeclaration unit) {
@@ -8583,6 +8866,11 @@ public void parse(ConstructorDeclaration cd, CompilationUnitDeclaration unit, bo
 
 	//convert bugs into parse error
 
+	boolean oldMethodRecoveryActivated = this.methodRecoveryActivated;
+	if(this.options.performStatementsRecovery) {
+		this.methodRecoveryActivated = true;
+	}
+	
 	initialize();
 	goForBlockStatementsopt();
 	if (recordLineSeparator) {
@@ -8601,6 +8889,9 @@ public void parse(ConstructorDeclaration cd, CompilationUnitDeclaration unit, bo
 		this.lastAct = ERROR_ACTION;
 	} finally {
 		this.nestedMethod[this.nestedType]--;
+		if(this.options.performStatementsRecovery) {
+			this.methodRecoveryActivated = oldMethodRecoveryActivated;
+		}
 	}
 
 	checkNonNLSAfterBodyEnd(cd.declarationSourceEnd);
@@ -8613,7 +8904,7 @@ public void parse(ConstructorDeclaration cd, CompilationUnitDeclaration unit, bo
 	//statements
 	cd.explicitDeclarations = this.realBlockStack[this.realBlockPtr--];
 	int length;
-	if ((length = this.astLengthStack[this.astLengthPtr--]) != 0) {
+	if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) != 0) {
 		this.astPtr -= length;
 		if (this.astStack[this.astPtr + 1] instanceof ExplicitConstructorCall)
 			//avoid a isSomeThing that would only be used here BUT what is faster between two alternatives ?
@@ -8747,6 +9038,11 @@ public void parse(
 
 	//convert bugs into parse error
 
+	boolean oldMethodRecoveryActivated = this.methodRecoveryActivated;
+	if(this.options.performStatementsRecovery) {
+		this.methodRecoveryActivated = true;
+	}
+	
 	initialize();
 	goForBlockStatementsopt();
 	this.nestedMethod[this.nestedType]++;
@@ -8762,6 +9058,9 @@ public void parse(
 		this.lastAct = ERROR_ACTION;
 	} finally {
 		this.nestedMethod[this.nestedType]--;
+		if(this.options.performStatementsRecovery) {
+			this.methodRecoveryActivated = oldMethodRecoveryActivated;
+		}
 	}
 
 	checkNonNLSAfterBodyEnd(initializer.declarationSourceEnd);
@@ -8773,7 +9072,7 @@ public void parse(
 	//refill statements
 	initializer.block.explicitDeclarations = this.realBlockStack[this.realBlockPtr--];
 	int length;
-	if ((length = this.astLengthStack[this.astLengthPtr--]) > 0) {
+	if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) > 0) {
 		System.arraycopy(this.astStack, (this.astPtr -= length) + 1, initializer.block.statements = new Statement[length], 0, length); 
 	} else {
 		// check whether this block at least contains some comment in it
@@ -8801,6 +9100,11 @@ public void parse(MethodDeclaration md, CompilationUnitDeclaration unit) {
 	if ((md.modifiers & ExtraCompilerModifiers.AccSemicolonBody) != 0)
 		return;
 
+	boolean oldMethodRecoveryActivated = this.methodRecoveryActivated;
+	if(this.options.performStatementsRecovery) {
+		this.methodRecoveryActivated = true;
+		this.rParenPos = md.sourceEnd;
+	}
 	initialize();
 	goForBlockStatementsopt();
 	this.nestedMethod[this.nestedType]++;
@@ -8817,6 +9121,9 @@ public void parse(MethodDeclaration md, CompilationUnitDeclaration unit) {
 		this.lastAct = ERROR_ACTION;
 	} finally {
 		this.nestedMethod[this.nestedType]--;		
+		if(this.options.performStatementsRecovery) {
+			this.methodRecoveryActivated = oldMethodRecoveryActivated;
+		}
 	}
 
 	checkNonNLSAfterBodyEnd(md.declarationSourceEnd);
@@ -8828,7 +9135,7 @@ public void parse(MethodDeclaration md, CompilationUnitDeclaration unit) {
 	//refill statements
 	md.explicitDeclarations = this.realBlockStack[this.realBlockPtr--];
 	int length;
-	if ((length = this.astLengthStack[this.astLengthPtr--]) != 0) {
+	if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) != 0) {
 		System.arraycopy(
 			this.astStack, 
 			(this.astPtr -= length) + 1, 
@@ -8871,7 +9178,7 @@ public ASTNode[] parseClassBodyDeclarations(char[] source, int offset, int lengt
 		return null;
 	}
 	int astLength;
-	if ((astLength = this.astLengthStack[this.astLengthPtr--]) != 0) {
+	if (astLengthPtr > -1 && (astLength = this.astLengthStack[this.astLengthPtr--]) != 0) {
 		ASTNode[] result = new ASTNode[astLength];
 		this.astPtr -= astLength;
 		System.arraycopy(this.astStack, this.astPtr + 1, result, 0, astLength);
@@ -8929,11 +9236,67 @@ public Expression parseMemberValue(char[] source, int offset, int length, Compil
 
 	return this.expressionStack[this.expressionPtr];
 }
+public void parseStatements(ReferenceContext rc, int start, int end, TypeDeclaration[] types, CompilationUnitDeclaration unit) {
+	boolean oldStatementRecoveryEnabled = this.statementRecoveryActivated;
+	this.statementRecoveryActivated = true;
+	
+	initialize();
+	
+	goForBlockStatementsopt();
+	this.nestedMethod[this.nestedType]++;
+	pushOnRealBlockStack(0);
+	
+	pushOnAstLengthStack(0);
+
+	this.referenceContext = rc;
+	this.compilationUnit = unit;
+	
+	if(types != null && types.length > 0) {
+		this.recoveredTypes = types;
+		this.recoveredTypePtr = 0;
+		this.nextTypeStart =
+			this.recoveredTypes[0].allocation == null
+				? this.recoveredTypes[0].declarationSourceStart
+						: this.recoveredTypes[0].bodyStart;
+	} else {
+		this.recoveredTypes = null;
+		this.recoveredTypePtr = -1;
+		this.nextTypeStart = -1;
+	}
+	
+	this.scanner.resetTo(start, end);
+	// reset the scanner to parser from { down to }
+	
+	this.lastCheckPoint = this.scanner.initialPosition;
+	
+	
+	this.stateStackTop = -1;
+		
+	try {
+		parse();
+	} catch (AbortCompilation ex) {
+		this.lastAct = ERROR_ACTION;
+	} finally {
+		this.nestedMethod[this.nestedType]--;	
+		this.recoveredTypes = null;
+		this.statementRecoveryActivated = oldStatementRecoveryEnabled;
+	}
+
+	checkNonNLSAfterBodyEnd(end);
+}
 public void persistLineSeparatorPositions() {
 	if (this.scanner.recordLineSeparator) {
 		this.compilationUnit.compilationResult.lineSeparatorPositions = this.scanner.getLineEnds();
 	}
 }
+/*
+ * Prepares the state of the parser to go for BlockStatements.
+ */
+protected void prepareForBlockStatements() {
+	this.nestedMethod[this.nestedType = 0] = 1;
+	this.variablesCounter[this.nestedType] = 0;
+	this.realBlockStack[this.realBlockPtr = 1] = 0;
+}
 /**
  * Returns this parser's problem reporter initialized with its reference context.
  * Also it is assumed that a problem is going to be reported, so initializes
@@ -9121,6 +9484,166 @@ protected void pushOnRealBlockStack(int i){
 	}
 	this.realBlockStack[this.realBlockPtr] = i;
 }
+protected void recoverStatements() {
+	class MethodVisitor extends ASTVisitor {
+		public ASTVisitor typeVisitor;
+		
+		TypeDeclaration enclosingType; // used only for initializer
+		
+		TypeDeclaration[] types = new TypeDeclaration[0];
+		int typePtr = -1;
+		public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {
+			typePtr = -1;
+			return true;
+		}
+		public boolean visit(Initializer initializer, MethodScope scope) {
+			typePtr = -1;
+			return true;
+		}
+		public boolean visit(MethodDeclaration methodDeclaration,ClassScope scope) {
+			typePtr = -1;
+			return true;
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, BlockScope scope) {
+			return this.visit(typeDeclaration);
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, ClassScope scope) {
+			return this.visit(typeDeclaration);
+		}
+		private boolean visit(TypeDeclaration typeDeclaration) {
+			if(this.types.length <= ++this.typePtr) {
+				int length = this.typePtr;
+				System.arraycopy(this.types, 0, this.types = new TypeDeclaration[length * 2 + 1], 0, length);
+			}
+			this.types[this.typePtr] = typeDeclaration;
+			return false;
+		}
+		public void endVisit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {
+			this.endVisitMethod(constructorDeclaration, scope);
+		}
+		public void endVisit(MethodDeclaration methodDeclaration, ClassScope scope) {
+			this.endVisitMethod(methodDeclaration, scope);
+		}
+		private void endVisitMethod(AbstractMethodDeclaration methodDeclaration, ClassScope scope) {
+			TypeDeclaration[] foundTypes = null;
+			int length = 0;
+			if(this.typePtr > -1) {
+				length = this.typePtr + 1;
+				foundTypes = new TypeDeclaration[length];
+				System.arraycopy(this.types, 0, foundTypes, 0, length);
+			}
+			ReferenceContext oldContext = Parser.this.referenceContext;
+			Parser.this.recoveryScanner.resetTo(methodDeclaration.bodyStart, methodDeclaration.bodyEnd);
+			Scanner oldScanner = Parser.this.scanner;
+			Parser.this.scanner = Parser.this.recoveryScanner;
+			Parser.this.parseStatements(
+					methodDeclaration,
+					methodDeclaration.bodyStart,
+					methodDeclaration.bodyEnd,
+					foundTypes,
+					compilationUnit);
+			Parser.this.scanner = oldScanner;
+			Parser.this.referenceContext = oldContext;
+			
+			for (int i = 0; i < length; i++) {
+				foundTypes[i].traverse(typeVisitor, scope);
+			}
+		}
+		public void endVisit(Initializer initializer, MethodScope scope) {
+			TypeDeclaration[] foundTypes = null;
+			int length = 0;
+			if(this.typePtr > -1) {
+				length = this.typePtr + 1;
+				foundTypes = new TypeDeclaration[length];
+				System.arraycopy(this.types, 0, foundTypes, 0, length);
+			}
+			ReferenceContext oldContext = Parser.this.referenceContext;
+			Parser.this.recoveryScanner.resetTo(initializer.bodyStart, initializer.bodyEnd);
+			Scanner oldScanner = Parser.this.scanner;
+			Parser.this.scanner = Parser.this.recoveryScanner;
+			Parser.this.parseStatements(
+					this.enclosingType,
+					initializer.bodyStart,
+					initializer.bodyEnd,
+					foundTypes,
+					compilationUnit);
+			Parser.this.scanner = oldScanner;
+			Parser.this.referenceContext = oldContext;
+			
+			for (int i = 0; i < length; i++) {
+				foundTypes[i].traverse(typeVisitor, scope);
+			}
+		}
+	}
+	class TypeVisitor extends ASTVisitor {
+		public MethodVisitor methodVisitor;
+		
+		TypeDeclaration[] types = new TypeDeclaration[0];
+		int typePtr = -1;
+		
+		public void endVisit(TypeDeclaration typeDeclaration, BlockScope scope) {
+			endVisitType();
+		}
+		public void endVisit(TypeDeclaration typeDeclaration, ClassScope scope) {
+			endVisitType();
+		}
+		private void endVisitType() {
+			this.typePtr--;
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, BlockScope scope) {
+			return this.visit(typeDeclaration);
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, ClassScope scope) {
+			return this.visit(typeDeclaration);
+		}
+		private boolean visit(TypeDeclaration typeDeclaration) {
+			if(this.types.length <= ++this.typePtr) {
+				int length = this.typePtr;
+				System.arraycopy(this.types, 0, this.types = new TypeDeclaration[length * 2 + 1], 0, length);
+			}
+			this.types[this.typePtr] = typeDeclaration;
+			return true;
+		}
+		public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {
+			if(constructorDeclaration.isDefaultConstructor()) return false;
+			
+			constructorDeclaration.traverse(methodVisitor, scope);
+			return false;
+		}
+		public boolean visit(Initializer initializer, MethodScope scope) {
+			methodVisitor.enclosingType = this.types[typePtr];
+			initializer.traverse(methodVisitor, scope);
+			return false;
+		}
+		public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
+			methodDeclaration.traverse(methodVisitor, scope);
+			return false;
+		}
+	}
+	
+	MethodVisitor methodVisitor = new MethodVisitor();
+	TypeVisitor typeVisitor = new TypeVisitor();
+	methodVisitor.typeVisitor = typeVisitor;
+	typeVisitor.methodVisitor = methodVisitor;
+	
+	if(this.referenceContext instanceof AbstractMethodDeclaration) {
+		((AbstractMethodDeclaration)this.referenceContext).traverse(methodVisitor, (ClassScope)null);
+	} else if(this.referenceContext instanceof TypeDeclaration) {
+		TypeDeclaration typeContext = (TypeDeclaration)this.referenceContext;
+		
+		int length = typeContext.fields.length;
+		for (int i = 0; i < length; i++) {
+			final FieldDeclaration fieldDeclaration = typeContext.fields[i];
+			switch(fieldDeclaration.getKind()) {
+				case AbstractVariableDeclaration.INITIALIZER:
+					methodVisitor.enclosingType = typeContext;
+					((Initializer) fieldDeclaration).traverse(methodVisitor, (MethodScope)null);
+					break;
+			}
+		}
+	}
+}
+
 public void recoveryExitFromVariable() {
 	if(this.currentElement != null && this.currentElement.parent != null) {
 		if(this.currentElement instanceof RecoveredLocalVariable) {
@@ -9202,16 +9725,15 @@ protected void reportSyntaxErrors(boolean isDietParse, int oldFirstToken) {
 	int end = this.scanner.eofPosition <= Integer.MAX_VALUE ? this.scanner.eofPosition - 1 : this.scanner.eofPosition;
 	if(isDietParse) {
 		TypeDeclaration[] types = this.compilationUnit.types;
-		
 		int[][] intervalToSkip = org.eclipse.jdt.internal.compiler.parser.diagnose.RangeUtil.computeDietRange(types);
 		DiagnoseParser diagnoseParser = new DiagnoseParser(this, oldFirstToken, start, end, intervalToSkip[0], intervalToSkip[1], intervalToSkip[2], this.options);
-		diagnoseParser.diagnoseParse();
+		diagnoseParser.diagnoseParse(false);
 		
 		reportSyntaxErrorsForSkippedMethod(types);
 		this.scanner.resetTo(start, end);
 	} else {
 		DiagnoseParser diagnoseParser = new DiagnoseParser(this, oldFirstToken, start, end, this.options);
-		diagnoseParser.diagnoseParse();
+		diagnoseParser.diagnoseParse(this.options.performStatementsRecovery);
 	}
 }
 private void reportSyntaxErrorsForSkippedMethod(TypeDeclaration[] types){
@@ -9229,10 +9751,10 @@ private void reportSyntaxErrorsForSkippedMethod(TypeDeclaration[] types){
 					if(method.errorInSignature) {
 						if(method.isAnnotationMethod()) {
 							DiagnoseParser diagnoseParser = new DiagnoseParser(this, TokenNameQUESTION, method.declarationSourceStart, method.declarationSourceEnd, this.options);
-							diagnoseParser.diagnoseParse();
+							diagnoseParser.diagnoseParse(this.options.performStatementsRecovery);
 						} else {
 							DiagnoseParser diagnoseParser = new DiagnoseParser(this, TokenNameDIVIDE, method.declarationSourceStart, method.declarationSourceEnd, this.options);
-							diagnoseParser.diagnoseParse();
+							diagnoseParser.diagnoseParse(this.options.performStatementsRecovery);
 						}
 						
 					}
@@ -9247,7 +9769,7 @@ private void reportSyntaxErrorsForSkippedMethod(TypeDeclaration[] types){
 						Initializer initializer = (Initializer)fields[j];
 						if(initializer.errorInSignature){
 							DiagnoseParser diagnoseParser = new DiagnoseParser(this, TokenNameRIGHT_SHIFT, initializer.declarationSourceStart, initializer.declarationSourceEnd, this.options);
-							diagnoseParser.diagnoseParse();
+							diagnoseParser.diagnoseParse(this.options.performStatementsRecovery);
 						}
 					}
 				}
@@ -9292,24 +9814,43 @@ protected void resetStacks() {
  * decide which grammar goal is activated.
  */
 protected boolean resumeAfterRecovery() {
-
-	// reset internal stacks 
-	this.resetStacks();
-	this.resetModifiers();
+	if(!this.methodRecoveryActivated && !this.statementRecoveryActivated) {
+		
+		// reset internal stacks 
+		this.resetStacks();
+		this.resetModifiers();
+		
+		/* attempt to move checkpoint location */
+		if (!this.moveRecoveryCheckpoint()) {
+			return false;
+		}
 	
-	/* attempt to move checkpoint location */
-	if (!this.moveRecoveryCheckpoint()) {
+		// only look for headers
+		if (this.referenceContext instanceof CompilationUnitDeclaration){
+			goForHeaders();
+			this.diet = true; // passed this point, will not consider method bodies
+			return true;
+		}
+		
+		// does not know how to restart
 		return false;
-	}
-
-	// only look for headers
-	if (this.referenceContext instanceof CompilationUnitDeclaration){
+	} else if(!this.statementRecoveryActivated) {
+		
+		// reset internal stacks 
+		this.resetStacks();
+		this.resetModifiers();
+		
+		/* attempt to move checkpoint location */
+		if (!this.moveRecoveryCheckpoint()) {
+			return false;
+		}
+		
+		// only look for headers
 		goForHeaders();
-		this.diet = true; // passed this point, will not consider method bodies
 		return true;
+	} else {
+		return false;
 	}
-	// does not know how to restart
-	return false;
 }
 protected boolean resumeOnSyntaxError() {
 	this.checkExternalizeStrings = false;
@@ -9335,6 +9876,9 @@ protected boolean resumeOnSyntaxError() {
 	/* attempt to reset state in order to resume to parse loop */
 	return this.resumeAfterRecovery();
 }
+public void setStatementsRecovery(boolean enabled) {
+	this.options.performStatementsRecovery = enabled;
+}
 public String toString() {
 
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
index 64ddbc9..c41567c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
@@ -33,6 +33,8 @@ public RecoveredBlock(Block block, RecoveredElement parent, int bracketBalance){
 	super(block, parent, bracketBalance);
 	this.blockDeclaration = block;
 	this.foundOpeningBrace = true;
+	
+	this.preserveContent = this.parser().methodRecoveryActivated || this.parser().statementRecoveryActivated;
 }
 /*
  * Record a nested block declaration 
@@ -53,6 +55,9 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
 		element.attach(this.pendingArgument);
 		this.pendingArgument = null;
 	}
+	if(this.parser().statementRecoveryActivated) {
+		this.addBlockStatement(element);
+	}
 	this.attach(element);
 	if (nestedBlockDeclaration.sourceEnd == 0) return element;
 	return this;	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 28e4691..dfa5035 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -106,6 +106,15 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(typeDeclaration.declarationSourceStart - 1));	
 	return this.parent.add(typeDeclaration, bracketBalanceValue);
 }
+protected void addBlockStatement(RecoveredBlock recoveredBlock) {
+	Block block = recoveredBlock.blockDeclaration;
+	if(block.statements != null) {
+		Statement[] statements = block.statements;
+		for (int i = 0; i < statements.length; i++) {
+			recoveredBlock.add(statements[i], 0);
+		}
+	}
+}
 /*
  * Answer the depth of this element, considering the parent link.
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
index 181fdd1..baa2a1d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
@@ -207,7 +207,7 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 		}
 		return this.parent.add(typeDeclaration, bracketBalanceValue);
 	}
-	if ((typeDeclaration.bits & ASTNode.IsLocalType) != 0){
+	if ((typeDeclaration.bits & ASTNode.IsLocalType) != 0 || this.parser().methodRecoveryActivated || this.parser().statementRecoveryActivated){
 		if (methodBody == null){
 			Block block = new Block(0);
 			block.sourceStart = methodDeclaration.bodyStart;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
index 62c4551..6af4494 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
@@ -57,6 +57,8 @@ public RecoveredType(TypeDeclaration typeDeclaration, RecoveredElement parent, i
 	if(this.foundOpeningBrace) {
 		this.bracketBalance++;
 	}
+	
+	this.preserveContent = this.parser().methodRecoveryActivated || this.parser().statementRecoveryActivated;
 }
 public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bracketBalanceValue) {
 
@@ -311,7 +313,7 @@ public Statement updatedStatement(){
 	return updatedType;
 }
 public TypeDeclaration updatedTypeDeclaration(){
-
+	int lastEnd = typeDeclaration.bodyStart;
 	/* update member types */
 	if (memberTypeCount > 0){
 		int existingCount = typeDeclaration.memberTypes == null ? 0 : typeDeclaration.memberTypes.length;
@@ -329,6 +331,9 @@ public TypeDeclaration updatedTypeDeclaration(){
 			memberTypeDeclarations[existingCount + i] = memberTypes[i].updatedTypeDeclaration();
 		}
 		typeDeclaration.memberTypes = memberTypeDeclarations;
+		if(memberTypeDeclarations[memberTypeDeclarations.length - 1].declarationSourceEnd > lastEnd) {
+			lastEnd = memberTypeDeclarations[memberTypeDeclarations.length - 1].declarationSourceEnd;
+		}
 	}
 	/* update fields */
 	if (fieldCount > 0){
@@ -347,6 +352,9 @@ public TypeDeclaration updatedTypeDeclaration(){
 			fieldDeclarations[existingCount + i] = fields[i].updatedFieldDeclaration();
 		}
 		typeDeclaration.fields = fieldDeclarations;
+		if(fieldDeclarations[fieldDeclarations.length - 1].declarationSourceEnd > lastEnd) {
+			lastEnd = fieldDeclarations[fieldDeclarations.length - 1].declarationSourceEnd;
+		}
 	}
 	/* update methods */
 	int existingCount = typeDeclaration.methods == null ? 0 : typeDeclaration.methods.length;
@@ -374,6 +382,9 @@ public TypeDeclaration updatedTypeDeclaration(){
 			methodDeclarations[existingCount + i] = updatedMethod;			
 		}
 		typeDeclaration.methods = methodDeclarations;
+		if(methodDeclarations[methodDeclarations.length - 1].declarationSourceEnd > lastEnd) {
+			lastEnd = methodDeclarations[methodDeclarations.length - 1].declarationSourceEnd;
+		}
 		if (hasAbstractMethods) typeDeclaration.bits |= ASTNode.HasAbstractMethods;
 		hasConstructor = typeDeclaration.checkConstructors(this.parser());
 	} else {
@@ -428,6 +439,10 @@ public TypeDeclaration updatedTypeDeclaration(){
 	} else if (parent instanceof RecoveredMethod){
 		typeDeclaration.bits |= ASTNode.IsLocalType;
 	}
+	if(typeDeclaration.declarationSourceEnd == 0) {
+		typeDeclaration.declarationSourceEnd = lastEnd;
+		typeDeclaration.bodyEnd = lastEnd;
+	}
 	return typeDeclaration;
 }
 /*
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
new file mode 100644
index 0000000..528915d
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
@@ -0,0 +1,186 @@
+package org.eclipse.jdt.internal.compiler.parser;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.compiler.InvalidInputException;
+
+public class RecoveryScanner extends Scanner {
+	private RecoveryScannerData data;
+	
+	private int[] pendingTokens;
+	private int pendingTokensPtr = -1;
+	private char[] fakeTokenSource = null;
+	private int skipNextInsertedTokens = -1;
+
+	public boolean record = true;
+	
+	public RecoveryScanner(Scanner scanner, RecoveryScannerData data) {
+		super(false,
+				scanner.tokenizeWhiteSpace,
+				scanner.checkNonExternalizedStringLiterals,
+				scanner.sourceLevel,
+				scanner.complianceLevel,
+				scanner.taskTags,
+				scanner.taskPriorities,
+				scanner.isTaskCaseSensitive);
+		this.setData(data);
+	}
+	
+	public void insertToken(int token, int completedToken, int position) {
+		insertTokens(new int []{token}, completedToken, position);
+	}
+	
+	private int[] reverse(int[] tokens) {
+		int length = tokens.length;
+		for(int i = 0, max = length / 2; i < max; i++) {
+			int tmp = tokens[i];
+			tokens[i] = tokens[length - i - 1];
+			tokens[length - i - 1] = tmp;
+		}
+		return tokens;
+	}
+	public void insertTokens(int[] tokens, int completedToken, int position) {
+		if(!this.record) return;
+		
+		if(completedToken > -1 && Parser.statements_recovery_filter[completedToken] != 0) return;
+		
+		this.data.insertedTokensPtr++;
+		if(this.data.insertedTokens == null) {
+			this.data.insertedTokens = new int[10][];
+			this.data.insertedTokensPosition = new int[10];
+			this.data.insertedTokenUsed = new boolean[10];
+		} else if(this.data.insertedTokens.length == this.data.insertedTokensPtr) {
+			int length = this.data.insertedTokens.length;
+			System.arraycopy(this.data.insertedTokens, 0, this.data.insertedTokens = new int[length * 2][], 0, length);
+			System.arraycopy(this.data.insertedTokensPosition, 0, this.data.insertedTokensPosition = new int[length * 2], 0, length);
+			System.arraycopy(this.data.insertedTokenUsed, 0, this.data.insertedTokenUsed = new boolean[length * 2], 0, length);
+		}
+		this.data.insertedTokens[this.data.insertedTokensPtr] = reverse(tokens);
+		this.data.insertedTokensPosition[this.data.insertedTokensPtr] = position;
+		this.data.insertedTokenUsed[this.data.insertedTokensPtr] = false;
+	}
+	
+	public void replaceTokens(int token, int start, int end) {
+		replaceTokens(new int []{token}, start, end);
+	}
+	
+	public void replaceTokens(int[] tokens, int start, int end) {
+		if(!this.record) return;
+		this.data.replacedTokensPtr++;
+		if(this.data.replacedTokensStart == null) {
+			this.data.replacedTokens = new int[10][];
+			this.data.replacedTokensStart = new int[10];
+			this.data.replacedTokensEnd = new int[10];
+			this.data.replacedTokenUsed= new boolean[10];
+		} else if(this.data.replacedTokensStart.length == this.data.replacedTokensPtr) {
+			int length = this.data.replacedTokensStart.length;
+			System.arraycopy(this.data.replacedTokens, 0, this.data.replacedTokens = new int[length * 2][], 0, length);
+			System.arraycopy(this.data.replacedTokensStart, 0, this.data.replacedTokensStart = new int[length * 2], 0, length);
+			System.arraycopy(this.data.replacedTokensEnd, 0, this.data.replacedTokensEnd = new int[length * 2], 0, length);
+			System.arraycopy(this.data.replacedTokenUsed, 0, this.data.replacedTokenUsed = new boolean[length * 2], 0, length);
+		}
+		this.data.replacedTokens[this.data.replacedTokensPtr] = reverse(tokens);
+		this.data.replacedTokensStart[this.data.replacedTokensPtr] = start;
+		this.data.replacedTokensEnd[this.data.replacedTokensPtr] = end;
+		this.data.replacedTokenUsed[this.data.replacedTokensPtr] = false;
+	}
+	
+	public void removeTokens(int start, int end) {
+		if(!this.record) return;
+		this.data.removedTokensPtr++;
+		if(this.data.removedTokensStart == null) {
+			this.data.removedTokensStart = new int[10];
+			this.data.removedTokensEnd = new int[10];
+			this.data.removedTokenUsed = new boolean[10];
+		} else if(this.data.removedTokensStart.length == this.data.removedTokensPtr) {
+			int length = this.data.removedTokensStart.length;
+			System.arraycopy(this.data.removedTokensStart, 0, this.data.removedTokensStart = new int[length * 2], 0, length);
+			System.arraycopy(this.data.removedTokensEnd, 0, this.data.removedTokensEnd = new int[length * 2], 0, length);
+			System.arraycopy(this.data.removedTokenUsed, 0, this.data.removedTokenUsed = new boolean[length * 2], 0, length);
+		}
+		this.data.removedTokensStart[this.data.removedTokensPtr] = start;
+		this.data.removedTokensEnd[this.data.removedTokensPtr] = end;
+		this.data.removedTokenUsed[this.data.removedTokensPtr] = false;
+	}
+	
+	public int getNextToken() throws InvalidInputException {
+		if(this.pendingTokensPtr > -1) {
+			return this.pendingTokens[this.pendingTokensPtr--];
+		}
+		
+		this.fakeTokenSource = null;
+		
+		if(this.data.insertedTokens != null) {
+//			if(!skipNextInsertedTokens) {
+				for (int i = 0; i <= this.data.insertedTokensPtr; i++) {
+					if(this.data.insertedTokensPosition[i] == this.currentPosition - 1 && i > skipNextInsertedTokens) {
+						this.data.insertedTokenUsed[i] = true;
+						this.pendingTokens = this.data.insertedTokens[i];
+						this.pendingTokensPtr = this.data.insertedTokens[i].length - 1;
+						this.fakeTokenSource = CharOperation.NO_CHAR;
+						this.startPosition = this.currentPosition - 1;
+						this.skipNextInsertedTokens = i;
+						return this.pendingTokens[this.pendingTokensPtr--];
+					}
+				}
+//			}
+			this.skipNextInsertedTokens = -1;
+		}
+
+		int previousLocation = this.currentPosition;
+		int currentToken = super.getNextToken();
+		
+		if(this.data.replacedTokens != null) {
+			for (int i = 0; i <= this.data.replacedTokensPtr; i++) {
+				if(this.data.replacedTokensStart[i] >= previousLocation &&
+						this.data.replacedTokensStart[i] <= this.startPosition &&
+						this.data.replacedTokensEnd[i] >= this.currentPosition - 1) {
+					this.data.replacedTokenUsed[i] = true;
+					this.pendingTokens = this.data.replacedTokens[i];
+					this.pendingTokensPtr = this.data.replacedTokens[i].length - 1;
+					this.fakeTokenSource = CharOperation.NO_CHAR;
+					this.currentPosition = this.data.replacedTokensEnd[i] + 1;
+					return this.pendingTokens[this.pendingTokensPtr--];
+				}
+			}
+		}
+		if(this.data.removedTokensStart != null) {
+			for (int i = 0; i <= this.data.removedTokensPtr; i++) {
+				if(this.data.removedTokensStart[i] >= previousLocation &&
+						this.data.removedTokensStart[i] <= this.startPosition &&
+						this.data.removedTokensEnd[i] >= this.currentPosition - 1) {
+					this.data.removedTokenUsed[i] = true;
+					this.currentPosition = this.data.removedTokensEnd[i] + 1;
+					return getNextToken();
+				}
+			}
+		}
+		return currentToken;
+	}
+	
+	public char[] getCurrentIdentifierSource() {
+		if(this.fakeTokenSource != null) return this.fakeTokenSource;
+		return super.getCurrentIdentifierSource();
+	}
+	
+	public char[] getCurrentTokenSourceString() {
+		if(this.fakeTokenSource != null) return this.fakeTokenSource;
+		return super.getCurrentTokenSourceString();
+	}
+	
+	public char[] getCurrentTokenSource() {
+		if(this.fakeTokenSource != null) return this.fakeTokenSource;
+		return super.getCurrentTokenSource();
+	}
+	
+	public RecoveryScannerData getData() {
+		return this.data;
+	}
+	
+	public void setData(RecoveryScannerData data) {
+		if(data == null) {
+			this.data = new RecoveryScannerData();
+		} else {
+			this.data = data;
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
new file mode 100644
index 0000000..be74fa7
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
@@ -0,0 +1,65 @@
+/**
+ * 
+ */
+package org.eclipse.jdt.internal.compiler.parser;
+
+public class RecoveryScannerData {
+	public int insertedTokensPtr = -1;
+	public int[][] insertedTokens;
+	public int[] insertedTokensPosition;
+	public boolean[] insertedTokenUsed;
+	
+	public int replacedTokensPtr = -1;
+	public int[][] replacedTokens;
+	public int[] replacedTokensStart;
+	public int[] replacedTokensEnd;
+	public boolean[] replacedTokenUsed;
+		
+	public int removedTokensPtr = -1;
+	public int[] removedTokensStart;
+	public int[] removedTokensEnd;
+	public boolean[] removedTokenUsed;
+	
+	public RecoveryScannerData removeUnused() {
+		if(this.insertedTokens != null) {
+			int newInsertedTokensPtr = -1;
+			for (int i = 0; i <= this.insertedTokensPtr; i++) {
+				if(this.insertedTokenUsed[i]) {
+					newInsertedTokensPtr++;
+					this.insertedTokens[newInsertedTokensPtr] = this.insertedTokens[i];
+					this.insertedTokensPosition[newInsertedTokensPtr] = this.insertedTokensPosition[i];
+					this.insertedTokenUsed[newInsertedTokensPtr] = this.insertedTokenUsed[i];
+				}
+			}
+			this.insertedTokensPtr = newInsertedTokensPtr;
+		}
+
+		if(this.replacedTokens != null) {
+			int newReplacedTokensPtr = -1;
+			for (int i = 0; i <= this.replacedTokensPtr; i++) {
+				if(this.replacedTokenUsed[i]) {
+					newReplacedTokensPtr++;
+					this.replacedTokens[newReplacedTokensPtr] = this.replacedTokens[i];
+					this.replacedTokensStart[newReplacedTokensPtr] = this.replacedTokensStart[i];
+					this.replacedTokensEnd[newReplacedTokensPtr] = this.replacedTokensEnd[i];
+					this.replacedTokenUsed[newReplacedTokensPtr] = this.replacedTokenUsed[i];
+				}
+			}
+			this.replacedTokensPtr = newReplacedTokensPtr;
+		}
+		if(this.removedTokensStart != null) {
+			int newRemovedTokensPtr = -1;
+			for (int i = 0; i <= this.removedTokensPtr; i++) {
+				if(this.removedTokenUsed[i]) {
+					newRemovedTokensPtr++;
+					this.removedTokensStart[newRemovedTokensPtr] = this.removedTokensStart[i];
+					this.removedTokensEnd[newRemovedTokensPtr] = this.removedTokensEnd[i];
+					this.removedTokenUsed[newRemovedTokensPtr] = this.removedTokenUsed[i];
+				}
+			}
+			this.removedTokensPtr = newRemovedTokensPtr;
+		}
+		
+		return this;
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index 4f300ec..4b93802 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -410,7 +410,7 @@ public char[] getCurrentIdentifierSource() {
 public int getCurrentTokenEndPosition(){
 	return this.currentPosition - 1;
 }
-public final char[] getCurrentTokenSource() {
+public char[] getCurrentTokenSource() {
 	// Return the token REAL source (aka unicodes are precomputed)
 
 	char[] result;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
index 2308ab5..d8747df 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
@@ -14,6 +14,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.parser.ParserBasicInformation;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 
@@ -79,6 +80,10 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 	
 	private Parser parser;
 	
+	private RecoveryScanner recoveryScanner;
+	
+	private boolean reportProblem;
+	
 	private class RepairCandidate {
 		public int symbol;
 		public int location;
@@ -145,6 +150,7 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 		this.parser = parser;
 		this.options = options;
 		this.lexStream = new LexStream(BUFF_SIZE, parser.scanner, intervalStartToSkip, intervalEndToSkip, intervalFlagsToSkip, firstToken, start, end);
+		this.recoveryScanner = parser.recoveryScanner;
 	}
 	
 	private ProblemReporter problemReporter(){
@@ -179,230 +185,242 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 	}
 
 
-	public void diagnoseParse() {
-		lexStream.reset();
-
-		currentToken = lexStream.getToken();
-
-		int prev_pos;
-		int pos;
-		int next_pos;
-		int act = START_STATE;
-
-		reallocateStacks();
-
-		//
-		// Start parsing
-		//
-		stateStackTop = 0;
-		stack[stateStackTop] = act;
-
-		int tok = lexStream.kind(currentToken);
-		locationStack[stateStackTop] = currentToken;
-		locationStartStack[stateStackTop] = lexStream.start(currentToken);
-		
-		boolean forceRecoveryAfterLBracketMissing = false;
-//		int forceRecoveryToken = -1;
-
-		//
-		// Process a terminal
-		//
-		do {
+	public void diagnoseParse(boolean record) {
+		this.reportProblem = true;
+		boolean oldRecord = false;
+		if(this.recoveryScanner != null) {
+			oldRecord = this.recoveryScanner.record;
+			this.recoveryScanner.record = record;
+		}
+		try {
+			lexStream.reset();
+	
+			currentToken = lexStream.getToken();
+	
+			int prev_pos;
+			int pos;
+			int next_pos;
+			int act = START_STATE;
+	
+			reallocateStacks();
+	
 			//
-			// Synchronize state stacks and update the location stack
+			// Start parsing
 			//
-			prev_pos = -1;
-			prevStackTop = -1;
-
-			next_pos = -1;
-			nextStackTop = -1;
-
-			pos = stateStackTop;
-			tempStackTop = stateStackTop - 1;
-			for (int i = 0; i <= stateStackTop; i++)
-				tempStack[i] = stack[i];
-
-			act = Parser.tAction(act, tok);
+			stateStackTop = 0;
+			stack[stateStackTop] = act;
+	
+			int tok = lexStream.kind(currentToken);
+			locationStack[stateStackTop] = currentToken;
+			locationStartStack[stateStackTop] = lexStream.start(currentToken);
+			
+			boolean forceRecoveryAfterLBracketMissing = false;
+	//		int forceRecoveryToken = -1;
+	
 			//
-			// When a reduce action is encountered, we compute all REDUCE
-			// and associated goto actions induced by the current token.
-			// Eventually, a SHIFT, SHIFT-REDUCE, ACCEPT or ERROR action is
-			// computed...
+			// Process a terminal
 			//
-			while (act <= NUM_RULES) {
-				do {
-					tempStackTop -= (Parser.rhs[act]-1);
-					act = Parser.ntAction(tempStack[tempStackTop], Parser.lhs[act]);
-				} while(act <= NUM_RULES);
+			do {
 				//
-				// ... Update the maximum useful position of the
-				// (STATE_)STACK, push goto state into stack, and
-				// compute next action on current symbol ...
+				// Synchronize state stacks and update the location stack
 				//
-				if (tempStackTop + 1 >= stackLength)
-					reallocateStacks();
-				pos = pos < tempStackTop ? pos : tempStackTop;
-				tempStack[tempStackTop + 1] = act;
+				prev_pos = -1;
+				prevStackTop = -1;
+	
+				next_pos = -1;
+				nextStackTop = -1;
+	
+				pos = stateStackTop;
+				tempStackTop = stateStackTop - 1;
+				for (int i = 0; i <= stateStackTop; i++)
+					tempStack[i] = stack[i];
+	
 				act = Parser.tAction(act, tok);
-			}
-
-			//
-			// At this point, we have a shift, shift-reduce, accept or error
-			// action.  STACK contains the configuration of the state stack
-			// prior to executing any action on curtok. next_stack contains
-			// the configuration of the state stack after executing all
-			// reduce actions induced by curtok.  The variable pos indicates
-			// the highest position in STACK that is still useful after the
-			// reductions are executed.
-			//
-			while(act > ERROR_ACTION || act < ACCEPT_ACTION) { // SHIFT-REDUCE action or SHIFT action ?
-				nextStackTop = tempStackTop + 1;
-				for (int i = next_pos + 1; i <= nextStackTop; i++)
-					nextStack[i] = tempStack[i];
-
-				for (int i = pos + 1; i <= nextStackTop; i++) {
-					locationStack[i] = locationStack[stateStackTop];
-					locationStartStack[i] = locationStartStack[stateStackTop];
-				}
-
 				//
-				// If we have a shift-reduce, process it as well as
-				// the goto-reduce actions that follow it.
+				// When a reduce action is encountered, we compute all REDUCE
+				// and associated goto actions induced by the current token.
+				// Eventually, a SHIFT, SHIFT-REDUCE, ACCEPT or ERROR action is
+				// computed...
 				//
-				if (act > ERROR_ACTION) {
-					act -= ERROR_ACTION;
+				while (act <= NUM_RULES) {
 					do {
-						nextStackTop -= (Parser.rhs[act]-1);
-						act = Parser.ntAction(nextStack[nextStackTop], Parser.lhs[act]);
-					} while(act <= NUM_RULES);
-					pos = pos < nextStackTop ? pos : nextStackTop;
-				}
-
-				if (nextStackTop + 1 >= stackLength)
-					reallocateStacks();
-
-				tempStackTop = nextStackTop;
-				nextStack[++nextStackTop] = act;
-				next_pos = nextStackTop;
-
-				//
-				// Simulate the parser through the next token without
-				// destroying STACK or next_stack.
-				//
-				currentToken = lexStream.getToken();
-				tok = lexStream.kind(currentToken);
-				act = Parser.tAction(act, tok);
-				while(act <= NUM_RULES) {
-					//
-					// ... Process all goto-reduce actions following
-					// reduction, until a goto action is computed ...
-					//
-					do {
-						int lhs_symbol = Parser.lhs[act];
-						if(DEBUG) {
-							System.out.println(Parser.name[Parser.non_terminal_index[lhs_symbol]]);
-						}
 						tempStackTop -= (Parser.rhs[act]-1);
-						act = (tempStackTop > next_pos
-								   ? tempStack[tempStackTop]
-								   : nextStack[tempStackTop]);
-						act = Parser.ntAction(act, lhs_symbol);
-					}   while(act <= NUM_RULES);
-
+						act = Parser.ntAction(tempStack[tempStackTop], Parser.lhs[act]);
+					} while(act <= NUM_RULES);
 					//
 					// ... Update the maximum useful position of the
-					// (STATE_)STACK, push GOTO state into stack, and
+					// (STATE_)STACK, push goto state into stack, and
 					// compute next action on current symbol ...
 					//
 					if (tempStackTop + 1 >= stackLength)
 						reallocateStacks();
-
-					next_pos = next_pos < tempStackTop ? next_pos : tempStackTop;
+					pos = pos < tempStackTop ? pos : tempStackTop;
 					tempStack[tempStackTop + 1] = act;
 					act = Parser.tAction(act, tok);
 				}
-
-//				if((tok != TokenNameRBRACE || (forceRecoveryToken != currentToken && (lexStream.flags(currentToken) & LexStream.LBRACE_MISSING) != 0))
-//					&& (lexStream.flags(currentToken) & LexStream.IS_AFTER_JUMP) !=0) {
-//					act = ERROR_ACTION;
-//					if(forceRecoveryToken != currentToken
-//						&& (lexStream.flags(currentToken) & LexStream.LBRACE_MISSING) != 0) {
-//						forceRecoveryAfterLBracketMissing = true;
-//						forceRecoveryToken = currentToken;
-//					}
-//				}
-				
-				//
-				// No error was detected, Read next token into
-				// PREVTOK element, advance CURTOK pointer and
-				// update stacks.
-				//
-				if (act != ERROR_ACTION) {
-					prevStackTop = stateStackTop;
-					for (int i = prev_pos + 1; i <= prevStackTop; i++)
-						prevStack[i] = stack[i];
-					prev_pos = pos;
-
-					stateStackTop = nextStackTop;
-					for (int i = pos + 1; i <= stateStackTop; i++)
-						stack[i] = nextStack[i];
-					locationStack[stateStackTop] = currentToken;
-					locationStartStack[stateStackTop] = lexStream.start(currentToken);
-					pos = next_pos;
-				}
-			}
-
-			//
-			// At this stage, either we have an ACCEPT or an ERROR
-			// action.
-			//
-			if (act == ERROR_ACTION) {
+	
 				//
-				// An error was detected.
+				// At this point, we have a shift, shift-reduce, accept or error
+				// action.  STACK contains the configuration of the state stack
+				// prior to executing any action on curtok. next_stack contains
+				// the configuration of the state stack after executing all
+				// reduce actions induced by curtok.  The variable pos indicates
+				// the highest position in STACK that is still useful after the
+				// reductions are executed.
 				//
-				RepairCandidate candidate = errorRecovery(currentToken, forceRecoveryAfterLBracketMissing);
-				
-				forceRecoveryAfterLBracketMissing = false;
-				
-				if(parser.reportOnlyOneSyntaxError) {
-					return;
-				}
-				
-				if(this.parser.problemReporter().options.maxProblemsPerUnit < this.parser.compilationUnit.compilationResult.problemCount) {
-					return;
+				while(act > ERROR_ACTION || act < ACCEPT_ACTION) { // SHIFT-REDUCE action or SHIFT action ?
+					nextStackTop = tempStackTop + 1;
+					for (int i = next_pos + 1; i <= nextStackTop; i++)
+						nextStack[i] = tempStack[i];
+	
+					for (int i = pos + 1; i <= nextStackTop; i++) {
+						locationStack[i] = locationStack[stateStackTop];
+						locationStartStack[i] = locationStartStack[stateStackTop];
+					}
+	
+					//
+					// If we have a shift-reduce, process it as well as
+					// the goto-reduce actions that follow it.
+					//
+					if (act > ERROR_ACTION) {
+						act -= ERROR_ACTION;
+						do {
+							nextStackTop -= (Parser.rhs[act]-1);
+							act = Parser.ntAction(nextStack[nextStackTop], Parser.lhs[act]);
+						} while(act <= NUM_RULES);
+						pos = pos < nextStackTop ? pos : nextStackTop;
+					}
+	
+					if (nextStackTop + 1 >= stackLength)
+						reallocateStacks();
+	
+					tempStackTop = nextStackTop;
+					nextStack[++nextStackTop] = act;
+					next_pos = nextStackTop;
+	
+					//
+					// Simulate the parser through the next token without
+					// destroying STACK or next_stack.
+					//
+					currentToken = lexStream.getToken();
+					tok = lexStream.kind(currentToken);
+					act = Parser.tAction(act, tok);
+					while(act <= NUM_RULES) {
+						//
+						// ... Process all goto-reduce actions following
+						// reduction, until a goto action is computed ...
+						//
+						do {
+							int lhs_symbol = Parser.lhs[act];
+							if(DEBUG) {
+								System.out.println(Parser.name[Parser.non_terminal_index[lhs_symbol]]);
+							}
+							tempStackTop -= (Parser.rhs[act]-1);
+							act = (tempStackTop > next_pos
+									   ? tempStack[tempStackTop]
+									   : nextStack[tempStackTop]);
+							act = Parser.ntAction(act, lhs_symbol);
+						}   while(act <= NUM_RULES);
+	
+						//
+						// ... Update the maximum useful position of the
+						// (STATE_)STACK, push GOTO state into stack, and
+						// compute next action on current symbol ...
+						//
+						if (tempStackTop + 1 >= stackLength)
+							reallocateStacks();
+	
+						next_pos = next_pos < tempStackTop ? next_pos : tempStackTop;
+						tempStack[tempStackTop + 1] = act;
+						act = Parser.tAction(act, tok);
+					}
+	
+	//				if((tok != TokenNameRBRACE || (forceRecoveryToken != currentToken && (lexStream.flags(currentToken) & LexStream.LBRACE_MISSING) != 0))
+	//					&& (lexStream.flags(currentToken) & LexStream.IS_AFTER_JUMP) !=0) {
+	//					act = ERROR_ACTION;
+	//					if(forceRecoveryToken != currentToken
+	//						&& (lexStream.flags(currentToken) & LexStream.LBRACE_MISSING) != 0) {
+	//						forceRecoveryAfterLBracketMissing = true;
+	//						forceRecoveryToken = currentToken;
+	//					}
+	//				}
+					
+					//
+					// No error was detected, Read next token into
+					// PREVTOK element, advance CURTOK pointer and
+					// update stacks.
+					//
+					if (act != ERROR_ACTION) {
+						prevStackTop = stateStackTop;
+						for (int i = prev_pos + 1; i <= prevStackTop; i++)
+							prevStack[i] = stack[i];
+						prev_pos = pos;
+	
+						stateStackTop = nextStackTop;
+						for (int i = pos + 1; i <= stateStackTop; i++)
+							stack[i] = nextStack[i];
+						locationStack[stateStackTop] = currentToken;
+						locationStartStack[stateStackTop] = lexStream.start(currentToken);
+						pos = next_pos;
+					}
 				}
-
-				act = stack[stateStackTop];
-
+	
 				//
-				// If the recovery was successful on a nonterminal candidate,
-				// parse through that candidate and "read" the next token.
+				// At this stage, either we have an ACCEPT or an ERROR
+				// action.
 				//
-				if (candidate.symbol == 0) {
-					break;
-				} else if (candidate.symbol > NT_OFFSET) {
-					int lhs_symbol = candidate.symbol - NT_OFFSET;
-					if(DEBUG) {
-						System.out.println(Parser.name[Parser.non_terminal_index[lhs_symbol]]);
+				if (act == ERROR_ACTION) {
+					//
+					// An error was detected.
+					//
+					RepairCandidate candidate = errorRecovery(currentToken, forceRecoveryAfterLBracketMissing);
+					
+					forceRecoveryAfterLBracketMissing = false;
+					
+					if(parser.reportOnlyOneSyntaxError) {
+						return;
 					}
-					act = Parser.ntAction(act, lhs_symbol);
-					while(act <= NUM_RULES) {
-						stateStackTop -= (Parser.rhs[act]-1);
-						act = Parser.ntAction(stack[stateStackTop], Parser.lhs[act]);
+					
+					if(this.parser.problemReporter().options.maxProblemsPerUnit < this.parser.compilationUnit.compilationResult.problemCount) {						
+						if(this.recoveryScanner == null) return;
+						this.reportProblem = false;
+					}
+	
+					act = stack[stateStackTop];
+	
+					//
+					// If the recovery was successful on a nonterminal candidate,
+					// parse through that candidate and "read" the next token.
+					//
+					if (candidate.symbol == 0) {
+						break;
+					} else if (candidate.symbol > NT_OFFSET) {
+						int lhs_symbol = candidate.symbol - NT_OFFSET;
+						if(DEBUG) {
+							System.out.println(Parser.name[Parser.non_terminal_index[lhs_symbol]]);
+						}
+						act = Parser.ntAction(act, lhs_symbol);
+						while(act <= NUM_RULES) {
+							stateStackTop -= (Parser.rhs[act]-1);
+							act = Parser.ntAction(stack[stateStackTop], Parser.lhs[act]);
+						}
+						stack[++stateStackTop] = act;
+						currentToken = lexStream.getToken();
+						tok = lexStream.kind(currentToken);
+						locationStack[stateStackTop] = currentToken;
+						locationStartStack[stateStackTop] = lexStream.start(currentToken);
+					} else {
+						tok = candidate.symbol;
+						locationStack[stateStackTop] = candidate.location;
+						locationStartStack[stateStackTop] = lexStream.start(candidate.location);
 					}
-					stack[++stateStackTop] = act;
-					currentToken = lexStream.getToken();
-					tok = lexStream.kind(currentToken);
-					locationStack[stateStackTop] = currentToken;
-					locationStartStack[stateStackTop] = lexStream.start(currentToken);
-				} else {
-					tok = candidate.symbol;
-					locationStack[stateStackTop] = candidate.location;
-					locationStartStack[stateStackTop] = lexStream.start(candidate.location);
 				}
+			} while (act != ACCEPT_ACTION);
+		} finally {
+			if(this.recoveryScanner != null) {
+				this.recoveryScanner.record = oldRecord;
 			}
-		} while (act != ACCEPT_ACTION);
-
+		}
 		return;
 	}
 
@@ -2084,9 +2102,25 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 		String errorTokenName = Parser.name[Parser.terminal_index[lexStream.kind(token)]];
 		char[] errorTokenSource = lexStream.name(token);
 
+		int addedToken = -1;
+		if(recoveryScanner != null) {
+			if (nameIndex >= 0) {
+				addedToken = Parser.reverse_index[nameIndex];
+			}
+		}
 		switch(msgCode) {
 			case BEFORE_CODE:
-				problemReporter().parseErrorInsertBeforeToken(
+				if(recoveryScanner != null) {
+					if(addedToken > -1) {
+						recoveryScanner.insertToken(addedToken, -1, errorStart);
+					} else {
+						int[] template = getNTermTemplate(-addedToken);
+						if(template != null) {
+							recoveryScanner.insertTokens(template, -1, errorStart);
+						}
+					}
+				}
+				if(this.reportProblem) problemReporter().parseErrorInsertBeforeToken(
 					errorStart, 
 					errorEnd, 
 					currentKind,
@@ -2095,7 +2129,17 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 					name);
 				 break;
 			case INSERTION_CODE:
-				problemReporter().parseErrorInsertAfterToken(
+				if(recoveryScanner != null) {
+					if(addedToken > -1) {
+						recoveryScanner.insertToken(addedToken, -1, errorEnd);
+					} else {
+						int[] template = getNTermTemplate(-addedToken);
+						if(template != null) {
+							recoveryScanner.insertTokens(template, -1, errorEnd);
+						}
+					}
+				}
+				if(this.reportProblem) problemReporter().parseErrorInsertAfterToken(
 					errorStart, 
 					errorEnd, 
 					currentKind,
@@ -2104,7 +2148,10 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 					name);  
 				 break;
 			case DELETION_CODE:
-				problemReporter().parseErrorDeleteToken(
+				if(recoveryScanner != null) {
+					recoveryScanner.removeTokens(errorStart, errorEnd);
+				}
+				if(this.reportProblem) problemReporter().parseErrorDeleteToken(
 					errorStart, 
 					errorEnd, 
 					currentKind,
@@ -2113,7 +2160,10 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 				break;
 			case INVALID_CODE:
 				if (name.length() == 0) {
-					problemReporter().parseErrorReplaceToken(
+					if(recoveryScanner != null) {
+						recoveryScanner.removeTokens(errorStart, errorEnd);
+					}
+					if(this.reportProblem) problemReporter().parseErrorReplaceToken(
 						errorStart, 
 						errorEnd, 
 						currentKind,
@@ -2121,7 +2171,17 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 						errorTokenName, 
 						name);
 				} else {
-					problemReporter().parseErrorInvalidToken(
+					if(recoveryScanner != null) {
+						if(addedToken > -1) {
+							recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+						} else {
+							int[] template = getNTermTemplate(-addedToken);
+							if(template != null) {
+								recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+							}
+						}
+					}
+					if(this.reportProblem) problemReporter().parseErrorInvalidToken(
 						errorStart, 
 						errorEnd, 
 						currentKind,
@@ -2131,7 +2191,17 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 				}
 				break;
 			case SUBSTITUTION_CODE:
-				problemReporter().parseErrorReplaceToken(
+				if(recoveryScanner != null) {
+					if(addedToken > -1) {
+						recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+					} else {
+						int[] template = getNTermTemplate(-addedToken);
+						if(template != null) {
+							recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+						}
+					}
+				}
+				if(this.reportProblem) problemReporter().parseErrorReplaceToken(
 					errorStart, 
 					errorEnd, 
 					currentKind,
@@ -2141,21 +2211,62 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 				 break;
 			case SCOPE_CODE:
 				StringBuffer buf = new StringBuffer();
+				
+				int[] addedTokens = null;
+	            int addedTokenCount = 0;
+	            if(this.recoveryScanner != null) {
+	            	addedTokens = new int[Parser.scope_rhs.length - Parser.scope_suffix[- nameIndex]];
+	            }
+	            
 				for (int i = Parser.scope_suffix[- nameIndex]; Parser.scope_rhs[i] != 0; i++) {
 					buf.append(Parser.readableName[Parser.scope_rhs[i]]);
 					if (Parser.scope_rhs[i + 1] != 0) // any more symbols to print?
 						buf.append(' ');
-						
+					
+					if(addedTokens != null) {
+	                	int tmpAddedToken = Parser.reverse_index[Parser.scope_rhs[i]];
+		                if (tmpAddedToken > -1) {
+		                	int length = addedTokens.length;
+		                	if(addedTokenCount == length) {
+		                		System.arraycopy(addedTokens, 0, addedTokens = new int[length * 2], 0, length);
+		                	}
+		                	addedTokens[addedTokenCount++] = tmpAddedToken;
+		                } else {
+		                	int[] template = getNTermTemplate(-tmpAddedToken);
+		                	if(template != null) {
+			                	for (int j = 0; j < template.length; j++) {
+									int length = addedTokens.length;
+		                			if(addedTokenCount == length) {
+				                		System.arraycopy(addedTokens, 0, addedTokens = new int[length * 2], 0, length);
+				                	}
+		                			addedTokens[addedTokenCount++] = template[j];
+								}
+		                	} else {
+			                	addedTokenCount = 0;
+			                	addedTokens = null;
+		                	}
+		                }
+	                }
 				}
 
+				if(addedTokenCount > 0) {
+	            	System.arraycopy(addedTokens, 0, addedTokens = new int[addedTokenCount], 0, addedTokenCount);
+	            	
+	            	int completedToken = -1;
+	            	if(scopeNameIndex != 0) {
+	            		completedToken = -Parser.reverse_index[scopeNameIndex];
+	            	}
+	            	this.recoveryScanner.insertTokens(addedTokens, completedToken, errorEnd);
+	            }
+				
 				if (scopeNameIndex != 0) {
-					problemReporter().parseErrorInsertToComplete(
+					if(this.reportProblem) problemReporter().parseErrorInsertToComplete(
 						errorStart, 
 						errorEnd,
 						buf.toString(),
 						Parser.readableName[scopeNameIndex]);
 				} else {
-					problemReporter().parseErrorInsertToCompleteScope(
+					if(this.reportProblem) problemReporter().parseErrorInsertToCompleteScope(
 						errorStart, 
 						errorEnd,
 						buf.toString()); 
@@ -2163,31 +2274,57 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 				
 				break;
 			case EOF_CODE:
-				problemReporter().parseErrorUnexpectedEnd(
+				if(this.reportProblem) problemReporter().parseErrorUnexpectedEnd(
 					errorStart, 
 					errorEnd); 
 				break;
 			case MERGE_CODE:
-				problemReporter().parseErrorMergeTokens(
+				if(recoveryScanner != null) {
+					if(addedToken > -1) {
+						recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+					} else {
+						int[] template = getNTermTemplate(-addedToken);
+						if(template != null) {
+							recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+						}
+					}
+				}
+				if(this.reportProblem) problemReporter().parseErrorMergeTokens(
 					errorStart, 
 					errorEnd,
 					name);
 				break;
 			case MISPLACED_CODE:
-				problemReporter().parseErrorMisplacedConstruct(
+				if(recoveryScanner != null) {
+					recoveryScanner.removeTokens(errorStart, errorEnd);
+				}
+				if(this.reportProblem) problemReporter().parseErrorMisplacedConstruct(
 					errorStart, 
 					errorEnd);
 				break;
 			default:
 				if (name.length() == 0) {
-					problemReporter().parseErrorNoSuggestion(
+					if(recoveryScanner != null) {
+						recoveryScanner.removeTokens(errorStart, errorEnd);
+					}
+					if(this.reportProblem) problemReporter().parseErrorNoSuggestion(
 						errorStart, 
 						errorEnd, 
 						currentKind,
 						errorTokenSource, 
 						errorTokenName);
 				} else {
-					problemReporter().parseErrorReplaceToken(
+					if(recoveryScanner != null) {
+						if(addedToken > -1) {
+							recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+						} else {
+							int[] template = getNTermTemplate(-addedToken);
+							if(template != null) {
+								recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+							}
+						}
+					}
+					if(this.reportProblem) problemReporter().parseErrorReplaceToken(
 						errorStart, 
 						errorEnd, 
 						currentKind,
@@ -2230,9 +2367,19 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 		}
 		int errorEnd = lexStream.end(rightToken);
 		
+		int addedToken = -1;
+		if(recoveryScanner != null) {
+			if (nameIndex >= 0) {
+				addedToken = Parser.reverse_index[nameIndex];
+			}
+		}
+		
 		switch(msgCode) {
 			case MISPLACED_CODE:
-				problemReporter().parseErrorMisplacedConstruct(
+				if(recoveryScanner != null) {
+					recoveryScanner.removeTokens(errorStart, errorEnd);
+				}
+				if(this.reportProblem) problemReporter().parseErrorMisplacedConstruct(
 					errorStart, 
 					errorEnd); 
 				break;
@@ -2241,42 +2388,109 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 				errorStart = lexStream.start(rightToken);
 			
 	            StringBuffer buf = new StringBuffer();
+	            
+	            int[] addedTokens = null;
+	            int addedTokenCount = 0;
+	            if(this.recoveryScanner != null) {
+	            	addedTokens = new int[Parser.scope_rhs.length - Parser.scope_suffix[- nameIndex]];
+	            }
+	            
 	            for (int i = Parser.scope_suffix[- nameIndex]; Parser.scope_rhs[i] != 0; i++) {
+	                
 	                buf.append(Parser.readableName[Parser.scope_rhs[i]]);
 	                if (Parser.scope_rhs[i+1] != 0)
 	                     buf.append(' ');
+	                
+	                if(addedTokens != null) {
+	                	int tmpAddedToken = Parser.reverse_index[Parser.scope_rhs[i]];
+		                if (tmpAddedToken > -1) {
+		                	int length = addedTokens.length;
+		                	if(addedTokenCount == length) {
+		                		System.arraycopy(addedTokens, 0, addedTokens = new int[length * 2], 0, length);
+		                	}
+		                	addedTokens[addedTokenCount++] = tmpAddedToken;
+		                } else {
+		                	int[] template = getNTermTemplate(-tmpAddedToken);
+		                	if(template != null) {
+			                	for (int j = 0; j < template.length; j++) {
+									int length = addedTokens.length;
+		                			if(addedTokenCount == length) {
+				                		System.arraycopy(addedTokens, 0, addedTokens = new int[length * 2], 0, length);
+				                	}
+		                			addedTokens[addedTokenCount++] = template[j];
+								}
+		                	} else {
+			                	addedTokenCount = 0;
+			                	addedTokens = null;
+		                	}
+		                }
+	                }
+	            }
+	            if(addedTokenCount > 0) {
+	            	System.arraycopy(addedTokens, 0, addedTokens = new int[addedTokenCount], 0, addedTokenCount);
+	            	int completedToken = -1;
+	            	if(scopeNameIndex != 0) {
+	            		completedToken = -Parser.reverse_index[scopeNameIndex];
+	            	}
+	            	this.recoveryScanner.insertTokens(addedTokens, completedToken, errorEnd);
 	            }
 	            if (scopeNameIndex != 0) {
-	                problemReporter().parseErrorInsertToComplete(
+	                if(this.reportProblem) problemReporter().parseErrorInsertToComplete(
 						errorStart, 
 						errorEnd,
 						buf.toString(),
 						Parser.readableName[scopeNameIndex]);
 	            } else {
-	            	problemReporter().parseErrorInsertToCompletePhrase(
+	            	if(this.reportProblem) problemReporter().parseErrorInsertToCompletePhrase(
 						errorStart, 
 						errorEnd,
 						buf.toString()); 
 	            }
 	            break;
 			case MERGE_CODE:
-				problemReporter().parseErrorMergeTokens(
+				if(recoveryScanner != null) {
+					if(addedToken > -1) {
+						recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+					} else {
+						int[] template = getNTermTemplate(-addedToken);
+						if(template != null) {
+							recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+						}
+					}
+				}
+				if(this.reportProblem) problemReporter().parseErrorMergeTokens(
 					errorStart, 
 					errorEnd,
 					name);
 				break;
 			case DELETION_CODE:
-				problemReporter().parseErrorDeleteTokens(
+				if(recoveryScanner != null) {
+					recoveryScanner.removeTokens(errorStart, errorEnd);
+				}
+				if(this.reportProblem) problemReporter().parseErrorDeleteTokens(
 					errorStart, 
 					errorEnd);
 				break;
 			default:
 				if (name.length() == 0) {
-					problemReporter().parseErrorNoSuggestionForTokens(
+					if(recoveryScanner != null) {
+						recoveryScanner.removeTokens(errorStart, errorEnd);
+					}
+					if(this.reportProblem) problemReporter().parseErrorNoSuggestionForTokens(
 						errorStart, 
 						errorEnd);
 				} else {
-					problemReporter().parseErrorReplaceTokens(
+					if(recoveryScanner != null) {
+						if(addedToken > -1) {
+							recoveryScanner.replaceTokens(addedToken, errorStart, errorEnd);
+						} else {
+							int[] template = getNTermTemplate(-addedToken);
+							if(template != null) {
+								recoveryScanner.replaceTokens(template, errorStart, errorEnd);
+							}
+						}
+					}
+					if(this.reportProblem) problemReporter().parseErrorReplaceTokens(
 						errorStart, 
 						errorEnd,
 						name);
@@ -2285,6 +2499,21 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens {
 		return;
 	}
 
+	private int[] getNTermTemplate(int sym) {
+		int templateIndex = Parser.recovery_templates_index[sym];
+    	if(templateIndex > 0) {
+    		int[] result = new int[Parser.recovery_templates.length];
+    		int count = 0;
+    		for(int j = templateIndex; Parser.recovery_templates[j] != 0; j++) {
+    			result[count++] = Parser.recovery_templates[j];
+    		}
+    		System.arraycopy(result, 0, result = new int[count], 0, count);
+    		return result;
+    	} else {
+        	return null;
+    	}
+	}
+	
 	public String toString() {
 		StringBuffer res = new StringBuffer();
 		
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
new file mode 100644
index 0000000..296c986
Binary files /dev/null and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
new file mode 100644
index 0000000..856f2e2
Binary files /dev/null and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
new file mode 100644
index 0000000..41aba0c
Binary files /dev/null and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 595e91d..809efb6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -2628,6 +2628,8 @@ public void invalidContinue(ASTNode location) {
 public void invalidEnclosingType(Expression expression, TypeBinding type, ReferenceBinding enclosingType) {
 
 	if (enclosingType.isAnonymousType()) enclosingType = enclosingType.superclass();
+	if (enclosingType.sourceName.length == 0) return;
+	
 	int flag = IProblem.UndefinedType; // default
 	switch (type.problemId()) {
 		case ProblemReasons.NotFound : // 1
@@ -2675,6 +2677,8 @@ public void invalidExpressionAsStatement(Expression expression){
 		expression.sourceEnd);
 }
 public void invalidField(FieldReference fieldRef, TypeBinding searchedType) {
+	if(fieldRef.token.length == 0) return;
+	
 	int id = IProblem.UndefinedField;
 	FieldBinding field = fieldRef.binding;
 	final int sourceStart= (int) (fieldRef.nameSourcePosition >> 32);
@@ -2730,6 +2734,14 @@ public void invalidField(FieldReference fieldRef, TypeBinding searchedType) {
 		fieldRef.sourceEnd);
 }
 public void invalidField(NameReference nameRef, FieldBinding field) {
+	if (nameRef instanceof QualifiedNameReference) {
+		QualifiedNameReference ref = (QualifiedNameReference) nameRef;
+		char[] lastToken = ref.tokens[ref.tokens.length - 1];
+		if (lastToken.length == 0) return;
+	} else {
+		SingleNameReference ref = (SingleNameReference) nameRef;
+		if (ref.token.length == 0) return;
+	}
 	int id = IProblem.UndefinedField;
 	switch (field.problemId()) {
 		case ProblemReasons.NotFound :
@@ -2786,6 +2798,9 @@ public void invalidField(QualifiedNameReference nameRef, FieldBinding field, int
 	//UndefinedField
 	//NotVisibleField
 	//AmbiguousField
+	
+	char[] lastToken = nameRef.tokens[nameRef.tokens.length - 1];
+	if (lastToken.length == 0) return;
 
 	if (searchedType.isBaseType()) {
 		this.handle(
@@ -2863,6 +2878,8 @@ public void invalidFileNameForPackageAnnotations(Annotation annotation) {
 			annotation.sourceEnd);	
 }
 public void invalidMethod(MessageSend messageSend, MethodBinding method) {
+	if(messageSend.selector.length == 0) return;
+	
 	int id = IProblem.UndefinedMethod; //default...
     MethodBinding shownMethod = method;
 	switch (method.problemId()) {
@@ -3148,26 +3165,31 @@ public void invalidType(ASTNode location, TypeBinding type) {
 	int end = location.sourceEnd;
 	if (location instanceof QualifiedNameReference) {
 		QualifiedNameReference ref = (QualifiedNameReference) location;
+		if(ref.tokens[ref.tokens.length - 1].length == 0) return;
 		if (ref.indexOfFirstFieldBinding >= 1)
 			end = (int) ref.sourcePositions[ref.indexOfFirstFieldBinding - 1];
 	} else if (location instanceof ArrayQualifiedTypeReference) {
 		ArrayQualifiedTypeReference arrayQualifiedTypeReference = (ArrayQualifiedTypeReference) location;
+		if(arrayQualifiedTypeReference.tokens[arrayQualifiedTypeReference.tokens.length - 1].length == 0) return;
 		long[] positions = arrayQualifiedTypeReference.sourcePositions;
 		end = (int) positions[positions.length - 1];
 	} else if (location instanceof QualifiedTypeReference) {
 		QualifiedTypeReference ref = (QualifiedTypeReference) location;
+		if(ref.tokens[ref.tokens.length - 1].length == 0) return;
 		if (type instanceof ReferenceBinding) {
 			char[][] name = ((ReferenceBinding) type).compoundName;
 			end = (int) ref.sourcePositions[name.length - 1];
 		}
 	} else if (location instanceof ImportReference) {
 		ImportReference ref = (ImportReference) location;
+		if (ref.tokens[ref.tokens.length - 1].length == 0) return;
 		if (type instanceof ReferenceBinding) {
 			char[][] name = ((ReferenceBinding) type).compoundName;
 			end = (int) ref.sourcePositions[name.length - 1];
 		}
 	} else if (location instanceof ArrayTypeReference) {
 		ArrayTypeReference arrayTypeReference = (ArrayTypeReference) location;
+		if (arrayTypeReference.token.length == 0) return;
 		end = arrayTypeReference.originalSourceEnd;
 	}
 	this.handle(
@@ -5274,6 +5296,7 @@ private String typesAsString(boolean isVarargs, TypeBinding[] types, boolean mak
 }
 public void undefinedAnnotationValue(TypeBinding annotationType, MemberValuePair memberValuePair) {
 	String name = 	new String(memberValuePair.name);
+	if(name.length() == 0) return;
 	this.handle(
 		IProblem.UndefinedAnnotationMember,
 		new String[] { name, new String(annotationType.readableName())},
@@ -5283,6 +5306,7 @@ public void undefinedAnnotationValue(TypeBinding annotationType, MemberValuePair
 }
 public void undefinedLabel(BranchStatement statement) {
 	String[] arguments = new String[] {new String(statement.label)};
+	if (statement.label.length == 0) return;
 	this.handle(
 		IProblem.UndefinedLabel,
 		arguments,
@@ -5292,6 +5316,7 @@ public void undefinedLabel(BranchStatement statement) {
 }
 // can only occur inside binaries
 public void undefinedTypeVariableSignature(char[] variableName, ReferenceBinding binaryType) {
+	if(variableName.length == 0)
 	this.handle(
 		IProblem.UndefinedTypeVariable,
 		new String[] {new String(variableName), new String(binaryType.readableName()) },	
@@ -5466,8 +5491,13 @@ public void unresolvableReference(NameReference nameRef, Binding binding) {
 	int end = nameRef.sourceEnd;
 	if (nameRef instanceof QualifiedNameReference) {
 		QualifiedNameReference ref = (QualifiedNameReference) nameRef;
+		char[] lastToken = ref.tokens[ref.tokens.length - 1];
+		if (lastToken.length == 0) return;
 		if (ref.indexOfFirstFieldBinding >= 1)
 			end = (int) ref.sourcePositions[ref.indexOfFirstFieldBinding - 1];
+	} else {
+		SingleNameReference ref = (SingleNameReference) nameRef;
+		if (ref.token.length == 0) return;
 	}
 	this.handle(
 		IProblem.UndefinedName,
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 8fb973a..af6b09a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -46,6 +46,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 
@@ -1190,6 +1191,10 @@ class ASTConverter {
 	}
 	
 	public CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source) {
+		if(unit.compilationResult.recoveryScannerData != null) {
+			this.scanner = new RecoveryScanner(this.scanner, unit.compilationResult.recoveryScannerData.removeUnused());
+			this.docParser.scanner = this.scanner;
+		}
 		this.compilationUnitSource = source;
 		this.compilationUnitSourceLength = source.length;
 		this.scanner.setSource(source, unit.compilationResult);
@@ -1248,6 +1253,8 @@ class ASTConverter {
 			}
 			ASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(resizedProblems);
 			compilationUnit.accept(syntaxErrorPropagator);
+			ASTRecoveryPropagator recoveryPropagator = new ASTRecoveryPropagator(resizedProblems);
+			compilationUnit.accept(recoveryPropagator);
 			compilationUnit.setProblems(resizedProblems);
 		}
 		if (this.resolveBindings) {
@@ -4237,23 +4244,6 @@ class ASTConverter {
 							return;
 						}
 						break;
-					case TerminalTokens.TokenNameLBRACE :
-						count++;
-						break;
-					case TerminalTokens.TokenNameRBRACE :
-						count--;
-						break;
-					case TerminalTokens.TokenNameLPAREN :
-						count++;
-						break;
-					case TerminalTokens.TokenNameRPAREN :
-						count--;
-						break;
-					case TerminalTokens.TokenNameLBRACKET :
-						count++;
-						break;
-					case TerminalTokens.TokenNameRBRACKET :
-						count--;
 				}
 			}
 		} catch(InvalidInputException e) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 336dd65..7b851f3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -1034,6 +1034,17 @@ public abstract class ASTNode {
 	public static final int PROTECT = 4;
 
 	/**
+	 * Flag constant (bit mask, value 8) indicating that this node
+	 * or a part of this node is recovered from source that contains
+	 * a syntax error detected in the vicinity.
+	 * <p>
+	 * The standard parser (<code>ASTParser</code>) sets this
+	 * flag on a node to indicate a recovered node.
+	 * </p>
+	 */
+	public static final int RECOVERED = 8;
+	
+	/**
 	 * int containing the node type in the top 16 bits and
 	 * flags in the bottom 16 bits; none set by default.
      * <p>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index 63ec9b3..9053183 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -26,6 +26,9 @@ import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScannerData;
+import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.*;
 import org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil;
@@ -914,7 +917,15 @@ public class ASTParser {
 		}
 		switch(this.astKind) {
 			case K_STATEMENTS :
-				ConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(this.rawSource, this.sourceOffset, this.sourceLength, this.compilerOptions, true);
+				ConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(this.rawSource, this.sourceOffset, this.sourceLength, this.compilerOptions, true, true);
+				RecoveryScannerData data = constructorDeclaration.compilationResult.recoveryScannerData;
+				if(data != null) {
+					Scanner scanner = converter.scanner;
+					converter.scanner = new RecoveryScanner(scanner, data.removeUnused());
+					converter.docParser.scanner = converter.scanner;
+					converter.scanner.setSource(scanner.source);
+					
+				}
 				RecordedParsingInformation recordedParsingInformation = codeSnippetParsingUtil.recordedParsingInformation;
 				int[][] comments = recordedParsingInformation.commentPositions;
 				if (comments != null) {
@@ -1000,6 +1011,8 @@ public class ASTParser {
 	private void propagateErrors(ASTNode astNode, IProblem[] problems) {
 		ASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(problems);
 		astNode.accept(syntaxErrorPropagator);
+		ASTRecoveryPropagator recoveryPropagator = new ASTRecoveryPropagator(problems);
+		astNode.accept(recoveryPropagator);
 	}
 	
 	private void rootNodeToCompilationUnit(AST ast, CompilationUnit compilationUnit, ASTNode node, RecordedParsingInformation recordedParsingInformation) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
new file mode 100644
index 0000000..939969c
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.dom;
+
+import org.eclipse.jdt.core.compiler.IProblem;
+
+/**
+ * Internal AST visitor for propagating syntax errors.
+ */
+class ASTRecoveryPropagator extends DefaultASTVisitor {
+	private IProblem[] problems;
+	
+	ASTRecoveryPropagator(IProblem[] problems) {
+		// visit Javadoc.tags() as well
+		this.problems = problems;
+	}
+	
+	protected boolean visitNode(ASTNode node) {
+		return checkAndTagAsMalformed(node);
+	}
+	
+	private boolean checkAndTagAsMalformed(ASTNode node) {
+		boolean tagWithErrors = false;
+		search: for (int i = 0, max = this.problems.length; i < max; i++) {
+			IProblem problem = this.problems[i];
+			switch(problem.getID()) {
+				case IProblem.ParsingErrorOnKeywordNoSuggestion :
+				case IProblem.ParsingErrorOnKeyword :
+				case IProblem.ParsingError :
+				case IProblem.ParsingErrorNoSuggestion :
+				case IProblem.ParsingErrorInsertTokenBefore :
+				case IProblem.ParsingErrorInsertTokenAfter :
+				case IProblem.ParsingErrorDeleteToken :
+				case IProblem.ParsingErrorDeleteTokens :
+				case IProblem.ParsingErrorMergeTokens :
+				case IProblem.ParsingErrorInvalidToken :
+				case IProblem.ParsingErrorMisplacedConstruct :
+				case IProblem.ParsingErrorReplaceTokens :
+				case IProblem.ParsingErrorNoSuggestionForTokens :
+				case IProblem.ParsingErrorUnexpectedEOF :
+				case IProblem.ParsingErrorInsertToComplete :
+				case IProblem.ParsingErrorInsertToCompleteScope :
+				case IProblem.ParsingErrorInsertToCompletePhrase :
+				case IProblem.EndOfSource :
+				case IProblem.InvalidHexa :
+				case IProblem.InvalidOctal :
+				case IProblem.InvalidCharacterConstant :
+				case IProblem.InvalidEscape :
+				case IProblem.InvalidInput :
+				case IProblem.InvalidUnicodeEscape :
+				case IProblem.InvalidFloat :
+				case IProblem.NullSourceString :
+				case IProblem.UnterminatedString :
+				case IProblem.UnterminatedComment :
+				case IProblem.InvalidDigit :
+					break;
+				default:
+					continue search;
+			}
+			int problemStart = problem.getSourceStart();
+			int problemEnd = problem.getSourceEnd();
+			int start = node.getStartPosition();
+			int end = start + node.getLength();
+			if ((start <= problemStart) && (problemStart <= end) ||
+					(start <= problemEnd) && (problemEnd <= end)) {
+				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+				tagWithErrors = true;
+			}
+		}
+		return tagWithErrors;
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index ed5123b..566fc58 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -18,6 +18,14 @@ class DefaultASTVisitor extends ASTVisitor {
 	public DefaultASTVisitor() {
 		super();
 	}
+	
+	/**
+	 * 
+	 */
+	public DefaultASTVisitor(boolean visitDocTags) {
+		super(visitDocTags);
+	}
+	
 	protected boolean visitNode(ASTNode node) {
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index cc942e1..d000a93 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -267,7 +267,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 			return this.newCodeFormatter2.format(source, (Block) node);
 		}
 		
-		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), getDefaultCompilerOptions(), true);
+		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), getDefaultCompilerOptions(), true, false);
 		
 		if (constructorDeclaration.statements == null) {
 			// a problem occured while parsing the source
@@ -469,7 +469,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		}
 
 		// probe for statements
-		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), getDefaultCompilerOptions(), true);
+		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), getDefaultCompilerOptions(), true, false);
 		if (constructorDeclaration.statements != null) {
 			if (USE_NEW_FORMATTER) {
 				ASTParser parser = ASTParser.newParser(AST.JLS3);
diff --git a/org.eclipse.jdt.core/grammar/java_1_5.g b/org.eclipse.jdt.core/grammar/java_1_5.g
index 8881e65..01382a2 100644
--- a/org.eclipse.jdt.core/grammar/java_1_5.g
+++ b/org.eclipse.jdt.core/grammar/java_1_5.g
@@ -28,11 +28,15 @@ $break
 
 
 $readableName 
-/.1#$rule_number=./
+/.1#$rule_number#./
 $compliance
-/.2#$rule_number=./
+/.2#$rule_number#./
 $recovery
-/.2#$rule_number= recovery./
+/.2#$rule_number# recovery./
+$recovery_template
+/.3#$rule_number#./
+$no_statements_recovery
+/.4#$rule_number# 1./
 -- here it starts really ------------------------------------------
 $Terminals
 
@@ -483,6 +487,7 @@ InterfaceType ::= ClassOrInterfaceType
 
 ClassBody ::= '{' ClassBodyDeclarationsopt '}'
 /:$readableName ClassBody:/
+/:$no_statements_recovery:/
 
 ClassBodyDeclarations ::= ClassBodyDeclaration
 ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
@@ -612,6 +617,7 @@ MethodHeaderName ::= Modifiersopt Type 'Identifier' '('
 MethodHeaderRightParen ::= ')'
 /.$putCase consumeMethodHeaderRightParen(); $break ./
 /:$readableName ):/
+/:$recovery_template ):/
 
 MethodHeaderExtendedDims ::= Dimsopt
 /.$putCase consumeMethodHeaderExtendedDims(); $break ./
@@ -656,6 +662,7 @@ ClassTypeElt ::= ClassType
 MethodBody ::= NestedMethod '{' BlockStatementsopt '}' 
 /.$putCase consumeMethodBody(); $break ./
 /:$readableName MethodBody:/
+/:$no_statements_recovery:/
 
 NestedMethod ::= $empty
 /.$putCase consumeNestedMethod(); $break ./
@@ -810,6 +817,7 @@ ArrayInitializer ::= '{' PushLeftBrace VariableInitializers '}'
 ArrayInitializer ::= '{' PushLeftBrace VariableInitializers , '}'
 /.$putCase consumeArrayInitializer(); $break ./
 /:$readableName ArrayInitializer:/
+/:$recovery_template Identifier:/
 
 VariableInitializers ::= VariableInitializer
 VariableInitializers ::= VariableInitializers ',' VariableInitializer
@@ -1087,9 +1095,11 @@ Finally ::= 'finally'    Block
 PushLPAREN ::= '('
 /.$putCase consumeLeftParen(); $break ./
 /:$readableName (:/
+/:$recovery_template (:/
 PushRPAREN ::= ')'
 /.$putCase consumeRightParen(); $break ./
 /:$readableName ):/
+/:$recovery_template ):/
 
 Primary -> PrimaryNoNewArray
 Primary -> ArrayCreationWithArrayInitializer
@@ -1174,6 +1184,7 @@ ClassBodyopt ::= $empty --test made using null as contents
 /.$putCase consumeClassBodyopt(); $break ./
 ClassBodyopt ::= EnterAnonymousClassBody ClassBody
 /:$readableName ClassBody:/
+/:$no_statements_recovery:/
 
 EnterAnonymousClassBody ::= $empty
 /.$putCase consumeEnterAnonymousClassBody(); $break ./
@@ -1448,9 +1459,11 @@ AssignmentOperator ::= '^='
 AssignmentOperator ::= '|='
 /.$putCase consumeAssignmentOperator(OR); $break ./
 /:$readableName AssignmentOperator:/
+/:$recovery_template =:/
 
 Expression -> AssignmentExpression
 /:$readableName Expression:/
+/:$recovery_template Identifier:/
 
 -- The following rules are for optional nonterminals.
 --
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index ab72902..281c18f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -657,6 +657,13 @@ public final class JavaCore extends Plugin {
 	/**
 	 * Possible  configurable option ID.
 	 * @see #getDefaultOptions()
+	 * @since 3.2
+	 */
+	//TODO It is a temporary option. It will removed before 3.2 release
+	public static final String COMPILER_STATEMENTS_RECOVERY = PLUGIN_ID + ".compiler.statementsRecovery"; //$NON-NLS-1$
+	/**
+	 * Possible  configurable option ID.
+	 * @see #getDefaultOptions()
 	 */
 	public static final String CORE_JAVA_BUILD_ORDER = PLUGIN_ID + ".computeJavaBuildOrder"; //$NON-NLS-1$
 	/**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
index eeea18b..8279785 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
@@ -62,6 +62,8 @@ public DocumentElementParser(
 	intArrayStack = new int[30][];
 	this.options = options;
 	this.javadocParser.checkDocComment = false;
+	
+	this.setStatementsRecovery(false);
 }
 /*
  * Will clear the comment stack when looking
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
index c80be1a..8032bf5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
@@ -43,7 +43,8 @@ public class JavaCorePreferenceInitializer extends AbstractPreferenceInitializer
 		defaultOptionsMap.put(JavaCore.COMPILER_TASK_CASE_SENSITIVE, JavaCore.ENABLED);
 		defaultOptionsMap.put(JavaCore.COMPILER_DOC_COMMENT_SUPPORT, JavaCore.ENABLED);
 		defaultOptionsMap.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, JavaCore.ERROR);
-	
+		defaultOptionsMap.put(JavaCore.COMPILER_STATEMENTS_RECOVERY, JavaCore.DISABLED); //TODO It is a temporary option
+		
 		// Builder settings
 		defaultOptionsMap.put(JavaCore.CORE_JAVA_BUILD_RESOURCE_COPY_FILTER, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH, JavaCore.ABORT); 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
index 50ae3af..175fe64 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
@@ -415,6 +415,7 @@ protected Compiler newCompiler() {
 
 	// enable the compiler reference info support
 	options.produceReferenceInfo = true;
+	options.performStatementsRecovery = false;
 	
 	org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment env = newCompiler.lookupEnvironment;
 	synchronized (env) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
index 1346bde..c293719 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeSnippetParsingUtil.java
@@ -62,7 +62,8 @@ public class CodeSnippetParsingUtil {
 					new DefaultProblemFactory(Locale.getDefault()));
 					
 		CommentRecorderParser parser = new CommentRecorderParser(problemReporter, false);
-
+		parser.setStatementsRecovery(false);
+		
 		ICompilationUnit sourceUnit = 
 			new CompilationUnit(
 				source, 
@@ -158,11 +159,11 @@ public class CodeSnippetParsingUtil {
 		return result;
 	}
 
-	public ConstructorDeclaration parseStatements(char[] source, Map settings, boolean recordParsingInformation) {
-		return parseStatements(source, 0, source.length, settings, recordParsingInformation);
+	public ConstructorDeclaration parseStatements(char[] source, Map settings, boolean recordParsingInformation, boolean enabledStatementRecovery) {
+		return parseStatements(source, 0, source.length, settings, recordParsingInformation, enabledStatementRecovery);
 	}
 	
-	public ConstructorDeclaration parseStatements(char[] source, int offset, int length, Map settings, boolean recordParsingInformation) {
+	public ConstructorDeclaration parseStatements(char[] source, int offset, int length, Map settings, boolean recordParsingInformation, boolean enabledStatementRecovery) {
 		if (source == null) {
 			throw new IllegalArgumentException();
 		}
@@ -172,6 +173,7 @@ public class CodeSnippetParsingUtil {
 					compilerOptions, 
 					new DefaultProblemFactory(Locale.getDefault()));
 		CommentRecorderParser parser = new CommentRecorderParser(problemReporter, false);
+		parser.setStatementsRecovery(enabledStatementRecovery);
 		
 		ICompilationUnit sourceUnit = 
 			new CompilationUnit(
commit 1a8faae82ee05c56b97b490a2a93ff4926cafdc0
Author: David Audel <daudel>
Date:   Wed Jan 18 09:38:20 2006 +0000

    HEAD - Robust AST - bug 42253

11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
11	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
index 528915d..9a88e88 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
@@ -1,3 +1,14 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
 package org.eclipse.jdt.internal.compiler.parser;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
index be74fa7..ea8b84a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScannerData.java
@@ -1,6 +1,14 @@
-/**
- * 
- */
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
 package org.eclipse.jdt.internal.compiler.parser;
 
 public class RecoveryScannerData {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
index b2f61ca..1e77997 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
@@ -408,7 +408,7 @@ public char[] getCurrentIdentifierSource() {
 public int getCurrentTokenEndPosition(){
 	return this.currentPosition - 1;
 }
-public final char[] getCurrentTokenSource() {
+public char[] getCurrentTokenSource() {
 	// Return the token REAL source (aka unicodes are precomputed)
 
 	char[] result;
commit 314f5d19dc6dfaf646f95bec3ee76ef6107ec5f3
Author: David Audel <daudel>
Date:   Wed Jan 18 12:22:39 2006 +0000

    HEAD - Robust AST - bug 42253

3	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
4	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 6eca6b3..2b18c9d 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -60,6 +60,9 @@ What's new in this drop</h2>
 	 the classpath entry is optional. </li>
 <li>Added support for statement recovery in Parser<br>
 	 Currently this new behavior is incomplete (mapping non-terminals -> terminals) and disabled. The option JavaCore.COMPILER_STATEMENTS_RECOVERY must be set to ENABLED to use it (It's a temporary option).</li>
+<li>Added API for DOM ASTNode flag: <code>ASTNode.RECOVERED</code><br>
+	 It is a flag constant indicating that this node or a part of this node is recovered
+	 from source that contains a syntax error detected in the vicinity.</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 7b851f3..75e7c27 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -2222,6 +2222,8 @@ public abstract class ASTNode {
 	 * created by ASTParser</li>
 	 * <li>{@link #PROTECT} - indicates node is protected
 	 * from further modification</li>
+	 * <li>{@link #RECOVERED} - indicates node or a part of this node
+	 *  is recovered from source that contains a syntax error</li>
 	 * </ul>
 	 * Other bit positions are reserved for future use.
 	 * </p>
@@ -2245,6 +2247,8 @@ public abstract class ASTNode {
 	 * created by ASTParser</li>
 	 * <li>{@link #PROTECT} - indicates node is protected
 	 * from further modification</li>
+	 * <li>{@link #RECOVERED} - indicates node or a part of this node
+	 *  is recovered from source that contains a syntax error</li>
 	 * </ul>
 	 * Other bit positions are reserved for future use.
 	 * </p>
commit d4d7f9bf434c822e7818dfb358fa83468e120df6
Author: David Audel <daudel>
Date:   Fri Jan 20 12:10:35 2006 +0000

    HAED - Robust AST - bug 42253

4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterRecoveryTest.java
5	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
3	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
29	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
11	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterRecoveryTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterRecoveryTest.java
index 83dd22a..6379e59 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterRecoveryTest.java
@@ -85,7 +85,7 @@ public class ASTConverterRecoveryTest extends ConverterTestSetup {
 			"}\n");
 		
 		char[] source = this.workingCopies[0].getSource().toCharArray();
-		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true);
+		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true, true);
 		
 		assertASTNodeEquals(
 			"package test;\n" + 
@@ -152,7 +152,7 @@ public class ASTConverterRecoveryTest extends ConverterTestSetup {
 			"}\n");
 		
 		char[] source = this.workingCopies[0].getSource().toCharArray();
-		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true);
+		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true, true);
 		
 		assertASTNodeEquals(
 			"package test;\n" + 
@@ -220,7 +220,7 @@ public class ASTConverterRecoveryTest extends ConverterTestSetup {
 			"}\n");
 		
 		char[] source = this.workingCopies[0].getSource().toCharArray();
-		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true);
+		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true, true);
 		
 		assertASTNodeEquals(
 			"package test;\n" + 
@@ -288,7 +288,7 @@ public class ASTConverterRecoveryTest extends ConverterTestSetup {
 			"}\n");
 		
 		char[] source = this.workingCopies[0].getSource().toCharArray();
-		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true);
+		ASTNode result = runConversion(AST.JLS3, this.workingCopies[0], true, true);
 		
 		assertASTNodeEquals(
 			"package test;\n" + 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
index 6b45034..a5b2343 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
@@ -132,9 +132,14 @@ public abstract class ConverterTestSetup extends AbstractASTTests {
 	}
 	
 	public ASTNode runConversion(int astLevel, ICompilationUnit unit, boolean resolveBindings) {
+		return runConversion(astLevel, unit, resolveBindings, false);
+	}
+	
+	public ASTNode runConversion(int astLevel, ICompilationUnit unit, boolean resolveBindings, boolean statementsRecovery) {
 		ASTParser parser = ASTParser.newParser(astLevel);
 		parser.setSource(unit);
 		parser.setResolveBindings(resolveBindings);
+		parser.setStatementsRecovery(statementsRecovery);
 		return parser.createAST(null);
 	}
 
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 4b85bcd..209f117 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -64,6 +64,9 @@ What's new in this drop</h2>
 <li>Added API for DOM ASTNode flag: <code>ASTNode.RECOVERED</code><br>
 	 It is a flag constant indicating that this node or a part of this node is recovered
 	 from source that contains a syntax error detected in the vicinity.</li>
+<li>Added API: <code>ASTParser#setStatementsRecovery(boolean enabled)</code><br>
+	 This method allow to enable statements recovery for ASTParser.
+	 Statements recovery is disabled by default.</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
index 878aa1e..5d25d75 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
@@ -155,12 +155,16 @@ public class Compiler implements ITypeRequestor, ProblemSeverities {
 		final ICompilerRequestor requestor,
 		IProblemFactory problemFactory,
 		boolean parseLiteralExpressionsAsConstants,
-		boolean storeAnnotations) {
+		boolean storeAnnotations,
+		boolean statementsRecovery) {
 
 		// create a problem handler given a handling policy
 		this.options = new CompilerOptions(settings);
 		this.options.parseLiteralExpressionsAsConstants = parseLiteralExpressionsAsConstants;
 		this.options.storeAnnotations = storeAnnotations;
+		this.options.performStatementsRecovery =
+			statementsRecovery &&
+			this.options.performStatementsRecovery;// TODO temporary code to take into account the temporary JavaCore options
 		
 		// wrap requestor in DebugRequestor if one is specified
 		if(DebugRequestor == null) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index 9053183..fdf6ef7 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -138,6 +138,11 @@ public class ASTParser {
 	private boolean partial = false;
 
 	/**
+	 * Request for a statements recovery. Defaults to <code>false</code>.
+     */
+	private boolean statementsRecovery;
+	
+	/**
 	 * The focal point for a partial AST request.
      * Only used when <code>partial</code> is <code>true</code>.
      */
@@ -503,6 +508,23 @@ public class ASTParser {
 		this.sourceLength = length;
 	}
 	
+	/**
+	 * Requests that the compiler should perform statements recovery.
+	 * When statements recovery is enabled the compiler try to create statement nodes
+	 * from code containing syntax errors
+     * <p>
+     * Default to <code>false</code>.
+     * </p>
+	 * 
+	 * @param enabled <code>true</code> if statements containing syntax errors are wanted, 
+	 *   and <code>false</code> if these statements aren't wanted.
+	 *   
+	 * @since 3.2
+	 */
+	public void setStatementsRecovery(boolean enabled) {
+		this.statementsRecovery = enabled;
+	}
+	
     /**
      * Sets the working copy owner using when resolving bindings, where
      * <code>null</code> means the primary owner. Defaults to the primary owner.
@@ -664,7 +686,7 @@ public class ASTParser {
 			if (this.resolveBindings) {
 				if (this.project == null)
 					throw new IllegalStateException("project not specified"); //$NON-NLS-1$
-				CompilationUnitResolver.resolve(compilationUnits, bindingKeys, requestor, this.apiLevel, this.compilerOptions, this.project, this.workingCopyOwner, monitor);
+				CompilationUnitResolver.resolve(compilationUnits, bindingKeys, requestor, this.apiLevel, this.compilerOptions, this.project, this.workingCopyOwner, this.statementsRecovery, monitor);
 			} else {
 				CompilationUnitResolver.parse(compilationUnits, requestor, this.apiLevel, this.compilerOptions, monitor);
 			}
@@ -717,7 +739,7 @@ public class ASTParser {
 		try {
 			if (this.project == null)
 				throw new IllegalStateException("project not specified"); //$NON-NLS-1$
-			return CompilationUnitResolver.resolve(elements, this.apiLevel, this.compilerOptions, this.project, this.workingCopyOwner, monitor);
+			return CompilationUnitResolver.resolve(elements, this.apiLevel, this.compilerOptions, this.project, this.workingCopyOwner, this.statementsRecovery, monitor);
 		} finally {
 	   	   // re-init defaults to allow reuse (and avoid leaking)
 	   	   initializeDefaults();
@@ -795,19 +817,22 @@ public class ASTParser {
 									searcher,
 									this.compilerOptions,
 									this.workingCopyOwner,
+									this.statementsRecovery,
 									monitor);
 						} catch (JavaModelException e) {
 							compilationUnitDeclaration = CompilationUnitResolver.parse(
 									sourceUnit,
 									searcher,
-									this.compilerOptions);
+									this.compilerOptions,
+									this.statementsRecovery);
 							needToResolveBindings = false;
 						}
 					} else {
 						compilationUnitDeclaration = CompilationUnitResolver.parse(
 								sourceUnit,
 								searcher,
-								this.compilerOptions);
+								this.compilerOptions,
+								this.statementsRecovery);
 						needToResolveBindings = false;
 					}
 					CompilationUnit result = CompilationUnitResolver.convert(
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
index aacb4c0..390f009 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
@@ -130,9 +130,10 @@ class CompilationUnitResolver extends Compiler {
 		Map settings,
 		ICompilerRequestor requestor,
 		IProblemFactory problemFactory,
+		boolean statementsRecovery,
 		IProgressMonitor monitor) {
 
-		super(environment, policy, settings, requestor, problemFactory, false, true/*store annotations in the bindings*/);
+		super(environment, policy, settings, requestor, problemFactory, false, true/*store annotations in the bindings*/, statementsRecovery);
 		this.hasCompilationAborted = false;
 		this.monitor =monitor;
 	}
@@ -367,11 +368,12 @@ class CompilationUnitResolver extends Compiler {
 		}
 	}
 	
-	public static CompilationUnitDeclaration parse(org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, NodeSearcher nodeSearcher, Map settings) {
+	public static CompilationUnitDeclaration parse(org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, NodeSearcher nodeSearcher, Map settings, boolean statementsRecovery) {
 		if (sourceUnit == null) {
 			throw new IllegalStateException();
 		}
 		CompilerOptions compilerOptions = new CompilerOptions(settings);
+		compilerOptions.performStatementsRecovery = statementsRecovery;
 		Parser parser = new CommentRecorderParser(
 			new ProblemReporter(
 					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
@@ -434,6 +436,7 @@ class CompilationUnitResolver extends Compiler {
 		Map options,
 		IJavaProject javaProject,
 		WorkingCopyOwner owner,
+		boolean statementsRecovery,
 		IProgressMonitor monitor) {
 	
 		CancelableNameEnvironment environment = null;
@@ -452,6 +455,7 @@ class CompilationUnitResolver extends Compiler {
 					options,
 					getRequestor(),
 					problemFactory, 
+					statementsRecovery,
 					monitor);
 
 			resolver.resolve(compilationUnits, bindingKeys, requestor, apiLevel, options, owner);
@@ -478,6 +482,7 @@ class CompilationUnitResolver extends Compiler {
 		NodeSearcher nodeSearcher,
 		Map options,
 		WorkingCopyOwner owner,
+		boolean statementsRecovery,
 		IProgressMonitor monitor) throws JavaModelException {
 	
 		CompilationUnitDeclaration unit = null;
@@ -494,6 +499,7 @@ class CompilationUnitResolver extends Compiler {
 					options,
 					getRequestor(),
 					problemFactory, 
+					statementsRecovery,
 					monitor);
 
 			unit = 
@@ -507,7 +513,7 @@ class CompilationUnitResolver extends Compiler {
 			if (resolver.hasCompilationAborted) {
 				// the bindings could not be resolved due to missing types in name environment
 				// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=86541
-				CompilationUnitDeclaration unitDeclaration = parse(sourceUnit, nodeSearcher, options);
+				CompilationUnitDeclaration unitDeclaration = parse(sourceUnit, nodeSearcher, options, statementsRecovery);
 				final int problemCount = unit.compilationResult.problemCount;
 				if (problemCount != 0) {
 					unitDeclaration.compilationResult.problems = new IProblem[problemCount];
@@ -545,6 +551,7 @@ class CompilationUnitResolver extends Compiler {
 		Map compilerOptions,
 		IJavaProject javaProject,
 		WorkingCopyOwner owner,
+		boolean statementsRecovery,
 		IProgressMonitor monitor) {
 
 		final int length = elements.length;
@@ -604,7 +611,7 @@ class CompilationUnitResolver extends Compiler {
 			}
 		}
 		Requestor requestor = new Requestor();
-		resolve(cus, bindingKeys, requestor, apiLevel, compilerOptions, javaProject, owner, monitor);
+		resolve(cus, bindingKeys, requestor, apiLevel, compilerOptions, javaProject, owner, statementsRecovery, monitor);
 		return requestor.bindings;
 	}
 	/*
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
index f2c777b..03d5d3d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
@@ -85,7 +85,8 @@ public class CompilationUnitProblemFinder extends Compiler {
 			requestor,
 			problemFactory,
 			creatingAST/*parse literal expressions as constants if creating ast*/,
-			creatingAST/*store annotations in the bindings if creating ast*/
+			creatingAST/*store annotations in the bindings if creating ast*/,
+			creatingAST/*perform statements recovery during parse if creating ast*/
 		);
 	}
 
commit 1ae160aec8c2770799af520f2104ef31bd7dce0c
Author: David Audel <daudel>
Date:   Fri Jan 20 14:07:17 2006 +0000

    HEAD - Robust AST - bug 42253

19	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
7	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
index 659b73b..6978b49 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
@@ -20,6 +20,7 @@ public class RecoveryScanner extends Scanner {
 	private int[] pendingTokens;
 	private int pendingTokensPtr = -1;
 	private char[] fakeTokenSource = null;
+	private boolean isInserted = true;
 	private int skipNextInsertedTokens = -1;
 
 	public boolean record = true;
@@ -121,19 +122,17 @@ public class RecoveryScanner extends Scanner {
 		this.fakeTokenSource = null;
 		
 		if(this.data.insertedTokens != null) {
-//			if(!skipNextInsertedTokens) {
-				for (int i = 0; i <= this.data.insertedTokensPtr; i++) {
-					if(this.data.insertedTokensPosition[i] == this.currentPosition - 1 && i > skipNextInsertedTokens) {
-						this.data.insertedTokenUsed[i] = true;
-						this.pendingTokens = this.data.insertedTokens[i];
-						this.pendingTokensPtr = this.data.insertedTokens[i].length - 1;
-						this.fakeTokenSource = CharOperation.NO_CHAR;
-						this.startPosition = this.currentPosition - 1;
-						this.skipNextInsertedTokens = i;
-						return this.pendingTokens[this.pendingTokensPtr--];
-					}
+			for (int i = 0; i <= this.data.insertedTokensPtr; i++) {
+				if(this.data.insertedTokensPosition[i] == this.currentPosition - 1 && i > skipNextInsertedTokens) {
+					this.data.insertedTokenUsed[i] = true;
+					this.pendingTokens = this.data.insertedTokens[i];
+					this.pendingTokensPtr = this.data.insertedTokens[i].length - 1;
+					this.fakeTokenSource = CharOperation.NO_CHAR;
+					this.startPosition = this.currentPosition - 1;
+					this.skipNextInsertedTokens = i;
+					return this.pendingTokens[this.pendingTokensPtr--];
 				}
-//			}
+			}
 			this.skipNextInsertedTokens = -1;
 		}
 
@@ -191,6 +190,14 @@ public class RecoveryScanner extends Scanner {
 		return this.fakeTokenSource != null;
 	}
 	
+	public boolean isFakeTokenInserted() {
+		return this.fakeTokenSource != null && this.isInserted;
+	}
+	
+	public boolean isFakeTokenReplaced() {
+		return this.fakeTokenSource != null && !this.isInserted;
+	}
+	
 	public void setData(RecoveryScannerData data) {
 		if(data == null) {
 			this.data = new RecoveryScannerData();
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 5741109..8d02c55 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -114,7 +114,11 @@ class ASTConverter {
 						}
 				}
 			}
-			expression.sourceEnd = this.scanner.startPosition - 1;
+			if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeTokenInserted()) {
+				expression.sourceEnd =  this.scanner.startPosition;
+			} else {
+				expression.sourceEnd = this.scanner.startPosition - 1;
+			}
 		} catch(InvalidInputException e) {
 			// ignore
 		}
@@ -4112,8 +4116,8 @@ class ASTConverter {
 				switch(token) {
 					case TerminalTokens.TokenNameCOMMA :
 					case TerminalTokens.TokenNameSEMICOLON :
-						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeToken()) {
-							return -1;
+						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeTokenInserted()) {
+							return this.scanner.startPosition;
 						}
 						return this.scanner.startPosition - 1;
 				}
commit 677c4b39a30069207f57550aec27ea9d04477c82
Author: David Audel <daudel>
Date:   Mon Jan 23 10:08:24 2006 +0000

    HEAD - Robust AST - bug 42253

2	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
65	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/ICompilationUnit.java
3	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOpenable.java
19	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
8	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
4	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 980f9d5..ec3dc4d 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -67,6 +67,8 @@ What's new in this drop</h2>
 <li>Added API: <code>ASTParser#setStatementsRecovery(boolean enabled)</code><br>
 	 This method allow to enable statements recovery for ASTParser.
 	 Statements recovery is disabled by default.</li>
+<li>Added API: <code>ICompilationUnit#reconcile(int astLevel, boolean forceProblemDetection, boolean enableStatementsRecovery, WorkingCopyOwner owner, IProgressMonitor monitor)</code><br>
+	 This method allow to enable statements recovery for reconcile operation.</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index fdf6ef7..73f170a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -510,7 +510,7 @@ public class ASTParser {
 	
 	/**
 	 * Requests that the compiler should perform statements recovery.
-	 * When statements recovery is enabled the compiler try to create statement nodes
+	 * When statements recovery is enabled the compiler tries to create statement nodes
 	 * from code containing syntax errors
      * <p>
      * Default to <code>false</code>.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ICompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ICompilationUnit.java
index 885b640..a2672bc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ICompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ICompilationUnit.java
@@ -534,6 +534,71 @@ boolean isWorkingCopy();
 CompilationUnit reconcile(int astLevel, boolean forceProblemDetection, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException;
 
 /**
+ * Reconciles the contents of this working copy, sends out a Java delta
+ * notification indicating the nature of the change of the working copy since
+ * the last time it was either reconciled or made consistent 
+ * ({@link IOpenable#makeConsistent(IProgressMonitor)}), and returns a
+ * compilation unit AST if requested.
+ * <p>
+ * It performs the reconciliation by locally caching the contents of 
+ * the working copy, updating the contents, then creating a delta 
+ * over the cached contents and the new contents, and finally firing
+ * this delta.
+ * <p>
+ * The boolean argument allows to force problem detection even if the
+ * working copy is already consistent.
+ * </p>
+ * <p>
+ * This functionality allows to specify a working copy owner which is used
+ * during problem detection. All references contained in the working copy are
+ * resolved against other units; for which corresponding owned working copies
+ * are going to take precedence over their original compilation units. If
+ * <code>null</code> is passed in, then the primary working copy owner is used.
+ * </p>
+ * <p>
+ * Compilation problems found in the new contents are notified through the
+ * {@link IProblemRequestor} interface which was passed at
+ * creation, and no longer as transient markers.
+ * </p>
+ * <p>
+ * Note: Since 3.0, added/removed/changed inner types generate change deltas.
+ * </p>
+ * <p>
+ * If requested, a DOM AST representing the compilation unit is returned.
+ * Its bindings are computed only if the problem requestor is active, or if the
+ * problem detection is forced. This method returns <code>null</code> if the
+ * creation of the DOM AST was not requested, or if the requested level of AST
+ * API is not supported, or if the working copy was already consistent.
+ * </p>
+ * 
+ * <p>
+ * If statements recovery is enabled then this method tries to rebuild statements
+ * with syntax error. Otherwise statements with syntax error won't be present in
+ * the returning DOM AST.
+ * </p>
+ *
+ * @param astLevel either {@link #NO_AST} if no AST is wanted,
+ * or the {@linkplain AST#newAST(int) AST API level} of the AST if one is wanted
+ * @param forceProblemDetection boolean indicating whether problem should be 
+ *   recomputed even if the source hasn't changed
+ * @param enableStatementsRecovery if <code>true</code> statements recovery is enabled.
+ * @param owner the owner of working copies that take precedence over the 
+ *   original compilation units, or <code>null</code> if the primary working
+ *   copy owner should be used
+ * @param monitor a progress monitor
+ * @return the compilation unit AST or <code>null</code> if not requested, 
+ *    or if the requested level of AST API is not supported,
+ *    or if the working copy was consistent
+ * @throws JavaModelException if the contents of the original element
+ *		cannot be accessed. Reasons include:
+ * <ul>
+ * <li> The original Java element does not exist (ELEMENT_DOES_NOT_EXIST)</li>
+ * </ul>
+ * @since 3.2
+ */
+CompilationUnit reconcile(int astLevel, boolean forceProblemDetection, boolean enableStatementsRecovery, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException;
+
+/**
  * Restores the contents of this working copy to the current contents of
  * this working copy's original element. Has no effect if this element
  * is not a working copy.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOpenable.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOpenable.java
index b07e67e..b8e579b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOpenable.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOpenable.java
@@ -123,7 +123,9 @@ boolean isOpen();
  * by updating the element's structure and properties as necessary.
  *<p>
  * Note: Using this functionality on a working copy will interfere with any
- * subsequent reconciling operation. Indeed, the next {@link ICompilationUnit#reconcile}
+ * subsequent reconciling operation. Indeed, the next
+ * {@link ICompilationUnit#reconcile(int, boolean, WorkingCopyOwner, IProgressMonitor)} or
+ * {@link ICompilationUnit#reconcile(int, boolean, boolean, WorkingCopyOwner, IProgressMonitor)}
  * operation will not account for changes which occurred before an
  * explicit use of {@link #makeConsistent(IProgressMonitor)}
  * <p>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
index 35ab29b..065e1bd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
@@ -174,7 +174,7 @@ protected boolean buildStructure(OpenableElementInfo info, final IProgressMonito
 			if (problems == null) {
 				// report problems to the problem requestor
 				problems = new HashMap();
-				compilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, pm);
+				compilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, true, pm);
 				try {
 					perWorkingCopyInfo.beginReporting();
 					for (Iterator iteraror = problems.values().iterator(); iteraror.hasNext();) {
@@ -189,7 +189,7 @@ protected boolean buildStructure(OpenableElementInfo info, final IProgressMonito
 				}
 			} else {
 				// collect problems
-				compilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, pm);
+				compilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, true, pm);
 			}
 		}
 		
@@ -1066,14 +1066,14 @@ protected void openParent(Object childInfo, HashMap newElements, IProgressMonito
  * @deprecated
  */
 public IMarker[] reconcile() throws JavaModelException {
-	reconcile(NO_AST, false/*don't force problem detection*/, null/*use primary owner*/, null/*no progress monitor*/);
+	reconcile(NO_AST, false/*don't force problem detection*/, false, null/*use primary owner*/, null/*no progress monitor*/);
 	return null;
 }
 /**
  * @see ICompilationUnit#reconcile(int, boolean, WorkingCopyOwner, IProgressMonitor)
  */
 public void reconcile(boolean forceProblemDetection, IProgressMonitor monitor) throws JavaModelException {
-	reconcile(NO_AST, forceProblemDetection, null/*use primary owner*/, monitor);
+	reconcile(NO_AST, forceProblemDetection, false, null/*use primary owner*/, monitor);
 }
 
 /**
@@ -1086,6 +1086,20 @@ public org.eclipse.jdt.core.dom.CompilationUnit reconcile(
 	WorkingCopyOwner workingCopyOwner,
 	IProgressMonitor monitor)
 	throws JavaModelException {
+	return reconcile(astLevel, forceProblemDetection, false, workingCopyOwner, monitor);
+}
+		
+/**
+ * @see ICompilationUnit#reconcile(int, boolean, WorkingCopyOwner, IProgressMonitor)
+ * @since 3.0
+ */
+public org.eclipse.jdt.core.dom.CompilationUnit reconcile(
+	int astLevel,
+	boolean forceProblemDetection,
+	boolean enableStatementsRecovery,
+	WorkingCopyOwner workingCopyOwner,
+	IProgressMonitor monitor)
+	throws JavaModelException {
 	
 	if (!isWorkingCopy()) return null; // Reconciling is not supported on non working copies
 	if (workingCopyOwner == null) workingCopyOwner = DefaultWorkingCopyOwner.PRIMARY;
@@ -1096,7 +1110,7 @@ public org.eclipse.jdt.core.dom.CompilationUnit reconcile(
 		stats = PerformanceStats.getStats(JavaModelManager.RECONCILE_PERF, this);
 		stats.startRun(new String(this.getFileName()));
 	}
-	ReconcileWorkingCopyOperation op = new ReconcileWorkingCopyOperation(this, astLevel, forceProblemDetection, workingCopyOwner);
+	ReconcileWorkingCopyOperation op = new ReconcileWorkingCopyOperation(this, astLevel, forceProblemDetection, enableStatementsRecovery,workingCopyOwner);
 	op.runOperation(monitor);
 	if(ReconcileWorkingCopyOperation.PERF) {
 		stats.endRun();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
index 03d5d3d..c5f6544 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
@@ -77,7 +77,8 @@ public class CompilationUnitProblemFinder extends Compiler {
 		Map settings,
 		ICompilerRequestor requestor,
 		IProblemFactory problemFactory,
-		boolean creatingAST) {
+		boolean creatingAST,
+		boolean statementsRecovery) {
 
 		super(environment,
 			policy,
@@ -86,7 +87,7 @@ public class CompilationUnitProblemFinder extends Compiler {
 			problemFactory,
 			creatingAST/*parse literal expressions as constants if creating ast*/,
 			creatingAST/*store annotations in the bindings if creating ast*/,
-			creatingAST/*perform statements recovery during parse if creating ast*/
+			statementsRecovery/*perform statements recovery during parse if creating ast*/
 		);
 	}
 
@@ -143,6 +144,7 @@ public class CompilationUnitProblemFinder extends Compiler {
 		WorkingCopyOwner workingCopyOwner,
 		HashMap problems,
 		boolean creatingAST,
+		boolean statementsRecovery,
 		IProgressMonitor monitor)
 		throws JavaModelException {
 
@@ -159,7 +161,8 @@ public class CompilationUnitProblemFinder extends Compiler {
 				project.getOptions(true),
 				getRequestor(),
 				problemFactory,
-				!creatingAST); // optimize string literal only if not creating a DOM AST
+				!creatingAST,
+				statementsRecovery); // optimize string literal only if not creating a DOM AST
 			if (parser != null) {
 				problemFinder.parser = parser;
 			}
@@ -229,10 +232,11 @@ public class CompilationUnitProblemFinder extends Compiler {
 		WorkingCopyOwner workingCopyOwner,
 		HashMap problems,
 		boolean creatingAST,
+		boolean statementsRecovery,
 		IProgressMonitor monitor)
 		throws JavaModelException {
 			
-		return process(null/*no CompilationUnitDeclaration*/, unitElement, contents, null/*use default Parser*/, workingCopyOwner, problems, creatingAST, monitor);
+		return process(null/*no CompilationUnitDeclaration*/, unitElement, contents, null/*use default Parser*/, workingCopyOwner, problems, creatingAST, statementsRecovery, monitor);
 	}
 
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java
index 7e8daa7..847b3ed 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ReconcileWorkingCopyOperation.java
@@ -36,14 +36,16 @@ public class ReconcileWorkingCopyOperation extends JavaModelOperation {
 	public boolean resolveBindings;
 	public HashMap problems;
 	boolean forceProblemDetection;
+	boolean enableStatementsRecovery;
 	WorkingCopyOwner workingCopyOwner;
 	public org.eclipse.jdt.core.dom.CompilationUnit ast;
 	public JavaElementDeltaBuilder deltaBuilder;
 	
-	public ReconcileWorkingCopyOperation(IJavaElement workingCopy, int astLevel, boolean forceProblemDetection, WorkingCopyOwner workingCopyOwner) {
+	public ReconcileWorkingCopyOperation(IJavaElement workingCopy, int astLevel, boolean forceProblemDetection, boolean enableStatementsRecovery, WorkingCopyOwner workingCopyOwner) {
 		super(new IJavaElement[] {workingCopy});
 		this.astLevel = astLevel;
 		this.forceProblemDetection = forceProblemDetection;
+		this.enableStatementsRecovery = enableStatementsRecovery;
 		this.workingCopyOwner = workingCopyOwner;
 	}
 	
@@ -147,6 +149,7 @@ public class ReconcileWorkingCopyOperation extends JavaModelOperation {
 							this.workingCopyOwner, 
 							this.problems, 
 							this.astLevel != ICompilationUnit.NO_AST/*creating AST if level is not NO_AST */, 
+							this.enableStatementsRecovery,
 							this.progressMonitor);
 					if (this.progressMonitor != null) this.progressMonitor.worked(1);
 					
commit 523f72b860e1c5f7334e13e5c75a18826c7ae1a0
Author: David Audel <daudel>
Date:   Thu Jan 26 11:09:02 2006 +0000

    HEAD - Robust AST - bug 42253

67	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
1	0	org.eclipse.jdt.core/grammar/java_1_5.g
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
index 7300ac9..f3fc9cf 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest.java
@@ -3011,6 +3011,12 @@ public void test0036() {
 		"        {\n" + 
 		"          foo();\n" + 
 		"        }\n" + 
+		"    for (; ; ) \n" + 
+		"      ;\n" + 
+		"    if (true)\n" + 
+		"        {\n" + 
+		"          foo();\n" + 
+		"        }\n" + 
 		"  }\n" + 
 		"}\n";
 	
@@ -3475,4 +3481,65 @@ public void test0041() {
 		expectedFullWithStatementRecoveryUnitToString,
 		testName);
 }
+public void test0042() {
+
+	String s = 
+		"package a;											\n"
+			+ "public class X {								\n"
+			+ "  void foo() {								\n"
+			+ "    for(int i								\n"
+			+ "  }											\n"
+			+ "}											\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    for (int i;; ; ) \n" + 
+		"      ;\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index 7386206..1d88cc5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -336,7 +336,7 @@ public class ForStatement extends Statement {
 			output.append('\n');
 			action.printStatement(tab + 1, output);
 		}
-		return output.append(';');
+		return output;
 	}
 
 	public void resolve(BlockScope upperScope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
index 296c986..0febc35 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
index 856f2e2..132dda1 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc differ
diff --git a/org.eclipse.jdt.core/grammar/java_1_5.g b/org.eclipse.jdt.core/grammar/java_1_5.g
index 01382a2..fd6c743 100644
--- a/org.eclipse.jdt.core/grammar/java_1_5.g
+++ b/org.eclipse.jdt.core/grammar/java_1_5.g
@@ -888,6 +888,7 @@ Statement -> ForStatement
 -----------------------------------------------
 Statement -> EnhancedForStatement
 /:$readableName Statement:/
+/:$recovery_template ;:/
 
 StatementNoShortIf -> StatementWithoutTrailingSubstatement
 StatementNoShortIf -> LabeledStatementNoShortIf
commit ffe39da04df0f3a3dcc2e15c0353857438ce8e35
Author: David Audel <daudel>
Date:   Wed Feb 8 12:51:14 2006 +0000

    HEAD - More Robust AST - bug 42253

3	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
24	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
11	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
147	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToIntArray.java
7	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
9	9	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
267	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index faaa44f..808d0eb 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -64,6 +64,9 @@ e.g: Element rootE| is completed to Element rootElement.
     get all the valid warning tokens, which can be used into <code>@SuppressWarnings</code>
     annotations. See bug 
     <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=126326">126326</a> for details.</li>
+<li>Changed the way to flag DOM AST nodes as RECOVERED.<br>
+Now only nodes which really contains added/removed/replaced tokens are flagged. A parent of these kind of node isn't flagged.
+Sometimes our heuristic can't recognize the really recovered node, so in this case all potentially recovered nodes are flagged.</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index a9a0db4..d1e5bba 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -2654,11 +2654,32 @@ protected void consumeEmptyMemberValueArrayInitializer() {
 }
 protected void consumeEmptyStatement() {
 	// EmptyStatement ::= ';'
-	if (this.scanner.source[this.endStatementPosition] == ';') {
+	char[] source = this.scanner.source;
+	if (source[this.endStatementPosition] == ';') {
 		pushOnAstStack(new EmptyStatement(this.endStatementPosition, this.endStatementPosition));
 	} else {
-		// we have a Unicode for the ';' (/u003B)
-		pushOnAstStack(new EmptyStatement(this.endStatementPosition - 5, this.endStatementPosition));
+		if(source.length > 5) {
+			int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
+			int pos = this.endStatementPosition - 4;
+			while (source[pos] == 'u') {
+				pos--;
+			}
+			if (source[pos] == '\\' &&
+					!((c1 = Character.getNumericValue(source[this.endStatementPosition - 3])) > 15
+						|| c1 < 0
+						|| (c2 = Character.getNumericValue(source[this.endStatementPosition - 2])) > 15
+						|| c2 < 0
+						|| (c3 = Character.getNumericValue(source[this.endStatementPosition - 1])) > 15
+						|| c3 < 0
+						|| (c4 = Character.getNumericValue(source[this.endStatementPosition])) > 15
+						|| c4 < 0) &&
+					((char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4)) == ';'){
+				// we have a Unicode for the ';' (/u003B)
+				pushOnAstStack(new EmptyStatement(pos, this.endStatementPosition));
+				return;
+			}
+		}
+		pushOnAstStack(new EmptyStatement(this.endStatementPosition, this.endStatementPosition));
 	}
 }
 protected void consumeEmptySwitchBlock() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
index 6978b49..b5bcfa2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveryScanner.java
@@ -21,6 +21,7 @@ public class RecoveryScanner extends Scanner {
 	private int pendingTokensPtr = -1;
 	private char[] fakeTokenSource = null;
 	private boolean isInserted = true;
+	private boolean precededByRemoved = false;
 	private int skipNextInsertedTokens = -1;
 
 	public boolean record = true;
@@ -120,6 +121,7 @@ public class RecoveryScanner extends Scanner {
 		}
 		
 		this.fakeTokenSource = null;
+		this.precededByRemoved = false;
 		
 		if(this.data.insertedTokens != null) {
 			for (int i = 0; i <= this.data.insertedTokensPtr; i++) {
@@ -128,6 +130,7 @@ public class RecoveryScanner extends Scanner {
 					this.pendingTokens = this.data.insertedTokens[i];
 					this.pendingTokensPtr = this.data.insertedTokens[i].length - 1;
 					this.fakeTokenSource = CharOperation.NO_CHAR;
+					this.isInserted = true;
 					this.startPosition = this.currentPosition - 1;
 					this.skipNextInsertedTokens = i;
 					return this.pendingTokens[this.pendingTokensPtr--];
@@ -148,6 +151,7 @@ public class RecoveryScanner extends Scanner {
 					this.pendingTokens = this.data.replacedTokens[i];
 					this.pendingTokensPtr = this.data.replacedTokens[i].length - 1;
 					this.fakeTokenSource = CharOperation.NO_CHAR;
+					this.isInserted = false;
 					this.currentPosition = this.data.replacedTokensEnd[i] + 1;
 					return this.pendingTokens[this.pendingTokensPtr--];
 				}
@@ -160,6 +164,7 @@ public class RecoveryScanner extends Scanner {
 						this.data.removedTokensEnd[i] >= this.currentPosition - 1) {
 					this.data.removedTokenUsed[i] = true;
 					this.currentPosition = this.data.removedTokensEnd[i] + 1;
+					this.precededByRemoved = false;
 					return getNextToken();
 				}
 			}
@@ -190,14 +195,18 @@ public class RecoveryScanner extends Scanner {
 		return this.fakeTokenSource != null;
 	}
 	
-	public boolean isFakeTokenInserted() {
+	public boolean isInsertedToken() {
 		return this.fakeTokenSource != null && this.isInserted;
 	}
 	
-	public boolean isFakeTokenReplaced() {
+	public boolean isReplacedToken() {
 		return this.fakeTokenSource != null && !this.isInserted;
 	}
 	
+	public boolean isPrecededByRemovedToken() {
+		return this.precededByRemoved;
+	}
+	
 	public void setData(RecoveryScannerData data) {
 		if(data == null) {
 			this.data = new RecoveryScannerData();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToIntArray.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToIntArray.java
new file mode 100644
index 0000000..b1d54a6
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToIntArray.java
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.util;
+
+/**
+ * Hashtable of {Object --> int[] }
+ */
+public final class HashtableOfObjectToIntArray implements Cloneable {
+	
+	// to avoid using Enumerations, walk the individual tables skipping nulls
+	public Object[] keyTable;
+	public int[][] valueTable;
+
+	public int elementSize; // number of elements in the table
+	int threshold;
+
+	public HashtableOfObjectToIntArray() {
+		this(13);
+	}
+
+	public HashtableOfObjectToIntArray(int size) {
+
+		this.elementSize = 0;
+		this.threshold = size; // size represents the expected number of elements
+		int extraRoom = (int) (size * 1.75f);
+		if (this.threshold == extraRoom)
+			extraRoom++;
+		this.keyTable = new Object[extraRoom];
+		this.valueTable = new int[extraRoom][];
+	}
+
+	public Object clone() throws CloneNotSupportedException {
+		HashtableOfObjectToIntArray result = (HashtableOfObjectToIntArray) super.clone();
+		result.elementSize = this.elementSize;
+		result.threshold = this.threshold;
+
+		int length = this.keyTable.length;
+		result.keyTable = new Object[length];
+		System.arraycopy(this.keyTable, 0, result.keyTable, 0, length);
+
+		length = this.valueTable.length;
+		result.valueTable = new int[length][];
+		System.arraycopy(this.valueTable, 0, result.valueTable, 0, length);
+		return result;
+	}
+
+	public boolean containsKey(Object key) {
+
+		int index = (key.hashCode()& 0x7FFFFFFF) % this.valueTable.length;
+		Object currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.equals(key))
+				return true;
+			index = (index + 1) % this.keyTable.length;
+		}
+		return false;
+	}
+
+	public int[] get(Object key) {
+
+		int index = (key.hashCode()& 0x7FFFFFFF) % this.valueTable.length;
+		Object currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.equals(key))
+				return this.valueTable[index];
+			index = (index + 1) % this.keyTable.length;
+		}
+		return null;
+	}
+
+	public void keysToArray(Object[] array) {
+		int index = 0;
+		for (int i=0, length=this.keyTable.length; i<length; i++) {
+			if (this.keyTable[i] != null)
+				array[index++] = this.keyTable[i];
+		}
+	}
+
+	public int[] put(Object key, int[] value) {
+
+		int index = (key.hashCode()& 0x7FFFFFFF) % this.valueTable.length;
+		Object currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.equals(key))
+				return this.valueTable[index] = value;
+			index = (index + 1) % this.keyTable.length;
+		}
+		this.keyTable[index] = key;
+		this.valueTable[index] = value;
+
+		// assumes the threshold is never equal to the size of the table
+		if (++elementSize > threshold)
+			rehash();
+		return value;
+	}
+
+	public int[] removeKey(Object key) {
+
+		int index = (key.hashCode()& 0x7FFFFFFF) % this.valueTable.length;
+		Object currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.equals(key)) {
+				int[] value = this.valueTable[index];
+				elementSize--;
+				this.keyTable[index] = null;
+				rehash();
+				return value;
+			}
+			index = (index + 1) % this.keyTable.length;
+		}
+		return null;
+	}
+
+	private void rehash() {
+
+		HashtableOfObjectToIntArray newHashtable = new HashtableOfObjectToIntArray(elementSize * 2);		// double the number of expected elements
+		Object currentKey;
+		for (int i = this.keyTable.length; --i >= 0;)
+			if ((currentKey = this.keyTable[i]) != null)
+				newHashtable.put(currentKey, this.valueTable[i]);
+
+		this.keyTable = newHashtable.keyTable;
+		this.valueTable = newHashtable.valueTable;
+		this.threshold = newHashtable.threshold;
+	}
+
+	public int size() {
+		return elementSize;
+	}
+	
+	public String toString() {
+		String s = ""; //$NON-NLS-1$
+		Object key;
+		for (int i = 0, length = this.keyTable.length; i < length; i++)
+			if ((key = this.keyTable[i]) != null)
+				s += key + " -> " + this.valueTable[i] + "\n"; 	//$NON-NLS-2$ //$NON-NLS-1$
+		return s;
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 40a08ab..6093674 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -114,7 +114,7 @@ class ASTConverter {
 						}
 				}
 			}
-			if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeTokenInserted()) {
+			if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isInsertedToken()) {
 				expression.sourceEnd =  this.scanner.startPosition;
 			} else {
 				expression.sourceEnd = this.scanner.startPosition - 1;
@@ -1196,7 +1196,8 @@ class ASTConverter {
 	
 	public CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source) {
 		if(unit.compilationResult.recoveryScannerData != null) {
-			this.scanner = new RecoveryScanner(this.scanner, unit.compilationResult.recoveryScannerData.removeUnused());
+			RecoveryScanner recoveryScanner = new RecoveryScanner(this.scanner, unit.compilationResult.recoveryScannerData.removeUnused());
+			this.scanner = recoveryScanner;
 			this.docParser.scanner = this.scanner;
 		}
 		this.compilationUnitSource = source;
@@ -1257,7 +1258,8 @@ class ASTConverter {
 			}
 			ASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(resizedProblems);
 			compilationUnit.accept(syntaxErrorPropagator);
-			ASTRecoveryPropagator recoveryPropagator = new ASTRecoveryPropagator(resizedProblems);
+			ASTRecoveryPropagator recoveryPropagator =
+				new ASTRecoveryPropagator(resizedProblems, unit.compilationResult.recoveryScannerData);
 			compilationUnit.accept(recoveryPropagator);
 			compilationUnit.setProblems(resizedProblems);
 		}
@@ -4125,13 +4127,13 @@ class ASTConverter {
 						balance --;
 						break;
 					case TerminalTokens.TokenNameCOMMA :
-						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeTokenInserted()) {
+						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isInsertedToken()) {
 							return this.scanner.startPosition;
 						}
 						if (balance == 0) return this.scanner.startPosition - 1;
 						break;
 					case TerminalTokens.TokenNameSEMICOLON :
-						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isFakeTokenInserted()) {
+						if(this.scanner instanceof RecoveryScanner && ((RecoveryScanner)this.scanner).isInsertedToken()) {
 							return this.scanner.startPosition;
 						}
 						return this.scanner.startPosition - 1;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index 73f170a..b7572bb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -970,7 +970,7 @@ public class ASTParser {
 							}
 						}
 					}
-					rootNodeToCompilationUnit(ast, compilationUnit, block, recordedParsingInformation);
+					rootNodeToCompilationUnit(ast, compilationUnit, block, recordedParsingInformation, data);
 					ast.setDefaultNodeFlag(0);
 					ast.setOriginalModificationCount(ast.modificationCount());
 					return block;
@@ -993,7 +993,7 @@ public class ASTParser {
 				compilationUnit.setLineEndTable(recordedParsingInformation.lineEnds);
 				if (expression != null) {
 					Expression expression2 = converter.convert(expression);
-					rootNodeToCompilationUnit(expression2.getAST(), compilationUnit, expression2, codeSnippetParsingUtil.recordedParsingInformation);
+					rootNodeToCompilationUnit(expression2.getAST(), compilationUnit, expression2, codeSnippetParsingUtil.recordedParsingInformation, null);
 					ast.setDefaultNodeFlag(0);
 					ast.setOriginalModificationCount(ast.modificationCount());
 					return expression2;
@@ -1016,7 +1016,7 @@ public class ASTParser {
 				compilationUnit.setLineEndTable(recordedParsingInformation.lineEnds);
 				if (nodes != null) {
 					TypeDeclaration typeDeclaration = converter.convert(nodes);
-					rootNodeToCompilationUnit(typeDeclaration.getAST(), compilationUnit, typeDeclaration, codeSnippetParsingUtil.recordedParsingInformation);
+					rootNodeToCompilationUnit(typeDeclaration.getAST(), compilationUnit, typeDeclaration, codeSnippetParsingUtil.recordedParsingInformation, null);
 					ast.setDefaultNodeFlag(0);
 					ast.setOriginalModificationCount(ast.modificationCount());
 					return typeDeclaration;
@@ -1033,14 +1033,14 @@ public class ASTParser {
 		throw new IllegalStateException();
 	}
 
-	private void propagateErrors(ASTNode astNode, IProblem[] problems) {
+	private void propagateErrors(ASTNode astNode, IProblem[] problems, RecoveryScannerData data) {
 		ASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(problems);
 		astNode.accept(syntaxErrorPropagator);
-		ASTRecoveryPropagator recoveryPropagator = new ASTRecoveryPropagator(problems);
+		ASTRecoveryPropagator recoveryPropagator = new ASTRecoveryPropagator(problems, data);
 		astNode.accept(recoveryPropagator);
 	}
 	
-	private void rootNodeToCompilationUnit(AST ast, CompilationUnit compilationUnit, ASTNode node, RecordedParsingInformation recordedParsingInformation) {
+	private void rootNodeToCompilationUnit(AST ast, CompilationUnit compilationUnit, ASTNode node, RecordedParsingInformation recordedParsingInformation, RecoveryScannerData data) {
 		final int problemsCount = recordedParsingInformation.problemsCount;
 		switch(node.getNodeType()) {
 			case ASTNode.BLOCK :
@@ -1050,7 +1050,7 @@ public class ASTParser {
 						// propagate and record problems
 						final IProblem[] problems = recordedParsingInformation.problems;
 						for (int i = 0, max = block.statements().size(); i < max; i++) {
-							propagateErrors((ASTNode) block.statements().get(i), problems);
+							propagateErrors((ASTNode) block.statements().get(i), problems, data);
 						}
 						compilationUnit.setProblems(problems);
 					}
@@ -1068,7 +1068,7 @@ public class ASTParser {
 						// propagate and record problems
 						final IProblem[] problems = recordedParsingInformation.problems;
 						for (int i = 0, max = typeDeclaration.bodyDeclarations().size(); i < max; i++) {
-							propagateErrors((ASTNode) typeDeclaration.bodyDeclarations().get(i), problems);
+							propagateErrors((ASTNode) typeDeclaration.bodyDeclarations().get(i), problems, data);
 						}
 						compilationUnit.setProblems(problems);
 					}
@@ -1081,7 +1081,7 @@ public class ASTParser {
 					if (problemsCount != 0) {
 						// propagate and record problems
 						final IProblem[] problems = recordedParsingInformation.problems;
-						propagateErrors(expression, problems);
+						propagateErrors(expression, problems, data);
 						compilationUnit.setProblems(problems);
 					}
 					ExpressionStatement expressionStatement = ast.newExpressionStatement(expression);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
index 939969c..3bc17ab 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
@@ -11,27 +11,282 @@
 
 package org.eclipse.jdt.core.dom;
 
+import java.util.Vector;
+
 import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.parser.RecoveryScannerData;
+import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToIntArray;
 
 /**
  * Internal AST visitor for propagating syntax errors.
  */
 class ASTRecoveryPropagator extends DefaultASTVisitor {
+	private static final int NOTHING = -1;
+	HashtableOfObjectToIntArray endingTokens = new HashtableOfObjectToIntArray();
+	{
+		this.endingTokens.put(AnonymousClassDeclaration.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(ArrayAccess.class, new int[]{TerminalTokens.TokenNameRBRACKET});
+		this.endingTokens.put(ArrayCreation.class, new int[]{NOTHING, TerminalTokens.TokenNameRBRACKET});
+		this.endingTokens.put(ArrayInitializer.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(ArrayType.class, new int[]{TerminalTokens.TokenNameRBRACKET});
+		this.endingTokens.put(AssertStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(Block.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(BooleanLiteral.class, new int[]{TerminalTokens.TokenNamefalse, TerminalTokens.TokenNametrue});
+		this.endingTokens.put(BreakStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(CharacterLiteral.class, new int[]{TerminalTokens.TokenNameCharacterLiteral});
+		this.endingTokens.put(ClassInstanceCreation.class, new int[]{TerminalTokens.TokenNameRBRACE, TerminalTokens.TokenNameRPAREN});
+		this.endingTokens.put(ConstructorInvocation.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(ContinueStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(DoStatement.class, new int[]{TerminalTokens.TokenNameRPAREN});
+		this.endingTokens.put(EmptyStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(ExpressionStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(FieldDeclaration.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(ImportDeclaration.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(Initializer.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(MethodDeclaration.class, new int[]{NOTHING, TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(MethodInvocation.class, new int[]{TerminalTokens.TokenNameRPAREN});
+		this.endingTokens.put(NullLiteral.class, new int[]{TerminalTokens.TokenNamenull});
+		this.endingTokens.put(NumberLiteral.class, new int[]{TerminalTokens.TokenNameIntegerLiteral, TerminalTokens.TokenNameLongLiteral, TerminalTokens.TokenNameFloatingPointLiteral, TerminalTokens.TokenNameDoubleLiteral});
+		this.endingTokens.put(PackageDeclaration.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(ParenthesizedExpression.class, new int[]{TerminalTokens.TokenNameRPAREN});
+		this.endingTokens.put(PostfixExpression.class, new int[]{TerminalTokens.TokenNamePLUS_PLUS, TerminalTokens.TokenNameMINUS_MINUS});
+		this.endingTokens.put(PrimitiveType.class, new int[]{TerminalTokens.TokenNamebyte, TerminalTokens.TokenNameshort, TerminalTokens.TokenNamechar, TerminalTokens.TokenNameint, TerminalTokens.TokenNamelong, TerminalTokens.TokenNamefloat, TerminalTokens.TokenNameboolean, TerminalTokens.TokenNamedouble, TerminalTokens.TokenNamevoid});
+		this.endingTokens.put(ReturnStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(SimpleName.class, new int[]{TerminalTokens.TokenNameIdentifier});
+		this.endingTokens.put(SingleVariableDeclaration.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(StringLiteral.class, new int[]{TerminalTokens.TokenNameStringLiteral});
+		this.endingTokens.put(SuperConstructorInvocation.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(SuperMethodInvocation.class, new int[]{TerminalTokens.TokenNameRPAREN});
+		this.endingTokens.put(SwitchCase.class, new int[]{TerminalTokens.TokenNameCOLON});
+		this.endingTokens.put(SwitchStatement.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(SynchronizedStatement.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(ThisExpression.class, new int[]{TerminalTokens.TokenNamethis});
+		this.endingTokens.put(ThrowStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(TypeDeclaration.class, new int[]{TerminalTokens.TokenNameRBRACE});
+		this.endingTokens.put(TypeLiteral.class, new int[]{TerminalTokens.TokenNameclass});
+		this.endingTokens.put(VariableDeclarationStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+	}
+
 	private IProblem[] problems;
+	private boolean[] usedOrIrrelevantProblems;
+	
+	private RecoveryScannerData data;
+	private int blockDepth = 0;
+	private int lastEnd;
+	
+	private int[] insertedTokensKind;
+	private int[] insertedTokensPosition;
+	private boolean[] insertedTokensFlagged;
+	
+	private boolean[] removedTokensFlagged;
+	private boolean[] replacedTokensFlagged;
+	
+	private Vector stack = new Vector();
 	
-	ASTRecoveryPropagator(IProblem[] problems) {
+	ASTRecoveryPropagator(IProblem[] problems, RecoveryScannerData data) {
 		// visit Javadoc.tags() as well
 		this.problems = problems;
+		this.usedOrIrrelevantProblems = new boolean[problems.length];
+		
+		this.data = data;
+		
+		if(this.data != null) {
+			
+			int length = 0;
+			for (int i = 0; i < data.insertedTokensPtr + 1; i++) {
+				length += data.insertedTokens[i].length;
+			}
+			this.insertedTokensKind = new int[length];
+			this.insertedTokensPosition = new int[length];
+			this.insertedTokensFlagged = new boolean[length];
+			int tokenCount = 0;
+			for (int i = 0; i < data.insertedTokensPtr + 1; i++) {
+				for (int j = 0; j < data.insertedTokens[i].length; j++) {
+					this.insertedTokensKind[tokenCount] = data.insertedTokens[i][j];
+					this.insertedTokensPosition[tokenCount] = data.insertedTokensPosition[i];
+					tokenCount++;
+				}
+			}
+			
+			if(data.removedTokensPtr != -1) {
+				this.removedTokensFlagged = new boolean[data.removedTokensPtr + 1];
+			}
+			if(data.replacedTokensPtr != -1) {
+				this.replacedTokensFlagged = new boolean[data.replacedTokensPtr + 1];
+			}
+		}
+	}
+
+	public void endVisit(Block node) {
+		this.blockDepth--;
+		if(this.blockDepth <= 0) {
+			flagNodeWithInsertedTokens();
+		}
+		super.endVisit(node);
+	}
+
+	
+
+	public boolean visit(Block node) {
+		boolean visitChildren = super.visit(node);
+		this.blockDepth++;
+		return visitChildren;
 	}
 	
 	protected boolean visitNode(ASTNode node) {
-		return checkAndTagAsMalformed(node);
+		if(this.blockDepth > 0) {
+			int start = node.getStartPosition();
+			int end = start + node.getLength() - 1;
+			
+			// continue to visit the node only if it contains tokens modifications
+			
+			if(this.insertedTokensFlagged != null) {
+				for (int i = 0; i < this.insertedTokensFlagged.length; i++) {
+					if(this.insertedTokensPosition[i] >= start &&
+							this.insertedTokensPosition[i] <= end) {
+						return true;
+					}
+				}
+			}
+			
+			if(this.removedTokensFlagged != null) {
+				for (int i = 0; i <= this.data.removedTokensPtr; i++) {
+					if(this.data.removedTokensStart[i] >= start &&
+							this.data.removedTokensEnd[i] <= end) {
+						return true;
+					}
+				}
+			}
+			
+			if(this.replacedTokensFlagged != null) {
+				for (int i = 0; i <= this.data.removedTokensPtr; i++) {
+					if(this.data.replacedTokensStart[i] >= start &&
+							this.data.replacedTokensEnd[i] <= end) {
+						return true;
+					}
+				}
+			}
+			
+			return false;
+		}
+		return true;
+	}
+
+	protected void endVisitNode(ASTNode node) {
+		int start = node.getStartPosition();
+		int end = start + node.getLength() - 1;
+		
+		// is inside diet part of the ast
+		if(this.blockDepth < 1) {
+			if(this.markIncludedProblems(start, end)) {
+				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+			}
+		} else {			
+			this.markIncludedProblems(start, end);
+			
+			if(this.insertedTokensFlagged != null) {
+				if(this.lastEnd != end) {
+					flagNodeWithInsertedTokens();
+				}
+				this.stack.add(node);
+			}
+
+			if(this.removedTokensFlagged != null) {
+				for (int i = 0; i <= this.data.removedTokensPtr; i++) {
+					if(!this.removedTokensFlagged[i] &&
+							this.data.removedTokensStart[i] >= start &&
+							this.data.removedTokensEnd[i] <= end) {
+						node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+						this.removedTokensFlagged[i] = true;
+					}
+				}
+			}
+			
+			if(this.replacedTokensFlagged != null) {
+				for (int i = 0; i <= this.data.replacedTokensPtr; i++) {
+					if(!this.replacedTokensFlagged[i] &&
+							this.data.replacedTokensStart[i] >= start &&
+							this.data.replacedTokensEnd[i] <= end) {
+						node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+						this.replacedTokensFlagged[i] = true;
+					}
+				}
+			}
+		}
+		this.lastEnd = end;
 	}
 	
-	private boolean checkAndTagAsMalformed(ASTNode node) {
-		boolean tagWithErrors = false;
-		search: for (int i = 0, max = this.problems.length; i < max; i++) {
+	private void flagNodeWithInsertedTokens() {
+		if(this.insertedTokensKind != null && this.insertedTokensKind.length > 0) {
+			int s = this.stack.size();
+			for (int i = s - 1; i > -1; i--) {
+				flagNodesWithInsertedTokensAtEnd((ASTNode)this.stack.get(i));
+			}
+			for (int i = 0; i < s; i++) {
+				flagNodesWithInsertedTokensInside((ASTNode)this.stack.get(i));
+			}
+			this.stack = new Vector();
+		}
+	}
+	
+	private boolean flagNodesWithInsertedTokensAtEnd(ASTNode node) {
+		int[] expectedEndingToken = this.endingTokens.get(node.getClass());
+		if (expectedEndingToken != null) {
+			int start = node.getStartPosition();
+			int end = start + node.getLength() - 1;
+			
+			boolean flagParent = false;
+			done : for (int i = this.insertedTokensKind.length - 1; i > -1 ; i--) {
+				if(!this.insertedTokensFlagged[i] &&
+						this.insertedTokensPosition[i] == end){
+					this.insertedTokensFlagged[i] = true;
+					for (int j = 0; j < expectedEndingToken.length; j++) {
+						if(expectedEndingToken[j] == this.insertedTokensKind[i]) {
+							node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+							break done;
+						}
+					}
+					flagParent = true;
+				}
+			}
+			
+			if(flagParent) {
+				ASTNode parent = node.getParent();
+				while (parent != null) {
+					parent.setFlags(node.getFlags() | ASTNode.RECOVERED);
+					if((parent.getStartPosition() + parent.getLength() - 1) != end) {
+						parent = null;
+					} else {
+						parent = parent.getParent();
+					}
+				}
+			}
+		}
+		return true;
+	}
+	
+	private boolean flagNodesWithInsertedTokensInside(ASTNode node) {
+		int start = node.getStartPosition();
+		int end = start + node.getLength() - 1;
+		for (int i = 0; i < this.insertedTokensKind.length; i++) {
+			if(!this.insertedTokensFlagged[i] &&
+					start <= this.insertedTokensPosition[i] &&
+					this.insertedTokensPosition[i] < end){
+				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+				this.insertedTokensFlagged[i] = true;
+			}
+		}
+		return true;
+	}
+	
+	private boolean markIncludedProblems(int start, int end) {
+		boolean foundProblems = false;
+		next: for (int i = 0, max = this.problems.length; i < max; i++) {
 			IProblem problem = this.problems[i];
+			
+			if(this.usedOrIrrelevantProblems[i]) continue next;
+			
 			switch(problem.getID()) {
 				case IProblem.ParsingErrorOnKeywordNoSuggestion :
 				case IProblem.ParsingErrorOnKeyword :
@@ -64,18 +319,19 @@ class ASTRecoveryPropagator extends DefaultASTVisitor {
 				case IProblem.InvalidDigit :
 					break;
 				default:
-					continue search;
+					this.usedOrIrrelevantProblems[i] = true;
+					continue next;
+					
 			}
+			
 			int problemStart = problem.getSourceStart();
 			int problemEnd = problem.getSourceEnd();
-			int start = node.getStartPosition();
-			int end = start + node.getLength();
 			if ((start <= problemStart) && (problemStart <= end) ||
 					(start <= problemEnd) && (problemEnd <= end)) {
-				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
-				tagWithErrors = true;
+				this.usedOrIrrelevantProblems[i] = true;
+				foundProblems = true;
 			}
 		}
-		return tagWithErrors;
+		return foundProblems;
 	}
 }
