commit 3f1cbb254c604c7416bb668e3ca0c2f6d90b8afc
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Jan 18 00:12:22 2014 +0100

    Bug 424415 - [1.8][compiler] Eventual resolution of
    ReferenceExpression is not seen to be happening.

72	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
19	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
12	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
10	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
16	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
15	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
10	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
4	4	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
4	4	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index 2a363ce..a624db9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -19,7 +19,7 @@ import junit.framework.Test;
 public class GenericsRegressionTest_1_8 extends AbstractRegressionTest {
 
 static {
-//	TESTS_NAMES = new String[] { "testBug424205b" };
+//	TESTS_NAMES = new String[] { "testBug424415c" };
 //	TESTS_NUMBERS = new int[] { 40, 41, 43, 45, 63, 64 };
 //	TESTS_RANGE = new int[] { 11, -1 };
 }
@@ -316,7 +316,77 @@ public void testBug424415() {
 			"}\n"
 		});
 }
-
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424415#c6
+public void testBug424415b() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.ArrayList;\n" + 
+			"import java.util.Collection;\n" + 
+			"\n" + 
+			"interface Functional<T> {\n" + 
+			"   T apply();\n" + 
+			"}\n" + 
+			"\n" + 
+			"class X {\n" + 
+			"    void foo(Object o) { }\n" + 
+			"    void foo(String str) {} \n" + 
+			"\n" + 
+			"    <Q extends Collection<?>> Q goo(Functional<Q> s) {\n" + 
+			"        return null;\n" + 
+			"    } \n" + 
+			"\n" + 
+			"    void test() {\n" + 
+			"        foo(goo(ArrayList<String>::new));\n" + 
+			"    }\n" + 
+			"}\n"
+		});
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424415#c8
+public void testBug424415c() {
+	runConformTest(
+		new String[] {
+			"com/example/MyEmployee.java",
+			"package com.example;\n" + 
+			"class MyEmployee {\n" + 
+			"	\n" + 
+			"	public enum Gender { MALE, FEMALE, OTHERS }\n" + 
+			"\n" + 
+			"	private int age = 0;\n" + 
+			"	private Gender gender = Gender.MALE;\n" + 
+			"	\n" + 
+			"	public MyEmployee(int age, Gender gender) {\n" + 
+			"		this.age = age;\n" + 
+			"		this.gender = gender;\n" + 
+			"	}	\n" + 
+			"	\n" + 
+			"	public int getAge() {\n" + 
+			"		return age;\n" + 
+			"	}\n" + 
+			"	\n" + 
+			"	public Gender getGender() {\n" + 
+			"		return gender;\n" + 
+			"	}\n" + 
+			"}",
+			"com/example/Test.java",
+			"package com.example;\n" + 
+			"\n" + 
+			"import java.util.List;\n" + 
+			"import java.util.concurrent.ConcurrentMap;\n" + 
+			"import java.util.stream.Collectors;\n" + 
+			"\n" + 
+			"public class Test {\n" + 
+			"\n" + 
+			"	ConcurrentMap<MyEmployee.Gender, List<MyEmployee>> test(List<MyEmployee> el) {\n" + 
+			"		return el.parallelStream()\n" + 
+			"					.collect(\n" + 
+			"						Collectors.groupingByConcurrent(MyEmployee::getGender)\n" + 
+			"						);\n" + 
+			"	}\n" + 
+			"	\n" + 
+			"}"
+		});
+}
 public void testBug424631() {
 	runConformTest(
 		new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index b8ef725..b73f0c6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -26,6 +26,7 @@
  *								Bug 424742 - [1.8] NPE in LambdaExpression.isCompatibleWith
  *								Bug 424710 - [1.8][compiler] CCE in SingleNameReference.localVariableBinding
  *								Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *     Jesper S Moller - Contributions for
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -643,6 +644,8 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	 * 	the method lookup.
 	 */
 	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes) {
+		if (!invocation.innersNeedUpdate())
+			return;
 		int problemReason = 0;
 		MethodBinding candidateMethod;
 		if (methodBinding.isValidBinding()) {
@@ -659,8 +662,12 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 			if (candidateMethod instanceof ParameterizedGenericMethodBinding) {
 				infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) candidateMethod);
 				if (infCtx != null) {
-					if (infCtx.stepCompleted < InferenceContext18.TYPE_INFERRED)
-						return; // not yet ready for pushing type information down to arguments
+					if (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {
+						// only work in the exact state of TYPE_INFERRED
+						// - below we're not yet ready
+						// - above we're already done-done
+						return;
+					}
 					variableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?
 				}
 			} else if (invocation instanceof AllocationExpression) {
@@ -687,10 +694,15 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 					if (binding instanceof ParameterizedGenericMethodBinding) {
 						ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;
 						InferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);
-						if (innerContext != null && innerContext.stepCompleted < InferenceContext18.TYPE_INFERRED) {							
-							argument.setExpectedType(parameterType);
-							MethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);
-							innerInvocation.updateBindings(improvedBinding);
+						if (innerContext != null) {
+							if (innerContext.stepCompleted < InferenceContext18.TYPE_INFERRED) {
+								argument.setExpectedType(parameterType);
+								MethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);
+								innerInvocation.updateBindings(improvedBinding);
+								// TODO need to report invalidMethod if !improvedBinding.isValidBinding() ?
+							} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {
+								innerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);
+							}
 						}
 						continue; // otherwise these have been dealt with during inner method lookup
 					}
@@ -714,6 +726,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 				}
 			}
 		}
+		invocation.innerUpdateDone();
 	}
 
 	public static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 27b2ca7..c57d8af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -29,6 +29,7 @@
  *							Bug 424710 - [1.8][compiler] CCE in SingleNameReference.localVariableBinding
  *							Bug 425152 - [1.8] [compiler] Lambda Expression not resolved but flow analyzed leading to NPE.
  *							Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *							Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -68,6 +69,7 @@ public class AllocationExpression extends Expression implements Invocation {
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PGMB,IC18>*/ inferenceContexts;
+	protected boolean innersNeedUpdate; // see Invocation.innersNeedUpdate()
 
 	/** Record to keep state between different parts of resolution. */
 	ResolutionState suspendedResolutionState;
@@ -76,18 +78,16 @@ public class AllocationExpression extends Expression implements Invocation {
 		boolean isDiamond;
 		boolean diamondNeedsDeferring;
 		boolean argsContainCast;
-		boolean polyExpressionSeen;
 		boolean cannotInferDiamond; // request the an error be reported in due time
 		TypeBinding[] argumentTypes;
 
 		ResolutionState(BlockScope scope, boolean isDiamond, boolean diamonNeedsDeferring,
-				boolean argsContainCast, boolean polyExpressionSeen, TypeBinding[] argumentTypes)
+				boolean argsContainCast, TypeBinding[] argumentTypes)
 		{
 			this.scope = scope;
 			this.isDiamond = isDiamond;
 			this.diamondNeedsDeferring = diamonNeedsDeferring;
 			this.argsContainCast = argsContainCast;
-			this.polyExpressionSeen = polyExpressionSeen;
 			this.argumentTypes = argumentTypes;
 		}
 	}
@@ -404,7 +404,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	// buffering the arguments' types
 	boolean argsContainCast = false;
 	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	boolean polyExpressionSeen = false;
 	if (this.arguments != null) {
 		boolean argHasError = false;
 		int length = this.arguments.length;
@@ -420,7 +419,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argHasError = true;
 			}
 			if (sourceLevel >= ClassFileConstants.JDK1_8 && argument.isPolyExpression())
-				polyExpressionSeen = true;
+				this.innersNeedUpdate = true;
 		}
 		if (argHasError) {
 			/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.
@@ -466,7 +465,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		scope.problemReporter().cannotInstantiate(this.type, this.resolvedType);
 		return this.resolvedType;
 	}
-	ResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, polyExpressionSeen, argumentTypes);
+	ResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, argumentTypes);
 	if (diamondNeedsDeferring) {
 		this.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).
 		return new PolyTypeBinding(this);
@@ -496,7 +495,7 @@ boolean resolvePart2(ResolutionState state) {
 		state.cannotInferDiamond = false;
  	}
 	ReferenceBinding receiverType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(state.scope, this, receiverType, state.argumentTypes, state.polyExpressionSeen);
+	this.binding = findConstructorBinding(state.scope, this, receiverType, state.argumentTypes);
 	return true;
 }
 
@@ -736,6 +735,12 @@ public InferenceContext18 getInferenceContext(ParameterizedGenericMethodBinding
 		return null;
 	return (InferenceContext18) this.inferenceContexts.get(method);
 }
+public boolean innersNeedUpdate() {
+	return this.innersNeedUpdate;
+}
+public void innerUpdateDone() {
+	this.innersNeedUpdate = false;
+}
 
 //-- interface InvocationSite: --
 public ExpressionContext getExpressionContext() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 99fab46..faee223 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -22,6 +22,7 @@
  *								Bug 424710 - [1.8][compiler] CCE in SingleNameReference.localVariableBinding
  *								Bug 425152 - [1.8] [compiler] Lambda Expression not resolved but flow analyzed leading to NPE.
  *								Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 409245 - [1.8][compiler] Type annotations dropped when call is routed through a synthetic bridge method
  *******************************************************************************/
@@ -74,6 +75,7 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
+	private boolean innersNeedUpdate; // see Invocation.innersNeedUpdate()
 
 	public ExplicitConstructorCall(int accessMode) {
 		this.accessMode = accessMode;
@@ -374,7 +376,6 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 			// arguments buffering for the method lookup
 			TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 			boolean argsContainCast = false;
-			boolean polyExpressionSeen = false;
 			if (this.arguments != null) {
 				boolean argHasError = false; // typeChecks all arguments
 				int length = this.arguments.length;
@@ -390,7 +391,7 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 						argHasError = true;
 					}
 					if (sourceLevel >= ClassFileConstants.JDK1_8 && argument.isPolyExpression())
-						polyExpressionSeen = true;
+						this.innersNeedUpdate = true;
 				}
 				if (argHasError) {
 					if (receiverType == null) {
@@ -427,7 +428,7 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 			if (receiverType == null) {
 				return;
 			}
-			this.binding = findConstructorBinding(scope, this, receiverType, argumentTypes, polyExpressionSeen);
+			this.binding = findConstructorBinding(scope, this, receiverType, argumentTypes);
 
 			if (this.binding.isValidBinding()) {
 				if ((this.binding.tagBits & TagBits.HasMissingType) != 0) {
@@ -526,6 +527,12 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 		return (this.binding instanceof ParameterizedGenericMethodBinding) 
 				&& getInferenceContext((ParameterizedGenericMethodBinding) this.binding) != null;
 	}
+	public boolean innersNeedUpdate() {
+		return this.innersNeedUpdate;
+	}
+	public void innerUpdateDone() {
+		this.innersNeedUpdate = false;
+	}
 
 	// -- interface InvocationSite: --
 	public InferenceContext18 freshInferenceContext(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
index 6020964..c05e000 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
@@ -65,5 +65,15 @@ public interface Invocation extends InvocationSite {
 	 * @return true if an update has happened
 	 */
 	boolean updateBindings(MethodBinding updatedBinding);
+	
+	/**
+	 * Answer whether the current invocation has inner expressions that still need updating after inference.
+	 */
+	boolean innersNeedUpdate();
 
+	/**
+	 * Mark that updating (the need for which is signaled via {@link #innersNeedUpdate()}) has been done.
+	 */
+	void innerUpdateDone();
+	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 86c4942..1621615 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -43,6 +43,7 @@
  *								Bug 424710 - [1.8][compiler] CCE in SingleNameReference.localVariableBinding
  *								Bug 425152 - [1.8] [compiler] Lambda Expression not resolved but flow analyzed leading to NPE.
  *								Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -107,6 +108,7 @@ public class MessageSend extends Expression implements Invocation {
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
+	protected boolean innersNeedUpdate; // see Invocation.innersNeedUpdate()
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	boolean nonStatic = !this.binding.isStatic();
@@ -624,7 +626,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	// will check for null after args are resolved
 	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	boolean argumentsNeedUpdate = false;
 	if (this.arguments != null) {
 		boolean argHasError = false; // typeChecks all arguments
 		int length = this.arguments.length;
@@ -644,7 +645,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			if (sourceLevel >= ClassFileConstants.JDK1_8) {
 				if (argument.isPolyExpression()
 					|| (argument instanceof Invocation && ((Invocation)argument).usesInference()))
-					argumentsNeedUpdate = true;
+					this.innersNeedUpdate = true;
 			}
 		}
 		if (argHasError) {
@@ -686,7 +687,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		return null;
 	}
 
-	findMethodBinding(scope, argumentTypes, argumentsNeedUpdate);
+	findMethodBinding(scope, argumentTypes);
 
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
@@ -847,17 +848,15 @@ public TypeBinding resolveType(BlockScope scope) {
 }
 /**
  * Find the method binding; 
- * if polyExpressionSeen allow for two attempts where the first round may stop
+ * if this.innersNeedUpdate allow for two attempts where the first round may stop
  * after applicability checking (18.5.1) to include more information into the final
  * invocation type inference (18.5.2).
  */
-protected void findMethodBinding(BlockScope scope, TypeBinding[] argumentTypes, boolean polyExpressionSeen) {
+protected void findMethodBinding(BlockScope scope, TypeBinding[] argumentTypes) {
 	this.binding = this.receiver.isImplicitThis()
 			? scope.getImplicitMethod(this.selector, argumentTypes, this)
 			: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
-	
-	if (polyExpressionSeen)
-		resolvePolyExpressionArguments(this, this.binding, argumentTypes);
+	resolvePolyExpressionArguments(this, this.binding, argumentTypes);
 }
 
 public void setActualReceiverType(ReferenceBinding receiverType) {
@@ -978,19 +977,25 @@ public boolean usesInference() {
 			&& getInferenceContext((ParameterizedGenericMethodBinding) this.binding) != null;
 }
 public boolean updateBindings(MethodBinding updatedBinding) {
-	if (this.binding == updatedBinding)
-		return false;
+	boolean hasUpdate = this.binding != updatedBinding;
 	if (this.inferenceContexts != null) {
 		InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
 		if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
 			this.inferenceContexts.put(updatedBinding, ctx);
 			// solution may have come from an outer inference, mark now that this (inner) is done (but not deep inners):
+			hasUpdate |= ctx.stepCompleted < InferenceContext18.TYPE_INFERRED;
 			ctx.stepCompleted = InferenceContext18.TYPE_INFERRED;
 		}
 	}
 	this.binding = updatedBinding;
 	this.resolvedType = updatedBinding.returnType;
-	return true;
+	return hasUpdate;
+}
+public boolean innersNeedUpdate() {
+	return this.innersNeedUpdate;
+}
+public void innerUpdateDone() {
+	this.innersNeedUpdate = false;
 }
 // -- Interface InvocationSite: --
 public InferenceContext18 freshInferenceContext(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 826d541..32565f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,6 +26,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 416267 - NPE in QualifiedAllocationExpression.resolveType
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -397,7 +398,6 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 
 		// will check for null after args are resolved
 		TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-		boolean polyExpressionSeen = false;
 		if (this.arguments != null) {
 			int length = this.arguments.length;
 			argumentTypes = new TypeBinding[length];
@@ -412,7 +412,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					hasError = true;
 				}
 				if (sourceLevel >= ClassFileConstants.JDK1_8 && argument.isPolyExpression())
-					polyExpressionSeen = true;
+					this.innersNeedUpdate = true;
 			}
 		}
 
@@ -476,7 +476,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				receiverType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) receiverType).genericType(), inferredTypes, ((ParameterizedTypeBinding) receiverType).enclosingType());
 			}
 			ReferenceBinding allocationType = (ReferenceBinding) receiverType;
-			this.binding = findConstructorBinding(scope, this, allocationType, argumentTypes, polyExpressionSeen);
+			this.binding = findConstructorBinding(scope, this, allocationType, argumentTypes);
 
 			if (this.binding.isValidBinding()) {	
 				if (isMethodUseDeprecated(this.binding, scope, true)) {
@@ -542,7 +542,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		if ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {
 			return null; // stop secondary errors
 		}
-		MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, argumentTypes, polyExpressionSeen);
+		MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, argumentTypes);
 			
 		if (!inheritedBinding.isValidBinding()) {
 			if (inheritedBinding.declaringClass == null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index f2c0d38..26b8218 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *							Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
+ *							Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contribution for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -554,6 +555,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		ExpressionContext previousContext = this.expressionContext;
 		MethodBinding previousBinding = this.binding;
 		MethodBinding previousDescriptor = this.descriptor;
+		TypeBinding previousResolvedType = this.resolvedType;
 		try {
 			setExpressionContext(INVOCATION_CONTEXT);
 			setExpectedType(targetType);
@@ -565,6 +567,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			// remove *any relevant* traces of this 'inofficial' resolving:
 			this.binding = previousBinding;
 			this.descriptor = previousDescriptor;
+			this.resolvedType = previousResolvedType;
 			setExpressionContext(previousContext);
 			this.expectedType = null; // don't call setExpectedType(null), would NPE
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 1571dd3..02542e7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,6 +29,7 @@
  *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *								Bug 417758 - [1.8][null] Null safety compromise during array creation.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
@@ -332,13 +333,12 @@ public ExpressionContext getExpressionContext() {
 }
 /**
  * For all constructor invocations: find the constructor binding; 
- * if polyExpressionSeen perform some post processing for those and produce
+ * if site.innersNeedUpdate() perform some post processing for those and produce
  * any updates as side-effects into 'argumentTypes'.
  */
-protected MethodBinding findConstructorBinding(BlockScope scope, Invocation site, ReferenceBinding receiverType, TypeBinding[] argumentTypes, boolean polyExpressionSeen) {
+protected MethodBinding findConstructorBinding(BlockScope scope, Invocation site, ReferenceBinding receiverType, TypeBinding[] argumentTypes) {
 	MethodBinding ctorBinding = scope.getConstructor(receiverType, argumentTypes, site);
-	if (polyExpressionSeen)
-		resolvePolyExpressionArguments(site, ctorBinding, argumentTypes);
+	resolvePolyExpressionArguments(site, ctorBinding, argumentTypes);
 	return ctorBinding;
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 3360443..ec1a3ce 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -249,9 +249,10 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				if (!functionType.parameters[i].isProperType(true))
 					return FALSE;
 			// Otherwise, a search for a compile-time declaration is performed, as defined in 15.28.1....
-			reference.resolveTypeExpecting(reference.enclosingScope, t);
-			MethodBinding compileTimeDecl = reference.binding;
-			if (compileTimeDecl == null || !compileTimeDecl.isValidBinding())
+			// Note: we currently don't distinguish search for a potentially-applicable method from searching the compiler-time declaration,
+			// hence reusing the method binding from above
+			MethodBinding compileTimeDecl = potentiallyApplicable;
+			if (!compileTimeDecl.isValidBinding())
 				return FALSE;
 			TypeBinding r = functionType.isConstructor() ? functionType.declaringClass : functionType.returnType;
 			if (r.id == TypeIds.T_void)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index fcd8feb..d5f3a9a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -692,7 +692,21 @@ public class InferenceContext18 {
 						}
 						if (tmpBoundSet == this.currentBounds)
 							tmpBoundSet = tmpBoundSet.copy();
-						// FIXME: remove capture bounds
+						Iterator captureKeys = tmpBoundSet.captures.keySet().iterator();
+						Set toRemove = new HashSet();
+						while (captureKeys.hasNext()) {
+							ParameterizedTypeBinding key = (ParameterizedTypeBinding) captureKeys.next();
+							int len = key.arguments.length;
+							for (int i = 0; i < len; i++) {
+								if (key.arguments[i] == variable) { //$IDENTITY-COMPARISON$
+									toRemove.add(key);
+									break;
+								}
+							}
+						}
+						captureKeys = toRemove.iterator();
+						while (captureKeys.hasNext())
+							tmpBoundSet.captures.remove(captureKeys.next());
 						tmpBoundSet.addBound(new TypeBound(variable, zsj, ReductionResult.SAME));
 					}
 					if (tmpBoundSet.incorporate(this)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index c5dded2..849cf21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -26,6 +26,7 @@
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 424710 - [1.8][compiler] CCE in SingleNameReference.localVariableBinding
  *								Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *								Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *  							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
@@ -4908,12 +4909,16 @@ public abstract class Scope {
 	 * otherwise return the applicable method unchanged.
 	 */
 	protected MethodBinding inferInvocationType(InvocationSite invocationSite, MethodBinding applicable, TypeBinding[] argumentTypes) {
-		if (applicable instanceof ParameterizedGenericMethodBinding && invocationSite instanceof Invocation) {
+		if (invocationSite instanceof Invocation) {
 			Invocation invocation = (Invocation) invocationSite;
-			ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) applicable;
-			InferenceContext18 infCtx18 = invocation.getInferenceContext(parameterizedMethod);
-			if (infCtx18 != null && infCtx18.stepCompleted < InferenceContext18.TYPE_INFERRED) {
-				return infCtx18.inferInvocationType(invocation, argumentTypes, parameterizedMethod);
+			if (applicable instanceof ParameterizedGenericMethodBinding) {
+				ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) applicable;
+				InferenceContext18 infCtx18 = invocation.getInferenceContext(parameterizedMethod);
+				if (infCtx18 != null && infCtx18.stepCompleted < InferenceContext18.TYPE_INFERRED) {
+					return infCtx18.inferInvocationType(invocation, argumentTypes, parameterizedMethod);
+				}
+			} else {
+				ASTNode.resolvePolyExpressionArguments(invocation, applicable, argumentTypes);
 			}
 		}
 		return applicable;
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
index 0f0b82b..caf547b 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,7 @@
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
  *        Stephan Herrmann - Contribution for
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec) 
+ *							Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -185,7 +186,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	// buffering the arguments' types
 	boolean argsContainCast = false;
 	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	boolean polyExpressionSeen = false;
 	if (this.arguments != null) {
 		boolean argHasError = false;
 		int length = this.arguments.length;
@@ -202,7 +202,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argHasError = true;
 			}
 			if (argumentType != null && argumentType.kind() == Binding.POLY_TYPE)
-				polyExpressionSeen = true;
+				this.innersNeedUpdate = true;
 		}
 		if (argHasError) {
 			return this.resolvedType;
@@ -225,7 +225,7 @@ public TypeBinding resolveType(BlockScope scope) {
  	}
 	
 	ReferenceBinding allocatedType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(scope, this, allocatedType, argumentTypes, polyExpressionSeen);
+	this.binding = findConstructorBinding(scope, this, allocatedType, argumentTypes);
 
 	if (!this.binding.isValidBinding()) {	
 		if (this.binding instanceof ProblemMethodBinding
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
index a6ee1db..0173feb 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,7 @@
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
  *        Stephan Herrmann - Contribution for
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *							Bug 424415 - [1.8][compiler] Eventual resolution of ReferenceExpression is not seen to be happening.
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -224,7 +225,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	// will check for null after args are resolved
 	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	boolean polyExpressionSeen = false;
 	if (this.arguments != null) {
 		boolean argHasError = false; // typeChecks all arguments
 		int length = this.arguments.length;
@@ -240,7 +240,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			if ((argumentType = argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)
 				argHasError = true;
 			if (argumentType != null && argumentType.kind() == Binding.POLY_TYPE)
-				polyExpressionSeen = true;
+				this.innersNeedUpdate = true;
 		}
 		if (argHasError) {
 			if(this.actualReceiverType instanceof ReferenceBinding) {
@@ -259,7 +259,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		return null;
 	}
 
-	findMethodBinding(scope, argumentTypes, polyExpressionSeen);
+	findMethodBinding(scope, argumentTypes);
 		
 	if (!this.binding.isValidBinding()) {
 		if (this.binding instanceof ProblemMethodBinding
