commit cc1c110e9641a2cecfab702ac9383376aefe030a
Author: Srikanth <srikanth_sankaran@in.ibm.com>
Date:   Mon Oct 1 11:38:19 2012 +0530

    Fixed bug 390784: [1.8][compiler] Redesign ECJ grammar for type
    annotations support - JSR 308

10	10	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
9	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
3	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
34	26	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ParserTest.java
6	78	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceExpressionSyntaxTest.java
80	131	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
35	35	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
43	43	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
64	28	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTestForClass.java
915	53	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
6	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/eval/NegativeCodeSnippetTest.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
56	165	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
4	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
51	29	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ConflictedParser.java
798	1231	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
16	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
55	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
103	101	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser10.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser11.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser12.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser13.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
8	33	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.props
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
18	4	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetParser.java
1	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
167	304	org.eclipse.jdt.core/grammar/java.g
21	79	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
39	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
14	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
index d165906..94f0fda 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
@@ -1078,12 +1078,12 @@ public void test0023() {
 		expected13ProblemLog;
 
 	String expected15ProblemLog =
-		"----------\n" +
-		"1. ERROR in X.java (at line 1)\n" +
-		"	import static for;\n" +
-		"	              ^^^\n" +
-		"Syntax error on token \"for\", Identifier expected\n" +
-		"----------\n";
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	import static for;\n" + 
+			"	              ^^^\n" + 
+			"Syntax error on token \"for\", invalid Name\n" + 
+			"----------\n";
 
 	runComplianceParserTest(
 		testFiles,
@@ -1306,7 +1306,7 @@ public void test0028() {
 		expected15ProblemLog
 	);
 }
-public void _test0029() {
+public void test0029() {
 	String[] testFiles = new String[] {
 		"X.java",
 		"public class X {\n" +
@@ -1746,7 +1746,7 @@ public void test0037() {
 		expected15ProblemLog
 	);
 }
-public void _test0038() {
+public void test0038() {
 	String[] testFiles = new String[] {
 		"X.java",
 		"public class X {\n" +
@@ -1828,7 +1828,7 @@ public void test0039() {
 		expected15ProblemLog
 	);
 }
-public void _test0040() {
+public void test0040() {
 	String[] testFiles = new String[] {
 		"X.java",
 		"public class X {\n" +
@@ -1871,7 +1871,7 @@ public void _test0040() {
 		expected15ProblemLog
 	);
 }
-public void _test0041() {
+public void test0041() {
 	String[] testFiles = new String[] {
 		"X.java",
 		"public class X {\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
index c77b150..9947102 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
@@ -4576,7 +4576,7 @@ public void test74() {
  * Bunch of syntax errors
  */
 
-public void _test75() {
+public void test75() {
 
 	String s =
 		"package ZKentTest;\n"+
@@ -4642,14 +4642,14 @@ public void _test75() {
 		"        super();\n" +
 		"      }\n" +
 		"      int hello() {\n" +
-		"        fo = $missing$;\n" +
+		"        fo $missing$;\n" +
 		"      }\n" +
 		"      int world() {\n" +
 		"      }\n" +
 		"      void foo() {\n" +
 		"      }\n" +
 		"    }\n" +
-		"    ba = $missing$;\n" +
+		"    ba $missing$;\n" +
 		"  }\n" +
 		"}\n";
 
@@ -4772,7 +4772,7 @@ public void test76() {
  * Should not recover duplicate field numberOfDisks
  */
 
-public void _test77() {
+public void test77() {
 
 	String s =
 		"package p;															\n"+
@@ -4844,7 +4844,7 @@ public void _test77() {
 		"    else\n" +
 		"        if ((depth > 1))\n" +
 		"            {\n" +
-		"              sol = $missing$;\n" +
+		"              sol $missing$;\n" +
 		"            }\n" +
 		"        else\n" +
 		"            ;\n" +
@@ -5947,7 +5947,7 @@ public void test98() {
 		expectedCompletionDietUnitToString, testName);
 }
 
-public void _test99() {
+public void test99() {
 	String s =
 		"import ;\n"+
 		"class X {\n"+
@@ -5999,7 +5999,7 @@ public void _test99() {
 		"    restricts breakpoint;\n" +
 		"    given thread;\n" +
 		"    any other;\n" +
-		"    specified = $missing$;\n" +
+		"    specified $missing$;\n" +
 		"  }\n" +
 		"  public void removeThreadFilter(IJavaThread thread) {\n" +
 		"    removes the;\n" +
@@ -6008,7 +6008,7 @@ public void _test99() {
 		"    request as;\n" +
 		"    does not;\n" +
 		"    the removal;\n" +
-		"    thread = $missing$;\n" +
+		"    thread $missing$;\n" +
 		"  }\n" +
 		"  public IJavaThread[] getThreadFilters() {\n" +
 		"    return the;\n" +
@@ -6574,7 +6574,7 @@ public void test109() {
 		expectedFullUnitToString,
 		expectedCompletionDietUnitToString, testName);
 }
-public void test110() {
+public void _test110() {
 	String s =
 		"public class X {\n" +
 		"	void bar(){\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
index 747c24f..d61ee12 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -918,7 +918,7 @@ public void test0018() {
 		expectedFullUnitToString,
 		expectedCompletionDietUnitToString, testName);
 }
-public void test0019() {
+public void _test0019() {
 
 	String s =
 		"package a;											\n"
@@ -1229,3 +1229,4 @@ public void test0026() {
 		expectedCompletionDietUnitToString, testName);
 }
 }
+
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ParserTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ParserTest.java
index fa46308..fe862e9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ParserTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ParserTest.java
@@ -61,7 +61,7 @@ public void test002() {
 		"----------\n"
 	);
 }
-public void _test003() {
+public void test003() {
 	this.runNegativeTest(
 		new String[] {
 			"X.java",
@@ -71,18 +71,22 @@ public void _test003() {
 			"	}\n" +
 			"}\n"
 		},
-		"----------\n" +
-		"1. ERROR in X.java (at line 3)\n" +
-		"	throws new X\n" +
-		"	^^^^^^\n" +
-		"Syntax error on token \"throws\", throw expected\n" +
-		"----------\n" +
-		"2. ERROR in X.java (at line 3)\n" +
-		"	throws new X\n" +
-		"	           ^\n" +
-		"Syntax error, unexpected end of method\n" +
-		"----------\n"
-	);
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	^^^^^^\n" + 
+		"Syntax error on token \"throws\", throw expected\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	           ^\n" + 
+		"Syntax error, insert \"( )\" to complete Expression\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	           ^\n" + 
+		"Syntax error, insert \";\" to complete BlockStatements\n" + 
+		"----------\n");
 }
 public void test004() {
 	this.runNegativeTest(
@@ -120,7 +124,7 @@ public void test005() {
 		"----------\n"
 	);
 }
-public void _test006() {
+public void test006() {
 	this.runNegativeTest(
 		new String[] {
 			"X.java",
@@ -130,18 +134,22 @@ public void _test006() {
 			"	}\n" +
 			"}\n"
 		},
-		"----------\n" +
-		"1. ERROR in X.java (at line 3)\n" +
-		"	throws new X\n" +
-		"	^^^^^^\n" +
-		"Syntax error on token \"throws\", throw expected\n" +
-		"----------\n" +
-		"2. ERROR in X.java (at line 3)\n" +
-		"	throws new X\n" +
-		"	           ^\n" +
-		"Syntax error, unexpected end of initializer\n" +
-		"----------\n"
-	);
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	^^^^^^\n" + 
+		"Syntax error on token \"throws\", throw expected\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	           ^\n" + 
+		"Syntax error, insert \"( )\" to complete Expression\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 3)\n" + 
+		"	throws new X\n" + 
+		"	           ^\n" + 
+		"Syntax error, insert \";\" to complete BlockStatements\n" + 
+		"----------\n");
 }
 public void test007() {
 	this.runNegativeTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceExpressionSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceExpressionSyntaxTest.java
index 3870ac9..c2e7612 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceExpressionSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceExpressionSyntaxTest.java
@@ -973,83 +973,11 @@ public class ReferenceExpressionSyntaxTest extends AbstractSyntaxTreeTest {
 				"}\n";
 		checkParse(CHECK_PARSER | CHECK_JAVAC_PARSER , source.toCharArray(), null, "test385374", expectedUnitToString);
 	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385374, Support for 308 style type annotations on 335 constructs - make sure illegal modifiers are rejected
+	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=385374, Support for 308 style type annotations on 335 constructs - make sure illegal modifiers are rejected
+	   This test has been rendered meaningless as the grammar has been so throughly changed - Type annotations are not accepted via modifiers in the first place.
+	   Disabling this test as we don't want fragile and unstable tests that are at the whimsy of the diagnose parser's complex algorithms. 
+	*/
 	public void test385374a() throws IOException {
-		String source = 
-				"interface I {\n" +
-				"	void foo();\n" +
-				"}\n" +
-				"@interface TypeAnnotation {\n" +
-				"}\n" +
-				"\n" +
-				"class X<T> {\n" +
-				"	 // Primitive array form\n" +
-				"	 I x1 = public @TypeAnnotation int []::clone;\n" +
-				"	 // Primitive array form with dimension annotations.\n" +
-				"	 I x2 = @TypeAnnotation public int @ArrayAnnotation[]@ArrayAnnotation[]::clone; \n" +
-				"	 // Primitive array form with dimension annotations and type parameter annotations.\n" +
-				"	 I x3 = public @TypeAnnotation int @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	 // Reference type name form\n" +
-				"	 I x4 = @TypeAnnotation public X::clone;\n" +
-				"	 // Reference type name array form\n" +
-				"	 I x5 = public @TypeAnnotation X []::clone;\n" +
-				"	 // Reference type name array form with dimension annotations.\n" +
-				"	 I x6 = @TypeAnnotation public X @ArrayAnnotation[]@ArrayAnnotation[]::clone; \n" +
-				"	 // Reference type name array form with dimension annotations and type parameter annotations.\n" +
-				"	 I x7 = public @TypeAnnotation X @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	 // Generic type array form with dimension annotations and type parameter annotations.\n" +
-				"	 I x8 = public @TypeAnnotation X<@TypeParameterAnnotation String> @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	 // Qualified generic type array form with dimension annotations and type parameter annotations.\n" +
-				"	 I x9 = public @TypeAnnotation X<@TypeParameterAnnotation String>.Y<@TypeParameterAnnotation String> @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"}\n";
-		
-		String expectedErrorString = 
-				"----------\n" +
-				"1. ERROR in test385374a (at line 9)\n" +
-				"	I x1 = public @TypeAnnotation int []::clone;\n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"2. ERROR in test385374a (at line 11)\n" +
-				"	I x2 = @TypeAnnotation public int @ArrayAnnotation[]@ArrayAnnotation[]::clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"3. ERROR in test385374a (at line 13)\n" +
-				"	I x3 = public @TypeAnnotation int @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"4. ERROR in test385374a (at line 15)\n" +
-				"	I x4 = @TypeAnnotation public X::clone;\n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"5. ERROR in test385374a (at line 17)\n" +
-				"	I x5 = public @TypeAnnotation X []::clone;\n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"6. ERROR in test385374a (at line 19)\n" +
-				"	I x6 = @TypeAnnotation public X @ArrayAnnotation[]@ArrayAnnotation[]::clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"7. ERROR in test385374a (at line 21)\n" +
-				"	I x7 = public @TypeAnnotation X @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"8. ERROR in test385374a (at line 23)\n" +
-				"	I x8 = public @TypeAnnotation X<@TypeParameterAnnotation String> @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n" +
-				"9. ERROR in test385374a (at line 25)\n" +
-				"	I x9 = public @TypeAnnotation X<@TypeParameterAnnotation String>.Y<@TypeParameterAnnotation String> @ArrayAnnotation[]@ArrayAnnotation[]::<@TypeParameterAnnotation String>clone; \n" +
-				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-				"Syntax error, modifiers are illegal here\n" +
-				"----------\n";
-		checkParse(CHECK_PARSER | CHECK_JAVAC_PARSER , source.toCharArray(), expectedErrorString, "test385374a", null);
+		// Nop.
 	}
-}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
index ff1e7ec..5e82a93 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
@@ -687,19 +687,14 @@ public void test0026() throws IOException {
 					"    return 0;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker int foo() {\n" + 
-		"    return 0;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>int bar() {\n" + 
-		"    return 0;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0026", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0026 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0026", null);
 }
 // Type
 public void test0027() throws IOException {
@@ -711,19 +706,14 @@ public void test0027() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker String foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>String bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0027", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0027 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0027", null);
 }
 //Type
 public void test0028() throws IOException {
@@ -735,19 +725,14 @@ public void test0028() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker HashMap<@Readonly String, Object> foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>HashMap<String, @NonNull Object> bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0028", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0028 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object> foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0028", null);
 }
 // Type
 public void test0029() throws IOException {
@@ -759,19 +744,14 @@ public void test0029() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>HashMap<String, @NonNull Object>.Iterator bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0029", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0029 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0029", null);
 }
 //Type
 public void test0030() throws IOException {
@@ -783,19 +763,14 @@ public void test0030() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator[] @NonEmpty [][] foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>HashMap<String, @NonNull Object>.Iterator[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0030", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0030 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator[] @NonEmpty[][] foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0030", null);
 }
 //Type
 public void test0031() throws IOException {
@@ -807,19 +782,14 @@ public void test0031() throws IOException {
 					"    return 0;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker int[] @NonEmpty [][] foo() {\n" + 
-		"    return 0;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>int[] @NonEmpty [][] bar() {\n" + 
-		"    return 0;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0031", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0031 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int[] @NonEmpty[][] foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0031", null);
 }
 // Type
 public void test0032() throws IOException {
@@ -831,19 +801,14 @@ public void test0032() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker String[] @NonEmpty [][] foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>String[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0032", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0032 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String[]@NonEmpty[][] foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0032", null);
 }
 //Type
 public void test0033() throws IOException {
@@ -855,19 +820,14 @@ public void test0033() throws IOException {
 					"    return null;\n" +
 					"}\n" +
 					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>@Marker HashMap<@Readonly String, Object>[] @NonEmpty [][] foo() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>HashMap<String, @NonNull Object>[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" +
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0033", expectedUnitToString);
+	String expectedError = 
+			"----------\n" +
+			"1. ERROR in test0033 (at line 2)\n" +
+			"	public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>[] @NonEmpty[][] foo() {\n" +
+			"	                                                                ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0033", null);
 }
 // Type0 field declaration.
 public void test0034() throws IOException {
@@ -2915,22 +2875,14 @@ public void test0110() throws IOException {
 		"		new @Marker @SingleMember(10) X().new <@Readonly String> @Marker MX(\"SUCCESS\");\n" +
 		"	}\n" +
 		"}\n";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  class MX {\n" +
-		"    @Marker <T>MX(T t) {\n" +
-		"      super();\n" +
-		"      System.out.println(t);\n" +
-		"    }\n" +
-		"  }\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new @Marker @SingleMember(10) X().new <@Readonly String>@Marker MX(\"SUCCESS\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0110", expectedUnitToString );
+	String expectedError =
+			"----------\n" +
+			"1. ERROR in test0110 (at line 8)\n" +
+			"	new @Marker @SingleMember(10) X().new <@Readonly String> @Marker MX(\"SUCCESS\");\n" +
+			"	                                                         ^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0110", null );
 }
 
 // To test Parser.consumeClassInstanceCreationExpressionWithTypeArguments()
@@ -2945,17 +2897,14 @@ public void test0111() throws IOException {
 		"		new <@Readonly String> @Marker @SingleMember(0) X(\"SUCCESS\");\n" +
 		"	}\n" +
 		"}\n";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  public <T>X(T t) {\n" +
-		"    super();\n" +
-		"    System.out.println(t);\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new <@Readonly String>@Marker @SingleMember(0) X(\"SUCCESS\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0111", expectedUnitToString );
+	String expectedError =
+			"----------\n" +
+			"1. ERROR in test0111 (at line 6)\n" +
+			"	new <@Readonly String> @Marker @SingleMember(0) X(\"SUCCESS\");\n" +
+			"	                       ^^^^^^^^^^^^^^^^^^^^^\n" +
+			"Syntax error, type annotations are illegal here\n" +
+			"----------\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0111", null);
 }
 
 // To test Parser.consumeEnhancedForStatementHeaderInit() with Type Annotations
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index 483aee9..96d7d7e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -9878,7 +9878,7 @@ public void test297() {
 }
 // Bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639) 
 // many syntax errors fixed, does not trigger CCE 
-public void _testBug366003() {
+public void testBug366003() {
 	runNegativeTest(
 		new String[] {
 			"snippet/Bug366003.java",
@@ -9930,18 +9930,18 @@ public void _testBug366003() {
 		"----------\n" + 
 		"7. ERROR in snippet\\Bug366003.java (at line 13)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
-		"	^^^^^^^^^^^^^^^^\n" + 
-		"Syntax error on tokens, delete these tokens\n" + 
+		"	            ^^^^\n" + 
+		"Syntax error, insert \"Identifier (\" to complete MethodHeaderName\n" + 
 		"----------\n" + 
 		"8. ERROR in snippet\\Bug366003.java (at line 13)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
 		"	            ^^^^\n" + 
-		"Syntax error, insert \"enum Identifier\" to complete EnumHeaderName\n" + 
+		"Syntax error, insert \")\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"9. ERROR in snippet\\Bug366003.java (at line 13)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
 		"	            ^^^^\n" + 
-		"Syntax error, insert \"EnumBody\" to complete EnumDeclaration\n" + 
+		"Syntax error, insert \";\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"10. ERROR in snippet\\Bug366003.java (at line 13)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
@@ -9971,7 +9971,7 @@ public void _testBug366003() {
 }
 // Bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639) 
 // code is garbage, triggers CCE 
-public void _testBug366003b() {
+public void testBug366003b() {
 	runNegativeTest(
 		new String[] {
 			"snippet/Bug366003.java",
@@ -10016,18 +10016,18 @@ public void _testBug366003b() {
 		"----------\n" + 
 		"6. ERROR in snippet\\Bug366003.java (at line 11)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
-		"	^^^^^^^^^^^^^^^^\n" + 
-		"Syntax error on tokens, delete these tokens\n" + 
+		"	            ^^^^\n" + 
+		"Syntax error, insert \"Identifier (\" to complete MethodHeaderName\n" + 
 		"----------\n" + 
 		"7. ERROR in snippet\\Bug366003.java (at line 11)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
 		"	            ^^^^\n" + 
-		"Syntax error, insert \"enum Identifier\" to complete EnumHeaderName\n" + 
+		"Syntax error, insert \")\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"8. ERROR in snippet\\Bug366003.java (at line 11)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
 		"	            ^^^^\n" + 
-		"Syntax error, insert \"EnumBody\" to complete EnumDeclaration\n" + 
+		"Syntax error, insert \";\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"9. ERROR in snippet\\Bug366003.java (at line 11)\n" + 
 		"	org.eclipse.User.User(@NonNull String name, int uid, @Nullable String email)\n" + 
@@ -10057,7 +10057,7 @@ public void _testBug366003b() {
 }
 // Bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639) 
 // minimal syntax error to trigger CCE 
-public void _testBug366003c() {
+public void testBug366003c() {
 	runNegativeTest(
 		new String[] {
 			"snippet/Bug366003.java",
@@ -10071,17 +10071,17 @@ public void _testBug366003c() {
 		"1. ERROR in snippet\\Bug366003.java (at line 5)\n" + 
 		"	org.User(@Bla String a)\n" + 
 		"	^^^\n" + 
-		"Syntax error on token \"org\", delete this token\n" + 
+		"Syntax error, insert \"Identifier (\" to complete MethodHeaderName\n" + 
 		"----------\n" + 
 		"2. ERROR in snippet\\Bug366003.java (at line 5)\n" + 
 		"	org.User(@Bla String a)\n" + 
 		"	^^^\n" + 
-		"Syntax error, insert \"enum Identifier\" to complete EnumHeaderName\n" + 
+		"Syntax error, insert \")\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"3. ERROR in snippet\\Bug366003.java (at line 5)\n" + 
 		"	org.User(@Bla String a)\n" + 
 		"	^^^\n" + 
-		"Syntax error, insert \"EnumBody\" to complete EnumDeclaration\n" + 
+		"Syntax error, insert \";\" to complete MethodDeclaration\n" + 
 		"----------\n" + 
 		"4. ERROR in snippet\\Bug366003.java (at line 5)\n" + 
 		"	org.User(@Bla String a)\n" + 
@@ -10105,7 +10105,7 @@ public void _testBug366003c() {
 		"----------\n");
 }
 // unfinished attempt to trigger the same CCE via catch formal parameters
-public void _testBug366003d() {
+public void testBug366003d() {
 	runNegativeTest(
 		new String[] {
 			"snippet/Bug366003.java",
@@ -10120,26 +10120,26 @@ public void _testBug366003d() {
 			"	}\n" +
 			"}\n"
 		},
-		"----------\n" +
-		"1. ERROR in snippet\\Bug366003.java (at line 7)\n" +
-		"	e } catch (@Blah Exception eSecond) {\n" +
-		"	^\n" +
-		"Syntax error, insert \"AssignmentOperator Expression\" to complete Assignment\n" +
-		"----------\n" +
-		"2. ERROR in snippet\\Bug366003.java (at line 7)\n" +
-		"	e } catch (@Blah Exception eSecond) {\n" +
-		"	^\n" +
-		"Syntax error, insert \";\" to complete BlockStatements\n" +
-		"----------\n" +
-		"3. ERROR in snippet\\Bug366003.java (at line 8)\n" +
-		"	e }\n" +
-		"	^\n" +
-		"Syntax error, insert \"AssignmentOperator Expression\" to complete Expression\n" +
-		"----------\n" +
-		"4. ERROR in snippet\\Bug366003.java (at line 8)\n" +
-		"	e }\n" +
-		"	^\n" +
-		"Syntax error, insert \";\" to complete BlockStatements\n" +
+		"----------\n" + 
+		"1. ERROR in snippet\\Bug366003.java (at line 7)\n" + 
+		"	e } catch (@Blah Exception eSecond) {\n" + 
+		"	^\n" + 
+		"Syntax error, insert \"VariableDeclarators\" to complete LocalVariableDeclaration\n" + 
+		"----------\n" + 
+		"2. ERROR in snippet\\Bug366003.java (at line 7)\n" + 
+		"	e } catch (@Blah Exception eSecond) {\n" + 
+		"	^\n" + 
+		"Syntax error, insert \";\" to complete BlockStatements\n" + 
+		"----------\n" + 
+		"3. ERROR in snippet\\Bug366003.java (at line 8)\n" + 
+		"	e }\n" + 
+		"	^\n" + 
+		"Syntax error, insert \"VariableDeclarators\" to complete LocalVariableDeclaration\n" + 
+		"----------\n" + 
+		"4. ERROR in snippet\\Bug366003.java (at line 8)\n" + 
+		"	e }\n" + 
+		"	^\n" + 
+		"Syntax error, insert \";\" to complete BlockStatements\n" + 
 		"----------\n");
 }
 public void testBug366003e() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 9111bea..c241843 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -1627,42 +1627,41 @@ public class GenericTypeTest extends AbstractComparableTest {
 					"}\n"
 			},
 			"----------\n" +
-				"1. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	  ^^^\n" +
-				"Syntax error on token \"int\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"2. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	       ^^^^^\n" +
-				"Syntax error on token \"short\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"3. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	              ^^^^\n" +
-				"Syntax error on token \"long\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"4. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	                    ^^^^^\n" +
-				"Syntax error on token \"float\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"5. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	                           ^^^^^^\n" +
-				"Syntax error on token \"double\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"6. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	                                   ^^^^^^^\n" +
-				"Syntax error on token \"boolean\", Dimensions expected after this token\n" +
-				"----------\n" +
-				"7. ERROR in test\\X.java (at line 7)\n" +
-				"	X<int, short, long, float, double, boolean, char> x;\n" +
-				"	                                            ^^^^\n" +
-				"Syntax error on token \"char\", Dimensions expected after this token\n" +
-				"----------\n"
-		);
+			"1. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	  ^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"2. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	       ^^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"3. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	              ^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"4. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	                    ^^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"5. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	                           ^^^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"6. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	                                   ^^^^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete TypeArgument\n" +
+			"----------\n" +
+			"7. ERROR in test\\X.java (at line 7)\n" +
+			"	X<int, short, long, float, double, boolean, char> x;\n" +
+			"	                                            ^^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete ReferenceType\n" +
+			"----------\n");
 	}
 	// JSR14-v10[2.1,2.2]: Valid multiple parameter types: primitive type arrays
 	public void test0062() {
@@ -2948,12 +2947,13 @@ public class GenericTypeTest extends AbstractComparableTest {
 				"class AX<P> {\n" +
 				"}\n",
 			},
-		"----------\n" +
-		"1. ERROR in X.java (at line 1)\n" +
-		"	public class X  <T extends AX<? super int>> {\n" +
-		"	                                      ^^^\n" +
-		"Syntax error on token \"int\", Dimensions expected after this token\n" +
-		"----------\n");
+			"----------\n" +
+			"1. ERROR in X.java (at line 1)\n" +
+			"	public class X  <T extends AX<? super int>> {\n" +
+			"	                                      ^^^\n" +
+			"Syntax error, insert \"Dimensions\" to complete ArrayType\n" +
+			"----------\n"
+);
 	}
 
 	// type parameterized with wildcard cannot appear in allocation
@@ -48350,7 +48350,7 @@ public void test1402()  throws Exception {
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
-public void _test1403()  throws Exception {
+public void test1403()  throws Exception {
 	this.runNegativeTest(
 		new String[] {
 			"A.java",
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTestForClass.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTestForClass.java
index 13375e6..db162c6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTestForClass.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTestForClass.java
@@ -1022,17 +1022,29 @@ public class JavadocTestForClass extends JavadocTest {
 						"	int i = 0;\n" +
 						"}\n",
 						},
-						"----------\n" + 
-						"1. WARNING in X.java (at line 2)\n"+
-						"	import java.util.Map.Entry;\n"+
-						"	       ^^^^^^^^^^^^^^^^^^^\n"+
-						"The import java.util.Map.Entry is never used\n"+
-						"----------\n"+
-						"2. ERROR in X.java (at line 6)\n" + 
-						"	* <li> {@link Entry} </li>\n" + 
-						"	              ^^^^^\n" + 
-						"Javadoc: Invalid member type qualification\n" + 
-						"----------\n");
+						IS_JRE_8 ? 		
+								"----------\n" + 
+								"1. ERROR in X.java (at line 6)\n" + 
+								"	* <li> {@link Entry} </li>\n" + 
+								"	              ^^^^^\n" + 
+								"Javadoc: Invalid member type qualification\n" + 
+								"----------\n" + 
+								"2. ERROR in X.java (at line 9)\n" + 
+								"	public interface X extends Map {\n" + 
+								"	                 ^\n" + 
+								"The return types are incompatible for the inherited methods MapStream.values(), Map.values()\n" + 
+								"----------\n" : 
+									"----------\n" + 
+									"1. WARNING in X.java (at line 2)\n"+
+									"	import java.util.Map.Entry;\n"+
+									"	       ^^^^^^^^^^^^^^^^^^^\n"+
+									"The import java.util.Map.Entry is never used\n"+
+									"----------\n"+
+									"2. ERROR in X.java (at line 6)\n" + 
+									"	* <li> {@link Entry} </li>\n" + 
+									"	              ^^^^^\n" + 
+									"Javadoc: Invalid member type qualification\n" + 
+									"----------\n");
 			return;
 		}
 		runNegativeTest(
@@ -1073,12 +1085,24 @@ public class JavadocTestForClass extends JavadocTest {
 				"	Entry e = null;\n" + 
 				"}\n",
 				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	* <li> {@link Entry} </li>\n" + 
-				"	              ^^^^^\n" + 
-				"Javadoc: Invalid member type qualification\n" + 
-				"----------\n");
+				IS_JRE_8 && this.complianceLevel >= ClassFileConstants.JDK1_5 ? 
+						"----------\n" + 
+						"1. ERROR in X.java (at line 5)\n" + 
+						"	* <li> {@link Entry} </li>\n" + 
+						"	              ^^^^^\n" + 
+						"Javadoc: Invalid member type qualification\n" + 
+						"----------\n":
+							"----------\n" + 
+							"1. ERROR in X.java (at line 5)\n" + 
+							"	* <li> {@link Entry} </li>\n" + 
+							"	              ^^^^^\n" + 
+							"Javadoc: Invalid member type qualification\n" + 
+							"----------\n" + 
+							"2. ERROR in X.java (at line 8)\n" + 
+							"	public interface X extends Map {\n" + 
+							"	                 ^\n" + 
+							"The return types are incompatible for the inherited methods MapStream.values(), Map.values()\n" + 
+							"----------\n");
 	}	
 
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=253750
@@ -1099,17 +1123,29 @@ public class JavadocTestForClass extends JavadocTest {
 						"	Entry e = null;\n" + 
 						"}\n",
 						},
-						"----------\n" + 
-						"1. WARNING in X.java (at line 2)\n"+
-						"	import java.util.Map.Entry;\n"+
-						"	       ^^^^^^^^^^^^^^^^^^^\n"+
-						"The import java.util.Map.Entry is never used\n"+
-						"----------\n"+
-						"2. ERROR in X.java (at line 6)\n" + 
-						"	* <li> {@link Entry} </li>\n" + 
-						"	              ^^^^^\n" + 
-						"Javadoc: Invalid member type qualification\n" + 
-						"----------\n");
+						IS_JRE_8 ? 
+								"----------\n" + 
+								"1. ERROR in X.java (at line 6)\n" + 
+								"	* <li> {@link Entry} </li>\n" + 
+								"	              ^^^^^\n" + 
+								"Javadoc: Invalid member type qualification\n" + 
+								"----------\n" + 
+								"2. ERROR in X.java (at line 9)\n" + 
+								"	public interface X extends Map {\n" + 
+								"	                 ^\n" + 
+								"The return types are incompatible for the inherited methods MapStream.values(), Map.values()\n" + 
+								"----------\n" : 
+									"----------\n" + 
+									"1. WARNING in X.java (at line 2)\n"+
+									"	import java.util.Map.Entry;\n"+
+									"	       ^^^^^^^^^^^^^^^^^^^\n"+
+									"The import java.util.Map.Entry is never used\n"+
+									"----------\n"+
+									"2. ERROR in X.java (at line 6)\n" + 
+									"	* <li> {@link Entry} </li>\n" + 
+									"	              ^^^^^\n" + 
+									"Javadoc: Invalid member type qualification\n" + 
+									"----------\n");
 			return;
 		}
 		runNegativeTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
index 75fd7f5..b9e5e8e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
@@ -845,68 +845,28 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 		"----------\n" + 
 		"2. ERROR in X.java (at line 3)\n" + 
 		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                       ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
 		"	                                       ^^^^^^^^^^^^^^^^\n" + 
 		"Syntax error, type annotations are illegal here\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                       ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"5. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                 ^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"6. ERROR in X.java (at line 3)\n" + 
+		"3. ERROR in X.java (at line 3)\n" + 
 		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
 		"	                                                              ^^^^^^^^^\n" + 
 		"Syntax error, type annotations are illegal here\n" + 
 		"----------\n" + 
-		"7. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                              ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"8. ERROR in X.java (at line 4)\n" + 
+		"4. ERROR in X.java (at line 4)\n" + 
 		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
 		"	                     ^^^^^^^^^\n" + 
 		"Syntax error, type annotations are illegal here\n" + 
 		"----------\n" + 
-		"9. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                     ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"10. ERROR in X.java (at line 4)\n" + 
+		"5. ERROR in X.java (at line 4)\n" + 
 		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
 		"	                                     ^^^^^^^^^^^^^^^^\n" + 
 		"Syntax error, type annotations are illegal here\n" + 
 		"----------\n" + 
-		"11. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                     ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"12. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                               ^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
-		"----------\n" + 
-		"13. ERROR in X.java (at line 4)\n" + 
+		"6. ERROR in X.java (at line 4)\n" + 
 		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
 		"	                                                            ^^^^^^^^^\n" + 
 		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"14. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                            ^^^^^^^^^\n" + 
-		"Only annotation types that explicitly specify TYPE_USE as a possible target element type can be applied here\n" + 
 		"----------\n");
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383950
@@ -973,13 +933,8 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 					"----------\n" + 
 					"1. ERROR in X.java (at line 1)\n" + 
 					"	import @Marker java.lang.String; // Compilation error \n" + 
-					"	^^^^^^\n" + 
-					"Syntax error on token(s), misplaced construct(s)\n" + 
-					"----------\n" + 
-					"2. ERROR in X.java (at line 1)\n" + 
-					"	import @Marker java.lang.String; // Compilation error \n" + 
-					"	        ^^^^^^\n" + 
-					"Syntax error on token \"Marker\", package expected after this token\n" + 
+					"	       ^^^^^^^\n" + 
+					"Syntax error, type annotations are illegal here\n" + 
 					"----------\n");
 	}
 	// Test that type name can't be left out in a cast expression with an annotations 
@@ -997,8 +952,8 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 					"----------\n" + 
 					"1. ERROR in X.java (at line 3)\n" + 
 					"	String myString = (@NonNull) myObject;	}\n" + 
-					"	                    ^^^^^^^\n" + 
-					"Syntax error on token \"NonNull\", void expected after this token\n" + 
+					"	                   ^\n" + 
+					"Syntax error on token \"@\", delete this token\n" + 
 					"----------\n");
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385111
@@ -1365,4 +1320,911 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 				"Duplicate method foo() in type X\n" + 
 				"----------\n");
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
+	public void test383596() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	           ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                        ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                           ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
+	public void test383596a() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	^^^^^^^\n" + 
+			"Package annotations must be in file package-info.java\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                   ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                                   ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
+	public void test039b() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	       ^\n" + 
+			"The import p cannot be resolved\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	          ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                       ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
+	public void test383596b() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	       ^\n" + 
+			"The import p cannot be resolved\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	          ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	                       ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
+	public void test041() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" +
+						"public class X {\n" +
+						"}"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	              ^\n" + 
+				"The import p cannot be resolved\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                 ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                              ^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
+	public void test042() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
+						"public class X {\n" +
+						"}"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	              ^\n" + 
+				"The import p cannot be resolved\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                 ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                              ^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit this.
+	// Much water has flown under the bridge. The grammar itself does not allow annotations in qualified name in explicit this.
+	// We now use the production UnannotatableName instead of plain Name. 
+	public void test043() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"   class Y {\n" +
+			    "       class Z {\n" +
+				"           Z(X. @Marker Y  X.Y.this) {\n" +
+				"           }\n" +
+				"       }\n" +
+				"    }\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	Z(X. @Marker Y  X.Y.this) {\n" + 
+			"	      ^^^^^^\n" + 
+			"Marker cannot be resolved to a type\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call -- super form
+	public void test044() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	static X x;\n" +
+						"	public class InnerBar {\n" +
+						"	}\n" +
+						"	public class SubInnerBar extends InnerBar {\n" +
+						"		SubInnerBar() {\n" +
+						"			X.@Marker x. @Marker @Marker @Marker x.super();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	                                     ^\n" + 
+				"The static field X.x should be accessed in a static way\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, super form with explicit type arguments
+	public void test045() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	static X x;\n" +
+						"	public class InnerBar {\n" +
+						"	}\n" +
+						"	public class SubInnerBar extends InnerBar {\n" +
+						"		SubInnerBar() {\n" +
+						"			X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	                                     ^\n" + 
+				"The static field X.x should be accessed in a static way\n" + 
+				"----------\n" + 
+				"4. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	                                        ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X.InnerBar() of type X.InnerBar; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call - this form
+	public void test046() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	Bar bar;\n" +
+						"	class Bar {\n" +
+						"		//static Bar x;\n" +
+						"		public class InnerBar {\n" +
+						"			InnerBar(Bar x) {\n" +
+						"			}\n" +
+						"		}\n" +
+						"		public class SubInnerBar extends InnerBar {\n" +
+						"			SubInnerBar() {\n" +
+						"				X. @Marker bar.this();\n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"Cannot make a static reference to the non-static field X.bar\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	   ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, this form with explicit type arguments
+	public void test047() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	Bar bar;\n" +
+						"	class Bar {\n" +
+						"		//static Bar x;\n" +
+						"		public class InnerBar {\n" +
+						"			InnerBar(Bar x) {\n" +
+						"			}\n" +
+						"		}\n" +
+						"		public class SubInnerBar extends InnerBar {\n" +
+						"			SubInnerBar() {\n" +
+						"				X.@Marker bar.<String>this();\n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"Cannot make a static reference to the non-static field X.bar\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. WARNING in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	               ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X.Bar.SubInnerBar() of type X.Bar.SubInnerBar; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in PrimaryNoNewArray
+	public void test048() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	X bar;\n" +
+						"	private void foo(X x) {\n" +
+						"		System.out.println((x. @Marker bar));\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	System.out.println((x. @Marker bar));\n" + 
+				"	                       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified this.
+	public void test049() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	class Y {\n" +
+						"		class Z {\n" +
+						"			void foo() {\n" +
+						"				Object o = X.@Marker Y.this; \n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	Object o = X.@Marker Y.this; \n" + 
+				"	             ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" +
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified super.
+	public void test050() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			X. @Marker Y.super.hashCode();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	X. @Marker Y.super.hashCode();\n" + 
+				"	   ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name.class
+	public void test051() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			Class<?> c = X. @Marker @Illegal Y.class;\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Illegal Y.class;\n" + 
+				"	                ^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name [].class.
+	public void test052() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
+				"	                ^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
+				"	                                   ^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in binary expressions with qualified names.
+	public void test053() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"    static int x;\n" +
+						"    static boolean fb;\n" +
+						"	 public void foo(boolean b) {\n" +
+						"		x = (X.@Marker x * 10);\n" +
+						"		x = (X.@Marker x / 10);\n" +
+						"		x = (X.@Marker x % 10);\n" +
+						"		x = (X.@Marker x + 10);\n" +
+						"		x = (X.@Marker x - 10);\n" +
+						"		x = (X.@Marker x << 10);\n" +
+						"		x = (X.@Marker x >> 10);\n" +
+						"		x = (X.@Marker x >>> 10);\n" +
+						"		b = (X.@Marker x < 10);\n" +
+						"		b = (X.@Marker x > 10);\n" +
+						"		b = (X.@Marker x <= 10);\n" +
+						"		b = (X.@Marker x >= 10);\n" +
+						"		b = (X.@Marker x instanceof Object);\n" +
+						"		b = (X.@Marker x == 10);\n" +
+						"		b = (X.@Marker x != 10);\n" +
+						"		x = (X.@Marker x & 10);\n" +
+						"		x = (X.@Marker x ^ 10);\n" +
+						"		x = (X.@Marker x | 10);\n" +
+						"		fb = (X.@Marker fb && true);\n" +
+						"		fb = (X.@Marker fb || true);\n" +
+						"		x = (X.@Marker fb ? 10 : 10);\n" +
+						"	 }\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	x = (X.@Marker x * 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 6)\n" + 
+				"	x = (X.@Marker x / 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 7)\n" + 
+				"	x = (X.@Marker x % 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 8)\n" + 
+				"	x = (X.@Marker x + 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 9)\n" + 
+				"	x = (X.@Marker x - 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"6. ERROR in X.java (at line 10)\n" + 
+				"	x = (X.@Marker x << 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"7. ERROR in X.java (at line 11)\n" + 
+				"	x = (X.@Marker x >> 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"8. ERROR in X.java (at line 12)\n" + 
+				"	x = (X.@Marker x >>> 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"9. ERROR in X.java (at line 13)\n" + 
+				"	b = (X.@Marker x < 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"10. ERROR in X.java (at line 14)\n" + 
+				"	b = (X.@Marker x > 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"11. ERROR in X.java (at line 15)\n" + 
+				"	b = (X.@Marker x <= 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"12. ERROR in X.java (at line 16)\n" + 
+				"	b = (X.@Marker x >= 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"13. ERROR in X.java (at line 17)\n" + 
+				"	b = (X.@Marker x instanceof Object);\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Incompatible conditional operand types int and Object\n" + 
+				"----------\n" + 
+				"14. ERROR in X.java (at line 17)\n" + 
+				"	b = (X.@Marker x instanceof Object);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"15. ERROR in X.java (at line 18)\n" + 
+				"	b = (X.@Marker x == 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"16. ERROR in X.java (at line 19)\n" + 
+				"	b = (X.@Marker x != 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"17. ERROR in X.java (at line 20)\n" + 
+				"	x = (X.@Marker x & 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"18. ERROR in X.java (at line 21)\n" + 
+				"	x = (X.@Marker x ^ 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"19. ERROR in X.java (at line 22)\n" + 
+				"	x = (X.@Marker x | 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"20. ERROR in X.java (at line 23)\n" + 
+				"	fb = (X.@Marker fb && true);\n" + 
+				"	        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"21. ERROR in X.java (at line 24)\n" + 
+				"	fb = (X.@Marker fb || true);\n" + 
+				"	        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"22. ERROR in X.java (at line 25)\n" + 
+				"	x = (X.@Marker fb ? 10 : 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in annotations with qualified names.
+	   This test is disabled. Now the grammar itself forbids annotations in the said place by using the production
+	   AnnotationName ::= '@' UnannotatableName. We don't want to add tests that will be fragile and unstable due to 
+	   syntax. If a construct is provably not parsed at the grammar level, that ought to be good enough.
+	*/
+	public void test054() throws Exception {
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used as annotation values.
+	public void test055() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"@interface Annot {\n" +
+					"	String bar();\n" +
+					"}\n" +
+					"@Annot(bar = X. @Marker s)\n" +
+					"public class X {\n" +
+					"	final static String s = \"\";\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	@Annot(bar = X. @Marker s)\n" + 
+				"	                ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names that are postfix expressions.
+	public void test056() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static int x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x;\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x;\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used in array access.
+	public void test057() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static int x[];\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x[0];\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x[0];\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name with type arguments used in method invocation.
+	public void test058() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x.<String> foo();\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x.<String> foo();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. WARNING in X.java (at line 4)\n" + 
+				"	return X.@Marker x.<String> foo();\n" + 
+				"	                    ^^^^^^\n" + 
+				"Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in method invocation.
+	public void test059() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x. @Blah foo();\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x. @Blah foo();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x. @Blah foo();\n" + 
+				"	                    ^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
+	public void test060() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static Y y;\n" +
+					"    class Y {\n" +
+					"        class Z {\n" +
+					"            void foo() {\n" +
+					"                Z z = X. @Marker y.new Z();\n" +
+					"            }\n" +
+					"        }\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 6)\n" + 
+				"	Z z = X. @Marker y.new Z();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
+	public void test061() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    X getX() {\n" +
+					"        return (X.@Marker x);\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return (X.@Marker x);\n" + 
+				"	          ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test062() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	public <T> @Marker Object foo() {\n" +
+					"	}\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	public <T> @Marker Object foo() {\n" + 
+				"	           ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test063() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = @Marker int.class;\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = @Marker int.class;\n" + 
+				"	           ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test064() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"@interface X {\n" +
+					"	<T> @Marker String foo();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	<T> @Marker String foo();\n" + 
+				"	    ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	<T> @Marker String foo();\n" + 
+				"	                   ^^^^^\n" + 
+				"Annotation attributes cannot be generic\n" + 
+				"----------\n");
+	}
+	public void test065() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new <String> @Marker X();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. WARNING in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X();\n" + 
+				"	                ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X();\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test066() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new X().new <String> @Marker X();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new X().new <String> @Marker X();\n" + 
+				"	                                ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new X().new <String> @Marker X();\n" + 
+				"	                                ^^^^^^^^^\n" + 
+				"X.X cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test067() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = x.new <String> @Marker X() {};\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = x.new <String> @Marker X() {};\n" + 
+				"	           ^\n" + 
+				"x cannot be resolved to a variable\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = x.new <String> @Marker X() {};\n" + 
+				"	                          ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test068() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new <String> @Marker X() {};\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. WARNING in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X() {};\n" + 
+				"	                ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X() {};\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/eval/NegativeCodeSnippetTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/eval/NegativeCodeSnippetTest.java
index 8750f9b..0feafb3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/eval/NegativeCodeSnippetTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/eval/NegativeCodeSnippetTest.java
@@ -1,9 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -151,7 +155,7 @@ public void testInvalidImport() {
 		evaluateWithExpectedImportProblem(buildCharArray(new String[] {
 			"new File(\"c:\\temp\")"}),
 			"{".toCharArray(),
-			newProblem(IProblem.ParsingError, Error, 0, 0, 1)); // Syntax error on token "{", "Identifier" expected
+			newProblem(IProblem.ParsingErrorInvalidToken, Error, 0, 0, 1)); // Syntax error on token "{", "Identifier" expected
 	} finally {
 		// Clean up
 		this.context.setImports(new char[0][]);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
index b9ea950..6dd1c02 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
@@ -765,7 +765,7 @@ public void testBug130778p() throws JavaModelException {
 			"No problem",
 			result);
 }
-public void _testBug130778q() throws JavaModelException {
+public void testBug130778q() throws JavaModelException {
 	this.workingCopies = new ICompilationUnit[2];
 
 	this.workingCopies[0] = getWorkingCopy(
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 4ce4261..f554950 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -752,6 +752,17 @@ private void buildMoreCompletionContext(Expression expression) {
 									this.identifierLengthPtr--;
 								} else {
 									this.identifierLengthStack[this.identifierLengthPtr]--;
+									length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--];
+									Annotation [] typeAnnotations;
+									if (length != 0) {
+										System.arraycopy(
+												this.typeAnnotationStack,
+												(this.typeAnnotationPtr -= length) + 1,
+												typeAnnotations = new Annotation[length],
+												0,
+												length);
+										problemReporter().misplacedTypeAnnotations(typeAnnotations[0], typeAnnotations[typeAnnotations.length - 1]);
+									}
 								}
 								// consume the receiver
 								int identifierLength = this.identifierLengthStack[this.identifierLengthPtr];
@@ -1162,8 +1173,8 @@ private void buildMoreGenericsCompletionContext(ASTNode node, boolean consumeTyp
 						if (consumeTypeArguments) consumeTypeArguments();
 						TypeReference ref;
 						if(prevKind == K_PARAMETERIZED_CAST) {
-							ref = this.getUnannotatedTypeReference(0);  // by design type is not annotated.
-							ref = computeQualifiedGenericsFromRightSide(ref, 0);
+							ref = this.getTypeReference(0);
+							ref = computeQualifiedGenericsFromRightSide(ref, 0, null);
 						} else {
 							ref = this.getTypeReference(0);
 						}
@@ -1571,6 +1582,17 @@ private boolean checkInvocation() {
 						this.identifierLengthPtr--;
 					} else {
 						this.identifierLengthStack[this.identifierLengthPtr]--;
+						int length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--];
+						Annotation [] typeAnnotations;
+						if (length != 0) {
+							System.arraycopy(
+									this.typeAnnotationStack,
+									(this.typeAnnotationPtr -= length) + 1,
+									typeAnnotations = new Annotation[length],
+									0,
+									length);
+							problemReporter().misplacedTypeAnnotations(typeAnnotations[0], typeAnnotations[typeAnnotations.length - 1]);
+						}
 					}
 					// consume the receiver
 					messageSend.receiver = getUnspecifiedReference();
@@ -2100,34 +2122,6 @@ protected void consumeCastExpressionWithPrimitiveType() {
 	cast.sourceStart = castType.sourceStart - 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithPrimitiveTypeWithTypeAnnotations() {
-	popElement(K_CAST_STATEMENT);
-
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	TypeReference typeReference = (TypeReference) this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	cast.sourceStart = typeReference.sourceStart - 1;
-	cast.sourceEnd = expression.sourceEnd;
-}
 protected void consumeCastExpressionWithGenericsArray() {
 	popElement(K_CAST_STATEMENT);
 
@@ -2140,36 +2134,6 @@ protected void consumeCastExpressionWithGenericsArray() {
 	cast.sourceStart = castType.sourceStart - 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithGenericsArrayWithTypeAnnotations() {
-	popElement(K_CAST_STATEMENT);
- 
-	Expression exp = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	// pop the type reference
-	TypeReference typeReference = (TypeReference) this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(exp, typeReference));
-	cast.sourceStart = typeReference.sourceStart - 1;
-	cast.sourceEnd = exp.sourceEnd;
-}
 protected void consumeCastExpressionWithQualifiedGenericsArray() {
 	popElement(K_CAST_STATEMENT);
 
@@ -2182,33 +2146,6 @@ protected void consumeCastExpressionWithQualifiedGenericsArray() {
 	cast.sourceStart = castType.sourceStart - 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithQualifiedGenericsArrayWithTypeAnnotations() {
-	popElement(K_CAST_STATEMENT);
-
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	TypeReference typeReference = (TypeReference) this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	cast.sourceStart = typeReference.sourceStart - 1;
-	cast.sourceEnd = expression.sourceEnd;
-}
 protected void consumeCastExpressionWithNameArray() {
 	// CastExpression ::= PushLPAREN Name Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 	popElement(K_CAST_STATEMENT);
@@ -2222,42 +2159,10 @@ protected void consumeCastExpressionWithNameArray() {
 	cast.sourceStart = castType.sourceStart - 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithNameArrayWithTypeAnnotations() {
-	popElement(K_CAST_STATEMENT);
-
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	TypeReference typeReference = (TypeReference) this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	cast.sourceStart = typeReference.sourceStart - 1;
-	cast.sourceEnd = expression.sourceEnd;
-}
 protected void consumeCastExpressionLL1() {
 	popElement(K_CAST_STATEMENT);
 	super.consumeCastExpressionLL1();
 }
-protected void consumeCastExpressionLL1WithTypeAnnotations() {
-	popElement(K_CAST_STATEMENT);
-	super.consumeCastExpressionLL1WithTypeAnnotations();
-}
 protected void consumeCatchFormalParameter() {
 	if (this.indexOfAssistIdentifier() < 0) {
 		super.consumeCatchFormalParameter();
@@ -2733,31 +2638,34 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 		char[] identifierName = this.identifierStack[this.identifierPtr];
 		long namePositions = this.identifierPositionStack[this.identifierPtr--];
 		int extendedDimensions = this.intStack[this.intPtr--];
+		Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : getAnnotationsOnDimensions(extendedDimensions);
+		Annotation [] varArgsAnnotations = null;
+		int length;
 		int endOfEllipsis = 0;
 		if (isVarArgs) {
 			endOfEllipsis = this.intStack[this.intPtr--];
+			if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+				System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					varArgsAnnotations = new Annotation[length],
+					0,
+					length);
+			} 
 		}
 		int firstDimensions = this.intStack[this.intPtr--];
-		TypeReference type = getUnannotatedTypeReference(extendedDimensions);
-		Annotation [] varArgsAnnotations = null;
-		int length;
-		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-			System.arraycopy(
-				this.typeAnnotationStack,
-				(this.typeAnnotationPtr -= length) + 1,
-				varArgsAnnotations = new Annotation[length],
-				0,
-				length);
-		} 
+		TypeReference type = getTypeReference(firstDimensions);
+		
 		final int typeDimensions = firstDimensions + extendedDimensions + (isVarArgs ? 1 : 0);
-		if (typeDimensions != extendedDimensions) {
+		if (typeDimensions != firstDimensions) {
 			// jsr308 type annotations management
-			Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : getAnnotationsOnDimensions(firstDimensions);
-			Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : type.getAnnotationsOnDimensions();
-			Annotation [][] annotationsOnAllDimensions = null;
-			if (annotationsOnFirstDimensions != null || annotationsOnExtendedDimensions != null || varArgsAnnotations != null) {
-				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions); 
-				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, isVarArgs ? 1 : 0, isVarArgs ? new Annotation[][]{varArgsAnnotations} : null);
+			Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : type.getAnnotationsOnDimensions();
+			Annotation [][] annotationsOnAllDimensions = annotationsOnFirstDimensions;
+			if (annotationsOnExtendedDimensions != null) {
+				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions);
+			}
+			if (varArgsAnnotations != null) {
+				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, 1, new Annotation[][]{varArgsAnnotations});
 			}
 			type = copyDims(type, typeDimensions, annotationsOnAllDimensions);
 			type.sourceEnd = type.isParameterizedTypeReference() ? this.endStatementPosition : this.endPosition;
@@ -2877,24 +2785,6 @@ protected void consumeInsideCastExpressionLL1() {
 	}
 	pushOnElementStack(K_CAST_STATEMENT);
 }
-protected void consumeInsideCastExpressionWithAnnotatedQualifiedGenerics() {
-	popElement(K_PARAMETERIZED_CAST);
-
-	Expression castType;
-	int end = this.intStack[this.intPtr--];
-
-	int dim = this.intStack[this.intPtr--];
-	// TODO is it an annotated type reference?
-	TypeReference rightSide = getUnannotatedTypeReference(0); // by design the type after . is not annotated.
-
-	castType = computeQualifiedGenericsFromRightSide(rightSide, dim);
-	this.intPtr--;
-	castType.sourceEnd = end - 1;
-	castType.sourceStart = this.intStack[this.intPtr--] + 1;
-	pushOnExpressionStack(castType);
-
-	pushOnElementStack(K_CAST_STATEMENT);
-}
 protected void consumeInsideCastExpressionWithQualifiedGenerics() {
 	popElement(K_PARAMETERIZED_CAST);
 
@@ -2902,9 +2792,10 @@ protected void consumeInsideCastExpressionWithQualifiedGenerics() {
 	int end = this.intStack[this.intPtr--];
 
 	int dim = this.intStack[this.intPtr--];
-	TypeReference rightSide = getUnannotatedTypeReference(0); // by design the type after . is not annotated.
+	Annotation[][] annotationsOnDimensions = dim == 0 ? null : getAnnotationsOnDimensions(dim);
+	TypeReference rightSide = getTypeReference(0);
 
-	castType = computeQualifiedGenericsFromRightSide(rightSide, dim);
+	castType = computeQualifiedGenericsFromRightSide(rightSide, dim, annotationsOnDimensions);
 	this.intPtr--;
 	castType.sourceEnd = end - 1;
 	castType.sourceStart = this.intStack[this.intPtr--] + 1;
@@ -3292,14 +3183,14 @@ protected void consumeLabel() {
 	pushOnLabelStack(this.identifierStack[this.identifierPtr]);
 	this.pushOnElementStack(K_LABEL, this.labelPtr);
 }
-protected void consumeMarkerAnnotation() {
+protected void consumeMarkerAnnotation(boolean isTypeAnnotation) {
 	if (this.topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN &&
 			(this.topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) & ANNOTATION_NAME_COMPLETION) != 0 ) {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
 		this.restartRecovery = true;
 	} else {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
-		super.consumeMarkerAnnotation();
+		super.consumeMarkerAnnotation(isTypeAnnotation);
 	}
 }
 protected void consumeMemberValuePair() {
@@ -3374,14 +3265,14 @@ protected void consumeRestoreDiet() {
 		popElement(K_LOCAL_INITIALIZER_DELIMITER);
 	}
 }
-protected void consumeSingleMemberAnnotation() {
+protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
 	if (this.topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN &&
 			(this.topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) & ANNOTATION_NAME_COMPLETION) != 0 ) {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
 		this.restartRecovery = true;
 	} else {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
-		super.consumeSingleMemberAnnotation();
+		super.consumeSingleMemberAnnotation(isTypeAnnotation);
 	}
 }
 protected void consumeSingleStaticImportDeclarationName() {
@@ -3431,14 +3322,14 @@ protected void consumeNestedMethod() {
 	super.consumeNestedMethod();
 	if(!(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BLOCK_DELIMITER)) pushOnElementStack(K_BLOCK_DELIMITER);
 }
-protected void consumeNormalAnnotation() {
+protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
 	if (this.topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN &&
 			(this.topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) & ANNOTATION_NAME_COMPLETION) != 0 ) {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
 		this.restartRecovery = true;
 	} else {
 		popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
-		super.consumeNormalAnnotation();
+		super.consumeNormalAnnotation(isTypeAnnotation);
 	}
 }
 protected void consumePackageDeclarationName() {
@@ -4621,8 +4512,8 @@ protected TypeReference getTypeReferenceForGenericType(int dim,	int identifierLe
 
 	return ref;
 }
-protected NameReference getUnspecifiedReference() {
-	NameReference nameReference = super.getUnspecifiedReference();
+protected NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
+	NameReference nameReference = super.getUnspecifiedReference(rejectTypeAnnotations);
 	if (this.record) {
 		recordReference(nameReference);
 	}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 7c52455..c2cbaaa 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -901,13 +901,13 @@ protected void flushElementStack() {
 /*
  * Build specific type reference nodes in case the cursor is located inside the type reference
  */
-protected TypeReference getUnannotatedTypeReference(int dim) {
+protected TypeReference getTypeReference(int dim) {
 
 	int index;
 
 	/* no need to take action if not inside completed identifiers */
 	if ((index = indexOfAssistIdentifier(true)) < 0) {
-		return super.getUnannotatedTypeReference(dim);
+		return super.getTypeReference(dim);
 	}
 	int length = this.identifierLengthStack[this.identifierLengthPtr];
 	TypeReference reference;
@@ -1066,6 +1066,8 @@ protected NameReference getUnspecifiedReferenceOptimized() {
 		return super.getUnspecifiedReferenceOptimized();
 	}
 
+	consumeNonTypeUseName();
+	
 	/* retrieve identifiers subset and whole positions, the completion node positions
 		should include the entire replaced source. */
 	int length = this.identifierLengthStack[this.identifierLengthPtr];
@@ -1631,7 +1633,6 @@ protected boolean resumeAfterRecovery() {
 	this.astLengthPtr = -1;
 	this.expressionPtr = -1;
 	this.expressionLengthPtr = -1;
-	this.unattachedAnnotationPtr = -1;
 	this.typeAnnotationLengthPtr = -1;
 	this.typeAnnotationPtr = -1;
 	this.identifierPtr = -1;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
index d5439ef..68fe84f 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
@@ -610,31 +610,34 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 		char[] identifierName = this.identifierStack[this.identifierPtr];
 		long namePositions = this.identifierPositionStack[this.identifierPtr--];
 		int extendedDimensions = this.intStack[this.intPtr--];
+		Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : getAnnotationsOnDimensions(extendedDimensions);
+		Annotation [] varArgsAnnotations = null;
+		int length;
 		int endOfEllipsis = 0;
 		if (isVarArgs) {
 			endOfEllipsis = this.intStack[this.intPtr--];
+			if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+				System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					varArgsAnnotations = new Annotation[length],
+					0,
+					length);
+			} 
 		}
 		int firstDimensions = this.intStack[this.intPtr--];
-		TypeReference type = getUnannotatedTypeReference(extendedDimensions);
-		Annotation [] varArgsAnnotations = null;
-		int length;
-		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-			System.arraycopy(
-				this.typeAnnotationStack,
-				(this.typeAnnotationPtr -= length) + 1,
-				varArgsAnnotations = new Annotation[length],
-				0,
-				length);
-		} 
+		TypeReference type = getTypeReference(firstDimensions);
+
 		final int typeDimensions = firstDimensions + extendedDimensions + (isVarArgs ? 1 : 0);
-		if (typeDimensions != extendedDimensions) {
+		if (typeDimensions != firstDimensions) {
 			// jsr308 type annotations management
-			Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : getAnnotationsOnDimensions(firstDimensions);
-			Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : type.getAnnotationsOnDimensions();
-			Annotation [][] annotationsOnAllDimensions = null;
-			if (annotationsOnFirstDimensions != null || annotationsOnExtendedDimensions != null || varArgsAnnotations != null) {
-				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions); 
-				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, isVarArgs ? 1 : 0, isVarArgs ? new Annotation[][]{varArgsAnnotations} : null);
+			Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : type.getAnnotationsOnDimensions();
+			Annotation [][] annotationsOnAllDimensions = annotationsOnFirstDimensions;
+			if (annotationsOnExtendedDimensions != null) {
+				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions);
+			}
+			if (varArgsAnnotations != null) {
+				annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, 1, new Annotation[][]{varArgsAnnotations});
 			}
 			type = copyDims(type, typeDimensions, annotationsOnAllDimensions);
 			type.sourceEnd = type.isParameterizedTypeReference() ? this.endStatementPosition : this.endPosition;
@@ -729,11 +732,11 @@ protected void consumeLocalVariableDeclarationStatement() {
 		}
 	}
 }
-protected void consumeMarkerAnnotation() {
+protected void consumeMarkerAnnotation(boolean isTypeAnnotation) {
 	int index;
 
 	if ((index = this.indexOfAssistIdentifier()) < 0) {
-		super.consumeMarkerAnnotation();
+		super.consumeMarkerAnnotation(isTypeAnnotation);
 		return;
 	}
 
@@ -774,7 +777,11 @@ protected void consumeMarkerAnnotation() {
 
 	markerAnnotation = new MarkerAnnotation(typeReference, this.intStack[this.intPtr--]);
 	markerAnnotation.declarationSourceEnd = markerAnnotation.sourceEnd;
-	pushOnExpressionStack(markerAnnotation);
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(markerAnnotation);
+	} else {
+		pushOnExpressionStack(markerAnnotation);
+	}
 }
 protected void consumeMemberValuePair() {
 	if (this.indexOfAssistIdentifier() < 0) {
@@ -896,11 +903,11 @@ protected void consumeMethodInvocationPrimary() {
 	this.lastCheckPoint = constructorCall.sourceEnd + 1;
 	this.isOrphanCompletionNode = true;
 }
-protected void consumeNormalAnnotation() {
+protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
 	int index;
 
 	if ((index = this.indexOfAssistIdentifier()) < 0) {
-		super.consumeNormalAnnotation();
+		super.consumeNormalAnnotation(isTypeAnnotation);
 		return;
 	}
 
@@ -949,13 +956,17 @@ protected void consumeNormalAnnotation() {
 			length);
 	}
 	normalAnnotation.declarationSourceEnd = this.rParenPos;
-	pushOnExpressionStack(normalAnnotation);
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(normalAnnotation);
+	} else {
+		pushOnExpressionStack(normalAnnotation);
+	}
 }
-protected void consumeSingleMemberAnnotation() {
+protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
 	int index;
 
 	if ((index = this.indexOfAssistIdentifier()) < 0) {
-		super.consumeSingleMemberAnnotation();
+		super.consumeSingleMemberAnnotation(isTypeAnnotation);
 		return;
 	}
 
@@ -998,7 +1009,11 @@ protected void consumeSingleMemberAnnotation() {
 	singleMemberAnnotation.memberValue = this.expressionStack[this.expressionPtr--];
 	this.expressionLengthPtr--;
 	singleMemberAnnotation.declarationSourceEnd = this.rParenPos;
-	pushOnExpressionStack(singleMemberAnnotation);
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(singleMemberAnnotation);
+	} else {
+		pushOnExpressionStack(singleMemberAnnotation);
+	}
 }
 protected void consumeStaticImportOnDemandDeclarationName() {
 	// TypeImportOnDemandDeclarationName ::= 'import' 'static' Name '.' '*'
@@ -1192,25 +1207,32 @@ public CompilationUnitDeclaration dietParse(ICompilationUnit sourceUnit, Compila
 	selectionScanner.selectionEnd = end;
 	return this.dietParse(sourceUnit, compilationResult);
 }
-protected NameReference getUnspecifiedReference() {
+protected NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
 	/* build a (unspecified) NameReference which may be qualified*/
 
 	int completionIndex;
 
 	/* no need to take action if not inside completed identifiers */
 	if ((completionIndex = indexOfAssistIdentifier()) < 0) {
-		return super.getUnspecifiedReference();
+		return super.getUnspecifiedReference(rejectTypeAnnotations);
 	}
 
+	if (rejectTypeAnnotations) {
+		consumeNonTypeUseName();
+	}
 	int length = this.identifierLengthStack[this.identifierLengthPtr];
 	if (CharOperation.equals(assistIdentifier(), SUPER)){
 		Reference reference;
 		if (completionIndex > 0){ // qualified super
 			// discard 'super' from identifier stacks
+			// There is some voodoo going on here in combination with SelectionScanne#scanIdentifierOrKeyword, do in Rome as Romans do and leave the stacks at the right depth.
 			this.identifierLengthStack[this.identifierLengthPtr] = completionIndex;
 			int ptr = this.identifierPtr -= (length - completionIndex);
 			pushOnGenericsLengthStack(0);
 			pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
+			for (int i = 0; i < completionIndex; i++) {
+				pushOnTypeAnnotationLengthStack(0);
+			}
 			reference =
 				new SelectionOnQualifiedSuperReference(
 					getTypeReference(0),
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
index 66a6083..3a68564 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
@@ -44,6 +44,10 @@ public class ArrayQualifiedTypeReference extends QualifiedTypeReference {
 	public Annotation[][] getAnnotationsOnDimensions() {
 		return this.annotationsOnDimensions;
 	}
+	
+	public void setAnnotationsOnDimensions(Annotation [][] annotationsOnDimensions) {
+		this.annotationsOnDimensions = annotationsOnDimensions;
+	}
 
 	/**
 	 * @return char[][]
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
index a233368..1cb3070 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
@@ -57,6 +57,9 @@ public class ArrayTypeReference extends SingleTypeReference {
 	public Annotation[][] getAnnotationsOnDimensions() {
 		return this.annotationsOnDimensions;
 	}
+	public void setAnnotationsOnDimensions(Annotation [][] annotationsOnDimensions) {
+		this.annotationsOnDimensions = annotationsOnDimensions;
+	}
 	/**
 	 * @return char[][]
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 42afe36..f82d2f0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -354,6 +354,10 @@ public Annotation[][] getAnnotationsOnDimensions() {
 	return null;
 }
 
+public void setAnnotationsOnDimensions(Annotation [][] annotationsOnDimensions) {
+	// nothing to do. Subtypes should react suitably.
+}
+
 public abstract char[] getLastToken();
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ConflictedParser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ConflictedParser.java
index a795f04..6ee4085 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ConflictedParser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ConflictedParser.java
@@ -17,7 +17,9 @@ package org.eclipse.jdt.internal.compiler.parser;
 public interface ConflictedParser {
 	
 	/* Return true if at the configuration the parser finds itself in, token would need to be disambiguated.
-	   At Java SE 8 time, we have two tokens that need to clarified: the use of '( and that of '<'
+	   At Java SE 8 time, we have three tokens that need to clarified: the use of '( and that of '<' and finally
+	   whether an @ begins a SE8 style type annotation or a SE5 declaration annotation. Where they can co-exist,
+	   we treat the type annotation as a declarative annotation.
 	*/
 	boolean atConflictScenario(int token);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index aaface4..f1257b4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -168,9 +168,6 @@ public class Parser implements ConflictedParser, ParserBasicInformation, Termina
 	//expression stack
 	protected final static int ExpressionStackIncrement = 100;
 
-	// annotation stack
-	protected final static int TypeAnnotationStackIncrement = 100;
-	
 	protected final static int GenericsStackIncrement = 10;
 
 	private final static String FILEPREFIX = "parser"; //$NON-NLS-1$
@@ -894,7 +891,6 @@ public class Parser implements ConflictedParser, ParserBasicInformation, Termina
 	protected int[] expressionLengthStack;
 	protected int expressionPtr;
 	protected Expression[] expressionStack = new Expression[ExpressionStackIncrement];
-	protected int unattachedAnnotationPtr;  // used for figuring out whether some set of annotations are annotating a dimension or not.
 	public int firstToken ; // handle for multiple parsing goals
 	
 	/* jsr308 -- Type annotation management, we now maintain type annotations in a separate stack
@@ -913,6 +909,9 @@ public class Parser implements ConflictedParser, ParserBasicInformation, Termina
 	protected int typeAnnotationLengthPtr;
 	protected Annotation [] typeAnnotationStack = new Annotation[TypeAnnotationStackIncrement];
 	protected int [] typeAnnotationLengthStack;
+	// annotation stack
+	protected final static int TypeAnnotationStackIncrement = 100;
+	
 	// generics management
 	protected int genericsIdentifiersLengthPtr;
 	protected int[] genericsIdentifiersLengthStack = new int[GenericsStackIncrement];
@@ -998,8 +997,11 @@ private boolean shouldDeferRecovery = false; // https://bugs.eclipse.org/bugs/sh
 private int valueLambdaNestDepth = -1;
 private int stateStackLengthStack[] = new int[0];
 private boolean parsingJava8Plus;
-private int unstackedAct = ERROR_ACTION;
+protected int unstackedAct = ERROR_ACTION;
 
+protected Parser () {
+	// Caveat Emptor: For inheritance purposes and then only in very special needs. Only minimal state is initialized !
+}
 public Parser(ProblemReporter problemReporter, boolean optimizeStringLiterals) {
 
 	this.problemReporter = problemReporter;
@@ -1357,8 +1359,7 @@ protected void checkForDiamond(TypeReference allocType) {
 		}
 	}
 }
-protected ParameterizedQualifiedTypeReference computeQualifiedGenericsFromRightSide(TypeReference rightSide, int dim) {
-	Annotation [][] annotationsOnDimensions = dim == 0 ? null : getAnnotationsOnDimensions(dim);
+protected ParameterizedQualifiedTypeReference computeQualifiedGenericsFromRightSide(TypeReference rightSide, int dim, Annotation [][] annotationsOnDimensions) {
 	int nameSize = this.identifierLengthStack[this.identifierLengthPtr];
 	int tokensSize = nameSize;
 	if (rightSide instanceof ParameterizedSingleTypeReference) {
@@ -1373,15 +1374,24 @@ protected ParameterizedQualifiedTypeReference computeQualifiedGenericsFromRightS
 	TypeReference[][] typeArguments = new TypeReference[tokensSize][];
 	char[][] tokens = new char[tokensSize][];
 	long[] positions = new long[tokensSize];
+	Annotation [][] typeAnnotations = null;
 	if (rightSide instanceof ParameterizedSingleTypeReference) {
 		ParameterizedSingleTypeReference singleParameterizedTypeReference = (ParameterizedSingleTypeReference) rightSide;
 		tokens[nameSize] = singleParameterizedTypeReference.token;
 		positions[nameSize] = (((long) singleParameterizedTypeReference.sourceStart) << 32) + singleParameterizedTypeReference.sourceEnd;
 		typeArguments[nameSize] = singleParameterizedTypeReference.typeArguments;
+		if (singleParameterizedTypeReference.annotations != null) {
+			typeAnnotations = new Annotation[tokensSize][];
+		    typeAnnotations[nameSize] = singleParameterizedTypeReference.annotations[0];
+		}
 	} else if (rightSide instanceof SingleTypeReference) {
 		SingleTypeReference singleTypeReference = (SingleTypeReference) rightSide;
 		tokens[nameSize] = singleTypeReference.token;
 		positions[nameSize] = (((long) singleTypeReference.sourceStart) << 32) + singleTypeReference.sourceEnd;
+		if (singleTypeReference.annotations != null) {
+			typeAnnotations = new Annotation[tokensSize][];
+			typeAnnotations[nameSize] =  singleTypeReference.annotations[0];
+		}
 	} else if (rightSide instanceof ParameterizedQualifiedTypeReference) {
 		ParameterizedQualifiedTypeReference parameterizedTypeReference = (ParameterizedQualifiedTypeReference) rightSide;
 		TypeReference[][] rightSideTypeArguments = parameterizedTypeReference.typeArguments;
@@ -1390,12 +1400,22 @@ protected ParameterizedQualifiedTypeReference computeQualifiedGenericsFromRightS
 		System.arraycopy(rightSideTokens, 0, tokens, nameSize, rightSideTokens.length);
 		long[] rightSidePositions = parameterizedTypeReference.sourcePositions;
 		System.arraycopy(rightSidePositions, 0, positions, nameSize, rightSidePositions.length);
+		Annotation [][] rightSideAnnotations = parameterizedTypeReference.annotations;
+		if (rightSideAnnotations != null) {
+			typeAnnotations = new Annotation[tokensSize][];
+			System.arraycopy(rightSideAnnotations, 0, typeAnnotations, nameSize, rightSideAnnotations.length);
+		}
 	} else if (rightSide instanceof QualifiedTypeReference) {
 		QualifiedTypeReference qualifiedTypeReference = (QualifiedTypeReference) rightSide;
 		char[][] rightSideTokens = qualifiedTypeReference.tokens;
 		System.arraycopy(rightSideTokens, 0, tokens, nameSize, rightSideTokens.length);
 		long[] rightSidePositions = qualifiedTypeReference.sourcePositions;
 		System.arraycopy(rightSidePositions, 0, positions, nameSize, rightSidePositions.length);
+		Annotation [][] rightSideAnnotations = qualifiedTypeReference.annotations;
+		if (rightSideAnnotations != null) {
+			typeAnnotations = new Annotation[tokensSize][];
+			System.arraycopy(rightSideAnnotations, 0, typeAnnotations, nameSize, rightSideAnnotations.length);
+		}
 	}
 
 	int currentTypeArgumentsLength = this.genericsLengthStack[this.genericsLengthPtr--];
@@ -1415,16 +1435,26 @@ protected ParameterizedQualifiedTypeReference computeQualifiedGenericsFromRightS
 	}
 	this.identifierLengthPtr--;
 	ParameterizedQualifiedTypeReference typeRef = new ParameterizedQualifiedTypeReference(tokens, typeArguments, dim, annotationsOnDimensions, positions);
-	int length;
-	if (this.typeAnnotationLengthPtr >= 0 && (length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-		typeRef.annotations = new Annotation[tokensSize][];
-		System.arraycopy(
-			this.typeAnnotationStack,
-			(this.typeAnnotationPtr -= length) + 1,
-			typeRef.annotations[0] = new Annotation[length],
-			0,
-			length);
-		typeRef.sourceStart = typeRef.annotations[0][0].sourceStart;
+
+	while (nameSize > 0) {
+		int length;
+		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+			if (typeAnnotations == null)
+				typeAnnotations = new Annotation[tokensSize][];
+			System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					typeAnnotations[nameSize - 1] = new Annotation[length],
+					0,
+					length);
+			if (nameSize == 1) {
+				typeRef.sourceStart = typeAnnotations[0][0].sourceStart;
+			}
+		}
+		nameSize--;
+	}
+	
+	if ((typeRef.annotations = typeAnnotations) != null) {
 		typeRef.bits |= ASTNode.HasTypeAnnotations;
 	}
 	return typeRef;
@@ -2227,45 +2257,6 @@ protected void consumeCastExpressionLL1() {
 	updateSourcePosition(cast);
 	cast.sourceEnd=exp.sourceEnd;
 }
-protected void consumeCastExpressionLL1WithTypeAnnotations() {
-	// CastExpression ::= '(' Modifiers Name ')' InsideCastExpressionLL1 UnaryExpressionNotPlusMinus
-	// Expression is used in order to make the grammar LL1
-
-	//optimize push/pop
-
-	// pop the expression
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	// pop the type reference
-	TypeReference typeReference = (TypeReference) this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.sourceStart = typeReferenceSourceStart;
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	// pop the two positions for left and right parenthesis 
-	updateSourcePosition(cast);
-	cast.sourceEnd = expression.sourceEnd;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeCastExpressionWithGenericsArray() {
 	// CastExpression ::= PushLPAREN Name TypeArguments Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 
@@ -2283,45 +2274,6 @@ protected void consumeCastExpressionWithGenericsArray() {
 	castType.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithGenericsArrayWithTypeAnnotations() {
-	// CastExpression ::= PushLPAREN Modifiers Name OnlyTypeArgumentsForCastExpression Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
-	int end = this.intStack[this.intPtr--];
-	int dim = this.intStack[this.intPtr--];
-
-	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
-	TypeReference typeReference = getTypeReference(dim);
-	
-	// pop expression
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	this.intPtr--;
-	typeReference.sourceEnd = end - 1;
-	typeReference.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
-	cast.sourceEnd = expression.sourceEnd;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeCastExpressionWithNameArray() {
 	// CastExpression ::= PushLPAREN Name Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 
@@ -2339,46 +2291,6 @@ protected void consumeCastExpressionWithNameArray() {
 	castType.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithNameArrayWithTypeAnnotations() {
-	// CastExpression ::= PushLPAREN Modifiers Name Dims PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
-
-	int end = this.intStack[this.intPtr--];
-
-	// handle type arguments
-	pushOnGenericsLengthStack(0);
-	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
-
-	// pop expression
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	TypeReference typeReference = getTypeReference(this.intStack[this.intPtr--]);
-
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	typeReference.sourceEnd = end - 1;
-	typeReference.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
-	cast.sourceEnd = expression.sourceEnd;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeCastExpressionWithPrimitiveType() {
 	// CastExpression ::= PushLPAREN PrimitiveType Dimsopt PushRPAREN InsideCastExpression UnaryExpression
 
@@ -2395,45 +2307,6 @@ protected void consumeCastExpressionWithPrimitiveType() {
 	castType.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithPrimitiveTypeWithTypeAnnotations() {
-	// CastExpression ::= PushLPAREN Modifiers PrimitiveType Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpression
-
-	//this.intStack : posOfLeftParen dim posOfRightParen
-	int end = this.intStack[this.intPtr--];
-
-	// pop expression
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-
-	TypeReference typeReference = getTypeReference(this.intStack[this.intPtr--]);
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	
-	typeReference.sourceEnd = end - 1;
-	typeReference.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
-	cast.sourceEnd = expression.sourceEnd;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeCastExpressionWithQualifiedGenericsArray() {
 	// CastExpression ::= PushLPAREN Name OnlyTypeArguments '.' ClassOrInterfaceType Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 	Expression exp;
@@ -2442,54 +2315,15 @@ protected void consumeCastExpressionWithQualifiedGenericsArray() {
 	int end = this.intStack[this.intPtr--];
 
 	int dim = this.intStack[this.intPtr--];
-	TypeReference rightSide = getUnannotatedTypeReference(0); // by design the type after . is not annotated.
-
-	ParameterizedQualifiedTypeReference qualifiedParameterizedTypeReference = computeQualifiedGenericsFromRightSide(rightSide, dim);
+	Annotation [][] annotationsOnDimensions = dim == 0 ? null : getAnnotationsOnDimensions(dim);
+	TypeReference rightSide = getTypeReference(0);
+    ParameterizedQualifiedTypeReference qualifiedParameterizedTypeReference = computeQualifiedGenericsFromRightSide(rightSide, dim, annotationsOnDimensions);
 	this.intPtr--;
 	this.expressionStack[this.expressionPtr] = cast = new CastExpression(exp = this.expressionStack[this.expressionPtr], castType = qualifiedParameterizedTypeReference);
 	castType.sourceEnd = end - 1;
 	castType.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
 	cast.sourceEnd = exp.sourceEnd;
 }
-protected void consumeCastExpressionWithQualifiedGenericsArrayWithTypeAnnotations() {
-	// CastExpression ::= PushLPAREN Name OnlyTypeArguments '.' ClassOrInterfaceType Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
-	int end = this.intStack[this.intPtr--];
-
-	int dim = this.intStack[this.intPtr--];
-	// pop expression
-	Expression expression = this.expressionStack[this.expressionPtr--];
-	this.expressionLengthPtr--;
-	
-	TypeReference rightSide = getUnannotatedTypeReference(0); // by design the type after . is not annotated.
-
-	ParameterizedQualifiedTypeReference typeReference = computeQualifiedGenericsFromRightSide(rightSide, dim);
-	this.intPtr--;
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	Expression cast;
-	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
-	typeReference.sourceEnd = end - 1;
-	typeReference.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
-	cast.sourceEnd = expression.sourceEnd;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeCatches() {
 	// Catches ::= Catches CatchClause
 	optimizedConcatNodeLists();
@@ -2828,6 +2662,7 @@ protected void consumeClassInstanceCreationExpressionQualifiedWithTypeArguments(
 				length);
 		}
 		alloc.type = getTypeReference(0);
+		rejectIllegalLeadingTypeAnnotations(alloc.type);
 		checkForDiamond(alloc.type);
 		length = this.genericsLengthStack[this.genericsLengthPtr--];
 		this.genericsPtr -= length;
@@ -2859,6 +2694,7 @@ protected void consumeClassInstanceCreationExpressionQualifiedWithTypeArguments(
 			allocationExpression.sourceStart = this.intStack[this.intPtr--];
 			checkForDiamond(allocationExpression.type);
 		}
+		rejectIllegalLeadingTypeAnnotations(allocationExpression.type);
 	}
 	
 	QualifiedAllocationExpression qae =
@@ -2893,6 +2729,7 @@ protected void consumeClassInstanceCreationExpressionWithTypeArguments() {
 				length);
 		}
 		alloc.type = getTypeReference(0);
+		rejectIllegalLeadingTypeAnnotations(alloc.type);
 		checkForDiamond(alloc.type);
 
 		length = this.genericsLengthStack[this.genericsLengthPtr--];
@@ -2925,6 +2762,7 @@ protected void consumeClassInstanceCreationExpressionWithTypeArguments() {
 			allocationExpression.sourceStart = this.intStack[this.intPtr--];
 			checkForDiamond(allocationExpression.type);
 		}
+		rejectIllegalLeadingTypeAnnotations(allocationExpression.type);
 	}
 }
 protected void consumeClassOrInterface() {
@@ -3675,18 +3513,15 @@ protected Annotation[][] getMergedAnnotationsOnDimensions(int dims, Annotation[]
 		return null;
 
 	Annotation [][] mergedAnnotations = new Annotation[dims + extendedDims][];
-	for (int i = 0; i < dims; i++) {
-		if (annotationsOnDimensions != null) {
+	
+	if (annotationsOnDimensions != null) {
+		for (int i = 0; i < dims; i++) {
 			mergedAnnotations[i] = annotationsOnDimensions[i];
-		} else {
-			mergedAnnotations[i] = null;
-		}
+		} 
 	}
-	for (int i = dims, j = 0; i < dims + extendedDims; i++, j++) {
-		if (annotationsOnExtendedDimensions != null) {
+	if (annotationsOnExtendedDimensions != null) {
+		for (int i = dims, j = 0; i < dims + extendedDims; i++, j++) {
 			mergedAnnotations[i] = annotationsOnExtendedDimensions[j];
-		} else {
-			mergedAnnotations[i] = null;
 		}
 	}
 
@@ -4322,32 +4157,34 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 	char[] identifierName = this.identifierStack[this.identifierPtr];
 	long namePositions = this.identifierPositionStack[this.identifierPtr--];
 	int extendedDimensions = this.intStack[this.intPtr--];
+	Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : getAnnotationsOnDimensions(extendedDimensions);
+	Annotation [] varArgsAnnotations = null;
 	int endOfEllipsis = 0;
+	int length;
 	if (isVarArgs) {
 		endOfEllipsis = this.intStack[this.intPtr--];
+		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+			System.arraycopy(
+				this.typeAnnotationStack,
+				(this.typeAnnotationPtr -= length) + 1,
+				varArgsAnnotations = new Annotation[length],
+				0,
+				length);
+		} 
 	}
 	int firstDimensions = this.intStack[this.intPtr--];
-	TypeReference type = getUnannotatedTypeReference(extendedDimensions);
-	Annotation [] varArgsAnnotations = null;
-	int length;
-	if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-		System.arraycopy(
-			this.typeAnnotationStack,
-			(this.typeAnnotationPtr -= length) + 1,
-			varArgsAnnotations = new Annotation[length],
-			0,
-			length);
-	} 
+	TypeReference type = getTypeReference(firstDimensions);
 	final int typeDimensions = firstDimensions + extendedDimensions + (isVarArgs ? 1 : 0);
 
-	if (typeDimensions != extendedDimensions) {
+	if (typeDimensions != firstDimensions) {
 		// jsr308 type annotations management
-		Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : getAnnotationsOnDimensions(firstDimensions);
-		Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : type.getAnnotationsOnDimensions();
-		Annotation [][] annotationsOnAllDimensions = null;
-		if (annotationsOnFirstDimensions != null || annotationsOnExtendedDimensions != null || varArgsAnnotations != null) {
-			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions); 
-			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, isVarArgs ? 1 : 0, isVarArgs ? new Annotation[][]{varArgsAnnotations} : null);
+		Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : type.getAnnotationsOnDimensions();
+		Annotation [][] annotationsOnAllDimensions = annotationsOnFirstDimensions;
+		if (annotationsOnExtendedDimensions != null) {
+			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions);
+		}
+		if (varArgsAnnotations != null) {
+			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, 1, new Annotation[][]{varArgsAnnotations});
 		}
 		type = copyDims(type, typeDimensions, annotationsOnAllDimensions);
 		type.sourceEnd = type.isParameterizedTypeReference() ? this.endStatementPosition : this.endPosition;
@@ -4405,14 +4242,6 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 				extendedDimensions > 0) {
 			problemReporter().illegalExtendedDimensions(arg);
 		}
-	} else {
-		// The grammar allows trailing annotations in FormalParameter as in 
-		// "int @NonNull[] @Misplaced parameter" in order to allow for constructs such as
-		// "Object @NonNull[] @Correct ... objects" -- we prune these here.
-		if (varArgsAnnotations != null) {
-			problemReporter().misplacedTypeAnnotations(varArgsAnnotations[0],
-					varArgsAnnotations[varArgsAnnotations.length-1]);
-		}
 	}
 }
 protected Annotation[][] getAnnotationsOnDimensions(int dimensionsCount) {
@@ -4498,9 +4327,6 @@ protected void consumeInsideCastExpressionLL1() {
 protected void consumeInsideCastExpressionWithQualifiedGenerics() {
 	// InsideCastExpressionWithQualifiedGenerics ::= $empty
 }
-protected void consumeInsideCastExpressionWithAnnotatedQualifiedGenerics() {
-	// InsideCastExpressionWithAnnotatedQualifiedGenerics ::= $empty
-}
 protected void consumeInstanceOfExpression() {
 	// RelationalExpression ::= RelationalExpression 'instanceof' ReferenceType
 	//optimize the push/pop
@@ -4885,7 +4711,7 @@ protected void consumeLocalVariableDeclarationStatement() {
 	}
 
 }
-protected void consumeMarkerAnnotation() {
+protected void consumeMarkerAnnotation(boolean isTypeAnnotation) {
 	// MarkerAnnotation ::= '@' Name
 	MarkerAnnotation markerAnnotation = null;
 
@@ -4894,7 +4720,11 @@ protected void consumeMarkerAnnotation() {
 	TypeReference typeReference = getAnnotationType();
 	markerAnnotation = new MarkerAnnotation(typeReference, this.intStack[this.intPtr--]);
 	markerAnnotation.declarationSourceEnd = markerAnnotation.sourceEnd;
-	pushOnExpressionStack(markerAnnotation);
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(markerAnnotation);
+	} else {
+		pushOnExpressionStack(markerAnnotation);
+	}
 	if(!this.statementRecoveryActivated &&
 			this.options.sourceLevel < ClassFileConstants.JDK1_5 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
@@ -5164,6 +4994,7 @@ protected void consumeMethodHeaderNameWithTypeParameters(boolean isAnnotationMet
 	this.identifierLengthPtr--;
 	//type
 	TypeReference returnType = getTypeReference(this.intStack[this.intPtr--]);
+	rejectIllegalLeadingTypeAnnotations(returnType);
 	md.returnType = returnType;
 	md.bits |= (returnType.bits & ASTNode.HasTypeAnnotations);
 
@@ -5294,6 +5125,17 @@ protected void consumeMethodInvocationName() {
 		this.identifierLengthPtr--;
 	} else {
 		this.identifierLengthStack[this.identifierLengthPtr]--;
+		int length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--];
+		Annotation [] typeAnnotations;
+		if (length != 0) {
+			System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					typeAnnotations = new Annotation[length],
+					0,
+					length);
+			problemReporter().misplacedTypeAnnotations(typeAnnotations[0], typeAnnotations[typeAnnotations.length - 1]);
+		}
 		m.receiver = getUnspecifiedReference();
 		m.sourceStart = m.receiver.sourceStart;
 	}
@@ -5404,26 +5246,17 @@ protected void consumeMultipleResources() {
 	// Resources ::= Resources ';' Resource
 	concatNodeLists();
 }
-protected void consumeOneMoreTypeAnnotation() {
-	// OneOrMoreAnnotations ::= OneOrMoreAnnotations Annotation
-	this.expressionLengthPtr --;
-	Annotation annotation = (Annotation) this.expressionStack[this.expressionPtr--];
-	pushOnTypeAnnotationStack(annotation);
-	this.typeAnnotationLengthStack[--this.typeAnnotationLengthPtr]++;
-	if(!this.statementRecoveryActivated &&
-			this.options.sourceLevel <= ClassFileConstants.JDK1_7 &&
+protected void consumeTypeAnnotation() {
+	if (!this.statementRecoveryActivated &&
+			this.options.sourceLevel < ClassFileConstants.JDK1_8 &&
 			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
+		Annotation annotation = this.typeAnnotationStack[this.typeAnnotationPtr];
 		problemReporter().invalidUsageOfTypeAnnotations(annotation);
 	}
 }
-protected void consumePotentialNameArrayType () {
-	
-	// FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt PotentialNameArray VariableDeclaratorId
-	// FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt PotentialNameArray '...' VariableDeclaratorId
-	// PotentialNameArray -> $empty
-	// Dimensions including lack of have been pushed appropriately by action attached to DimsoptAnnotsopt
-	pushOnGenericsLengthStack(0); // handle type arguments
-	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
+protected void consumeOneMoreTypeAnnotation() {
+	// OneOrMoreAnnotations ::= OneOrMoreAnnotations Annotation
+	this.typeAnnotationLengthStack[--this.typeAnnotationLengthPtr]++;
 }
 protected void consumeNameArrayType() {
 	pushOnGenericsLengthStack(0); // handle type arguments
@@ -5453,7 +5286,7 @@ protected void consumeNestedType() {
 	this.nestedMethod[this.nestedType] = 0;
 	this.variablesCounter[this.nestedType] = 0;
 }
-protected void consumeNormalAnnotation() {
+protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
 	// NormalAnnotation ::= '@' Name '(' MemberValuePairsopt ')'
 	NormalAnnotation normalAnnotation = null;
 
@@ -5471,7 +5304,12 @@ protected void consumeNormalAnnotation() {
 			length);
 	}
 	normalAnnotation.declarationSourceEnd = this.rParenPos;
-	pushOnExpressionStack(normalAnnotation);
+	
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(normalAnnotation);
+	} else {
+		pushOnExpressionStack(normalAnnotation);
+	}
 
 	if(this.currentElement != null) {
 		annotationRecoveryCheckPoint(normalAnnotation.sourceStart, normalAnnotation.declarationSourceEnd);
@@ -5488,22 +5326,12 @@ protected void consumeNormalAnnotation() {
 	}
 	this.recordStringLiterals = true;
 }
-protected void consumeOneDimLoop(boolean expressionStackMayHaveAnnotations) {
-	// OneDimLoop ::= '[' ']'
-	// OneDimOrAnnot -> '[' ']'
+protected void consumeOneDimLoop(boolean isAnnotated) {
 	this.dimensions++;
-	if (!expressionStackMayHaveAnnotations || this.unattachedAnnotationPtr == -1 ) {
-		pushOnTypeAnnotationLengthStack(0); // no annotations for the current dimension.
-	} else { 
-		this.unattachedAnnotationPtr = -1;	// Leave type annotation stacks they are. 
+	if (!isAnnotated) {
+		pushOnTypeAnnotationLengthStack(0); // signal no annotations for the current dimension.
 	}
 }
-protected void consumeOneDimLoopWithAnnotations() {
-	// OneDimLoop ::= OneOrMoreAnnotations '[' ']'
-	this.dimensions++;
-	// Top of expression stack contains annotations of length specified
-	// by top of expression length stack that apply to this dimension.
-}
 protected void consumeOnlySynchronized() {
 	// OnlySynchronized ::= 'synchronized'
 	pushOnIntStack(this.synchronizedBlockSourceStart);
@@ -5672,17 +5500,8 @@ protected void consumePrimaryNoNewArrayArrayType() {
 	pushOnGenericsLengthStack(0);
 	ClassLiteralAccess cla;
 	pushOnExpressionStack(
-		cla = new ClassLiteralAccess(this.intStack[this.intPtr--], getUnannotatedTypeReference(this.intStack[this.intPtr--])));
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383884
-	Annotation [][] dimensionAnnotations = cla.type.getAnnotationsOnDimensions();
-	if (dimensionAnnotations != null) {
-		for (int i = 0, max = dimensionAnnotations.length; i < max; i++) {
-			Annotation [] annotations = dimensionAnnotations[i];
-			if (annotations != null) {
-				problemReporter().misplacedTypeAnnotations(annotations[0], annotations[annotations.length - 1]);
-			}
-		}
-	}
+		cla = new ClassLiteralAccess(this.intStack[this.intPtr--], getTypeReference(this.intStack[this.intPtr--])));
+	rejectIllegalTypeAnnotations(cla.type);
 }
 protected void consumePrimaryNoNewArrayName() {
 	// PrimaryNoNewArray ::= Name '.' 'class'
@@ -5691,18 +5510,50 @@ protected void consumePrimaryNoNewArrayName() {
 	// handle type arguments
 	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
 	pushOnGenericsLengthStack(0);
-	TypeReference typeReference = getUnannotatedTypeReference(0);
+	TypeReference typeReference = getTypeReference(0);
+	
+	rejectIllegalTypeAnnotations(typeReference);
 
 	pushOnExpressionStack(
 		new ClassLiteralAccess(this.intStack[this.intPtr--], typeReference));
 }
+private void rejectIllegalLeadingTypeAnnotations(TypeReference typeReference) {
+	// Reject misplaced annotations prefixed to a type reference; Used when the grammar is permissive enough to allow them in the first place.
+	Annotation [][]  annotations = typeReference.annotations;
+	if (annotations != null && annotations[0] != null) {
+		problemReporter().misplacedTypeAnnotations(annotations[0][0], annotations[0][annotations[0].length - 1]);
+		annotations[0] = null;  // don't complain further.
+	}
+}
+private void rejectIllegalTypeAnnotations(TypeReference typeReference) {
+	// Reject misplaced annotations on type reference; Used when grammar is permissive enough to allow them in the first place.
+	Annotation [][]  annotations = typeReference.annotations;
+	Annotation[] misplacedAnnotations;
+	for (int i = 0, length = annotations == null ? 0 : annotations.length; i < length; i++) {
+		misplacedAnnotations =  annotations[i];
+		if (misplacedAnnotations != null) {
+			problemReporter().misplacedTypeAnnotations(misplacedAnnotations[0], misplacedAnnotations[misplacedAnnotations.length - 1]);
+		}
+	}
+	annotations = typeReference.getAnnotationsOnDimensions();
+	for (int i = 0, length = annotations == null ? 0 : annotations.length; i < length; i++) {
+		misplacedAnnotations = annotations[i];
+		if (misplacedAnnotations != null) {
+			problemReporter().misplacedTypeAnnotations(misplacedAnnotations[0], misplacedAnnotations[misplacedAnnotations.length - 1]);
+		}
+	}
+	typeReference.annotations = null;
+	typeReference.setAnnotationsOnDimensions(null);
+	typeReference.bits &= ~ASTNode.HasTypeAnnotations;
+}
 protected void consumePrimaryNoNewArrayNameSuper() {
 	// PrimaryNoNewArray ::= Name '.' 'super'
 	// handle type arguments
 	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
 	pushOnGenericsLengthStack(0);
-	TypeReference typeReference = getUnannotatedTypeReference(0);
-
+	// javac does not accept annotations here anywhere ...
+	TypeReference typeReference = getTypeReference(0);
+	rejectIllegalTypeAnnotations(typeReference);
 	pushOnExpressionStack(
 		new QualifiedSuperReference(
 			typeReference,
@@ -5714,8 +5565,9 @@ protected void consumePrimaryNoNewArrayNameThis() {
 	// handle type arguments
 	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
 	pushOnGenericsLengthStack(0); // handle type arguments
-	TypeReference typeReference = getUnannotatedTypeReference(0);
-
+	// javac does not accept annotations here anywhere ...
+	TypeReference typeReference = getTypeReference(0);
+	rejectIllegalTypeAnnotations(typeReference);
 	pushOnExpressionStack(
 		new QualifiedThisReference(
 			typeReference,
@@ -5727,30 +5579,23 @@ protected void consumePrimaryNoNewArrayPrimitiveArrayType() {
 	this.intPtr--; // remove the class start position
 	ClassLiteralAccess cla;
 	pushOnExpressionStack(
-		cla = new ClassLiteralAccess(this.intStack[this.intPtr--], getUnannotatedTypeReference(this.intStack[this.intPtr--])));
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383884
-	Annotation [][] dimensionAnnotations = cla.type.getAnnotationsOnDimensions();
-	if (dimensionAnnotations != null) {
-		for (int i = 0, max = dimensionAnnotations.length; i < max; i++) {
-			Annotation [] annotations = dimensionAnnotations[i];
-			if (annotations != null) {
-				problemReporter().misplacedTypeAnnotations(annotations[0], annotations[annotations.length - 1]);
-			}
-		}
-	}
+		cla = new ClassLiteralAccess(this.intStack[this.intPtr--], getTypeReference(this.intStack[this.intPtr--])));
+	rejectIllegalTypeAnnotations(cla.type);
 }
 protected void consumePrimaryNoNewArrayPrimitiveType() {
 	// PrimaryNoNewArray ::= PrimitiveType '.' 'class'
 	this.intPtr--; // remove the class start position
+	ClassLiteralAccess cla;
 	pushOnExpressionStack(
-		new ClassLiteralAccess(this.intStack[this.intPtr--], getUnannotatedTypeReference(0)));
+		cla = new ClassLiteralAccess(this.intStack[this.intPtr--], getTypeReference(0)));
+	rejectIllegalTypeAnnotations(cla.type);
 }
 protected void consumePrimaryNoNewArrayThis() {
 	// PrimaryNoNewArray ::= 'this'
 	pushOnExpressionStack(new ThisReference(this.intStack[this.intPtr--], this.endPosition));
 }
 protected void consumePrimaryNoNewArrayWithName() {
-	// PrimaryNoNewArray ::=  PushLPAREN Expression PushRPAREN
+	// PrimaryNoNewArray ::=  PushLPAREN Name PushRPAREN
 	pushOnExpressionStack(getUnspecifiedReferenceOptimized());
 	final Expression parenthesizedExpression = this.expressionStack[this.expressionPtr];
 	updateSourcePosition(parenthesizedExpression);
@@ -5793,7 +5638,17 @@ protected void consumePushRealModifiers() {
 	pushOnIntStack(this.modifiersSourceStart);
 	resetModifiers();
 }
-protected void consumeQualifiedName() {
+protected void consumeQualifiedName(boolean qualifiedNameIsAnnotated) {
+	// QualifiedName ::= Name '.' SimpleName
+	/*back from the recursive loop of QualifiedName.
+	Updates identifier length into the length stack*/
+
+	this.identifierLengthStack[--this.identifierLengthPtr]++;
+	if (!qualifiedNameIsAnnotated) {
+		pushOnTypeAnnotationLengthStack(0);
+	}
+}
+protected void consumeUnannotatableQualifiedName() {
 	// QualifiedName ::= Name '.' SimpleName
 	/*back from the recursive loop of QualifiedName.
 	Updates identifier length into the length stack*/
@@ -5874,2147 +5729,1924 @@ protected void consumeRightParen() {
 	// PushRPAREN ::= ')'
 	pushOnIntStack(this.rParenPos);
 }
-protected void consumeUnannotatedType() {
-	/* We go through some song & dance here to get the type annotations stacks
-	   to reflect the fact that this type was unannotated. Using a dummy non-terminal
-	   with an empty rhs leads to conflicts in many places :-(
-	*/
-	pushOnTypeAnnotationLengthStack(0); // either done or else made room.
-	int dims = this.intStack[this.intPtr];
-	if (dims != 0) {
-		System.arraycopy(
-				this.typeAnnotationLengthStack,
-				this.typeAnnotationLengthPtr - dims,
-				this.typeAnnotationLengthStack,
-				this.typeAnnotationLengthPtr - dims + 1,
-				dims);
-		this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr - dims] = 0; // tag type as unannotated
-	}
-}
-protected void consumeAnnotatedType() {
-	/* We go through some song & dance here to get the type annotations stacks
-	   to reflect the fact that this type was unannotated. Using a dummy non-terminal
-	   with an empty rhs leads to conflicts in many places :-(
-	*/
-	int dims = this.intStack[this.intPtr];
-	if (dims != 0) {
-		int counter = 0;
-		for (int i = 0; i < dims; i++) {
-			// we count existing dimensions with annotations
-			counter += this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr - dims + 1 + i];
-		}
-		System.arraycopy(
-				this.typeAnnotationLengthStack,
-				this.typeAnnotationLengthPtr - dims + 1,
-				this.typeAnnotationLengthStack,
-				this.typeAnnotationLengthPtr - dims + 2,
-				dims);
-		int length = this.expressionLengthStack[this.expressionLengthPtr--];
-		this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr - dims + 1] = length;
-		int typeAnnotationStackLength = this.typeAnnotationStack.length;
-		if (this.typeAnnotationPtr + counter + length >= typeAnnotationStackLength) {
+protected void consumeNonTypeUseName() { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596
+	// NonTypeUseName ::= $empty
+	// We can get here with type annotation stack empty, because completion parser manipulates the identifier stacks even without rule reduction. See completionIdentifierCheck
+	for (int i = this.identifierLengthStack[this.identifierLengthPtr]; i > 0 && this.typeAnnotationLengthPtr >= 0; --i) {
+		int length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--];
+		Annotation [] typeAnnotations;
+		if (length != 0) {
 			System.arraycopy(
 					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					typeAnnotations = new Annotation[length],
 					0,
-					this.typeAnnotationStack = new Annotation[typeAnnotationStackLength + TypeAnnotationStackIncrement],
-					0,
-					typeAnnotationStackLength);
-		}
-		System.arraycopy(
-				this.typeAnnotationStack,
-				this.typeAnnotationPtr - counter + 1,
-				this.typeAnnotationStack,
-				this.typeAnnotationPtr - counter + 1 + length,
-				counter);
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				this.typeAnnotationStack,
-				this.typeAnnotationPtr - counter + 1,
-				length);
-		this.typeAnnotationPtr += length;
-		this.typeAnnotationLengthPtr++;
-	} else {
-		int length = this.expressionLengthStack[this.expressionLengthPtr--];
-		int typeAnnotationStackLength = this.typeAnnotationStack.length;
-		if (this.typeAnnotationPtr + length >= typeAnnotationStackLength) {
-			System.arraycopy(
-					this.typeAnnotationStack,
-					0,
-					this.typeAnnotationStack = new Annotation[typeAnnotationStackLength + TypeAnnotationStackIncrement],
-					0,
-					typeAnnotationStackLength);
-		}
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				this.typeAnnotationStack,
-				this.typeAnnotationPtr + 1,
-				length);
-		this.typeAnnotationPtr += length;
-		pushOnTypeAnnotationLengthStack(length);
-	}
-//	if (this.modifiers != ClassFileConstants.AccDefault) {
-//		problemReporter().invalidLocationForModifiers(typeReference);
-//	}
-//	resetModifiers();
-}
-protected void consumeTypeAnnotation (boolean markAsUnattached) {
-	if(!this.statementRecoveryActivated &&
-			this.options.sourceLevel <= ClassFileConstants.JDK1_7 &&
-			this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
-		problemReporter().invalidUsageOfTypeAnnotations((Annotation) this.expressionStack[this.expressionPtr]);
-	}
-	this.expressionLengthPtr --;
-	Annotation annotation = (Annotation) this.expressionStack[this.expressionPtr--];
-	pushOnTypeAnnotationStack(annotation);
-	if (markAsUnattached) {
-		if (this.unattachedAnnotationPtr == -1) {
-			this.unattachedAnnotationPtr = this.typeAnnotationPtr;
-		} else {
-			this.typeAnnotationLengthStack[--this.typeAnnotationLengthPtr]++;
+					length);
+			problemReporter().misplacedTypeAnnotations(typeAnnotations[0], typeAnnotations[typeAnnotations.length - 1]);
 		}
-	} 
-}
-protected void consumeDimsWithTrailingAnnotsopt() {
-	// DimsoptAnnotsopt -> DimsAnnotLoop
-	pushOnIntStack(this.dimensions);
-	this.dimensions = 0;
-	if (this.unattachedAnnotationPtr == -1) {
-		pushOnTypeAnnotationLengthStack(0); // no trailing annotations (receiver/vararg)
-	} else {
-		this.unattachedAnnotationPtr = -1;  // reset this and leave the annotation stacks as they are.
-	}
-}
-protected void consumeZeroTypeAnnotations(boolean shouldPush) {
-	if (shouldPush) {
-		pushOnTypeAnnotationLengthStack(0);
-	} else {
-		this.typeAnnotationLengthPtr --; // pop the 0 from the length stack
 	}
 }
-protected void consumeEmptyDimsoptAnnotsopt() {
-	// DimsoptAnnotsopt ::= $empty
-	pushOnIntStack(0);  // signal a non array
-	pushOnTypeAnnotationLengthStack(0); // no trailing annotations (receiver/vararg)
-}
-protected void consumeRightParenForUnannotatedTypeCast() {
-	consumeUnannotatedType();
-	// PushRPAREN ::= ')'
-	pushOnIntStack(this.rParenPos);
-}
-protected void consumeRightParenForNameUnannotatedTypeCast() {
-	pushOnIntStack(0);  // signal a non array
-	consumeUnannotatedType();
-	// remove the fake dimension
-	this.intPtr--;
-	// PushRPAREN ::= ')'
-	pushOnIntStack(this.rParenPos);
-}
-protected void consumeRightParenForAnnotatedTypeCast() {
-	consumeUnannotatedType();
-	// PushRPAREN ::= ')'
-	pushOnIntStack(this.rParenPos);
-}
-protected void consumeRightParenForNameAndAnnotatedTypeCast() {
-	// push a zero for dimensions
-	pushOnIntStack(0);
-	consumeUnannotatedType();
-	// remove the fake dimension
-	this.intPtr--;
-	// PushRPAREN ::= ')'
-	pushOnIntStack(this.rParenPos);
+protected void consumeZeroTypeAnnotations() {
+	pushOnTypeAnnotationLengthStack(0); // signal absence of @308 annotations.
 }
 // This method is part of an automatic generation : do NOT edit-modify
 protected void consumeRule(int act) {
   switch ( act ) {
-    case 34 : if (DEBUG) { System.out.println("Type ::= TypeInternal"); }  //$NON-NLS-1$
-		    consumeUnannotatedType();   
+    case 33 : if (DEBUG) { System.out.println("Type ::= PrimitiveType"); }  //$NON-NLS-1$
+		    consumePrimitiveType();  
 			break;
  
-    case 36 : if (DEBUG) { System.out.println("Type0 ::= TypeInternal"); }  //$NON-NLS-1$
-		    consumeUnannotatedType();   
+    case 47 : if (DEBUG) { System.out.println("ReferenceType ::= ClassOrInterfaceType"); }  //$NON-NLS-1$
+		    consumeReferenceType();  
 			break;
  
-    case 37 : if (DEBUG) { System.out.println("TypeInternal ::= PrimitiveType"); }  //$NON-NLS-1$
-		    consumePrimitiveType();  
+    case 51 : if (DEBUG) { System.out.println("ClassOrInterface ::= Name"); }  //$NON-NLS-1$
+		    consumeClassOrInterfaceName();  
 			break;
  
-    case 51 : if (DEBUG) { System.out.println("ReferenceType ::= ReferenceType0"); }  //$NON-NLS-1$
-		    consumeUnannotatedType();   
+    case 52 : if (DEBUG) { System.out.println("ClassOrInterface ::= GenericType DOT Name"); }  //$NON-NLS-1$
+		    consumeClassOrInterface();  
 			break;
  
-    case 52 : if (DEBUG) { System.out.println("ReferenceType ::= Modifiers ReferenceType0"); }  //$NON-NLS-1$
-		    consumeAnnotatedType();   
+    case 53 : if (DEBUG) { System.out.println("GenericType ::= ClassOrInterface TypeArguments"); }  //$NON-NLS-1$
+		    consumeGenericType();  
 			break;
  
-    case 53 : if (DEBUG) { System.out.println("ReferenceType0 ::= ClassOrInterfaceType0"); }  //$NON-NLS-1$
-		    consumeReferenceType();   
+    case 54 : if (DEBUG) { System.out.println("GenericType ::= ClassOrInterface LESS GREATER"); }  //$NON-NLS-1$
+		    consumeGenericTypeWithDiamond();  
 			break;
  
-    case 55 : if (DEBUG) { System.out.println("Annotationsopt ::="); }  //$NON-NLS-1$
-		    consumeZeroTypeAnnotations(true);  
+    case 55 : if (DEBUG) { System.out.println("ArrayTypeWithTypeArgumentsName ::= GenericType DOT Name"); }  //$NON-NLS-1$
+		    consumeArrayTypeWithTypeArgumentsName();  
 			break;
  
-    case 60 : if (DEBUG) { System.out.println("ClassOrInterface ::= ClassOrInterface0"); }  //$NON-NLS-1$
-		    consumeZeroTypeAnnotations(true);  
+    case 56 : if (DEBUG) { System.out.println("ArrayType ::= PrimitiveType Dims"); }  //$NON-NLS-1$
+		    consumePrimitiveArrayType();  
 			break;
  
-    case 61 : if (DEBUG) { System.out.println("ClassOrInterface0 ::= Name"); }  //$NON-NLS-1$
-		    consumeClassOrInterfaceName();   
+    case 57 : if (DEBUG) { System.out.println("ArrayType ::= Name Dims"); }  //$NON-NLS-1$
+		    consumeNameArrayType();  
 			break;
  
-    case 63 : if (DEBUG) { System.out.println("PopZeroTypeAnnotations ::="); }  //$NON-NLS-1$
-		    consumeZeroTypeAnnotations(false);  
+    case 58 : if (DEBUG) { System.out.println("ArrayType ::= ArrayTypeWithTypeArgumentsName Dims"); }  //$NON-NLS-1$
+		    consumeGenericTypeNameArrayType();  
 			break;
  
-    case 64 : if (DEBUG) { System.out.println("GenericType ::= ClassOrInterface TypeArguments..."); }  //$NON-NLS-1$
-		    consumeGenericType();   
+    case 59 : if (DEBUG) { System.out.println("ArrayType ::= GenericType Dims"); }  //$NON-NLS-1$
+		    consumeGenericTypeArrayType();  
 			break;
  
-    case 65 : if (DEBUG) { System.out.println("GenericTypeDotName ::= GenericType DOT Name"); }  //$NON-NLS-1$
-		    consumeClassOrInterface();   
+    case 61 : if (DEBUG) { System.out.println("Name ::= SimpleName"); }  //$NON-NLS-1$
+		    consumeZeroTypeAnnotations();  
 			break;
  
-    case 66 : if (DEBUG) { System.out.println("GenericType ::= ClassOrInterface LESS GREATER..."); }  //$NON-NLS-1$
-		    consumeGenericTypeWithDiamond();  
+    case 66 : if (DEBUG) { System.out.println("UnannotatableName ::= UnannotatableName DOT SimpleName"); }  //$NON-NLS-1$
+		    consumeUnannotatableQualifiedName();  
 			break;
  
-    case 68 : if (DEBUG) { System.out.println("ArrayType ::= PrimitiveType Dims"); }  //$NON-NLS-1$
-		    consumePrimitiveArrayType();  
+    case 67 : if (DEBUG) { System.out.println("QualifiedName ::= Name DOT SimpleName"); }  //$NON-NLS-1$
+		    consumeQualifiedName(false);  
 			break;
  
-    case 69 : if (DEBUG) { System.out.println("ArrayType ::= Name Dims"); }  //$NON-NLS-1$
-		    consumeNameArrayType();  
+    case 68 : if (DEBUG) { System.out.println("QualifiedName ::= Name DOT TypeAnnotations SimpleName"); }  //$NON-NLS-1$
+		    consumeQualifiedName(true);  
 			break;
  
-    case 70 : if (DEBUG) { System.out.println("ArrayType ::= ArrayTypeWithTypeArgumentsName Dims"); }  //$NON-NLS-1$
-		    consumeGenericTypeNameArrayType();  
+    case 69 : if (DEBUG) { System.out.println("TypeAnnotationsopt ::="); }  //$NON-NLS-1$
+		    consumeZeroTypeAnnotations();  
 			break;
  
-    case 71 : if (DEBUG) { System.out.println("ArrayType ::= GenericType Dims"); }  //$NON-NLS-1$
-		    consumeGenericTypeArrayType();  
+     case 72 : if (DEBUG) { System.out.println("TypeAnnotations ::= TypeAnnotations TypeAnnotation"); }  //$NON-NLS-1$
+		    consumeOneMoreTypeAnnotation();  
+			break;
+ 
+     case 73 : if (DEBUG) { System.out.println("TypeAnnotation ::= NormalTypeAnnotation"); }  //$NON-NLS-1$
+		    consumeTypeAnnotation();  
+			break;
+ 
+     case 74 : if (DEBUG) { System.out.println("TypeAnnotation ::= MarkerTypeAnnotation"); }  //$NON-NLS-1$
+		    consumeTypeAnnotation();  
+			break;
+ 
+     case 75 : if (DEBUG) { System.out.println("TypeAnnotation ::= SingleMemberTypeAnnotation"); }  //$NON-NLS-1$
+		    consumeTypeAnnotation();  
+			break;
+ 
+    case 76 : if (DEBUG) { System.out.println("TypeAnnotationName ::= AT308 UnannotatableName"); }  //$NON-NLS-1$
+		    consumeAnnotationName() ;  
 			break;
  
-    case 76 : if (DEBUG) { System.out.println("QualifiedName ::= Name DOT SimpleName"); }  //$NON-NLS-1$
-		    consumeQualifiedName();  
+    case 77 : if (DEBUG) { System.out.println("NormalTypeAnnotation ::= TypeAnnotationName LPAREN..."); }  //$NON-NLS-1$
+		    consumeNormalAnnotation(true) ;  
 			break;
  
-    case 77 : if (DEBUG) { System.out.println("CompilationUnit ::= EnterCompilationUnit..."); }  //$NON-NLS-1$
+    case 78 : if (DEBUG) { System.out.println("MarkerTypeAnnotation ::= TypeAnnotationName"); }  //$NON-NLS-1$
+		    consumeMarkerAnnotation(true) ;  
+			break;
+ 
+    case 79 : if (DEBUG) { System.out.println("SingleMemberTypeAnnotation ::= TypeAnnotationName LPAREN"); }  //$NON-NLS-1$
+		    consumeSingleMemberAnnotation(true) ;  
+			break;
+ 
+    case 80 : if (DEBUG) { System.out.println("RejectTypeAnnotations ::="); }  //$NON-NLS-1$
+		    consumeNonTypeUseName();  
+			break;
+ 
+    case 81 : if (DEBUG) { System.out.println("PushZeroTypeAnnotations ::="); }  //$NON-NLS-1$
+		    consumeZeroTypeAnnotations();  
+			break;
+ 
+    case 82 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= this"); }  //$NON-NLS-1$
+		    consumeExplicitThisParameter(false);  
+			break;
+ 
+    case 83 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= UnannotatableName DOT this"); }  //$NON-NLS-1$
+		    consumeExplicitThisParameter(true);  
+			break;
+ 
+    case 84 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= VariableDeclaratorId"); }  //$NON-NLS-1$
+		    consumeVariableDeclaratorIdParameter();  
+			break;
+ 
+    case 85 : if (DEBUG) { System.out.println("CompilationUnit ::= EnterCompilationUnit..."); }  //$NON-NLS-1$
 		    consumeCompilationUnit();  
 			break;
  
-    case 78 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration"); }  //$NON-NLS-1$
+    case 86 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration"); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnit();  
 			break;
  
-    case 79 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
+    case 87 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnit();  
 			break;
  
-    case 80 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
+    case 88 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnitWithTypes();  
 			break;
  
-    case 81 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
+    case 89 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= PackageDeclaration..."); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnitWithTypes();  
 			break;
  
-    case 82 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= ImportDeclarations..."); }  //$NON-NLS-1$
+    case 90 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= ImportDeclarations..."); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnit();  
 			break;
  
-    case 83 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= TypeDeclarations"); }  //$NON-NLS-1$
+    case 91 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= TypeDeclarations"); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnitWithTypes();  
 			break;
  
-    case 84 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= ImportDeclarations..."); }  //$NON-NLS-1$
+    case 92 : if (DEBUG) { System.out.println("InternalCompilationUnit ::= ImportDeclarations..."); }  //$NON-NLS-1$
 		    consumeInternalCompilationUnitWithTypes();  
 			break;
  
-    case 85 : if (DEBUG) { System.out.println("InternalCompilationUnit ::="); }  //$NON-NLS-1$
+    case 93 : if (DEBUG) { System.out.println("InternalCompilationUnit ::="); }  //$NON-NLS-1$
 		    consumeEmptyInternalCompilationUnit();  
 			break;
  
-    case 86 : if (DEBUG) { System.out.println("ReduceImports ::="); }  //$NON-NLS-1$
+    case 94 : if (DEBUG) { System.out.println("ReduceImports ::="); }  //$NON-NLS-1$
 		    consumeReduceImports();  
 			break;
  
-    case 87 : if (DEBUG) { System.out.println("EnterCompilationUnit ::="); }  //$NON-NLS-1$
+    case 95 : if (DEBUG) { System.out.println("EnterCompilationUnit ::="); }  //$NON-NLS-1$
 		    consumeEnterCompilationUnit();  
 			break;
  
-    case 106 : if (DEBUG) { System.out.println("CatchHeader ::= catch LPAREN CatchFormalParameter RPAREN"); }  //$NON-NLS-1$
+    case 111 : if (DEBUG) { System.out.println("CatchHeader ::= catch LPAREN CatchFormalParameter RPAREN"); }  //$NON-NLS-1$
 		    consumeCatchHeader();  
 			break;
  
-    case 108 : if (DEBUG) { System.out.println("ImportDeclarations ::= ImportDeclarations..."); }  //$NON-NLS-1$
+    case 113 : if (DEBUG) { System.out.println("ImportDeclarations ::= ImportDeclarations..."); }  //$NON-NLS-1$
 		    consumeImportDeclarations();  
 			break;
  
-    case 110 : if (DEBUG) { System.out.println("TypeDeclarations ::= TypeDeclarations TypeDeclaration"); }  //$NON-NLS-1$
+    case 115 : if (DEBUG) { System.out.println("TypeDeclarations ::= TypeDeclarations TypeDeclaration"); }  //$NON-NLS-1$
 		    consumeTypeDeclarations();  
 			break;
  
-    case 111 : if (DEBUG) { System.out.println("PackageDeclaration ::= PackageDeclarationName SEMICOLON"); }  //$NON-NLS-1$
+    case 116 : if (DEBUG) { System.out.println("PackageDeclaration ::= PackageDeclarationName SEMICOLON"); }  //$NON-NLS-1$
 		    consumePackageDeclaration();  
 			break;
  
-    case 112 : if (DEBUG) { System.out.println("PackageDeclarationName ::= Modifiers package..."); }  //$NON-NLS-1$
+    case 117 : if (DEBUG) { System.out.println("PackageDeclarationName ::= Modifiers package..."); }  //$NON-NLS-1$
 		    consumePackageDeclarationNameWithModifiers();  
 			break;
  
-    case 113 : if (DEBUG) { System.out.println("PackageDeclarationName ::= PackageComment package Name"); }  //$NON-NLS-1$
-		     consumePackageDeclarationName();  
+    case 118 : if (DEBUG) { System.out.println("PackageDeclarationName ::= PackageComment package Name"); }  //$NON-NLS-1$
+		    consumePackageDeclarationName();  
 			break;
  
-    case 114 : if (DEBUG) { System.out.println("PackageComment ::="); }  //$NON-NLS-1$
+    case 119 : if (DEBUG) { System.out.println("PackageComment ::="); }  //$NON-NLS-1$
 		    consumePackageComment();  
 			break;
  
-    case 119 : if (DEBUG) { System.out.println("SingleTypeImportDeclaration ::=..."); }  //$NON-NLS-1$
+    case 124 : if (DEBUG) { System.out.println("SingleTypeImportDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeImportDeclaration();  
 			break;
  
-    case 120 : if (DEBUG) { System.out.println("SingleTypeImportDeclarationName ::= import Name"); }  //$NON-NLS-1$
+    case 125 : if (DEBUG) { System.out.println("SingleTypeImportDeclarationName ::= import Name..."); }  //$NON-NLS-1$
 		    consumeSingleTypeImportDeclarationName();  
 			break;
  
-    case 121 : if (DEBUG) { System.out.println("TypeImportOnDemandDeclaration ::=..."); }  //$NON-NLS-1$
+    case 126 : if (DEBUG) { System.out.println("TypeImportOnDemandDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeImportDeclaration();  
 			break;
  
-    case 122 : if (DEBUG) { System.out.println("TypeImportOnDemandDeclarationName ::= import Name DOT..."); }  //$NON-NLS-1$
+    case 127 : if (DEBUG) { System.out.println("TypeImportOnDemandDeclarationName ::= import Name DOT..."); }  //$NON-NLS-1$
 		    consumeTypeImportOnDemandDeclarationName();  
 			break;
  
-     case 125 : if (DEBUG) { System.out.println("TypeDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
+     case 130 : if (DEBUG) { System.out.println("TypeDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeEmptyTypeDeclaration();  
 			break;
  
-    case 129 : if (DEBUG) { System.out.println("Modifiers ::= Modifiers Modifier"); }  //$NON-NLS-1$
+    case 134 : if (DEBUG) { System.out.println("Modifiers ::= Modifiers Modifier"); }  //$NON-NLS-1$
 		    consumeModifiers2();  
 			break;
  
-    case 141 : if (DEBUG) { System.out.println("Modifier ::= Annotation"); }  //$NON-NLS-1$
+    case 146 : if (DEBUG) { System.out.println("Modifier ::= Annotation"); }  //$NON-NLS-1$
 		    consumeAnnotationAsModifier();  
 			break;
  
-    case 142 : if (DEBUG) { System.out.println("ClassDeclaration ::= ClassHeader ClassBody"); }  //$NON-NLS-1$
+    case 147 : if (DEBUG) { System.out.println("ClassDeclaration ::= ClassHeader ClassBody"); }  //$NON-NLS-1$
 		    consumeClassDeclaration();  
 			break;
  
-    case 143 : if (DEBUG) { System.out.println("ClassHeader ::= ClassHeaderName ClassHeaderExtendsopt..."); }  //$NON-NLS-1$
+    case 148 : if (DEBUG) { System.out.println("ClassHeader ::= ClassHeaderName ClassHeaderExtendsopt..."); }  //$NON-NLS-1$
 		    consumeClassHeader();  
 			break;
  
-    case 144 : if (DEBUG) { System.out.println("ClassHeaderName ::= ClassHeaderName1 TypeParameters"); }  //$NON-NLS-1$
+    case 149 : if (DEBUG) { System.out.println("ClassHeaderName ::= ClassHeaderName1 TypeParameters"); }  //$NON-NLS-1$
 		    consumeTypeHeaderNameWithTypeParameters();  
 			break;
  
-    case 146 : if (DEBUG) { System.out.println("ClassHeaderName1 ::= Modifiersopt class Identifier"); }  //$NON-NLS-1$
+    case 151 : if (DEBUG) { System.out.println("ClassHeaderName1 ::= Modifiersopt class Identifier"); }  //$NON-NLS-1$
 		    consumeClassHeaderName1();  
 			break;
  
-    case 147 : if (DEBUG) { System.out.println("ClassHeaderExtends ::= extends ClassType"); }  //$NON-NLS-1$
+    case 152 : if (DEBUG) { System.out.println("ClassHeaderExtends ::= extends ClassType"); }  //$NON-NLS-1$
 		    consumeClassHeaderExtends();  
 			break;
  
-    case 148 : if (DEBUG) { System.out.println("ClassHeaderImplements ::= implements InterfaceTypeList"); }  //$NON-NLS-1$
+    case 153 : if (DEBUG) { System.out.println("ClassHeaderImplements ::= implements InterfaceTypeList"); }  //$NON-NLS-1$
 		    consumeClassHeaderImplements();  
 			break;
  
-    case 150 : if (DEBUG) { System.out.println("InterfaceTypeList ::= InterfaceTypeList COMMA..."); }  //$NON-NLS-1$
+    case 155 : if (DEBUG) { System.out.println("InterfaceTypeList ::= InterfaceTypeList COMMA..."); }  //$NON-NLS-1$
 		    consumeInterfaceTypeList();  
 			break;
  
-    case 151 : if (DEBUG) { System.out.println("InterfaceType ::= ClassOrInterfaceType"); }  //$NON-NLS-1$
+    case 156 : if (DEBUG) { System.out.println("InterfaceType ::= ClassOrInterfaceType"); }  //$NON-NLS-1$
 		    consumeInterfaceType();  
 			break;
  
-    case 154 : if (DEBUG) { System.out.println("ClassBodyDeclarations ::= ClassBodyDeclarations..."); }  //$NON-NLS-1$
+    case 159 : if (DEBUG) { System.out.println("ClassBodyDeclarations ::= ClassBodyDeclarations..."); }  //$NON-NLS-1$
 		    consumeClassBodyDeclarations();  
 			break;
  
-    case 158 : if (DEBUG) { System.out.println("ClassBodyDeclaration ::= Diet NestedMethod..."); }  //$NON-NLS-1$
+    case 163 : if (DEBUG) { System.out.println("ClassBodyDeclaration ::= Diet NestedMethod..."); }  //$NON-NLS-1$
 		    consumeClassBodyDeclaration();  
 			break;
  
-    case 159 : if (DEBUG) { System.out.println("Diet ::="); }  //$NON-NLS-1$
+    case 164 : if (DEBUG) { System.out.println("Diet ::="); }  //$NON-NLS-1$
 		    consumeDiet();  
 			break;
 
-    case 160 : if (DEBUG) { System.out.println("Initializer ::= Diet NestedMethod CreateInitializer..."); }  //$NON-NLS-1$
+    case 165 : if (DEBUG) { System.out.println("Initializer ::= Diet NestedMethod CreateInitializer..."); }  //$NON-NLS-1$
 		    consumeClassBodyDeclaration();  
 			break;
  
-    case 161 : if (DEBUG) { System.out.println("CreateInitializer ::="); }  //$NON-NLS-1$
+    case 166 : if (DEBUG) { System.out.println("CreateInitializer ::="); }  //$NON-NLS-1$
 		    consumeCreateInitializer();  
 			break;
 
-    case 168 : if (DEBUG) { System.out.println("ClassMemberDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
+    case 173 : if (DEBUG) { System.out.println("ClassMemberDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeEmptyTypeDeclaration();  
 			break;
 
-    case 171 : if (DEBUG) { System.out.println("FieldDeclaration ::= Modifiersopt Type0..."); }  //$NON-NLS-1$
+    case 176 : if (DEBUG) { System.out.println("FieldDeclaration ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeFieldDeclaration();  
 			break;
  
-    case 173 : if (DEBUG) { System.out.println("VariableDeclarators ::= VariableDeclarators COMMA..."); }  //$NON-NLS-1$
+    case 178 : if (DEBUG) { System.out.println("VariableDeclarators ::= VariableDeclarators COMMA..."); }  //$NON-NLS-1$
 		    consumeVariableDeclarators();  
 			break;
  
-    case 176 : if (DEBUG) { System.out.println("EnterVariable ::="); }  //$NON-NLS-1$
+    case 181 : if (DEBUG) { System.out.println("EnterVariable ::="); }  //$NON-NLS-1$
 		    consumeEnterVariable();  
 			break;
  
-    case 177 : if (DEBUG) { System.out.println("ExitVariableWithInitialization ::="); }  //$NON-NLS-1$
+    case 182 : if (DEBUG) { System.out.println("ExitVariableWithInitialization ::="); }  //$NON-NLS-1$
 		    consumeExitVariableWithInitialization();  
 			break;
  
-    case 178 : if (DEBUG) { System.out.println("ExitVariableWithoutInitialization ::="); }  //$NON-NLS-1$
+    case 183 : if (DEBUG) { System.out.println("ExitVariableWithoutInitialization ::="); }  //$NON-NLS-1$
 		    consumeExitVariableWithoutInitialization();  
 			break;
  
-    case 179 : if (DEBUG) { System.out.println("ForceNoDiet ::="); }  //$NON-NLS-1$
+    case 184 : if (DEBUG) { System.out.println("ForceNoDiet ::="); }  //$NON-NLS-1$
 		    consumeForceNoDiet();  
 			break;
  
-    case 180 : if (DEBUG) { System.out.println("RestoreDiet ::="); }  //$NON-NLS-1$
+    case 185 : if (DEBUG) { System.out.println("RestoreDiet ::="); }  //$NON-NLS-1$
 		    consumeRestoreDiet();  
 			break;
  
-    case 181 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= this"); }  //$NON-NLS-1$
-		    consumeExplicitThisParameter(false);  
-			break;
- 
-    case 182 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= Name DOT this"); }  //$NON-NLS-1$
-		    consumeExplicitThisParameter(true);  
-			break;
- 
-    case 183 : if (DEBUG) { System.out.println("VariableDeclaratorIdOrThis ::= VariableDeclaratorId"); }  //$NON-NLS-1$
-		    consumeVariableDeclaratorIdParameter();  
-			break;
- 
-    case 188 : if (DEBUG) { System.out.println("MethodDeclaration ::= MethodHeader MethodBody"); }  //$NON-NLS-1$
+    case 190 : if (DEBUG) { System.out.println("MethodDeclaration ::= MethodHeader MethodBody"); }  //$NON-NLS-1$
 		    // set to true to consume a method with a body
  consumeMethodDeclaration(true);  
 			break;
  
-    case 189 : if (DEBUG) { System.out.println("AbstractMethodDeclaration ::= MethodHeader SEMICOLON"); }  //$NON-NLS-1$
+    case 191 : if (DEBUG) { System.out.println("AbstractMethodDeclaration ::= MethodHeader SEMICOLON"); }  //$NON-NLS-1$
 		    // set to false to consume a method without body
  consumeMethodDeclaration(false);  
 			break;
  
-    case 190 : if (DEBUG) { System.out.println("MethodHeader ::= MethodHeaderName FormalParameterListopt"); }  //$NON-NLS-1$
+    case 192 : if (DEBUG) { System.out.println("MethodHeader ::= MethodHeaderName FormalParameterListopt"); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
-    case 191 : if (DEBUG) { System.out.println("MethodHeaderName ::= Modifiersopt TypeParameters Type..."); }  //$NON-NLS-1$
+    case 193 : if (DEBUG) { System.out.println("MethodHeaderName ::= Modifiersopt TypeParameters Type..."); }  //$NON-NLS-1$
 		    consumeMethodHeaderNameWithTypeParameters(false);  
 			break;
  
-    case 192 : if (DEBUG) { System.out.println("MethodHeaderName ::= Modifiersopt Type0 Identifier..."); }  //$NON-NLS-1$
+    case 194 : if (DEBUG) { System.out.println("MethodHeaderName ::= Modifiersopt Type Identifier LPAREN"); }  //$NON-NLS-1$
 		    consumeMethodHeaderName(false);  
 			break;
  
-    case 193 : if (DEBUG) { System.out.println("MethodHeaderRightParen ::= RPAREN"); }  //$NON-NLS-1$
+    case 195 : if (DEBUG) { System.out.println("MethodHeaderRightParen ::= RPAREN"); }  //$NON-NLS-1$
 		    consumeMethodHeaderRightParen();  
 			break;
  
-    case 194 : if (DEBUG) { System.out.println("MethodHeaderExtendedDims ::= Dimsopt"); }  //$NON-NLS-1$
+    case 196 : if (DEBUG) { System.out.println("MethodHeaderExtendedDims ::= Dimsopt"); }  //$NON-NLS-1$
 		    consumeMethodHeaderExtendedDims();  
 			break;
  
-    case 195 : if (DEBUG) { System.out.println("MethodHeaderThrowsClause ::= throws ClassTypeList"); }  //$NON-NLS-1$
+    case 197 : if (DEBUG) { System.out.println("MethodHeaderThrowsClause ::= throws ClassTypeList"); }  //$NON-NLS-1$
 		    consumeMethodHeaderThrowsClause();  
 			break;
  
-    case 196 : if (DEBUG) { System.out.println("ConstructorHeader ::= ConstructorHeaderName..."); }  //$NON-NLS-1$
+    case 198 : if (DEBUG) { System.out.println("ConstructorHeader ::= ConstructorHeaderName..."); }  //$NON-NLS-1$
 		    consumeConstructorHeader();  
 			break;
  
-    case 197 : if (DEBUG) { System.out.println("ConstructorHeaderName ::= Modifiersopt TypeParameters..."); }  //$NON-NLS-1$
+    case 199 : if (DEBUG) { System.out.println("ConstructorHeaderName ::= Modifiersopt TypeParameters..."); }  //$NON-NLS-1$
 		    consumeConstructorHeaderNameWithTypeParameters();  
 			break;
  
-    case 198 : if (DEBUG) { System.out.println("ConstructorHeaderName ::= Modifiersopt Identifier LPAREN"); }  //$NON-NLS-1$
+    case 200 : if (DEBUG) { System.out.println("ConstructorHeaderName ::= Modifiersopt Identifier LPAREN"); }  //$NON-NLS-1$
 		    consumeConstructorHeaderName();  
 			break;
  
-    case 200 : if (DEBUG) { System.out.println("FormalParameterList ::= FormalParameterList COMMA..."); }  //$NON-NLS-1$
+    case 202 : if (DEBUG) { System.out.println("FormalParameterList ::= FormalParameterList COMMA..."); }  //$NON-NLS-1$
 		    consumeFormalParameterList();  
 			break;
  
-    case 201 : if (DEBUG) { System.out.println("PotentialNameArray ::="); }  //$NON-NLS-1$
-		    consumePotentialNameArrayType();  
-			break;
- 
-    case 202 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt PrimitiveType..."); }  //$NON-NLS-1$
+    case 203 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeFormalParameter(false);  
 			break;
  
-    case 203 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt PrimitiveType..."); }  //$NON-NLS-1$
+    case 204 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeFormalParameter(true);  
 			break;
  
-    case 204 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt"); }  //$NON-NLS-1$
-		    consumeFormalParameter(false);  
-			break;
- 
-    case 205 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt"); }  //$NON-NLS-1$
-		    consumeFormalParameter(true);  
-			break;
- 
-    case 206 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt GenericType..."); }  //$NON-NLS-1$
-		    consumeFormalParameter(false);  
-			break;
- 
-    case 207 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt GenericType..."); }  //$NON-NLS-1$
+    case 205 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt Type AT308DOTDOTDOT..."); }  //$NON-NLS-1$
 		    consumeFormalParameter(true);  
 			break;
  
-    case 208 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt GenericTypeDotName..."); }  //$NON-NLS-1$
-		    consumeFormalParameter(false);  
-			break;
- 
-    case 209 : if (DEBUG) { System.out.println("FormalParameter ::= Modifiersopt GenericTypeDotName..."); }  //$NON-NLS-1$
-		    consumeFormalParameter(true);  
-			break;
- 
-    case 210 : if (DEBUG) { System.out.println("CatchFormalParameter ::= Modifiersopt CatchType..."); }  //$NON-NLS-1$
+    case 206 : if (DEBUG) { System.out.println("CatchFormalParameter ::= Modifiersopt CatchType..."); }  //$NON-NLS-1$
 		    consumeCatchFormalParameter();  
 			break;
  
-    case 211 : if (DEBUG) { System.out.println("CatchType ::= UnionType"); }  //$NON-NLS-1$
+    case 207 : if (DEBUG) { System.out.println("CatchType ::= UnionType"); }  //$NON-NLS-1$
 		    consumeCatchType();  
 			break;
  
-    case 212 : if (DEBUG) { System.out.println("UnionType ::= Type0"); }  //$NON-NLS-1$
+    case 208 : if (DEBUG) { System.out.println("UnionType ::= Type"); }  //$NON-NLS-1$
 		    consumeUnionTypeAsClassType();  
 			break;
  
-    case 213 : if (DEBUG) { System.out.println("UnionType ::= UnionType OR Type"); }  //$NON-NLS-1$
+    case 209 : if (DEBUG) { System.out.println("UnionType ::= UnionType OR Type"); }  //$NON-NLS-1$
 		    consumeUnionType();  
 			break;
  
-    case 215 : if (DEBUG) { System.out.println("ClassTypeList ::= ClassTypeList COMMA ClassTypeElt"); }  //$NON-NLS-1$
+    case 211 : if (DEBUG) { System.out.println("ClassTypeList ::= ClassTypeList COMMA ClassTypeElt"); }  //$NON-NLS-1$
 		    consumeClassTypeList();  
 			break;
  
-    case 216 : if (DEBUG) { System.out.println("ClassTypeElt ::= ClassType"); }  //$NON-NLS-1$
+    case 212 : if (DEBUG) { System.out.println("ClassTypeElt ::= ClassType"); }  //$NON-NLS-1$
 		    consumeClassTypeElt();  
 			break;
  
-    case 217 : if (DEBUG) { System.out.println("MethodBody ::= NestedMethod LBRACE BlockStatementsopt..."); }  //$NON-NLS-1$
+    case 213 : if (DEBUG) { System.out.println("MethodBody ::= NestedMethod LBRACE BlockStatementsopt..."); }  //$NON-NLS-1$
 		    consumeMethodBody();  
 			break;
  
-    case 218 : if (DEBUG) { System.out.println("NestedMethod ::="); }  //$NON-NLS-1$
+    case 214 : if (DEBUG) { System.out.println("NestedMethod ::="); }  //$NON-NLS-1$
 		    consumeNestedMethod();  
 			break;
  
-    case 219 : if (DEBUG) { System.out.println("StaticInitializer ::= StaticOnly Block"); }  //$NON-NLS-1$
+    case 215 : if (DEBUG) { System.out.println("StaticInitializer ::= StaticOnly Block"); }  //$NON-NLS-1$
 		    consumeStaticInitializer();  
 			break;
 
-    case 220 : if (DEBUG) { System.out.println("StaticOnly ::= static"); }  //$NON-NLS-1$
+    case 216 : if (DEBUG) { System.out.println("StaticOnly ::= static"); }  //$NON-NLS-1$
 		    consumeStaticOnly();  
 			break;
  
-    case 221 : if (DEBUG) { System.out.println("ConstructorDeclaration ::= ConstructorHeader MethodBody"); }  //$NON-NLS-1$
+    case 217 : if (DEBUG) { System.out.println("ConstructorDeclaration ::= ConstructorHeader MethodBody"); }  //$NON-NLS-1$
 		    consumeConstructorDeclaration() ;  
 			break;
  
-    case 222 : if (DEBUG) { System.out.println("ConstructorDeclaration ::= ConstructorHeader SEMICOLON"); }  //$NON-NLS-1$
+    case 218 : if (DEBUG) { System.out.println("ConstructorDeclaration ::= ConstructorHeader SEMICOLON"); }  //$NON-NLS-1$
 		    consumeInvalidConstructorDeclaration() ;  
 			break;
  
-    case 223 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= this LPAREN..."); }  //$NON-NLS-1$
+    case 219 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= this LPAREN..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(0, THIS_CALL);  
 			break;
  
-    case 224 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= OnlyTypeArguments this"); }  //$NON-NLS-1$
+    case 220 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= OnlyTypeArguments this"); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(0,THIS_CALL);  
 			break;
  
-    case 225 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= super LPAREN..."); }  //$NON-NLS-1$
+    case 221 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= super LPAREN..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(0,SUPER_CALL);  
 			break;
  
-    case 226 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= OnlyTypeArguments..."); }  //$NON-NLS-1$
+    case 222 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= OnlyTypeArguments..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(0,SUPER_CALL);  
 			break;
  
-    case 227 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT super..."); }  //$NON-NLS-1$
+    case 223 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT super..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(1, SUPER_CALL);  
 			break;
  
-    case 228 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT..."); }  //$NON-NLS-1$
+    case 224 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(1, SUPER_CALL);  
 			break;
  
-    case 229 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT super LPAREN"); }  //$NON-NLS-1$
+    case 225 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT super LPAREN"); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(2, SUPER_CALL);  
 			break;
  
-    case 230 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT..."); }  //$NON-NLS-1$
+    case 226 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(2, SUPER_CALL);  
 			break;
  
-    case 231 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT this..."); }  //$NON-NLS-1$
+    case 227 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT this..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(1, THIS_CALL);  
 			break;
  
-    case 232 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT..."); }  //$NON-NLS-1$
+    case 228 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Primary DOT..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(1, THIS_CALL);  
 			break;
  
-    case 233 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT this LPAREN"); }  //$NON-NLS-1$
+    case 229 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT this LPAREN"); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocation(2, THIS_CALL);  
 			break;
  
-    case 234 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT..."); }  //$NON-NLS-1$
+    case 230 : if (DEBUG) { System.out.println("ExplicitConstructorInvocation ::= Name DOT..."); }  //$NON-NLS-1$
 		    consumeExplicitConstructorInvocationWithTypeArguments(2, THIS_CALL);  
 			break;
  
-    case 235 : if (DEBUG) { System.out.println("InterfaceDeclaration ::= InterfaceHeader InterfaceBody"); }  //$NON-NLS-1$
+    case 231 : if (DEBUG) { System.out.println("InterfaceDeclaration ::= InterfaceHeader InterfaceBody"); }  //$NON-NLS-1$
 		    consumeInterfaceDeclaration();  
 			break;
  
-    case 236 : if (DEBUG) { System.out.println("InterfaceHeader ::= InterfaceHeaderName..."); }  //$NON-NLS-1$
+    case 232 : if (DEBUG) { System.out.println("InterfaceHeader ::= InterfaceHeaderName..."); }  //$NON-NLS-1$
 		    consumeInterfaceHeader();  
 			break;
  
-    case 237 : if (DEBUG) { System.out.println("InterfaceHeaderName ::= InterfaceHeaderName1..."); }  //$NON-NLS-1$
+    case 233 : if (DEBUG) { System.out.println("InterfaceHeaderName ::= InterfaceHeaderName1..."); }  //$NON-NLS-1$
 		    consumeTypeHeaderNameWithTypeParameters();  
 			break;
  
-    case 239 : if (DEBUG) { System.out.println("InterfaceHeaderName1 ::= Modifiersopt interface..."); }  //$NON-NLS-1$
+    case 235 : if (DEBUG) { System.out.println("InterfaceHeaderName1 ::= Modifiersopt interface..."); }  //$NON-NLS-1$
 		    consumeInterfaceHeaderName1();  
 			break;
  
-    case 240 : if (DEBUG) { System.out.println("InterfaceHeaderExtends ::= extends InterfaceTypeList"); }  //$NON-NLS-1$
+    case 236 : if (DEBUG) { System.out.println("InterfaceHeaderExtends ::= extends InterfaceTypeList"); }  //$NON-NLS-1$
 		    consumeInterfaceHeaderExtends();  
 			break;
  
-    case 243 : if (DEBUG) { System.out.println("InterfaceMemberDeclarations ::=..."); }  //$NON-NLS-1$
+    case 239 : if (DEBUG) { System.out.println("InterfaceMemberDeclarations ::=..."); }  //$NON-NLS-1$
 		    consumeInterfaceMemberDeclarations();  
 			break;
  
-    case 244 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
+    case 240 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeEmptyTypeDeclaration();  
 			break;
  
-    case 245 : if (DEBUG) { System.out.println("PushDefault ::="); }  //$NON-NLS-1$
+    case 241 : if (DEBUG) { System.out.println("PushDefault ::="); }  //$NON-NLS-1$
 		    consumeInterfaceMethodDefault();  
 			break;
  
-    case 247 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= MethodHeader default..."); }  //$NON-NLS-1$
+    case 243 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= MethodHeader default..."); }  //$NON-NLS-1$
 		    consumeInterfaceMethodDeclaration(true);  
 			break;
  
-    case 248 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= MethodHeader MethodBody"); }  //$NON-NLS-1$
+    case 244 : if (DEBUG) { System.out.println("InterfaceMemberDeclaration ::= MethodHeader MethodBody"); }  //$NON-NLS-1$
 		    consumeInterfaceMethodDeclaration(false);  
 			break;
  
-    case 249 : if (DEBUG) { System.out.println("InvalidConstructorDeclaration ::= ConstructorHeader..."); }  //$NON-NLS-1$
+    case 245 : if (DEBUG) { System.out.println("InvalidConstructorDeclaration ::= ConstructorHeader..."); }  //$NON-NLS-1$
 		    consumeInvalidConstructorDeclaration(true);  
 			break;
  
-    case 250 : if (DEBUG) { System.out.println("InvalidConstructorDeclaration ::= ConstructorHeader..."); }  //$NON-NLS-1$
+    case 246 : if (DEBUG) { System.out.println("InvalidConstructorDeclaration ::= ConstructorHeader..."); }  //$NON-NLS-1$
 		    consumeInvalidConstructorDeclaration(false);  
 			break;
  
-    case 261 : if (DEBUG) { System.out.println("PushLeftBrace ::="); }  //$NON-NLS-1$
+    case 257 : if (DEBUG) { System.out.println("PushLeftBrace ::="); }  //$NON-NLS-1$
 		    consumePushLeftBrace();  
 			break;
  
-    case 262 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace ,opt RBRACE"); }  //$NON-NLS-1$
+    case 258 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace ,opt RBRACE"); }  //$NON-NLS-1$
 		    consumeEmptyArrayInitializer();  
 			break;
  
-    case 263 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 259 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeArrayInitializer();  
 			break;
  
-    case 264 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 260 : if (DEBUG) { System.out.println("ArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeArrayInitializer();  
 			break;
  
-    case 266 : if (DEBUG) { System.out.println("VariableInitializers ::= VariableInitializers COMMA..."); }  //$NON-NLS-1$
+    case 262 : if (DEBUG) { System.out.println("VariableInitializers ::= VariableInitializers COMMA..."); }  //$NON-NLS-1$
 		    consumeVariableInitializers();  
 			break;
  
-    case 267 : if (DEBUG) { System.out.println("Block ::= OpenBlock LBRACE BlockStatementsopt RBRACE"); }  //$NON-NLS-1$
+    case 263 : if (DEBUG) { System.out.println("Block ::= OpenBlock LBRACE BlockStatementsopt RBRACE"); }  //$NON-NLS-1$
 		    consumeBlock();  
 			break;
  
-    case 268 : if (DEBUG) { System.out.println("OpenBlock ::="); }  //$NON-NLS-1$
+    case 264 : if (DEBUG) { System.out.println("OpenBlock ::="); }  //$NON-NLS-1$
 		    consumeOpenBlock() ;  
 			break;
  
-    case 270 : if (DEBUG) { System.out.println("BlockStatements ::= BlockStatements BlockStatement"); }  //$NON-NLS-1$
+    case 266 : if (DEBUG) { System.out.println("BlockStatements ::= BlockStatements BlockStatement"); }  //$NON-NLS-1$
 		    consumeBlockStatements() ;  
 			break;
  
-    case 274 : if (DEBUG) { System.out.println("BlockStatement ::= InterfaceDeclaration"); }  //$NON-NLS-1$
+    case 270 : if (DEBUG) { System.out.println("BlockStatement ::= InterfaceDeclaration"); }  //$NON-NLS-1$
 		    consumeInvalidInterfaceDeclaration();  
 			break;
  
-    case 275 : if (DEBUG) { System.out.println("BlockStatement ::= AnnotationTypeDeclaration"); }  //$NON-NLS-1$
+    case 271 : if (DEBUG) { System.out.println("BlockStatement ::= AnnotationTypeDeclaration"); }  //$NON-NLS-1$
 		    consumeInvalidAnnotationTypeDeclaration();  
 			break;
  
-    case 276 : if (DEBUG) { System.out.println("BlockStatement ::= EnumDeclaration"); }  //$NON-NLS-1$
+    case 272 : if (DEBUG) { System.out.println("BlockStatement ::= EnumDeclaration"); }  //$NON-NLS-1$
 		    consumeInvalidEnumDeclaration();  
 			break;
  
-    case 277 : if (DEBUG) { System.out.println("LocalVariableDeclarationStatement ::=..."); }  //$NON-NLS-1$
+    case 273 : if (DEBUG) { System.out.println("LocalVariableDeclarationStatement ::=..."); }  //$NON-NLS-1$
 		    consumeLocalVariableDeclarationStatement();  
 			break;
  
-    case 278 : if (DEBUG) { System.out.println("LocalVariableDeclaration ::= Type0 PushModifiers..."); }  //$NON-NLS-1$
+    case 274 : if (DEBUG) { System.out.println("LocalVariableDeclaration ::= Type PushModifiers..."); }  //$NON-NLS-1$
 		    consumeLocalVariableDeclaration();  
 			break;
  
-    case 279 : if (DEBUG) { System.out.println("LocalVariableDeclaration ::= Modifiers Type0..."); }  //$NON-NLS-1$
+    case 275 : if (DEBUG) { System.out.println("LocalVariableDeclaration ::= Modifiers Type..."); }  //$NON-NLS-1$
 		    consumeLocalVariableDeclaration();  
 			break;
  
-    case 280 : if (DEBUG) { System.out.println("PushModifiers ::="); }  //$NON-NLS-1$
+    case 276 : if (DEBUG) { System.out.println("PushModifiers ::="); }  //$NON-NLS-1$
 		    consumePushModifiers();  
 			break;
  
-    case 281 : if (DEBUG) { System.out.println("PushModifiersForHeader ::="); }  //$NON-NLS-1$
+    case 277 : if (DEBUG) { System.out.println("PushModifiersForHeader ::="); }  //$NON-NLS-1$
 		    consumePushModifiersForHeader();  
 			break;
  
-    case 282 : if (DEBUG) { System.out.println("PushRealModifiers ::="); }  //$NON-NLS-1$
+    case 278 : if (DEBUG) { System.out.println("PushRealModifiers ::="); }  //$NON-NLS-1$
 		    consumePushRealModifiers();  
 			break;
  
-    case 309 : if (DEBUG) { System.out.println("EmptyStatement ::= SEMICOLON"); }  //$NON-NLS-1$
+    case 305 : if (DEBUG) { System.out.println("EmptyStatement ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeEmptyStatement();  
 			break;
  
-    case 310 : if (DEBUG) { System.out.println("LabeledStatement ::= Label COLON Statement"); }  //$NON-NLS-1$
+    case 306 : if (DEBUG) { System.out.println("LabeledStatement ::= Label COLON Statement"); }  //$NON-NLS-1$
 		    consumeStatementLabel() ;  
 			break;
  
-    case 311 : if (DEBUG) { System.out.println("LabeledStatementNoShortIf ::= Label COLON..."); }  //$NON-NLS-1$
+    case 307 : if (DEBUG) { System.out.println("LabeledStatementNoShortIf ::= Label COLON..."); }  //$NON-NLS-1$
 		    consumeStatementLabel() ;  
 			break;
  
-    case 312 : if (DEBUG) { System.out.println("Label ::= Identifier"); }  //$NON-NLS-1$
-		    consumeLabel();  
+    case 308 : if (DEBUG) { System.out.println("Label ::= Identifier"); }  //$NON-NLS-1$
+		    consumeLabel() ;  
 			break;
  
-     case 313 : if (DEBUG) { System.out.println("ExpressionStatement ::= StatementExpression SEMICOLON"); }  //$NON-NLS-1$
+     case 309 : if (DEBUG) { System.out.println("ExpressionStatement ::= StatementExpression SEMICOLON"); }  //$NON-NLS-1$
 		    consumeExpressionStatement();  
 			break;
  
-    case 322 : if (DEBUG) { System.out.println("IfThenStatement ::= if LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
+    case 318 : if (DEBUG) { System.out.println("IfThenStatement ::= if LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
 		    consumeStatementIfNoElse();  
 			break;
  
-    case 323 : if (DEBUG) { System.out.println("IfThenElseStatement ::= if LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
+    case 319 : if (DEBUG) { System.out.println("IfThenElseStatement ::= if LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
 		    consumeStatementIfWithElse();  
 			break;
  
-    case 324 : if (DEBUG) { System.out.println("IfThenElseStatementNoShortIf ::= if LPAREN Expression..."); }  //$NON-NLS-1$
+    case 320 : if (DEBUG) { System.out.println("IfThenElseStatementNoShortIf ::= if LPAREN Expression..."); }  //$NON-NLS-1$
 		    consumeStatementIfWithElse();  
 			break;
  
-    case 325 : if (DEBUG) { System.out.println("SwitchStatement ::= switch LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
+    case 321 : if (DEBUG) { System.out.println("SwitchStatement ::= switch LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
 		    consumeStatementSwitch() ;  
 			break;
  
-    case 326 : if (DEBUG) { System.out.println("SwitchBlock ::= LBRACE RBRACE"); }  //$NON-NLS-1$
+    case 322 : if (DEBUG) { System.out.println("SwitchBlock ::= LBRACE RBRACE"); }  //$NON-NLS-1$
 		    consumeEmptySwitchBlock() ;  
 			break;
  
-    case 329 : if (DEBUG) { System.out.println("SwitchBlock ::= LBRACE SwitchBlockStatements..."); }  //$NON-NLS-1$
+    case 325 : if (DEBUG) { System.out.println("SwitchBlock ::= LBRACE SwitchBlockStatements..."); }  //$NON-NLS-1$
 		    consumeSwitchBlock() ;  
 			break;
  
-    case 331 : if (DEBUG) { System.out.println("SwitchBlockStatements ::= SwitchBlockStatements..."); }  //$NON-NLS-1$
+    case 327 : if (DEBUG) { System.out.println("SwitchBlockStatements ::= SwitchBlockStatements..."); }  //$NON-NLS-1$
 		    consumeSwitchBlockStatements() ;  
 			break;
  
-    case 332 : if (DEBUG) { System.out.println("SwitchBlockStatement ::= SwitchLabels BlockStatements"); }  //$NON-NLS-1$
+    case 328 : if (DEBUG) { System.out.println("SwitchBlockStatement ::= SwitchLabels BlockStatements"); }  //$NON-NLS-1$
 		    consumeSwitchBlockStatement() ;  
 			break;
  
-    case 334 : if (DEBUG) { System.out.println("SwitchLabels ::= SwitchLabels SwitchLabel"); }  //$NON-NLS-1$
+    case 330 : if (DEBUG) { System.out.println("SwitchLabels ::= SwitchLabels SwitchLabel"); }  //$NON-NLS-1$
 		    consumeSwitchLabels() ;  
 			break;
  
-     case 335 : if (DEBUG) { System.out.println("SwitchLabel ::= case ConstantExpression COLON"); }  //$NON-NLS-1$
+     case 331 : if (DEBUG) { System.out.println("SwitchLabel ::= case ConstantExpression COLON"); }  //$NON-NLS-1$
 		    consumeCaseLabel();  
 			break;
  
-     case 336 : if (DEBUG) { System.out.println("SwitchLabel ::= default COLON"); }  //$NON-NLS-1$
+     case 332 : if (DEBUG) { System.out.println("SwitchLabel ::= default COLON"); }  //$NON-NLS-1$
 		    consumeDefaultLabel();  
 			break;
  
-    case 337 : if (DEBUG) { System.out.println("WhileStatement ::= while LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
+    case 333 : if (DEBUG) { System.out.println("WhileStatement ::= while LPAREN Expression RPAREN..."); }  //$NON-NLS-1$
 		    consumeStatementWhile() ;  
 			break;
  
-    case 338 : if (DEBUG) { System.out.println("WhileStatementNoShortIf ::= while LPAREN Expression..."); }  //$NON-NLS-1$
+    case 334 : if (DEBUG) { System.out.println("WhileStatementNoShortIf ::= while LPAREN Expression..."); }  //$NON-NLS-1$
 		    consumeStatementWhile() ;  
 			break;
  
-    case 339 : if (DEBUG) { System.out.println("DoStatement ::= do Statement while LPAREN Expression..."); }  //$NON-NLS-1$
+    case 335 : if (DEBUG) { System.out.println("DoStatement ::= do Statement while LPAREN Expression..."); }  //$NON-NLS-1$
 		    consumeStatementDo() ;  
 			break;
  
-    case 340 : if (DEBUG) { System.out.println("ForStatement ::= for LPAREN ForInitopt SEMICOLON..."); }  //$NON-NLS-1$
+    case 336 : if (DEBUG) { System.out.println("ForStatement ::= for LPAREN ForInitopt SEMICOLON..."); }  //$NON-NLS-1$
 		    consumeStatementFor() ;  
 			break;
  
-    case 341 : if (DEBUG) { System.out.println("ForStatementNoShortIf ::= for LPAREN ForInitopt..."); }  //$NON-NLS-1$
+    case 337 : if (DEBUG) { System.out.println("ForStatementNoShortIf ::= for LPAREN ForInitopt..."); }  //$NON-NLS-1$
 		    consumeStatementFor() ;  
 			break;
  
-    case 342 : if (DEBUG) { System.out.println("ForInit ::= StatementExpressionList"); }  //$NON-NLS-1$
+    case 338 : if (DEBUG) { System.out.println("ForInit ::= StatementExpressionList"); }  //$NON-NLS-1$
 		    consumeForInit() ;  
 			break;
  
-    case 346 : if (DEBUG) { System.out.println("StatementExpressionList ::= StatementExpressionList..."); }  //$NON-NLS-1$
+    case 342 : if (DEBUG) { System.out.println("StatementExpressionList ::= StatementExpressionList..."); }  //$NON-NLS-1$
 		    consumeStatementExpressionList() ;  
 			break;
  
-    case 347 : if (DEBUG) { System.out.println("AssertStatement ::= assert Expression SEMICOLON"); }  //$NON-NLS-1$
+    case 343 : if (DEBUG) { System.out.println("AssertStatement ::= assert Expression SEMICOLON"); }  //$NON-NLS-1$
 		    consumeSimpleAssertStatement() ;  
 			break;
  
-    case 348 : if (DEBUG) { System.out.println("AssertStatement ::= assert Expression COLON Expression"); }  //$NON-NLS-1$
+    case 344 : if (DEBUG) { System.out.println("AssertStatement ::= assert Expression COLON Expression"); }  //$NON-NLS-1$
 		    consumeAssertStatement() ;  
 			break;
  
-    case 349 : if (DEBUG) { System.out.println("BreakStatement ::= break SEMICOLON"); }  //$NON-NLS-1$
+    case 345 : if (DEBUG) { System.out.println("BreakStatement ::= break SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementBreak() ;  
 			break;
  
-    case 350 : if (DEBUG) { System.out.println("BreakStatement ::= break Identifier SEMICOLON"); }  //$NON-NLS-1$
+    case 346 : if (DEBUG) { System.out.println("BreakStatement ::= break Identifier SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementBreakWithLabel() ;  
 			break;
  
-    case 351 : if (DEBUG) { System.out.println("ContinueStatement ::= continue SEMICOLON"); }  //$NON-NLS-1$
+    case 347 : if (DEBUG) { System.out.println("ContinueStatement ::= continue SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementContinue() ;  
 			break;
  
-    case 352 : if (DEBUG) { System.out.println("ContinueStatement ::= continue Identifier SEMICOLON"); }  //$NON-NLS-1$
+    case 348 : if (DEBUG) { System.out.println("ContinueStatement ::= continue Identifier SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementContinueWithLabel() ;  
 			break;
  
-    case 353 : if (DEBUG) { System.out.println("ReturnStatement ::= return Expressionopt SEMICOLON"); }  //$NON-NLS-1$
+    case 349 : if (DEBUG) { System.out.println("ReturnStatement ::= return Expressionopt SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementReturn() ;  
 			break;
  
-    case 354 : if (DEBUG) { System.out.println("ThrowStatement ::= throw Expression SEMICOLON"); }  //$NON-NLS-1$
+    case 350 : if (DEBUG) { System.out.println("ThrowStatement ::= throw Expression SEMICOLON"); }  //$NON-NLS-1$
 		    consumeStatementThrow();  
 			break;
  
-    case 355 : if (DEBUG) { System.out.println("SynchronizedStatement ::= OnlySynchronized LPAREN..."); }  //$NON-NLS-1$
+    case 351 : if (DEBUG) { System.out.println("SynchronizedStatement ::= OnlySynchronized LPAREN..."); }  //$NON-NLS-1$
 		    consumeStatementSynchronized();  
 			break;
  
-    case 356 : if (DEBUG) { System.out.println("OnlySynchronized ::= synchronized"); }  //$NON-NLS-1$
+    case 352 : if (DEBUG) { System.out.println("OnlySynchronized ::= synchronized"); }  //$NON-NLS-1$
 		    consumeOnlySynchronized();  
 			break;
  
-    case 357 : if (DEBUG) { System.out.println("TryStatement ::= try TryBlock Catches"); }  //$NON-NLS-1$
+    case 353 : if (DEBUG) { System.out.println("TryStatement ::= try TryBlock Catches"); }  //$NON-NLS-1$
 		    consumeStatementTry(false, false);  
 			break;
  
-    case 358 : if (DEBUG) { System.out.println("TryStatement ::= try TryBlock Catchesopt Finally"); }  //$NON-NLS-1$
+    case 354 : if (DEBUG) { System.out.println("TryStatement ::= try TryBlock Catchesopt Finally"); }  //$NON-NLS-1$
 		    consumeStatementTry(true, false);  
 			break;
  
-    case 359 : if (DEBUG) { System.out.println("TryStatementWithResources ::= try ResourceSpecification"); }  //$NON-NLS-1$
+    case 355 : if (DEBUG) { System.out.println("TryStatementWithResources ::= try ResourceSpecification"); }  //$NON-NLS-1$
 		    consumeStatementTry(false, true);  
 			break;
  
-    case 360 : if (DEBUG) { System.out.println("TryStatementWithResources ::= try ResourceSpecification"); }  //$NON-NLS-1$
+    case 356 : if (DEBUG) { System.out.println("TryStatementWithResources ::= try ResourceSpecification"); }  //$NON-NLS-1$
 		    consumeStatementTry(true, true);  
 			break;
  
-    case 361 : if (DEBUG) { System.out.println("ResourceSpecification ::= LPAREN Resources ;opt RPAREN"); }  //$NON-NLS-1$
+    case 357 : if (DEBUG) { System.out.println("ResourceSpecification ::= LPAREN Resources ;opt RPAREN"); }  //$NON-NLS-1$
 		    consumeResourceSpecification();  
 			break;
  
-    case 362 : if (DEBUG) { System.out.println(";opt ::="); }  //$NON-NLS-1$
+    case 358 : if (DEBUG) { System.out.println(";opt ::="); }  //$NON-NLS-1$
 		    consumeResourceOptionalTrailingSemiColon(false);  
 			break;
  
-    case 363 : if (DEBUG) { System.out.println(";opt ::= SEMICOLON"); }  //$NON-NLS-1$
+    case 359 : if (DEBUG) { System.out.println(";opt ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeResourceOptionalTrailingSemiColon(true);  
 			break;
  
-    case 364 : if (DEBUG) { System.out.println("Resources ::= Resource"); }  //$NON-NLS-1$
+    case 360 : if (DEBUG) { System.out.println("Resources ::= Resource"); }  //$NON-NLS-1$
 		    consumeSingleResource();  
 			break;
  
-    case 365 : if (DEBUG) { System.out.println("Resources ::= Resources TrailingSemiColon Resource"); }  //$NON-NLS-1$
+    case 361 : if (DEBUG) { System.out.println("Resources ::= Resources TrailingSemiColon Resource"); }  //$NON-NLS-1$
 		    consumeMultipleResources();  
 			break;
  
-    case 366 : if (DEBUG) { System.out.println("TrailingSemiColon ::= SEMICOLON"); }  //$NON-NLS-1$
+    case 362 : if (DEBUG) { System.out.println("TrailingSemiColon ::= SEMICOLON"); }  //$NON-NLS-1$
 		    consumeResourceOptionalTrailingSemiColon(true);  
 			break;
  
-    case 367 : if (DEBUG) { System.out.println("Resource ::= Type0 PushModifiers VariableDeclaratorId..."); }  //$NON-NLS-1$
+    case 363 : if (DEBUG) { System.out.println("Resource ::= Type PushModifiers VariableDeclaratorId..."); }  //$NON-NLS-1$
 		    consumeResourceAsLocalVariableDeclaration();  
 			break;
  
-    case 368 : if (DEBUG) { System.out.println("Resource ::= Modifiers Type0 PushRealModifiers..."); }  //$NON-NLS-1$
+    case 364 : if (DEBUG) { System.out.println("Resource ::= Modifiers Type PushRealModifiers..."); }  //$NON-NLS-1$
 		    consumeResourceAsLocalVariableDeclaration();  
 			break;
  
-    case 370 : if (DEBUG) { System.out.println("ExitTryBlock ::="); }  //$NON-NLS-1$
+    case 366 : if (DEBUG) { System.out.println("ExitTryBlock ::="); }  //$NON-NLS-1$
 		    consumeExitTryBlock();  
 			break;
  
-    case 372 : if (DEBUG) { System.out.println("Catches ::= Catches CatchClause"); }  //$NON-NLS-1$
+    case 368 : if (DEBUG) { System.out.println("Catches ::= Catches CatchClause"); }  //$NON-NLS-1$
 		    consumeCatches();  
 			break;
  
-    case 373 : if (DEBUG) { System.out.println("CatchClause ::= catch LPAREN CatchFormalParameter RPAREN"); }  //$NON-NLS-1$
+    case 369 : if (DEBUG) { System.out.println("CatchClause ::= catch LPAREN CatchFormalParameter RPAREN"); }  //$NON-NLS-1$
 		    consumeStatementCatch() ;  
 			break;
  
-    case 375 : if (DEBUG) { System.out.println("PushLPAREN ::= LPAREN"); }  //$NON-NLS-1$
+    case 371 : if (DEBUG) { System.out.println("PushLPAREN ::= LPAREN"); }  //$NON-NLS-1$
 		    consumeLeftParen();  
 			break;
  
-    case 376 : if (DEBUG) { System.out.println("PushRPARENForUnannotatedTypeCast ::= RPAREN"); }  //$NON-NLS-1$
-		    consumeRightParenForUnannotatedTypeCast();  
-			break;
- 
-    case 377 : if (DEBUG) { System.out.println("PushRPARENForNameUnannotatedTypeCast ::= RPAREN"); }  //$NON-NLS-1$
-		    consumeRightParenForNameUnannotatedTypeCast();  
-			break;
- 
-    case 378 : if (DEBUG) { System.out.println("PushRPAREN ::= RPAREN"); }  //$NON-NLS-1$
+    case 372 : if (DEBUG) { System.out.println("PushRPAREN ::= RPAREN"); }  //$NON-NLS-1$
 		    consumeRightParen();  
 			break;
  
-    case 379 : if (DEBUG) { System.out.println("PushRPARENForAnnotatedTypeCast ::= RPAREN"); }  //$NON-NLS-1$
-		    consumeRightParenForAnnotatedTypeCast();  
-			break;
- 
-    case 380 : if (DEBUG) { System.out.println("PushRPARENForNameAndAnnotatedTypeCast ::= RPAREN"); }  //$NON-NLS-1$
-		    consumeRightParenForNameAndAnnotatedTypeCast();  
-			break;
- 
-    case 385 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= this"); }  //$NON-NLS-1$
+    case 377 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= this"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayThis();  
 			break;
  
-    case 386 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PushLPAREN Expression_NotName..."); }  //$NON-NLS-1$
+    case 378 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PushLPAREN Expression_NotName..."); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArray();  
 			break;
  
-    case 387 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PushLPAREN Name PushRPAREN"); }  //$NON-NLS-1$
+    case 379 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PushLPAREN Name PushRPAREN"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayWithName();  
 			break;
  
-    case 390 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT this"); }  //$NON-NLS-1$
+    case 382 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT this"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayNameThis();  
 			break;
  
-    case 391 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT super"); }  //$NON-NLS-1$
+    case 383 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT super"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayNameSuper();  
 			break;
  
-    case 392 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT class"); }  //$NON-NLS-1$
+    case 384 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name DOT class"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayName();  
 			break;
  
-    case 393 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name Dims DOT class"); }  //$NON-NLS-1$
+    case 385 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= Name Dims DOT class"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayArrayType();  
 			break;
  
-    case 394 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PrimitiveType Dims DOT class"); }  //$NON-NLS-1$
+    case 386 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PrimitiveType Dims DOT class"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayPrimitiveArrayType();  
 			break;
  
-    case 395 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PrimitiveType DOT class"); }  //$NON-NLS-1$
+    case 387 : if (DEBUG) { System.out.println("PrimaryNoNewArray ::= PrimitiveType DOT class"); }  //$NON-NLS-1$
 		    consumePrimaryNoNewArrayPrimitiveType();  
 			break;
  
-    case 400 : if (DEBUG) { System.out.println("ReferenceExpressionTypeArgumentsAndTrunk ::=..."); }  //$NON-NLS-1$
+    case 392 : if (DEBUG) { System.out.println("ReferenceExpressionTypeArgumentsAndTrunk ::=..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionTypeArgumentsAndTrunk(false);  
 			break;
  
-    case 401 : if (DEBUG) { System.out.println("ReferenceExpressionTypeArgumentsAndTrunk ::=..."); }  //$NON-NLS-1$
+    case 393 : if (DEBUG) { System.out.println("ReferenceExpressionTypeArgumentsAndTrunk ::=..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionTypeArgumentsAndTrunk(true);  
 			break;
  
-    case 402 : if (DEBUG) { System.out.println("ReferenceExpression ::= PrimitiveType Dims PushModifiers"); }  //$NON-NLS-1$
+    case 394 : if (DEBUG) { System.out.println("ReferenceExpression ::= PrimitiveType Dims COLON_COLON"); }  //$NON-NLS-1$
 		    consumeReferenceExpressionTypeForm(true, true);  
 			break;
  
-    case 403 : if (DEBUG) { System.out.println("ReferenceExpression ::= Modifiers PrimitiveType Dims..."); }  //$NON-NLS-1$
-		    consumeReferenceExpressionTypeForm(true, true);  
-			break;
- 
-    case 404 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name Dims PushModifiers..."); }  //$NON-NLS-1$
-		    consumeReferenceExpressionTypeForm(false, true);  
-			break;
- 
-    case 405 : if (DEBUG) { System.out.println("ReferenceExpression ::= Modifiers Name Dims..."); }  //$NON-NLS-1$
+    case 395 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name Dims COLON_COLON..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionTypeForm(false, true);  
 			break;
  
-    case 406 : if (DEBUG) { System.out.println("ReferenceExpression ::= Modifiers Name PushRealModifiers"); }  //$NON-NLS-1$
+    case 396 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name COLON_COLON..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionTypeForm(false, false);  
 			break;
  
-    case 407 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name COLON_COLON..."); }  //$NON-NLS-1$
-		    consumeReferenceExpressionNameForm();  
-			break;
- 
-    case 408 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name PushModifiers..."); }  //$NON-NLS-1$
-		    consumeReferenceExpressionGenericTypeForm();  
-			break;
- 
-    case 409 : if (DEBUG) { System.out.println("ReferenceExpression ::= Modifiers Name PushRealModifiers"); }  //$NON-NLS-1$
+    case 397 : if (DEBUG) { System.out.println("ReferenceExpression ::= Name BeginTypeArguments..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionGenericTypeForm();  
 			break;
  
-    case 410 : if (DEBUG) { System.out.println("ReferenceExpression ::= Primary COLON_COLON..."); }  //$NON-NLS-1$
+    case 398 : if (DEBUG) { System.out.println("ReferenceExpression ::= Primary COLON_COLON..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionPrimaryForm();  
 			break;
  
-    case 411 : if (DEBUG) { System.out.println("ReferenceExpression ::= super COLON_COLON..."); }  //$NON-NLS-1$
+    case 399 : if (DEBUG) { System.out.println("ReferenceExpression ::= super COLON_COLON..."); }  //$NON-NLS-1$
 		    consumeReferenceExpressionSuperForm();  
 			break;
  
-    case 412 : if (DEBUG) { System.out.println("NonWildTypeArgumentsopt ::="); }  //$NON-NLS-1$
+    case 400 : if (DEBUG) { System.out.println("NonWildTypeArgumentsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyTypeArguments();  
 			break;
  
-    case 414 : if (DEBUG) { System.out.println("IdentifierOrNew ::= Identifier"); }  //$NON-NLS-1$
+    case 402 : if (DEBUG) { System.out.println("IdentifierOrNew ::= Identifier"); }  //$NON-NLS-1$
 		    consumeIdentifierOrNew(false);  
 			break;
  
-    case 415 : if (DEBUG) { System.out.println("IdentifierOrNew ::= new"); }  //$NON-NLS-1$
+    case 403 : if (DEBUG) { System.out.println("IdentifierOrNew ::= new"); }  //$NON-NLS-1$
 		    consumeIdentifierOrNew(true);  
 			break;
  
-    case 416 : if (DEBUG) { System.out.println("LambdaExpression ::= LambdaParameters ARROW LambdaBody"); }  //$NON-NLS-1$
+    case 404 : if (DEBUG) { System.out.println("LambdaExpression ::= LambdaParameters ARROW LambdaBody"); }  //$NON-NLS-1$
 		    consumeLambdaExpression();  
 			break;
  
-    case 417 : if (DEBUG) { System.out.println("LambdaParameters ::= Identifier"); }  //$NON-NLS-1$
+    case 405 : if (DEBUG) { System.out.println("LambdaParameters ::= Identifier"); }  //$NON-NLS-1$
 		    consumeTypeElidedLambdaParameter(false);  
 			break;
  
-    case 422 : if (DEBUG) { System.out.println("TypeElidedFormalParameterList ::=..."); }  //$NON-NLS-1$
+    case 410 : if (DEBUG) { System.out.println("TypeElidedFormalParameterList ::=..."); }  //$NON-NLS-1$
 		    consumeFormalParameterList();  
 			break;
  
-    case 423 : if (DEBUG) { System.out.println("TypeElidedFormalParameter ::= Modifiersopt Identifier"); }  //$NON-NLS-1$
+    case 411 : if (DEBUG) { System.out.println("TypeElidedFormalParameter ::= Modifiersopt Identifier"); }  //$NON-NLS-1$
 		    consumeTypeElidedLambdaParameter(true);  
 			break;
  
-    case 425 : if (DEBUG) { System.out.println("LambdaBody ::= NestedType NestedMethod LBRACE..."); }  //$NON-NLS-1$
+    case 413 : if (DEBUG) { System.out.println("LambdaBody ::= NestedType NestedMethod LBRACE..."); }  //$NON-NLS-1$
 		    consumeBlock();  
 			break;
  
-    case 426 : if (DEBUG) { System.out.println("ElidedLeftBraceAndReturn ::="); }  //$NON-NLS-1$
+    case 414 : if (DEBUG) { System.out.println("ElidedLeftBraceAndReturn ::="); }  //$NON-NLS-1$
 		    consumeElidedLeftBraceAndReturn();  
 			break;
  
-    case 427 : if (DEBUG) { System.out.println("AllocationHeader ::= new ClassType LPAREN..."); }  //$NON-NLS-1$
+    case 415 : if (DEBUG) { System.out.println("AllocationHeader ::= new ClassType LPAREN..."); }  //$NON-NLS-1$
 		    consumeAllocationHeader();  
 			break;
  
-    case 428 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= new..."); }  //$NON-NLS-1$
+    case 416 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= new..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionWithTypeArguments();  
 			break;
  
-    case 429 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= new ClassType..."); }  //$NON-NLS-1$
+    case 417 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= new ClassType..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpression();  
 			break;
  
-    case 430 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= Primary DOT new..."); }  //$NON-NLS-1$
+    case 418 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= Primary DOT new..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionQualifiedWithTypeArguments() ;  
 			break;
  
-    case 431 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= Primary DOT new..."); }  //$NON-NLS-1$
+    case 419 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::= Primary DOT new..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionQualified() ;  
 			break;
  
-    case 432 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::=..."); }  //$NON-NLS-1$
+    case 420 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::=..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionQualified() ;  
 			break;
  
-    case 433 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::=..."); }  //$NON-NLS-1$
+    case 421 : if (DEBUG) { System.out.println("ClassInstanceCreationExpression ::=..."); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionQualifiedWithTypeArguments() ;  
 			break;
  
-    case 434 : if (DEBUG) { System.out.println("EnterInstanceCreationArgumentList ::="); }  //$NON-NLS-1$
+    case 422 : if (DEBUG) { System.out.println("EnterInstanceCreationArgumentList ::="); }  //$NON-NLS-1$
 		    consumeEnterInstanceCreationArgumentList();  
 			break;
  
-    case 435 : if (DEBUG) { System.out.println("ClassInstanceCreationExpressionName ::= Name DOT"); }  //$NON-NLS-1$
+    case 423 : if (DEBUG) { System.out.println("ClassInstanceCreationExpressionName ::= Name DOT"); }  //$NON-NLS-1$
 		    consumeClassInstanceCreationExpressionName() ;  
 			break;
  
-    case 436 : if (DEBUG) { System.out.println("UnqualifiedClassBodyopt ::="); }  //$NON-NLS-1$
+    case 424 : if (DEBUG) { System.out.println("UnqualifiedClassBodyopt ::="); }  //$NON-NLS-1$
 		    consumeClassBodyopt();  
 			break;
  
-    case 438 : if (DEBUG) { System.out.println("UnqualifiedEnterAnonymousClassBody ::="); }  //$NON-NLS-1$
+    case 426 : if (DEBUG) { System.out.println("UnqualifiedEnterAnonymousClassBody ::="); }  //$NON-NLS-1$
 		    consumeEnterAnonymousClassBody(false);  
 			break;
  
-    case 439 : if (DEBUG) { System.out.println("QualifiedClassBodyopt ::="); }  //$NON-NLS-1$
+    case 427 : if (DEBUG) { System.out.println("QualifiedClassBodyopt ::="); }  //$NON-NLS-1$
 		    consumeClassBodyopt();  
 			break;
  
-    case 441 : if (DEBUG) { System.out.println("QualifiedEnterAnonymousClassBody ::="); }  //$NON-NLS-1$
+    case 429 : if (DEBUG) { System.out.println("QualifiedEnterAnonymousClassBody ::="); }  //$NON-NLS-1$
 		    consumeEnterAnonymousClassBody(true);  
 			break;
  
-    case 443 : if (DEBUG) { System.out.println("ArgumentList ::= ArgumentList COMMA Expression"); }  //$NON-NLS-1$
+    case 431 : if (DEBUG) { System.out.println("ArgumentList ::= ArgumentList COMMA Expression"); }  //$NON-NLS-1$
 		    consumeArgumentList();  
 			break;
  
-    case 444 : if (DEBUG) { System.out.println("ArrayCreationHeader ::= new Annotationsopt PrimitiveType"); }  //$NON-NLS-1$
+    case 432 : if (DEBUG) { System.out.println("ArrayCreationHeader ::= new PrimitiveType..."); }  //$NON-NLS-1$
 		    consumeArrayCreationHeader();  
 			break;
  
-    case 445 : if (DEBUG) { System.out.println("ArrayCreationHeader ::= new ClassOrInterfaceType..."); }  //$NON-NLS-1$
+    case 433 : if (DEBUG) { System.out.println("ArrayCreationHeader ::= new ClassOrInterfaceType..."); }  //$NON-NLS-1$
 		    consumeArrayCreationHeader();  
 			break;
  
-    case 446 : if (DEBUG) { System.out.println("ArrayCreationWithoutArrayInitializer ::= new..."); }  //$NON-NLS-1$
+    case 434 : if (DEBUG) { System.out.println("ArrayCreationWithoutArrayInitializer ::= new..."); }  //$NON-NLS-1$
 		    consumeArrayCreationExpressionWithoutInitializer();  
 			break;
  
-    case 447 : if (DEBUG) { System.out.println("ArrayCreationWithArrayInitializer ::= new Annotationsopt"); }  //$NON-NLS-1$
+    case 435 : if (DEBUG) { System.out.println("ArrayCreationWithArrayInitializer ::= new PrimitiveType"); }  //$NON-NLS-1$
 		    consumeArrayCreationExpressionWithInitializer();  
 			break;
  
-    case 448 : if (DEBUG) { System.out.println("ArrayCreationWithoutArrayInitializer ::= new..."); }  //$NON-NLS-1$
+    case 436 : if (DEBUG) { System.out.println("ArrayCreationWithoutArrayInitializer ::= new..."); }  //$NON-NLS-1$
 		    consumeArrayCreationExpressionWithoutInitializer();  
 			break;
  
-    case 449 : if (DEBUG) { System.out.println("ArrayCreationWithArrayInitializer ::= new..."); }  //$NON-NLS-1$
+    case 437 : if (DEBUG) { System.out.println("ArrayCreationWithArrayInitializer ::= new..."); }  //$NON-NLS-1$
 		    consumeArrayCreationExpressionWithInitializer();  
 			break;
  
-    case 451 : if (DEBUG) { System.out.println("DimWithOrWithOutExprs ::= DimWithOrWithOutExprs..."); }  //$NON-NLS-1$
+    case 439 : if (DEBUG) { System.out.println("DimWithOrWithOutExprs ::= DimWithOrWithOutExprs..."); }  //$NON-NLS-1$
 		    consumeDimWithOrWithOutExprs();  
 			break;
  
-     case 454 : if (DEBUG) { System.out.println("DimWithOrWithOutExpr ::= LBRACKET..."); }  //$NON-NLS-1$
+     case 441 : if (DEBUG) { System.out.println("DimWithOrWithOutExpr ::= TypeAnnotationsopt LBRACKET..."); }  //$NON-NLS-1$
 		    consumeDimWithOrWithOutExpr();  
 			break;
  
-     case 455 : if (DEBUG) { System.out.println("DimWithOrWithOutExpr ::= TypeAnnotations LBRACKET..."); }  //$NON-NLS-1$
-		    consumeDimWithOrWithOutExpr();  
-			break;
- 
-     case 456 : if (DEBUG) { System.out.println("DimsoptAnnotsopt ::="); }  //$NON-NLS-1$
-		    consumeEmptyDimsoptAnnotsopt();  
-			break;
- 
-     case 457 : if (DEBUG) { System.out.println("DimsoptAnnotsopt -> DimsAnnotLoop"); }  //$NON-NLS-1$
-		    consumeDimsWithTrailingAnnotsopt();  
-			break;
- 
-     case 460 : if (DEBUG) { System.out.println("OneDimOrAnnot ::= Annotation"); }  //$NON-NLS-1$
-		    consumeTypeAnnotation(true);  
-			break;
- 
-     case 461 : if (DEBUG) { System.out.println("OneDimOrAnnot ::= LBRACKET RBRACKET"); }  //$NON-NLS-1$
-		    consumeOneDimLoop(true);  
-			break;
- 
-     case 462 : if (DEBUG) { System.out.println("TypeAnnotations ::= Annotation"); }  //$NON-NLS-1$
-		    consumeTypeAnnotation(false);  
-			break;
- 
-     case 463 : if (DEBUG) { System.out.println("TypeAnnotations ::= TypeAnnotations Annotation"); }  //$NON-NLS-1$
-		    consumeOneMoreTypeAnnotation();  
-			break;
- 
-     case 464 : if (DEBUG) { System.out.println("Dims ::= DimsLoop"); }  //$NON-NLS-1$
+     case 442 : if (DEBUG) { System.out.println("Dims ::= DimsLoop"); }  //$NON-NLS-1$
 		    consumeDims();  
 			break;
  
-     case 467 : if (DEBUG) { System.out.println("OneDimLoop ::= LBRACKET RBRACKET"); }  //$NON-NLS-1$
+     case 445 : if (DEBUG) { System.out.println("OneDimLoop ::= LBRACKET RBRACKET"); }  //$NON-NLS-1$
 		    consumeOneDimLoop(false);  
 			break;
  
-     case 468 : if (DEBUG) { System.out.println("OneDimLoop ::= TypeAnnotations LBRACKET RBRACKET"); }  //$NON-NLS-1$
-		    consumeOneDimLoopWithAnnotations();  
+     case 446 : if (DEBUG) { System.out.println("OneDimLoop ::= TypeAnnotations LBRACKET RBRACKET"); }  //$NON-NLS-1$
+		    consumeOneDimLoop(true);  
 			break;
  
-    case 469 : if (DEBUG) { System.out.println("FieldAccess ::= Primary DOT Identifier"); }  //$NON-NLS-1$
+    case 447 : if (DEBUG) { System.out.println("FieldAccess ::= Primary DOT Identifier"); }  //$NON-NLS-1$
 		    consumeFieldAccess(false);  
 			break;
  
-    case 470 : if (DEBUG) { System.out.println("FieldAccess ::= super DOT Identifier"); }  //$NON-NLS-1$
+    case 448 : if (DEBUG) { System.out.println("FieldAccess ::= super DOT Identifier"); }  //$NON-NLS-1$
 		    consumeFieldAccess(true);  
 			break;
  
-    case 471 : if (DEBUG) { System.out.println("MethodInvocation ::= Name LPAREN ArgumentListopt RPAREN"); }  //$NON-NLS-1$
+    case 449 : if (DEBUG) { System.out.println("MethodInvocation ::= Name LPAREN ArgumentListopt RPAREN"); }  //$NON-NLS-1$
 		    consumeMethodInvocationName();  
 			break;
  
-    case 472 : if (DEBUG) { System.out.println("MethodInvocation ::= Name DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
+    case 450 : if (DEBUG) { System.out.println("MethodInvocation ::= Name DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
 		    consumeMethodInvocationNameWithTypeArguments();  
 			break;
  
-    case 473 : if (DEBUG) { System.out.println("MethodInvocation ::= Primary DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
+    case 451 : if (DEBUG) { System.out.println("MethodInvocation ::= Primary DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
 		    consumeMethodInvocationPrimaryWithTypeArguments();  
 			break;
  
-    case 474 : if (DEBUG) { System.out.println("MethodInvocation ::= Primary DOT Identifier LPAREN..."); }  //$NON-NLS-1$
+    case 452 : if (DEBUG) { System.out.println("MethodInvocation ::= Primary DOT Identifier LPAREN..."); }  //$NON-NLS-1$
 		    consumeMethodInvocationPrimary();  
 			break;
  
-    case 475 : if (DEBUG) { System.out.println("MethodInvocation ::= super DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
+    case 453 : if (DEBUG) { System.out.println("MethodInvocation ::= super DOT OnlyTypeArguments..."); }  //$NON-NLS-1$
 		    consumeMethodInvocationSuperWithTypeArguments();  
 			break;
  
-    case 476 : if (DEBUG) { System.out.println("MethodInvocation ::= super DOT Identifier LPAREN..."); }  //$NON-NLS-1$
+    case 454 : if (DEBUG) { System.out.println("MethodInvocation ::= super DOT Identifier LPAREN..."); }  //$NON-NLS-1$
 		    consumeMethodInvocationSuper();  
 			break;
  
-    case 477 : if (DEBUG) { System.out.println("ArrayAccess ::= Name LBRACKET Expression RBRACKET"); }  //$NON-NLS-1$
+    case 455 : if (DEBUG) { System.out.println("ArrayAccess ::= Name LBRACKET Expression RBRACKET"); }  //$NON-NLS-1$
 		    consumeArrayAccess(true);  
 			break;
  
-    case 478 : if (DEBUG) { System.out.println("ArrayAccess ::= PrimaryNoNewArray LBRACKET Expression..."); }  //$NON-NLS-1$
+    case 456 : if (DEBUG) { System.out.println("ArrayAccess ::= PrimaryNoNewArray LBRACKET Expression..."); }  //$NON-NLS-1$
 		    consumeArrayAccess(false);  
 			break;
  
-    case 479 : if (DEBUG) { System.out.println("ArrayAccess ::= ArrayCreationWithArrayInitializer..."); }  //$NON-NLS-1$
+    case 457 : if (DEBUG) { System.out.println("ArrayAccess ::= ArrayCreationWithArrayInitializer..."); }  //$NON-NLS-1$
 		    consumeArrayAccess(false);  
 			break;
  
-    case 481 : if (DEBUG) { System.out.println("PostfixExpression ::= Name"); }  //$NON-NLS-1$
+    case 459 : if (DEBUG) { System.out.println("PostfixExpression ::= Name"); }  //$NON-NLS-1$
 		    consumePostfixExpression();  
 			break;
  
-    case 484 : if (DEBUG) { System.out.println("PostIncrementExpression ::= PostfixExpression PLUS_PLUS"); }  //$NON-NLS-1$
+    case 462 : if (DEBUG) { System.out.println("PostIncrementExpression ::= PostfixExpression PLUS_PLUS"); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.PLUS,true);  
 			break;
  
-    case 485 : if (DEBUG) { System.out.println("PostDecrementExpression ::= PostfixExpression..."); }  //$NON-NLS-1$
+    case 463 : if (DEBUG) { System.out.println("PostDecrementExpression ::= PostfixExpression..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.MINUS,true);  
 			break;
  
-    case 486 : if (DEBUG) { System.out.println("PushPosition ::="); }  //$NON-NLS-1$
+    case 464 : if (DEBUG) { System.out.println("PushPosition ::="); }  //$NON-NLS-1$
 		    consumePushPosition();  
 			break;
  
-    case 489 : if (DEBUG) { System.out.println("UnaryExpression ::= PLUS PushPosition UnaryExpression"); }  //$NON-NLS-1$
+    case 467 : if (DEBUG) { System.out.println("UnaryExpression ::= PLUS PushPosition UnaryExpression"); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.PLUS);  
 			break;
  
-    case 490 : if (DEBUG) { System.out.println("UnaryExpression ::= MINUS PushPosition UnaryExpression"); }  //$NON-NLS-1$
+    case 468 : if (DEBUG) { System.out.println("UnaryExpression ::= MINUS PushPosition UnaryExpression"); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.MINUS);  
 			break;
  
-    case 492 : if (DEBUG) { System.out.println("PreIncrementExpression ::= PLUS_PLUS PushPosition..."); }  //$NON-NLS-1$
+    case 470 : if (DEBUG) { System.out.println("PreIncrementExpression ::= PLUS_PLUS PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.PLUS,false);  
 			break;
  
-    case 493 : if (DEBUG) { System.out.println("PreDecrementExpression ::= MINUS_MINUS PushPosition..."); }  //$NON-NLS-1$
+    case 471 : if (DEBUG) { System.out.println("PreDecrementExpression ::= MINUS_MINUS PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.MINUS,false);  
 			break;
  
-    case 495 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus ::= TWIDDLE PushPosition..."); }  //$NON-NLS-1$
+    case 473 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus ::= TWIDDLE PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.TWIDDLE);  
 			break;
  
-    case 496 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus ::= NOT PushPosition..."); }  //$NON-NLS-1$
+    case 474 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus ::= NOT PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.NOT);  
 			break;
  
-    case 498 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN PrimitiveType Dimsopt..."); }  //$NON-NLS-1$
+    case 476 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN PrimitiveType Dimsopt..."); }  //$NON-NLS-1$
 		    consumeCastExpressionWithPrimitiveType();  
 			break;
  
-    case 499 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Modifiers PrimitiveType..."); }  //$NON-NLS-1$
-		    consumeCastExpressionWithPrimitiveTypeWithTypeAnnotations();  
-			break;
- 
-    case 500 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name..."); }  //$NON-NLS-1$
+    case 477 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name..."); }  //$NON-NLS-1$
 		    consumeCastExpressionWithGenericsArray();  
 			break;
  
-    case 501 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Modifiers Name..."); }  //$NON-NLS-1$
-		    consumeCastExpressionWithGenericsArrayWithTypeAnnotations();  
-			break;
- 
-    case 502 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name..."); }  //$NON-NLS-1$
+    case 478 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name..."); }  //$NON-NLS-1$
 		    consumeCastExpressionWithQualifiedGenericsArray();  
 			break;
  
-    case 503 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Modifiers Name..."); }  //$NON-NLS-1$
-		    consumeCastExpressionWithQualifiedGenericsArrayWithTypeAnnotations();  
-			break;
- 
-    case 504 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name..."); }  //$NON-NLS-1$
+    case 479 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name PushRPAREN..."); }  //$NON-NLS-1$
 		    consumeCastExpressionLL1();  
 			break;
  
-    case 505 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Modifiers Name..."); }  //$NON-NLS-1$
-		    consumeCastExpressionLL1WithTypeAnnotations();  
-			break;
- 
-    case 506 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name Dims..."); }  //$NON-NLS-1$
+    case 480 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Name Dims PushRPAREN..."); }  //$NON-NLS-1$
 		    consumeCastExpressionWithNameArray();  
 			break;
  
-    case 507 : if (DEBUG) { System.out.println("CastExpression ::= PushLPAREN Modifiers Name Dims..."); }  //$NON-NLS-1$
-		    consumeCastExpressionWithNameArrayWithTypeAnnotations();  
-			break;
- 
-    case 508 : if (DEBUG) { System.out.println("OnlyTypeArgumentsForCastExpression ::= OnlyTypeArguments"); }  //$NON-NLS-1$
+    case 481 : if (DEBUG) { System.out.println("OnlyTypeArgumentsForCastExpression ::= OnlyTypeArguments"); }  //$NON-NLS-1$
 		    consumeOnlyTypeArgumentsForCastExpression();  
 			break;
  
-    case 509 : if (DEBUG) { System.out.println("InsideCastExpression ::="); }  //$NON-NLS-1$
+    case 482 : if (DEBUG) { System.out.println("InsideCastExpression ::="); }  //$NON-NLS-1$
 		    consumeInsideCastExpression();  
 			break;
  
-    case 510 : if (DEBUG) { System.out.println("InsideCastExpressionLL1 ::="); }  //$NON-NLS-1$
+    case 483 : if (DEBUG) { System.out.println("InsideCastExpressionLL1 ::="); }  //$NON-NLS-1$
 		    consumeInsideCastExpressionLL1();  
 			break;
  
-    case 511 : if (DEBUG) { System.out.println("InsideCastExpressionWithQualifiedGenerics ::="); }  //$NON-NLS-1$
+    case 484 : if (DEBUG) { System.out.println("InsideCastExpressionWithQualifiedGenerics ::="); }  //$NON-NLS-1$
 		    consumeInsideCastExpressionWithQualifiedGenerics();  
 			break;
  
-    case 512 : if (DEBUG) { System.out.println("InsideCastExpressionWithAnnotatedQualifiedGenerics ::="); }  //$NON-NLS-1$
-		    consumeInsideCastExpressionWithAnnotatedQualifiedGenerics();  
-			break;
- 
-    case 514 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
+    case 486 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.MULTIPLY);  
 			break;
  
-    case 515 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
+    case 487 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.DIVIDE);  
 			break;
  
-    case 516 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
+    case 488 : if (DEBUG) { System.out.println("MultiplicativeExpression ::= MultiplicativeExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.REMAINDER);  
 			break;
  
-    case 518 : if (DEBUG) { System.out.println("AdditiveExpression ::= AdditiveExpression PLUS..."); }  //$NON-NLS-1$
+    case 490 : if (DEBUG) { System.out.println("AdditiveExpression ::= AdditiveExpression PLUS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.PLUS);  
 			break;
  
-    case 519 : if (DEBUG) { System.out.println("AdditiveExpression ::= AdditiveExpression MINUS..."); }  //$NON-NLS-1$
+    case 491 : if (DEBUG) { System.out.println("AdditiveExpression ::= AdditiveExpression MINUS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.MINUS);  
 			break;
  
-    case 521 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression LEFT_SHIFT..."); }  //$NON-NLS-1$
+    case 493 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression LEFT_SHIFT..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LEFT_SHIFT);  
 			break;
  
-    case 522 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression RIGHT_SHIFT..."); }  //$NON-NLS-1$
+    case 494 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression RIGHT_SHIFT..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.RIGHT_SHIFT);  
 			break;
  
-    case 523 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression UNSIGNED_RIGHT_SHIFT"); }  //$NON-NLS-1$
+    case 495 : if (DEBUG) { System.out.println("ShiftExpression ::= ShiftExpression UNSIGNED_RIGHT_SHIFT"); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.UNSIGNED_RIGHT_SHIFT);  
 			break;
  
-    case 525 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression LESS..."); }  //$NON-NLS-1$
+    case 497 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression LESS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LESS);  
 			break;
  
-    case 526 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression GREATER..."); }  //$NON-NLS-1$
+    case 498 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression GREATER..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.GREATER);  
 			break;
  
-    case 527 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression LESS_EQUAL"); }  //$NON-NLS-1$
+    case 499 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression LESS_EQUAL"); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LESS_EQUAL);  
 			break;
  
-    case 528 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression..."); }  //$NON-NLS-1$
+    case 500 : if (DEBUG) { System.out.println("RelationalExpression ::= RelationalExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.GREATER_EQUAL);  
 			break;
  
-    case 530 : if (DEBUG) { System.out.println("InstanceofExpression ::= InstanceofExpression instanceof"); }  //$NON-NLS-1$
+    case 502 : if (DEBUG) { System.out.println("InstanceofExpression ::= InstanceofExpression instanceof"); }  //$NON-NLS-1$
 		    consumeInstanceOfExpression();  
 			break;
  
-    case 532 : if (DEBUG) { System.out.println("EqualityExpression ::= EqualityExpression EQUAL_EQUAL..."); }  //$NON-NLS-1$
+    case 504 : if (DEBUG) { System.out.println("EqualityExpression ::= EqualityExpression EQUAL_EQUAL..."); }  //$NON-NLS-1$
 		    consumeEqualityExpression(OperatorIds.EQUAL_EQUAL);  
 			break;
  
-    case 533 : if (DEBUG) { System.out.println("EqualityExpression ::= EqualityExpression NOT_EQUAL..."); }  //$NON-NLS-1$
+    case 505 : if (DEBUG) { System.out.println("EqualityExpression ::= EqualityExpression NOT_EQUAL..."); }  //$NON-NLS-1$
 		    consumeEqualityExpression(OperatorIds.NOT_EQUAL);  
 			break;
  
-    case 535 : if (DEBUG) { System.out.println("AndExpression ::= AndExpression AND EqualityExpression"); }  //$NON-NLS-1$
+    case 507 : if (DEBUG) { System.out.println("AndExpression ::= AndExpression AND EqualityExpression"); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.AND);  
 			break;
  
-    case 537 : if (DEBUG) { System.out.println("ExclusiveOrExpression ::= ExclusiveOrExpression XOR..."); }  //$NON-NLS-1$
+    case 509 : if (DEBUG) { System.out.println("ExclusiveOrExpression ::= ExclusiveOrExpression XOR..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.XOR);  
 			break;
  
-    case 539 : if (DEBUG) { System.out.println("InclusiveOrExpression ::= InclusiveOrExpression OR..."); }  //$NON-NLS-1$
+    case 511 : if (DEBUG) { System.out.println("InclusiveOrExpression ::= InclusiveOrExpression OR..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.OR);  
 			break;
  
-    case 541 : if (DEBUG) { System.out.println("ConditionalAndExpression ::= ConditionalAndExpression..."); }  //$NON-NLS-1$
+    case 513 : if (DEBUG) { System.out.println("ConditionalAndExpression ::= ConditionalAndExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.AND_AND);  
 			break;
  
-    case 543 : if (DEBUG) { System.out.println("ConditionalOrExpression ::= ConditionalOrExpression..."); }  //$NON-NLS-1$
+    case 515 : if (DEBUG) { System.out.println("ConditionalOrExpression ::= ConditionalOrExpression..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.OR_OR);  
 			break;
  
-    case 545 : if (DEBUG) { System.out.println("ConditionalExpression ::= ConditionalOrExpression..."); }  //$NON-NLS-1$
+    case 517 : if (DEBUG) { System.out.println("ConditionalExpression ::= ConditionalOrExpression..."); }  //$NON-NLS-1$
 		    consumeConditionalExpression(OperatorIds.QUESTIONCOLON) ;  
 			break;
  
-    case 548 : if (DEBUG) { System.out.println("Assignment ::= PostfixExpression AssignmentOperator..."); }  //$NON-NLS-1$
+    case 520 : if (DEBUG) { System.out.println("Assignment ::= PostfixExpression AssignmentOperator..."); }  //$NON-NLS-1$
 		    consumeAssignment();  
 			break;
  
-    case 550 : if (DEBUG) { System.out.println("Assignment ::= InvalidArrayInitializerAssignement"); }  //$NON-NLS-1$
+    case 522 : if (DEBUG) { System.out.println("Assignment ::= InvalidArrayInitializerAssignement"); }  //$NON-NLS-1$
 		    ignoreExpressionAssignment(); 
 			break;
  
-    case 551 : if (DEBUG) { System.out.println("AssignmentOperator ::= EQUAL"); }  //$NON-NLS-1$
+    case 523 : if (DEBUG) { System.out.println("AssignmentOperator ::= EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(EQUAL);  
 			break;
  
-    case 552 : if (DEBUG) { System.out.println("AssignmentOperator ::= MULTIPLY_EQUAL"); }  //$NON-NLS-1$
+    case 524 : if (DEBUG) { System.out.println("AssignmentOperator ::= MULTIPLY_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(MULTIPLY);  
 			break;
  
-    case 553 : if (DEBUG) { System.out.println("AssignmentOperator ::= DIVIDE_EQUAL"); }  //$NON-NLS-1$
+    case 525 : if (DEBUG) { System.out.println("AssignmentOperator ::= DIVIDE_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(DIVIDE);  
 			break;
  
-    case 554 : if (DEBUG) { System.out.println("AssignmentOperator ::= REMAINDER_EQUAL"); }  //$NON-NLS-1$
+    case 526 : if (DEBUG) { System.out.println("AssignmentOperator ::= REMAINDER_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(REMAINDER);  
 			break;
  
-    case 555 : if (DEBUG) { System.out.println("AssignmentOperator ::= PLUS_EQUAL"); }  //$NON-NLS-1$
+    case 527 : if (DEBUG) { System.out.println("AssignmentOperator ::= PLUS_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(PLUS);  
 			break;
  
-    case 556 : if (DEBUG) { System.out.println("AssignmentOperator ::= MINUS_EQUAL"); }  //$NON-NLS-1$
+    case 528 : if (DEBUG) { System.out.println("AssignmentOperator ::= MINUS_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(MINUS);  
 			break;
  
-    case 557 : if (DEBUG) { System.out.println("AssignmentOperator ::= LEFT_SHIFT_EQUAL"); }  //$NON-NLS-1$
+    case 529 : if (DEBUG) { System.out.println("AssignmentOperator ::= LEFT_SHIFT_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(LEFT_SHIFT);  
 			break;
  
-    case 558 : if (DEBUG) { System.out.println("AssignmentOperator ::= RIGHT_SHIFT_EQUAL"); }  //$NON-NLS-1$
+    case 530 : if (DEBUG) { System.out.println("AssignmentOperator ::= RIGHT_SHIFT_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(RIGHT_SHIFT);  
 			break;
  
-    case 559 : if (DEBUG) { System.out.println("AssignmentOperator ::= UNSIGNED_RIGHT_SHIFT_EQUAL"); }  //$NON-NLS-1$
+    case 531 : if (DEBUG) { System.out.println("AssignmentOperator ::= UNSIGNED_RIGHT_SHIFT_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(UNSIGNED_RIGHT_SHIFT);  
 			break;
  
-    case 560 : if (DEBUG) { System.out.println("AssignmentOperator ::= AND_EQUAL"); }  //$NON-NLS-1$
+    case 532 : if (DEBUG) { System.out.println("AssignmentOperator ::= AND_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(AND);  
 			break;
  
-    case 561 : if (DEBUG) { System.out.println("AssignmentOperator ::= XOR_EQUAL"); }  //$NON-NLS-1$
+    case 533 : if (DEBUG) { System.out.println("AssignmentOperator ::= XOR_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(XOR);  
 			break;
  
-    case 562 : if (DEBUG) { System.out.println("AssignmentOperator ::= OR_EQUAL"); }  //$NON-NLS-1$
+    case 534 : if (DEBUG) { System.out.println("AssignmentOperator ::= OR_EQUAL"); }  //$NON-NLS-1$
 		    consumeAssignmentOperator(OR);  
 			break;
  
-    case 563 : if (DEBUG) { System.out.println("Expression ::= AssignmentExpression"); }  //$NON-NLS-1$
+    case 535 : if (DEBUG) { System.out.println("Expression ::= AssignmentExpression"); }  //$NON-NLS-1$
 		    consumeExpression();  
 			break;
  
-    case 566 : if (DEBUG) { System.out.println("Expressionopt ::="); }  //$NON-NLS-1$
+    case 538 : if (DEBUG) { System.out.println("Expressionopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyExpression();  
 			break;
  
-    case 571 : if (DEBUG) { System.out.println("ClassBodyDeclarationsopt ::="); }  //$NON-NLS-1$
+    case 543 : if (DEBUG) { System.out.println("ClassBodyDeclarationsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyClassBodyDeclarationsopt();  
 			break;
  
-    case 572 : if (DEBUG) { System.out.println("ClassBodyDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
+    case 544 : if (DEBUG) { System.out.println("ClassBodyDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
 		    consumeClassBodyDeclarationsopt();  
 			break;
  
-     case 573 : if (DEBUG) { System.out.println("Modifiersopt ::="); }  //$NON-NLS-1$
+     case 545 : if (DEBUG) { System.out.println("Modifiersopt ::="); }  //$NON-NLS-1$
 		    consumeDefaultModifiers();  
 			break;
  
-    case 574 : if (DEBUG) { System.out.println("Modifiersopt ::= Modifiers"); }  //$NON-NLS-1$
+    case 546 : if (DEBUG) { System.out.println("Modifiersopt ::= Modifiers"); }  //$NON-NLS-1$
 		    consumeModifiers();  
 			break;
  
-    case 575 : if (DEBUG) { System.out.println("BlockStatementsopt ::="); }  //$NON-NLS-1$
+    case 547 : if (DEBUG) { System.out.println("BlockStatementsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyBlockStatementsopt();  
 			break;
  
-     case 577 : if (DEBUG) { System.out.println("Dimsopt ::="); }  //$NON-NLS-1$
+     case 549 : if (DEBUG) { System.out.println("Dimsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyDimsopt();  
 			break;
  
-     case 579 : if (DEBUG) { System.out.println("ArgumentListopt ::="); }  //$NON-NLS-1$
+     case 551 : if (DEBUG) { System.out.println("ArgumentListopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyArgumentListopt();  
 			break;
  
-    case 583 : if (DEBUG) { System.out.println("FormalParameterListopt ::="); }  //$NON-NLS-1$
+    case 555 : if (DEBUG) { System.out.println("FormalParameterListopt ::="); }  //$NON-NLS-1$
 		    consumeFormalParameterListopt();  
 			break;
  
-     case 587 : if (DEBUG) { System.out.println("InterfaceMemberDeclarationsopt ::="); }  //$NON-NLS-1$
+     case 559 : if (DEBUG) { System.out.println("InterfaceMemberDeclarationsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyInterfaceMemberDeclarationsopt();  
 			break;
  
-     case 588 : if (DEBUG) { System.out.println("InterfaceMemberDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
+     case 560 : if (DEBUG) { System.out.println("InterfaceMemberDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
 		    consumeInterfaceMemberDeclarationsopt();  
 			break;
  
-    case 589 : if (DEBUG) { System.out.println("NestedType ::="); }  //$NON-NLS-1$
+    case 561 : if (DEBUG) { System.out.println("NestedType ::="); }  //$NON-NLS-1$
 		    consumeNestedType();  
 			break;
 
-     case 590 : if (DEBUG) { System.out.println("ForInitopt ::="); }  //$NON-NLS-1$
+     case 562 : if (DEBUG) { System.out.println("ForInitopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyForInitopt();  
 			break;
  
-     case 592 : if (DEBUG) { System.out.println("ForUpdateopt ::="); }  //$NON-NLS-1$
+     case 564 : if (DEBUG) { System.out.println("ForUpdateopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyForUpdateopt();  
 			break;
  
-     case 596 : if (DEBUG) { System.out.println("Catchesopt ::="); }  //$NON-NLS-1$
+     case 568 : if (DEBUG) { System.out.println("Catchesopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyCatchesopt();  
 			break;
  
-     case 598 : if (DEBUG) { System.out.println("EnumDeclaration ::= EnumHeader EnumBody"); }  //$NON-NLS-1$
+     case 570 : if (DEBUG) { System.out.println("EnumDeclaration ::= EnumHeader EnumBody"); }  //$NON-NLS-1$
 		    consumeEnumDeclaration();  
 			break;
  
-     case 599 : if (DEBUG) { System.out.println("EnumHeader ::= EnumHeaderName ClassHeaderImplementsopt"); }  //$NON-NLS-1$
+     case 571 : if (DEBUG) { System.out.println("EnumHeader ::= EnumHeaderName ClassHeaderImplementsopt"); }  //$NON-NLS-1$
 		    consumeEnumHeader();  
 			break;
  
-     case 600 : if (DEBUG) { System.out.println("EnumHeaderName ::= Modifiersopt enum Identifier"); }  //$NON-NLS-1$
+     case 572 : if (DEBUG) { System.out.println("EnumHeaderName ::= Modifiersopt enum Identifier"); }  //$NON-NLS-1$
 		    consumeEnumHeaderName();  
 			break;
  
-     case 601 : if (DEBUG) { System.out.println("EnumHeaderName ::= Modifiersopt enum Identifier..."); }  //$NON-NLS-1$
+     case 573 : if (DEBUG) { System.out.println("EnumHeaderName ::= Modifiersopt enum Identifier..."); }  //$NON-NLS-1$
 		    consumeEnumHeaderNameWithTypeParameters();  
 			break;
  
-     case 602 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumBodyDeclarationsopt RBRACE"); }  //$NON-NLS-1$
+     case 574 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumBodyDeclarationsopt RBRACE"); }  //$NON-NLS-1$
 		    consumeEnumBodyNoConstants();  
 			break;
  
-     case 603 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE COMMA EnumBodyDeclarationsopt..."); }  //$NON-NLS-1$
+     case 575 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE COMMA EnumBodyDeclarationsopt..."); }  //$NON-NLS-1$
 		    consumeEnumBodyNoConstants();  
 			break;
  
-     case 604 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumConstants COMMA..."); }  //$NON-NLS-1$
+     case 576 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumConstants COMMA..."); }  //$NON-NLS-1$
 		    consumeEnumBodyWithConstants();  
 			break;
  
-     case 605 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumConstants..."); }  //$NON-NLS-1$
+     case 577 : if (DEBUG) { System.out.println("EnumBody ::= LBRACE EnumConstants..."); }  //$NON-NLS-1$
 		    consumeEnumBodyWithConstants();  
 			break;
  
-    case 607 : if (DEBUG) { System.out.println("EnumConstants ::= EnumConstants COMMA EnumConstant"); }  //$NON-NLS-1$
+    case 579 : if (DEBUG) { System.out.println("EnumConstants ::= EnumConstants COMMA EnumConstant"); }  //$NON-NLS-1$
 		    consumeEnumConstants();  
 			break;
  
-    case 608 : if (DEBUG) { System.out.println("EnumConstantHeaderName ::= Modifiersopt Identifier"); }  //$NON-NLS-1$
+    case 580 : if (DEBUG) { System.out.println("EnumConstantHeaderName ::= Modifiersopt Identifier"); }  //$NON-NLS-1$
 		    consumeEnumConstantHeaderName();  
 			break;
  
-    case 609 : if (DEBUG) { System.out.println("EnumConstantHeader ::= EnumConstantHeaderName..."); }  //$NON-NLS-1$
+    case 581 : if (DEBUG) { System.out.println("EnumConstantHeader ::= EnumConstantHeaderName..."); }  //$NON-NLS-1$
 		    consumeEnumConstantHeader();  
 			break;
  
-    case 610 : if (DEBUG) { System.out.println("EnumConstant ::= EnumConstantHeader ForceNoDiet..."); }  //$NON-NLS-1$
+    case 582 : if (DEBUG) { System.out.println("EnumConstant ::= EnumConstantHeader ForceNoDiet..."); }  //$NON-NLS-1$
 		    consumeEnumConstantWithClassBody();  
 			break;
  
-    case 611 : if (DEBUG) { System.out.println("EnumConstant ::= EnumConstantHeader"); }  //$NON-NLS-1$
+    case 583 : if (DEBUG) { System.out.println("EnumConstant ::= EnumConstantHeader"); }  //$NON-NLS-1$
 		    consumeEnumConstantNoClassBody();  
 			break;
  
-    case 612 : if (DEBUG) { System.out.println("Arguments ::= LPAREN ArgumentListopt RPAREN"); }  //$NON-NLS-1$
+    case 584 : if (DEBUG) { System.out.println("Arguments ::= LPAREN ArgumentListopt RPAREN"); }  //$NON-NLS-1$
 		    consumeArguments();  
 			break;
  
-    case 613 : if (DEBUG) { System.out.println("Argumentsopt ::="); }  //$NON-NLS-1$
+    case 585 : if (DEBUG) { System.out.println("Argumentsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyArguments();  
 			break;
  
-    case 615 : if (DEBUG) { System.out.println("EnumDeclarations ::= SEMICOLON ClassBodyDeclarationsopt"); }  //$NON-NLS-1$
+    case 587 : if (DEBUG) { System.out.println("EnumDeclarations ::= SEMICOLON ClassBodyDeclarationsopt"); }  //$NON-NLS-1$
 		    consumeEnumDeclarations();  
 			break;
  
-    case 616 : if (DEBUG) { System.out.println("EnumBodyDeclarationsopt ::="); }  //$NON-NLS-1$
+    case 588 : if (DEBUG) { System.out.println("EnumBodyDeclarationsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyEnumDeclarations();  
 			break;
  
-    case 618 : if (DEBUG) { System.out.println("EnhancedForStatement ::= EnhancedForStatementHeader..."); }  //$NON-NLS-1$
+    case 590 : if (DEBUG) { System.out.println("EnhancedForStatement ::= EnhancedForStatementHeader..."); }  //$NON-NLS-1$
 		    consumeEnhancedForStatement();  
 			break;
  
-    case 619 : if (DEBUG) { System.out.println("EnhancedForStatementNoShortIf ::=..."); }  //$NON-NLS-1$
+    case 591 : if (DEBUG) { System.out.println("EnhancedForStatementNoShortIf ::=..."); }  //$NON-NLS-1$
 		    consumeEnhancedForStatement();  
 			break;
  
-    case 620 : if (DEBUG) { System.out.println("EnhancedForStatementHeaderInit ::= for LPAREN Type0..."); }  //$NON-NLS-1$
+    case 592 : if (DEBUG) { System.out.println("EnhancedForStatementHeaderInit ::= for LPAREN Type..."); }  //$NON-NLS-1$
 		    consumeEnhancedForStatementHeaderInit(false);  
 			break;
  
-    case 621 : if (DEBUG) { System.out.println("EnhancedForStatementHeaderInit ::= for LPAREN Modifiers"); }  //$NON-NLS-1$
+    case 593 : if (DEBUG) { System.out.println("EnhancedForStatementHeaderInit ::= for LPAREN Modifiers"); }  //$NON-NLS-1$
 		    consumeEnhancedForStatementHeaderInit(true);  
 			break;
  
-    case 622 : if (DEBUG) { System.out.println("EnhancedForStatementHeader ::=..."); }  //$NON-NLS-1$
+    case 594 : if (DEBUG) { System.out.println("EnhancedForStatementHeader ::=..."); }  //$NON-NLS-1$
 		    consumeEnhancedForStatementHeader();  
 			break;
  
-    case 623 : if (DEBUG) { System.out.println("SingleStaticImportDeclaration ::=..."); }  //$NON-NLS-1$
+    case 595 : if (DEBUG) { System.out.println("SingleStaticImportDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeImportDeclaration();  
 			break;
  
-    case 624 : if (DEBUG) { System.out.println("SingleStaticImportDeclarationName ::= import static Name"); }  //$NON-NLS-1$
+    case 596 : if (DEBUG) { System.out.println("SingleStaticImportDeclarationName ::= import static Name"); }  //$NON-NLS-1$
 		    consumeSingleStaticImportDeclarationName();  
 			break;
  
-    case 625 : if (DEBUG) { System.out.println("StaticImportOnDemandDeclaration ::=..."); }  //$NON-NLS-1$
+    case 597 : if (DEBUG) { System.out.println("StaticImportOnDemandDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeImportDeclaration();  
 			break;
  
-    case 626 : if (DEBUG) { System.out.println("StaticImportOnDemandDeclarationName ::= import static..."); }  //$NON-NLS-1$
+    case 598 : if (DEBUG) { System.out.println("StaticImportOnDemandDeclarationName ::= import static..."); }  //$NON-NLS-1$
 		    consumeStaticImportOnDemandDeclarationName();  
 			break;
  
-    case 627 : if (DEBUG) { System.out.println("TypeArguments ::= LESS TypeArgumentList1"); }  //$NON-NLS-1$
+    case 599 : if (DEBUG) { System.out.println("TypeArguments ::= LESS TypeArgumentList1"); }  //$NON-NLS-1$
 		    consumeTypeArguments();  
 			break;
  
-    case 628 : if (DEBUG) { System.out.println("OnlyTypeArguments ::= LESS TypeArgumentList1"); }  //$NON-NLS-1$
+    case 600 : if (DEBUG) { System.out.println("OnlyTypeArguments ::= LESS TypeArgumentList1"); }  //$NON-NLS-1$
 		    consumeOnlyTypeArguments();  
 			break;
  
-    case 630 : if (DEBUG) { System.out.println("TypeArgumentList1 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
+    case 602 : if (DEBUG) { System.out.println("TypeArgumentList1 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
 		    consumeTypeArgumentList1();  
 			break;
  
-    case 632 : if (DEBUG) { System.out.println("TypeArgumentList ::= TypeArgumentList COMMA TypeArgument"); }  //$NON-NLS-1$
+    case 604 : if (DEBUG) { System.out.println("TypeArgumentList ::= TypeArgumentList COMMA TypeArgument"); }  //$NON-NLS-1$
 		    consumeTypeArgumentList();  
 			break;
  
-    case 633 : if (DEBUG) { System.out.println("TypeArgument ::= ReferenceType"); }  //$NON-NLS-1$
+    case 605 : if (DEBUG) { System.out.println("TypeArgument ::= ReferenceType"); }  //$NON-NLS-1$
 		    consumeTypeArgument();  
 			break;
  
-    case 637 : if (DEBUG) { System.out.println("ReferenceType1 ::= ReferenceType GREATER"); }  //$NON-NLS-1$
+    case 609 : if (DEBUG) { System.out.println("ReferenceType1 ::= ReferenceType GREATER"); }  //$NON-NLS-1$
 		    consumeReferenceType1();  
 			break;
  
-    case 638 : if (DEBUG) { System.out.println("ReferenceType1 ::= ClassOrInterface LESS..."); }  //$NON-NLS-1$
+    case 610 : if (DEBUG) { System.out.println("ReferenceType1 ::= ClassOrInterface LESS..."); }  //$NON-NLS-1$
 		    consumeTypeArgumentReferenceType1();  
 			break;
  
-    case 639 : if (DEBUG) { System.out.println("ReferenceType1 ::= Modifiers ClassOrInterface LESS..."); }  //$NON-NLS-1$
-		    consumeTypeArgumentReferenceType1WithTypeAnnotations();  
-			break;
- 
-    case 641 : if (DEBUG) { System.out.println("TypeArgumentList2 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
+    case 612 : if (DEBUG) { System.out.println("TypeArgumentList2 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
 		    consumeTypeArgumentList2();  
 			break;
  
-    case 644 : if (DEBUG) { System.out.println("ReferenceType2 ::= ReferenceType RIGHT_SHIFT"); }  //$NON-NLS-1$
+    case 615 : if (DEBUG) { System.out.println("ReferenceType2 ::= ReferenceType RIGHT_SHIFT"); }  //$NON-NLS-1$
 		    consumeReferenceType2();  
 			break;
  
-    case 645 : if (DEBUG) { System.out.println("ReferenceType2 ::= ClassOrInterface LESS..."); }  //$NON-NLS-1$
+    case 616 : if (DEBUG) { System.out.println("ReferenceType2 ::= ClassOrInterface LESS..."); }  //$NON-NLS-1$
 		    consumeTypeArgumentReferenceType2();  
 			break;
  
-    case 646 : if (DEBUG) { System.out.println("ReferenceType2 ::= Modifiers ClassOrInterface LESS..."); }  //$NON-NLS-1$
-		    consumeTypeArgumentReferenceType2WithTypeAnnotations();  
-			break;
- 
-    case 648 : if (DEBUG) { System.out.println("TypeArgumentList3 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
+    case 618 : if (DEBUG) { System.out.println("TypeArgumentList3 ::= TypeArgumentList COMMA..."); }  //$NON-NLS-1$
 		    consumeTypeArgumentList3();  
 			break;
  
-    case 651 : if (DEBUG) { System.out.println("ReferenceType3 ::= ReferenceType UNSIGNED_RIGHT_SHIFT"); }  //$NON-NLS-1$
+    case 621 : if (DEBUG) { System.out.println("ReferenceType3 ::= ReferenceType UNSIGNED_RIGHT_SHIFT"); }  //$NON-NLS-1$
 		    consumeReferenceType3();  
 			break;
  
-    case 652 : if (DEBUG) { System.out.println("Wildcard ::= QUESTION"); }  //$NON-NLS-1$
+    case 622 : if (DEBUG) { System.out.println("Wildcard ::= TypeAnnotationsopt QUESTION"); }  //$NON-NLS-1$
 		    consumeWildcard();  
 			break;
  
-    case 653 : if (DEBUG) { System.out.println("Wildcard ::= QUESTION WildcardBounds"); }  //$NON-NLS-1$
+    case 623 : if (DEBUG) { System.out.println("Wildcard ::= TypeAnnotationsopt QUESTION WildcardBounds"); }  //$NON-NLS-1$
 		    consumeWildcardWithBounds();  
 			break;
  
-    case 654 : if (DEBUG) { System.out.println("WildcardBounds ::= extends ReferenceType"); }  //$NON-NLS-1$
+    case 624 : if (DEBUG) { System.out.println("WildcardBounds ::= extends ReferenceType"); }  //$NON-NLS-1$
 		    consumeWildcardBoundsExtends();  
 			break;
  
-    case 655 : if (DEBUG) { System.out.println("WildcardBounds ::= super ReferenceType"); }  //$NON-NLS-1$
+    case 625 : if (DEBUG) { System.out.println("WildcardBounds ::= super ReferenceType"); }  //$NON-NLS-1$
 		    consumeWildcardBoundsSuper();  
 			break;
  
-    case 656 : if (DEBUG) { System.out.println("Wildcard1 ::= QUESTION GREATER"); }  //$NON-NLS-1$
+    case 626 : if (DEBUG) { System.out.println("Wildcard1 ::= TypeAnnotationsopt QUESTION GREATER"); }  //$NON-NLS-1$
 		    consumeWildcard1();  
 			break;
  
-    case 657 : if (DEBUG) { System.out.println("Wildcard1 ::= QUESTION WildcardBounds1"); }  //$NON-NLS-1$
+    case 627 : if (DEBUG) { System.out.println("Wildcard1 ::= TypeAnnotationsopt QUESTION..."); }  //$NON-NLS-1$
 		    consumeWildcard1WithBounds();  
 			break;
  
-    case 658 : if (DEBUG) { System.out.println("WildcardBounds1 ::= extends ReferenceType1"); }  //$NON-NLS-1$
+    case 628 : if (DEBUG) { System.out.println("WildcardBounds1 ::= extends ReferenceType1"); }  //$NON-NLS-1$
 		    consumeWildcardBounds1Extends();  
 			break;
  
-    case 659 : if (DEBUG) { System.out.println("WildcardBounds1 ::= super ReferenceType1"); }  //$NON-NLS-1$
+    case 629 : if (DEBUG) { System.out.println("WildcardBounds1 ::= super ReferenceType1"); }  //$NON-NLS-1$
 		    consumeWildcardBounds1Super();  
 			break;
  
-    case 660 : if (DEBUG) { System.out.println("Wildcard2 ::= QUESTION RIGHT_SHIFT"); }  //$NON-NLS-1$
+    case 630 : if (DEBUG) { System.out.println("Wildcard2 ::= TypeAnnotationsopt QUESTION RIGHT_SHIFT"); }  //$NON-NLS-1$
 		    consumeWildcard2();  
 			break;
  
-    case 661 : if (DEBUG) { System.out.println("Wildcard2 ::= QUESTION WildcardBounds2"); }  //$NON-NLS-1$
+    case 631 : if (DEBUG) { System.out.println("Wildcard2 ::= TypeAnnotationsopt QUESTION..."); }  //$NON-NLS-1$
 		    consumeWildcard2WithBounds();  
 			break;
  
-    case 662 : if (DEBUG) { System.out.println("WildcardBounds2 ::= extends ReferenceType2"); }  //$NON-NLS-1$
+    case 632 : if (DEBUG) { System.out.println("WildcardBounds2 ::= extends ReferenceType2"); }  //$NON-NLS-1$
 		    consumeWildcardBounds2Extends();  
 			break;
  
-    case 663 : if (DEBUG) { System.out.println("WildcardBounds2 ::= super ReferenceType2"); }  //$NON-NLS-1$
+    case 633 : if (DEBUG) { System.out.println("WildcardBounds2 ::= super ReferenceType2"); }  //$NON-NLS-1$
 		    consumeWildcardBounds2Super();  
 			break;
  
-    case 664 : if (DEBUG) { System.out.println("Wildcard3 ::= QUESTION UNSIGNED_RIGHT_SHIFT"); }  //$NON-NLS-1$
+    case 634 : if (DEBUG) { System.out.println("Wildcard3 ::= TypeAnnotationsopt QUESTION..."); }  //$NON-NLS-1$
 		    consumeWildcard3();  
 			break;
  
-    case 665 : if (DEBUG) { System.out.println("Wildcard3 ::= QUESTION WildcardBounds3"); }  //$NON-NLS-1$
+    case 635 : if (DEBUG) { System.out.println("Wildcard3 ::= TypeAnnotationsopt QUESTION..."); }  //$NON-NLS-1$
 		    consumeWildcard3WithBounds();  
 			break;
  
-    case 666 : if (DEBUG) { System.out.println("WildcardBounds3 ::= extends ReferenceType3"); }  //$NON-NLS-1$
+    case 636 : if (DEBUG) { System.out.println("WildcardBounds3 ::= extends ReferenceType3"); }  //$NON-NLS-1$
 		    consumeWildcardBounds3Extends();  
 			break;
  
-    case 667 : if (DEBUG) { System.out.println("WildcardBounds3 ::= super ReferenceType3"); }  //$NON-NLS-1$
+    case 637 : if (DEBUG) { System.out.println("WildcardBounds3 ::= super ReferenceType3"); }  //$NON-NLS-1$
 		    consumeWildcardBounds3Super();  
 			break;
  
-    case 668 : if (DEBUG) { System.out.println("PushZeroTypeAnnotations ::="); }  //$NON-NLS-1$
-		    consumeZeroTypeAnnotations(true);  
-			break;
- 
-    case 669 : if (DEBUG) { System.out.println("TypeParameterHeader ::= PushZeroTypeAnnotations..."); }  //$NON-NLS-1$
+    case 638 : if (DEBUG) { System.out.println("TypeParameterHeader ::= TypeAnnotationsopt Identifier"); }  //$NON-NLS-1$
 		    consumeTypeParameterHeader();  
 			break;
  
-    case 670 : if (DEBUG) { System.out.println("TypeParameterHeader ::= TypeAnnotations Identifier"); }  //$NON-NLS-1$
-		    consumeTypeParameterHeader();  
-			break;
- 
-    case 671 : if (DEBUG) { System.out.println("TypeParameters ::= LESS TypeParameterList1"); }  //$NON-NLS-1$
+    case 639 : if (DEBUG) { System.out.println("TypeParameters ::= LESS TypeParameterList1"); }  //$NON-NLS-1$
 		    consumeTypeParameters();  
 			break;
  
-    case 673 : if (DEBUG) { System.out.println("TypeParameterList ::= TypeParameterList COMMA..."); }  //$NON-NLS-1$
+    case 641 : if (DEBUG) { System.out.println("TypeParameterList ::= TypeParameterList COMMA..."); }  //$NON-NLS-1$
 		    consumeTypeParameterList();  
 			break;
  
-    case 675 : if (DEBUG) { System.out.println("TypeParameter ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
+    case 643 : if (DEBUG) { System.out.println("TypeParameter ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
 		    consumeTypeParameterWithExtends();  
 			break;
  
-    case 676 : if (DEBUG) { System.out.println("TypeParameter ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
+    case 644 : if (DEBUG) { System.out.println("TypeParameter ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
 		    consumeTypeParameterWithExtendsAndBounds();  
 			break;
  
-    case 678 : if (DEBUG) { System.out.println("AdditionalBoundList ::= AdditionalBoundList..."); }  //$NON-NLS-1$
+    case 646 : if (DEBUG) { System.out.println("AdditionalBoundList ::= AdditionalBoundList..."); }  //$NON-NLS-1$
 		    consumeAdditionalBoundList();  
 			break;
  
-    case 679 : if (DEBUG) { System.out.println("AdditionalBound ::= AND ReferenceType"); }  //$NON-NLS-1$
+    case 647 : if (DEBUG) { System.out.println("AdditionalBound ::= AND ReferenceType"); }  //$NON-NLS-1$
 		    consumeAdditionalBound();  
 			break;
  
-    case 681 : if (DEBUG) { System.out.println("TypeParameterList1 ::= TypeParameterList COMMA..."); }  //$NON-NLS-1$
+    case 649 : if (DEBUG) { System.out.println("TypeParameterList1 ::= TypeParameterList COMMA..."); }  //$NON-NLS-1$
 		    consumeTypeParameterList1();  
 			break;
  
-    case 682 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader GREATER"); }  //$NON-NLS-1$
+    case 650 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader GREATER"); }  //$NON-NLS-1$
 		    consumeTypeParameter1();  
 			break;
  
-    case 683 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
+    case 651 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
 		    consumeTypeParameter1WithExtends();  
 			break;
  
-    case 684 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
+    case 652 : if (DEBUG) { System.out.println("TypeParameter1 ::= TypeParameterHeader extends..."); }  //$NON-NLS-1$
 		    consumeTypeParameter1WithExtendsAndBounds();  
 			break;
  
-    case 686 : if (DEBUG) { System.out.println("AdditionalBoundList1 ::= AdditionalBoundList..."); }  //$NON-NLS-1$
+    case 654 : if (DEBUG) { System.out.println("AdditionalBoundList1 ::= AdditionalBoundList..."); }  //$NON-NLS-1$
 		    consumeAdditionalBoundList1();  
 			break;
  
-    case 687 : if (DEBUG) { System.out.println("AdditionalBound1 ::= AND ReferenceType1"); }  //$NON-NLS-1$
+    case 655 : if (DEBUG) { System.out.println("AdditionalBound1 ::= AND ReferenceType1"); }  //$NON-NLS-1$
 		    consumeAdditionalBound1();  
 			break;
  
-    case 693 : if (DEBUG) { System.out.println("UnaryExpression_NotName ::= PLUS PushPosition..."); }  //$NON-NLS-1$
+    case 661 : if (DEBUG) { System.out.println("UnaryExpression_NotName ::= PLUS PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.PLUS);  
 			break;
  
-    case 694 : if (DEBUG) { System.out.println("UnaryExpression_NotName ::= MINUS PushPosition..."); }  //$NON-NLS-1$
+    case 662 : if (DEBUG) { System.out.println("UnaryExpression_NotName ::= MINUS PushPosition..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.MINUS);  
 			break;
  
-    case 697 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus_NotName ::= TWIDDLE..."); }  //$NON-NLS-1$
+    case 665 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus_NotName ::= TWIDDLE..."); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.TWIDDLE);  
 			break;
  
-    case 698 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus_NotName ::= NOT PushPosition"); }  //$NON-NLS-1$
+    case 666 : if (DEBUG) { System.out.println("UnaryExpressionNotPlusMinus_NotName ::= NOT PushPosition"); }  //$NON-NLS-1$
 		    consumeUnaryExpression(OperatorIds.NOT);  
 			break;
  
-    case 701 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 669 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.MULTIPLY);  
 			break;
  
-    case 702 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name MULTIPLY..."); }  //$NON-NLS-1$
+    case 670 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name MULTIPLY..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.MULTIPLY);  
 			break;
  
-    case 703 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 671 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.DIVIDE);  
 			break;
  
-    case 704 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name DIVIDE..."); }  //$NON-NLS-1$
+    case 672 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name DIVIDE..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.DIVIDE);  
 			break;
  
-    case 705 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 673 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.REMAINDER);  
 			break;
  
-    case 706 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name REMAINDER..."); }  //$NON-NLS-1$
+    case 674 : if (DEBUG) { System.out.println("MultiplicativeExpression_NotName ::= Name REMAINDER..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.REMAINDER);  
 			break;
  
-    case 708 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 676 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.PLUS);  
 			break;
  
-    case 709 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::= Name PLUS..."); }  //$NON-NLS-1$
+    case 677 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::= Name PLUS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.PLUS);  
 			break;
  
-    case 710 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 678 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.MINUS);  
 			break;
  
-    case 711 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::= Name MINUS..."); }  //$NON-NLS-1$
+    case 679 : if (DEBUG) { System.out.println("AdditiveExpression_NotName ::= Name MINUS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.MINUS);  
 			break;
  
-    case 713 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
+    case 681 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LEFT_SHIFT);  
 			break;
  
-    case 714 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name LEFT_SHIFT..."); }  //$NON-NLS-1$
+    case 682 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name LEFT_SHIFT..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.LEFT_SHIFT);  
 			break;
  
-    case 715 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
+    case 683 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.RIGHT_SHIFT);  
 			break;
  
-    case 716 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name RIGHT_SHIFT..."); }  //$NON-NLS-1$
+    case 684 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name RIGHT_SHIFT..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.RIGHT_SHIFT);  
 			break;
  
-    case 717 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
+    case 685 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= ShiftExpression_NotName..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.UNSIGNED_RIGHT_SHIFT);  
 			break;
  
-    case 718 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name UNSIGNED_RIGHT_SHIFT..."); }  //$NON-NLS-1$
+    case 686 : if (DEBUG) { System.out.println("ShiftExpression_NotName ::= Name UNSIGNED_RIGHT_SHIFT..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.UNSIGNED_RIGHT_SHIFT);  
 			break;
  
-    case 720 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= ShiftExpression_NotName"); }  //$NON-NLS-1$
+    case 688 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= ShiftExpression_NotName"); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LESS);  
 			break;
  
-    case 721 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name LESS..."); }  //$NON-NLS-1$
+    case 689 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name LESS..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.LESS);  
 			break;
  
-    case 722 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= ShiftExpression_NotName"); }  //$NON-NLS-1$
+    case 690 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= ShiftExpression_NotName"); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.GREATER);  
 			break;
  
-    case 723 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name GREATER..."); }  //$NON-NLS-1$
+    case 691 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name GREATER..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.GREATER);  
 			break;
  
-    case 724 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 692 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.LESS_EQUAL);  
 			break;
  
-    case 725 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name LESS_EQUAL..."); }  //$NON-NLS-1$
+    case 693 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name LESS_EQUAL..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.LESS_EQUAL);  
 			break;
  
-    case 726 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 694 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.GREATER_EQUAL);  
 			break;
  
-    case 727 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name GREATER_EQUAL..."); }  //$NON-NLS-1$
+    case 695 : if (DEBUG) { System.out.println("RelationalExpression_NotName ::= Name GREATER_EQUAL..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.GREATER_EQUAL);  
 			break;
  
-    case 729 : if (DEBUG) { System.out.println("InstanceofExpression_NotName ::= Name instanceof..."); }  //$NON-NLS-1$
+    case 697 : if (DEBUG) { System.out.println("InstanceofExpression_NotName ::= Name instanceof..."); }  //$NON-NLS-1$
 		    consumeInstanceOfExpressionWithName();  
 			break;
  
-    case 730 : if (DEBUG) { System.out.println("InstanceofExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 698 : if (DEBUG) { System.out.println("InstanceofExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeInstanceOfExpression();  
 			break;
  
-    case 732 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 700 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeEqualityExpression(OperatorIds.EQUAL_EQUAL);  
 			break;
  
-    case 733 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::= Name EQUAL_EQUAL..."); }  //$NON-NLS-1$
+    case 701 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::= Name EQUAL_EQUAL..."); }  //$NON-NLS-1$
 		    consumeEqualityExpressionWithName(OperatorIds.EQUAL_EQUAL);  
 			break;
  
-    case 734 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 702 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeEqualityExpression(OperatorIds.NOT_EQUAL);  
 			break;
  
-    case 735 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::= Name NOT_EQUAL..."); }  //$NON-NLS-1$
+    case 703 : if (DEBUG) { System.out.println("EqualityExpression_NotName ::= Name NOT_EQUAL..."); }  //$NON-NLS-1$
 		    consumeEqualityExpressionWithName(OperatorIds.NOT_EQUAL);  
 			break;
  
-    case 737 : if (DEBUG) { System.out.println("AndExpression_NotName ::= AndExpression_NotName AND..."); }  //$NON-NLS-1$
+    case 705 : if (DEBUG) { System.out.println("AndExpression_NotName ::= AndExpression_NotName AND..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.AND);  
 			break;
  
-    case 738 : if (DEBUG) { System.out.println("AndExpression_NotName ::= Name AND EqualityExpression"); }  //$NON-NLS-1$
+    case 706 : if (DEBUG) { System.out.println("AndExpression_NotName ::= Name AND EqualityExpression"); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.AND);  
 			break;
  
-    case 740 : if (DEBUG) { System.out.println("ExclusiveOrExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 708 : if (DEBUG) { System.out.println("ExclusiveOrExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.XOR);  
 			break;
  
-    case 741 : if (DEBUG) { System.out.println("ExclusiveOrExpression_NotName ::= Name XOR AndExpression"); }  //$NON-NLS-1$
+    case 709 : if (DEBUG) { System.out.println("ExclusiveOrExpression_NotName ::= Name XOR AndExpression"); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.XOR);  
 			break;
  
-    case 743 : if (DEBUG) { System.out.println("InclusiveOrExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 711 : if (DEBUG) { System.out.println("InclusiveOrExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.OR);  
 			break;
  
-    case 744 : if (DEBUG) { System.out.println("InclusiveOrExpression_NotName ::= Name OR..."); }  //$NON-NLS-1$
+    case 712 : if (DEBUG) { System.out.println("InclusiveOrExpression_NotName ::= Name OR..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.OR);  
 			break;
  
-    case 746 : if (DEBUG) { System.out.println("ConditionalAndExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 714 : if (DEBUG) { System.out.println("ConditionalAndExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.AND_AND);  
 			break;
  
-    case 747 : if (DEBUG) { System.out.println("ConditionalAndExpression_NotName ::= Name AND_AND..."); }  //$NON-NLS-1$
+    case 715 : if (DEBUG) { System.out.println("ConditionalAndExpression_NotName ::= Name AND_AND..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.AND_AND);  
 			break;
  
-    case 749 : if (DEBUG) { System.out.println("ConditionalOrExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 717 : if (DEBUG) { System.out.println("ConditionalOrExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeBinaryExpression(OperatorIds.OR_OR);  
 			break;
  
-    case 750 : if (DEBUG) { System.out.println("ConditionalOrExpression_NotName ::= Name OR_OR..."); }  //$NON-NLS-1$
+    case 718 : if (DEBUG) { System.out.println("ConditionalOrExpression_NotName ::= Name OR_OR..."); }  //$NON-NLS-1$
 		    consumeBinaryExpressionWithName(OperatorIds.OR_OR);  
 			break;
  
-    case 752 : if (DEBUG) { System.out.println("ConditionalExpression_NotName ::=..."); }  //$NON-NLS-1$
+    case 720 : if (DEBUG) { System.out.println("ConditionalExpression_NotName ::=..."); }  //$NON-NLS-1$
 		    consumeConditionalExpression(OperatorIds.QUESTIONCOLON) ;  
 			break;
  
-    case 753 : if (DEBUG) { System.out.println("ConditionalExpression_NotName ::= Name QUESTION..."); }  //$NON-NLS-1$
+    case 721 : if (DEBUG) { System.out.println("ConditionalExpression_NotName ::= Name QUESTION..."); }  //$NON-NLS-1$
 		    consumeConditionalExpressionWithName(OperatorIds.QUESTIONCOLON) ;  
 			break;
  
-    case 757 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= Modifiers AT..."); }  //$NON-NLS-1$
+    case 725 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= Modifiers AT..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclarationHeaderName() ;  
 			break;
  
-    case 758 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= Modifiers AT..."); }  //$NON-NLS-1$
+    case 726 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= Modifiers AT..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclarationHeaderNameWithTypeParameters() ;  
 			break;
  
-    case 759 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= AT..."); }  //$NON-NLS-1$
+    case 727 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= AT..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclarationHeaderNameWithTypeParameters() ;  
 			break;
  
-    case 760 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= AT..."); }  //$NON-NLS-1$
+    case 728 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeaderName ::= AT..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclarationHeaderName() ;  
 			break;
  
-    case 761 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeader ::=..."); }  //$NON-NLS-1$
+    case 729 : if (DEBUG) { System.out.println("AnnotationTypeDeclarationHeader ::=..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclarationHeader() ;  
 			break;
  
-    case 762 : if (DEBUG) { System.out.println("AnnotationTypeDeclaration ::=..."); }  //$NON-NLS-1$
+    case 730 : if (DEBUG) { System.out.println("AnnotationTypeDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeDeclaration() ;  
 			break;
  
-    case 764 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarationsopt ::="); }  //$NON-NLS-1$
+    case 732 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarationsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyAnnotationTypeMemberDeclarationsopt() ;  
 			break;
  
-    case 765 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
+    case 733 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarationsopt ::= NestedType..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeMemberDeclarationsopt() ;  
 			break;
  
-    case 767 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarations ::=..."); }  //$NON-NLS-1$
+    case 735 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclarations ::=..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeMemberDeclarations() ;  
 			break;
  
-    case 768 : if (DEBUG) { System.out.println("AnnotationMethodHeaderName ::= Modifiersopt..."); }  //$NON-NLS-1$
+    case 736 : if (DEBUG) { System.out.println("AnnotationMethodHeaderName ::= Modifiersopt..."); }  //$NON-NLS-1$
 		    consumeMethodHeaderNameWithTypeParameters(true);  
 			break;
  
-    case 769 : if (DEBUG) { System.out.println("AnnotationMethodHeaderName ::= Modifiersopt Type0..."); }  //$NON-NLS-1$
+    case 737 : if (DEBUG) { System.out.println("AnnotationMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeMethodHeaderName(true);  
 			break;
  
-    case 770 : if (DEBUG) { System.out.println("AnnotationMethodHeaderDefaultValueopt ::="); }  //$NON-NLS-1$
+    case 738 : if (DEBUG) { System.out.println("AnnotationMethodHeaderDefaultValueopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyMethodHeaderDefaultValue() ;  
 			break;
  
-    case 771 : if (DEBUG) { System.out.println("AnnotationMethodHeaderDefaultValueopt ::= DefaultValue"); }  //$NON-NLS-1$
+    case 739 : if (DEBUG) { System.out.println("AnnotationMethodHeaderDefaultValueopt ::= DefaultValue"); }  //$NON-NLS-1$
 		    consumeMethodHeaderDefaultValue();  
 			break;
  
-    case 772 : if (DEBUG) { System.out.println("AnnotationMethodHeader ::= AnnotationMethodHeaderName..."); }  //$NON-NLS-1$
+    case 740 : if (DEBUG) { System.out.println("AnnotationMethodHeader ::= AnnotationMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
-    case 773 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclaration ::=..."); }  //$NON-NLS-1$
+    case 741 : if (DEBUG) { System.out.println("AnnotationTypeMemberDeclaration ::=..."); }  //$NON-NLS-1$
 		    consumeAnnotationTypeMemberDeclaration() ;  
 			break;
  
-    case 781 : if (DEBUG) { System.out.println("AnnotationName ::= AT Name"); }  //$NON-NLS-1$
+    case 749 : if (DEBUG) { System.out.println("AnnotationName ::= AT UnannotatableName"); }  //$NON-NLS-1$
 		    consumeAnnotationName() ;  
 			break;
  
-    case 782 : if (DEBUG) { System.out.println("NormalAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
-		    consumeNormalAnnotation() ;  
+    case 750 : if (DEBUG) { System.out.println("NormalAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
+		    consumeNormalAnnotation(false) ;  
 			break;
  
-    case 783 : if (DEBUG) { System.out.println("MemberValuePairsopt ::="); }  //$NON-NLS-1$
+    case 751 : if (DEBUG) { System.out.println("MemberValuePairsopt ::="); }  //$NON-NLS-1$
 		    consumeEmptyMemberValuePairsopt() ;  
 			break;
  
-    case 786 : if (DEBUG) { System.out.println("MemberValuePairs ::= MemberValuePairs COMMA..."); }  //$NON-NLS-1$
+    case 754 : if (DEBUG) { System.out.println("MemberValuePairs ::= MemberValuePairs COMMA..."); }  //$NON-NLS-1$
 		    consumeMemberValuePairs() ;  
 			break;
  
-    case 787 : if (DEBUG) { System.out.println("MemberValuePair ::= SimpleName EQUAL EnterMemberValue..."); }  //$NON-NLS-1$
+    case 755 : if (DEBUG) { System.out.println("MemberValuePair ::= SimpleName EQUAL EnterMemberValue..."); }  //$NON-NLS-1$
 		    consumeMemberValuePair() ;  
 			break;
  
-    case 788 : if (DEBUG) { System.out.println("EnterMemberValue ::="); }  //$NON-NLS-1$
+    case 756 : if (DEBUG) { System.out.println("EnterMemberValue ::="); }  //$NON-NLS-1$
 		    consumeEnterMemberValue() ;  
 			break;
  
-    case 789 : if (DEBUG) { System.out.println("ExitMemberValue ::="); }  //$NON-NLS-1$
+    case 757 : if (DEBUG) { System.out.println("ExitMemberValue ::="); }  //$NON-NLS-1$
 		    consumeExitMemberValue() ;  
 			break;
  
-    case 791 : if (DEBUG) { System.out.println("MemberValue ::= Name"); }  //$NON-NLS-1$
+    case 759 : if (DEBUG) { System.out.println("MemberValue ::= Name"); }  //$NON-NLS-1$
 		    consumeMemberValueAsName() ;  
 			break;
  
-    case 794 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
+    case 762 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
 		    consumeMemberValueArrayInitializer() ;  
 			break;
  
-    case 795 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
+    case 763 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
 		    consumeMemberValueArrayInitializer() ;  
 			break;
  
-    case 796 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
+    case 764 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
 		    consumeEmptyMemberValueArrayInitializer() ;  
 			break;
  
-    case 797 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
+    case 765 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::=..."); }  //$NON-NLS-1$
 		    consumeEmptyMemberValueArrayInitializer() ;  
 			break;
  
-    case 798 : if (DEBUG) { System.out.println("EnterMemberValueArrayInitializer ::="); }  //$NON-NLS-1$
+    case 766 : if (DEBUG) { System.out.println("EnterMemberValueArrayInitializer ::="); }  //$NON-NLS-1$
 		    consumeEnterMemberValueArrayInitializer() ;  
 			break;
  
-    case 800 : if (DEBUG) { System.out.println("MemberValues ::= MemberValues COMMA MemberValue"); }  //$NON-NLS-1$
+    case 768 : if (DEBUG) { System.out.println("MemberValues ::= MemberValues COMMA MemberValue"); }  //$NON-NLS-1$
 		    consumeMemberValues() ;  
 			break;
  
-    case 801 : if (DEBUG) { System.out.println("MarkerAnnotation ::= AnnotationName"); }  //$NON-NLS-1$
-		    consumeMarkerAnnotation() ;  
+    case 769 : if (DEBUG) { System.out.println("MarkerAnnotation ::= AnnotationName"); }  //$NON-NLS-1$
+		    consumeMarkerAnnotation(false) ;  
 			break;
  
-    case 802 : if (DEBUG) { System.out.println("SingleMemberAnnotationMemberValue ::= MemberValue"); }  //$NON-NLS-1$
+    case 770 : if (DEBUG) { System.out.println("SingleMemberAnnotationMemberValue ::= MemberValue"); }  //$NON-NLS-1$
 		    consumeSingleMemberAnnotationMemberValue() ;  
 			break;
  
-    case 803 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
-		    consumeSingleMemberAnnotation() ;  
+    case 771 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
+		    consumeSingleMemberAnnotation(false) ;  
 			break;
  
-    case 804 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
+    case 772 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderNameWithTypeParameters();  
 			break;
  
-    case 805 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type0..."); }  //$NON-NLS-1$
+    case 773 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderName();  
 			break;
  
-    case 806 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 774 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
-    case 807 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 775 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
@@ -8029,7 +7661,7 @@ protected void consumeExplicitThisParameter(boolean isQualified) {
 
 	NameReference qualifyingNameReference = null;
 	if (isQualified) {
-		qualifyingNameReference = getUnspecifiedReference();
+		qualifyingNameReference = getUnspecifiedReference(false); // By construction the qualified name is unannotated here, so we should not meddle with the type annotation stack
 	}
 	pushOnExpressionStack(qualifyingNameReference);
 
@@ -8178,11 +7810,9 @@ protected void consumeEmptyTypeArguments() {
 }
 protected void consumeReferenceExpressionTypeForm(boolean isPrimitive, boolean isArray) {
 	
-	// ReferenceExpression ::= PrimitiveType Dims PushModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-	// ReferenceExpression ::= Modifiers PrimitiveType Dims PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-	// ReferenceExpression ::= Name Dims PushModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-	// ReferenceExpression ::= Modifiers Name Dims PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-	// ReferenceExpression ::= Modifiers Name PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
+	// ReferenceExpression ::= PrimitiveType Dims '::' NonWildTypeArgumentsopt IdentifierOrNew
+	// ReferenceExpression ::= Name Dims '::' NonWildTypeArgumentsopt IdentifierOrNew
+	// ReferenceExpression ::= Name '::' NonWildTypeArgumentsopt IdentifierOrNew
 
 	ReferenceExpression rexp;
 	TypeReference type = null;
@@ -8194,7 +7824,8 @@ protected void consumeReferenceExpressionTypeForm(boolean isPrimitive, boolean i
 	if (newForm) {
 		newEnd = this.intStack[this.intPtr--] + 3; // "new"
 	} else {
-		methodReference = (SingleNameReference) getUnspecifiedReferenceOptimized();
+		methodReference = new SingleNameReference(this.identifierStack[this.identifierPtr], this.identifierPositionStack[this.identifierPtr--]);
+		this.identifierLengthPtr--;
 	}
 	
 	int length = this.genericsLengthStack[this.genericsLengthPtr--];
@@ -8204,37 +7835,13 @@ protected void consumeReferenceExpressionTypeForm(boolean isPrimitive, boolean i
 		this.intPtr--;  // pop type arguments source start.
 	}
 	
-	int illegalModifiersSourceStart = this.intStack[this.intPtr--];
-	int illegalModifiers = this.intStack[this.intPtr--];
-	
 	if (!isPrimitive) { // handle type arguments
 		pushOnGenericsLengthStack(0);
 		pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
 	}
 
-	// Type Annotations are in the expression stack, so retrieve as unannotated type 
-	type = getUnannotatedTypeReference(isArray ? this.intStack[this.intPtr--] : 0);
-    // and attach the annotations now.
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		type.annotations = new Annotation[type.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				type.annotations[0] = new Annotation[length],
-				0,
-				length);
-		type.sourceStart = type.annotations[0][0].sourceStart;
-		type.bits |= ASTNode.HasTypeAnnotations;
-	}
-	if (illegalModifiersSourceStart >= 0 && illegalModifiersSourceStart < type.sourceStart) {
-		type.sourceStart = illegalModifiersSourceStart;
-	}
+	type = getTypeReference(isArray ? this.intStack[this.intPtr--] : 0);
 
-	if (illegalModifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(type);
-	}
-	resetModifiers();
-	
 	if (newForm) {
 		rexp = new ReferenceExpression(type, typeArguments, newEnd);
 	} else {
@@ -8258,7 +7865,8 @@ protected void consumeReferenceExpressionNameForm() {
 	if (newForm) {
 		newEnd = this.intStack[this.intPtr--] + 3; // "new"
 	} else {
-		methodReference = (SingleNameReference) getUnspecifiedReferenceOptimized();
+		methodReference = new SingleNameReference(this.identifierStack[this.identifierPtr], this.identifierPositionStack[this.identifierPtr--]);
+		this.identifierLengthPtr--;
 	}
 	
 	int length = this.genericsLengthStack[this.genericsLengthPtr--];
@@ -8287,7 +7895,8 @@ protected void consumeReferenceExpressionPrimaryForm() {
 	TypeReference [] typeArguments = null;
 	SingleNameReference methodReference;
 	
-	methodReference = (SingleNameReference) getUnspecifiedReferenceOptimized();
+	methodReference = new SingleNameReference(this.identifierStack[this.identifierPtr], this.identifierPositionStack[this.identifierPtr--]);
+	this.identifierLengthPtr--;
 	int length = this.genericsLengthStack[this.genericsLengthPtr--];
 	if (length > 0) {
 		this.genericsPtr -= length;
@@ -8310,7 +7919,8 @@ protected void consumeReferenceExpressionSuperForm() {
 	TypeReference [] typeArguments = null;
 	SingleNameReference methodReference;
 	
-	methodReference = (SingleNameReference) getUnspecifiedReferenceOptimized();
+	methodReference = new SingleNameReference(this.identifierStack[this.identifierPtr], this.identifierPositionStack[this.identifierPtr--]);
+	this.identifierLengthPtr--;
 	int length = this.genericsLengthStack[this.genericsLengthPtr--];
 	if (length > 0) {
 		this.genericsPtr -= length;
@@ -8333,8 +7943,7 @@ protected void consumeReferenceExpressionTypeArgumentsAndTrunk(boolean qualified
 }
 protected void consumeReferenceExpressionGenericTypeForm() {
 
-	// ReferenceExpression ::= Name PushModifiers BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
-	// ReferenceExpression ::= Modifiers Name PushRealModifiers BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
+	// ReferenceExpression ::= Name BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
 	
 	ReferenceExpression rexp;
 	TypeReference type = null;
@@ -8346,7 +7955,8 @@ protected void consumeReferenceExpressionGenericTypeForm() {
 	if (newForm) {
 		newEnd = this.intStack[this.intPtr--] + 3; // "new"
 	} else {
-		methodReference = (SingleNameReference) getUnspecifiedReferenceOptimized();
+		methodReference = new SingleNameReference(this.identifierStack[this.identifierPtr], this.identifierPositionStack[this.identifierPtr--]);
+		this.identifierLengthPtr--;
 	}
 	
 	int length = this.genericsLengthStack[this.genericsLengthPtr--];
@@ -8359,44 +7969,19 @@ protected void consumeReferenceExpressionGenericTypeForm() {
 	int typeSourceEnd = this.intStack[this.intPtr--];
 	boolean qualified = this.intStack[this.intPtr--] != 0;
 	int dims = this.intStack[this.intPtr--];
-
 	if (qualified) {
-		TypeReference rightSide = getUnannotatedTypeReference(0); // until we add support for X. @Inner Y, by design the type after '.' is unannotated.
-		type = computeQualifiedGenericsFromRightSide(rightSide, dims);
+		Annotation [][] annotationsOnDimensions = dims == 0 ? null : getAnnotationsOnDimensions(dims);
+		TypeReference rightSide = getTypeReference(0);
+		type = computeQualifiedGenericsFromRightSide(rightSide, dims, annotationsOnDimensions);
 	} else {		
 		pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
-		type = getUnannotatedTypeReference(dims); // annotations attached below.
+		type = getTypeReference(dims);
 	}
 	this.intPtr--; // pop '<' position
-	int illegalModifiersSourceStart = this.intStack[this.intPtr--];
-	if (illegalModifiersSourceStart >= 0 && illegalModifiersSourceStart < type.sourceStart) {
-		type.sourceStart = illegalModifiersSourceStart;
-	}
 	type.sourceEnd = typeSourceEnd;
 	
 	rexp = newForm ? new ReferenceExpression(type, typeArguments, newEnd) : new ReferenceExpression(type, typeArguments, methodReference);
 
-	// Prefix annotations if any are on the expression stack, attach them now.
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		type.annotations = new Annotation[type.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				type.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int annotStart = type.annotations[0][0].sourceStart;
-		if (annotStart < type.sourceStart) {
-			type.sourceStart = annotStart;
-		}
-		type.bits |= ASTNode.HasTypeAnnotations;
-	}
-
-	int illegalModifiers = this.intStack[this.intPtr--];
-	if (illegalModifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(type);
-	}
-	resetModifiers();
 	pushOnExpressionStack(rexp);
 	if (!this.parsingJava8Plus) {
 		problemReporter().referenceExpressionsNotBelow18(rexp);
@@ -8416,7 +8001,7 @@ protected void consumeSimpleAssertStatement() {
 	this.expressionLengthPtr--;
 	pushOnAstStack(new AssertStatement(this.expressionStack[this.expressionPtr--], this.intStack[this.intPtr--]));
 }
-protected void consumeSingleMemberAnnotation() {
+protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
 	// SingleMemberAnnotation ::= '@' Name '(' MemberValue ')'
 	SingleMemberAnnotation singleMemberAnnotation = null;
 
@@ -8427,8 +8012,12 @@ protected void consumeSingleMemberAnnotation() {
 	singleMemberAnnotation.memberValue = this.expressionStack[this.expressionPtr--];
 	this.expressionLengthPtr--;
 	singleMemberAnnotation.declarationSourceEnd = this.rParenPos;
-	pushOnExpressionStack(singleMemberAnnotation);
-
+	
+	if (isTypeAnnotation) {
+		pushOnTypeAnnotationStack(singleMemberAnnotation);
+	} else {
+		pushOnExpressionStack(singleMemberAnnotation);
+	}
 
 	if(this.currentElement != null) {
 		annotationRecoveryCheckPoint(singleMemberAnnotation.sourceStart, singleMemberAnnotation.declarationSourceEnd);
@@ -9236,6 +8825,7 @@ protected void consumeToken(int type) {
 		case TokenNameLPAREN :
 			this.lParenPos = this.scanner.startPosition;
 			break;
+		case TokenNameAT308:
 		case TokenNameAT :
 			pushOnIntStack(this.scanner.startPosition);
 			break;
@@ -9324,67 +8914,11 @@ protected void consumeTypeArgumentReferenceType1() {
 	pushOnGenericsStack(getTypeReference(0));
 	this.intPtr--;
 }
-protected void consumeTypeArgumentReferenceType1WithTypeAnnotations() {
-	concatGenericsLists();
-	TypeReference typeReference = getUnannotatedTypeReference(0);
-	// copy from expression stack to type annotation stack
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	pushOnGenericsStack(typeReference);
-	// remove the 0 pushed by ZeroTypeAnnotation
-	this.typeAnnotationLengthPtr--;
-	this.intPtr--;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeTypeArgumentReferenceType2() {
 	concatGenericsLists();
 	pushOnGenericsStack(getTypeReference(0));
 	this.intPtr--;
 }
-protected void consumeTypeArgumentReferenceType2WithTypeAnnotations() {
-	concatGenericsLists();
-	TypeReference typeReference = getUnannotatedTypeReference(0);
-	// copy from expression stack to type annotation stack
-	int length;
-	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
-		typeReference.annotations = new Annotation[typeReference.getAnnotatableLevels()][];
-		System.arraycopy(
-				this.expressionStack,
-				(this.expressionPtr -= length) + 1,
-				typeReference.annotations[0] = new Annotation[length],
-				0,
-				length);
-		int typeReferenceSourceStart = typeReference.annotations[0][0].sourceStart;
-		if (this.modifiersSourceStart < typeReferenceSourceStart) {
-			typeReferenceSourceStart = this.modifiersSourceStart;
-		}
-		typeReference.bits |= ASTNode.HasTypeAnnotations;
-		typeReference.sourceStart = typeReferenceSourceStart;
-	}
-	pushOnGenericsStack(typeReference);
-	this.intPtr--;
-	if (this.modifiers != ClassFileConstants.AccDefault) {
-		problemReporter().invalidLocationForModifiers(typeReference);
-	}
-	resetModifiers();
-}
 protected void consumeTypeArguments() {
 	concatGenericsLists();
 	this.intPtr--;
@@ -9673,12 +9207,14 @@ protected void consumeWildcard() {
 	final Wildcard wildcard = new Wildcard(Wildcard.UNBOUND);
 	wildcard.sourceEnd = this.intStack[this.intPtr--];
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcard1() {
 	final Wildcard wildcard = new Wildcard(Wildcard.UNBOUND);
 	wildcard.sourceEnd = this.intStack[this.intPtr--];
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcard1WithBounds() {
@@ -9689,6 +9225,7 @@ protected void consumeWildcard2() {
 	final Wildcard wildcard = new Wildcard(Wildcard.UNBOUND);
 	wildcard.sourceEnd = this.intStack[this.intPtr--];
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcard2WithBounds() {
@@ -9699,6 +9236,7 @@ protected void consumeWildcard3() {
 	final Wildcard wildcard = new Wildcard(Wildcard.UNBOUND);
 	wildcard.sourceEnd = this.intStack[this.intPtr--];
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcard3WithBounds() {
@@ -9711,6 +9249,7 @@ protected void consumeWildcardBounds1Extends() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBounds1Super() {
@@ -9720,6 +9259,7 @@ protected void consumeWildcardBounds1Super() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBounds2Extends() {
@@ -9728,6 +9268,7 @@ protected void consumeWildcardBounds2Extends() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBounds2Super() {
@@ -9737,6 +9278,7 @@ protected void consumeWildcardBounds2Super() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBounds3Extends() {
@@ -9745,6 +9287,7 @@ protected void consumeWildcardBounds3Extends() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBounds3Super() {
@@ -9754,6 +9297,7 @@ protected void consumeWildcardBounds3Super() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	this.genericsStack[this.genericsPtr] = wildcard;
 }
 protected void consumeWildcardBoundsExtends() {
@@ -9762,6 +9306,7 @@ protected void consumeWildcardBoundsExtends() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcardBoundsSuper() {
@@ -9771,6 +9316,7 @@ protected void consumeWildcardBoundsSuper() {
 	wildcard.sourceEnd = wildcard.bound.sourceEnd;
 	this.intPtr--; // remove end position of the '?'
 	wildcard.sourceStart = this.intStack[this.intPtr--];
+	annotateTypeReference(wildcard);
 	pushOnGenericsStack(wildcard);
 }
 protected void consumeWildcardWithBounds() {
@@ -10308,13 +9854,11 @@ protected Expression getTypeReference(Expression exp) {
 	exp.bits |= Binding.TYPE;
 	return exp;
 }
-protected TypeReference getTypeReference(int dim) {
-	TypeReference ref = getUnannotatedTypeReference(dim);
+protected void annotateTypeReference(TypeReference ref) {
 	int length;
-	if (this.typeAnnotationLengthPtr >= 0
-			&& (length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-		//	if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-		ref.annotations = new Annotation[ref.getAnnotatableLevels()][];
+	if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+		if (ref.annotations == null)
+			ref.annotations = new Annotation[ref.getAnnotatableLevels()][];
 		System.arraycopy(
 				this.typeAnnotationStack,
 				(this.typeAnnotationPtr -= length) + 1,
@@ -10324,9 +9868,8 @@ protected TypeReference getTypeReference(int dim) {
 		ref.sourceStart = ref.annotations[0][0].sourceStart;
 		ref.bits |= ASTNode.HasTypeAnnotations;
 	}
-	return ref;
-	}
-protected TypeReference getUnannotatedTypeReference(int dim) {
+}
+protected TypeReference getTypeReference(int dim) {
 	/* build a Reference on a variable that may be qualified or not
 	 This variable is a type reference and dim will be its dimensions*/
 
@@ -10351,7 +9894,7 @@ protected TypeReference getUnannotatedTypeReference(int dim) {
 			// generic type
 			ref = getTypeReferenceForGenericType(dim, length, numberOfIdentifiers);
 		} else if (length == 1) {
-			// single variable reference
+			// single type reference
 			this.genericsLengthPtr--; // pop the 0
 			if (dim == 0) {
 				ref =
@@ -10373,7 +9916,7 @@ protected TypeReference getUnannotatedTypeReference(int dim) {
 			}
 		} else {
 			this.genericsLengthPtr--;
-			//Qualified variable reference
+			//Qualified type reference
 			char[][] tokens = new char[length][];
 			this.identifierPtr -= length;
 			long[] positions = new long[length];
@@ -10390,8 +9933,27 @@ protected TypeReference getUnannotatedTypeReference(int dim) {
 				annotationsOnDimensions = getAnnotationsOnDimensions(dim);
 				ref = new ArrayQualifiedTypeReference(tokens, dim, annotationsOnDimensions, positions);
 				ref.sourceEnd = this.endPosition;
-				ref.bits |= ASTNode.HasTypeAnnotations;
+				if (annotationsOnDimensions != null) {
+					ref.bits |= ASTNode.HasTypeAnnotations;
+				}
+			}
+		}
+	}
+	int levels = ref.getAnnotatableLevels();
+	for (int i = levels - 1; i >= 0; i--) {
+		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+			if (ref.annotations == null)
+				ref.annotations = new Annotation[levels][];
+			System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					ref.annotations[i] = new Annotation[length],
+					0,
+					length);
+			if (i == 0) {
+				ref.sourceStart = ref.annotations[0][0].sourceStart;
 			}
+			ref.bits |= ASTNode.HasTypeAnnotations;
 		}
 	}
 	return ref;
@@ -10463,8 +10025,13 @@ protected TypeReference getTypeReferenceForGenericType(int dim, int identifierLe
 	}
 }
 protected NameReference getUnspecifiedReference() {
+	return getUnspecifiedReference(true);
+}
+protected NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
 	/* build a (unspecified) NameReference which may be qualified*/
-
+	if (rejectTypeAnnotations) { // Compensate for overpermissive grammar.
+		consumeNonTypeUseName();
+	}
 	int length;
 	NameReference ref;
 	if ((length = this.identifierLengthStack[this.identifierLengthPtr--]) == 1)
@@ -10496,7 +10063,7 @@ protected NameReference getUnspecifiedReferenceOptimized() {
 	a field access. This optimization is IMPORTANT while it results
 	that when a NameReference is build, the type checker should always
 	look for that it is not a type reference */
-
+	consumeNonTypeUseName();
 	int length;
 	NameReference ref;
 	if ((length = this.identifierLengthStack[this.identifierLengthPtr--]) == 1) {
@@ -10682,7 +10249,6 @@ public void initialize(boolean initializeNLS) {
 	this.astLengthPtr = -1;
 	this.expressionPtr = -1;
 	this.expressionLengthPtr = -1;
-	this.unattachedAnnotationPtr = -1;
 	this.typeAnnotationLengthPtr = -1;
 	this.typeAnnotationPtr = -1;
 	this.identifierPtr = -1;
@@ -11004,10 +10570,10 @@ protected void optimizedConcatNodeLists() {
 public boolean atConflictScenario(int token) {
 	
 	/* Answer true if the parser is at a configuration where the scanner must look ahead and help disambiguate between (a) '<' as an operator and '<' as the
-	   start of <type argument> and (b) the use of '(' in '(' expression ')' and '( type ')' and '(' lambda formal parameters ')'. When requested thus,
-	   the scanner helps by fabricating synthetic tokens and injecting them into the stream ahead of the tokens that trigger conflicts in the absence
-	   of these artificial tokens. These manufactured token help transform the grammar into LALR(1) by splitting the states so that they have unambigious
-	   prefixes.
+	   start of <type argument> and (b) the use of '(' in '(' expression ')' and '( type ')' and '(' lambda formal parameters ')'. (c) whether the token @
+	   begins a Java SE5 style declaration annotation or if it begins a SE8 style type annotation. When requested thus, the scanner helps by fabricating 
+	   synthetic tokens and injecting them into the stream ahead of the tokens that trigger conflicts in the absence of these artificial tokens. These 
+	   manufactured token help transform the grammar into LALR(1) by splitting the states so that they have unambigious prefixes.
 	   
 	   We do this by claiming to the automaton that the next token seen is the (suitable) synthetic token and observing the response of the state machine. 
 	   Error signals we are NOT at a conflict site, while shift or shift/reduce signals that we are. Accept is impossible, while there may be intermediate
@@ -11036,7 +10602,9 @@ public boolean atConflictScenario(int token) {
 	int stackTopState = this.stack[stackTop]; // single cell non write through "alternate stack" - the automaton's stack pointer either stays fixed during this manoeuvre or monotonically decreases.
 	int highWaterMark = stackTop;
 	
-	token = token == TokenNameLPAREN ? TokenNameBeginLambda : TokenNameBeginTypeArguments;
+	if (token != TokenNameAT) {
+		token = token == TokenNameLPAREN ? TokenNameBeginLambda : TokenNameBeginTypeArguments;
+	}
 	
 	// A rotated version of the automaton - cf. parse()'s for(;;)
 	for (;;) {  
@@ -12363,7 +11931,6 @@ protected void resetStacks() {
 	this.astLengthPtr = -1;
 	this.expressionPtr = -1;
 	this.expressionLengthPtr = -1;
-	this.unattachedAnnotationPtr = -1;
 	this.typeAnnotationLengthPtr = -1;
 	this.typeAnnotationPtr = -1;
 	this.identifierPtr = -1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
index 1112cb3..beff986 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
@@ -22,22 +22,22 @@ package org.eclipse.jdt.internal.compiler.parser;
  about the parser such as the number of rules in the grammar, the starting state, etc...*/
 public interface ParserBasicInformation {
 
-	int ERROR_SYMBOL = 115,
-		MAX_NAME_LENGTH = 50,
-		NUM_STATES = 1135,
+	int ERROR_SYMBOL = 117,
+		MAX_NAME_LENGTH = 41,
+		NUM_STATES = 1062,
 
-		NT_OFFSET = 115,
-		SCOPE_UBOUND = 252,
-		SCOPE_SIZE = 253,
-		LA_STATE_OFFSET = 16585,
+		NT_OFFSET = 117,
+		SCOPE_UBOUND = 277,
+		SCOPE_SIZE = 278,
+		LA_STATE_OFFSET = 15569,
 		MAX_LA = 1,
-		NUM_RULES = 807,
-		NUM_TERMINALS = 115,
-		NUM_NON_TERMINALS = 358,
-		NUM_SYMBOLS = 473,
-		START_STATE = 1277,
-		EOFT_SYMBOL = 67,
-		EOLT_SYMBOL = 67,
-		ACCEPT_ACTION = 16584,
-		ERROR_ACTION = 16585;
+		NUM_RULES = 775,
+		NUM_TERMINALS = 117,
+		NUM_NON_TERMINALS = 347,
+		NUM_SYMBOLS = 464,
+		START_STATE = 831,
+		EOFT_SYMBOL = 60,
+		EOLT_SYMBOL = 60,
+		ACCEPT_ACTION = 15568,
+		ERROR_ACTION = 15569;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index b4b613c..c89f1fe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -1155,6 +1155,12 @@ public int getNextToken() throws InvalidInputException {
 	} else if (token == TokenNameLESS && atReferenceExpression()) {
 		this.nextToken = token;
 		token = TokenNameBeginTypeArguments;
+	} else if (token == TokenNameAT && atTypeAnnotation()) {
+		token = TokenNameAT308;
+		if (atEllipsisAnnotation()) {
+			this.nextToken = token;
+			token = TokenNameAT308DOTDOTDOT;
+		}
 	}
 
 	this.lookBack[0] = this.lookBack[1];
@@ -4200,6 +4206,9 @@ private static class VanguardScanner extends Scanner {
 	   We morph one or the other specific token into EOF and see if the parser enters accept state. On true EOF, we return fake
 	   EOF to force an error. This is so that the interim goal reduction actually happens only when -> or :: occur in input at
 	   the expected place.
+	   
+	   To make matters interesting, type annotations can occur inside both lambda parameter list and reference expression trunks
+	   and declarative annotations can occur in lambda parameter lists. We need to discriminate between them. Sigh.
 	*/
 	private int fakeEofToken = TokenNameNotAToken; // if encountered in input stream, will be exposed as EOF instead.
 
@@ -4209,6 +4218,9 @@ private static class VanguardScanner extends Scanner {
 	
 	public int getNextToken() throws InvalidInputException {
 		int token = getNextToken0();
+		if (token == TokenNameAT && atTypeAnnotation()) {
+			token = TokenNameAT308;
+		}
 		return token == this.fakeEofToken ? TokenNameEOF : token == TokenNameEOF ? this.fakeEofToken : token; 
 	}
 
@@ -4218,13 +4230,7 @@ private static class VanguardScanner extends Scanner {
 }
 
 // Vanguard Parser - A Private utility helper class for the scanner.
-private static class VanguardParser implements ParserBasicInformation, TerminalTokens {
-	
-	private int[] stack = new int[StackIncrement];
-	private int stateStackTop;
-	private final static int StackIncrement = 255;
-	private int currentToken;
-	private final VanguardScanner scanner;
+private static class VanguardParser extends Parser {
 	
 	public VanguardParser(VanguardScanner scanner) {
 		this.scanner = scanner;
@@ -4252,11 +4258,21 @@ private static class VanguardParser implements ParserBasicInformation, TerminalT
 				if (act <= NUM_RULES) {
 					this.stateStackTop--;
 				} else if (act > ERROR_ACTION) { /* shift-reduce */
-					this.currentToken = this.scanner.getNextToken();
+					this.unstackedAct = act;
+					try {
+						this.currentToken = this.scanner.getNextToken();
+					} finally {
+						this.unstackedAct = ERROR_ACTION;
+					}
 					act -= ERROR_ACTION;
 				} else {
 				    if (act < ACCEPT_ACTION) { /* shift */
-				    	this.currentToken = this.scanner.getNextToken();
+				    	this.unstackedAct = act;
+						try {
+							this.currentToken = this.scanner.getNextToken();
+						} finally {
+							this.unstackedAct = ERROR_ACTION;
+						}
 						continue ProcessTerminals;
 					}
 				    return true; // accept !
@@ -4278,12 +4294,18 @@ private VanguardParser getVanguardParser() {
 	if (this.vanguardParser == null) {
 		this.vanguardScanner = new VanguardScanner(this.sourceLevel, this.complianceLevel);
 		this.vanguardParser = new VanguardParser(this.vanguardScanner);
+		this.vanguardScanner.setActiveParser(this.vanguardParser);
 	}
 	this.vanguardScanner.setSource(this.source);
 	this.vanguardScanner.resetTo(this.startPosition, this.eofPosition - 1);
 	return this.vanguardParser;
 }
-private final boolean atLambdaParameterList() { // Did the '(' we saw just now herald a lambda parameter list ?
+
+public void setFakeEofToken(int specialToken) {
+	throw new UnsupportedOperationException();   // for specific specializations only.
+}
+
+protected final boolean atLambdaParameterList() { // Did the '(' we saw just now herald a lambda parameter list ?
 
 	switch (this.lookBack[1]) {
 		case TokenNameEQUAL : 
@@ -4303,7 +4325,8 @@ private final boolean atLambdaParameterList() { // Did the '(' we saw just now h
 	}
 	return this.activeParser.atConflictScenario(TokenNameLPAREN) && getVanguardParser().parse(TokenNameARROW);
 }
-private final boolean atReferenceExpression() { // Did the '<' we saw just now herald a reference expression ?
+
+protected final boolean atReferenceExpression() { // Did the '<' we saw just now herald a reference expression ?
 	switch (this.lookBack[1]) {
 		case TokenNameIdentifier:
 			switch (this.lookBack[0]) {
@@ -4341,6 +4364,27 @@ private final boolean atReferenceExpression() { // Did the '<' we saw just now h
 	}
 	return this.activeParser.atConflictScenario(TokenNameLESS) && getVanguardParser().parse(TokenNameCOLON_COLON);
 }
+protected final boolean atEllipsisAnnotation() { // Did the '@' we saw just now herald a type annotation on a ... ? Presumed to be at type annotation already.
+	switch (this.lookBack[1]) {
+		case TokenNamenew:
+		case TokenNameCOMMA:
+		case TokenNameextends:
+		case TokenNamesuper:
+		case TokenNameimplements:
+		case TokenNameDOT:
+		case TokenNameLBRACE:
+		case TokenNameinstanceof:
+		case TokenNameLESS:
+		case TokenNameGREATER:
+		case TokenNameAND:
+		case TokenNamethrows:
+			return false;
+	}
+	return getVanguardParser().parse(TokenNameELLIPSIS);
+}
+protected final boolean atTypeAnnotation() { // Did the '@' we saw just now herald a type annotation ? We should not ask the parser whether it would shift @308 !
+	return !this.activeParser.atConflictScenario(TokenNameAT);
+}
 
 public void setActiveParser(ConflictedParser parser) {
 	this.activeParser  = parser;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
index fd9c359..f58f38d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
@@ -43,119 +43,121 @@ public interface TerminalTokens {
 		TokenNameCOMMENT_BLOCK = 1002,
 		TokenNameCOMMENT_JAVADOC = 1003;
 
-	int TokenNameIdentifier = 20,
-		TokenNameabstract = 33,
-		TokenNameassert = 79,
-		TokenNameboolean = 43,
-		TokenNamebreak = 80,
-		TokenNamebyte = 44,
-		TokenNamecase = 107,
-		TokenNamecatch = 104,
-		TokenNamechar = 45,
-		TokenNameclass = 77,
-		TokenNamecontinue = 81,
-		TokenNameconst = 113,
-		TokenNamedefault = 89,
-		TokenNamedo = 82,
-		TokenNamedouble = 46,
+	int TokenNameIdentifier = 23,
+		TokenNameabstract = 51,
+		TokenNameassert = 71,
+		TokenNameboolean = 96,
+		TokenNamebreak = 72,
+		TokenNamebyte = 97,
+		TokenNamecase = 98,
+		TokenNamecatch = 99,
+		TokenNamechar = 100,
+		TokenNameclass = 66,
+		TokenNamecontinue = 73,
+		TokenNameconst = 115,
+		TokenNamedefault = 82,
+		TokenNamedo = 74,
+		TokenNamedouble = 101,
 		TokenNameelse = 110,
-		TokenNameenum = 105,
-		TokenNameextends = 103,
-		TokenNamefalse = 57,
-		TokenNamefinal = 34,
+		TokenNameenum = 69,
+		TokenNameextends = 95,
+		TokenNamefalse = 38,
+		TokenNamefinal = 52,
 		TokenNamefinally = 108,
-		TokenNamefloat = 47,
-		TokenNamefor = 83,
-		TokenNamegoto = 114,
-		TokenNameif = 84,
-		TokenNameimplements = 112,
-		TokenNameimport = 106,
+		TokenNamefloat = 102,
+		TokenNamefor = 75,
+		TokenNamegoto = 116,
+		TokenNameif = 76,
+		TokenNameimplements = 113,
+		TokenNameimport = 103,
 		TokenNameinstanceof = 17,
-		TokenNameint = 48,
-		TokenNameinterface = 90,
-		TokenNamelong = 49,
-		TokenNamenative = 35,
-		TokenNamenew = 56,
-		TokenNamenull = 58,
-		TokenNamepackage = 91,
-		TokenNameprivate = 36,
-		TokenNameprotected = 37,
-		TokenNamepublic = 38,
-		TokenNamereturn = 85,
-		TokenNameshort = 50,
-		TokenNamestatic = 32,
-		TokenNamestrictfp = 39,
-		TokenNamesuper = 55,
-		TokenNameswitch = 86,
-		TokenNamesynchronized = 40,
-		TokenNamethis = 54,
-		TokenNamethrow = 87,
-		TokenNamethrows = 111,
-		TokenNametransient = 41,
-		TokenNametrue = 59,
-		TokenNametry = 88,
-		TokenNamevoid = 51,
-		TokenNamevolatile = 42,
-		TokenNamewhile = 78,
-		TokenNameIntegerLiteral = 60,
-		TokenNameLongLiteral = 61,
-		TokenNameFloatingPointLiteral = 62,
-		TokenNameDoubleLiteral = 63,
-		TokenNameCharacterLiteral = 64,
-		TokenNameStringLiteral = 65,
-		TokenNamePLUS_PLUS = 2,
-		TokenNameMINUS_MINUS = 3,
-		TokenNameEQUAL_EQUAL = 21,
-		TokenNameLESS_EQUAL = 14,
-		TokenNameGREATER_EQUAL = 15,
-		TokenNameNOT_EQUAL = 22,
-		TokenNameLEFT_SHIFT = 19,
-		TokenNameRIGHT_SHIFT = 13,
+		TokenNameint = 104,
+		TokenNameinterface = 67,
+		TokenNamelong = 105,
+		TokenNamenative = 53,
+		TokenNamenew = 36,
+		TokenNamenull = 39,
+		TokenNamepackage = 94,
+		TokenNameprivate = 54,
+		TokenNameprotected = 55,
+		TokenNamepublic = 56,
+		TokenNamereturn = 77,
+		TokenNameshort = 106,
+		TokenNamestatic = 40,
+		TokenNamestrictfp = 57,
+		TokenNamesuper = 34,
+		TokenNameswitch = 78,
+		TokenNamesynchronized = 41,
+		TokenNamethis = 35,
+		TokenNamethrow = 79,
+		TokenNamethrows = 112,
+		TokenNametransient = 58,
+		TokenNametrue = 42,
+		TokenNametry = 80,
+		TokenNamevoid = 107,
+		TokenNamevolatile = 59,
+		TokenNamewhile = 70,
+		TokenNameIntegerLiteral = 43,
+		TokenNameLongLiteral = 44,
+		TokenNameFloatingPointLiteral = 45,
+		TokenNameDoubleLiteral = 46,
+		TokenNameCharacterLiteral = 47,
+		TokenNameStringLiteral = 48,
+		TokenNamePLUS_PLUS = 1,
+		TokenNameMINUS_MINUS = 2,
+		TokenNameEQUAL_EQUAL = 19,
+		TokenNameLESS_EQUAL = 12,
+		TokenNameGREATER_EQUAL = 13,
+		TokenNameNOT_EQUAL = 20,
+		TokenNameLEFT_SHIFT = 18,
+		TokenNameRIGHT_SHIFT = 14,
 		TokenNameUNSIGNED_RIGHT_SHIFT = 16,
-		TokenNamePLUS_EQUAL = 92,
-		TokenNameMINUS_EQUAL = 93,
-		TokenNameMULTIPLY_EQUAL = 94,
-		TokenNameDIVIDE_EQUAL = 95,
-		TokenNameAND_EQUAL = 96,
-		TokenNameOR_EQUAL = 97,
-		TokenNameXOR_EQUAL = 98,
-		TokenNameREMAINDER_EQUAL = 99,
-		TokenNameLEFT_SHIFT_EQUAL = 100,
-		TokenNameRIGHT_SHIFT_EQUAL = 101,
-		TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL = 102,
+		TokenNamePLUS_EQUAL = 83,
+		TokenNameMINUS_EQUAL = 84,
+		TokenNameMULTIPLY_EQUAL = 85,
+		TokenNameDIVIDE_EQUAL = 86,
+		TokenNameAND_EQUAL = 87,
+		TokenNameOR_EQUAL = 88,
+		TokenNameXOR_EQUAL = 89,
+		TokenNameREMAINDER_EQUAL = 90,
+		TokenNameLEFT_SHIFT_EQUAL = 91,
+		TokenNameRIGHT_SHIFT_EQUAL = 92,
+		TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL = 93,
 		TokenNameOR_OR = 31,
 		TokenNameAND_AND = 30,
 		TokenNamePLUS = 4,
 		TokenNameMINUS = 5,
-		TokenNameNOT = 69,
-		TokenNameREMAINDER = 9,
-		TokenNameXOR = 24,
-		TokenNameAND = 23,
-		TokenNameMULTIPLY = 8,
-		TokenNameOR = 26,
-		TokenNameTWIDDLE = 70,
-		TokenNameDIVIDE = 10,
-		TokenNameGREATER = 12,
+		TokenNameNOT = 62,
+		TokenNameREMAINDER = 8,
+		TokenNameXOR = 22,
+		TokenNameAND = 21,
+		TokenNameMULTIPLY = 6,
+		TokenNameOR = 25,
+		TokenNameTWIDDLE = 63,
+		TokenNameDIVIDE = 9,
+		TokenNameGREATER = 15,
 		TokenNameLESS = 11,
 		TokenNameLPAREN = 27,
-		TokenNameRPAREN = 25,
-		TokenNameLBRACE = 68,
-		TokenNameRBRACE = 53,
-		TokenNameLBRACKET = 6,
-		TokenNameRBRACKET = 72,
+		TokenNameRPAREN = 26,
+		TokenNameLBRACE = 49,
+		TokenNameRBRACE = 32,
+		TokenNameLBRACKET = 10,
+		TokenNameRBRACKET = 64,
 		TokenNameSEMICOLON = 28,
 		TokenNameQUESTION = 29,
-		TokenNameCOLON = 71,
-		TokenNameCOMMA = 52,
-		TokenNameDOT = 1,
-		TokenNameEQUAL = 75,
-		TokenNameAT = 18,
-		TokenNameELLIPSIS = 76,
+		TokenNameCOLON = 61,
+		TokenNameCOMMA = 33,
+		TokenNameDOT = 3,
+		TokenNameEQUAL = 68,
+		TokenNameAT = 37,
+		TokenNameELLIPSIS = 111,
 		TokenNameARROW = 109,
 		TokenNameCOLON_COLON = 7,
-		TokenNameBeginLambda = 66,
-		TokenNameBeginTypeArguments = 74,
-		TokenNameElidedSemicolonAndRightBrace = 73,
-		TokenNameEOF = 67,
-		TokenNameERROR = 115;
+		TokenNameBeginLambda = 50,
+		TokenNameBeginTypeArguments = 81,
+		TokenNameElidedSemicolonAndRightBrace = 65,
+		TokenNameAT308 = 24,
+		TokenNameAT308DOTDOTDOT = 114,
+		TokenNameEOF = 60,
+		TokenNameERROR = 117;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
index 0db9162..ff187bd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java
@@ -2606,6 +2606,6 @@ public class DiagnoseParser implements ParserBasicInformation, TerminalTokens, C
 		   '<' should not be tagged for disambiguation. If a synthetic token gets injected there, there will be syntax
 		   error. See that this is not a problem for the regular/normal parser.
 		*/ 
-		return (token == TokenNameLPAREN || (token == TokenNameLESS && !this.lexStream.awaitingColonColon()));
+		return (token == TokenNameLPAREN || token == TokenNameAT || (token == TokenNameLESS && !this.lexStream.awaitingColonColon()));
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
index bbb3869..7791c05 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser10.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser10.rsc
index a6bc5bc..7c841c7 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser10.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser10.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser11.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser11.rsc
index 2e3f5cc..9f7d374 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser11.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser11.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser12.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser12.rsc
index 2f76296..e0575f8 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser12.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser12.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser13.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser13.rsc
index 2365ba5..9678c62 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser13.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser13.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
index a837d69..5f70b72 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
index b25a584..c33252c 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
index 5b11c93..115a60c 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
index 79101fc..e6a2127 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc
index 20e892b..ceac058 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
index cf5eb70..05d341c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
@@ -1 +1,12 @@
-nnK55D5l64LK55HHHHHDl5555666GGG4LLL,667755IhG5555,k,4,G,,NDOOD,DD,g4444iKKmZ,M,gGi,Y,,,,76,,
\ No newline at end of file
+nnD   l!oD  @@@@11l    ===!o##""  Ac=   # b!=
+rF1GG111
+
+k`a	_!!!!EDD
+
+mCB_=E
+
+
+
+R%
+
+%Q"#$$
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
index 766e4bb..38e1536 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
index c824117..c2daa1f 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
index e13a2cc..a71307b 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
index c29c7be..f5684f2 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc
index 72db512..5366251 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser23.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
index e16bf97..0941dda 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
index 735b0c2..798a7c5 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
index ec5f191..05f1624 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
index aadfeb4..1f93049 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
index bd3add5..e4abff4 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc
index f9d2137..737712a 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
index 478faed..f10d49a 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
index ee1c4d0..df20df2 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.props b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.props
index bccc528..61118ce 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.props
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.props
@@ -1,17 +1,3 @@
-###############################################################################
-# Copyright (c) 2012 IBM Corporation and others.
-# All rights reserved. This program and the accompanying materials
-# are made available under the terms of the Eclipse Public License v1.0
-# which accompanies this distribution, and is available at
-# http://www.eclipse.org/legal/epl-v10.html
-#
-# This is an implementation of an early-draft specification developed under the Java
-# Community Process (JCP) and is made available for testing and evaluation purposes
-# only. The code is not compatible with any specification of the JCP.
-#
-# Contributors:
-#     IBM Corporation - initial API and implementation
-###############################################################################
 ,opt=,
 ;opt=;
 AbstractMethodDeclaration=MethodDeclaration
@@ -36,7 +22,6 @@ AnnotationTypeDeclarationHeaderName=AnnotationTypeDeclarationHeaderName
 AnnotationTypeMemberDeclaration=AnnotationTypeMemberDeclaration
 AnnotationTypeMemberDeclarations=AnnotationTypeMemberDeclarations
 AnnotationTypeMemberDeclarationsopt=AnnotationTypeMemberDeclarations
-Annotationsopt=Annotationsopt
 ArgumentList=ArgumentList
 ArgumentListopt=ArgumentList
 Arguments=Arguments
@@ -81,9 +66,7 @@ ClassHeaderName=ClassHeaderName
 ClassInstanceCreationExpression=ClassInstanceCreationExpression
 ClassInstanceCreationExpressionName=ClassInstanceCreationExpressionName
 ClassMemberDeclaration=ClassMemberDeclaration
-ClassOrInterface0=Type
 ClassOrInterface=Type
-ClassOrInterfaceType0=Type
 ClassOrInterfaceType=Type
 ClassType=ClassType
 ClassTypeElt=ClassType
@@ -107,10 +90,8 @@ Diet=Diet
 DimWithOrWithOutExpr=Dimension
 DimWithOrWithOutExprs=Dimensions
 Dims=Dimensions
-DimsAnnotLoop=DimsAnnotLoop
 DimsLoop=Dimensions
 Dimsopt=Dimensions
-DimsoptAnnotsopt=AnnotationsDimensionsSequence
 DoStatement=DoStatement
 ElidedLeftBraceAndReturn=ElidedLeftBraceAndReturn
 EmptyStatement=EmptyStatement
@@ -162,7 +143,6 @@ FormalParameterList=FormalParameterList
 FormalParameterListopt=FormalParameterList
 GenericMethodDeclaration=GenericMethodDeclaration
 GenericType=GenericType
-GenericTypeDotName=GenericTypeDotName
 Goal=Goal
 Header1=Header1
 Header2=Header2
@@ -178,7 +158,6 @@ InclusiveOrExpression_NotName=Expression
 Initializer=Initializer
 InsideCastExpression=InsideCastExpression
 InsideCastExpressionLL1=InsideCastExpression
-InsideCastExpressionWithAnnotatedQualifiedGenerics=InsideCastExpression
 InsideCastExpressionWithQualifiedGenerics=InsideCastExpression
 InstanceofExpression=Expression
 InstanceofExpression_NotName=Expression
@@ -209,6 +188,7 @@ Literal=Literal
 LocalVariableDeclaration=LocalVariableDeclaration
 LocalVariableDeclarationStatement=LocalVariableDeclarationStatement
 MarkerAnnotation=MarkerAnnotation
+MarkerTypeAnnotation=MarkerAnnotation
 MemberValue=MemberValue
 MemberValueArrayInitializer=MemberValueArrayInitializer
 MemberValuePair=MemberValuePair
@@ -234,9 +214,9 @@ NestedMethod=NestedMethod
 NestedType=NestedType
 NonWildTypeArgumentsopt=NonWildTypeArgumentsopt
 NormalAnnotation=NormalAnnotation
+NormalTypeAnnotation=NormalAnnotation
 NumericType=NumericType
 OneDimLoop=Dimension
-OneDimOrAnnot=OneDimensionOrAnnotation
 OnlySynchronized=OnlySynchronized
 OnlyTypeArguments=TypeArguments
 OnlyTypeArgumentsForCastExpression=TypeArguments
@@ -245,12 +225,10 @@ PackageComment=PackageComment
 PackageDeclaration=PackageDeclaration
 PackageDeclarationName=PackageDeclarationName
 ParenthesizedLambdaParameterList=ParenthesizedLambdaParameterList
-PopZeroTypeAnnotations=PopZeroTypeAnnotations
 PostDecrementExpression=PostDecrementExpression
 PostIncrementExpression=PostIncrementExpression
 PostfixExpression=Expression
 PostfixExpression_NotName=Expression
-PotentialNameArray=PotentialNameArray
 PreDecrementExpression=PreDecrementExpression
 PreIncrementExpression=PreIncrementExpression
 Primary=Expression
@@ -263,27 +241,21 @@ PushModifiers=PushModifiers
 PushModifiersForHeader=PushModifiersForHeader
 PushPosition=PushPosition
 PushRPAREN=)
-PushRPARENForAnnotatedTypeCast=)
-PushRPARENForNameAndAnnotatedTypeCast=)
-PushRPARENForNameUnannotatedTypeCast=)
-PushRPARENForUnannotatedTypeCast=)
 PushRealModifiers=PushRealModifiers
 PushZeroTypeAnnotations=ZeroTypeAnnotations
 QualifiedClassBodyopt=ClassBody
 QualifiedEnterAnonymousClassBody=EnterAnonymousClassBody
 QualifiedName=QualifiedName
-RecoveryEnumConstantSeparatoropt=RecoveryEnumConstantSeparatoropt
-RecoveryExitHeader=RecoveryExitHeader
 RecoveryMethodHeader=MethodHeader
 RecoveryMethodHeaderName=MethodHeaderName
 ReduceImports=ReduceImports
 ReferenceExpression=ReferenceExpression
 ReferenceExpressionTypeArgumentsAndTrunk=ReferenceExpressionTypeArgumentsAndTrunk
-ReferenceType0=ReferenceType
 ReferenceType1=ReferenceType1
 ReferenceType2=ReferenceType2
 ReferenceType3=ReferenceType3
 ReferenceType=ReferenceType
+RejectTypeAnnotations=RejectTypeAnnotations
 RelationalExpression=Expression
 RelationalExpression_NotName=Expression
 Resource=Resource
@@ -296,6 +268,7 @@ ShiftExpression_NotName=Expression
 SimpleName=SimpleName
 SingleMemberAnnotation=SingleMemberAnnotation
 SingleMemberAnnotationMemberValue=MemberValue
+SingleMemberTypeAnnotation=SingleMemberAnnotation
 SingleStaticImportDeclaration=SingleStaticImportDeclaration
 SingleStaticImportDeclarationName=SingleStaticImportDeclarationName
 SingleTypeImportDeclaration=SingleTypeImportDeclaration
@@ -321,9 +294,11 @@ TrailingSemiColon=;
 TryBlock=Block
 TryStatement=TryStatement
 TryStatementWithResources=TryStatementWithResources
-Type0=Type
 Type=Type
+TypeAnnotation=TypeAnnotation
+TypeAnnotationName=AnnotationName
 TypeAnnotations=TypeAnnotations
+TypeAnnotationsopt=TypeAnnotationsopt
 TypeArgument1=TypeArgument1
 TypeArgument2=TypeArgument2
 TypeArgument3=TypeArgument3
@@ -339,13 +314,13 @@ TypeElidedFormalParameter=TypeElidedFormalParameter
 TypeElidedFormalParameterList=TypeElidedFormalParameterList
 TypeImportOnDemandDeclaration=TypeImportOnDemandDeclaration
 TypeImportOnDemandDeclarationName=TypeImportOnDemandDeclarationName
-TypeInternal=Type
 TypeParameter1=TypeParameter1
 TypeParameter=TypeParameter
 TypeParameterHeader=TypeParameter
 TypeParameterList1=TypeParameterList1
 TypeParameterList=TypeParameterList
 TypeParameters=TypeParameters
+UnannotatableName=UnannotatableQualifiedName
 UnaryExpression=Expression
 UnaryExpressionNotPlusMinus=Expression
 UnaryExpressionNotPlusMinus_NotName=Expression
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 09072016..6ab1205 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -6982,6 +6982,11 @@ private void syntaxError(
 	String errorTokenName,
 	String expectedToken) {
 
+	if (currentKind == TerminalTokens.TokenNameAT && expectedToken != null && expectedToken.equals("@")) { //$NON-NLS-1$
+		// In the diagnose parser case, we don't have the wherewithal to discriminate when we should hand out @308 vs @. So we always answer @.
+		// We should silently recover so swallow the message.
+		return;
+	}
 	String eTokenName;
 	if (isKeyword(currentKind) ||
 		isLiteral(currentKind) ||
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetParser.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetParser.java
index efe4aff..13b7003 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetParser.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetParser.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -374,6 +374,17 @@ protected void consumeMethodInvocationName() {
 			this.identifierLengthPtr--;
 		} else {
 			this.identifierLengthStack[this.identifierLengthPtr]--;
+			int length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--];
+			Annotation [] typeAnnotations;
+			if (length != 0) {
+				System.arraycopy(
+						this.typeAnnotationStack,
+						(this.typeAnnotationPtr -= length) + 1,
+						typeAnnotations = new Annotation[length],
+						0,
+						length);
+				problemReporter().misplacedTypeAnnotations(typeAnnotations[0], typeAnnotations[typeAnnotations.length - 1]);
+			}
 			m.receiver = getUnspecifiedReference();
 			m.sourceStart = m.receiver.sourceStart;
 		}
@@ -629,8 +640,11 @@ protected CompilationUnitDeclaration endParse(int act) {
 	}
 	return super.endParse(act);
 }
-protected NameReference getUnspecifiedReference() {
+protected NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
 	/* build a (unspecified) NameReference which may be qualified*/
+	if (rejectTypeAnnotations) {
+		consumeNonTypeUseName();
+	}
 
 	if (this.scanner.startPosition >= this.codeSnippetStart
 		&& this.scanner.startPosition <= this.codeSnippetEnd+1+this.lineSeparatorLength /*14838*/){
@@ -659,7 +673,7 @@ protected NameReference getUnspecifiedReference() {
 		}
 		return ref;
 	} else {
-		return super.getUnspecifiedReference();
+		return super.getUnspecifiedReference(rejectTypeAnnotations);
 	}
 }
 protected NameReference getUnspecifiedReferenceOptimized() {
@@ -669,6 +683,7 @@ protected NameReference getUnspecifiedReferenceOptimized() {
 	a field access. This optimization is IMPORTANT while it results
 	that when a NameReference is build, the type checker should always
 	look for that it is not a type reference */
+	consumeNonTypeUseName();
 
 	if (this.scanner.startPosition >= this.codeSnippetStart
 		&& this.scanner.startPosition <= this.codeSnippetEnd+1+this.lineSeparatorLength /*14838*/){
@@ -796,7 +811,6 @@ protected boolean resumeOnSyntaxError() {
 
 	// reset stacks in consistent state
 	this.expressionPtr = -1;
-	this.unattachedAnnotationPtr = -1;
 	this.typeAnnotationLengthPtr = -1;
 	this.typeAnnotationPtr = -1;
 	this.identifierPtr = -1;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
index ec9e531..cd20cf1 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
@@ -171,8 +171,8 @@ public class CodeFormatterVisitor extends ASTVisitor {
 		TerminalTokens.TokenNamevoid
 	};
 	private static final int[] CLOSING_GENERICS_EXPECTEDTOKENS = new int[] {
-		TerminalTokens.TokenNameGREATER,
 		TerminalTokens.TokenNameRIGHT_SHIFT,
+		TerminalTokens.TokenNameGREATER,
 		TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT,
 	};
 	public int lastLocalDeclarationSourceStart;
diff --git a/org.eclipse.jdt.core/grammar/java.g b/org.eclipse.jdt.core/grammar/java.g
index 79aad05..21997eb 100644
--- a/org.eclipse.jdt.core/grammar/java.g
+++ b/org.eclipse.jdt.core/grammar/java.g
@@ -110,6 +110,8 @@ $Terminals
 	BeginLambda
 	BeginTypeArguments
 	ElidedSemicolonAndRightBrace
+	AT308
+	AT308DOTDOTDOT
 
 --    BodyMarker
 
@@ -165,6 +167,8 @@ $Alias
 	'='    ::= EQUAL
 	'@'	   ::= AT
 	'...'  ::= ELLIPSIS
+	'@308' ::= AT308
+	'@308...' ::= AT308DOTDOTDOT
 	
 $Start
 	Goal
@@ -182,8 +186,9 @@ Goal ::= '--' MethodBody
 Goal ::= '>>' StaticInitializer
 Goal ::= '>>' Initializer
 -- error recovery
-Goal ::= '>>>' Header1 RecoveryExitHeader
-Goal ::= '!' Header2 RecoveryExitHeader
+-- Modifiersopt is used to properly consume a header and exit the rule reduction at the end of the parse() method
+Goal ::= '>>>' Header1 Modifiersopt
+Goal ::= '!' Header2 Modifiersopt
 Goal ::= '*' BlockStatements
 Goal ::= '*' CatchHeader
 -- JDOM
@@ -205,12 +210,10 @@ Goal ::= '?' AnnotationTypeMemberDeclaration
 -- JSR 335 Reconnaissance missions.
 Goal ::= '->' ParenthesizedLambdaParameterList
 Goal ::= '::' ReferenceExpressionTypeArgumentsAndTrunk
+-- JSR 308 Reconnaissance mission.
+Goal ::= '...' TypeAnnotations
 /:$readableName Goal:/
 
-RecoveryExitHeader ::= $empty
-RecoveryExitHeader ::= '...'
-/:$readableName RecoveryExitHeader:/
-
 Literal -> IntegerLiteral
 Literal -> LongLiteral
 Literal -> FloatingPointLiteral
@@ -224,47 +227,19 @@ BooleanLiteral -> true
 BooleanLiteral -> false
 /:$readableName BooleanLiteral:/
 
--- Type is a wrapper that automatically allows for jsr308 style
--- annotations to prefix a (Java7) Type. If type annotations
--- are illegal in a certain place, use TypeInternal instead.
--- If type annotations are legal, but so are java7 style
--- declaration annotations, use Type0 instead.
-
-Type ::= TypeInternal
--- consumeUnannotatedType inserts 0 at the suitable place in the type
--- annotation stacks, so that the TOS(typeAnnotationsLengthStack) is the right
--- length of the type annotations 0 or otherwise.
-/.$putCase consumeUnannotatedType();  $break ./
-Type ::= TypeAnnotations TypeInternal
-/:$compliance 1.8:/
-/:$readableName Type:/
-
--- Type0 is to be used in places where type annotations are legal
--- but are not consumed as TypeAnnotations, but as modifiers. This
--- is because from the parser's point of view there are places where
--- java7 style declarations annotations can occur in the same place
--- and it is too early to tell which is which.
-Type0 ::= TypeInternal
--- consumeUnannotatedType inserts 0 at the suitable place in the type
--- annotation stacks, so that the TOS(typeAnnotationsLengthStack) is the right
--- length of the type annotations 0 or otherwise.
-/.$putCase consumeUnannotatedType();  $break ./
-/:$readableName Type:/
-
--- TypeInternal is the Java7 Type
-TypeInternal ::= PrimitiveType
+Type ::= PrimitiveType
 /.$putCase consumePrimitiveType(); $break ./
-TypeInternal -> ReferenceType0
+Type -> ReferenceType
 /:$readableName Type:/
 
-PrimitiveType -> NumericType
+PrimitiveType -> TypeAnnotationsopt NumericType
 /:$readableName PrimitiveType:/
 NumericType -> IntegralType
 NumericType -> FloatingPointType
 /:$readableName NumericType:/
 
-PrimitiveType -> 'boolean'
-PrimitiveType -> 'void'
+PrimitiveType -> TypeAnnotationsopt 'boolean'
+PrimitiveType -> TypeAnnotationsopt 'void'
 IntegralType -> 'byte'
 IntegralType -> 'short'
 IntegralType -> 'int'
@@ -275,74 +250,29 @@ FloatingPointType -> 'float'
 FloatingPointType -> 'double'
 /:$readableName FloatingPointType:/
 
----------------------------- JSR308-------------------------------------------
--- ReferenceType has been wrapped now, so that it can be used by itself without
--- having to spell out the rule once with Modifiers & once without.
--- If type annotations are not legal prefixes to ReferenceType at some point, use 
--- ReferenceType0 instead. Otherwise reject the annotations in the parser.
-
-ReferenceType ::= ReferenceType0
--- consumeUnannotatedType inserts 0 at the suitable place in the type
--- annotation stacks, so that the TOS(typeAnnotationsLengthStack) is the right
--- length of the type annotations 0 or otherwise.
-/.$putCase consumeUnannotatedType();  $break ./
-ReferenceType ::= Modifiers ReferenceType0
-/.$putCase consumeAnnotatedType();  $break ./
-/:$compliance 1.8:/
-/:$readableName ReferenceType:/
-
-ReferenceType0 ::= ClassOrInterfaceType0
-/.$putCase consumeReferenceType();  $break ./
-ReferenceType0 -> ArrayType
+ReferenceType ::= ClassOrInterfaceType
+/.$putCase consumeReferenceType(); $break ./
+ReferenceType -> ArrayType
 /:$readableName ReferenceType:/
 
-Annotationsopt ::= $empty
-/.$putCase consumeZeroTypeAnnotations(true); $break ./
-Annotationsopt -> TypeAnnotations
-/:$compliance 1.8:/
-/:$readableName Annotationsopt:/
-
--- ClassOrInterfaceType has now been wrapped so that it automatically includes
--- JSR308 style optional annotations. Use ClassOrInterfaceType0 if annotations
--- are illegal in some place - otherwise reject the annotations in the parser.
-ClassOrInterfaceType ::= Annotationsopt ClassOrInterfaceType0
-/:$readableName Type:/
-
-ClassOrInterfaceType0 -> ClassOrInterface0
-ClassOrInterfaceType0 -> GenericType
-/:$readableName Type:/
----------------------------- JSR308-------------------------------------------
-
--- ClassOrInterface has been wrapped now so that it ALWAYS PUSHES
--- A 0 IN THE TYPE ANNOTATIONS LENGTH STACK. If this behavior is
--- not desirable, then (a) use ClassOrInterface0 if possible or (b)
--- if that is not possible due to conflicts, then this 0 will have
--- to be popped suitably when erroneous/extraneous. See the use of
--- the production PopZeroTypeAnnotations for examples.
-
-ClassOrInterface ::= ClassOrInterface0
-/.$putCase consumeZeroTypeAnnotations(true); $break ./
+---------------------------------------------------------------
+-- 1.5 feature
+---------------------------------------------------------------
+ClassOrInterfaceType -> ClassOrInterface
+ClassOrInterfaceType -> GenericType
 /:$readableName Type:/
 
-ClassOrInterface0 ::= Name
-/.$putCase consumeClassOrInterfaceName();  $break ./
-ClassOrInterface0 ::= GenericTypeDotName
+ClassOrInterface ::= Name
+/.$putCase consumeClassOrInterfaceName(); $break ./
+ClassOrInterface ::= GenericType '.' Name
+/.$putCase consumeClassOrInterface(); $break ./
 /:$readableName Type:/
 
-PopZeroTypeAnnotations ::= $empty
-/.$putCase consumeZeroTypeAnnotations(false); $break ./
-/:$readableName PopZeroTypeAnnotations:/
-
-GenericType ::= ClassOrInterface TypeArguments PopZeroTypeAnnotations
-/.$putCase consumeGenericType();  $break ./
-/:$compliance 1.5:/
+GenericType ::= ClassOrInterface TypeArguments
+/.$putCase consumeGenericType(); $break ./
 /:$readableName GenericType:/
 
-GenericTypeDotName ::= GenericType '.' Name
-/.$putCase consumeClassOrInterface();  $break ./
-/:$readableName GenericTypeDotName:/
-
-GenericType ::= ClassOrInterface '<' '>' PopZeroTypeAnnotations
+GenericType ::= ClassOrInterface '<' '>'
 /.$putCase consumeGenericTypeWithDiamond(); $break ./
 /:$readableName GenericType:/
 /:$compliance 1.7:/
@@ -356,7 +286,8 @@ GenericType ::= ClassOrInterface '<' '>' PopZeroTypeAnnotations
 -- ArrayType ::= ArrayType '[' ']'
 --
 
-ArrayTypeWithTypeArgumentsName ::= GenericTypeDotName
+ArrayTypeWithTypeArgumentsName ::= GenericType '.' Name
+/.$putCase consumeArrayTypeWithTypeArgumentsName(); $break ./
 /:$readableName ArrayTypeWithTypeArgumentsName:/
 
 ArrayType ::= PrimitiveType Dims
@@ -375,7 +306,10 @@ ClassType -> ClassOrInterfaceType
 --------------------------------------------------------------
 --------------------------------------------------------------
 
-Name -> SimpleName
+Name ::= SimpleName
+/.$putCase consumeZeroTypeAnnotations(); $break ./
+Name -> TypeAnnotations SimpleName
+/:$compliance 1.8:/
 Name -> QualifiedName
 /:$readableName Name:/
 /:$recovery_template Identifier:/
@@ -383,10 +317,78 @@ Name -> QualifiedName
 SimpleName -> 'Identifier'
 /:$readableName SimpleName:/
 
+UnannotatableName -> SimpleName
+UnannotatableName ::= UnannotatableName '.' SimpleName
+/.$putCase consumeUnannotatableQualifiedName(); $break ./
+/:$readableName UnannotatableQualifiedName:/
+
 QualifiedName ::= Name '.' SimpleName 
-/.$putCase consumeQualifiedName(); $break ./
+/.$putCase consumeQualifiedName(false); $break ./
+QualifiedName ::= Name '.' TypeAnnotations SimpleName 
+/.$putCase consumeQualifiedName(true); $break ./
+/:$compliance 1.8:/
 /:$readableName QualifiedName:/
 
+TypeAnnotationsopt ::= $empty
+/.$putCase consumeZeroTypeAnnotations(); $break ./
+TypeAnnotationsopt -> TypeAnnotations
+/:$compliance 1.8:/
+/:$readableName TypeAnnotationsopt:/
+
+TypeAnnotations -> TypeAnnotation
+/:$compliance 1.8:/
+TypeAnnotations ::= TypeAnnotations TypeAnnotation
+/. $putCase consumeOneMoreTypeAnnotation(); $break ./
+/:$compliance 1.8:/
+/:$readableName TypeAnnotations:/
+
+TypeAnnotation ::= NormalTypeAnnotation
+/. $putCase consumeTypeAnnotation(); $break ./
+/:$compliance 1.8:/
+TypeAnnotation ::= MarkerTypeAnnotation
+/. $putCase consumeTypeAnnotation(); $break ./
+/:$compliance 1.8:/
+TypeAnnotation ::= SingleMemberTypeAnnotation
+/. $putCase consumeTypeAnnotation(); $break ./
+/:$compliance 1.8:/
+/:$readableName TypeAnnotation:/
+
+TypeAnnotationName ::= @308 UnannotatableName
+/.$putCase consumeAnnotationName() ; $break ./
+/:$readableName AnnotationName:/
+/:$compliance 1.8:/
+/:$recovery_template @ Identifier:/
+NormalTypeAnnotation ::= TypeAnnotationName '(' MemberValuePairsopt ')'
+/.$putCase consumeNormalAnnotation(true) ; $break ./
+/:$readableName NormalAnnotation:/
+/:$compliance 1.8:/
+MarkerTypeAnnotation ::= TypeAnnotationName
+/.$putCase consumeMarkerAnnotation(true) ; $break ./
+/:$readableName MarkerAnnotation:/
+/:$compliance 1.8:/
+SingleMemberTypeAnnotation ::= TypeAnnotationName '(' SingleMemberAnnotationMemberValue ')'
+/.$putCase consumeSingleMemberAnnotation(true) ; $break ./
+/:$readableName SingleMemberAnnotation:/
+/:$compliance 1.8:/
+
+RejectTypeAnnotations ::= $empty
+/.$putCase consumeNonTypeUseName(); $break ./
+/:$readableName RejectTypeAnnotations:/
+
+PushZeroTypeAnnotations ::= $empty
+/.$putCase consumeZeroTypeAnnotations(); $break ./
+/:$readableName ZeroTypeAnnotations:/
+
+VariableDeclaratorIdOrThis ::= 'this'
+/.$putCase consumeExplicitThisParameter(false); $break ./
+/:$compliance 1.8:/
+VariableDeclaratorIdOrThis ::= UnannotatableName '.' 'this'
+/.$putCase consumeExplicitThisParameter(true); $break ./
+/:$compliance 1.8:/
+VariableDeclaratorIdOrThis ::= VariableDeclaratorId
+/.$putCase consumeVariableDeclaratorIdParameter(); $break ./
+/:$readableName VariableDeclaratorId:/
+
 CompilationUnit ::= EnterCompilationUnit InternalCompilationUnit
 /.$putCase consumeCompilationUnit(); $break ./
 /:$readableName CompilationUnit:/
@@ -435,14 +437,9 @@ Header1 -> ConstructorHeader
 /:$readableName Header1:/
 
 Header2 -> Header
-Header2 -> EnumConstantHeader RecoveryEnumConstantSeparatoropt
+Header2 -> EnumConstantHeader
 /:$readableName Header2:/
 
-RecoveryEnumConstantSeparatoropt ::= $empty
-RecoveryEnumConstantSeparatoropt ::= ','
-RecoveryEnumConstantSeparatoropt ::= ';'
-/:$readableName RecoveryEnumConstantSeparatoropt:/
-
 CatchHeader ::= 'catch' '(' CatchFormalParameter ')' '{'
 /.$putCase consumeCatchHeader(); $break ./
 /:$readableName CatchHeader:/
@@ -461,13 +458,13 @@ PackageDeclaration ::= PackageDeclarationName ';'
 /.$putCase consumePackageDeclaration(); $break ./
 /:$readableName PackageDeclaration:/
 
-PackageDeclarationName ::= Modifiers 'package' PushRealModifiers Name
+PackageDeclarationName ::= Modifiers 'package' PushRealModifiers Name RejectTypeAnnotations
 /.$putCase consumePackageDeclarationNameWithModifiers(); $break ./
 /:$readableName PackageDeclarationName:/
 /:$compliance 1.5:/
 
-PackageDeclarationName ::= PackageComment 'package' Name
-/.$putCase  consumePackageDeclarationName(); $break ./
+PackageDeclarationName ::= PackageComment 'package' Name RejectTypeAnnotations
+/.$putCase consumePackageDeclarationName(); $break ./
 /:$readableName PackageDeclarationName:/
 
 PackageComment ::= $empty
@@ -487,7 +484,7 @@ SingleTypeImportDeclaration ::= SingleTypeImportDeclarationName ';'
 /.$putCase consumeImportDeclaration(); $break ./
 /:$readableName SingleTypeImportDeclaration:/
 
-SingleTypeImportDeclarationName ::= 'import' Name
+SingleTypeImportDeclarationName ::= 'import' Name RejectTypeAnnotations
 /.$putCase consumeSingleTypeImportDeclarationName(); $break ./
 /:$readableName SingleTypeImportDeclarationName:/
 
@@ -495,7 +492,7 @@ TypeImportOnDemandDeclaration ::= TypeImportOnDemandDeclarationName ';'
 /.$putCase consumeImportDeclaration(); $break ./
 /:$readableName TypeImportOnDemandDeclaration:/
 
-TypeImportOnDemandDeclarationName ::= 'import' Name '.' '*'
+TypeImportOnDemandDeclarationName ::= 'import' Name '.' RejectTypeAnnotations '*'
 /.$putCase consumeTypeImportOnDemandDeclarationName(); $break ./
 /:$readableName TypeImportOnDemandDeclarationName:/
 
@@ -641,7 +638,7 @@ GenericMethodDeclaration -> ConstructorDeclaration
 --    | 'transient'
 --    | 'volatile'
 
-FieldDeclaration ::= Modifiersopt Type0 VariableDeclarators ';'
+FieldDeclaration ::= Modifiersopt Type VariableDeclarators ';'
 /.$putCase consumeFieldDeclaration(); $break ./
 /:$readableName FieldDeclaration:/
 
@@ -675,16 +672,6 @@ RestoreDiet ::= $empty
 /.$putCase consumeRestoreDiet(); $break ./
 /:$readableName RestoreDiet:/
 
-VariableDeclaratorIdOrThis ::= 'this'
-/.$putCase consumeExplicitThisParameter(false); $break ./
-/:$compliance 1.8:/
-VariableDeclaratorIdOrThis ::= Name '.' 'this'
-/.$putCase consumeExplicitThisParameter(true); $break ./
-/:$compliance 1.8:/
-VariableDeclaratorIdOrThis ::= VariableDeclaratorId
-/.$putCase consumeVariableDeclaratorIdParameter(); $break ./
-/:$readableName VariableDeclaratorId:/
-
 VariableDeclaratorId ::= 'Identifier' Dimsopt
 /:$readableName VariableDeclaratorId:/
 /:$recovery_template Identifier:/
@@ -723,7 +710,7 @@ MethodHeader ::= MethodHeaderName FormalParameterListopt MethodHeaderRightParen
 
 MethodHeaderName ::= Modifiersopt TypeParameters Type 'Identifier' '('
 /.$putCase consumeMethodHeaderNameWithTypeParameters(false); $break ./
-MethodHeaderName ::= Modifiersopt Type0 'Identifier' '('
+MethodHeaderName ::= Modifiersopt Type 'Identifier' '('
 /.$putCase consumeMethodHeaderName(false); $break ./
 /:$readableName MethodHeaderName:/
 
@@ -755,36 +742,16 @@ FormalParameterList ::= FormalParameterList ',' FormalParameter
 /.$putCase consumeFormalParameterList(); $break ./
 /:$readableName FormalParameterList:/
 
-PotentialNameArray -> $empty
-/.$putCase consumePotentialNameArrayType(); $break ./
-/:$readableName PotentialNameArray:/
-
 --1.1 feature
---FormalParameter ::= Modifiersopt Type VariableDeclaratorId
---FormalParameter ::= Modifiersopt Type '...' VariableDeclaratorId
---The above rules have been rewritten by inlinng the type subgrammar
---to avoid the conflicts resulting from jsr308 changes.
-FormalParameter ::= Modifiersopt PrimitiveType DimsoptAnnotsopt VariableDeclaratorIdOrThis
+FormalParameter ::= Modifiersopt Type VariableDeclaratorIdOrThis
 /.$putCase consumeFormalParameter(false); $break ./
-FormalParameter ::= Modifiersopt PrimitiveType DimsoptAnnotsopt '...' VariableDeclaratorIdOrThis
+FormalParameter ::= Modifiersopt Type PushZeroTypeAnnotations '...' VariableDeclaratorIdOrThis
 /.$putCase consumeFormalParameter(true); $break ./
 /:$compliance 1.5:/
-FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt PotentialNameArray VariableDeclaratorIdOrThis
-/.$putCase consumeFormalParameter(false); $break ./
-FormalParameter ::= Modifiersopt Name DimsoptAnnotsopt PotentialNameArray '...' VariableDeclaratorIdOrThis
-/.$putCase consumeFormalParameter(true); $break ./
-/:$compliance 1.5:/
-FormalParameter ::= Modifiersopt GenericType DimsoptAnnotsopt VariableDeclaratorIdOrThis
-/.$putCase consumeFormalParameter(false); $break ./
-FormalParameter ::= Modifiersopt GenericType DimsoptAnnotsopt '...' VariableDeclaratorIdOrThis
-/.$putCase consumeFormalParameter(true); $break ./
-/:$compliance 1.5:/
-FormalParameter ::= Modifiersopt GenericTypeDotName DimsoptAnnotsopt VariableDeclaratorIdOrThis
-/.$putCase consumeFormalParameter(false); $break ./
-FormalParameter ::= Modifiersopt GenericTypeDotName DimsoptAnnotsopt '...' VariableDeclaratorIdOrThis
+FormalParameter ::= Modifiersopt Type @308... TypeAnnotations '...' VariableDeclaratorIdOrThis
 /.$putCase consumeFormalParameter(true); $break ./
 /:$readableName FormalParameter:/
-/:$compliance 1.5:/
+/:$compliance 1.8:/
 /:$recovery_template Identifier Identifier:/
 
 CatchFormalParameter ::= Modifiersopt CatchType VariableDeclaratorId
@@ -796,7 +763,7 @@ CatchType ::= UnionType
 /.$putCase consumeCatchType(); $break ./
 /:$readableName CatchType:/
 
-UnionType ::= Type0
+UnionType ::= Type
 /.$putCase consumeUnionTypeAsClassType(); $break ./
 UnionType ::= UnionType '|' Type
 /.$putCase consumeUnionType(); $break ./
@@ -823,7 +790,7 @@ NestedMethod ::= $empty
 
 --18.8.4 Productions from 8.5: Static Initializers
 
-StaticInitializer ::=  StaticOnly Block
+StaticInitializer ::= StaticOnly Block
 /.$putCase consumeStaticInitializer(); $break./
 /:$readableName StaticInitializer:/
 
@@ -959,6 +926,7 @@ InvalidInitializer -> StaticInitializer
 InvalidInitializer -> Initializer
 /:$readableName InvalidInitializer:/
 
+
 InterfaceMemberDeclaration -> AbstractMethodDeclaration
 InterfaceMemberDeclaration -> InvalidConstructorDeclaration
 InterfaceMemberDeclaration -> InvalidInitializer
@@ -1022,13 +990,13 @@ LocalVariableDeclarationStatement ::= LocalVariableDeclaration ';'
 /.$putCase consumeLocalVariableDeclarationStatement(); $break ./
 /:$readableName LocalVariableDeclarationStatement:/
 
-LocalVariableDeclaration ::= Type0 PushModifiers VariableDeclarators
+LocalVariableDeclaration ::= Type PushModifiers VariableDeclarators
 /.$putCase consumeLocalVariableDeclaration(); $break ./
 -- 1.1 feature
 -- The modifiers part of this rule makes the grammar more permissive. 
 -- The only modifier here is final. We put Modifiers to allow multiple modifiers
 -- This will require to check the validity of the modifier
-LocalVariableDeclaration ::= Modifiers Type0 PushRealModifiers VariableDeclarators
+LocalVariableDeclaration ::= Modifiers Type PushRealModifiers VariableDeclarators
 /.$putCase consumeLocalVariableDeclaration(); $break ./
 /:$readableName LocalVariableDeclaration:/
 
@@ -1096,7 +1064,7 @@ LabeledStatementNoShortIf ::= Label ':' StatementNoShortIf
 /:$readableName LabeledStatement:/
 
 Label ::= 'Identifier'
-/.$putCase consumeLabel(); $break ./
+/.$putCase consumeLabel() ; $break ./
 /:$readableName Label:/
 
 ExpressionStatement ::= StatementExpression ';'
@@ -1241,7 +1209,6 @@ TryStatement ::= 'try' TryBlock Catchesopt Finally
 
 TryStatementWithResources ::= 'try' ResourceSpecification TryBlock Catchesopt
 /.$putCase consumeStatementTry(false, true); $break ./
-/:$compliance 1.7:/
 TryStatementWithResources ::= 'try' ResourceSpecification TryBlock Catchesopt Finally
 /.$putCase consumeStatementTry(true, true); $break ./
 /:$readableName TryStatementWithResources:/
@@ -1254,7 +1221,6 @@ ResourceSpecification ::= '(' Resources ;opt ')'
 
 ;opt ::= $empty
 /.$putCase consumeResourceOptionalTrailingSemiColon(false); $break ./
-/:$compliance 1.7:/
 ;opt ::= ';'
 /.$putCase consumeResourceOptionalTrailingSemiColon(true); $break ./
 /:$readableName ;:/
@@ -1262,7 +1228,6 @@ ResourceSpecification ::= '(' Resources ;opt ')'
 
 Resources ::= Resource
 /.$putCase consumeSingleResource(); $break ./
-/:$compliance 1.7:/
 Resources ::= Resources TrailingSemiColon Resource
 /.$putCase consumeMultipleResources(); $break ./
 /:$readableName Resources:/
@@ -1273,12 +1238,12 @@ TrailingSemiColon ::= ';'
 /:$readableName ;:/
 /:$compliance 1.7:/
 
-Resource ::= Type0 PushModifiers VariableDeclaratorId EnterVariable '=' ForceNoDiet VariableInitializer RestoreDiet ExitVariableWithInitialization
+Resource ::= Type PushModifiers VariableDeclaratorId EnterVariable '=' ForceNoDiet VariableInitializer RestoreDiet ExitVariableWithInitialization
 /.$putCase consumeResourceAsLocalVariableDeclaration(); $break ./
 /:$readableName Resource:/
 /:$compliance 1.7:/
 
-Resource ::= Modifiers Type0 PushRealModifiers VariableDeclaratorId EnterVariable '=' ForceNoDiet VariableInitializer RestoreDiet ExitVariableWithInitialization
+Resource ::= Modifiers Type PushRealModifiers VariableDeclaratorId EnterVariable '=' ForceNoDiet VariableInitializer RestoreDiet ExitVariableWithInitialization
 /.$putCase consumeResourceAsLocalVariableDeclaration(); $break ./
 /:$readableName Resource:/
 /:$compliance 1.7:/
@@ -1299,7 +1264,7 @@ CatchClause ::= 'catch' '(' CatchFormalParameter ')' Block
 /.$putCase consumeStatementCatch() ; $break ./
 /:$readableName CatchClause:/
 
-Finally ::= 'finally'    Block
+Finally ::= 'finally' Block
 /:$readableName Finally:/
 /:$recovery_template finally { }:/
 
@@ -1310,27 +1275,10 @@ PushLPAREN ::= '('
 /.$putCase consumeLeftParen(); $break ./
 /:$readableName (:/
 /:$recovery_template (:/
-PushRPARENForUnannotatedTypeCast ::= ')'
-/.$putCase consumeRightParenForUnannotatedTypeCast(); $break ./
-/:$readableName ):/
-/:$recovery_template ):/
-PushRPARENForNameUnannotatedTypeCast ::=  ')'
-/.$putCase consumeRightParenForNameUnannotatedTypeCast(); $break ./
-/:$readableName ):/
-/:$recovery_template ):/
 PushRPAREN ::= ')'
 /.$putCase consumeRightParen(); $break ./
 /:$readableName ):/
 /:$recovery_template ):/
-PushRPARENForAnnotatedTypeCast ::= ')'
-/.$putCase consumeRightParenForAnnotatedTypeCast(); $break ./
-/:$readableName ):/
-/:$recovery_template ):/
-
-PushRPARENForNameAndAnnotatedTypeCast ::= ')'
-/.$putCase consumeRightParenForNameAndAnnotatedTypeCast(); $break ./
-/:$readableName ):/
-/:$recovery_template ):/
 
 Primary -> PrimaryNoNewArray
 Primary -> ArrayCreationWithArrayInitializer
@@ -1350,7 +1298,6 @@ PrimaryNoNewArray ::= PushLPAREN Name PushRPAREN
 PrimaryNoNewArray -> ClassInstanceCreationExpression
 PrimaryNoNewArray -> FieldAccess
 --1.1 feature
--- javac doesn't permit type annotations here.
 PrimaryNoNewArray ::= Name '.' 'this'
 /.$putCase consumePrimaryNoNewArrayNameThis(); $break ./
 PrimaryNoNewArray ::= Name '.' 'super'
@@ -1387,42 +1334,26 @@ PrimaryNoNewArray -> ReferenceExpression
 ReferenceExpressionTypeArgumentsAndTrunk ::= OnlyTypeArguments Dimsopt 
 /.$putCase consumeReferenceExpressionTypeArgumentsAndTrunk(false); $break ./
 /:$compliance 1.8:/
-ReferenceExpressionTypeArgumentsAndTrunk ::= OnlyTypeArguments '.' ClassOrInterfaceType0 Dimsopt 
+ReferenceExpressionTypeArgumentsAndTrunk ::= OnlyTypeArguments '.' ClassOrInterfaceType Dimsopt 
 /.$putCase consumeReferenceExpressionTypeArgumentsAndTrunk(true); $break ./
 /:$readableName ReferenceExpressionTypeArgumentsAndTrunk:/
 /:$compliance 1.8:/
 
-ReferenceExpression ::= PrimitiveType Dims PushModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
+ReferenceExpression ::= PrimitiveType Dims '::' NonWildTypeArgumentsopt IdentifierOrNew
 /.$putCase consumeReferenceExpressionTypeForm(true, true); $break ./
 /:$compliance 1.8:/
 
-ReferenceExpression ::= Modifiers PrimitiveType Dims PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-/.$putCase consumeReferenceExpressionTypeForm(true, true); $break ./
-/:$compliance 1.8:/
-
-ReferenceExpression ::= Name Dims PushModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
+ReferenceExpression ::= Name Dims '::' NonWildTypeArgumentsopt IdentifierOrNew
 /.$putCase consumeReferenceExpressionTypeForm(false, true); $break ./
 /:$compliance 1.8:/
 
-ReferenceExpression ::= Modifiers Name Dims PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-/.$putCase consumeReferenceExpressionTypeForm(false, true); $break ./
-/:$compliance 1.8:/
-
-ReferenceExpression ::= Modifiers Name PushRealModifiers '::' NonWildTypeArgumentsopt IdentifierOrNew
-/.$putCase consumeReferenceExpressionTypeForm(false, false); $break ./
-/:$compliance 1.8:/
-
 ReferenceExpression ::= Name '::' NonWildTypeArgumentsopt IdentifierOrNew
-/.$putCase consumeReferenceExpressionNameForm(); $break ./
+/.$putCase consumeReferenceExpressionTypeForm(false, false); $break ./
 /:$compliance 1.8:/
 
 -- BeginTypeArguments is a synthetic token the scanner concocts to help disambiguate
 -- between '<' as an operator and '<' in '<' TypeArguments '>'
-ReferenceExpression ::= Name PushModifiers BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
-/.$putCase consumeReferenceExpressionGenericTypeForm(); $break ./
-/:$compliance 1.8:/
-
-ReferenceExpression ::= Modifiers Name PushRealModifiers BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
+ReferenceExpression ::= Name BeginTypeArguments ReferenceExpressionTypeArgumentsAndTrunk '::' NonWildTypeArgumentsopt IdentifierOrNew
 /.$putCase consumeReferenceExpressionGenericTypeForm(); $break ./
 /:$compliance 1.8:/
 
@@ -1562,18 +1493,18 @@ ArgumentList ::= ArgumentList ',' Expression
 /.$putCase consumeArgumentList(); $break ./
 /:$readableName ArgumentList:/
 
--- ArrayCreationHeader is used only in recovery and the consume* method is a NOP.
-ArrayCreationHeader ::= 'new' Annotationsopt PrimitiveType DimWithOrWithOutExprs
+ArrayCreationHeader ::= 'new' PrimitiveType DimWithOrWithOutExprs
 /.$putCase consumeArrayCreationHeader(); $break ./
+
 ArrayCreationHeader ::= 'new' ClassOrInterfaceType DimWithOrWithOutExprs
 /.$putCase consumeArrayCreationHeader(); $break ./
 /:$readableName ArrayCreationHeader:/
 
-ArrayCreationWithoutArrayInitializer ::= 'new' Annotationsopt PrimitiveType DimWithOrWithOutExprs
+ArrayCreationWithoutArrayInitializer ::= 'new' PrimitiveType DimWithOrWithOutExprs
 /.$putCase consumeArrayCreationExpressionWithoutInitializer(); $break ./
 /:$readableName ArrayCreationWithoutArrayInitializer:/
 
-ArrayCreationWithArrayInitializer ::= 'new' Annotationsopt PrimitiveType DimWithOrWithOutExprs ArrayInitializer
+ArrayCreationWithArrayInitializer ::= 'new' PrimitiveType DimWithOrWithOutExprs ArrayInitializer
 /.$putCase consumeArrayCreationExpressionWithInitializer(); $break ./
 /:$readableName ArrayCreationWithArrayInitializer:/
 
@@ -1588,46 +1519,12 @@ DimWithOrWithOutExprs ::= DimWithOrWithOutExprs DimWithOrWithOutExpr
 /.$putCase consumeDimWithOrWithOutExprs(); $break ./
 /:$readableName Dimensions:/
 
-DimWithOrWithOutExpr ::= '[' PushZeroTypeAnnotations Expression ']'
-DimWithOrWithOutExpr ::= TypeAnnotations '[' Expression ']'
-/:$compliance 1.8:/
-DimWithOrWithOutExpr ::= '[' PushZeroTypeAnnotations ']'
-/. $putCase consumeDimWithOrWithOutExpr(); $break ./
-DimWithOrWithOutExpr ::= TypeAnnotations '[' ']'
+DimWithOrWithOutExpr ::= TypeAnnotationsopt '[' Expression ']'
+DimWithOrWithOutExpr ::= TypeAnnotationsopt '[' ']'
 /. $putCase consumeDimWithOrWithOutExpr(); $break ./
-/:$compliance 1.8:/
 /:$readableName Dimension:/
 -- -----------------------------------------------
 
--- jsr 308
-
-DimsoptAnnotsopt -> $empty
-/. $putCase consumeEmptyDimsoptAnnotsopt(); $break ./
-/:$readableName AnnotationsDimensionsSequence:/
-DimsoptAnnotsopt -> DimsAnnotLoop
-/. $putCase consumeDimsWithTrailingAnnotsopt(); $break ./
-/:$readableName Dimensionsoptannotsopt:/
-DimsAnnotLoop ::= OneDimOrAnnot
-DimsAnnotLoop ::= DimsAnnotLoop OneDimOrAnnot
-/:$readableName DimsAnnotLoop:/
-
-OneDimOrAnnot ::= Annotation
-/. $putCase consumeTypeAnnotation(true); $break ./
--- Complain if source level < 1.8
-/:$compliance 1.8:/
-OneDimOrAnnot -> '[' ']'
-/. $putCase consumeOneDimLoop(true); $break ./
--- Bump up dimensions && mark zero annotations.
-/:$readableName OneDimensionOrAnnotation:/
-
-TypeAnnotations ::= Annotation
-/. $putCase consumeTypeAnnotation(false); $break ./
-/:$compliance 1.8:/
-TypeAnnotations ::= TypeAnnotations Annotation
-/. $putCase consumeOneMoreTypeAnnotation(); $break ./
-/:$compliance 1.8:/
-/:$readableName TypeAnnotations:/
-
 Dims ::= DimsLoop
 /. $putCase consumeDims(); $break ./
 /:$readableName Dimensions:/
@@ -1636,13 +1533,10 @@ DimsLoop ::= DimsLoop OneDimLoop
 /:$readableName Dimensions:/
 OneDimLoop ::= '[' ']'
 /. $putCase consumeOneDimLoop(false); $break ./
--- Bump up dimensions && mark zero annotations.
-/:$readableName Dimension:/
 OneDimLoop ::= TypeAnnotations '[' ']'
 /:$compliance 1.8:/
-/. $putCase consumeOneDimLoopWithAnnotations(); $break ./
--- Bump up dimensions
-/:$readableName DimensionWithAnnotations:/
+/. $putCase consumeOneDimLoop(true); $break ./
+/:$readableName Dimension:/
 
 FieldAccess ::= Primary '.' 'Identifier'
 /.$putCase consumeFieldAccess(false); $break ./
@@ -1723,31 +1617,16 @@ UnaryExpressionNotPlusMinus ::= '!' PushPosition UnaryExpression
 UnaryExpressionNotPlusMinus -> CastExpression
 /:$readableName Expression:/
 
-CastExpression ::= PushLPAREN PrimitiveType Dimsopt PushRPARENForUnannotatedTypeCast InsideCastExpression UnaryExpression
+CastExpression ::= PushLPAREN PrimitiveType Dimsopt PushRPAREN InsideCastExpression UnaryExpression
 /.$putCase consumeCastExpressionWithPrimitiveType(); $break ./
-CastExpression ::= PushLPAREN Modifiers PrimitiveType Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpression
-/:$compliance 1.8:/
-/.$putCase consumeCastExpressionWithPrimitiveTypeWithTypeAnnotations(); $break ./
-CastExpression ::= PushLPAREN Name OnlyTypeArgumentsForCastExpression Dimsopt PushRPARENForUnannotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
+CastExpression ::= PushLPAREN Name OnlyTypeArgumentsForCastExpression Dimsopt PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 /.$putCase consumeCastExpressionWithGenericsArray(); $break ./
-CastExpression ::= PushLPAREN Modifiers Name OnlyTypeArgumentsForCastExpression Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
-/:$compliance 1.8:/
-/.$putCase consumeCastExpressionWithGenericsArrayWithTypeAnnotations(); $break ./
-CastExpression ::= PushLPAREN Name OnlyTypeArgumentsForCastExpression '.' ClassOrInterfaceType0 Dimsopt PushRPARENForUnannotatedTypeCast InsideCastExpressionWithQualifiedGenerics UnaryExpressionNotPlusMinus
+CastExpression ::= PushLPAREN Name OnlyTypeArgumentsForCastExpression '.' ClassOrInterfaceType Dimsopt PushRPAREN InsideCastExpressionWithQualifiedGenerics UnaryExpressionNotPlusMinus
 /.$putCase consumeCastExpressionWithQualifiedGenericsArray(); $break ./
-CastExpression ::= PushLPAREN Modifiers Name OnlyTypeArgumentsForCastExpression '.' ClassOrInterfaceType0 Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpressionWithAnnotatedQualifiedGenerics UnaryExpressionNotPlusMinus
-/:$compliance 1.8:/
-/.$putCase consumeCastExpressionWithQualifiedGenericsArrayWithTypeAnnotations(); $break ./
-CastExpression ::= PushLPAREN Name PushRPARENForNameUnannotatedTypeCast InsideCastExpressionLL1 UnaryExpressionNotPlusMinus
+CastExpression ::= PushLPAREN Name PushRPAREN InsideCastExpressionLL1 UnaryExpressionNotPlusMinus
 /.$putCase consumeCastExpressionLL1(); $break ./
-CastExpression ::= PushLPAREN Modifiers Name PushRPARENForNameAndAnnotatedTypeCast InsideCastExpressionLL1 UnaryExpressionNotPlusMinus
-/:$compliance 1.8:/
-/.$putCase consumeCastExpressionLL1WithTypeAnnotations(); $break ./
-CastExpression ::= PushLPAREN Name Dims PushRPARENForUnannotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
+CastExpression ::= PushLPAREN Name Dims PushRPAREN InsideCastExpression UnaryExpressionNotPlusMinus
 /.$putCase consumeCastExpressionWithNameArray(); $break ./
-CastExpression ::= PushLPAREN Modifiers Name Dims PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
-/:$compliance 1.8:/
-/.$putCase consumeCastExpressionWithNameArrayWithTypeAnnotations(); $break ./
 /:$readableName CastExpression:/
 
 OnlyTypeArgumentsForCastExpression ::= OnlyTypeArguments
@@ -1764,10 +1643,6 @@ InsideCastExpressionWithQualifiedGenerics ::= $empty
 /.$putCase consumeInsideCastExpressionWithQualifiedGenerics(); $break ./
 /:$readableName InsideCastExpression:/
 
-InsideCastExpressionWithAnnotatedQualifiedGenerics ::= $empty
-/.$putCase consumeInsideCastExpressionWithAnnotatedQualifiedGenerics(); $break ./
-/:$readableName InsideCastExpression:/
-
 MultiplicativeExpression -> UnaryExpression
 MultiplicativeExpression ::= MultiplicativeExpression '*' UnaryExpression
 /.$putCase consumeBinaryExpression(OperatorIds.MULTIPLY); $break ./
@@ -2073,11 +1948,11 @@ EnhancedForStatementNoShortIf ::= EnhancedForStatementHeader StatementNoShortIf
 /.$putCase consumeEnhancedForStatement(); $break ./
 /:$readableName EnhancedForStatementNoShortIf:/
 
-EnhancedForStatementHeaderInit ::= 'for' '(' Type0 PushModifiers Identifier Dimsopt
+EnhancedForStatementHeaderInit ::= 'for' '(' Type PushModifiers Identifier Dimsopt
 /.$putCase consumeEnhancedForStatementHeaderInit(false); $break ./
 /:$readableName EnhancedForStatementHeaderInit:/
 
-EnhancedForStatementHeaderInit ::= 'for' '(' Modifiers Type0 PushRealModifiers Identifier Dimsopt
+EnhancedForStatementHeaderInit ::= 'for' '(' Modifiers Type PushRealModifiers Identifier Dimsopt
 /.$putCase consumeEnhancedForStatementHeaderInit(true); $break ./
 /:$readableName EnhancedForStatementHeaderInit:/
 
@@ -2093,7 +1968,7 @@ SingleStaticImportDeclaration ::= SingleStaticImportDeclarationName ';'
 /.$putCase consumeImportDeclaration(); $break ./
 /:$readableName SingleStaticImportDeclaration:/
 
-SingleStaticImportDeclarationName ::= 'import' 'static' Name
+SingleStaticImportDeclarationName ::= 'import' 'static' Name RejectTypeAnnotations
 /.$putCase consumeSingleStaticImportDeclarationName(); $break ./
 /:$readableName SingleStaticImportDeclarationName:/
 /:$compliance 1.5:/
@@ -2102,7 +1977,7 @@ StaticImportOnDemandDeclaration ::= StaticImportOnDemandDeclarationName ';'
 /.$putCase consumeImportDeclaration(); $break ./
 /:$readableName StaticImportOnDemandDeclaration:/
 
-StaticImportOnDemandDeclarationName ::= 'import' 'static' Name '.' '*'
+StaticImportOnDemandDeclarationName ::= 'import' 'static' Name '.' RejectTypeAnnotations '*'
 /.$putCase consumeStaticImportOnDemandDeclarationName(); $break ./
 /:$readableName StaticImportOnDemandDeclarationName:/
 /:$compliance 1.5:/
@@ -2152,11 +2027,8 @@ ReferenceType1 ::= ReferenceType '>'
 /:$compliance 1.5:/
 ReferenceType1 ::= ClassOrInterface '<' TypeArgumentList2
 /.$putCase consumeTypeArgumentReferenceType1(); $break ./
-/:$compliance 1.5:/
-ReferenceType1 ::= Modifiers ClassOrInterface '<' TypeArgumentList2
-/:$compliance 1.8:/
-/.$putCase consumeTypeArgumentReferenceType1WithTypeAnnotations(); $break ./
 /:$readableName ReferenceType1:/
+/:$compliance 1.5:/
 
 TypeArgumentList2 -> TypeArgument2
 /:$compliance 1.5:/
@@ -2176,10 +2048,6 @@ ReferenceType2 ::= ReferenceType '>>'
 /:$compliance 1.5:/
 ReferenceType2 ::= ClassOrInterface '<' TypeArgumentList3
 /.$putCase consumeTypeArgumentReferenceType2(); $break ./
-/:$compliance 1.5:/
-ReferenceType2 ::= Modifiers ClassOrInterface '<' TypeArgumentList3
-/:$compliance 1.8:/
-/.$putCase consumeTypeArgumentReferenceType2WithTypeAnnotations(); $break ./
 /:$readableName ReferenceType2:/
 
 TypeArgumentList3 -> TypeArgument3
@@ -2198,10 +2066,10 @@ ReferenceType3 ::= ReferenceType '>>>'
 /:$readableName ReferenceType3:/
 /:$compliance 1.5:/
 
-Wildcard ::= '?'
+Wildcard ::= TypeAnnotationsopt '?'
 /.$putCase consumeWildcard(); $break ./
 /:$compliance 1.5:/
-Wildcard ::= '?' WildcardBounds
+Wildcard ::= TypeAnnotationsopt '?' WildcardBounds
 /.$putCase consumeWildcardWithBounds(); $break ./
 /:$readableName Wildcard:/
 /:$compliance 1.5:/
@@ -2214,10 +2082,10 @@ WildcardBounds ::= 'super' ReferenceType
 /:$readableName WildcardBounds:/
 /:$compliance 1.5:/
 
-Wildcard1 ::= '?' '>'
+Wildcard1 ::= TypeAnnotationsopt '?' '>'
 /.$putCase consumeWildcard1(); $break ./
 /:$compliance 1.5:/
-Wildcard1 ::= '?' WildcardBounds1
+Wildcard1 ::= TypeAnnotationsopt '?' WildcardBounds1
 /.$putCase consumeWildcard1WithBounds(); $break ./
 /:$readableName Wildcard1:/
 /:$compliance 1.5:/
@@ -2230,10 +2098,10 @@ WildcardBounds1 ::= 'super' ReferenceType1
 /:$readableName WildcardBounds1:/
 /:$compliance 1.5:/
 
-Wildcard2 ::= '?' '>>'
+Wildcard2 ::= TypeAnnotationsopt '?' '>>'
 /.$putCase consumeWildcard2(); $break ./
 /:$compliance 1.5:/
-Wildcard2 ::= '?' WildcardBounds2
+Wildcard2 ::= TypeAnnotationsopt '?' WildcardBounds2
 /.$putCase consumeWildcard2WithBounds(); $break ./
 /:$readableName Wildcard2:/
 /:$compliance 1.5:/
@@ -2246,10 +2114,10 @@ WildcardBounds2 ::= 'super' ReferenceType2
 /:$readableName WildcardBounds2:/
 /:$compliance 1.5:/
 
-Wildcard3 ::= '?' '>>>'
+Wildcard3 ::= TypeAnnotationsopt '?' '>>>'
 /.$putCase consumeWildcard3(); $break ./
 /:$compliance 1.5:/
-Wildcard3 ::= '?' WildcardBounds3
+Wildcard3 ::= TypeAnnotationsopt '?' WildcardBounds3
 /.$putCase consumeWildcard3WithBounds(); $break ./
 /:$readableName Wildcard3:/
 /:$compliance 1.5:/
@@ -2262,17 +2130,10 @@ WildcardBounds3 ::= 'super' ReferenceType3
 /:$readableName WildcardBound3:/
 /:$compliance 1.5:/
 
-PushZeroTypeAnnotations ::= $empty
-/.$putCase consumeZeroTypeAnnotations(true); $break ./
-/:$readableName ZeroTypeAnnotations:/
-
-TypeParameterHeader ::= PushZeroTypeAnnotations Identifier
-/.$putCase consumeTypeParameterHeader(); $break ./
-/:$compliance 1.5:/
-TypeParameterHeader ::= TypeAnnotations Identifier
-/:$compliance 1.8:/
+TypeParameterHeader ::= TypeAnnotationsopt Identifier
 /.$putCase consumeTypeParameterHeader(); $break ./
 /:$readableName TypeParameter:/
+/:$compliance 1.5:/
 
 TypeParameters ::= '<' TypeParameterList1
 /.$putCase consumeTypeParameters(); $break ./
@@ -2539,7 +2400,7 @@ AnnotationTypeMemberDeclarations ::= AnnotationTypeMemberDeclarations Annotation
 
 AnnotationMethodHeaderName ::= Modifiersopt TypeParameters Type 'Identifier' '('
 /.$putCase consumeMethodHeaderNameWithTypeParameters(true); $break ./
-AnnotationMethodHeaderName ::= Modifiersopt Type0 'Identifier' '('
+AnnotationMethodHeaderName ::= Modifiersopt Type 'Identifier' '('
 /.$putCase consumeMethodHeaderName(true); $break ./
 /:$readableName MethodHeaderName:/
 /:$compliance 1.5:/
@@ -2581,14 +2442,14 @@ Annotation -> SingleMemberAnnotation
 /:$readableName Annotation:/
 /:$compliance 1.5:/
 
-AnnotationName ::= '@' Name
+AnnotationName ::= '@' UnannotatableName
 /.$putCase consumeAnnotationName() ; $break ./
 /:$readableName AnnotationName:/
 /:$compliance 1.5:/
 /:$recovery_template @ Identifier:/
 
 NormalAnnotation ::= AnnotationName '(' MemberValuePairsopt ')'
-/.$putCase consumeNormalAnnotation() ; $break ./
+/.$putCase consumeNormalAnnotation(false) ; $break ./
 /:$readableName NormalAnnotation:/
 /:$compliance 1.5:/
 
@@ -2660,7 +2521,7 @@ MemberValues ::= MemberValues ',' MemberValue
 /:$compliance 1.5:/
 
 MarkerAnnotation ::= AnnotationName
-/.$putCase consumeMarkerAnnotation() ; $break ./
+/.$putCase consumeMarkerAnnotation(false) ; $break ./
 /:$readableName MarkerAnnotation:/
 /:$compliance 1.5:/
 
@@ -2670,7 +2531,7 @@ SingleMemberAnnotationMemberValue ::= MemberValue
 /:$compliance 1.5:/
 
 SingleMemberAnnotation ::= AnnotationName '(' SingleMemberAnnotationMemberValue ')'
-/.$putCase consumeSingleMemberAnnotation() ; $break ./
+/.$putCase consumeSingleMemberAnnotation(false) ; $break ./
 /:$readableName SingleMemberAnnotation:/
 /:$compliance 1.5:/
 --------------------------------------
@@ -2683,7 +2544,7 @@ SingleMemberAnnotation ::= AnnotationName '(' SingleMemberAnnotationMemberValue
 RecoveryMethodHeaderName ::= Modifiersopt TypeParameters Type 'Identifier' '('
 /.$putCase consumeRecoveryMethodHeaderNameWithTypeParameters(); $break ./
 /:$compliance 1.5:/
-RecoveryMethodHeaderName ::= Modifiersopt Type0 'Identifier' '('
+RecoveryMethodHeaderName ::= Modifiersopt Type 'Identifier' '('
 /.$putCase consumeRecoveryMethodHeaderName(); $break ./
 /:$readableName MethodHeaderName:/
 
@@ -2747,7 +2608,9 @@ COLON ::=    ':'
 COMMA ::=    ','    
 DOT ::=    '.'    
 EQUAL ::=    '='    
-AT ::=    '@'    
+AT ::=    '@'
+AT308 ::= '@'
+AT308DOTDOTDOT ::= '@'
 ELLIPSIS ::=    '...'    
 ARROW ::= '->'
 COLON_COLON ::= '::'
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
index b5ab9b9..337d57d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
@@ -26,7 +26,6 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class DocumentElementParser extends Parser {
 	IDocumentElementRequestor requestor;
-	private int localIntPtr;
 	private int lastFieldEndPosition;
 	private int lastFieldBodyEndPosition;
 	private int typeStartPosition;
@@ -515,8 +514,6 @@ protected void consumeEnterVariable() {
 		}
 	}
 
-	this.localIntPtr = this.intPtr;
-
 	if (extendedTypeDimension == 0) {
 		declaration.type = type;
 	} else {
@@ -731,31 +728,35 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 	char[] parameterName = this.identifierStack[this.identifierPtr];
 	long namePositions = this.identifierPositionStack[this.identifierPtr--];
 	int extendedDimensions = this.intStack[this.intPtr--];
+	Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : getAnnotationsOnDimensions(extendedDimensions);
 	int endOfEllipsis = 0;
+	int length;
+	Annotation [] varArgsAnnotations = null;
 	if (isVarArgs) {
 		endOfEllipsis = this.intStack[this.intPtr--];
+		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+			System.arraycopy(
+				this.typeAnnotationStack,
+				(this.typeAnnotationPtr -= length) + 1,
+				varArgsAnnotations = new Annotation[length],
+				0,
+				length);
+		} 
 	}
 	int firstDimensions = this.intStack[this.intPtr--];
-	TypeReference type = getUnannotatedTypeReference(extendedDimensions);
-	Annotation [] varArgsAnnotations = null;
-	int length;
-	if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
-		System.arraycopy(
-			this.typeAnnotationStack,
-			(this.typeAnnotationPtr -= length) + 1,
-			varArgsAnnotations = new Annotation[length],
-			0,
-			length);
-	} 
+	TypeReference type = getTypeReference(firstDimensions);
+
 	final int typeDimensions = firstDimensions + extendedDimensions + (isVarArgs ? 1 : 0);
-	if (typeDimensions != extendedDimensions) {
+	if (typeDimensions != firstDimensions) {
 		// jsr308 type annotations management
-		Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : getAnnotationsOnDimensions(firstDimensions);
-		Annotation [][] annotationsOnExtendedDimensions = extendedDimensions == 0 ? null : type.getAnnotationsOnDimensions();
-		Annotation [][] annotationsOnAllDimensions = null;
-		if (annotationsOnFirstDimensions != null || annotationsOnExtendedDimensions != null || varArgsAnnotations != null) {
+		Annotation [][] annotationsOnFirstDimensions = firstDimensions == 0 ? null : type.getAnnotationsOnDimensions();
+		Annotation [][] annotationsOnAllDimensions = annotationsOnFirstDimensions;
+		if (annotationsOnExtendedDimensions != null) {
 			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions, annotationsOnFirstDimensions, extendedDimensions, annotationsOnExtendedDimensions); 
-			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, isVarArgs ? 1 : 0, isVarArgs ? new Annotation[][]{varArgsAnnotations} : null);
+		}
+		if (varArgsAnnotations != null) {
+			annotationsOnAllDimensions = getMergedAnnotationsOnDimensions(firstDimensions + extendedDimensions, annotationsOnAllDimensions, 
+																				1, new Annotation[][]{varArgsAnnotations});
 		}
 		type = copyDims(type, typeDimensions, annotationsOnAllDimensions);
 		type.sourceEnd = type.isParameterizedTypeReference() ? this.endStatementPosition : this.endPosition;
@@ -1562,63 +1563,4 @@ public String toString() {
 	buffer.append(super.toString());
 	return buffer.toString();
 }
-/**
- * INTERNAL USE ONLY
- */
-protected TypeReference typeReference(
-	int dim,
-	int localIdentifierPtr,
-	int localIdentifierLengthPtr) {
-	/* build a Reference on a variable that may be qualified or not
-	 * This variable is a type reference and dim will be its dimensions.
-	 * We don't have any side effect on the stacks' pointers.
-	 */
-	Annotation [][] annotationsOnDimensions = dim == 0 ? null : getAnnotationsOnDimensions(dim);
-	int length;
-	TypeReference ref;
-	if ((length = this.identifierLengthStack[localIdentifierLengthPtr]) == 1) {
-		// single variable reference
-		if (dim == 0) {
-			ref =
-				new SingleTypeReference(
-					this.identifierStack[localIdentifierPtr],
-					this.identifierPositionStack[localIdentifierPtr--]);
-		} else {
-			ref =
-				new ArrayTypeReference(
-					this.identifierStack[localIdentifierPtr],
-					dim,
-					annotationsOnDimensions,
-					this.identifierPositionStack[localIdentifierPtr--]);
-			ref.sourceEnd = this.endPosition;
-		}
-	} else {
-		if (length < 0) { //flag for precompiled type reference on base types
-			ref = TypeReference.baseTypeReference(-length, dim, annotationsOnDimensions);
-			ref.sourceStart = this.intStack[this.localIntPtr--];
-			if (dim == 0) {
-				ref.sourceEnd = this.intStack[this.localIntPtr--];
-			} else {
-				this.localIntPtr--;
-				ref.sourceEnd = this.endPosition;
-			}
-		} else { //Qualified variable reference
-			char[][] tokens = new char[length][];
-			localIdentifierPtr -= length;
-			long[] positions = new long[length];
-			System.arraycopy(this.identifierStack, localIdentifierPtr + 1, tokens, 0, length);
-			System.arraycopy(
-				this.identifierPositionStack,
-				localIdentifierPtr + 1,
-				positions,
-				0,
-				length);
-			if (dim == 0)
-				ref = new QualifiedTypeReference(tokens, positions);
-			else
-				ref = new ArrayQualifiedTypeReference(tokens, dim, annotationsOnDimensions, positions);
-		}
-	}
-	return ref;
-}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
index 097a37a..31ae829 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
@@ -407,9 +407,9 @@ protected void consumeMemberValuePair() {
 		this.requestor.acceptMethodReference(memberValuepair.name, 0, memberValuepair.sourceStart);
 	}
 }
-protected void consumeMarkerAnnotation() {
-	super.consumeMarkerAnnotation();
-	Annotation annotation = (Annotation)this.expressionStack[this.expressionPtr];
+protected void consumeMarkerAnnotation(boolean isTypeAnnotation) {
+	super.consumeMarkerAnnotation(isTypeAnnotation);
+	Annotation annotation = (Annotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 	if (this.reportReferenceInfo) { // accept annotation type reference
 		this.requestor.acceptAnnotationTypeReference(annotation.type.getTypeName(), annotation.sourceStart, annotation.sourceEnd);
 	}
@@ -524,16 +524,16 @@ protected void consumeMethodInvocationSuperWithTypeArguments() {
 			(int)(messageSend.nameSourcePosition >>> 32));
 	}
 }
-protected void consumeNormalAnnotation() {
-	super.consumeNormalAnnotation();
-	Annotation annotation = (Annotation)this.expressionStack[this.expressionPtr];
+protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
+	super.consumeNormalAnnotation(isTypeAnnotation);
+	Annotation annotation = (Annotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 	if (this.reportReferenceInfo) { // accept annotation type reference
 		this.requestor.acceptAnnotationTypeReference(annotation.type.getTypeName(), annotation.sourceStart, annotation.sourceEnd);
 	}
 }
-protected void consumeSingleMemberAnnotation() {
-	super.consumeSingleMemberAnnotation();
-	SingleMemberAnnotation member = (SingleMemberAnnotation) this.expressionStack[this.expressionPtr];
+protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
+	super.consumeSingleMemberAnnotation(isTypeAnnotation);
+	SingleMemberAnnotation member = (SingleMemberAnnotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 	if (this.reportReferenceInfo) {
 		this.requestor.acceptMethodReference(TypeConstants.VALUE, 0, member.sourceStart);
 	}
@@ -734,7 +734,7 @@ protected CompilationUnitDeclaration endParse(int act) {
 		return null;
 	}
 }
-public TypeReference getUnannotatedTypeReference(int dim) {
+public TypeReference getTypeReference(int dim) {
 	/* build a Reference on a variable that may be qualified or not
 	 * This variable is a type reference and dim will be its dimensions
 	 */
@@ -788,11 +788,14 @@ public TypeReference getUnannotatedTypeReference(int dim) {
 						annotationsOnDimensions,
 						this.identifierPositionStack[this.identifierPtr--]);
 				ref.sourceEnd = this.endPosition;
+				if (annotationsOnDimensions != null) {
+					ref.bits |= ASTNode.HasTypeAnnotations;
+				}
 				if (this.reportReferenceInfo) {
 					this.requestor.acceptTypeReference(((ArrayTypeReference)ref).token, ref.sourceStart);
 				}
 			}
-		} else {//Qualified variable reference
+		} else { // Qualified type reference
 			this.genericsLengthPtr--;
 			char[][] tokens = new char[length][];
 			this.identifierPtr -= length;
@@ -814,17 +817,39 @@ public TypeReference getUnannotatedTypeReference(int dim) {
 				ref =
 					new ArrayQualifiedTypeReference(tokens, dim, annotationsOnDimensions, positions);
 				ref.sourceEnd = this.endPosition;
+				if (annotationsOnDimensions != null) {
+					ref.bits |= ASTNode.HasTypeAnnotations;
+				}
 				if (this.reportReferenceInfo) {
 					this.requestor.acceptTypeReference(((ArrayQualifiedTypeReference)ref).tokens, ref.sourceStart, ref.sourceEnd);
 				}
 			}
 		}
 	}
+	int levels = ref.getAnnotatableLevels();
+	for (int i = levels - 1; i >= 0; i--) {
+		if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
+			if (ref.annotations == null)
+				ref.annotations = new Annotation[levels][];
+			System.arraycopy(
+					this.typeAnnotationStack,
+					(this.typeAnnotationPtr -= length) + 1,
+					ref.annotations[i] = new Annotation[length],
+					0,
+					length);
+			if (i == 0) {
+				ref.sourceStart = ref.annotations[0][0].sourceStart;
+			}
+			ref.bits |= ASTNode.HasTypeAnnotations;
+		}
+	}
 	return ref;
 }
-public NameReference getUnspecifiedReference() {
+public NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
 	/* build a (unspecified) NameReference which may be qualified*/
-
+    if (rejectTypeAnnotations) {
+    	consumeNonTypeUseName();
+    }
 	int length;
 	if ((length = this.identifierLengthStack[this.identifierLengthPtr--]) == 1) {
 		// single variable reference
@@ -862,7 +887,7 @@ public NameReference getUnspecifiedReferenceOptimized() {
 	a field access. This optimization is IMPORTANT while it results
 	that when a NameReference is build, the type checker should always
 	look for that it is not a type reference */
-
+	consumeNonTypeUseName();
 	int length;
 	if ((length = this.identifierLengthStack[this.identifierLengthPtr--]) == 1) {
 		// single variable reference
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
index 60e683c..9a5c107 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -357,10 +357,10 @@ protected void consumeLocalVariableDeclaration() {
 	this.patternLocator.match((LocalDeclaration) this.astStack[this.astPtr], this.nodeSet);
 }
 
-protected void consumeMarkerAnnotation() {
-	super.consumeMarkerAnnotation();
+protected void consumeMarkerAnnotation(boolean isTypeAnnotation) {
+	super.consumeMarkerAnnotation(isTypeAnnotation);
 	if (this.patternFineGrain == 0 || (this.patternFineGrain & IJavaSearchConstants.ANNOTATION_TYPE_REFERENCE) != 0) {
-		Annotation annotation = (Annotation) this.expressionStack[this.expressionPtr];
+		Annotation annotation = (Annotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 		this.patternLocator.match(annotation, this.nodeSet);
 	}
 }
@@ -470,11 +470,11 @@ protected void consumeMethodInvocationSuperWithTypeArguments() {
 	}
 }
 
-protected void consumeNormalAnnotation() {
-	super.consumeNormalAnnotation();
+protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
+	super.consumeNormalAnnotation(isTypeAnnotation);
 	if (this.patternFineGrain == 0 || (this.patternFineGrain & IJavaSearchConstants.ANNOTATION_TYPE_REFERENCE) != 0) {
 		// this is always an Annotation
-		Annotation annotation = (Annotation) this.expressionStack[this.expressionPtr];
+		Annotation annotation = (Annotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 		this.patternLocator.match(annotation, this.nodeSet);
 	}
 }
@@ -508,11 +508,11 @@ protected void consumePrimaryNoNewArrayWithName() {
 	this.intPtr--;
 }
 
-protected void consumeSingleMemberAnnotation() {
-	super.consumeSingleMemberAnnotation();
+protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
+	super.consumeSingleMemberAnnotation(isTypeAnnotation);
 	if (this.patternFineGrain == 0 || (this.patternFineGrain & IJavaSearchConstants.ANNOTATION_TYPE_REFERENCE) != 0) {
 		// this is always an Annotation
-		Annotation annotation = (Annotation) this.expressionStack[this.expressionPtr];
+		Annotation annotation = (Annotation) (isTypeAnnotation ? this.typeAnnotationStack[this.typeAnnotationPtr] : this.expressionStack[this.expressionPtr]);
 		this.patternLocator.match(annotation, this.nodeSet);
 	}
 }
@@ -752,15 +752,15 @@ protected TypeReference copyDims(TypeReference typeRef, int dim, Annotation [][]
 		this.nodeSet.addTrustedMatch(result, true);
 	return result;
 }
-protected TypeReference getUnannotatedTypeReference(int dim) {
-	TypeReference typeRef = super.getUnannotatedTypeReference(dim);
+protected TypeReference getTypeReference(int dim) {
+	TypeReference typeRef = super.getTypeReference(dim);
 	if (this.patternFineGrain == 0) {
 		this.patternLocator.match(typeRef, this.nodeSet); // NB: Don't check container since type reference can happen anywhere
 	}
 	return typeRef;
 }
-protected NameReference getUnspecifiedReference() {
-	NameReference nameRef = super.getUnspecifiedReference();
+protected NameReference getUnspecifiedReference(boolean rejectTypeAnnotations) {
+	NameReference nameRef = super.getUnspecifiedReference(rejectTypeAnnotations);
 	if (this.patternFineGrain == 0) {
 		this.patternLocator.match(nameRef, this.nodeSet); // NB: Don't check container since unspecified reference can happen anywhere
 	} else if ((this.patternFineGrain & IJavaSearchConstants.QUALIFIED_REFERENCE) != 0) {
