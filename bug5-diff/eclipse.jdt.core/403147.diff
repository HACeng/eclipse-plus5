commit 6959c7be7767b62f5fa53e20bd2cfda242ece473
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Apr 18 22:05:38 2013 +0200

    Bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction
    between unboxing, NPE, and deferred checking
    - deferred checking

201	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
28	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
36	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
14	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 7dba22b..606345d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -31,6 +31,7 @@
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -59,7 +60,7 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "test0555_try_catch" };
+//		TESTS_NAMES = new String[] { "test0037_autounboxing_3" };
 //		TESTS_NAMES = new String[] { "testBug401088" };
 //		TESTS_NAMES = new String[] { "testBug402993" };
 //		TESTS_NUMBERS = new int[] { 561 };
@@ -1025,6 +1026,205 @@ public void test0037_conditional_expression_5() {
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// finally block injects pot-nn into itself via enclosing loop
+public void test0037_autounboxing_1() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo1(boolean b) {\n" +
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               j = 1;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"               i = 2;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"	void foo2(boolean b) {\n" +
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       try {\n" + 
+			"           j = 1;\n" + 
+			"       } finally {\n" + 
+			"           j = (b?i:1)+1;\n" + 
+			"           i = 2;\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 20)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// inject pot.nn from try into finally 
+public void test0037_autounboxing_2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo2(boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               if (b)\n" + 
+			"                   i = 3;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"	void foo3(boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       try {\n" + 
+			"           if (b)\n" + 
+			"               i = 3;\n" + 
+			"       } finally {\n" + 
+			"           j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 21)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// null from try, nn from catch, merge both into finally
+public void test0037_autounboxing_3() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo3(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               i = null;\n" + 
+			"               unsafe();\n" + 
+			"           } catch (Exception e) {\n" + 
+			"               i = 3;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"	void foo4(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       try {\n" + 
+			"           i = null;\n" + 
+			"           unsafe();\n" + 
+			"       } catch (Exception e) {\n" + 
+			"           i = 3;\n" + 
+			"       } finally {\n" + 
+			"           while (j < 0)\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   private void unsafe() throws Exception {\n" + 
+			"        throw new Exception();\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 11)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 24)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// effective protection locally within the finally block
+public void test0037_autounboxing_4() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo3(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               i = null;\n" + 
+			"               unsafe();\n" + 
+			"           } catch (Exception e) {\n" + 
+			"               i = 3;\n" + 
+			"           } finally {\n" +
+			"				if (i == null) i = 4;\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"	void foo4(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       try {\n" + 
+			"           i = null;\n" + 
+			"           unsafe();\n" + 
+			"       } catch (Exception e) {\n" + 
+			"           i = 3;\n" + 
+			"       } finally {\n" +
+			"           while (i == null)\n" + 
+			"				i = 4;\n" + 
+			"           while (j < 4)\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   private void unsafe() throws Exception {\n" + 
+			"        throw new Exception();\n" + 
+			"   }\n" +
+			"}\n"},
+		options);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 527c2ca..634a21f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -14,6 +14,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -560,12 +561,11 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 
 /** If this expression requires unboxing check if that operation can throw NPE. */
 protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	if ((this.implicitConversion & UNBOXING) != 0) {
-		int status = nullStatus(flowInfo, flowContext);
-		if ((status & FlowInfo.NULL) != 0)
-			scope.problemReporter().nullUnboxing(this, this.resolvedType);
-		else if ((status & FlowInfo.POTENTIALLY_NULL) != 0)
-			scope.problemReporter().potentialNullUnboxing(this, this.resolvedType);
+	if ((this.implicitConversion & UNBOXING) != 0
+			&& (this.bits & ASTNode.IsNonNull) == 0
+			&& nullStatus(flowInfo, flowContext) != FlowInfo.NON_NULL)
+	{
+		flowContext.recordUnboxing(scope, this, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 8d8333f..03c113d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -14,6 +14,7 @@
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 385626 - @NonNull fails across loop boundaries
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -39,7 +40,7 @@ public class FinallyFlowContext extends TryFlowContext {
 	int assignCount;
 
 	// the following three arrays are in sync regarding their indices:
-	LocalVariableBinding[] nullLocals;
+	LocalVariableBinding[] nullLocals; // slots can be null for checkType == IN_UNBOXING
 	ASTNode[] nullReferences;	// Expressions for null checking, Statements for resource analysis
 								// cast to Expression is safe if corresponding nullCheckType != EXIT_RESOURCE
 	int[] nullCheckTypes;
@@ -98,15 +99,21 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	// check inconsistent null checks
 	if ((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0) { // within an enclosing loop, be conservative
 		for (int i = 0; i < this.nullCount; i++) {
-			if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == ASSIGN_TO_NONNULL) {
-				int nullStatus = flowInfo.nullStatus(this.nullLocals[i]);
-				if (nullStatus != FlowInfo.NON_NULL) {
-					this.parent.recordNullityMismatch(scope, (Expression)this.nullReferences[i],
-							this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus);
-				}
-			} else {
-				this.parent.recordUsingNullReference(scope, this.nullLocals[i],
-						this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
+			ASTNode location = this.nullReferences[i];
+			switch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {
+				case ASSIGN_TO_NONNULL:
+					int nullStatus = flowInfo.nullStatus(this.nullLocals[i]);
+					if (nullStatus != FlowInfo.NON_NULL) {
+						this.parent.recordNullityMismatch(scope, (Expression) location,
+								this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus);
+					}
+					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
+				default:
+					this.parent.recordUsingNullReference(scope, this.nullLocals[i],
+							this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
 			}
 
 		}
@@ -195,6 +202,9 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 						scope.problemReporter().nullityMismatch((Expression) location, this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus, annotationName);
 					}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);	
+					break;
 				default:
 					// should not happen
 			}
@@ -423,10 +433,10 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	}
 
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode expression, int status) {
+	ASTNode expression, int checkType) {
 	if (this.nullCount == 0) {
 		this.nullLocals = new LocalVariableBinding[5];
-		this.nullReferences = new Expression[5];
+		this.nullReferences = new ASTNode[5];
 		this.nullCheckTypes = new int[5];
 	}
 	else if (this.nullCount == this.nullLocals.length) {
@@ -435,7 +445,7 @@ protected void recordNullReference(LocalVariableBinding local,
 			this.nullLocals = new LocalVariableBinding[newLength], 0,
 			this.nullCount);
 		System.arraycopy(this.nullReferences, 0,
-			this.nullReferences = new Expression[newLength], 0,
+			this.nullReferences = new ASTNode[newLength], 0,
 			this.nullCount);
 		System.arraycopy(this.nullCheckTypes, 0,
 			this.nullCheckTypes = new int[newLength], 0,
@@ -443,7 +453,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	}
 	this.nullLocals[this.nullCount] = local;
 	this.nullReferences[this.nullCount] = expression;
-	this.nullCheckTypes[this.nullCount++] = status;
+	this.nullCheckTypes[this.nullCount++] = checkType;
+}
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// defer checking:
+	recordNullReference(null, expression, IN_UNBOXING);
 }
 protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 97a0595..15597ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -16,6 +16,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -98,6 +99,8 @@ public static final int CAN_ONLY_NON_NULL = 0x0002;
 public static final int MAY_NULL = 0x0003;
 //check binding a value to a @NonNull variable 
 public final static int ASSIGN_TO_NONNULL = 0x0080;
+//check against an unboxing conversion
+public static final int IN_UNBOXING = 0x0010;
 //check against unclosed resource at early exit:
 public static final int EXIT_RESOURCE = 0x0800;
 // check against null, with potential values -- NPE guard
@@ -743,23 +746,52 @@ protected boolean recordFinalAssignment(VariableBinding variable, Reference fina
 
 /**
  * Record a null reference for use by deferred checks. Only looping or
- * finally contexts really record that information.
+ * finally contexts really record that information. Other contexts
+ * immediately check for unboxing.
  * @param local the local variable involved in the check
  * @param location the location triggering the analysis, for normal null dereference
  *      this is an expression resolving to 'local', for resource leaks it is an
  *      early exit statement.
- * @param status the status against which the check must be performed; one of
+ * @param checkType the checkType against which the check must be performed; one of
  * 		{@link #CAN_ONLY_NULL CAN_ONLY_NULL}, {@link #CAN_ONLY_NULL_NON_NULL
  * 		CAN_ONLY_NULL_NON_NULL}, {@link #MAY_NULL MAY_NULL},
  *      {@link #CAN_ONLY_NON_NULL CAN_ONLY_NON_NULL}, potentially
  *      combined with a context indicator (one of {@link #IN_COMPARISON_NULL},
- *      {@link #IN_COMPARISON_NON_NULL}, {@link #IN_ASSIGNMENT} or {@link #IN_INSTANCEOF})
+ *      {@link #IN_COMPARISON_NON_NULL}, {@link #IN_ASSIGNMENT} or {@link #IN_INSTANCEOF}).
+ *      <br>
+ *      Alternatively, a {@link #IN_UNBOXING} check can e requested.
  */
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode location, int status) {
+	ASTNode location, int checkType) {
 	// default implementation: do nothing
 }
 
+/**
+ * Either AST analysis or checking of a child flow context has encountered an unboxing situation.
+ * Record this fact for handling at an appropriate point in time.
+ */
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// default: handle immediately:
+	checkUnboxing(scope, expression, flowInfo);
+}
+/** During deferred checking re-visit a previously recording unboxing situation. */
+protected void checkUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	int status = expression.nullStatus(flowInfo, this);
+	if ((status & FlowInfo.NULL) != 0) {
+		scope.problemReporter().nullUnboxing(expression, expression.resolvedType);
+		return;
+	} else if ((status & FlowInfo.POTENTIALLY_NULL) != 0) {
+		scope.problemReporter().potentialNullUnboxing(expression, expression.resolvedType);
+		return;
+	} else if ((status & FlowInfo.NON_NULL) != 0) {
+		return;
+	}
+	// not handled, perhaps our parent will eventually have something to say?
+	if (this.parent != null) {
+		this.parent.recordUnboxing(scope, expression, flowInfo);
+	}
+}
+
 public void recordReturnFrom(UnconditionalFlowInfo flowInfo) {
 	// default implementation: do nothing
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 5dcf13a..68eb6c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -16,6 +16,7 @@
  *								bug 385626 - @NonNull fails across loop boundaries
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 376263 - Bogus "Potential null pointer access" warning
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -55,7 +56,7 @@ public class LoopingFlowContext extends SwitchFlowContext {
 	int assignCount = 0;
 
 	// the following three arrays are in sync regarding their indices:
-	LocalVariableBinding[] nullLocals;
+	LocalVariableBinding[] nullLocals; // slots can be null for checkType == IN_UNBOXING
 	ASTNode[] nullReferences;	// Expressions for null checking, Statements for resource analysis
 								// cast to Expression is safe if corresponding nullCheckType != EXIT_RESOURCE
 	int[] nullCheckTypes;
@@ -276,6 +277,9 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 							}
 						}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
 				default:
 					// never happens
 			}
@@ -396,6 +400,9 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						}
 					}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
 				default:
 					// never happens
 			}
@@ -518,7 +525,7 @@ public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo)
 	}
 
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode expression, int status) {
+	ASTNode expression, int checkType) {
 	if (this.nullCount == 0) {
 		this.nullLocals = new LocalVariableBinding[5];
 		this.nullReferences = new ASTNode[5];
@@ -534,7 +541,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	}
 	this.nullLocals[this.nullCount] = local;
 	this.nullReferences[this.nullCount] = expression;
-	this.nullCheckTypes[this.nullCount++] = status;
+	this.nullCheckTypes[this.nullCount++] = checkType;
+}
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// defer checking:
+	recordNullReference(null, expression, IN_UNBOXING);
 }
 
 /** Record the fact that we see an early exit (in 'reference') while 'trackingVar' is in scope and may be unclosed. */
commit a13c822f6e072c300a8032fb994879857c034ca1
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Apr 19 01:14:12 2013 +0200

    Bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction
    between unboxing, NPE, and deferred checking
    - uniform checking for all relevant AST nodes

36	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
4	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 606345d..138b822 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -1225,6 +1225,42 @@ public void test0037_autounboxing_4() {
 			"}\n"},
 		options);
 }
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// array reference in nested try
+public void test0037_autounboxing_5() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"		void foo(Object [] o, boolean b, Integer i) {\n" + 
+			"		int j = 1;\n" + 
+			"		try {\n" + 
+			"			if (b) i = null;\n" + 
+			"		} catch (RuntimeException r) {\n" + 
+			"			i = 3;\n" + 
+			"		} finally {\n" + 
+			"			try {\n" + 
+			"				System.out.println(o[i]);  \n" + 
+			"			} finally {\n" + 
+			"				System.out.println(j);\n" + 
+			"			}\n" + 
+			"		}\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	System.out.println(o[i]);  \n" + 
+		"	                     ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
index 8ae057c..6d10931 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -67,12 +68,8 @@ public class AND_AND_Expression extends BinaryExpression {
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
 		if ((flowContext.tagBits & FlowContext.INSIDE_NEGATION) != 0)
 			flowContext.expireNullCheckedFieldInfo();
-		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.left.checkNPE(currentScope, flowContext, flowInfo);
-		}
-		if ((this.right.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.right.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.left.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
+		this.right.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		FlowInfo mergedInfo = FlowInfo.conditional(
 				rightInfo.safeInitsWhenTrue(),
 				leftInfo.initsWhenFalse().unconditionalInits().mergedWith(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 5c60a59..2f4b127 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -17,6 +17,7 @@
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -65,9 +66,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			if (analyseResources && !hasResourceWrapperType) { // allocation of wrapped closeables is analyzed specially
 				flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 			}
-			if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-				this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-			}
+			this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index ab7b3bf..e944754 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -33,9 +34,7 @@ public class ArrayAllocationExpression extends Expression {
 			Expression dim;
 			if ((dim = this.dimensions[i]) != null) {
 				flowInfo = dim.analyseCode(currentScope, flowContext, flowInfo);
-				if ((dim.implicitConversion & TypeIds.UNBOXING) != 0) {
-					dim.checkNPE(currentScope, flowContext, flowInfo);
-				}
+				dim.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 		}
 		// account for potential OutOfMemoryError:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index 21f7e7a..0f80187 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -53,6 +54,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.receiver.checkNPE(currentScope, flowContext, flowInfo);
 	flowInfo = this.receiver.analyseCode(currentScope, flowContext, flowInfo);
 	flowInfo = this.position.analyseCode(currentScope, flowContext, flowInfo);
+	this.position.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	// account for potential ArrayIndexOutOfBoundsException:
 	flowContext.recordAbruptExit();
 	return flowInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
index 7cc168b..17cbc01 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
@@ -11,6 +11,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -47,9 +48,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.preAssertInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);
 
 	Constant cst = this.assertExpression.optimizedBooleanConstant();
-	if ((this.assertExpression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.assertExpression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.assertExpression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
 	boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 434d4c0..58255ce 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -24,6 +24,7 @@
  *							bug 331649 - [compiler][null] consider null annotations for fields
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -54,9 +55,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 // a field reference, a blank final field reference, a field of an enclosing instance or
 // just a local variable.
 	LocalVariableBinding local = this.lhs.localVariableBinding();
-	if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.expression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	
 	FlowInfo preInitInfo = null;
 	CompilerOptions compilerOptions = currentScope.compilerOptions();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index 6a76c3e..267ba15 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -83,9 +84,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 										actionInfo.mergedWith(loopingContext.initsOnContinue));
 		}
 	}
-	if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.condition.checkNPE(currentScope, flowContext, initsOnCondition);
-	}
+	this.condition.checkNPEbyUnboxing(currentScope, flowContext, initsOnCondition);
 	/* Reset reach mode, to address following scenario.
 	 *   final blank;
 	 *   do { if (true) break; else blank = 0; } while(false);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 9e8de3f..7c8b726 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,7 @@
  *								bug 361407 - Resource leak warning when resource is assigned to a field outside of constructor
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -87,9 +88,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 						// if argument is an AutoCloseable insert info that it *may* be closed (by the target constructor, i.e.)
 						flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 					}
-					if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-						this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-					}
+					this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 				}
 				analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 634a21f..aa6814f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -561,11 +561,12 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 
 /** If this expression requires unboxing check if that operation can throw NPE. */
 protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	int status;
 	if ((this.implicitConversion & UNBOXING) != 0
 			&& (this.bits & ASTNode.IsNonNull) == 0
-			&& nullStatus(flowInfo, flowContext) != FlowInfo.NON_NULL)
+			&& (status = nullStatus(flowInfo, flowContext)) != FlowInfo.NON_NULL)
 	{
-		flowContext.recordUnboxing(scope, this, flowInfo);
+		flowContext.recordUnboxing(scope, this, status, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index 88948bb..37dac8e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -96,9 +97,7 @@ public class ForStatement extends Statement {
 							new LoopingFlowContext(flowContext, flowInfo, this, null,
 								null, this.scope, true)),
 						condInfo);
-				if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-					this.condition.checkNPE(currentScope, flowContext, flowInfo);
-				}
+				this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 0521cb4..254ff71 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -62,9 +63,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	int initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;
 
 	Constant cst = this.condition.optimizedBooleanConstant();
-	if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.condition.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
 	boolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 769c60f..82e2853 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -25,6 +25,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -126,9 +127,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		int length = this.arguments.length;
 		for (int i = 0; i < length; i++) {
 			Expression argument = this.arguments[i];
-			if ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {
-				argument.checkNPE(currentScope, flowContext, flowInfo);
-			}
+			argument.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			switch (detectAssertionUtility(i)) {
 				case TRUE_ASSERTION:
 					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 4d05409..5e81242 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -72,12 +73,8 @@ public class OR_OR_Expression extends BinaryExpression {
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
 		if ((flowContext.tagBits & FlowContext.INSIDE_NEGATION) == 0)
 			flowContext.expireNullCheckedFieldInfo();
-		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.left.checkNPE(currentScope, flowContext, flowInfo);
-		}
-		if ((this.right.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.right.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.left.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
+		this.right.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		// The definitely null variables in right info when true should not be missed out while merging
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=299900
 		FlowInfo leftInfoWhenTrueForMerging = leftInfo.initsWhenTrue().unconditionalCopy().addPotentialInitializationsFrom(rightInfo.unconditionalInitsWithoutSideEffect());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 178d838..0f117bf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -16,6 +16,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  ******************************************************************************/
@@ -102,9 +103,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)
 					flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 				}
-				if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-					this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-				}
+				this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 			analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 54b3a16..837f432 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -67,9 +68,7 @@ public class WhileStatement extends Statement {
 					new LoopingFlowContext(flowContext, flowInfo, this, null,
 						null, currentScope, true)),
 				condInfo);
-		if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.condition.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 
 		LoopingFlowContext loopingContext;
 		FlowInfo actionInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 03c113d..d918879 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -455,9 +455,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = checkType;
 }
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
-	// defer checking:
-	recordNullReference(null, expression, IN_UNBOXING);
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
+	if (nullStatus == FlowInfo.NULL)
+		super.recordUnboxing(scope, expression, nullStatus, flowInfo);
+	else // defer checking:
+		recordNullReference(null, expression, IN_UNBOXING);
 }
 protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 15597ed..5ae2b8b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -769,8 +769,9 @@ protected void recordNullReference(LocalVariableBinding local,
 /**
  * Either AST analysis or checking of a child flow context has encountered an unboxing situation.
  * Record this fact for handling at an appropriate point in time.
+ * @param nullStatus the status as we know it so far.
  */
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
 	// default: handle immediately:
 	checkUnboxing(scope, expression, flowInfo);
 }
@@ -788,7 +789,7 @@ protected void checkUnboxing(Scope scope, Expression expression, FlowInfo flowIn
 	}
 	// not handled, perhaps our parent will eventually have something to say?
 	if (this.parent != null) {
-		this.parent.recordUnboxing(scope, expression, flowInfo);
+		this.parent.recordUnboxing(scope, expression, FlowInfo.UNKNOWN, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 68eb6c8..53f9c0a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -543,9 +543,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = checkType;
 }
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
-	// defer checking:
-	recordNullReference(null, expression, IN_UNBOXING);
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
+	if (nullStatus == FlowInfo.NULL)
+		super.recordUnboxing(scope, expression, nullStatus, flowInfo);
+	else // defer checking:
+		recordNullReference(null, expression, IN_UNBOXING);
 }
 
 /** Record the fact that we see an early exit (in 'reference') while 'trackingVar' is in scope and may be unclosed. */
commit 650909e8cb3636454033b091607121770e4ba739
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Apr 18 22:05:38 2013 +0200

    Bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction
    between unboxing, NPE, and deferred checking
    - deferred checking

201	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
28	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
36	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
14	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 7dba22b..606345d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -31,6 +31,7 @@
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -59,7 +60,7 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "test0555_try_catch" };
+//		TESTS_NAMES = new String[] { "test0037_autounboxing_3" };
 //		TESTS_NAMES = new String[] { "testBug401088" };
 //		TESTS_NAMES = new String[] { "testBug402993" };
 //		TESTS_NUMBERS = new int[] { 561 };
@@ -1025,6 +1026,205 @@ public void test0037_conditional_expression_5() {
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// finally block injects pot-nn into itself via enclosing loop
+public void test0037_autounboxing_1() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo1(boolean b) {\n" +
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               j = 1;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"               i = 2;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"	void foo2(boolean b) {\n" +
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       try {\n" + 
+			"           j = 1;\n" + 
+			"       } finally {\n" + 
+			"           j = (b?i:1)+1;\n" + 
+			"           i = 2;\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 20)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// inject pot.nn from try into finally 
+public void test0037_autounboxing_2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo2(boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               if (b)\n" + 
+			"                   i = 3;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"	void foo3(boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       Integer i = null;\n" + 
+			"       try {\n" + 
+			"           if (b)\n" + 
+			"               i = 3;\n" + 
+			"       } finally {\n" + 
+			"           j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 21)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// null from try, nn from catch, merge both into finally
+public void test0037_autounboxing_3() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo3(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               i = null;\n" + 
+			"               unsafe();\n" + 
+			"           } catch (Exception e) {\n" + 
+			"               i = 3;\n" + 
+			"           } finally {\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"	void foo4(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       try {\n" + 
+			"           i = null;\n" + 
+			"           unsafe();\n" + 
+			"       } catch (Exception e) {\n" + 
+			"           i = 3;\n" + 
+			"       } finally {\n" + 
+			"           while (j < 0)\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   private void unsafe() throws Exception {\n" + 
+			"        throw new Exception();\n" + 
+			"   }\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 11)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 24)\n" + 
+		"	j = (b?i:1)+1;\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// effective protection locally within the finally block
+public void test0037_autounboxing_4() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	void foo3(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       while (true) {\n" + 
+			"           try {\n" + 
+			"               i = null;\n" + 
+			"               unsafe();\n" + 
+			"           } catch (Exception e) {\n" + 
+			"               i = 3;\n" + 
+			"           } finally {\n" +
+			"				if (i == null) i = 4;\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"           }\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"	void foo4(Integer i, boolean b) {\n" + 
+			"       int j = 0;\n" + 
+			"       try {\n" + 
+			"           i = null;\n" + 
+			"           unsafe();\n" + 
+			"       } catch (Exception e) {\n" + 
+			"           i = 3;\n" + 
+			"       } finally {\n" +
+			"           while (i == null)\n" + 
+			"				i = 4;\n" + 
+			"           while (j < 4)\n" + 
+			"               j = (b?i:1)+1;\n" + 
+			"       }\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   private void unsafe() throws Exception {\n" + 
+			"        throw new Exception();\n" + 
+			"   }\n" +
+			"}\n"},
+		options);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index ac8ea62..c5437e8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -19,6 +19,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -590,12 +591,11 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 
 /** If this expression requires unboxing check if that operation can throw NPE. */
 protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	if ((this.implicitConversion & UNBOXING) != 0) {
-		int status = nullStatus(flowInfo, flowContext);
-		if ((status & FlowInfo.NULL) != 0)
-			scope.problemReporter().nullUnboxing(this, this.resolvedType);
-		else if ((status & FlowInfo.POTENTIALLY_NULL) != 0)
-			scope.problemReporter().potentialNullUnboxing(this, this.resolvedType);
+	if ((this.implicitConversion & UNBOXING) != 0
+			&& (this.bits & ASTNode.IsNonNull) == 0
+			&& nullStatus(flowInfo, flowContext) != FlowInfo.NON_NULL)
+	{
+		flowContext.recordUnboxing(scope, this, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 8d8333f..03c113d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -14,6 +14,7 @@
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 385626 - @NonNull fails across loop boundaries
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -39,7 +40,7 @@ public class FinallyFlowContext extends TryFlowContext {
 	int assignCount;
 
 	// the following three arrays are in sync regarding their indices:
-	LocalVariableBinding[] nullLocals;
+	LocalVariableBinding[] nullLocals; // slots can be null for checkType == IN_UNBOXING
 	ASTNode[] nullReferences;	// Expressions for null checking, Statements for resource analysis
 								// cast to Expression is safe if corresponding nullCheckType != EXIT_RESOURCE
 	int[] nullCheckTypes;
@@ -98,15 +99,21 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	// check inconsistent null checks
 	if ((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0) { // within an enclosing loop, be conservative
 		for (int i = 0; i < this.nullCount; i++) {
-			if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == ASSIGN_TO_NONNULL) {
-				int nullStatus = flowInfo.nullStatus(this.nullLocals[i]);
-				if (nullStatus != FlowInfo.NON_NULL) {
-					this.parent.recordNullityMismatch(scope, (Expression)this.nullReferences[i],
-							this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus);
-				}
-			} else {
-				this.parent.recordUsingNullReference(scope, this.nullLocals[i],
-						this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
+			ASTNode location = this.nullReferences[i];
+			switch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {
+				case ASSIGN_TO_NONNULL:
+					int nullStatus = flowInfo.nullStatus(this.nullLocals[i]);
+					if (nullStatus != FlowInfo.NON_NULL) {
+						this.parent.recordNullityMismatch(scope, (Expression) location,
+								this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus);
+					}
+					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
+				default:
+					this.parent.recordUsingNullReference(scope, this.nullLocals[i],
+							this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
 			}
 
 		}
@@ -195,6 +202,9 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 						scope.problemReporter().nullityMismatch((Expression) location, this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus, annotationName);
 					}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);	
+					break;
 				default:
 					// should not happen
 			}
@@ -423,10 +433,10 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	}
 
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode expression, int status) {
+	ASTNode expression, int checkType) {
 	if (this.nullCount == 0) {
 		this.nullLocals = new LocalVariableBinding[5];
-		this.nullReferences = new Expression[5];
+		this.nullReferences = new ASTNode[5];
 		this.nullCheckTypes = new int[5];
 	}
 	else if (this.nullCount == this.nullLocals.length) {
@@ -435,7 +445,7 @@ protected void recordNullReference(LocalVariableBinding local,
 			this.nullLocals = new LocalVariableBinding[newLength], 0,
 			this.nullCount);
 		System.arraycopy(this.nullReferences, 0,
-			this.nullReferences = new Expression[newLength], 0,
+			this.nullReferences = new ASTNode[newLength], 0,
 			this.nullCount);
 		System.arraycopy(this.nullCheckTypes, 0,
 			this.nullCheckTypes = new int[newLength], 0,
@@ -443,7 +453,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	}
 	this.nullLocals[this.nullCount] = local;
 	this.nullReferences[this.nullCount] = expression;
-	this.nullCheckTypes[this.nullCount++] = status;
+	this.nullCheckTypes[this.nullCount++] = checkType;
+}
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// defer checking:
+	recordNullReference(null, expression, IN_UNBOXING);
 }
 protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 3806cfc..a737f3b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -20,6 +20,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -103,6 +104,8 @@ public static final int CAN_ONLY_NON_NULL = 0x0002;
 public static final int MAY_NULL = 0x0003;
 //check binding a value to a @NonNull variable 
 public final static int ASSIGN_TO_NONNULL = 0x0080;
+//check against an unboxing conversion
+public static final int IN_UNBOXING = 0x0010;
 //check against unclosed resource at early exit:
 public static final int EXIT_RESOURCE = 0x0800;
 // check against null, with potential values -- NPE guard
@@ -748,23 +751,52 @@ protected boolean recordFinalAssignment(VariableBinding variable, Reference fina
 
 /**
  * Record a null reference for use by deferred checks. Only looping or
- * finally contexts really record that information.
+ * finally contexts really record that information. Other contexts
+ * immediately check for unboxing.
  * @param local the local variable involved in the check
  * @param location the location triggering the analysis, for normal null dereference
  *      this is an expression resolving to 'local', for resource leaks it is an
  *      early exit statement.
- * @param status the status against which the check must be performed; one of
+ * @param checkType the checkType against which the check must be performed; one of
  * 		{@link #CAN_ONLY_NULL CAN_ONLY_NULL}, {@link #CAN_ONLY_NULL_NON_NULL
  * 		CAN_ONLY_NULL_NON_NULL}, {@link #MAY_NULL MAY_NULL},
  *      {@link #CAN_ONLY_NON_NULL CAN_ONLY_NON_NULL}, potentially
  *      combined with a context indicator (one of {@link #IN_COMPARISON_NULL},
- *      {@link #IN_COMPARISON_NON_NULL}, {@link #IN_ASSIGNMENT} or {@link #IN_INSTANCEOF})
+ *      {@link #IN_COMPARISON_NON_NULL}, {@link #IN_ASSIGNMENT} or {@link #IN_INSTANCEOF}).
+ *      <br>
+ *      Alternatively, a {@link #IN_UNBOXING} check can e requested.
  */
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode location, int status) {
+	ASTNode location, int checkType) {
 	// default implementation: do nothing
 }
 
+/**
+ * Either AST analysis or checking of a child flow context has encountered an unboxing situation.
+ * Record this fact for handling at an appropriate point in time.
+ */
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// default: handle immediately:
+	checkUnboxing(scope, expression, flowInfo);
+}
+/** During deferred checking re-visit a previously recording unboxing situation. */
+protected void checkUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	int status = expression.nullStatus(flowInfo, this);
+	if ((status & FlowInfo.NULL) != 0) {
+		scope.problemReporter().nullUnboxing(expression, expression.resolvedType);
+		return;
+	} else if ((status & FlowInfo.POTENTIALLY_NULL) != 0) {
+		scope.problemReporter().potentialNullUnboxing(expression, expression.resolvedType);
+		return;
+	} else if ((status & FlowInfo.NON_NULL) != 0) {
+		return;
+	}
+	// not handled, perhaps our parent will eventually have something to say?
+	if (this.parent != null) {
+		this.parent.recordUnboxing(scope, expression, flowInfo);
+	}
+}
+
 public void recordReturnFrom(UnconditionalFlowInfo flowInfo) {
 	// default implementation: do nothing
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 5dcf13a..68eb6c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -16,6 +16,7 @@
  *								bug 385626 - @NonNull fails across loop boundaries
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 376263 - Bogus "Potential null pointer access" warning
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -55,7 +56,7 @@ public class LoopingFlowContext extends SwitchFlowContext {
 	int assignCount = 0;
 
 	// the following three arrays are in sync regarding their indices:
-	LocalVariableBinding[] nullLocals;
+	LocalVariableBinding[] nullLocals; // slots can be null for checkType == IN_UNBOXING
 	ASTNode[] nullReferences;	// Expressions for null checking, Statements for resource analysis
 								// cast to Expression is safe if corresponding nullCheckType != EXIT_RESOURCE
 	int[] nullCheckTypes;
@@ -276,6 +277,9 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 							}
 						}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
 				default:
 					// never happens
 			}
@@ -396,6 +400,9 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						}
 					}
 					break;
+				case IN_UNBOXING:
+					checkUnboxing(scope, (Expression) location, flowInfo);
+					break;
 				default:
 					// never happens
 			}
@@ -518,7 +525,7 @@ public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo)
 	}
 
 protected void recordNullReference(LocalVariableBinding local,
-	ASTNode expression, int status) {
+	ASTNode expression, int checkType) {
 	if (this.nullCount == 0) {
 		this.nullLocals = new LocalVariableBinding[5];
 		this.nullReferences = new ASTNode[5];
@@ -534,7 +541,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	}
 	this.nullLocals[this.nullCount] = local;
 	this.nullReferences[this.nullCount] = expression;
-	this.nullCheckTypes[this.nullCount++] = status;
+	this.nullCheckTypes[this.nullCount++] = checkType;
+}
+public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+	// defer checking:
+	recordNullReference(null, expression, IN_UNBOXING);
 }
 
 /** Record the fact that we see an early exit (in 'reference') while 'trackingVar' is in scope and may be unclosed. */
commit 04ba8714847b0b2ff7093c5cc3d0c90b552f67e9
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Apr 19 01:14:12 2013 +0200

    Bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction
    between unboxing, NPE, and deferred checking
    - uniform checking for all relevant AST nodes

36	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
4	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 606345d..138b822 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -1225,6 +1225,42 @@ public void test0037_autounboxing_4() {
 			"}\n"},
 		options);
 }
+// https://bugs.eclipse.org/403147 [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+// array reference in nested try
+public void test0037_autounboxing_5() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return;
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"		void foo(Object [] o, boolean b, Integer i) {\n" + 
+			"		int j = 1;\n" + 
+			"		try {\n" + 
+			"			if (b) i = null;\n" + 
+			"		} catch (RuntimeException r) {\n" + 
+			"			i = 3;\n" + 
+			"		} finally {\n" + 
+			"			try {\n" + 
+			"				System.out.println(o[i]);  \n" + 
+			"			} finally {\n" + 
+			"				System.out.println(j);\n" + 
+			"			}\n" + 
+			"		}\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	System.out.println(o[i]);  \n" + 
+		"	                     ^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
index 8ae057c..6d10931 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -67,12 +68,8 @@ public class AND_AND_Expression extends BinaryExpression {
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
 		if ((flowContext.tagBits & FlowContext.INSIDE_NEGATION) != 0)
 			flowContext.expireNullCheckedFieldInfo();
-		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.left.checkNPE(currentScope, flowContext, flowInfo);
-		}
-		if ((this.right.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.right.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.left.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
+		this.right.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		FlowInfo mergedInfo = FlowInfo.conditional(
 				rightInfo.safeInitsWhenTrue(),
 				leftInfo.initsWhenFalse().unconditionalInits().mergedWith(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index f05f3ea..2067bb6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -21,6 +21,7 @@
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement - Contributions for
@@ -72,9 +73,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			if (analyseResources && !hasResourceWrapperType) { // allocation of wrapped closeables is analyzed specially
 				flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 			}
-			if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-				this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-			}
+			this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index 2022890..9bb15e8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -38,9 +39,7 @@ public class ArrayAllocationExpression extends Expression {
 			Expression dim;
 			if ((dim = this.dimensions[i]) != null) {
 				flowInfo = dim.analyseCode(currentScope, flowContext, flowInfo);
-				if ((dim.implicitConversion & TypeIds.UNBOXING) != 0) {
-					dim.checkNPE(currentScope, flowContext, flowInfo);
-				}
+				dim.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 		}
 		// account for potential OutOfMemoryError:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index 1f5c4d2..4c896b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -66,6 +67,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.receiver.checkNPE(currentScope, flowContext, flowInfo);
 	flowInfo = this.receiver.analyseCode(currentScope, flowContext, flowInfo);
 	flowInfo = this.position.analyseCode(currentScope, flowContext, flowInfo);
+	this.position.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	// account for potential ArrayIndexOutOfBoundsException:
 	flowContext.recordAbruptExit();
 	return flowInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
index 7cc168b..17cbc01 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
@@ -11,6 +11,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -47,9 +48,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.preAssertInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);
 
 	Constant cst = this.assertExpression.optimizedBooleanConstant();
-	if ((this.assertExpression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.assertExpression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.assertExpression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
 	boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index f2199f8..6385def 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -28,6 +28,7 @@
  *							bug 331649 - [compiler][null] consider null annotations for fields
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+ *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -59,9 +60,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 // a field reference, a blank final field reference, a field of an enclosing instance or
 // just a local variable.
 	LocalVariableBinding local = this.lhs.localVariableBinding();
-	if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.expression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	
 	FlowInfo preInitInfo = null;
 	CompilerOptions compilerOptions = currentScope.compilerOptions();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index 6a76c3e..267ba15 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -83,9 +84,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 										actionInfo.mergedWith(loopingContext.initsOnContinue));
 		}
 	}
-	if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.condition.checkNPE(currentScope, flowContext, initsOnCondition);
-	}
+	this.condition.checkNPEbyUnboxing(currentScope, flowContext, initsOnCondition);
 	/* Reset reach mode, to address following scenario.
 	 *   final blank;
 	 *   do { if (true) break; else blank = 0; } while(false);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index f6202d5..89b0e42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -17,6 +17,7 @@
  *								bug 361407 - Resource leak warning when resource is assigned to a field outside of constructor
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -91,9 +92,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 						// if argument is an AutoCloseable insert info that it *may* be closed (by the target constructor, i.e.)
 						flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 					}
-					if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-						this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-					}
+					this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 				}
 				analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index c5437e8..8b6189a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -591,11 +591,12 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 
 /** If this expression requires unboxing check if that operation can throw NPE. */
 protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	int status;
 	if ((this.implicitConversion & UNBOXING) != 0
 			&& (this.bits & ASTNode.IsNonNull) == 0
-			&& nullStatus(flowInfo, flowContext) != FlowInfo.NON_NULL)
+			&& (status = nullStatus(flowInfo, flowContext)) != FlowInfo.NON_NULL)
 	{
-		flowContext.recordUnboxing(scope, this, flowInfo);
+		flowContext.recordUnboxing(scope, this, status, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index 88948bb..37dac8e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -96,9 +97,7 @@ public class ForStatement extends Statement {
 							new LoopingFlowContext(flowContext, flowInfo, this, null,
 								null, this.scope, true)),
 						condInfo);
-				if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-					this.condition.checkNPE(currentScope, flowContext, flowInfo);
-				}
+				this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 0521cb4..254ff71 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -62,9 +63,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	int initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;
 
 	Constant cst = this.condition.optimizedBooleanConstant();
-	if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.condition.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
 	boolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 9825fb7..b379cf5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -32,6 +32,7 @@
  *								bug 382350 - [1.8][compiler] Unable to invoke inherited default method via I.super.m() syntax
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement - Contributions for
@@ -137,9 +138,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		int length = this.arguments.length;
 		for (int i = 0; i < length; i++) {
 			Expression argument = this.arguments[i];
-			if ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {
-				argument.checkNPE(currentScope, flowContext, flowInfo);
-			}
+			argument.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			switch (detectAssertionUtility(i)) {
 				case TRUE_ASSERTION:
 					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 4d05409..5e81242 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -72,12 +73,8 @@ public class OR_OR_Expression extends BinaryExpression {
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
 		if ((flowContext.tagBits & FlowContext.INSIDE_NEGATION) == 0)
 			flowContext.expireNullCheckedFieldInfo();
-		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.left.checkNPE(currentScope, flowContext, flowInfo);
-		}
-		if ((this.right.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.right.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.left.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
+		this.right.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		// The definitely null variables in right info when true should not be missed out while merging
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=299900
 		FlowInfo leftInfoWhenTrueForMerging = leftInfo.initsWhenTrue().unconditionalCopy().addPotentialInitializationsFrom(rightInfo.unconditionalInitsWithoutSideEffect());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 4c80495..ec3a54f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -20,6 +20,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement - Contributions for
@@ -108,9 +109,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)
 					flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, flowContext, false);
 				}
-				if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-					this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
-				}
+				this.arguments[i].checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 			}
 			analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 54b3a16..837f432 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -67,9 +68,7 @@ public class WhileStatement extends Statement {
 					new LoopingFlowContext(flowContext, flowInfo, this, null,
 						null, currentScope, true)),
 				condInfo);
-		if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.condition.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.condition.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 
 		LoopingFlowContext loopingContext;
 		FlowInfo actionInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 03c113d..d918879 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -455,9 +455,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = checkType;
 }
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
-	// defer checking:
-	recordNullReference(null, expression, IN_UNBOXING);
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
+	if (nullStatus == FlowInfo.NULL)
+		super.recordUnboxing(scope, expression, nullStatus, flowInfo);
+	else // defer checking:
+		recordNullReference(null, expression, IN_UNBOXING);
 }
 protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index a737f3b..4804eec 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -774,8 +774,9 @@ protected void recordNullReference(LocalVariableBinding local,
 /**
  * Either AST analysis or checking of a child flow context has encountered an unboxing situation.
  * Record this fact for handling at an appropriate point in time.
+ * @param nullStatus the status as we know it so far.
  */
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
 	// default: handle immediately:
 	checkUnboxing(scope, expression, flowInfo);
 }
@@ -793,7 +794,7 @@ protected void checkUnboxing(Scope scope, Expression expression, FlowInfo flowIn
 	}
 	// not handled, perhaps our parent will eventually have something to say?
 	if (this.parent != null) {
-		this.parent.recordUnboxing(scope, expression, flowInfo);
+		this.parent.recordUnboxing(scope, expression, FlowInfo.UNKNOWN, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 68eb6c8..53f9c0a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -543,9 +543,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = checkType;
 }
-public void recordUnboxing(Scope scope, Expression expression, FlowInfo flowInfo) {
-	// defer checking:
-	recordNullReference(null, expression, IN_UNBOXING);
+public void recordUnboxing(Scope scope, Expression expression, int nullStatus, FlowInfo flowInfo) {
+	if (nullStatus == FlowInfo.NULL)
+		super.recordUnboxing(scope, expression, nullStatus, flowInfo);
+	else // defer checking:
+		recordNullReference(null, expression, IN_UNBOXING);
 }
 
 /** Record the fact that we see an early exit (in 'reference') while 'trackingVar' is in scope and may be unclosed. */
