commit 6612336f81825afdf894aa053e2e886c83842e87
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Nov 26 12:49:31 2013 +0530

    Fixed Bug 422489 - [1.8][compiler] NPE in CompoundAssignment.analyseCode
    when creating AST for java.util.stream.Collectors

2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
345	55	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
15	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
30	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
68	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
1	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ReferenceContext.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
2	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
3	3	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index e32467f..afa384e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -930,6 +930,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ReturnTypeCannotBeVoidArray", DEPRECATED);
 		expectedProblemAttributes.put("ReturnTypeInheritedNameHidesEnclosingName", DEPRECATED);
 		expectedProblemAttributes.put("ReturnTypeInternalNameProvided", DEPRECATED);
+		expectedProblemAttributes.put("ReturnTypeMismatch", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ReturnTypeNotFound", DEPRECATED);
 		expectedProblemAttributes.put("ReturnTypeNotVisible", DEPRECATED);
 		expectedProblemAttributes.put("SafeVarargsOnFixedArityMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1738,6 +1739,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ReturnTypeCannotBeVoidArray", SKIP);
 		expectedProblemAttributes.put("ReturnTypeInheritedNameHidesEnclosingName", SKIP);
 		expectedProblemAttributes.put("ReturnTypeInternalNameProvided", SKIP);
+		expectedProblemAttributes.put("ReturnTypeMismatch", SKIP);
 		expectedProblemAttributes.put("ReturnTypeNotFound", SKIP);
 		expectedProblemAttributes.put("ReturnTypeNotVisible", SKIP);
 		expectedProblemAttributes.put("SafeVarargsOnFixedArityMethod", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index 8d9dd97..b9789f3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -5051,6 +5051,12 @@ this.runNegativeTest(
 				"----------\n" + 
 				"1. ERROR in X.java (at line 20)\n" + 
 				"	new X().foo((s)->{});\n" + 
+				"	        ^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments ((<no type> s) -> {\n" + 
+				"})\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 20)\n" + 
+				"	new X().foo((s)->{});\n" + 
 				"	            ^^^^^^^\n" + 
 				"Lambda expression\'s signature does not match the signature of the functional interface method\n" + 
 				"----------\n");
@@ -5076,7 +5082,7 @@ this.runNegativeTest(
 				"	public static void main(String[] args) {\n" +
 				"		new X().foo(()->{ return \"\";});\n" +
 				"		new X().foo(()-> 10);\n" +
-				"		new X().foo((s)->{});\n" +
+				"		new X().foo((s)->{});\n" +    // error not reported here, since analyzeCode does not get to run.
 				"		new X().foo((s)->{ return;});\n" +
 				"		new X().foo((s)->{ return \"\";});\n" +
 				"		new X().foo((s)-> \"hello\");\n" +
@@ -5088,23 +5094,30 @@ this.runNegativeTest(
 				"----------\n" + 
 				"1. ERROR in X.java (at line 15)\n" + 
 				"	new X().foo(()->{ return \"\";});\n" + 
+				"	        ^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments (() -> {\n" + 
+				"  return \"\";\n" + 
+				"})\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 15)\n" + 
+				"	new X().foo(()->{ return \"\";});\n" + 
 				"	                  ^^^^^^^^^^\n" + 
 				"Void methods cannot return a value\n" + 
 				"----------\n" + 
-				"2. ERROR in X.java (at line 16)\n" + 
+				"3. ERROR in X.java (at line 16)\n" + 
+				"	new X().foo(()-> 10);\n" + 
+				"	        ^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments (() -> 10)\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 16)\n" + 
 				"	new X().foo(()-> 10);\n" + 
 				"	                 ^^\n" + 
 				"Void methods cannot return a value\n" + 
 				"----------\n" + 
-				"3. ERROR in X.java (at line 17)\n" + 
-				"	new X().foo((s)->{});\n" + 
-				"	            ^^^^^^^\n" + 
-				"Lambda expression\'s signature does not match the signature of the functional interface method\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 18)\n" + 
+				"5. ERROR in X.java (at line 18)\n" + 
 				"	new X().foo((s)->{ return;});\n" + 
-				"	            ^^^^^^^^^^^^^^^\n" + 
-				"Lambda expression\'s signature does not match the signature of the functional interface method\n" + 
+				"	                   ^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610, [1.8][compiler] Allow lambda/reference expressions in non-overloaded method invocation contexts
@@ -5217,6 +5230,13 @@ this.runNegativeTest(
 				"----------\n" + 
 				"1. ERROR in X.java (at line 11)\n" + 
 				"	new X().foo(()->{ return 10; });\n" + 
+				"	        ^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments (() -> {\n" + 
+				"  return 10;\n" + 
+				"})\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	new X().foo(()->{ return 10; });\n" + 
 				"	                  ^^^^^^^^^^\n" + 
 				"Void methods cannot return a value\n" + 
 				"----------\n");
@@ -5266,6 +5286,12 @@ this.runNegativeTest(
 				"----------\n" + 
 				"1. ERROR in X.java (at line 11)\n" + 
 				"	new X().foo((Object o)->{});\n" + 
+				"	        ^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments ((Object o) -> {\n" + 
+				"})\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	new X().foo((Object o)->{});\n" + 
 				"	             ^^^^^^\n" + 
 				"Lambda expression\'s parameter o is expected to be of type int\n" + 
 				"----------\n");
@@ -5358,45 +5384,65 @@ this.runNegativeTest(
 				"----------\n" + 
 				"1. ERROR in X.java (at line 9)\n" + 
 				"	this(X::goo);\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"The constructor X.Y(X::goo) is undefined\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 9)\n" + 
+				"	this(X::goo);\n" + 
 				"	     ^^^^^^\n" + 
 				"The type of goo() from the type X is int, this is incompatible with the descriptor\'s return type: String\n" + 
 				"----------\n" + 
-				"2. ERROR in X.java (at line 14)\n" + 
+				"3. ERROR in X.java (at line 14)\n" + 
 				"	this((x) -> { return 10;});\n" + 
 				"	                     ^^\n" + 
 				"Type mismatch: cannot convert from int to String\n" + 
 				"----------\n" + 
-				"3. ERROR in X.java (at line 18)\n" + 
+				"4. ERROR in X.java (at line 18)\n" + 
+				"	foo(X::goo);\n" + 
+				"	^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments (X::goo)\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 18)\n" + 
 				"	foo(X::goo);\n" + 
 				"	    ^^^^^^\n" + 
 				"The type of goo() from the type X is int, this is incompatible with the descriptor\'s return type: String\n" + 
 				"----------\n" + 
-				"4. ERROR in X.java (at line 19)\n" + 
+				"6. ERROR in X.java (at line 19)\n" + 
 				"	new X((x)->{ return 10;});\n" + 
 				"	                    ^^\n" + 
 				"Type mismatch: cannot convert from int to String\n" + 
 				"----------\n" + 
-				"5. ERROR in X.java (at line 20)\n" + 
+				"7. ERROR in X.java (at line 20)\n" + 
 				"	new X((x)->{ return 10;}).new Y((x) -> { return 0;});\n" + 
 				"	                    ^^\n" + 
 				"Type mismatch: cannot convert from int to String\n" + 
 				"----------\n" + 
-				"6. ERROR in X.java (at line 21)\n" + 
+				"8. ERROR in X.java (at line 20)\n" + 
+				"	new X((x)->{ return 10;}).new Y((x) -> { return 0;});\n" + 
+				"	                                                ^\n" + 
+				"Type mismatch: cannot convert from int to String\n" + 
+				"----------\n" + 
+				"9. ERROR in X.java (at line 21)\n" + 
 				"	new X((x)->{ return 10;}) {};\n" + 
 				"	                    ^^\n" + 
 				"Type mismatch: cannot convert from int to String\n" + 
 				"----------\n" + 
-				"7. ERROR in X.java (at line 26)\n" + 
+				"10. ERROR in X.java (at line 26)\n" + 
+				"	super(X::goo);\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"The constructor X(X::goo) is undefined\n" + 
+				"----------\n" + 
+				"11. ERROR in X.java (at line 26)\n" + 
 				"	super(X::goo);\n" + 
 				"	      ^^^^^^\n" + 
 				"The type of goo() from the type X is int, this is incompatible with the descriptor\'s return type: String\n" + 
 				"----------\n" + 
-				"8. ERROR in X.java (at line 29)\n" + 
+				"12. ERROR in X.java (at line 29)\n" + 
 				"	super (x -> 10);\n" + 
 				"	            ^^\n" + 
 				"Type mismatch: cannot convert from int to String\n" + 
 				"----------\n" + 
-				"9. ERROR in X.java (at line 31)\n" + 
+				"13. ERROR in X.java (at line 31)\n" + 
 				"	Zork z;\n" + 
 				"	^^^^\n" + 
 				"Zork cannot be resolved to a type\n" + 
@@ -5446,10 +5492,22 @@ public void test401845a() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 8)\n" + 
 			"	foo(X::goo);\n" + 
+			"	^^^\n" + 
+			"The method foo(I[]...) in the type X is not applicable for the arguments (X::goo)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 8)\n" + 
+			"	foo(X::goo);\n" + 
 			"	    ^^^^^^\n" + 
 			"The target type of this expression must be a functional interface\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 9)\n" + 
+			"3. ERROR in X.java (at line 9)\n" + 
+			"	foo((x)-> {return 10;});\n" + 
+			"	^^^\n" + 
+			"The method foo(I[]...) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
+			"  return 10;\n" + 
+			"})\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 9)\n" + 
 			"	foo((x)-> {return 10;});\n" + 
 			"	    ^^^^^^^^^^^^^^^^^^\n" + 
 			"The target type of this expression must be a functional interface\n" + 
@@ -5608,20 +5666,25 @@ public void test401847a() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 8)\n" + 
 			"	foo(true ? X::goo : X::goo);\n" + 
+			"	^^^\n" + 
+			"The method foo(I...) in the type X is not applicable for the arguments ((true ? X::goo : X::goo))\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 8)\n" + 
+			"	foo(true ? X::goo : X::goo);\n" + 
 			"	           ^^^^^^\n" + 
 			"The type of goo() from the type X is int, this is incompatible with the descriptor\'s return type: String\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 8)\n" + 
+			"3. ERROR in X.java (at line 8)\n" + 
 			"	foo(true ? X::goo : X::goo);\n" + 
 			"	                    ^^^^^^\n" + 
 			"The type of goo() from the type X is int, this is incompatible with the descriptor\'s return type: String\n" + 
 			"----------\n" + 
-			"3. ERROR in X.java (at line 9)\n" + 
+			"4. ERROR in X.java (at line 9)\n" + 
 			"	foo(true ? x-> 1 : x->0);\n" + 
 			"	               ^\n" + 
 			"Type mismatch: cannot convert from int to String\n" + 
 			"----------\n" + 
-			"4. ERROR in X.java (at line 9)\n" + 
+			"5. ERROR in X.java (at line 9)\n" + 
 			"	foo(true ? x-> 1 : x->0);\n" + 
 			"	                      ^\n" + 
 			"Type mismatch: cannot convert from int to String\n" + 
@@ -5711,32 +5774,58 @@ public void test401939b() {
 				"----------\n" + 
 				"1. ERROR in X.java (at line 14)\n" + 
 				"	goo((x) -> { while (FALSE) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"  while (FALSE)    throw new Exception();\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n" + 
-				"2. ERROR in X.java (at line 17)\n" + 
+				"2. ERROR in X.java (at line 14)\n" + 
+				"	goo((x) -> { while (FALSE) throw new Exception(); });\n" + 
+				"	                           ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Unreachable code\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 17)\n" + 
 				"	goo((x) -> { while (POI) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"  while (POI)    throw new Exception();\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n" + 
-				"3. ERROR in X.java (at line 19)\n" + 
+				"4. ERROR in X.java (at line 17)\n" + 
+				"	goo((x) -> { while (POI) throw new Exception(); });\n" + 
+				"	                         ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Unreachable code\n" + 
+				"----------\n" + 
+				"5. WARNING in X.java (at line 18)\n" + 
+				"	goo((x) -> { if (TRUE) throw new Exception(); else throw new Exception(); });\n" + 
+				"	                                                   ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+				"----------\n" + 
+				"6. ERROR in X.java (at line 19)\n" + 
 				"	goo((x) -> { if (TRUE) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"  if (TRUE)\n" + 
-				"      throw new Exception();\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
+				"----------\n" + 
+				"7. WARNING in X.java (at line 20)\n" + 
+				"	goo((x) -> { if (true) throw new Exception(); else throw new Exception(); });\n" + 
+				"	                                                   ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
 				"----------\n" + 
-				"4. ERROR in X.java (at line 22)\n" + 
+				"8. WARNING in X.java (at line 20)\n" + 
+				"	goo((x) -> { if (true) throw new Exception(); else throw new Exception(); });\n" + 
+				"	                                                   ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Dead code\n" + 
+				"----------\n" + 
+				"9. WARNING in X.java (at line 21)\n" + 
+				"	goo((x) -> { if (false) throw new Exception(); else throw new Exception(); });\n" + 
+				"	                        ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Dead code\n" + 
+				"----------\n" + 
+				"10. WARNING in X.java (at line 21)\n" + 
+				"	goo((x) -> { if (false) throw new Exception(); else throw new Exception(); });\n" + 
+				"	                                                    ^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+				"----------\n" + 
+				"11. ERROR in X.java (at line 22)\n" + 
 				"	goo((x) -> { while (BLANK) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"  while (BLANK)    throw new Exception();\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=401939, [1.8][compiler] Incorrect shape analysis leads to method resolution failure .
@@ -5760,12 +5849,28 @@ public void test401939c() {
 				"	goo((x) -> { if (x) return null; });\n" + 
 				"	                 ^\n" + 
 				"Type mismatch: cannot convert from String to boolean\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=401939, [1.8][compiler] Incorrect shape analysis leads to method resolution failure .
+public void test401939ca() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"    String foo(String x) throws Exception;\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	void goo(I i) {\n" +
+				"	}\n" +
+				"	void zoo() {\n" +
+				"		goo((x) -> {});\n" +
+				"	}\n" +
+				"}\n",			},
 				"----------\n" + 
-				"2. ERROR in X.java (at line 9)\n" + 
+				"1. ERROR in X.java (at line 8)\n" + 
 				"	goo((x) -> {});\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=401939, [1.8][compiler] Incorrect shape analysis leads to method resolution failure .
@@ -5786,11 +5891,8 @@ public void test401939d() {
 				"----------\n" + 
 				"1. ERROR in X.java (at line 8)\n" + 
 				"	goo((x) -> { if (x) return null; });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {\n" + 
-				"  if (x)\n" + 
-				"      return null;\n" + 
-				"})\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
 				"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=401939, [1.8][compiler] Incorrect shape analysis leads to method resolution failure .
@@ -5886,6 +5988,11 @@ public void test402219a() {
 				"----------\n" + 
 				"1. ERROR in X.java (at line 11)\n" + 
 				"	new X().goo((p1, p2) -> {});\n" + 
+				"	        ^^^\n" + 
+				"The method goo(I) is ambiguous for the type X\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	new X().goo((p1, p2) -> {});\n" + 
 				"	                        ^^\n" + 
 				"Empty block should be documented\n" + 
 				"----------\n",
@@ -6108,6 +6215,11 @@ public void test402609() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 18)\n" + 
 			"	f(super::foo);\n" + 
+			"	^\n" + 
+			"The method f(I) in the type X is not applicable for the arguments (super::foo)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 18)\n" + 
+			"	f(super::foo);\n" + 
 			"	  ^^^^^\n" + 
 			"Cannot use super in a static context\n" + 
 			"----------\n");
@@ -6739,6 +6851,11 @@ public void test412453() {
 		"----------\n" + 
 		"1. ERROR in X.java (at line 13)\n" + 
 		"	final Optional<Integer> min = empty.minBy((a, b) -> a - b);\n" + 
+		"	                                    ^^^^^\n" + 
+		"The method minBy(Function<Integer,C>) in the type Y<Integer> is not applicable for the arguments ((<no type> a, <no type> b) -> (a - b))\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	final Optional<Integer> min = empty.minBy((a, b) -> a - b);\n" + 
 		"	                                          ^^^^^^^^^^^^^^^\n" + 
 		"Lambda expression\'s signature does not match the signature of the functional interface method\n" + 
 		"----------\n",
@@ -6882,10 +6999,15 @@ public void test412650() {
 				"}\n"
 		},
 		"----------\n" + 
-		"1. ERROR in X.java (at line 7)\n" +
-		"	foo(() -> foo(X::getInt));\n" +
-		"	              ^^^^^^^^^\n" +
-		"The type of getInt() from the type X is Integer, this is incompatible with the descriptor's return type: String\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	foo(() -> foo(X::getInt));\n" + 
+		"	          ^^^\n" + 
+		"The method foo(I) in the type X is not applicable for the arguments (X::getInt)\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	foo(() -> foo(X::getInt));\n" + 
+		"	              ^^^^^^^^^\n" + 
+		"The type of getInt() from the type X is Integer, this is incompatible with the descriptor\'s return type: String\n" + 
 		"----------\n",
 		null /* no extra class libraries */,
 		true /* flush output directory */,
@@ -7291,6 +7413,174 @@ public void test422516a() {
 			"----------\n"
 		);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489, [1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors
+public void test422489() {
+	this.runNegativeTest(
+			new String[] {
+					"X.java", 
+					"interface I {\n" +
+					"	void foo(String [] x, String y);\n" +
+					"}\n" +
+					"interface J {\n" +
+					"	void foo(int x, int y);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"    static void goo(I i) {\n" +
+					"    }\n" +
+					"    static void goo(J j) {\n" +
+					"    }\n" +
+					"    public static void main(String[] args) throws InterruptedException {\n" +
+					"		goo((x, y) -> { x[0] += 1; });\n" +
+					"    }\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> { x[0] += 1; });\n" + 
+			"	^^^\n" + 
+			"The method goo(I) is ambiguous for the type X\n" + 
+			"----------\n"
+		);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489, [1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors
+public void test422489a() { // interfaces and methods order changed, triggers NPE.
+	this.runNegativeTest(
+			new String[] {
+					"X.java", 
+					"interface J {\n" +
+					"	void foo(int x, int y);\n" +
+					"}\n" +
+					"interface I {\n" +
+					"	void foo(String [] x, String y);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"    static void goo(J j) {\n" +
+					"    }\n" +
+					"    static void goo(I i) {\n" +
+					"    }\n" +
+					"    public static void main(String[] args) throws InterruptedException {\n" +
+					"		goo((x, y) -> { x[0] += 1; });\n" +
+					"    }\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> { x[0] += 1; });\n" + 
+			"	^^^\n" + 
+			"The method goo(J) is ambiguous for the type X\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> { x[0] += 1; });\n" + 
+			"	                ^^^^\n" + 
+			"The type of the expression must be an array type but it resolved to int\n" + 
+			"----------\n"
+		);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489, [1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors
+public void test422489b() { // interfaces and methods order changed, triggers NPE.
+	this.runNegativeTest(
+			new String[] {
+					"X.java", 
+					"interface I {\n" +
+					"	String foo(String [] x, String y);\n" +
+					"}\n" +
+					"interface J {\n" +
+					"	void foo(int x, int y);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"    static void goo(J j) {\n" +
+					"    }\n" +
+					"    static void goo(I i) {\n" +
+					"    }\n" +
+					"    public static void main(String[] args) throws InterruptedException {\n" +
+					"		goo((x, y) -> { return x[0] += 1; });\n" +
+					"    }\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> { return x[0] += 1; });\n" + 
+			"	^^^\n" + 
+			"The method goo(J) is ambiguous for the type X\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> { return x[0] += 1; });\n" + 
+			"	                       ^^^^\n" + 
+			"The type of the expression must be an array type but it resolved to int\n" + 
+			"----------\n"
+		);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489, [1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors
+public void test422489c() { // interfaces and methods order changed, triggers NPE.
+	this.runNegativeTest(
+			new String[] {
+					"X.java", 
+					"interface I {\n" +
+					"	String foo(String [] x, String y);\n" +
+					"}\n" +
+					"interface J {\n" +
+					"	void foo(int x, int y);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"    static void goo(J j) {\n" +
+					"    }\n" +
+					"    static void goo(I i) {\n" +
+					"    }\n" +
+					"    public static void main(String[] args) throws InterruptedException {\n" +
+					"		goo((x, y) -> x[0] += 1);\n" +
+					"    }\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> x[0] += 1);\n" + 
+			"	^^^\n" + 
+			"The method goo(J) is ambiguous for the type X\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> x[0] += 1);\n" + 
+			"	              ^^^^\n" + 
+			"The type of the expression must be an array type but it resolved to int\n" + 
+			"----------\n"
+		);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489, [1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors
+public void test422489d() { // interfaces and methods order changed, triggers NPE.
+	this.runNegativeTest(
+			new String[] {
+					"X.java", 
+					"interface I {\n" +
+					"	String foo(String x, String y);\n" +
+					"}\n" +
+					"interface J {\n" +
+					"	void foo(int x, int y);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"    static void goo(J j) {\n" +
+					"    }\n" +
+					"    static void goo(I i) {\n" +
+					"    }\n" +
+					"    public static void main(String[] args) throws InterruptedException {\n" +
+					"		goo((x, y) -> x[0] += 1);\n" +
+					"    }\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> x[0] += 1);\n" + 
+			"	^^^\n" + 
+			"The method goo(J) is ambiguous for the type X\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 13)\n" + 
+			"	goo((x, y) -> x[0] += 1);\n" + 
+			"	              ^^^^\n" + 
+			"The type of the expression must be an array type but it resolved to int\n" + 
+			"----------\n"
+		);
+}
+
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 9437588..9ec77e3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -3290,10 +3290,24 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n" + 
 			"1. WARNING in X.java (at line 5)\n" + 
 			"	Collections.sort(new ArrayList(), (o1, o2) -> {\n" + 
+			"			return o1.compareToIgnoreCase(o1);\n" + 
+			"		});\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation sort(ArrayList, (<no type> o1, <no type> o2) -> {\n" + 
+			"  return o1.compareToIgnoreCase(o1);\n" + 
+			"}) of the generic method sort(List<T>, Comparator<? super T>) of type Collections\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 5)\n" + 
+			"	Collections.sort(new ArrayList(), (o1, o2) -> {\n" + 
+			"	                 ^^^^^^^^^^^^^^^\n" + 
+			"Type safety: The expression of type ArrayList needs unchecked conversion to conform to List<Object>\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 5)\n" + 
+			"	Collections.sort(new ArrayList(), (o1, o2) -> {\n" + 
 			"	                     ^^^^^^^^^\n" + 
 			"ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 6)\n" + 
+			"4. ERROR in X.java (at line 6)\n" + 
 			"	return o1.compareToIgnoreCase(o1);\n" + 
 			"	          ^^^^^^^^^^^^^^^^^^^\n" + 
 			"The method compareToIgnoreCase(Object) is undefined for the type Object\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
index 8771baf..c524b47 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
@@ -250,6 +250,11 @@ public void test007() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 9)\n" + 
 			"	goo(()-> 10); \n" + 
+			"	^^^\n" + 
+			"The method goo(J) in the type X is not applicable for the arguments (() -> 10)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 9)\n" + 
+			"	goo(()-> 10); \n" + 
 			"	         ^^\n" + 
 			"Void methods cannot return a value\n" + 
 			"----------\n");
@@ -843,6 +848,11 @@ public void test029() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 17)\n" + 
 			"	foo(X []::new);\n" + 
+			"	^^^\n" + 
+			"The method foo(I) in the type X is not applicable for the arguments (X[]::new)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 17)\n" + 
+			"	foo(X []::new);\n" + 
 			"	    ^^^^^^^^^\n" + 
 			"Constructed array X[] cannot be assigned to Y[] as required in the interface descriptor  \n" + 
 			"----------\n");
@@ -1269,6 +1279,11 @@ public void test4008712g() {
 			"----------\n" + 
 			"2. ERROR in X.java (at line 20)\n" + 
 			"	goo(new X()::foo);\n" + 
+			"	^^^\n" + 
+			"The method goo(I) in the type X is not applicable for the arguments (new X()::foo)\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 20)\n" + 
+			"	goo(new X()::foo);\n" + 
 			"	    ^^^^^^^^^^^^\n" + 
 			"The type X does not define foo(int) that is applicable here\n" + 
 			"----------\n");
@@ -1707,6 +1722,11 @@ public void test4008712u() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 20)\n" + 
 			"	goo(I::clone);\n" + 
+			"	^^^\n" + 
+			"The method goo(I) in the type X<T> is not applicable for the arguments (I::clone)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 20)\n" + 
+			"	goo(I::clone);\n" + 
 			"	    ^^^^^^^^\n" + 
 			"The type I does not define clone() that is applicable here\n" + 
 			"----------\n");
@@ -1772,6 +1792,11 @@ public void test4008712w() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 21)\n" + 
 			"	goo(i::clone);\n" + 
+			"	^^^\n" + 
+			"The method goo(I) in the type X<T> is not applicable for the arguments (i::clone)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 21)\n" + 
+			"	goo(i::clone);\n" + 
 			"	    ^^^^^^^^\n" + 
 			"The type I does not define clone() that is applicable here\n" + 
 			"----------\n");
@@ -1938,6 +1963,11 @@ public void test4008712zc() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 16)\n" + 
 			"	goo(new X()::foo);\n" + 
+			"	^^^\n" + 
+			"The method goo(I) in the type X is not applicable for the arguments (new X()::foo)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 16)\n" + 
+			"	goo(new X()::foo);\n" + 
 			"	    ^^^^^^^^^^^^\n" + 
 			"The type of foo() from the type X is long, this is incompatible with the descriptor\'s return type: int\n" + 
 			"----------\n");
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 33bd8dee..31d986b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -376,6 +376,9 @@ void setSourceStart(int sourceStart);
 	int TypeMismatch = TypeRelated + 17;
 	/** @since 3.0 */
 	int IndirectAccessToStaticType = Internal + TypeRelated + 18;
+	
+	/** @since 3.9 BETA_JAVA8 */
+	int ReturnTypeMismatch = TypeRelated + 19;
 
 	/**
 	 * Inner types related problems
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index fd1538a..bc1870a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -624,7 +624,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		return output;
 	}
 
-	public static boolean polyExpressionsHaveErrors(BlockScope scope, MethodBinding methodBinding, Expression [] arguments, TypeBinding[] argumentTypes) {
+	public static boolean resolvePolyExpressionArguments(BlockScope scope, MethodBinding methodBinding, Expression [] arguments, TypeBinding[] argumentTypes) {
 		boolean polyExpressionsHaveErrors = false;
 		MethodBinding candidateMethod;
 		if (methodBinding.isValidBinding()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 06f837d..28ca2d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -630,6 +630,10 @@ public abstract class AbstractMethodDeclaration
 		this.ignoreFurtherInvestigation = true;
 	}
 	
+	public void tagAsHavingIgnoredMandatoryErrors(int problemId) {
+		// Nothing to do for this context;
+	}
+
 	public void traverse(
 		ASTVisitor visitor,
 		ClassScope classScope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 54bdd82..df28bc3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -444,8 +444,8 @@ public TypeBinding resolveType(BlockScope scope) {
 	
 	ReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;
 	this.binding = scope.getConstructor(allocationType, argumentTypes, this);
-	if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-		return null;
+	if (polyExpressionSeen) 
+		resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
 	
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index afb4ce3..4c896b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -54,7 +54,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			currentScope,
 			flowContext,
 			analyseCode(currentScope, flowContext, flowInfo).unconditionalInits());
-	if (this.resolvedType != null && (this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
+	if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
 		int nullStatus = assignment.expression.nullStatus(flowInfo, flowContext);
 		if (nullStatus != FlowInfo.NON_NULL) {
 			currentScope.problemReporter().nullityMismatch(this, assignment.expression.resolvedType, this.resolvedType, nullStatus, currentScope.environment().getNonNullAnnotationName());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index ed00510..9a08907 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -681,6 +681,10 @@ public void tagAsHavingErrors() {
 	this.ignoreFurtherInvestigation = true;
 }
 
+public void tagAsHavingIgnoredMandatoryErrors(int problemId) {
+	// Nothing to do for this context;
+}
+
 public void traverse(ASTVisitor visitor, CompilationUnitScope unitScope) {
 	if (this.ignoreFurtherInvestigation)
 		return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 53fc31e..64b7a23 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -649,8 +649,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		this.expressionContext = context;
 	}
 	
-	public boolean isPertinentToApplicability() {
-		return this.valueIfTrue.isPertinentToApplicability() && this.valueIfFalse.isPertinentToApplicability();
+	public boolean isPertinentToApplicability(TypeBinding targetType) {
+		return this.valueIfTrue.isPertinentToApplicability(targetType) && this.valueIfFalse.isPertinentToApplicability(targetType);
 	}
 	
 	public boolean isPolyExpression() throws UnsupportedOperationException {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 77276ee..9e5ada6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -418,8 +418,9 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 				return;
 			}
 			this.binding = scope.getConstructor(receiverType, argumentTypes, this);
-			if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-				return;
+			if (polyExpressionSeen)
+				resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
+				
 			if (this.binding.isValidBinding()) {
 				if ((this.binding.tagBits & TagBits.HasMissingType) != 0) {
 					if (!methodScope.enclosingSourceType().isAnonymousType()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 0a76b15..aa5816a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -949,7 +949,7 @@ public Constant optimizedBooleanConstant() {
 	return this.constant;
 }
 
-public boolean isPertinentToApplicability() {
+public boolean isPertinentToApplicability(TypeBinding targetType) {
 	return true;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 366a60f..d4658cc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -23,6 +23,7 @@
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
+import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -63,7 +64,7 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 public class LambdaExpression extends FunctionalExpression implements ReferenceContext, ProblemSeverities {
 	public Argument [] arguments;
-	private TypeBinding [] argumentTypes = Binding.NO_PARAMETERS;
+	private TypeBinding [] argumentTypes;
 	public Statement body;
 	public boolean hasParentheses;
 	public MethodScope scope;
@@ -77,6 +78,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	private int outerLocalVariablesSlotSize = 0;
 	public boolean shouldCaptureInstance = false;
 	private boolean shouldUnelideTypes = false;
+	private boolean hasIgnoredMandatoryErrors = false;
 	private static final SyntheticArgumentBinding [] NO_SYNTHETIC_ARGUMENTS = new SyntheticArgumentBinding[0];
 	
 	public LambdaExpression(CompilationResult compilationResult, Argument [] arguments, Statement body, boolean shouldUnelideTypes) {
@@ -84,6 +86,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		this.arguments = arguments != null ? arguments : ASTNode.NO_ARGUMENTS;
 		this.body = body;
 		this.shouldUnelideTypes = shouldUnelideTypes;
+		this.argumentTypes = new TypeBinding[arguments != null ? arguments.length : 0]; 
 	}
 	
 	protected FunctionalExpression original() {
@@ -196,9 +199,6 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		TypeBinding[] newParameters = new TypeBinding[length];
 
 		AnnotationBinding [][] parameterAnnotations = null;
-		if (!argumentsTypeElided) {
-			this.argumentTypes = new TypeBinding[length];
-		}
 		for (int i = 0; i < length; i++) {
 			Argument argument = this.arguments[i];
 			if (argument.isVarArgs()) {
@@ -420,15 +420,27 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		}
 	}
 
-	public boolean isPertinentToApplicability() {
+	public boolean isPertinentToApplicability(TypeBinding targetType) {
+		
+		// Add the rule about type variable of the generic method.
+		
+		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope); // cached/cheap call.
+		
+		if (sam == null || !sam.isValidBinding())
+			return true;
+		
+		if (sam.parameters.length != this.argumentTypes.length)
+			return true;
+		
 		if (argumentsTypeElided())
 			return false;
 		
 		Expression [] returnExpressions = this.resultExpressions;
 		for (int i = 0, length = returnExpressions.length; i < length; i++) {
-			if (!returnExpressions[i].isPertinentToApplicability())
+			if (!returnExpressions[i].isPertinentToApplicability(targetType))
 				return false;
 		}
+		
 		return true;
 	}
 	
@@ -495,26 +507,40 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 					return false;
 				copy.setExpressionContext(this.expressionContext);
 				copy.setExpectedType(left);
-				copy.resolveType(this.enclosingScope);
-
+				this.hasIgnoredMandatoryErrors = false;
+				TypeBinding type = copy.resolveType(this.enclosingScope);
 				if (!argumentsTypeElided()) {
 					this.argumentTypes = copy.argumentTypes;
 				}
-			
 				if (this.body instanceof Block) {
-					if (!this.returnsVoid) {
-						this.valueCompatible = copy.doesNotCompleteNormally();
+					if (this.returnsVoid) {
+						this.shapeAnalysisComplete = true;
 					}
 				} else {
 					this.voidCompatible = ((Expression) this.body).statementExpression();
+					this.shapeAnalysisComplete = true;
 				}
-			
-			} finally {
+				// Do not proceed with data/control flow analysis if resolve encountered errors.
+				if (type == null || !type.isValidBinding() || this.hasIgnoredMandatoryErrors) {
+					if (!isPertinentToApplicability(left))
+						return true;
+					return this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.
+				}
+				
+				// value compatibility of block lambda's is the only open question.
+				if (!this.shapeAnalysisComplete)
+					this.valueCompatible = copy.doesNotCompleteNormally();
+				
 				this.shapeAnalysisComplete = true;
+			} finally {
+				this.hasIgnoredMandatoryErrors = false;
 				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
 			}
 		}
 
+		if (!isPertinentToApplicability(left))
+			return true;
+	
 		if (sam.returnType.id == TypeIds.T_void) {
 			if (!this.voidCompatible)
 				return false;
@@ -523,9 +549,6 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				return false;
 		}
 		
-		if (!isPertinentToApplicability())
-			return true;
-	
 		Expression [] returnExpressions = this.resultExpressions;
 		for (int i = 0, length = returnExpressions.length; i < length; i++) {
 			if (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate
@@ -692,6 +715,35 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		}
 	}
 	
+	public void tagAsHavingIgnoredMandatoryErrors(int problemId) {
+		switch (problemId) {
+			// 15.27.3 requires exception throw related errors to not influence congruence. Other errors should. Also don't abort shape analysis.
+			case IProblem.UnhandledExceptionOnAutoClose:
+			case IProblem.UnhandledExceptionInDefaultConstructor:
+			case IProblem.UnhandledException:
+				return;
+			/* The following structural problems can occur only because of target type imposition. Filter, so we can distinguish inherent errors 
+			   in explicit lambdas. This is to help decide whether to proceed with data/control flow analysis to discover shape. In case of inherent
+			   errors, we will not call analyze code as it is not prepared to analyze broken programs.
+			*/
+			case IProblem.VoidMethodReturnsValue:
+			case IProblem.ShouldReturnValueHintMissingDefault:
+			case IProblem.ShouldReturnValue:
+			case IProblem.ReturnTypeMismatch:
+			case IProblem.IncompatibleLambdaParameterType:
+			case IProblem.lambdaParameterTypeMismatched:
+			case IProblem.lambdaSignatureMismatched:
+			case IProblem.LambdaDescriptorMentionsUnmentionable:
+			case IProblem.TargetTypeNotAFunctionalInterface:
+			case IProblem.illFormedParameterizationOfFunctionalInterface:
+			case IProblem.MultipleFunctionalInterfaces:
+				return;
+			default: 
+				this.original.hasIgnoredMandatoryErrors = true;
+				return;
+		}
+	}
+	
 	public void generateCode(ClassScope classScope, ClassFile classFile) {
 		int problemResetPC = 0;
 		classFile.codeStream.wideMode = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index f0b2d73..0c43c7c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -673,8 +673,8 @@ public TypeBinding resolveType(BlockScope scope) {
 			? scope.getImplicitMethod(this.selector, argumentTypes, this)
 			: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
 	
-	if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-		return null;
+	if (polyExpressionSeen)
+		resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
 
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index ee6d664..f335166 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -476,8 +476,9 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 			}
 			ReferenceBinding allocationType = (ReferenceBinding) receiverType;
 			this.binding = scope.getConstructor(allocationType, argumentTypes, this);
-			if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-				return null;
+			if (polyExpressionSeen)
+				resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
+
 			if (this.binding.isValidBinding()) {	
 				if (isMethodUseDeprecated(this.binding, scope, true)) {
 					scope.problemReporter().deprecatedMethod(this.binding, this);
@@ -543,8 +544,9 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 			return null; // stop secondary errors
 		}
 		MethodBinding inheritedBinding = scope.getConstructor(anonymousSuperclass, argumentTypes, this);
-		if (polyExpressionSeen && polyExpressionsHaveErrors(scope, inheritedBinding, this.arguments, argumentTypes))
-			return null;
+		if (polyExpressionSeen)
+			resolvePolyExpressionArguments(scope, inheritedBinding, this.arguments, argumentTypes);
+			
 		if (!inheritedBinding.isValidBinding()) {
 			if (inheritedBinding.declaringClass == null) {
 				inheritedBinding.declaringClass = anonymousSuperclass;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index 2078249..7704666 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -59,7 +59,7 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 
 protected boolean checkNullableFieldDereference(Scope scope, FieldBinding field, long sourcePosition) {
 	// preference to type annotations if we have any
-	if (field.type != null && (field.type.tagBits & TagBits.AnnotationNullable) != 0) {
+	if ((field.type.tagBits & TagBits.AnnotationNullable) != 0) {
 		scope.problemReporter().dereferencingNullableExpression(sourcePosition, scope.environment());
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 75c3fb5..91b294d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -526,6 +526,15 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		return !CharOperation.equals(this.selector,  ConstantPool.Init);
 	}
 	
+	public boolean isPertinentToApplicability(TypeBinding targetType) {
+		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope); // cached/cheap call.
+		
+		if (sam == null || !sam.isValidBinding())
+			return true;
+		
+		return this.isExactMethodReference();
+	}
+	
 	public TypeBinding[] genericTypeArguments() {
 		return this.resolvedTypeArguments;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 277151b..7b1ff97 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -353,7 +353,7 @@ public void resolve(BlockScope scope) {
 	}
 	if ((methodType.tagBits & TagBits.HasMissingType) == 0) {
 		// no need to complain if return type was missing (avoid secondary error : 220967)
-		scope.problemReporter().typeMismatchError(expressionType, methodType, this.expression, null);
+		scope.problemReporter().typeMismatchError(expressionType, methodType, this.expression, this);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index c207e43..32546f3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -146,9 +146,7 @@ void analyseOneArgument18(BlockScope currentScope, FlowContext flowContext, Flow
 	}
 }
 
-protected void checkAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requiredType, Expression expression, FlowContext flowContext, FlowInfo flowInfo) { 
-	if (requiredType == null || !requiredType.isValidBinding() || expression.resolvedType == null || !expression.resolvedType.isValidBinding())
-		return;
+protected void checkAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requiredType, Expression expression, FlowContext flowContext, FlowInfo flowInfo) {
 	int nullStatus = expression.nullStatus(flowInfo, flowContext);
 	NullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(requiredType, expression.resolvedType, nullStatus);
 	if (annotationStatus.isDefiniteMismatch()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index 12be82b..e6c67bd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -1324,6 +1324,10 @@ public void tagAsHavingErrors() {
 	this.ignoreFurtherInvestigation = true;
 }
 
+public void tagAsHavingIgnoredMandatoryErrors(int problemId) {
+	// Nothing to do for this context;
+}
+
 /**
  *	Iteration for a package member type
  *
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ReferenceContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ReferenceContext.java
index cba9b61..3f3f037 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ReferenceContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ReferenceContext.java
@@ -35,5 +35,7 @@ public interface ReferenceContext {
 	boolean hasErrors();
 
 	void tagAsHavingErrors();
+	
+	void tagAsHavingIgnoredMandatoryErrors(int problemId);
 
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
index 4db5951..a8a2fcc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
@@ -118,9 +118,17 @@ public void handle(
 	ReferenceContext referenceContext,
 	CompilationResult unitResult) {
 
-	if (severity == ProblemSeverities.Ignore || this.policy.ignoreAllErrors())
+	if (severity == ProblemSeverities.Ignore)
 		return;
 
+	 boolean mandatory = (severity & (ProblemSeverities.Error | ProblemSeverities.Optional)) == ProblemSeverities.Error;
+	 if (this.policy.ignoreAllErrors()) { 
+		 // Error is not to be exposed, but clients may need still notification as to whether there are silently-ignored-errors.
+		 if (mandatory)
+			 referenceContext.tagAsHavingIgnoredMandatoryErrors(problemId);
+		 return;
+	 }
+
 	if ((severity & ProblemSeverities.Optional) != 0 && problemId != IProblem.Task  && !this.options.ignoreSourceFolderWarningOption) {
 		ICompilationUnit cu = unitResult.getCompilationUnit();
 		try{
@@ -166,7 +174,6 @@ public void handle(
 
 	switch (severity & ProblemSeverities.Error) {
 		case ProblemSeverities.Error :
-			boolean mandatory = ((severity & ProblemSeverities.Optional) == 0);
 			record(problem, unitResult, referenceContext, mandatory);
 			if ((severity & ProblemSeverities.Fatal) != 0) {
 				// don't abort or tag as error if the error is suppressed
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index b950a5d..e7e6951 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -7738,7 +7738,7 @@ public void typeMismatchError(TypeBinding actualType, TypeBinding expectedType,
 		}
 	}
 	this.handle(
-		IProblem.TypeMismatch,
+		expectingLocation instanceof ReturnStatement ? IProblem.ReturnTypeMismatch : IProblem.TypeMismatch,
 		new String[] {new String(actualReadableName), new String(expectedReadableName)},
 		new String[] {new String(actualShortReadableName), new String(expectedShortReadableName)},
 		location.sourceStart,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index af4eb8a..66b9136 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -56,7 +56,7 @@
 16 = Incompatible conditional operand types {0} and {1}
 17 = Type mismatch: cannot convert from {0} to {1}
 18 = The static member type {0}.{1} should be accessed directly
-
+19 = Type mismatch: cannot convert from {0} to {1}
 20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
 21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
 22 = No enclosing instance of the type {0} is accessible in scope
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
index 7eea9b6..8b62299 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
@@ -224,8 +224,8 @@ public TypeBinding resolveType(BlockScope scope) {
 	
 	ReferenceBinding allocatedType = (ReferenceBinding) this.resolvedType;
 	this.binding = scope.getConstructor(allocatedType, argumentTypes, this);
-	if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-		return null;
+	if (polyExpressionSeen)
+		resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
 
 	if (!this.binding.isValidBinding()) {	
 		if (this.binding instanceof ProblemMethodBinding
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
index 891531c..cc0fbb0 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
@@ -262,9 +262,9 @@ public TypeBinding resolveType(BlockScope scope) {
 			? scope.getImplicitMethod(this.selector, argumentTypes, this)
 			: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
 	
-	if (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))
-		return null;
-	
+	if (polyExpressionSeen)
+		resolvePolyExpressionArguments(scope, this.binding, this.arguments, argumentTypes);
+		
 	if (!this.binding.isValidBinding()) {
 		if (this.binding instanceof ProblemMethodBinding
 			&& ((ProblemMethodBinding) this.binding).problemId() == ProblemReasons.NotVisible) {
