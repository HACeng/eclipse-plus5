commit 184b4b19c9d2c7d8c8ac5e75bb625e14dba4eba8
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Dec 16 16:34:11 2015 -0800

    Bug 481796 - JavaDoc updates
    
    Change-Id: I717b1f5e0a0580945716cef1a6bbab2cd70d0471

2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaNames.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
index 0aa8d63..d1a79e1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
@@ -116,13 +116,13 @@ public final class Indexer {
 
 	private void cleanGarbage(List<IJavaElement> allRoots, IProgressMonitor monitor) {
 		// TODO: lazily clean up unneeded files here... but only do so if we're under heavy space pressure
-		// or it's been a long time since the file was last scanned. Being to eager about removing old files
+		// or it's been a long time since the file was last scanned. Being too eager about removing old files
 		// means that operations which temporarily cause a file to become unreferenced will run really slowly
 
 		// We should also eagerly clean up any partially-indexed files we discover during the scan. That is,
 		// if we discover a file with a timestamp of 0, it indicates that the indexer or all of Eclipse crashed
 		// midway through indexing the file. Such garbage should be cleaned up as soon as possible, since it
-		// will never be useful
+		// will never be useful.
 	}
 
 	private List<IJavaElement> removeDuplicatePaths(List<IJavaElement> allRoots) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaNames.java
index 134dc47..1805c92 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaNames.java
@@ -3,6 +3,9 @@ package org.eclipse.jdt.internal.core.pdom.java;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 
+/**
+ * @since 3.12
+ */
 public class JavaNames {
 	/**
 	 * Converts a java binary name to a simple name.
commit 92b5f83dae2815073e2c9e8f2bab471df7155ade
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Dec 16 16:34:52 2015 -0800

    Bug 481796 - Make database deletions asynchronous
    
    Make deletions asynchronous (to prevent the
    possibility of a destructor reaching back
    and modifying another object that is in the
    process of being deleted.
    
    Change-Id: Iced662749ada445e3c1d721445442f3a1d9577ad

3	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
11	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
51	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/LongArray.java
33	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOM.java
1	17	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOMNode.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldManyToOne.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToOne.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
index eec6ef7..b30e98b 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
@@ -221,6 +221,7 @@ public class FieldBackPointerTest extends BaseTestCase {
 		this.fc.setBp(this.ba);
 
 		this.fb.delete();
+		this.pdom.processDeletions();
 
 		assertBackPointers(this.ba, this.fa, this.fc);
 	}
@@ -231,6 +232,7 @@ public class FieldBackPointerTest extends BaseTestCase {
 		this.fc.setBp(this.ba);
 
 		this.ba.delete();
+		this.pdom.processDeletions();
 
 		assertEquals(null, this.fa.getBp());
 		assertEquals(null, this.fb.getBp());
@@ -256,6 +258,7 @@ public class FieldBackPointerTest extends BaseTestCase {
 		this.fc.setBp(this.ba);
 
 		this.bb.delete();
+		this.pdom.processDeletions();
 
 		assertBackPointers(this.ba, this.fc);
 	}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
index 8d91076..7dcb5b8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
@@ -176,6 +176,7 @@ public class InheritenceTests extends BaseTestCase {
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refA.setSubClassReference(this.subClass);
 		this.refA.setSubClassReference(null);
+		this.pdom.processDeletions();
 		assertFalse(this.allObjects.contains(this.subClass));
 	}
 
@@ -185,8 +186,10 @@ public class InheritenceTests extends BaseTestCase {
 		this.refB.setBaseClassReference(this.subClass);
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refA.setSubClassReference(null);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refB.setBaseClassReference(null);
+		this.pdom.processDeletions();
 		assertFalse(this.allObjects.contains(this.subClass));
 	}
 
@@ -194,20 +197,26 @@ public class InheritenceTests extends BaseTestCase {
 		// Test what happens when the base class reference is removed first.
 		this.refA.setSubClassReference(this.subClass);
 		this.refB.setBaseClassReference(this.subClass);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refB.setBaseClassReference(null);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refA.setSubClassReference(null);
+		this.pdom.processDeletions();
 		assertFalse(this.allObjects.contains(this.subClass));
 	}
 
 	public void testOwnedPointersDontCountTowardsRefCount() {
 		this.refA.setOwner(this.subClass);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refB.setBaseClassReference(this.subClass);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		assertTrue(this.allObjects.contains(this.refA));
 		this.refB.setBaseClassReference(null);
+		this.pdom.processDeletions();
 		assertFalse(this.allObjects.contains(this.subClass));
 		assertFalse(this.allObjects.contains(this.refA));
 	}
@@ -216,8 +225,10 @@ public class InheritenceTests extends BaseTestCase {
 		this.refA.setBaseClassReference(this.subClass);
 		this.refB.setBaseClassReference(this.subClass);
 		this.refA.setBaseClassReference(null);
+		this.pdom.processDeletions();
 		assertTrue(this.allObjects.contains(this.subClass));
 		this.refB.setBaseClassReference(null);
+		this.pdom.processDeletions();
 		assertFalse(this.allObjects.contains(this.subClass));
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
index 777bc10..81bb9cb 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
@@ -148,7 +148,7 @@ public class SearchKeyTests extends BaseTestCase {
 		assertEquals(this.elementA, this.index.findNickName(SEARCH_STRING_B));
 
 		this.elementA.delete();
-
+		this.pdom.processDeletions();
 		assertEquals(null, this.index.findName(SEARCH_STRING_A));
 		assertEquals(null, this.index.findNickName(SEARCH_STRING_B));
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/LongArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/LongArray.java
new file mode 100644
index 0000000..427fe11
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/LongArray.java
@@ -0,0 +1,51 @@
+package org.eclipse.jdt.internal.core.pdom;
+
+/**
+ * Represents an array of long
+ * @since 3.12
+ */
+public class LongArray {
+	private static final int MIN_CAPACITY = 8;
+	private long[] contents;
+	private int size;
+
+	long get(int index) {
+		if (index >= this.size) {
+			throw new ArrayIndexOutOfBoundsException(index);
+		}
+
+		return this.contents[index];
+	}
+
+	long removeLast() {
+		return this.contents[--this.size];
+	}
+
+	void addLast(long toAdd) {
+		ensureCapacity(this.size + 1);
+		this.contents[this.size++] = toAdd;
+	}
+
+	private void ensureCapacity(int capacity) {
+		if (this.contents == null) {
+			this.contents = new long[Math.max(MIN_CAPACITY, capacity)];
+		}
+
+		if (this.contents.length >= capacity) {
+			return;
+		}
+
+		int newSize = capacity * 2;
+		long[] newContents = new long[newSize];
+
+		System.arraycopy(this.contents, 0, newContents, 0, this.contents.length);
+	}
+
+	int size() {
+		return this.size;
+	}
+
+	public boolean isEmpty() {
+		return this.size == 0;
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOM.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOM.java
index 145d85d..6e46ea8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOM.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOM.java
@@ -127,6 +127,7 @@ public class PDOM {
 	private final HashMap<Object, Object> fResultCache= new HashMap<>();
 	protected ChangeEvent fEvent= new ChangeEvent();
 	private final PDOMNodeTypeRegistry<PDOMNode> fNodeTypeRegistry;
+	private LongArray pendingDeletions = new LongArray();
 
 	public PDOM(File dbPath, PDOMNodeTypeRegistry<PDOMNode> nodeTypes, int minVersion, int maxVersion,
 			int currentVersion) throws IndexException {
@@ -146,6 +147,21 @@ public class PDOM {
 		}
 	}
 
+	public void scheduleDeletion(long addressOfNodeToDelete) {
+		this.pendingDeletions.addLast(addressOfNodeToDelete);
+	}
+
+	/**
+	 * Synchronously processes all pending deletions
+	 */
+	public void processDeletions() {
+		while (!this.pendingDeletions.isEmpty()) {
+			long next = this.pendingDeletions.removeLast();
+
+			delete(next);
+		}
+	}
+
 	/**
 	 * Returns whether this PDOM can never be written to. Writable subclasses should return false.
 	 */
@@ -300,6 +316,7 @@ public class PDOM {
 	public void releaseWriteLock(int establishReadLocks, boolean flush) {
 		// When all locks are released we can clear the result cache.
 		if (establishReadLocks == 0) {
+			processDeletions();
 			clearResultCache();
 		}
 		try {
@@ -556,4 +573,20 @@ public class PDOM {
 	public short getNodeType(Class<? extends PDOMNode> toQuery) {
 		return this.fNodeTypeRegistry.getTypeForClass(toQuery);
 	}
+
+	private void delete(long address) {
+		if (address == 0) {
+			return;
+		}
+		short nodeType = PDOMNode.NODE_TYPE.get(this, address);
+	
+		// Look up the type
+		ITypeFactory<? extends PDOMNode> factory1 = getTypeFactory(nodeType);
+	
+		// Call its destructor
+		factory1.destruct(this, address);
+	
+		// Free up its memory
+		getDB().free(address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOMNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOMNode.java
index 26d6721..c94ede5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOMNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PDOMNode.java
@@ -75,27 +75,11 @@ public abstract class PDOMNode implements IInternalPDOMNode, IDestructable {
 		return (T)result;
 	}
 
-	public static void delete(PDOM pdom, long address) {
-		if (address == 0) {
-			return;
-		}
-		short nodeType = NODE_TYPE.get(pdom, address);
-
-		// Look up the type
-		ITypeFactory<? extends PDOMNode> factory1 = pdom.getTypeFactory(nodeType);
-
-		// Call its destructor
-		factory1.destruct(pdom, address);
-
-		// Free up its memory
-		pdom.getDB().free(address);
-	}
-
 	/**
 	 * Invokes the destructor on this node and frees up its memory
 	 */
 	public final void delete() {
-		delete(getPDOM(), this.address);
+		getPDOM().scheduleDeletion(this.address);
 	}
 
 	protected PDOMNode(PDOM pdom, long address) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldManyToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldManyToOne.java
index a4e584f..401938a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldManyToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldManyToOne.java
@@ -131,7 +131,7 @@ public class FieldManyToOne<T extends PDOMNode> implements IDestructableField, I
 				ITypeFactory<T> typeFactory = pdom.getTypeFactory(targetType);
 
 				if (typeFactory.isRefCounted() && !typeFactory.hasReferences(pdom, oldTargetAddress)) {
-					PDOMNode.delete(pdom, oldTargetAddress);
+					pdom.scheduleDeletion(oldTargetAddress);
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
index 96138c5..e8c0992 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
@@ -163,7 +163,7 @@ public class FieldOneToMany<T extends PDOMNode> implements IDestructableField, I
 			this.forwardPointer.clearedByBackPointer(pdom, target);
 
 			if (isOwner) {
-				PDOMNode.delete(pdom, target);
+				pdom.scheduleDeletion(target);
 			}
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToOne.java
index ff24389..a097b6b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToOne.java
@@ -6,6 +6,7 @@ import org.eclipse.jdt.internal.core.pdom.db.Database;
 
 /**
  * Represents a 1-to-0..1 relationship in a PDOM database.
+ * @since 3.12
  */
 public class FieldOneToOne<T extends PDOMNode> implements IField, IDestructableField {
 	private int offset;
@@ -71,7 +72,7 @@ public class FieldOneToOne<T extends PDOMNode> implements IField, IDestructableF
 		if (ptr != 0) {
 			// If we own our target, delete it
 			if (this.backPointer.pointsToOwner) {
-				PDOMNode.delete(pdom, ptr);
+				pdom.scheduleDeletion(ptr);
 			} else {
 				db.putRecPtr(ptr + this.backPointer.offset, 0);
 			}
commit a474ff325ff488f6ef94e7f1b23f2ebae474ddfe
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Dec 16 16:35:49 2015 -0800

    Bug 481796 - Add protection against unlocked database access.
    
    Change-Id: I2e94a99fafe2cc0e6b5694c564ba3ed654b67fbf

11	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/db/Database.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index b5528d8..c5b9800 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -489,19 +489,20 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 	JavaIndex index = JavaPDOM.getIndex();
 	PDOM pdom = index.getPDOM();
 	String fieldDefinition = JavaNames.fullyQualifiedNameToFieldDescriptor(type.getFullyQualifiedName());
-	PDOMTypeId foundType = index.findType(fieldDefinition);
+	pdom.acquireReadLock();
 
-	if (foundType == null) {
-		return;
-	}
+	try {
+		PDOMTypeId foundType = index.findType(fieldDefinition);
 
-	ArrayDeque<PDOMType> typesToVisit = new ArrayDeque<>();
-	Set<PDOMType> discoveredTypes = new HashSet<>();
-	typesToVisit.addAll(foundType.getTypes());
-	discoveredTypes.addAll(typesToVisit);
+		if (foundType == null) {
+			return;
+		}
+
+		ArrayDeque<PDOMType> typesToVisit = new ArrayDeque<>();
+		Set<PDOMType> discoveredTypes = new HashSet<>();
+		typesToVisit.addAll(foundType.getTypes());
+		discoveredTypes.addAll(typesToVisit);
 
-	pdom.acquireReadLock();
-	try {
 		while (!typesToVisit.isEmpty()) {
 			PDOMType nextType = typesToVisit.removeFirst();
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/db/Database.java
index 9c61fc6..9f6061a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/db/Database.java
@@ -266,6 +266,9 @@ public class Database {
 	 * @throws IndexException
 	 */
 	public Chunk getChunk(long offset) throws IndexException {
+		if (!this.fLocked) {
+			throw new IllegalStateException("Database not locked!");
+		}
 		if (offset < CHUNK_SIZE) {
 			return fHeaderChunk;
 		}
commit 02fceea0e0f665df83e306ad519b5588b2092a63
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Dec 16 16:40:56 2015 -0800

    Bug 481796 - Support generic signatures + type annotations
    
    Change-Id: I725fd67d19e435d3771eb81461ae036601164dd9

5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
5	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
30	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/CharUtil.java
330	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
1	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
103	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
0	92	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaPDOM.java
4	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotation.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotationValuePair.java
15	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstant.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantAnnotation.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantArray.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantBoolean.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantByte.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantChar.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantClass.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantDouble.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantEnum.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantFloat.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantInt.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantLong.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantShort.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantString.java
4	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeArgument.java
46	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeBound.java
3	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
41	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeParameter.java
18	23	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
0	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMVariable.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/TagTreeReader.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
index c76163a..7f24103 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
@@ -192,6 +192,11 @@ public class SignatureWrapper {
 		return CharOperation.subarray(this.signature, this.start, this.signature.length);
 	}
 	public String toString() {
+		if (this.start >= 0 && this.start <= this.signature.length) {
+			return new String(CharOperation.subarray(this.signature, 0, this.start)) + " ^ " //$NON-NLS-1$
+					+ new String(CharOperation.subarray(this.signature, this.start, this.signature.length));
+		}
+		
 		return new String(this.signature) + " @ " + this.start; //$NON-NLS-1$
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index c5b9800..eaf3b58 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -54,7 +54,6 @@ import org.eclipse.jdt.internal.core.SearchableEnvironment;
 import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.java.JavaIndex;
 import org.eclipse.jdt.internal.core.pdom.java.JavaNames;
-import org.eclipse.jdt.internal.core.pdom.java.JavaPDOM;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMType;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeId;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeInterface;
@@ -474,7 +473,7 @@ public static void searchAllPossibleSubTypes(
 	int waitingPolicy,	// WaitUntilReadyToSearch | ForceImmediateSearch | CancelIfNotReadyToSearch
 	final IProgressMonitor progressMonitor) {
 	
-	if (JavaPDOM.isEnabled()) {
+	if (JavaIndex.isEnabled()) {
 		newSearchAllPossibleSubTypes(type, scope, binariesFromIndexMatches, pathRequestor, waitingPolicy,
 				progressMonitor);
 	} else {
@@ -486,7 +485,7 @@ public static void searchAllPossibleSubTypes(
 private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope scope2, Map binariesFromIndexMatches2,
 		IPathRequestor pathRequestor, int waitingPolicy, IProgressMonitor progressMonitor) {
 	SubMonitor subMonitor = SubMonitor.convert(progressMonitor);
-	JavaIndex index = JavaPDOM.getIndex();
+	JavaIndex index = JavaIndex.getIndex();
 	PDOM pdom = index.getPDOM();
 	String fieldDefinition = JavaNames.fullyQualifiedNameToFieldDescriptor(type.getFullyQualifiedName());
 	pdom.acquireReadLock();
@@ -516,7 +515,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 					.split(1)
 					.setWorkRemaining(3);
 
-			boolean isLocalClass = nextType.getDeclaringType() != null;
+			boolean isLocalClass = nextType.getTypeId().getDeclaringType() != null;
 			pathRequestor.acceptPath(typePath, isLocalClass);
 
 			HierarchyBinaryType binaryType = (HierarchyBinaryType)binariesFromIndexMatches2.get(typePath);
@@ -539,9 +538,9 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 
 private static HierarchyBinaryType createBinaryTypeFrom(PDOMType type) {
 	char[] enclosingTypeName = null;
-	PDOMTypeId enclosingType = type.getDeclaringType();
+	PDOMTypeSignature enclosingType = type.getTypeId().getDeclaringType();
 	if (enclosingType != null) {
-		enclosingTypeName = enclosingType.getSimpleName().getChars();
+		enclosingTypeName = enclosingType.getRawType().getSimpleName().getChars();
 	}
 	//final char[][] typeParameterSignatures;
 	PDOMTypeId typeId = type.getTypeId();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/CharUtil.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/CharUtil.java
new file mode 100644
index 0000000..28c9155
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/CharUtil.java
@@ -0,0 +1,30 @@
+package org.eclipse.jdt.internal.core.pdom.indexer;
+
+/**
+ * TODO: Insert description here. (generated by sxenos)
+ */
+public class CharUtil {
+
+	/**
+	 * Answers a new array which is the concatenation of all the given arrays.
+	 * 
+	 * @param toCatenate
+	 * @return
+	 * @since 3.12
+	 */
+	public static char[] concat(char[]... toCatenate) {
+		int totalSize = 0;
+		for (char[] next: toCatenate) {
+			totalSize += next.length;
+		}
+	
+		char[] result = new char[totalSize];
+		int writeIndex = 0;
+		for (char[] next: toCatenate) {
+			System.arraycopy(next, 0, result, writeIndex, next.length);
+			writeIndex += next.length;
+		}
+		return result;
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
index 208ca0c..6150fee 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
@@ -4,23 +4,30 @@ import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
 import org.eclipse.jdt.internal.core.ClassFile;
 import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.Openable;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.pdom.PDOM;
+import org.eclipse.jdt.internal.core.pdom.db.IndexException;
 import org.eclipse.jdt.internal.core.pdom.java.JavaIndex;
 import org.eclipse.jdt.internal.core.pdom.java.JavaNames;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMAnnotation;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMAnnotationValuePair;
+import org.eclipse.jdt.internal.core.pdom.java.PDOMComplexTypeSignature;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMConstant;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMConstantAnnotation;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMConstantArray;
@@ -29,14 +36,21 @@ import org.eclipse.jdt.internal.core.pdom.java.PDOMConstantEnum;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMMethodId;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMResourceFile;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMType;
+import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeArgument;
+import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeBound;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeId;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeInterface;
+import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeParameter;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeSignature;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMVariable;
 import org.eclipse.jdt.internal.core.util.Util;
 
+import java.util.Objects;
+
 public class ClassFileToIndexConverter {
 	private static final boolean ENABLE_LOGGING = false;
+	private static final char[][] EMPTY_CHAR_ARRAY_ARRAY = new char[0][];
+	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private PDOMResourceFile resource;
 	private JavaIndex index;
 
@@ -102,7 +116,7 @@ public class ClassFileToIndexConverter {
 		return info;
 	}
 
-	public PDOMType addType(IBinaryType binaryType, IProgressMonitor monitor) {
+	public PDOMType addType(IBinaryType binaryType, IProgressMonitor monitor) throws CoreException {
 		char[] binaryName = binaryType.getName();
 		logInfo("adding binary type " + new String(binaryName));
 
@@ -113,10 +127,69 @@ public class ClassFileToIndexConverter {
 			type = new PDOMType(getPDOM(), this.resource);
 		}
 
+		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
+		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short)-1, binaryType.getSuperclassName());
+
 		type.setTypeId(name);
-		type.setSuperclass(createTypeIdFromBinaryName(binaryType.getSuperclassName()));
+
+		char[][] interfaces = binaryType.getInterfaceNames();
+		if (interfaces == null) {
+			interfaces = EMPTY_CHAR_ARRAY_ARRAY;
+		}
+		// Create the default generic signature if the .class file didn't supply one
+		char[] genericSignature = binaryType.getGenericSignature();
+		if (genericSignature == null) {
+			int startIndex = binaryType.getSuperclassName() != null ? 3 : 0; 
+			char[][] toCatenate = new char[startIndex + (interfaces.length * 3)][];
+			char[] prefix = new char[]{'L'};
+			char[] suffix = new char[]{';'};
+
+			if (binaryType.getSuperclassName() != null) {
+				toCatenate[0] = prefix;
+				toCatenate[1] = binaryType.getSuperclassName();
+				toCatenate[2] = suffix;
+			}
+
+			for (int idx = 0; idx < interfaces.length; idx++) {
+				int catIndex = startIndex + idx * 3;
+				toCatenate[catIndex] = prefix;
+				toCatenate[catIndex + 1] = interfaces[idx];
+				toCatenate[catIndex + 2] = suffix;
+			}
+
+			genericSignature = CharUtil.concat(toCatenate);
+		}
+
 		type.setModifiers(binaryType.getModifiers());
-		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));
+ 
+		char[] enclosingTypeName = binaryType.getEnclosingTypeName();
+		// TODO(sxenos): There are some classes for which enclosingTypeName is null but which have classnames that
+		// resemble inner classes (ie: the classnames contain a '$'). Figure out what this means.
+//		assertThat((enclosingTypeName == null) == (name.getDeclaringType() == null), 
+//				"Declaring type should be null if and only if there is no enclosing type"); //$NON-NLS-1$
+		if (enclosingTypeName != null) {
+			String realEnclosingFieldDescriptor = JavaNames.binaryNameToFieldDescriptor(new String(enclosingTypeName));
+			String indexedFieldDescriptor = name.getDeclaringType().getRawType().getFieldDescriptor().getString();
+			assertThat(Objects.equals(realEnclosingFieldDescriptor, indexedFieldDescriptor),
+				"Incorrect field descriptor for declaring type"); //$NON-NLS-1$
+		}
+
+		SignatureWrapper signatureWrapper = new SignatureWrapper(genericSignature);
+		readTypeParameters(type, typeAnnotations, signatureWrapper);
+		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper));
+
+		short interfaceIdx = 0;
+		while (signatureWrapper.start < signatureWrapper.signature.length) {
+			// Note that there may be more interfaces listed in the generic signature than in the interfaces list.
+			// Although the VM spec doesn't discuss this case specifically, there are .class files in the wild with
+			// this characteristic. In such cases, we take what's in the generic signature and discard what's in the
+			// interfaces list.
+			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
+			new PDOMTypeInterface(getPDOM(), type, createTypeSignature(
+					typeAnnotations.toSupertype(interfaceIdx, interfaceSpec),
+					signatureWrapper));
+			interfaceIdx++;
+		}
 
 		IBinaryAnnotation[] annotations = binaryType.getAnnotations();
 		if (annotations != null) {
@@ -150,19 +223,266 @@ public class ClassFileToIndexConverter {
 			}
 		}
 
-		// genericSignature = binaryType.getGenericSignature();
+		return type;
+	}
 
-		char[][] interfaces = binaryType.getInterfaceNames();
-		if (interfaces != null) {
-			for (char[] next : interfaces) {
-				new PDOMTypeInterface(getPDOM(), type, createTypeIdFromBinaryName(next));
+	/**
+	 * Reads and attaches any generic type parameters at the current start position in the given wrapper.
+	 * Sets wrapper.start to the character following the type parameters.
+	 * @throws CoreException 
+	 */
+	private void readTypeParameters(PDOMType type, ITypeAnnotationWalker annotationWalker, SignatureWrapper wrapper)
+			throws CoreException {
+		char[] genericSignature = wrapper.signature;
+		if (genericSignature.length == 0 || genericSignature[wrapper.start] != '<') {
+			return;
+		}
+
+		int parameterIndex = 0;
+		int boundIndex = 0;
+		int indexOfClosingBracket = wrapper.skipAngleContents(wrapper.start) - 1;
+		wrapper.start++;
+		PDOMTypeParameter parameter = null;
+		while (wrapper.start < indexOfClosingBracket) {
+			int colonPos = CharOperation.indexOf(':', genericSignature, wrapper.start, indexOfClosingBracket);
+
+			if (colonPos > wrapper.start) {
+				String identifier = new String(CharOperation.subarray(genericSignature, wrapper.start, colonPos));
+				parameter = new PDOMTypeParameter(type, identifier);
+				wrapper.start = colonPos + 1;
+				parameterIndex++;
+				boundIndex = 0;
+			}
+
+			// Class files insert an empty bound if there is an interface bound but no class bound. We just omit
+			// the bound entirely.
+			while (genericSignature[wrapper.start] == ':') {
+				wrapper.start++;
 			}
+
+			PDOMTypeSignature boundSignature = createTypeSignature(
+					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short)boundIndex),
+					wrapper);
+ 
+			new PDOMTypeBound(parameter, boundSignature);
+			boundIndex++;
 		}
 
-		return type;
+		if (genericSignature[wrapper.start] == '>') {
+			wrapper.start++;
+		}
+	}
+
+	/**
+	 * Reads a type signature from the given {@link SignatureWrapper}, starting at the character pointed to by
+	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature.
+	 * 
+	 * @param supertypeAnnotations
+	 * @param superclassName
+	 * @param genericSignature
+	 * @return
+	 * @throws CoreException 
+	 */
+	private PDOMTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
+		char[] genericSignature = wrapper.signature;
+
+		if (genericSignature == null || genericSignature.length == 0) {
+			return null;
+		}
+
+		char firstChar = genericSignature[wrapper.start];
+		switch (firstChar) {
+			case 'T': {
+				// Skip the 'T' prefix
+				wrapper.start++;
+				PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
+				typeSignature.setVariableIdentifier(new String(wrapper.nextWord()));
+				attachAnnotations(typeSignature, annotations);
+				// Skip the trailing semicolon
+				wrapper.start++;
+				return typeSignature;
+			}
+			case '[': {
+				// Skip the '[' prefix
+				wrapper.start++;
+				// We encode arrays as though they were a one-argument generic type called '[' whose element
+				// type is the generic argument.
+				PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
+				typeSignature.setRawType(createTypeIdFromFieldDescriptor(new char[] {'['}));
+				PDOMTypeArgument typeArgument = new PDOMTypeArgument(getPDOM(), typeSignature);
+				PDOMTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
+				typeArgument.setType(elementType);
+				attachAnnotations(typeSignature, annotations);
+				return typeSignature;
+			}
+			case 'B':
+			case 'C':
+			case 'D':
+			case 'F':
+			case 'I':
+			case 'J':
+			case 'S':
+			case 'Z':
+				wrapper.start++;
+				return createTypeIdFromFieldDescriptor(new char[]{firstChar});
+			case 'L':
+				return parseClassTypeSignature(null, annotations, wrapper);
+			case '+':
+			case '-':
+			case '*':
+				throw new CoreException(Package.createStatus("Unexpected wildcard in top-level of generic signature: " //$NON-NLS-1$
+						+ genericSignature.toString()));
+			default:
+				throw new CoreException(Package.createStatus("Generic signature starts with unknow character: " //$NON-NLS-1$
+						+ genericSignature.toString()));
+		}
+	}
+
+	/**
+	 * Parses a ClassTypeSignature (as described in section 4.7.9.1 of the Java VM Specification Java SE 8 Edition).
+	 * The read pointer should be located just after the identifier. The caller is expected to have already read
+	 * the field descriptor for the type.
+	 * 
+	 * @param annotations
+	 * @param wrapper
+	 * @param genericSignature
+	 * @param fieldDescriptor
+	 * @return
+	 * @throws CoreException
+	 */
+	private PDOMTypeSignature parseClassTypeSignature(PDOMTypeSignature parentTypeOrNull,
+			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
+		char[] identifier = wrapper.nextName();
+		char[] fieldDescriptor;
+
+		if (parentTypeOrNull != null) {
+			fieldDescriptor = CharUtil.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
+					new char[] {'$'},
+					identifier);
+		} else {
+			fieldDescriptor = identifier;
+		}
+
+		char[] genericSignature = wrapper.signature;
+		boolean hasGenericArguments = (genericSignature.length > wrapper.start) && genericSignature[wrapper.start] == '<';
+		PDOMTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
+		PDOMTypeSignature result = rawType;
+
+		// Special optimization for signatures with no type annotations, no arrays, and no generic arguments that
+		// are not an inner type of a class that can't use this optimization. Basically, if there would be no attributes
+		// set on a PDOMComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
+		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
+		if (annotationList.length != 0 || hasGenericArguments
+				|| !Objects.equals(parentTypeOrNull, rawType.getDeclaringType())) {
+			PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
+			typeSignature.setRawType(rawType);
+			attachAnnotations(typeSignature, annotations);
+	
+			if (hasGenericArguments) {
+				wrapper.start++;
+				short argumentIndex = 0;
+				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
+					PDOMTypeArgument typeArgument = new PDOMTypeArgument(getPDOM(), typeSignature);
+	
+					switch(genericSignature[wrapper.start]) {
+						case '+': {
+							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_SUPER);
+							wrapper.start++;
+							break;
+						}
+						case '-': {
+							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_EXTENDS);
+							wrapper.start++;
+							break;
+						}
+						case '*': {
+							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_QUESTION);
+							wrapper.start++;
+							argumentIndex++;
+							continue;
+						}
+					}
+	
+					PDOMTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex), wrapper);
+					typeArgument.setType(nextSignature);
+					argumentIndex++;
+				}
+	
+				// Skip over the trailing '>'
+				wrapper.start++;
+			}
+			result = typeSignature;
+
+			if (parentTypeOrNull != null) {
+				result.setDeclaringType(parentTypeOrNull);
+			}
+		}
+
+		if (wrapper.start >= genericSignature.length) {
+			throw new IndexException("Read beyond end of the type signature!"); //$NON-NLS-1$
+		}
+
+		switch (genericSignature[wrapper.start]) {
+			case ';': 
+				wrapper.start++; 
+				break;
+			case '.':
+				PDOMTypeSignature nestedType = parseClassTypeSignature(result, annotations.toNextNestedType(), wrapper);
+				
+				PDOMTypeSignature detectedNestedType = nestedType.getDeclaringType();
+				
+				// Perform a sanity-test
+				assertThat(Objects.equals(detectedNestedType, result),
+						"Incorrect declaring type for nested type");
+				assertThat(Objects.equals(nestedType.getDeclaringType().getRawType(), result.getRawType()),
+						"Incorrect declaring type for nested raw type");
+
+				result = nestedType;
+				break;
+		}
+
+		return result;
+	}
+
+	/**
+	 * @param equals
+	 * @param string
+	 */
+	private void assertThat(boolean toTest, String errorMessage) {
+		if (!toTest) {
+			throw new IndexException(errorMessage);
+		}
+	}
+
+	/**
+	 * @param typeSignature
+	 * @param annotations
+	 */
+	private void attachAnnotations(PDOMComplexTypeSignature typeSignature, ITypeAnnotationWalker annotations) {
+		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
+
+		for (IBinaryAnnotation next: annotationList) {
+			PDOMAnnotation annotation = createAnnotation(next);
+
+			annotation.setParent(typeSignature);
+		}
+	}
+
+	private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations) {
+		if (typeAnnotations == null) {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+		return new TypeAnnotationWalker(typeAnnotations);
+	}
+
+	private PDOMTypeId createTypeIdFromFieldDescriptor(String typeName) {
+		if (typeName == null) {
+			return null;
+		}
+		return this.index.createTypeId(typeName);
 	}
 
-	private PDOMTypeSignature createTypeIdFromFieldDescriptor(char[] typeName) {
+	private PDOMTypeId createTypeIdFromFieldDescriptor(char[] typeName) {
 		if (typeName == null) {
 			return null;
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
index d1a79e1..0c51919 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/Indexer.java
@@ -40,7 +40,6 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.java.FileFingerprint;
 import org.eclipse.jdt.internal.core.pdom.java.FileFingerprint.FingerprintTestResult;
 import org.eclipse.jdt.internal.core.pdom.java.JavaIndex;
-import org.eclipse.jdt.internal.core.pdom.java.JavaPDOM;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMResourceFile;
 
 public final class Indexer {
@@ -61,7 +60,7 @@ public final class Indexer {
 	public static Indexer getInstance() {
 		synchronized (mutex) {
 			if (indexer == null) {
-				indexer = new Indexer(JavaPDOM.getPDOM(), ResourcesPlugin.getWorkspace().getRoot());
+				indexer = new Indexer(JavaIndex.getGlobalPDOM(), ResourcesPlugin.getWorkspace().getRoot());
 			}
 			return indexer;
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
index 94ddcfe..bd9b9d0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
@@ -10,9 +10,15 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.pdom.java;
 
+import java.io.File;
 import java.util.List;
 
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.core.pdom.PDOM;
+import org.eclipse.jdt.internal.core.pdom.PDOMNode;
+import org.eclipse.jdt.internal.core.pdom.PDOMNodeTypeRegistry;
+import org.eclipse.jdt.internal.core.pdom.db.ChunkCache;
 import org.eclipse.jdt.internal.core.pdom.db.Database;
 import org.eclipse.jdt.internal.core.pdom.field.FieldSearchIndex;
 import org.eclipse.jdt.internal.core.pdom.field.FieldSearchIndex.IResultRank;
@@ -23,6 +29,12 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef;
  * @since 3.12
  */
 public class JavaIndex {
+	// Version constants
+	static final int CURRENT_VERSION = PDOM.version(1, 8);
+	static final int MAX_SUPPORTED_VERSION= PDOM.version(1, Short.MAX_VALUE);
+	static final int MIN_SUPPORTED_VERSION= PDOM.version(1, 8);
+
+	// Fields for the search header
 	public static final FieldSearchIndex<PDOMResourceFile> FILES;
 	public static final FieldSearchIndex<PDOMTypeId> SIMPLE_INDEX;
 	public static final FieldSearchIndex<PDOMTypeId> TYPES;
@@ -58,16 +70,15 @@ public class JavaIndex {
 			return 1;
 		}
 	};
+	private static PDOM globalPdom;
+	private static final String INDEX_FILENAME = "index.db"; //$NON-NLS-1$
+	private final static Object pdomMutex = new Object();
 
 	public JavaIndex(PDOM dom, long address) {
 		this.address = address;
 		this.pdom = dom;
 	}
 
-	public static JavaIndex getIndex(PDOM pdom) {
-		return new JavaIndex(pdom, Database.DATA_AREA);
-	}
-
 	/**
 	 * Returns the most-recently-scanned resource file with the given name or null if none
 	 */
@@ -85,7 +96,7 @@ public class JavaIndex {
 		return TYPES.findBest(this.pdom, this.address, searchCriteria, this.anyResult);
 	}
 
-	public PDOMTypeSignature createTypeId(char[] fieldDescriptor) {
+	public PDOMTypeId createTypeId(char[] fieldDescriptor) {
 		return createTypeId(new String(fieldDescriptor));
 	}
 	
@@ -100,7 +111,15 @@ public class JavaIndex {
 			return existingType;
 		}
 
-		return new PDOMTypeId(this.pdom, fieldDescriptor);
+		int positionOfSeparator = fieldDescriptor.lastIndexOf('$');
+
+		PDOMTypeId result = new PDOMTypeId(this.pdom, fieldDescriptor);
+
+		if (positionOfSeparator != -1) {
+			result.setDeclaringType(createTypeId(fieldDescriptor.substring(0, positionOfSeparator)));
+		}
+
+		return result;
 	}
 
 	public PDOM getPDOM() {
@@ -123,6 +142,84 @@ public class JavaIndex {
 		return new PDOMMethodId(this.pdom, methodId);
 	}
 
+	public static boolean isEnabled() {
+		return true;
+	}
+
+	public static PDOM getGlobalPDOM() {
+		PDOM localPdom;
+		synchronized (pdomMutex) {
+			localPdom = globalPdom;
+		}
+	
+		if (localPdom != null) {
+			return localPdom;
+		}
+	
+		localPdom = new PDOM(getDBFile(), ChunkCache.getSharedInstance(), createTypeRegistry(),
+				MIN_SUPPORTED_VERSION, MAX_SUPPORTED_VERSION, CURRENT_VERSION);
+	
+		synchronized (pdomMutex) {
+			if (globalPdom == null) {
+				globalPdom = localPdom;
+			}
+			return globalPdom;
+		}
+	}
+
+	public static JavaIndex getIndex(PDOM pdom) {
+		return new JavaIndex(pdom, Database.DATA_AREA);
+	}
+
+	public static JavaIndex getIndex() {
+		return getIndex(getGlobalPDOM());
+	}
+
+	public static int getCurrentVersion() {
+		return CURRENT_VERSION;
+	}
+
+	static File getDBFile() {
+		IPath stateLocation = JavaCore.getPlugin().getStateLocation();
+		return stateLocation.append(INDEX_FILENAME).toFile();
+	}
+
+	static PDOMNodeTypeRegistry<PDOMNode> createTypeRegistry() {
+		PDOMNodeTypeRegistry<PDOMNode> registry = new PDOMNodeTypeRegistry<>();
+		registry.register(0x0000, PDOMAnnotation.type.getFactory());
+		registry.register(0x0010, PDOMAnnotationValuePair.type.getFactory());
+		registry.register(0x0020, PDOMBinding.type.getFactory());
+		registry.register(0x0028, PDOMComplexTypeSignature.type.getFactory());
+		registry.register(0x0030, PDOMConstant.type.getFactory());
+		registry.register(0x0040, PDOMConstantAnnotation.type.getFactory());
+		registry.register(0x0050, PDOMConstantArray.type.getFactory());
+		registry.register(0x0060, PDOMConstantBoolean.type.getFactory());
+		registry.register(0x0070, PDOMConstantByte.type.getFactory());
+		registry.register(0x0080, PDOMConstantChar.type.getFactory());
+		registry.register(0x0090, PDOMConstantClass.type.getFactory());
+		registry.register(0x00A0, PDOMConstantDouble.type.getFactory());
+		registry.register(0x00B0, PDOMConstantEnum.type.getFactory());
+		registry.register(0x00C0, PDOMConstantFloat.type.getFactory());
+		registry.register(0x00D0, PDOMConstantInt.type.getFactory());
+		registry.register(0x00E0, PDOMConstantLong.type.getFactory());
+		registry.register(0x00F0, PDOMConstantShort.type.getFactory());
+		registry.register(0x0100, PDOMConstantString.type.getFactory());
+		registry.register(0x0110, PDOMMethod.type.getFactory());
+		registry.register(0x0120, PDOMMethodId.type.getFactory());
+		registry.register(0x0150, PDOMResourceFile.type.getFactory());
+		registry.register(0x0160, PDOMTreeNode.type.getFactory());
+		registry.register(0x0170, PDOMType.type.getFactory());
+		registry.register(0x0180, PDOMTypeArgument.type.getFactory());
+		registry.register(0x0190, PDOMTypeBound.type.getFactory());
+		registry.register(0x01A0, PDOMTypeInterface.type.getFactory());
+		registry.register(0x01B0, PDOMTypeParameter.type.getFactory());
+		registry.register(0x01C0, PDOMTypeSignature.type.getFactory());
+		registry.register(0x01D0, PDOMTypeId.type.getFactory());
+		registry.register(0x01E0, PDOMTypeInterface.type.getFactory());
+		registry.register(0x01F0, PDOMVariable.type.getFactory());
+		return registry;
+	}
+
 //	/**
 //	 * Returns a method ID or creates a new one if it does not exist. The caller must
 //	 * attach a reference to it after calling this method or it may leak.
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaPDOM.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaPDOM.java
deleted file mode 100644
index 648b3af..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaPDOM.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package org.eclipse.jdt.internal.core.pdom.java;
-
-import java.io.File;
-
-import org.eclipse.core.runtime.IPath;
-import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.internal.core.pdom.PDOM;
-import org.eclipse.jdt.internal.core.pdom.PDOMNode;
-import org.eclipse.jdt.internal.core.pdom.PDOMNodeTypeRegistry;
-import org.eclipse.jdt.internal.core.pdom.db.ChunkCache;
-
-/**
- * @since 3.12
- */
-public class JavaPDOM {
-	private static final int MIN_SUPPORTED_VERSION= PDOM.version(1, 6);
-	private static final int MAX_SUPPORTED_VERSION= PDOM.version(1, Short.MAX_VALUE);
-	private static final int CURRENT_VERSION = PDOM.version(1, 6);
-
-	private static final String INDEX_FILENAME = "index.db"; //$NON-NLS-1$
-	private final static Object pdomMutex = new Object();
-	private static PDOM pdom;
-
-	public static boolean isEnabled() {
-		return true;
-	}
-
-	public static PDOM getPDOM() {
-		PDOM localPdom;
-		synchronized (pdomMutex) {
-			localPdom = pdom;
-		}
-
-		if (localPdom != null) {
-			return localPdom;
-		}
-
-		localPdom = new PDOM(getDBFile(), ChunkCache.getSharedInstance(), createTypeRegistry(),
-				MIN_SUPPORTED_VERSION, MAX_SUPPORTED_VERSION, CURRENT_VERSION);
-
-		synchronized (pdomMutex) {
-			if (pdom == null) {
-				pdom = localPdom;
-			}
-			return pdom;
-		}
-	}
-
-	public static JavaIndex getIndex() {
-		return JavaIndex.getIndex(getPDOM());
-	}
-
-	public static int getCurrentVersion() {
-		return CURRENT_VERSION;
-	}
-
-	private static File getDBFile() {
-		IPath stateLocation = JavaCore.getPlugin().getStateLocation();
-		return stateLocation.append(INDEX_FILENAME).toFile();
-	}
-
-	private static PDOMNodeTypeRegistry<PDOMNode> createTypeRegistry() {
-		PDOMNodeTypeRegistry<PDOMNode> registry = new PDOMNodeTypeRegistry<>();
-		registry.register(0x0000, PDOMAnnotation.type.getFactory());
-		registry.register(0x0010, PDOMAnnotationValuePair.type.getFactory());
-		registry.register(0x0020, PDOMBinding.type.getFactory());
-		registry.register(0x0030, PDOMConstant.type.getFactory());
-		registry.register(0x0040, PDOMConstantAnnotation.type.getFactory());
-		registry.register(0x0050, PDOMConstantArray.type.getFactory());
-		registry.register(0x0060, PDOMConstantBoolean.type.getFactory());
-		registry.register(0x0070, PDOMConstantByte.type.getFactory());
-		registry.register(0x0080, PDOMConstantChar.type.getFactory());
-		registry.register(0x0090, PDOMConstantClass.type.getFactory());
-		registry.register(0x00A0, PDOMConstantDouble.type.getFactory());
-		registry.register(0x00B0, PDOMConstantEnum.type.getFactory());
-		registry.register(0x00C0, PDOMConstantFloat.type.getFactory());
-		registry.register(0x00D0, PDOMConstantInt.type.getFactory());
-		registry.register(0x00E0, PDOMConstantLong.type.getFactory());
-		registry.register(0x00F0, PDOMConstantShort.type.getFactory());
-		registry.register(0x0100, PDOMConstantString.type.getFactory());
-		registry.register(0x0110, PDOMMethod.type.getFactory());
-		registry.register(0x0120, PDOMMethodId.type.getFactory());
-		registry.register(0x0150, PDOMResourceFile.type.getFactory());
-		registry.register(0x0160, PDOMTreeNode.type.getFactory());
-		registry.register(0x0170, PDOMType.type.getFactory());
-		registry.register(0x01A0, PDOMTypeSignature.type.getFactory());
-		registry.register(0x01A0, PDOMTypeId.type.getFactory());
-		registry.register(0x01B0, PDOMTypeInterface.type.getFactory());
-		registry.register(0x01D0, PDOMVariable.type.getFactory());
-		return registry;
-	}
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotation.java
index 35e516b..f2b3ca0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotation.java
@@ -58,6 +58,10 @@ public class PDOMAnnotation extends PDOMNode {
 		PARENT_CONSTANT.put(getPDOM(), this.address, constant);
 	}
 
+	public void setParent(PDOMComplexTypeSignature signature) {
+		PARENT_TYPE_SIGNATURE.put(getPDOM(), this.address, signature);
+	}
+
 	public PDOMTypeSignature getType() {
 		return ANNOTATION_TYPE.get(getPDOM(), this.address);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotationValuePair.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotationValuePair.java
index d7e2491..820f8ba 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotationValuePair.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMAnnotationValuePair.java
@@ -8,6 +8,9 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldString;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public class PDOMAnnotationValuePair extends PDOMNode {
 	public static final FieldManyToOne<PDOMAnnotation> APPLIES_TO;
 	public static final FieldString NAME;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
index fb1de5f..63264b2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
@@ -10,7 +10,12 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 /**
  * Represents a type signature that is anything other than a trivial reference to a concrete
  * type. If a type reference includes annotations, generic arguments, wildcards, or is a
- * type variable, this object represents it.
+ * type variable, this object represents it. 
+ * <p>
+ * Arrays are encoded in a special way. The RAW_TYPE points to a sentinel type called '['
+ * and the first type argument holds the array type.
+ * 
+ * @since 3.12
  */
 public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 	public static final FieldString VARIABLE_IDENTIFIER;
@@ -27,6 +32,7 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 		RAW_TYPE = FieldManyToOne.create(type, PDOMTypeId.USED_AS_COMPLEX_TYPE);
 		ANNOTATIONS = FieldOneToMany.create(type, PDOMAnnotation.PARENT_TYPE_SIGNATURE);
 		TYPE_ARGUMENTS = FieldOneToMany.create(type, PDOMTypeArgument.PARENT);
+
 		type.useStandardRefCounting().done();
 	}
 
@@ -43,6 +49,10 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 		return RAW_TYPE.get(getPDOM(), this.address);
 	}
 
+	public void setVariableIdentifier(String variableIdentifier) {
+		VARIABLE_IDENTIFIER.put(getPDOM(), this.address, variableIdentifier);
+	}
+
 	/**
 	 * If this type is a variable, this returns the identifier
 	 * 
@@ -51,4 +61,8 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 	public IString getVariableIdentifier() {
 		return VARIABLE_IDENTIFIER.get(getPDOM(), this.address);
 	}
+
+	public void setRawType(PDOMTypeId rawType) {
+		RAW_TYPE.put(getPDOM(), this.address, rawType);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstant.java
index 5fcd45d..ba5d67a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstant.java
@@ -8,6 +8,9 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public abstract class PDOMConstant extends PDOMNode {
 	// Parent pointers. Only one will be non-null.
 	// TODO(sxenos): Create something like a union to hold these, to eliminate this
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantAnnotation.java
index 2eb7cbe..a891e6f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantAnnotation.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantAnnotation extends PDOMConstant {
 	public static final FieldOneToOne<PDOMAnnotation> VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantArray.java
index ede1bc2..cd04f1a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantArray.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantArray.java
@@ -6,6 +6,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantArray extends PDOMConstant {
 	public static final FieldOneToMany<PDOMConstant> ELEMENTS;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantBoolean.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantBoolean.java
index cd23856..381f3c8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantBoolean.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantBoolean.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldByte;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantBoolean extends PDOMConstant {
 	public static final FieldByte VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantByte.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantByte.java
index 4fa625c..a6deda4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantByte.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantByte.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldByte;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantByte extends PDOMConstant {
 	public static final FieldByte VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantChar.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantChar.java
index 85cfaa8..2ef6791 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantChar.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantChar.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldChar;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantChar extends PDOMConstant {
 	public static final FieldChar VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantClass.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantClass.java
index 2da1310..2407b04 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantClass.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantClass.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantClass extends PDOMConstant {
 	public static final FieldManyToOne<PDOMTypeSignature> VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantDouble.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantDouble.java
index d5cf62d..5019e6a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantDouble.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantDouble.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldDouble;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantDouble extends PDOMConstant {
 	public static final FieldDouble VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantEnum.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantEnum.java
index 5efa654..d45603d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantEnum.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantEnum.java
@@ -5,6 +5,9 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldString;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantEnum extends PDOMConstant {
 	public static final FieldManyToOne<PDOMTypeSignature> ENUM_TYPE;
 	public static final FieldString ENUM_VALUE;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantFloat.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantFloat.java
index 5855774..094b97b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantFloat.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantFloat.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldFloat;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantFloat extends PDOMConstant {
 	public static final FieldFloat VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantInt.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantInt.java
index b69254c..1d3a482 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantInt.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantInt.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldInt;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantInt extends PDOMConstant {
 	public static final FieldInt VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantLong.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantLong.java
index fb8aee2..cb34bb5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantLong.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantLong.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldLong;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantLong extends PDOMConstant {
 	public static final FieldLong VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantShort.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantShort.java
index ba6724e..42a00be 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantShort.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantShort.java
@@ -4,6 +4,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.field.FieldShort;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantShort extends PDOMConstant {
 	public static final FieldShort VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantString.java
index 35a4c36..41204f3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMConstantString.java
@@ -5,6 +5,9 @@ import org.eclipse.jdt.internal.core.pdom.db.IString;
 import org.eclipse.jdt.internal.core.pdom.field.FieldString;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public final class PDOMConstantString extends PDOMConstant {
 	public static final FieldString VALUE;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
index 721b8b3..1692863 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
@@ -40,8 +40,9 @@ public class PDOMType extends PDOMBinding {
 //	public static final FieldManyToOne<PDOMTypeSignature> TYPE_DECLARATION;
 //	public static final FieldOneToMany<PDOMTypeParameter> TYPE_PARAMETERS;
 //	public static final FieldManyToOne<PDOMTypeSignature> WILDCARD;
-	public static final FieldManyToOne<PDOMTypeId> DECLARING_TYPE;
+//	public static final FieldManyToOne<PDOMTypeId> DECLARING_TYPE;
 	public static final FieldManyToOne<PDOMMethodId> DECLARING_METHOD;
+	public static final FieldOneToMany<PDOMTypeParameter> TYPE_PARAMETERS;
 //	public static final FieldLong TYPE_FLAGS;
 
 	@SuppressWarnings("hiding")
@@ -50,7 +51,7 @@ public class PDOMType extends PDOMBinding {
 	static {
 		type = StructDef.create(PDOMType.class, PDOMBinding.type);
 		TYPENAME = FieldManyToOne.create(type, PDOMTypeId.TYPES);
-		DECLARING_TYPE = FieldManyToOne.create(type, PDOMTypeId.DECLARED_TYPES);
+//		DECLARING_TYPE = FieldManyToOne.create(type, PDOMTypeId.DECLARED_TYPES);
 //		BOUND = FieldManyToOne.create(type, PDOMTypeSignature.class, PDOMTypeSignature.USED_AS_BOUND);
 //		GENERIC_TYPE_OF_WILDCARD_TYPE = FieldManyToOne.create(type, PDOMTypeSignature.class, PDOMTypeSignature.USED_AS_GENERIC_TYPE_OF_WILDCARD_TYPE);
 //		RANK = type.addInt();
@@ -71,6 +72,7 @@ public class PDOMType extends PDOMBinding {
 //		WILDCARD = FieldManyToOne.create(type, PDOMTypeSignature.class, PDOMTypeSignature.USED_AS_WILDCARD);
 //		TYPE_FLAGS = type.addLong();
 		DECLARING_METHOD = FieldManyToOne.create(type, PDOMMethodId.DECLARED_TYPES);
+		TYPE_PARAMETERS = FieldOneToMany.create(type, PDOMTypeParameter.PARENT);
 		type.done();
 	}
 
@@ -145,14 +147,6 @@ public class PDOMType extends PDOMBinding {
 		return FILE.get(getPDOM(), this.address);
 	}
 
-	public void setDeclaringType(PDOMTypeId enclosingType) {
-		DECLARING_TYPE.put(getPDOM(), this.address, enclosingType);
-	}
-
-	public PDOMTypeId getDeclaringType() {
-		return DECLARING_TYPE.get(getPDOM(), this.address);
-	}
-
 	public void setDeclaringMethod(PDOMMethodId createMethodId) {
 		DECLARING_METHOD.put(getPDOM(), this.address, createMethodId);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeArgument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeArgument.java
index 5255a42..8a5952f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeArgument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeArgument.java
@@ -6,6 +6,9 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldByte;
 import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public class PDOMTypeArgument extends PDOMNode {
 	public static final FieldManyToOne<PDOMComplexTypeSignature> PARENT;
 	public static final FieldManyToOne<PDOMTypeSignature> TYPE_SIGNATURE;
@@ -33,7 +36,7 @@ public class PDOMTypeArgument extends PDOMNode {
 	public PDOMTypeArgument(PDOM pdom, PDOMComplexTypeSignature typeSignature) {
 		super(pdom);
 
-		TYPE_SIGNATURE.put(pdom, this.address, typeSignature);
+		PARENT.put(pdom, this.address, typeSignature);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeBound.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeBound.java
new file mode 100644
index 0000000..cdef4f8
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeBound.java
@@ -0,0 +1,46 @@
+package org.eclipse.jdt.internal.core.pdom.java;
+
+import org.eclipse.jdt.internal.core.pdom.PDOM;
+import org.eclipse.jdt.internal.core.pdom.PDOMNode;
+import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.pdom.field.StructDef;
+
+/**
+ * Represents the bound on a generic parameter (a ClassBound or InterfaceBound in
+ * the sense of the Java VM spec Java SE 8 Edition, section 4.7.9.1)
+ * 
+ * @since 3.12
+ */
+public class PDOMTypeBound extends PDOMNode {
+	public static final FieldManyToOne<PDOMTypeParameter> PARENT;
+	public static final FieldManyToOne<PDOMTypeSignature> TYPE;
+
+	public static final StructDef<PDOMTypeBound> type;
+
+	static {
+		type = StructDef.create(PDOMTypeBound.class, PDOMNode.type);
+		PARENT = FieldManyToOne.createOwner(type, PDOMTypeParameter.BOUNDS);
+		TYPE = FieldManyToOne.create(type, PDOMTypeSignature.USED_AS_TYPE_BOUND);
+
+		type.done();
+	}
+
+	public PDOMTypeBound(PDOM pdom, long address) {
+		super(pdom, address);
+	}
+
+	public PDOMTypeBound(PDOMTypeParameter parent, PDOMTypeSignature signature) {
+		super(parent.getPDOM());
+
+		PARENT.put(getPDOM(), this.address, parent);
+		TYPE.put(getPDOM(), this.address, signature);
+	}
+
+	public PDOMTypeParameter getParent() {
+		return PARENT.get(getPDOM(), this.address);
+	}
+
+	public PDOMTypeSignature getType() {
+		return TYPE.get(getPDOM(), this.address);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
index 7e1ef05..19128ba 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
@@ -9,11 +9,13 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.pdom.field.FieldSearchKey;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public class PDOMTypeId extends PDOMTypeSignature {
 	public static final FieldSearchKey<JavaIndex> FIELD_DESCRIPTOR;
 	public static final FieldSearchKey<JavaIndex> SIMPLE_NAME;
 	public static final FieldOneToMany<PDOMType> TYPES;
-	public static final FieldOneToMany<PDOMType> DECLARED_TYPES;
 	public static final FieldOneToMany<PDOMComplexTypeSignature> USED_AS_COMPLEX_TYPE;
 
 	@SuppressWarnings("hiding")
@@ -26,7 +28,6 @@ public class PDOMTypeId extends PDOMTypeSignature {
 		FIELD_DESCRIPTOR = FieldSearchKey.create(type, JavaIndex.TYPES);
 		SIMPLE_NAME = FieldSearchKey.create(type, JavaIndex.SIMPLE_INDEX);
 		TYPES = FieldOneToMany.create(type, PDOMType.TYPENAME, 2);
-		DECLARED_TYPES = FieldOneToMany.create(type, PDOMType.DECLARING_TYPE);
 		USED_AS_COMPLEX_TYPE = FieldOneToMany.create(type, PDOMComplexTypeSignature.RAW_TYPE);
 		type.useStandardRefCounting().done();
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeParameter.java
new file mode 100644
index 0000000..d87ca55
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeParameter.java
@@ -0,0 +1,41 @@
+package org.eclipse.jdt.internal.core.pdom.java;
+
+import org.eclipse.jdt.internal.core.pdom.PDOM;
+import org.eclipse.jdt.internal.core.pdom.PDOMNode;
+import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
+import org.eclipse.jdt.internal.core.pdom.field.FieldString;
+import org.eclipse.jdt.internal.core.pdom.field.StructDef;
+
+/**
+ * Represents a TypeParameter, as described in Section 4.7.9.1 of
+ * the java VM specification, Java SE 8 edititon.
+ * @since 3.12
+ */
+public class PDOMTypeParameter extends PDOMNode {
+	public static final FieldManyToOne<PDOMType> PARENT;
+	public static final FieldString IDENTIFIER;
+	public static final FieldOneToMany<PDOMTypeBound> BOUNDS;
+
+	public static final StructDef<PDOMTypeParameter> type;
+
+	static {
+		type = StructDef.create(PDOMTypeParameter.class, PDOMNode.type);
+		PARENT = FieldManyToOne.createOwner(type, PDOMType.TYPE_PARAMETERS);
+		IDENTIFIER = type.addString();
+		BOUNDS = FieldOneToMany.create(type, PDOMTypeBound.PARENT);
+
+		type.done();
+	}
+
+	public PDOMTypeParameter(PDOM pdom, long address) {
+		super(pdom, address);
+	}
+
+	public PDOMTypeParameter(PDOMType parent, String identifier) {
+		super(parent.getPDOM());
+
+		PARENT.put(getPDOM(), this.address, parent);
+		IDENTIFIER.put(getPDOM(), this.address, identifier);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
index f538ddd..49da0fd 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
@@ -10,14 +10,15 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.pdom.java;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.PDOMNode;
+import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Corresponds roughly to a JavaTypeSignature, as described in section 4.7.9.1 of the Java VM spec version 4, with the
  * addition of annotations and backpointers to locations where the type is used.
@@ -38,21 +39,14 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 public abstract class PDOMTypeSignature extends PDOMNode {
 	public static final FieldOneToMany<PDOMType> SUBCLASSES;
 	public static final FieldOneToMany<PDOMAnnotation> ANNOTATIONS_OF_THIS_TYPE;
-//	public static final FieldOneToMany<PDOMType> USED_AS_BOUND;
-//	public static final FieldOneToMany<PDOMType> USED_AS_GENERIC_TYPE_OF_WILDCARD_TYPE;
-//	public static final FieldOneToMany<PDOMType> USED_AS_COMPONENT_TYPE;
-//	public static final FieldOneToMany<PDOMType> USED_AS_ELEMENT_TYPE;
-//	public static final FieldOneToMany<PDOMType> USED_AS_ERASURE;
 	public static final FieldOneToMany<PDOMTypeInterface> IMPLEMENTATIONS;
-//	public static final FieldOneToMany<PDOMTypeArgument> USED_AS_TYPE_ARGUMENT;
-//	public static final FieldOneToMany<PDOMTypeBounds> USED_AS_TYPE_BOUNDS;
-//	public static final FieldOneToMany<PDOMType> USED_AS_TYPE_DECLARATION;
-//	public static final FieldOneToMany<PDOMTypeParameter> USED_AS_TYPE_PARAMETER;
-//	public static final FieldOneToMany<PDOMType> USED_AS_WILDCARD;
 	public static final FieldOneToMany<PDOMVariable> VARIABLES_OF_TYPE;
 	public static final FieldOneToMany<PDOMConstantClass> USED_AS_CONSTANT;
 	public static final FieldOneToMany<PDOMConstantEnum> USED_AS_ENUM_CONSTANT;
 	public static final FieldOneToMany<PDOMTypeArgument> USED_AS_TYPE_ARGUMENT;
+	public static final FieldOneToMany<PDOMTypeBound> USED_AS_TYPE_BOUND;
+	public static final FieldManyToOne<PDOMTypeSignature> DECLARING_TYPE;
+	public static final FieldOneToMany<PDOMTypeSignature> DECLARED_TYPES;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<PDOMTypeSignature> type;
@@ -60,22 +54,15 @@ public abstract class PDOMTypeSignature extends PDOMNode {
 	static {
 		type = StructDef.createAbstract(PDOMTypeSignature.class, PDOMNode.type);
 		SUBCLASSES = FieldOneToMany.create(type, PDOMType.SUPERCLASS);
-//		USED_AS_BOUND = FieldOneToMany.create(type, PDOMType.class, PDOMType.BOUND);
 		ANNOTATIONS_OF_THIS_TYPE = FieldOneToMany.create(type, PDOMAnnotation.ANNOTATION_TYPE);
-//		USED_AS_GENERIC_TYPE_OF_WILDCARD_TYPE = FieldOneToMany.create(type, PDOMType.class, PDOMType.GENERIC_TYPE_OF_WILDCARD_TYPE);
-//		USED_AS_COMPONENT_TYPE = FieldOneToMany.create(type, PDOMType.class, PDOMType.COMPONENT_TYPE);
-//		USED_AS_ELEMENT_TYPE = FieldOneToMany.create(type, PDOMType.class, PDOMType.ELEMENT_TYPE);
-//		USED_AS_ERASURE = FieldOneToMany.create(type, PDOMType.class, PDOMType.ERASURE);
 		IMPLEMENTATIONS = FieldOneToMany.create(type, PDOMTypeInterface.IMPLEMENTS);
-//		USED_AS_TYPE_ARGUMENT = FieldOneToMany.create(type, PDOMTypeArgument.class, PDOMTypeArgument.ARGUMENT);
-//		USED_AS_TYPE_BOUNDS = FieldOneToMany.create(type, PDOMTypeBounds.class, PDOMTypeBounds.BOUNDS);
-//		USED_AS_TYPE_DECLARATION = FieldOneToMany.create(type, PDOMType.class, PDOMType.TYPE_DECLARATION);
-//		USED_AS_TYPE_PARAMETER = FieldOneToMany.create(type, PDOMTypeParameter.class, PDOMTypeParameter.PARAMETER);
-//		USED_AS_WILDCARD = FieldOneToMany.create(type, PDOMType.class, PDOMType.WILDCARD);
 		VARIABLES_OF_TYPE = FieldOneToMany.create(type, PDOMVariable.TYPE);
 		USED_AS_CONSTANT = FieldOneToMany.create(type, PDOMConstantClass.VALUE);
 		USED_AS_ENUM_CONSTANT = FieldOneToMany.create(type, PDOMConstantEnum.ENUM_TYPE);
 		USED_AS_TYPE_ARGUMENT = FieldOneToMany.create(type, PDOMTypeArgument.TYPE_SIGNATURE);
+		USED_AS_TYPE_BOUND = FieldOneToMany.create(type, PDOMTypeBound.TYPE);
+		DECLARING_TYPE = FieldManyToOne.create(type, null);
+		DECLARED_TYPES = FieldOneToMany.create(type, DECLARING_TYPE);
 		type.useStandardRefCounting().done();
 	}
 
@@ -109,6 +96,14 @@ public abstract class PDOMTypeSignature extends PDOMNode {
 		return result;
 	}
 
+	public void setDeclaringType(PDOMTypeSignature enclosingType) {
+		DECLARING_TYPE.put(getPDOM(), this.address, enclosingType);
+	}
+
+	public PDOMTypeSignature getDeclaringType() {
+		return DECLARING_TYPE.get(getPDOM(), this.address);
+	}
+
 	/**
 	 * Returns the raw version of this type, if one exists. That is, the version of this type 
 	 * without any generic arguments or annotations, which the java runtime sees. Returns null
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMVariable.java
index 91e1d2a..28cae67 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMVariable.java
@@ -29,8 +29,6 @@ public class PDOMVariable extends PDOMBinding {
 	public static final FieldManyToOne<PDOMBinding> PARENT;
 	public static final FieldString NAME;
 	public static final FieldOneToOne<PDOMConstant> CONSTANT;
-	// TODO: Add field for getConstantValue() 
-	// TODO: Add field for getVariableDeclaration()
 
 	@SuppressWarnings("hiding")
 	public static StructDef<PDOMVariable> type;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/TagTreeReader.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/TagTreeReader.java
index e94769a..abb2759 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/TagTreeReader.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/TagTreeReader.java
@@ -7,6 +7,9 @@ import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.db.Database;
 import org.eclipse.jdt.internal.core.pdom.db.IndexException;
 
+/**
+ * @since 3.12
+ */
 public abstract class TagTreeReader {
 	public static final int[] UNUSED_RESULT = new int[1];
 
commit 8311148272a3c51a33ce3b889ff945f91669dd18
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Dec 16 16:42:22 2015 -0800

    Bug 481796 - Refactor how inner classes are represented
    
    Split up the "declaring class" information to reflect how its stored in
    the .class file -- the data that disambiguates generic arguments is
    stored separately from the "declaring class".
    
    Change-Id: I3e5dc224630fb790decacee29b14866193f5a518

2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
12	40	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
4	12	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
20	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
15	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
0	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index eaf3b58..4cf378c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -515,7 +515,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 					.split(1)
 					.setWorkRemaining(3);
 
-			boolean isLocalClass = nextType.getTypeId().getDeclaringType() != null;
+			boolean isLocalClass = nextType.getDeclaringType() != null;
 			pathRequestor.acceptPath(typePath, isLocalClass);
 
 			HierarchyBinaryType binaryType = (HierarchyBinaryType)binariesFromIndexMatches2.get(typePath);
@@ -538,7 +538,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 
 private static HierarchyBinaryType createBinaryTypeFrom(PDOMType type) {
 	char[] enclosingTypeName = null;
-	PDOMTypeSignature enclosingType = type.getTypeId().getDeclaringType();
+	PDOMTypeSignature enclosingType = type.getDeclaringType();
 	if (enclosingType != null) {
 		enclosingTypeName = enclosingType.getRawType().getSimpleName().getChars();
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
index 6150fee..c6aa796 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/indexer/ClassFileToIndexConverter.java
@@ -45,8 +45,6 @@ import org.eclipse.jdt.internal.core.pdom.java.PDOMTypeSignature;
 import org.eclipse.jdt.internal.core.pdom.java.PDOMVariable;
 import org.eclipse.jdt.internal.core.util.Util;
 
-import java.util.Objects;
-
 public class ClassFileToIndexConverter {
 	private static final boolean ENABLE_LOGGING = false;
 	private static final char[][] EMPTY_CHAR_ARRAY_ARRAY = new char[0][];
@@ -161,18 +159,7 @@ public class ClassFileToIndexConverter {
 		}
 
 		type.setModifiers(binaryType.getModifiers());
- 
-		char[] enclosingTypeName = binaryType.getEnclosingTypeName();
-		// TODO(sxenos): There are some classes for which enclosingTypeName is null but which have classnames that
-		// resemble inner classes (ie: the classnames contain a '$'). Figure out what this means.
-//		assertThat((enclosingTypeName == null) == (name.getDeclaringType() == null), 
-//				"Declaring type should be null if and only if there is no enclosing type"); //$NON-NLS-1$
-		if (enclosingTypeName != null) {
-			String realEnclosingFieldDescriptor = JavaNames.binaryNameToFieldDescriptor(new String(enclosingTypeName));
-			String indexedFieldDescriptor = name.getDeclaringType().getRawType().getFieldDescriptor().getString();
-			assertThat(Objects.equals(realEnclosingFieldDescriptor, indexedFieldDescriptor),
-				"Incorrect field descriptor for declaring type"); //$NON-NLS-1$
-		}
+		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));
 
 		SignatureWrapper signatureWrapper = new SignatureWrapper(genericSignature);
 		readTypeParameters(type, typeAnnotations, signatureWrapper);
@@ -350,7 +337,7 @@ public class ClassFileToIndexConverter {
 	 * @return
 	 * @throws CoreException
 	 */
-	private PDOMTypeSignature parseClassTypeSignature(PDOMTypeSignature parentTypeOrNull,
+	private PDOMTypeSignature parseClassTypeSignature(PDOMComplexTypeSignature parentTypeOrNull,
 			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
 		char[] identifier = wrapper.nextName();
 		char[] fieldDescriptor;
@@ -365,6 +352,7 @@ public class ClassFileToIndexConverter {
 
 		char[] genericSignature = wrapper.signature;
 		boolean hasGenericArguments = (genericSignature.length > wrapper.start) && genericSignature[wrapper.start] == '<';
+		boolean isRawTypeWithNestedClass = genericSignature[wrapper.start] == '.';
 		PDOMTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
 		PDOMTypeSignature result = rawType;
 
@@ -372,8 +360,7 @@ public class ClassFileToIndexConverter {
 		// are not an inner type of a class that can't use this optimization. Basically, if there would be no attributes
 		// set on a PDOMComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
 		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
-		if (annotationList.length != 0 || hasGenericArguments
-				|| !Objects.equals(parentTypeOrNull, rawType.getDeclaringType())) {
+		if (annotationList.length != 0 || hasGenericArguments || parentTypeOrNull != null || isRawTypeWithNestedClass) {
 			PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
 			typeSignature.setRawType(rawType);
 			attachAnnotations(typeSignature, annotations);
@@ -414,31 +401,16 @@ public class ClassFileToIndexConverter {
 			result = typeSignature;
 
 			if (parentTypeOrNull != null) {
-				result.setDeclaringType(parentTypeOrNull);
+				typeSignature.setGenericDeclaringType(parentTypeOrNull);
 			}
-		}
-
-		if (wrapper.start >= genericSignature.length) {
-			throw new IndexException("Read beyond end of the type signature!"); //$NON-NLS-1$
-		}
 
-		switch (genericSignature[wrapper.start]) {
-			case ';': 
-				wrapper.start++; 
-				break;
-			case '.':
-				PDOMTypeSignature nestedType = parseClassTypeSignature(result, annotations.toNextNestedType(), wrapper);
-				
-				PDOMTypeSignature detectedNestedType = nestedType.getDeclaringType();
-				
-				// Perform a sanity-test
-				assertThat(Objects.equals(detectedNestedType, result),
-						"Incorrect declaring type for nested type");
-				assertThat(Objects.equals(nestedType.getDeclaringType().getRawType(), result.getRawType()),
-						"Incorrect declaring type for nested raw type");
-
-				result = nestedType;
-				break;
+			if (genericSignature[wrapper.start] == '.') {
+				result = parseClassTypeSignature(typeSignature, annotations.toNextNestedType(), wrapper);
+			}
+		} else {
+			if (genericSignature[wrapper.start] == ';') {
+				wrapper.start++;
+			}
 		}
 
 		return result;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
index bd9b9d0..8dc0e57 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/JavaIndex.java
@@ -30,9 +30,9 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = PDOM.version(1, 8);
+	static final int CURRENT_VERSION = PDOM.version(1, 9);
 	static final int MAX_SUPPORTED_VERSION= PDOM.version(1, Short.MAX_VALUE);
-	static final int MIN_SUPPORTED_VERSION= PDOM.version(1, 8);
+	static final int MIN_SUPPORTED_VERSION= PDOM.version(1, 9);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<PDOMResourceFile> FILES;
@@ -99,7 +99,7 @@ public class JavaIndex {
 	public PDOMTypeId createTypeId(char[] fieldDescriptor) {
 		return createTypeId(new String(fieldDescriptor));
 	}
-	
+
 	/**
 	 * Returns a type ID or creates a new one if it does not exist. The caller must
 	 * attach a reference to it after calling this method or it may leak.
@@ -111,15 +111,7 @@ public class JavaIndex {
 			return existingType;
 		}
 
-		int positionOfSeparator = fieldDescriptor.lastIndexOf('$');
-
-		PDOMTypeId result = new PDOMTypeId(this.pdom, fieldDescriptor);
-
-		if (positionOfSeparator != -1) {
-			result.setDeclaringType(createTypeId(fieldDescriptor.substring(0, positionOfSeparator)));
-		}
-
-		return result;
+		return new PDOMTypeId(this.pdom, fieldDescriptor);
 	}
 
 	public PDOM getPDOM() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
index 63264b2..459cf78 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMComplexTypeSignature.java
@@ -22,6 +22,8 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 	public static final FieldManyToOne<PDOMTypeId> RAW_TYPE;
 	public static final FieldOneToMany<PDOMAnnotation> ANNOTATIONS;
 	public static final FieldOneToMany<PDOMTypeArgument> TYPE_ARGUMENTS;
+	public static final FieldManyToOne<PDOMComplexTypeSignature> DECLARING_TYPE;
+	public static final FieldOneToMany<PDOMComplexTypeSignature> DECLARED_TYPES;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<PDOMComplexTypeSignature> type;
@@ -32,6 +34,8 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 		RAW_TYPE = FieldManyToOne.create(type, PDOMTypeId.USED_AS_COMPLEX_TYPE);
 		ANNOTATIONS = FieldOneToMany.create(type, PDOMAnnotation.PARENT_TYPE_SIGNATURE);
 		TYPE_ARGUMENTS = FieldOneToMany.create(type, PDOMTypeArgument.PARENT);
+		DECLARING_TYPE = FieldManyToOne.create(type, null);
+		DECLARED_TYPES = FieldOneToMany.create(type, DECLARING_TYPE);
 
 		type.useStandardRefCounting().done();
 	}
@@ -65,4 +69,20 @@ public class PDOMComplexTypeSignature extends PDOMTypeSignature {
 	public void setRawType(PDOMTypeId rawType) {
 		RAW_TYPE.put(getPDOM(), this.address, rawType);
 	}
+
+	public void setGenericDeclaringType(PDOMComplexTypeSignature enclosingType) {
+		DECLARING_TYPE.put(getPDOM(), this.address, enclosingType);
+	}
+
+	/**
+	 * Returns the declaring type (as reported by the type's generic signature).
+	 * Not to be confused with the declaring type as stored in the class file.
+	 * That is stored in {@link PDOMType#getDeclaringType}. Any class that is
+	 * nested inside another class with generic arguments will have one of
+	 * these. Classes nested inside non-generic classes won't have one of these,
+	 * and neither will non-nested classes.
+	 */
+	public PDOMComplexTypeSignature getGenericDeclaringType() {
+		return DECLARING_TYPE.get(getPDOM(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
index 1692863..b16fa54 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMType.java
@@ -10,8 +10,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.pdom.java;
 
-import java.util.List;
-
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.internal.core.pdom.IPDOMVisitor;
 import org.eclipse.jdt.internal.core.pdom.PDOM;
@@ -19,6 +17,8 @@ import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
+import java.util.List;
+
 /**
  * @since 3.12
  */
@@ -40,7 +40,7 @@ public class PDOMType extends PDOMBinding {
 //	public static final FieldManyToOne<PDOMTypeSignature> TYPE_DECLARATION;
 //	public static final FieldOneToMany<PDOMTypeParameter> TYPE_PARAMETERS;
 //	public static final FieldManyToOne<PDOMTypeSignature> WILDCARD;
-//	public static final FieldManyToOne<PDOMTypeId> DECLARING_TYPE;
+	public static final FieldManyToOne<PDOMTypeId> DECLARING_TYPE;
 	public static final FieldManyToOne<PDOMMethodId> DECLARING_METHOD;
 	public static final FieldOneToMany<PDOMTypeParameter> TYPE_PARAMETERS;
 //	public static final FieldLong TYPE_FLAGS;
@@ -51,7 +51,7 @@ public class PDOMType extends PDOMBinding {
 	static {
 		type = StructDef.create(PDOMType.class, PDOMBinding.type);
 		TYPENAME = FieldManyToOne.create(type, PDOMTypeId.TYPES);
-//		DECLARING_TYPE = FieldManyToOne.create(type, PDOMTypeId.DECLARED_TYPES);
+		DECLARING_TYPE = FieldManyToOne.create(type, PDOMTypeId.DECLARED_TYPES);
 //		BOUND = FieldManyToOne.create(type, PDOMTypeSignature.class, PDOMTypeSignature.USED_AS_BOUND);
 //		GENERIC_TYPE_OF_WILDCARD_TYPE = FieldManyToOne.create(type, PDOMTypeSignature.class, PDOMTypeSignature.USED_AS_GENERIC_TYPE_OF_WILDCARD_TYPE);
 //		RANK = type.addInt();
@@ -150,4 +150,15 @@ public class PDOMType extends PDOMBinding {
 	public void setDeclaringMethod(PDOMMethodId createMethodId) {
 		DECLARING_METHOD.put(getPDOM(), this.address, createMethodId);
 	}
+
+	/**
+	 * @param createTypeIdFromBinaryName
+	 */
+	public void setDeclaringType(PDOMTypeId createTypeIdFromBinaryName) {
+		DECLARING_TYPE.put(getPDOM(), this.address, createTypeIdFromBinaryName);
+	}
+
+	public PDOMTypeId getDeclaringType() {
+		return DECLARING_TYPE.get(getPDOM(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
index 19128ba..a77cee7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeId.java
@@ -17,6 +17,7 @@ public class PDOMTypeId extends PDOMTypeSignature {
 	public static final FieldSearchKey<JavaIndex> SIMPLE_NAME;
 	public static final FieldOneToMany<PDOMType> TYPES;
 	public static final FieldOneToMany<PDOMComplexTypeSignature> USED_AS_COMPLEX_TYPE;
+	public static final FieldOneToMany<PDOMType> DECLARED_TYPES;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<PDOMTypeId> type;
@@ -29,6 +30,7 @@ public class PDOMTypeId extends PDOMTypeSignature {
 		SIMPLE_NAME = FieldSearchKey.create(type, JavaIndex.SIMPLE_INDEX);
 		TYPES = FieldOneToMany.create(type, PDOMType.TYPENAME, 2);
 		USED_AS_COMPLEX_TYPE = FieldOneToMany.create(type, PDOMComplexTypeSignature.RAW_TYPE);
+		DECLARED_TYPES = FieldOneToMany.create(type, PDOMType.DECLARING_TYPE);
 		type.useStandardRefCounting().done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
index 49da0fd..a635274 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/PDOMTypeSignature.java
@@ -12,7 +12,6 @@ package org.eclipse.jdt.internal.core.pdom.java;
 
 import org.eclipse.jdt.internal.core.pdom.PDOM;
 import org.eclipse.jdt.internal.core.pdom.PDOMNode;
-import org.eclipse.jdt.internal.core.pdom.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.pdom.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.pdom.field.StructDef;
 
@@ -45,8 +44,6 @@ public abstract class PDOMTypeSignature extends PDOMNode {
 	public static final FieldOneToMany<PDOMConstantEnum> USED_AS_ENUM_CONSTANT;
 	public static final FieldOneToMany<PDOMTypeArgument> USED_AS_TYPE_ARGUMENT;
 	public static final FieldOneToMany<PDOMTypeBound> USED_AS_TYPE_BOUND;
-	public static final FieldManyToOne<PDOMTypeSignature> DECLARING_TYPE;
-	public static final FieldOneToMany<PDOMTypeSignature> DECLARED_TYPES;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<PDOMTypeSignature> type;
@@ -61,8 +58,6 @@ public abstract class PDOMTypeSignature extends PDOMNode {
 		USED_AS_ENUM_CONSTANT = FieldOneToMany.create(type, PDOMConstantEnum.ENUM_TYPE);
 		USED_AS_TYPE_ARGUMENT = FieldOneToMany.create(type, PDOMTypeArgument.TYPE_SIGNATURE);
 		USED_AS_TYPE_BOUND = FieldOneToMany.create(type, PDOMTypeBound.TYPE);
-		DECLARING_TYPE = FieldManyToOne.create(type, null);
-		DECLARED_TYPES = FieldOneToMany.create(type, DECLARING_TYPE);
 		type.useStandardRefCounting().done();
 	}
 
@@ -96,14 +91,6 @@ public abstract class PDOMTypeSignature extends PDOMNode {
 		return result;
 	}
 
-	public void setDeclaringType(PDOMTypeSignature enclosingType) {
-		DECLARING_TYPE.put(getPDOM(), this.address, enclosingType);
-	}
-
-	public PDOMTypeSignature getDeclaringType() {
-		return DECLARING_TYPE.get(getPDOM(), this.address);
-	}
-
 	/**
 	 * Returns the raw version of this type, if one exists. That is, the version of this type 
 	 * without any generic arguments or annotations, which the java runtime sees. Returns null
commit 7aa0bf1bd82226e77741d56372e00ab0038d7c43
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 09:17:18 2016 -0800

    Bug 481796 - Rename "record" to "address".
    
    Rename all variables which hold a database address to "address".
    
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>
    Change-Id: If3107ea72182f44644b430c590a77ba4ffa048f2

2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/AbstractTypeFactory.java
13	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/FindBinding.java
0	19	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/IInternalPDOMNode.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/ITypeFactory.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Nd.java
20	20	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdLinkedList.java
10	12	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNode.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNodeTypeRegistry.java
21	21	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdRawLinkedList.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Pointer.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PrimitiveTypes.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/Field.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldByte.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldChar.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldDouble.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldFloat.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldInt.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldLong.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldPointer.java
17	17	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldSearchIndex.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldShort.java
11	11	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldString.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/IRefCountedField.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/StructDef.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdAnnotation.java
28	28	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdBinding.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdComplexTypeSignature.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethod.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethodId.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdResourceFile.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTreeNode.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdType.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeId.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeInterface.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeSignature.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/AbstractTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/AbstractTypeFactory.java
index 7c4c7db..6b7ba08 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/AbstractTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/AbstractTypeFactory.java
@@ -17,10 +17,10 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef.DeletionSemantics;
  */
 public abstract class AbstractTypeFactory<T> implements ITypeFactory<T> {
 	@Override
-	public void destructFields(Nd dom, long record) {}
+	public void destructFields(Nd dom, long address) {}
 
 	@Override
-	public void destruct(Nd dom, long record) {}
+	public void destruct(Nd dom, long address) {}
 
 	@Override
 	public boolean hasDestructor() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/FindBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/FindBinding.java
index ce26119..e5579d8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/FindBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/FindBinding.java
@@ -51,32 +51,32 @@ public class FindBinding {
 //		private final long fLocalToFile;
 //		protected PDOMBinding fResult;
 //		private PDOM pdom;
-//	
+//
 //		protected DefaultFindBindingVisitor(PDOM pdom, char[] name, int[] constants, long localToFile) {
 //			this.pdom = pdom;
 //			this.fName = name;
 //			this.fConstants = constants;
 //			this.fLocalToFile= localToFile;
 //		}
-//		
+//
 //		// IBTreeVisitor
 //		@Override
-//		public int compare(long record) throws IndexException {
+//		public int compare(long address) throws IndexException {
 //			final Database db = this.pdom.getDB();
-//			IString nm1 = PDOMNamedNode.getDBName(db, record);
-//			int cmp= nm1.compareCompatibleWithIgnoreCase(this.fName); 
+//			IString nm1 = PDOMNamedNode.getDBName(db, address);
+//			int cmp= nm1.compareCompatibleWithIgnoreCase(this.fName);
 //			if (cmp == 0) {
-//				long t1= PDOMBinding.getLocalToFileRec(db, record);
+//				long t1= PDOMBinding.getLocalToFileRec(db, address);
 //				long t2= this.fLocalToFile;
 //				cmp= t1 < t2 ? -1 : (t1 > t2 ? 1 : 0);
 //			}
 //			return cmp;
 //		}
-//	
+//
 //		// IBTreeVisitor
 //		@Override
-//		public boolean visit(long record) throws IndexException {
-//			final PDOMNamedNode nnode = (PDOMNamedNode) PDOMNode.load(pdom, record);
+//		public boolean visit(long address) throws IndexException {
+//			final PDOMNamedNode nnode = (PDOMNamedNode) PDOMNode.load(pdom, address);
 //			if (nnode instanceof PDOMBinding) {
 //				final PDOMBinding binding = (PDOMBinding) nnode;
 //				if (matches(binding)) {
@@ -86,7 +86,7 @@ public class FindBinding {
 //			}
 //			return true;
 //		}
-//		
+//
 //		protected boolean matches(PDOMBinding nnode) throws IndexException {
 //			if (nnode.hasName(fName)) {
 //				int constant = nnode.getNodeType();
@@ -131,7 +131,7 @@ public class FindBinding {
 //			if (cmp == 0) {								// any order will do.
 //				if (record1 < record2) {
 //					return -1;
-//				} else if (record1 > record2) {			
+//				} else if (record1 > record2) {
 //					return 1;
 //				}
 //			}
@@ -141,7 +141,7 @@ public class FindBinding {
 //
 //	public static class MacroBTreeComparator implements IBTreeComparator {
 //		final private Database db;
-//		
+//
 //		public MacroBTreeComparator(Database database) {
 //			db= database;
 //		}
@@ -154,7 +154,7 @@ public class FindBinding {
 //		}
 //	}
 //
-//	public static PDOMBinding findBinding(BTree btree, final PDOM pdom, final char[] name, 
+//	public static PDOMBinding findBinding(BTree btree, final PDOM pdom, final char[] name,
 //			final int[] constants, final long localToFileRec) throws IndexException {
 //		final DefaultFindBindingVisitor visitor = new DefaultFindBindingVisitor(pdom, name, constants, localToFileRec);
 //		btree.accept(visitor);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/IInternalPDOMNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/IInternalPDOMNode.java
deleted file mode 100644
index 9963769..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/IInternalPDOMNode.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Stefan Xenos (Google) - Initial implementation
- *******************************************************************************/ 
-package org.eclipse.jdt.internal.core.pdom;
-
-/**
- * Common, but internal methods for all pdom nodes.
- * @since 3.12
- */
-public interface IInternalPDOMNode extends IPDOMNode {
-	public long getRecord();
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/ITypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/ITypeFactory.java
index 23033bb..c8724d2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/ITypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/ITypeFactory.java
@@ -39,7 +39,7 @@ public interface ITypeFactory<T> {
 
 	/**
 	 * Invokes any cleanup code for this object. In particular, it deallocates any memory allocated by the type's
-	 * fields. Does not free the memory at record, though. This is used for both objects which were allocated their own
+	 * fields. Does not free the memory at address, though. This is used for both objects which were allocated their own
 	 * memory block and objects which are embedded as fields within a larger object. If the object was given its own
 	 * memory block, it is the caller's responsibility to invoke free after calling this method.
 	 */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Nd.java
index 2280d71..40ae41c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Nd.java
@@ -566,12 +566,12 @@ public class Nd {
 	}
 
     /**
-     * @param record
+     * @param address
      * @param nodeType
      * @return
      */
-    public NdNode getNode(long record, short nodeType) throws IndexException {
-    	return this.fNodeTypeRegistry.createNode(this, record, nodeType);
+    public NdNode getNode(long address, short nodeType) throws IndexException {
+    	return this.fNodeTypeRegistry.createNode(this, address, nodeType);
     }
 
     public <T extends NdNode> ITypeFactory<T> getTypeFactory(short nodeType) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdLinkedList.java
index c984470..3431344 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdLinkedList.java
@@ -23,32 +23,32 @@ public final class NdLinkedList<T> {
 		public void visit(T record, short metadataBits, int index) throws IndexException;
 	}
 
-	public NdLinkedList(Nd pdom, long record, ITypeFactory<T> elementFactory, int recordsInFirstBlock,
+	public NdLinkedList(Nd pdom, long address, ITypeFactory<T> elementFactory, int recordsInFirstBlock,
 			int recordsInSubsequentBlocks) {
-		this(pdom, record, elementFactory, recordsInFirstBlock, recordsInSubsequentBlocks, 0);
+		this(pdom, address, elementFactory, recordsInFirstBlock, recordsInSubsequentBlocks, 0);
 	}
 
-	public NdLinkedList(Nd pdom, long record, ITypeFactory<T> elementFactory, int recordsInFirstBlock,
+	public NdLinkedList(Nd pdom, long address, ITypeFactory<T> elementFactory, int recordsInFirstBlock,
 			int recordsInSubsequentBlocks, int metadataBitsPerElement) {
-		this.rawList = new NdRawLinkedList(pdom, record, elementFactory.getRecordSize(), recordsInFirstBlock,
+		this.rawList = new NdRawLinkedList(pdom, address, elementFactory.getRecordSize(), recordsInFirstBlock,
 				recordsInSubsequentBlocks, metadataBitsPerElement);
 		this.elementFactory = elementFactory;
 	}
 
 	/**
 	 * Computes the size of this list. This is an O(n) operation.
-	 * 
+	 *
 	 * @return the size of this list
-	 * @throws IndexException 
+	 * @throws IndexException
 	 */
 	public int size() throws IndexException {
 		return this.rawList.size();
 	}
-	
+
 	public T addMember(short metadataBits) throws IndexException {
-		long record = this.rawList.addMember(metadataBits);
+		long address = this.rawList.addMember(metadataBits);
 
-		return this.elementFactory.create(this.rawList.getPDOM(), record);
+		return this.elementFactory.create(this.rawList.getPDOM(), address);
 	}
 
 	public void accept(final ILinkedListVisitor<T> visitor) throws IndexException {
@@ -56,9 +56,9 @@ public final class NdLinkedList<T> {
 		final ITypeFactory<T> localElementFactory = this.elementFactory;
 		localRawList.accept(new NdRawLinkedList.ILinkedListVisitor() {
 			@Override
-			public void visit(long record, short metadataBits, int index) throws IndexException {
+			public void visit(long address, short metadataBits, int index) throws IndexException {
 				visitor.visit(localElementFactory.create(localRawList.getPDOM(),
-						record), metadataBits, index);
+						address), metadataBits, index);
 			}
 		});
 	}
@@ -73,8 +73,8 @@ public final class NdLinkedList<T> {
 			final int metadataBitsPerElement) {
 
 		return new AbstractTypeFactory<NdLinkedList<T>>() {
-			public NdLinkedList<T> create(Nd dom, long record) {
-				return new NdLinkedList<T>(dom, record, elementFactory, recordsInFirstBlock, recordsInSubsequentBlocks, metadataBitsPerElement);
+			public NdLinkedList<T> create(Nd dom, long address) {
+				return new NdLinkedList<T>(dom, address, elementFactory, recordsInFirstBlock, recordsInSubsequentBlocks, metadataBitsPerElement);
 			}
 
 			@Override
@@ -94,27 +94,27 @@ public final class NdLinkedList<T> {
 			}
 
 			@Override
-			public void destructFields(Nd dom, long record) {
-				create(dom, record).destruct();
+			public void destructFields(Nd dom, long address) {
+				create(dom, address).destruct();
 			}
 
 			@Override
-			public void destruct(Nd dom, long record) {
-				destructFields(dom, record);
+			public void destruct(Nd dom, long address) {
+				destructFields(dom, address);
 			}
 		};
 	}
 
 	/**
-	 * 
+	 *
 	 */
 	protected void destruct() {
 		if (this.elementFactory.hasDestructor()) {
 			final Nd pdom = this.rawList.getPDOM();
 			this.rawList.accept(new NdRawLinkedList.ILinkedListVisitor() {
 				@Override
-				public void visit(long record, short metadataBits, int index) throws IndexException {
-					NdLinkedList.this.elementFactory.destruct(pdom, record);
+				public void visit(long address, short metadataBits, int index) throws IndexException {
+					NdLinkedList.this.elementFactory.destruct(pdom, address);
 				}
 			});
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNode.java
index 5ee4e64..0f5821b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNode.java
@@ -21,10 +21,10 @@ import org.eclipse.jdt.internal.core.pdom.field.StructDef;
  * This class managed the parent pointer.
  * @since 3.12
  */
-public abstract class NdNode implements IInternalPDOMNode, IDestructable {
+public abstract class NdNode implements IDestructable {
 	public static final FieldShort NODE_TYPE;
 
-	public static final StructDef<NdNode> type; 
+	public static final StructDef<NdNode> type;
 
 	static {
 		type = StructDef.create(NdNode.class);
@@ -43,11 +43,11 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 	}
 
 	/**
-	 * Load a node from the specified record in the given database.  Return null if a node cannot
+	 * Load a node from the specified address in the given database.  Return null if a node cannot
 	 * be loaded.
 	 *
 	 * @param pdom The PDOM from which to load the node.
-	 * @param address The record of the node in the given PDOM.
+	 * @param address The address of the node in the given PDOM.
 	 * @return The PDOMNode at the specified location or null if a node cannot be loaded.
 	 * @When there is a problem reading the given pdom's Database
 	 */
@@ -68,10 +68,10 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 		NdNode result = pdom.getNode(address, NODE_TYPE.get(pdom, address));
 
 		if (!clazz.isAssignableFrom(result.getClass())) {
-			throw new IndexException("Found wrong data type at record " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
+			throw new IndexException("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
 				clazz.getClass() + " but found " + result.getClass()); //$NON-NLS-1$
 		}
-	
+
 		return (T)result;
 	}
 
@@ -116,11 +116,10 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 		return this.pdom.getNodeType(getClass());
 	}
 
-	@Override
-	public final long getRecord() {
+	public final long getAddress() {
 		return this.address;
 	}
-	
+
 	public final long getBindingID() {
 		return this.address;
 	}
@@ -133,7 +132,7 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 			NdNode other = (NdNode) obj;
 			return getPDOM() == other.getPDOM() && this.address == other.address;
 		}
-		
+
 		return super.equals(obj);
 	}
 
@@ -142,7 +141,6 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 		return (int) (this.address >> Database.BLOCK_SIZE_DELTA_BITS);
 	}
 
-	@Override
 	public void accept(IPDOMVisitor visitor) {
 		// No children here.
 	}
@@ -176,7 +174,7 @@ public abstract class NdNode implements IInternalPDOMNode, IDestructable {
 	}
 
 	/**
-	 * Dispose this PDOMNode. Subclasses should extend this method to perform any high-level node-specific cleanup. 
+	 * Dispose this PDOMNode. Subclasses should extend this method to perform any high-level node-specific cleanup.
 	 * This will be invoked prior to disposing the fields. Implementations must invoke their parent's destruct method
 	 * and should not destruct the fields.
 	 * <p>
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNodeTypeRegistry.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNodeTypeRegistry.java
index a7d190d..3aad4f9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNodeTypeRegistry.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdNodeTypeRegistry.java
@@ -10,13 +10,13 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.pdom;
 
-import org.eclipse.jdt.internal.core.pdom.db.IndexException;
-
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
+import org.eclipse.jdt.internal.core.pdom.db.IndexException;
+
 /**
  * Maps integer constants onto factories for PDOMNode objects
  * @since 3.12
@@ -67,10 +67,10 @@ public class NdNodeTypeRegistry<R> {
 	}
 
 
-	public R createNode(Nd pdom, long record, short nodeType) throws IndexException {
+	public R createNode(Nd pdom, long address, short nodeType) throws IndexException {
 		ITypeFactory<? extends R> typeFactory = this.types.get(nodeType);
 
-		return typeFactory.create(pdom, record);
+		return typeFactory.create(pdom, address);
 	}
 
 	public short getTypeForClass(Class<? extends R> toQuery) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdRawLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdRawLinkedList.java
index a443b65..99ee74d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdRawLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/NdRawLinkedList.java
@@ -17,7 +17,7 @@ import org.eclipse.jdt.internal.core.pdom.db.IndexException;
  * PDOMLinkedList stores a list of fixed-sized records. Along with the records themselves, there is also
  * a bit field associated with each record which can hold a small number of bits of metadata per record.
  * The underlying format is as follows:
- * 
+ *
  * <pre>
  * Bytes       Content
  * ----------------
@@ -29,9 +29,9 @@ import org.eclipse.jdt.internal.core.pdom.db.IndexException;
  * recordSize  The content of the first element in the block
  * recordSize  The content of the second element in the block
  * ...         repeated recordsPerBlock times
- * recordSize  If the block is full, this holds the last 
+ * recordSize  If the block is full, this holds the last
  * </pre>
- * 
+ *
  * stored in linked blocks where each block is an array of record pointers. Each block contains a pointer to the
  * subsequent block, so they can be chained.
  * <p>
@@ -44,35 +44,35 @@ public class NdRawLinkedList {
 	private static final int NEXT_MEMBER_BLOCK = 0;
 	private static final int ELEMENT_START_POSITION = NEXT_MEMBER_BLOCK + Database.PTR_SIZE;
 
-	private final long record;
+	private final long address;
 	private final Nd dom;
 	private final int firstBlockRecordCount;
 	private final int recordCount;
-	private final int elementRecordSize; 
+	private final int elementRecordSize;
 	private final int metadataBitsPerRecord;
 
-	// Derived data. Holds the record for the last block we know about
+	// Derived data. Holds the address for the last block we know about
 	private long lastKnownBlock;
 
 	public static interface ILinkedListVisitor {
-		public void visit(long record, short metadataBits, int index) throws IndexException;
+		public void visit(long address, short metadataBits, int index) throws IndexException;
 	}
 
 	/**
 	 * @param pdom PDOM object
-	 * @param record pointer to the start of the linked list
+	 * @param address pointer to the start of the linked list
 	 * @param recordsPerBlock number of records per block. This is normally a hardcoded value.
 	 */
-	public NdRawLinkedList(Nd pdom, long record, int elementRecordSize, int firstBlockRecordCount, int recordsPerBlock,
+	public NdRawLinkedList(Nd pdom, long address, int elementRecordSize, int firstBlockRecordCount, int recordsPerBlock,
 			int metadataBitsPerRecord) {
 		assert(recordsPerBlock > 0);
 		assert(firstBlockRecordCount >= 0);
 		this.dom = pdom;
-		this.record = record;
+		this.address = address;
 		this.firstBlockRecordCount = firstBlockRecordCount;
 		this.recordCount = recordsPerBlock;
 		this.elementRecordSize = elementRecordSize;
-		this.lastKnownBlock = record;
+		this.lastKnownBlock = address;
 		this.metadataBitsPerRecord = metadataBitsPerRecord;
 	}
 
@@ -80,12 +80,12 @@ public class NdRawLinkedList {
 //		this.dom = dom;
 //		this.recordCount = recordsPerBlock;
 //		this.elementRecordSize = elementRecordSize;
-//		this.record = dom.getDB().malloc(Database.PTR_SIZE + this.elementRecordSize * recordsPerBlock);
-//		this.lastKnownBlock = this.record;
+//		this.address = dom.getDB().malloc(Database.PTR_SIZE + this.elementRecordSize * recordsPerBlock);
+//		this.lastKnownBlock = this.address;
 //	}
 
 	/**
-	 * Returns the record size for a linked list with the given element record size and number of 
+	 * Returns the record size for a linked list with the given element record size and number of
 	 * records per block
 	 */
 	public static int recordSize(int elementRecordSize, int recordsPerBlock, int metadataBitsPerRecord) {
@@ -116,13 +116,13 @@ public class NdRawLinkedList {
 		return this.dom.getDB();
 	}
 
-	public long getRecord() {
-		return this.record;
+	public long getAddress() {
+		return this.address;
 	}
 
 	/**
 	 * Adds a new element to the list and returns the record pointer to the start of the newly-allocated object
-	 * 
+	 *
 	 * @param metadataBits the metadata bits to attach to the new member. Use 0 if this list does not use metadata.
 	 */
 	public long addMember(short metadataBits) throws IndexException {
@@ -201,7 +201,7 @@ public class NdRawLinkedList {
 		int blockRecordCount = this.firstBlockRecordCount;
 		int metadataMask = (1 << this.metadataBitsPerRecord) - 1;
 		int metadataRecordsPerShort = this.metadataBitsPerRecord == 0 ? 0 : (16 / this.metadataBitsPerRecord);
-		long current = this.record;
+		long current = this.address;
 		while (true) {
 			long ptr = db.getRecPtr(current + NEXT_MEMBER_BLOCK);
 			int elementsInBlock = getElementsInBlock(current, ptr, blockRecordCount);
@@ -237,7 +237,7 @@ public class NdRawLinkedList {
 
 	public void destruct() throws IndexException {
 		Database db = getDB();
-		long current = this.record;
+		long current = this.address;
 		while (true) {
 			long ptr = db.getRecPtr(current + NEXT_MEMBER_BLOCK);
 			db.free(current);
@@ -261,13 +261,13 @@ public class NdRawLinkedList {
 
 	/**
 	 * Returns the number of elements in this list. This is an O(n) operation.
-	 * @throws IndexException 
+	 * @throws IndexException
 	 */
 	public int size() throws IndexException {
 		int count = 0;
 		Database db = getDB();
 		int currentRecordCount = this.firstBlockRecordCount;
-		long current = this.record;
+		long current = this.address;
 		while (true) {
 			long ptr = db.getRecPtr(current + NEXT_MEMBER_BLOCK);
 			count += getElementsInBlock(current, ptr, currentRecordCount);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Pointer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Pointer.java
index 9053077..5a46991 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Pointer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/Pointer.java
@@ -20,17 +20,17 @@ import org.eclipse.jdt.internal.core.pdom.db.Database;
  */
 public class Pointer<T> {
 	private final Nd pdom;
-	private final long record;
+	private final long address;
 	private ITypeFactory<T> targetFactory;
-	
-	public Pointer(Nd pdom, long record, ITypeFactory<T> targetFactory) {
+
+	public Pointer(Nd pdom, long address, ITypeFactory<T> targetFactory) {
 		this.pdom = pdom;
-		this.record = record;
+		this.address = address;
 		this.targetFactory = targetFactory;
 	}
 
 	public T get() {
-		long ptr = this.pdom.getDB().getRecPtr(this.record);
+		long ptr = this.pdom.getDB().getRecPtr(this.address);
 
 		if (ptr == 0) {
 			return null;
@@ -45,8 +45,8 @@ public class Pointer<T> {
 		}
 		return new AbstractTypeFactory<Pointer<T>>() {
 			@Override
-			public Pointer<T> create(Nd dom, long record) {
-				return new Pointer<T>(dom, record, targetFactory);
+			public Pointer<T> create(Nd dom, long address) {
+				return new Pointer<T>(dom, address, targetFactory);
 			}
 
 			@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PrimitiveTypes.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PrimitiveTypes.java
index 261ce29..ec2f997 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PrimitiveTypes.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/PrimitiveTypes.java
@@ -19,8 +19,8 @@ import org.eclipse.jdt.internal.core.pdom.db.Database;
 public class PrimitiveTypes {
 	public static final ITypeFactory<Long> Pointer = new AbstractTypeFactory<Long>() {
 		@Override
-		public Long create(Nd dom, long record) {
-			return dom.getDB().getRecPtr(record);
+		public Long create(Nd dom, long address) {
+			return dom.getDB().getRecPtr(address);
 		}
 
 		@Override
@@ -36,8 +36,8 @@ public class PrimitiveTypes {
 
 	public static final ITypeFactory<Short> Short = new AbstractTypeFactory<Short>() {
 		@Override
-		public Short create(Nd dom, long record) {
-			return dom.getDB().getShort(record);
+		public Short create(Nd dom, long address) {
+			return dom.getDB().getShort(address);
 		}
 
 		@Override
@@ -53,8 +53,8 @@ public class PrimitiveTypes {
 
 	public static final ITypeFactory<Integer> Integer = new AbstractTypeFactory<Integer>() {
 		@Override
-		public Integer create(Nd dom, long record) {
-			return dom.getDB().getInt(record);
+		public Integer create(Nd dom, long address) {
+			return dom.getDB().getInt(address);
 		}
 
 		@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/Field.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/Field.java
index ef0b8e4..658ada5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/Field.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/Field.java
@@ -37,8 +37,8 @@ public final class Field<T> implements IField, IDestructableField {
 		this.factory = objectFactory;
 	}
 
-	public T get(Nd pdom, long record) {
-		return this.factory.create(pdom, record + this.offset);
+	public T get(Nd pdom, long address) {
+		return this.factory.create(pdom, address + this.offset);
 	}
 
 	public boolean hasDestructor() {
@@ -46,8 +46,8 @@ public final class Field<T> implements IField, IDestructableField {
 	}
 
 	@Override
-	public void destruct(Nd pdom, long record) {
-		this.factory.destruct(pdom, record + this.offset);
+	public void destruct(Nd pdom, long address) {
+		this.factory.destruct(pdom, address + this.offset);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldByte.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldByte.java
index 5b826ee..8236fde 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldByte.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldByte.java
@@ -24,13 +24,13 @@ public class FieldByte implements IField {
 	public FieldByte() {
 	}
 
-	public byte get(Nd pdom, long record) {
+	public byte get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getByte(record + this.offset);
+		return db.getByte(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, byte newValue) {
-		pdom.getDB().putByte(record + this.offset, newValue);
+	public void put(Nd pdom, long address, byte newValue) {
+		pdom.getDB().putByte(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldChar.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldChar.java
index 9ff21e1..6b17244 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldChar.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldChar.java
@@ -24,13 +24,13 @@ public class FieldChar implements IField {
 	public FieldChar() {
 	}
 
-	public char get(Nd pdom, long record) {
+	public char get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getChar(record + this.offset);
+		return db.getChar(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, char newValue) {
-		pdom.getDB().putChar(record + this.offset, newValue);
+	public void put(Nd pdom, long address, char newValue) {
+		pdom.getDB().putChar(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldDouble.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldDouble.java
index a7f3599..740f80d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldDouble.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldDouble.java
@@ -24,13 +24,13 @@ public class FieldDouble implements IField {
 	public FieldDouble() {
 	}
 
-	public double get(Nd pdom, long record) {
+	public double get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getDouble(record + this.offset);
+		return db.getDouble(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, double newValue) {
-		pdom.getDB().putDouble(record + this.offset, newValue);
+	public void put(Nd pdom, long address, double newValue) {
+		pdom.getDB().putDouble(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldFloat.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldFloat.java
index 148d3cb..430e30e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldFloat.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldFloat.java
@@ -24,13 +24,13 @@ public class FieldFloat implements IField {
 	public FieldFloat() {
 	}
 
-	public float get(Nd pdom, long record) {
+	public float get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getFloat(record + this.offset);
+		return db.getFloat(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, float newValue) {
-		pdom.getDB().putFloat(record + this.offset, newValue);
+	public void put(Nd pdom, long address, float newValue) {
+		pdom.getDB().putFloat(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldInt.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldInt.java
index 44b0df2..3941bcb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldInt.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldInt.java
@@ -24,13 +24,13 @@ public class FieldInt implements IField {
 	public FieldInt() {
 	}
 
-	public int get(Nd pdom, long record) {
+	public int get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getInt(record + this.offset);
+		return db.getInt(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, int newValue) {
-		pdom.getDB().putInt(record + this.offset, newValue);
+	public void put(Nd pdom, long address, int newValue) {
+		pdom.getDB().putInt(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldLong.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldLong.java
index 71cf959..d2d55b2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldLong.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldLong.java
@@ -25,13 +25,13 @@ public class FieldLong implements IField {
 	public FieldLong() {
 	}
 
-	public long get(Nd pdom, long record) {
+	public long get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getLong(record + this.offset);
+		return db.getLong(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, long newValue) {
-		pdom.getDB().putLong(record + this.offset, newValue);
+	public void put(Nd pdom, long address, long newValue) {
+		pdom.getDB().putLong(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
index 4c76f9b..b47610f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldOneToMany.java
@@ -175,12 +175,12 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 	}
 
 	@Override
-	public boolean hasReferences(Nd pdom, long record) {
+	public boolean hasReferences(Nd pdom, long address) {
 		// If this field owns the objects it points to, don't treat the incoming pointers as ref counts
 		if (this.forwardPointer.pointsToOwner) {
 			return false;
 		}
-		return !isEmpty(pdom, record);
+		return !isEmpty(pdom, address);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldPointer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldPointer.java
index 9b1e621..675a969 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldPointer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldPointer.java
@@ -22,13 +22,13 @@ public class FieldPointer implements IField {
 	public FieldPointer() {
 	}
 
-	public long get(Nd pdom, long record) {
+	public long get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getRecPtr(record + this.offset);
+		return db.getRecPtr(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, long newValue) {
-		pdom.getDB().putRecPtr(record + this.offset, newValue);
+	public void put(Nd pdom, long address, long newValue) {
+		pdom.getDB().putRecPtr(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldSearchIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldSearchIndex.java
index 6a85328..88196d5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldSearchIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldSearchIndex.java
@@ -130,8 +130,8 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		}
 
 		@Override
-		public int compare(long record) throws IndexException {
-			IString key = FieldSearchIndex.this.searchKey.get(this.pdom, record);
+		public int compare(long address) throws IndexException {
+			IString key = FieldSearchIndex.this.searchKey.get(this.pdom, address);
 
 			if (this.searchCriteria.isPrefixSearch()) {
 				return key.comparePrefix(this.searchCriteria.getSearchString(), false);
@@ -141,21 +141,21 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		}
 
 		@Override
-		public boolean visit(long record) throws IndexException {
+		public boolean visit(long address) throws IndexException {
 			if (this.searchCriteria.requiresSpecificNodeType()) {
-				short nodeType = NdNode.NODE_TYPE.get(this.pdom, record);
+				short nodeType = NdNode.NODE_TYPE.get(this.pdom, address);
 
 				if (!this.searchCriteria.acceptsNodeType(nodeType)) {
 					return true;
 				}
 			}
 
-//			long parent = PDOMNamedNode.PARENT.getAddress(this.pdom, record);
+//			long parent = PDOMNamedNode.PARENT.getAddress(this.pdom, address);
 //			if (parent != this.searchCriteria.getRequiredParentAddress()) {
 //				return true;
 //			}
 
-			IString key = FieldSearchIndex.this.searchKey.get(this.pdom, record);
+			IString key = FieldSearchIndex.this.searchKey.get(this.pdom, address);
 
 			if (this.searchCriteria.isMatchingCase()) {
 				if (this.searchCriteria.isPrefixSearch()) {
@@ -169,11 +169,11 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 				}
 			}
 
-			acceptResult(record);
+			acceptResult(address);
 			return true;
 		}
 
-		protected abstract void acceptResult(long record);
+		protected abstract void acceptResult(long address);
 	}
 
 	private FieldSearchIndex(FieldSearchKey<?> searchKey) {
@@ -214,13 +214,13 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		return result;
 	}
 
-	public BTree get(Nd pdom, long record) {
-		return this.btreeFactory.create(pdom, record + this.offset);
+	public BTree get(Nd pdom, long address) {
+		return this.btreeFactory.create(pdom, address + this.offset);
 	}
 
 	@Override
-	public void destruct(Nd pdom, long record) {
-		this.btreeFactory.destruct(pdom, record);
+	public void destruct(Nd pdom, long address) {
+		this.btreeFactory.destruct(pdom, address);
 	}
 
 	@Override
@@ -242,11 +242,11 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		final long[] result = new long[1];
 		get(pdom, address).accept(new SearchCriteriaToBtreeVisitorAdapter(searchCriteria, pdom) {
 			@Override
-			protected void acceptResult(long record) {
-				long rank = rankFunction.getRank(pdom, record);
+			protected void acceptResult(long address) {
+				long rank = rankFunction.getRank(pdom, address);
 				if (rank >= resultRank[0]) {
 					resultRank[0] = rank;
-					result[0] = record;
+					result[0] = address;
 				}
 			}
 		});
@@ -261,8 +261,8 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		final List<T> result = new ArrayList<T>();
 		get(pdom, address).accept(new SearchCriteriaToBtreeVisitorAdapter(searchCriteria, pdom) {
 			@Override
-			protected void acceptResult(long record) {
-				result.add((T)NdNode.load(pdom, record));
+			protected void acceptResult(long address) {
+				result.add((T)NdNode.load(pdom, address));
 			}
 		});
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldShort.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldShort.java
index e68c632..1d2a3e8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldShort.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldShort.java
@@ -22,13 +22,13 @@ public class FieldShort implements IField {
 	public FieldShort() {
 	}
 
-	public short get(Nd pdom, long record) {
+	public short get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		return db.getShort(record + this.offset);
+		return db.getShort(address + this.offset);
 	}
 
-	public void put(Nd pdom, long record, short newValue) {
-		pdom.getDB().putShort(record + this.offset, newValue);
+	public void put(Nd pdom, long address, short newValue) {
+		pdom.getDB().putShort(address + this.offset, newValue);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldString.java
index c0ec56a..69bc3fe 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/FieldString.java
@@ -25,9 +25,9 @@ public class FieldString implements IDestructableField, IField {
 	public FieldString() {
 	}
 
-	public IString get(Nd pdom, long record) {
+	public IString get(Nd pdom, long address) {
 		Database db = pdom.getDB();
-		long namerec = db.getRecPtr(record + this.offset);
+		long namerec = db.getRecPtr(address + this.offset);
 
 		if (namerec == 0) {
 			return EmptyString.create();
@@ -35,26 +35,26 @@ public class FieldString implements IDestructableField, IField {
 		return db.getString(namerec);
 	}
 
-	public void put(Nd pdom, long record, char[] newString) {
+	public void put(Nd pdom, long address, char[] newString) {
 		final Database db= pdom.getDB();
-		IString name= get(pdom, record);
+		IString name= get(pdom, address);
 		if (name.compare(newString, true) != 0) {
 			name.delete();
 			if (newString != null && newString.length > 0) {
-				db.putRecPtr(record + this.offset, db.newString(newString).getRecord());
+				db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
 			} else {
-				db.putRecPtr(record + this.offset, 0);
+				db.putRecPtr(address + this.offset, 0);
 			}
 		}
 	}
 
-	public void put(Nd pdom, long record, String newString) {
-		put(pdom, record, newString.toCharArray());
+	public void put(Nd pdom, long address, String newString) {
+		put(pdom, address, newString.toCharArray());
 	}
 
-	public void destruct(Nd pdom, long record) {
-		get(pdom, record).delete();
-		pdom.getDB().putRecPtr(record + this.offset, 0);
+	public void destruct(Nd pdom, long address) {
+		get(pdom, address).delete();
+		pdom.getDB().putRecPtr(address + this.offset, 0);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/IRefCountedField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/IRefCountedField.java
index ce8a667..54f16ec 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/IRefCountedField.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/IRefCountedField.java
@@ -24,5 +24,5 @@ public interface IRefCountedField {
 	 * Implementations should return false if the refcount is 0 or true if the refcount
 	 * is nonzero.
 	 */	
-	public boolean hasReferences(Nd pdom, long record);
+	public boolean hasReferences(Nd pdom, long address);
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/StructDef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/StructDef.java
index 12611bc..5f5de48 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/StructDef.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/field/StructDef.java
@@ -118,13 +118,13 @@ public final class StructDef<T> {
 				return StructDef.this.clazz;
 			}
 
-			public void destruct(Nd pdom, long record) {
+			public void destruct(Nd pdom, long address) {
 				checkNotMutable();
 				if (StructDef.this.hasUserDestructor) {
-					IDestructable destructable = (IDestructable)create(pdom, record);
+					IDestructable destructable = (IDestructable)create(pdom, address);
 					destructable.destruct();
 				}
-				destructFields(pdom, record);
+				destructFields(pdom, address);
 			}
 
 			public void destructFields(Nd dom, long address) {
@@ -168,7 +168,7 @@ public final class StructDef<T> {
 		return new StructDef<T>(clazz, superClass);
 	}
 
-	protected boolean isReadyForDeletion(Nd dom, long record) {
+	protected boolean isReadyForDeletion(Nd dom, long address) {
 		List<IRefCountedField> toIterate = Collections.EMPTY_LIST;
 		switch (this.deletionSemantics) {
 			case EXPLICIT: return false;
@@ -177,14 +177,14 @@ public final class StructDef<T> {
 		}
 
 		for (IRefCountedField next : toIterate) {
-			if (next.hasReferences(dom, record)) {
+			if (next.hasReferences(dom, address)) {
 				return false;
 			}
 		}
 
 		final StructDef<? super T> localSuperClass = StructDef.this.superClass;
 		if (localSuperClass != null && localSuperClass.deletionSemantics != DeletionSemantics.EXPLICIT) {
-			return localSuperClass.isReadyForDeletion(dom, record);
+			return localSuperClass.isReadyForDeletion(dom, address);
 		}
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdAnnotation.java
index bc31ba0..482d783 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdAnnotation.java
@@ -40,8 +40,8 @@ public class NdAnnotation extends NdNode {
 		type.done();
 	}
 
-	public NdAnnotation(Nd pdom, long record) {
-		super(pdom, record);
+	public NdAnnotation(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdAnnotation(Nd pdom, NdTypeSignature type) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdBinding.java
index 82150ef..01cc902 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdBinding.java
@@ -46,8 +46,8 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 
 	private static final NdAnnotation[] NO_ANNOTATIONS = new NdAnnotation[0];
 
-	public NdBinding(Nd pdom, long record) {
-		super(pdom, record);
+	public NdBinding(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdBinding(Nd pdom, NdResourceFile resource) {
@@ -104,7 +104,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		// the PDOMBinding is deleted. However, PDOMBinding's don't get deleted, so there is no way
 		// to trigger deleting of the tags. If the implementation is changed so that PDOMBindings
 		// do get deleted, then it should call:
-		// PDOMTagIndex.setTags(getPDOM(), pdomBinding.record, Collections.<ITag>emptyList());
+		// PDOMTagIndex.setTags(getPDOM(), pdomBinding.address, Collections.<ITag>emptyList());
 		// to clear out all tags for the binding.
 		// if (adapter.isAssignableFrom(ITagReader.class))
 		// return new PDOMTaggable(getPDOM(), getRecord());
@@ -118,23 +118,23 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// * Watch out, a binding may also be used in a type (e.g. pointer to class)
 	// *
 	// * @param pdom
-	// * @param record
+	// * @param address
 	// * @return <code>true</code> if the binding is orphaned.
 	// * @throws IndexException
 	// */
-	// public static boolean isOrphaned(PDOM pdom, long record) throws IndexException {
+	// public static boolean isOrphaned(PDOM pdom, long address) throws IndexException {
 	// Database db = pdom.getDB();
-	// return db.getRecPtr(record + FIRST_DECL_OFFSET) == 0
-	// && db.getRecPtr(record + FIRST_DEF_OFFSET) == 0
-	// && db.getRecPtr(record + FIRST_REF_OFFSET) == 0
-	// && db.getRecPtr(record + FIRST_EXTREF_OFFSET) == 0;
+	// return db.getRecPtr(address + FIRST_DECL_OFFSET) == 0
+	// && db.getRecPtr(address + FIRST_DEF_OFFSET) == 0
+	// && db.getRecPtr(address + FIRST_REF_OFFSET) == 0
+	// && db.getRecPtr(address + FIRST_EXTREF_OFFSET) == 0;
 	// }
 	//
 	// public final boolean hasDeclaration() throws IndexException {
 	// if (hasDeclaration == -1) {
 	// final Database db = getDB();
-	// if (db.getRecPtr(record + FIRST_DECL_OFFSET) != 0
-	// || db.getRecPtr(record + FIRST_DEF_OFFSET) != 0) {
+	// if (db.getRecPtr(address + FIRST_DECL_OFFSET) != 0
+	// || db.getRecPtr(address + FIRST_DEF_OFFSET) != 0) {
 	// hasDeclaration= 1;
 	// return true;
 	// }
@@ -167,7 +167,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// // contexts that don't know which type of list they are iterating over. E.g., this is
 	// // used when deleting names from a PDOMFile.
 	// if (!getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getPDOM(), record + FIRST_EXTREF_OFFSET).add(name);
+	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).add(name);
 	// return;
 	// }
 	//
@@ -180,27 +180,27 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// }
 	//
 	// public PDOMName getFirstDeclaration() throws IndexException {
-	// long namerec = getDB().getRecPtr(record + FIRST_DECL_OFFSET);
+	// long namerec = getDB().getRecPtr(address + FIRST_DECL_OFFSET);
 	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
 	// }
 	//
 	// public void setFirstDeclaration(PDOMName name) throws IndexException {
 	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(record + FIRST_DECL_OFFSET, namerec);
+	// getDB().putRecPtr(address + FIRST_DECL_OFFSET, namerec);
 	// }
 	//
 	// public PDOMName getFirstDefinition() throws IndexException {
-	// long namerec = getDB().getRecPtr(record + FIRST_DEF_OFFSET);
+	// long namerec = getDB().getRecPtr(address + FIRST_DEF_OFFSET);
 	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
 	// }
 	//
 	// public void setFirstDefinition(PDOMName name) throws IndexException {
 	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(record + FIRST_DEF_OFFSET, namerec);
+	// getDB().putRecPtr(address + FIRST_DEF_OFFSET, namerec);
 	// }
 	//
 	// public PDOMName getFirstReference() throws IndexException {
-	// long namerec = getDB().getRecPtr(record + FIRST_REF_OFFSET);
+	// long namerec = getDB().getRecPtr(address + FIRST_REF_OFFSET);
 	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
 	// }
 	//
@@ -209,7 +209,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// * not return null.
 	// */
 	// public IPDOMIterator<PDOMName> getExternalReferences() throws IndexException {
-	// return new PDOMExternalReferencesList(getPDOM(), record + FIRST_EXTREF_OFFSET).getIterator();
+	// return new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).getIterator();
 	// }
 	//
 	// /**
@@ -220,7 +220,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// if (linkage.equals(getLinkage())) {
 	// setFirstReference(name);
 	// } else {
-	// new PDOMExternalReferencesList(getPDOM(), record + FIRST_EXTREF_OFFSET).setFirstReference(linkage, name);
+	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).setFirstReference(linkage, name);
 	// }
 	// }
 	//
@@ -230,31 +230,31 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// // used when deleting names from a PDOMFile.
 	// if (name != null
 	// && !getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getPDOM(), record + FIRST_EXTREF_OFFSET).add(name);
+	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).add(name);
 	// return;
 	// }
 	//
 	// // Otherwise put the reference into list of locals.
 	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(record + FIRST_REF_OFFSET, namerec);
+	// getDB().putRecPtr(address + FIRST_REF_OFFSET, namerec);
 	// }
 	//
 	// @Override
 	// public final PDOMFile getLocalToFile() throws IndexException {
-	// final long filerec = getLocalToFileRec(getDB(), record);
+	// final long filerec = getLocalToFileRec(getDB(), address);
 	// return filerec == 0 ? null : new PDOMFile(getLinkage(), filerec);
 	// }
 	//
 	// public final long getLocalToFileRec() throws IndexException {
-	// return getLocalToFileRec(getDB(), record);
+	// return getLocalToFileRec(getDB(), address);
 	// }
 
-	// public static long getLocalToFileRec(Database db, long record) throws IndexException {
-	// return db.getRecPtr(record + LOCAL_TO_FILE);
+	// public static long getLocalToFileRec(Database db, long address) throws IndexException {
+	// return db.getRecPtr(address + LOCAL_TO_FILE);
 	// }
 	//
 	// public final void setLocalToFileRec(long rec) throws IndexException {
-	// getDB().putRecPtr(record + LOCAL_TO_FILE, rec);
+	// getDB().putRecPtr(address + LOCAL_TO_FILE, rec);
 	// }
 
 	// public String getName() {
@@ -382,12 +382,12 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	//
 	// @Override
 	// final public boolean isFileLocal() throws IndexException {
-	// return getDB().getRecPtr(record + LOCAL_TO_FILE) != 0;
+	// return getDB().getRecPtr(address + LOCAL_TO_FILE) != 0;
 	// }
 	//
 	// @Override
 	// public boolean hasDefinition() throws IndexException {
-	// return getDB().getRecPtr(record + FIRST_DEF_OFFSET) != 0;
+	// return getDB().getRecPtr(address + FIRST_DEF_OFFSET) != 0;
 	// }
 	//
 	// /**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdComplexTypeSignature.java
index 4afcd40..adaa1d5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdComplexTypeSignature.java
@@ -40,8 +40,8 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 		type.useStandardRefCounting().done();
 	}
 
-	public NdComplexTypeSignature(Nd pdom, long record) {
-		super(pdom, record);
+	public NdComplexTypeSignature(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdComplexTypeSignature(Nd pdom) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethod.java
index 2cf9346..f1eb020 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethod.java
@@ -56,10 +56,10 @@ public class NdMethod extends NdBinding {
 
 	/**
 	 * @param pdom
-	 * @param record
+	 * @param address
 	 */
-	public NdMethod(Nd pdom, long record) {
-		super(pdom, record);
+	public NdMethod(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdMethod(NdType parent) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethodId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethodId.java
index 106d3ad..aeb84a1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethodId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdMethodId.java
@@ -46,8 +46,8 @@ public class NdMethodId extends NdNode {
 		type.useStandardRefCounting().done();
 	}
 
-	public NdMethodId(Nd pdom, long record) {
-		super(pdom, record);
+	public NdMethodId(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdResourceFile.java
index a16439e..5a18c62 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdResourceFile.java
@@ -45,8 +45,8 @@ public class NdResourceFile extends NdTreeNode {
 		type.done();
 	}
 
-	public NdResourceFile(Nd dom, long record) {
-		super(dom, record);
+	public NdResourceFile(Nd dom, long address) {
+		super(dom, address);
 	}
 
 	public NdResourceFile(Nd pdom) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTreeNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTreeNode.java
index ae9b7f8..81519a7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTreeNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTreeNode.java
@@ -37,8 +37,8 @@ public abstract class NdTreeNode extends NdNode {
 		type.done();
 	}
 
-	public NdTreeNode(Nd dom, long record) {
-		super(dom, record);
+	public NdTreeNode(Nd dom, long address) {
+		super(dom, address);
 	}
 
 	protected NdTreeNode(Nd pdom, NdTreeNode parent) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdType.java
index 5730239..97e8109 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdType.java
@@ -83,7 +83,7 @@ public class NdType extends NdBinding {
 	 */
 	public void acceptUncached(IPDOMVisitor visitor) throws CoreException {
 		super.accept(visitor);
-//		PDOMRawLinkedList list = new PDOMRawLinkedList(getPDOM(), this.record + MEMBERLIST);
+//		PDOMRawLinkedList list = new PDOMRawLinkedList(getPDOM(), this.address + MEMBERLIST);
 //		list.accept(visitor);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeId.java
index dbfdf35..ea1f21b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeId.java
@@ -34,8 +34,8 @@ public class NdTypeId extends NdTypeSignature {
 		type.useStandardRefCounting().done();
 	}
 
-	public NdTypeId(Nd pdom, long record) {
-		super(pdom, record);
+	public NdTypeId(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdTypeId(Nd pdom, char[] fieldDescriptor) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeInterface.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeInterface.java
index 2430bf9..bac542e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeInterface.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeInterface.java
@@ -36,8 +36,8 @@ public class NdTypeInterface extends NdNode {
 		type.done();
 	}
 	
-	public NdTypeInterface(Nd pdom, long record) {
-		super(pdom, record);
+	public NdTypeInterface(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdTypeInterface(Nd pdom, NdType targetType, NdTypeSignature makeTypeId) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeSignature.java
index af46963..683cbfa 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/pdom/java/NdTypeSignature.java
@@ -67,8 +67,8 @@ public abstract class NdTypeSignature extends NdNode {
 		type.useStandardRefCounting().done();
 	}
 
-	public NdTypeSignature(Nd pdom, long record) {
-		super(pdom, record);
+	public NdTypeSignature(Nd pdom, long address) {
+		super(pdom, address);
 	}
 
 	public NdTypeSignature(Nd pdom) {
commit 1d95376fc3b7cd63fb1fb3988f44b3f97cb9bd71
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 09:52:25 2016 -0800

    Bug 481796 - Fix all warnings in the org.eclipse.jdt.internal.core.nd.field
    
    Change-Id: I1829a01810fe31bb8b7ebc599e7dbee716b76974
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
8	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
8	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
0	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
index b58560c..e9dfd2f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
@@ -14,7 +14,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type int. Can be used in place of {@link Field<Integer>} in order to
+ * Declares a PDOM field of type byte. Can be used in place of {@link Field}&lt{@link Byte}&gt in order to
  * avoid extra GC overhead.
  * @since 3.12
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
index b78b1d0..1ed75fd 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
@@ -14,7 +14,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type int. Can be used in place of {@link Field<Integer>} in order to
+ * Declares a PDOM field of type char. Can be used in place of  {@link Field}&lt{@link Character}&gt in order to
  * avoid extra GC overhead.
  * @since 3.12
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
index ae0d6a1..489b2d2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
@@ -14,7 +14,8 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type double.
+ * Declares a PDOM field of type double. Can be used in place of  {@link Field}&lt{@link Double}&gt in order to
+ * avoid extra GC overhead.
  * 
  * @since 3.12
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
index b6b46a2..68638ef 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
@@ -14,7 +14,8 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type float.
+ * Declares a PDOM field of type float. Can be used in place of  {@link Field}&lt{@link Float}&gt in order to
+ * avoid extra GC overhead.
  * 
  * @since 3.12
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
index 0c1a9ba..aa599b0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
@@ -14,7 +14,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type int. Can be used in place of {@link Field<Integer>} in order to
+ * Declares a PDOM field of type int. Can be used in place of  {@link Field}&lt{@link Integer}&gt in order to
  * avoid extra GC overhead.
  * @since 3.12
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
index df0729d..a67c08e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
@@ -14,7 +14,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
- * Declares a PDOM field of type long. Can be used in place of {@link Field<Long>} in order to
+ * Declares a PDOM field of type long. Can be used in place of  {@link Field}&lt{@link Long}&gt in order to
  * avoid extra GC overhead.
  * 
  * @since 3.12
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
index 79d2c04..3003d59 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
@@ -15,9 +15,10 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 
 /**
- * Declares a PDOM field which is a pointer of a PDOMNode of the specified type. {@link FieldManyToOne} forms a
- * one-to-many relationship with {@link FieldOneToMany}. Whenever a {@link FieldManyToOne} points to an object, the
- * inverse pointer is automatically inserted into the matching back pointer list.
+ * Holds the n side of a n..1 relationship. Declares a PDOM field which is a pointer of a PDOMNode of the specified
+ * type. {@link FieldManyToOne} forms a one-to-many relationship with {@link FieldOneToMany}. Whenever a
+ * {@link FieldManyToOne} points to an object, the inverse pointer is automatically inserted into the matching back
+ * pointer list.
  * 
  * @since 3.12
  */
@@ -29,6 +30,7 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	Class<T> targetType;
 	final Class<? extends NdNode> localType;
 	FieldOneToMany<?> backPointer;
+	@SuppressWarnings("rawtypes")
 	private final static StructDef<FieldManyToOne> type;
 	/**
 	 * True iff the other end of this pointer should delete this object when its end of the pointer is cleared.
@@ -42,10 +44,6 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 		type.done();
 	}
 
-	/**
-	 * @param nodeType
-	 * @param backPointer
-	 */
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	private FieldManyToOne(Class<? extends NdNode> localType, FieldOneToMany<?> backPointer, boolean pointsToOwner) {
 		this.localType = localType;
@@ -76,9 +74,9 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	 * Creates a many-to-one pointer which points to this object's owner. If the pointer is non-null when the owner is
 	 * deleted, this object will be deleted too.
 	 * 
-	 * @param builder
-	 * @param forwardPointer
-	 * @return
+	 * @param builder the struct to which the field will be added
+	 * @param forwardPointer the field which holds the pointer in the other direction
+	 * @return a newly constructed field
 	 */
 	public static <T extends NdNode, B extends NdNode> FieldManyToOne<T> createOwner(StructDef<B> builder,
 			FieldOneToMany<B> forwardPointer) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
index bf00abb..2876b79 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
@@ -18,8 +18,9 @@ import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.RawGrowableArray;
 
 /**
- * Holds a list of backpointers to a field of type FieldNodePointer. FieldNodePointer
- * and FieldBackPointer fields always go together in pairs.
+ * Holds the 1 side of a 1..n relationship between two objects. FieldNodePointer and FieldBackPointer fields always go
+ * together in pairs.
+ * 
  * @since 3.12
  */
 public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRefCountedField, IField {
@@ -62,7 +63,6 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 	 * preallocated and reserved in the header. The first few elements inserted will be stored here. For relationships
 	 * which will usually have more than a certain number of participants, using a small number of inline elements will
 	 * offer a performance improvement. For relationships that will normally be empty, this should be 0.
-	 * @param nodeType model object that is being referred to 
 	 * @return the newly constructed backpointer field
 	 */
 	public static <T extends NdNode, B extends NdNode> FieldOneToMany<T> create(StructDef<B> builder, 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
index a44c4e0..4ebf3c7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
@@ -43,7 +43,6 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		private boolean isPrefix = false;
 		private char[] searchString;
 		private short requiredNodeType = -1;
-		private long requiredParentNodeAddress;
 		private boolean matchingParentNodeAddress = false;
 
 		private SearchCriteria(char[] searchString) {
@@ -124,7 +123,7 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		private final SearchCriteria searchCriteria;
 		private final Nd pdom;
 
-		private SearchCriteriaToBtreeVisitorAdapter(SearchCriteria searchCriteria, Nd pdom) {
+		public SearchCriteriaToBtreeVisitorAdapter(SearchCriteria searchCriteria, Nd pdom) {
 			this.searchCriteria = searchCriteria;
 			this.pdom = pdom;
 		}
@@ -237,16 +236,17 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		return findBest(pdom, address, searchCriteria, anything);
 	}
 
+	@SuppressWarnings("unchecked")
 	public T findBest(final Nd pdom, long address, final SearchCriteria searchCriteria, final IResultRank rankFunction) {
 		final long[] resultRank = new long[1];
 		final long[] result = new long[1];
 		get(pdom, address).accept(new SearchCriteriaToBtreeVisitorAdapter(searchCriteria, pdom) {
 			@Override
-			protected void acceptResult(long address) {
-				long rank = rankFunction.getRank(pdom, address);
+			protected void acceptResult(long resultAddress) {
+				long rank = rankFunction.getRank(pdom, resultAddress);
 				if (rank >= resultRank[0]) {
 					resultRank[0] = rank;
-					result[0] = address;
+					result[0] = resultAddress;
 				}
 			}
 		});
@@ -260,9 +260,10 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 	public List<T> findAll(final Nd pdom, long address, final SearchCriteria searchCriteria) {
 		final List<T> result = new ArrayList<T>();
 		get(pdom, address).accept(new SearchCriteriaToBtreeVisitorAdapter(searchCriteria, pdom) {
+			@SuppressWarnings("unchecked")
 			@Override
-			protected void acceptResult(long address) {
-				result.add((T)NdNode.load(pdom, address));
+			protected void acceptResult(long resultAddress) {
+				result.add((T)NdNode.load(pdom, resultAddress));
 			}
 		});
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
index bdaba88..037147b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
@@ -40,10 +40,6 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 
 	/**
 	 * Creates a search key attribute in the given struct which stores an entry in the given global search index
-	 *
-	 * @param builder
-	 * @param searchIndex
-	 * @return
 	 */
 	public static <T, B extends NdNode> FieldSearchKey<T> create(StructDef<B> builder,
 			FieldSearchIndex<B> searchIndex) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
index d00fcdd..a106d8d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
@@ -14,6 +14,8 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
+ * Declares a PDOM field of type short. Can be used in place of  {@link Field}&lt{@link Short}&gt in order to
+ * avoid extra GC overhead.
  * @since 3.12
  */
 public class FieldShort implements IField {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
index f8add60..c31d887 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
@@ -16,6 +16,8 @@ import org.eclipse.jdt.internal.core.nd.db.EmptyString;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 
 /**
+ * Declares a PDOM field of type string. Can be used in place of  {@link Field}&lt{@link String}&gt in order to
+ * avoid extra GC overhead.
  * @since 3.12
  */
 public class FieldString implements IDestructableField, IField {
commit d34ca0763a820dd9313157d4916804652e5ed819
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 09:52:50 2016 -0800

    Bug 481796 - Fix warnings in org.eclipse.jdt.internal.core.nd.db
    
    Change-Id: Icc3138bdab450e9c06698c435790d12ab3ad47b6
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

109	109	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
100	100	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
50	50	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ChunkCache.java
44	49	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/DBProperties.java
120	124	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
5	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/EmptyString.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
41	44	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/LongString.java
42	42	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/NdStringSet.java
5	17	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Package.java
46	50	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ShortString.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
index ae2ca05..26f1a3a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
@@ -12,6 +12,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.db;
 
+import java.text.MessageFormat;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.JavaCore;
@@ -19,8 +21,6 @@ import org.eclipse.jdt.internal.core.nd.AbstractTypeFactory;
 import org.eclipse.jdt.internal.core.nd.ITypeFactory;
 import org.eclipse.jdt.internal.core.nd.Nd;
 
-import java.text.MessageFormat;
-
 /**
  * Implements B-Tree search structure
  * @since 3.12
@@ -38,12 +38,12 @@ public class BTree {
 	protected final Database db;
 	protected final long rootPointer;
 
-	protected final int DEGREE;
-	protected final int MAX_RECORDS;
-	protected final int MAX_CHILDREN;
-	protected final int MIN_RECORDS; 
-	protected final int OFFSET_CHILDREN;
-	protected final int MEDIAN_RECORD;
+	protected final int degree;
+	protected final int maxRecords;
+	protected final int maxChildren;
+	protected final int minRecords;
+	protected final int offsetChildren;
+	protected final int medianRecord;
 
 	protected final IBTreeComparator cmp;
 
@@ -53,8 +53,8 @@ public class BTree {
 
 	/**
 	 * Constructor.
-	 * 
-	 * @param db the database containing the btree
+	 *
+	 * @param pdom the database containing the btree
 	 * @param rootPointer offset into database of the pointer to the root node
 	 */
 	public BTree(Nd pdom, long rootPointer, int degree, IBTreeComparator cmp) {
@@ -65,13 +65,13 @@ public class BTree {
 		this.db = pdom.getDB();
 		this.rootPointer = rootPointer;
 		this.cmp = cmp;
-		
-		this.DEGREE = degree;
-		this.MIN_RECORDS = DEGREE - 1;
-		this.MAX_RECORDS = 2*DEGREE - 1;
-		this.MAX_CHILDREN = 2*DEGREE;
-		this.OFFSET_CHILDREN = MAX_RECORDS * Database.INT_SIZE;
-		this.MEDIAN_RECORD = DEGREE - 1;
+
+		this.degree = degree;
+		this.minRecords = this.degree - 1;
+		this.maxRecords = 2*this.degree - 1;
+		this.maxChildren = 2*this.degree;
+		this.offsetChildren = this.maxRecords * Database.INT_SIZE;
+		this.medianRecord = this.degree - 1;
 	}
 
 	public static ITypeFactory<BTree> getFactory(final IBTreeComparator cmp) {
@@ -108,7 +108,7 @@ public class BTree {
 	}
 
 	protected long getRoot() throws IndexException {
-		return db.getRecPtr(rootPointer);
+		return this.db.getRecPtr(this.rootPointer);
 	}
 
 	protected final void putRecord(Chunk chunk, long node, int index, long record) {
@@ -120,16 +120,16 @@ public class BTree {
 	}
 
 	protected final void putChild(Chunk chunk, long node, int index, long child) {
-		chunk.putRecPtr(node + OFFSET_CHILDREN + index * Database.INT_SIZE, child);
+		chunk.putRecPtr(node + this.offsetChildren + index * Database.INT_SIZE, child);
 	}
 
 	protected final long getChild(Chunk chunk, long node, int index) {
-		return chunk.getRecPtr(node + OFFSET_CHILDREN + index * Database.INT_SIZE);
+		return chunk.getRecPtr(node + this.offsetChildren + index * Database.INT_SIZE);
 	}
 
 	public void destruct() {
 		long root = getRoot();
-		
+
 		if (root == 0) {
 			return;
 		}
@@ -142,7 +142,7 @@ public class BTree {
 
 		// Copy all the children pointers to an array of longs so all the reads will happen on the same chunk
 		// consecutively
-		long[] children = new long[this.MAX_RECORDS + 1];
+		long[] children = new long[this.maxRecords + 1];
 
 		for (int idx = 0; idx < children.length; idx++) {
 			children[idx] = getChild(chunk, record, idx);
@@ -163,7 +163,7 @@ public class BTree {
 	 * Inserts the record into the b-tree. We don't insert if the key was already there,
 	 * in which case we return the record that matched. In other cases, we just return
 	 * the record back.
-	 * 
+	 *
 	 * @param record  offset of the record
 	 */
 	public long insert(long record) throws IndexException {
@@ -179,11 +179,11 @@ public class BTree {
 	}
 
 	private long insert(Chunk pChunk, long parent, int iParent, long node, long record) throws IndexException {
-		Chunk chunk = db.getChunk(node);
+		Chunk chunk = this.db.getChunk(node);
 
 		// If this node is full (last record isn't null), split it.
-		if (getRecord(chunk, node, MAX_RECORDS - 1) != 0) {
-			long median = getRecord(chunk, node, MEDIAN_RECORD); 
+		if (getRecord(chunk, node, this.maxRecords - 1) != 0) {
+			long median = getRecord(chunk, node, this.medianRecord);
 			if (median == record) {
 				// Found it, never mind.
 				return median;
@@ -191,25 +191,25 @@ public class BTree {
 				// Split it.
 				// Create the new node and move the larger records over.
 				long newnode = allocateNode();
-				Chunk newchunk = db.getChunk(newnode);
-				for (int i = 0; i < MEDIAN_RECORD; ++i) {
-					putRecord(newchunk, newnode, i, getRecord(chunk, node, MEDIAN_RECORD + 1 + i));
-					putRecord(chunk, node, MEDIAN_RECORD + 1 + i, 0);
-					putChild(newchunk, newnode, i, getChild(chunk, node, MEDIAN_RECORD + 1 + i));
-					putChild(chunk, node, MEDIAN_RECORD + 1 + i, 0);
+				Chunk newchunk = this.db.getChunk(newnode);
+				for (int i = 0; i < this.medianRecord; ++i) {
+					putRecord(newchunk, newnode, i, getRecord(chunk, node, this.medianRecord + 1 + i));
+					putRecord(chunk, node, this.medianRecord + 1 + i, 0);
+					putChild(newchunk, newnode, i, getChild(chunk, node, this.medianRecord + 1 + i));
+					putChild(chunk, node, this.medianRecord + 1 + i, 0);
 				}
-				putChild(newchunk, newnode, MEDIAN_RECORD, getChild(chunk, node, MAX_RECORDS));
-				putChild(chunk, node, MAX_RECORDS, 0);
+				putChild(newchunk, newnode, this.medianRecord, getChild(chunk, node, this.maxRecords));
+				putChild(chunk, node, this.maxRecords, 0);
 
 				if (parent == 0) {
 					// Create a new root
 					parent = allocateNode();
-					pChunk = db.getChunk(parent);
-					db.putRecPtr(rootPointer, parent);
+					pChunk = this.db.getChunk(parent);
+					this.db.putRecPtr(this.rootPointer, parent);
 					putChild(pChunk, parent, 0, node);
 				} else {
 					// Insert the median into the parent.
-					for (int i = MAX_RECORDS - 2; i >= iParent; --i) {
+					for (int i = this.maxRecords - 2; i >= iParent; --i) {
 						long r = getRecord(pChunk, parent, i);
 						if (r != 0) {
 							putRecord(pChunk, parent, i + 1, r);
@@ -220,10 +220,10 @@ public class BTree {
 				putRecord(pChunk, parent, iParent, median);
 				putChild(pChunk, parent, iParent + 1, newnode);
 
-				putRecord(chunk, node, MEDIAN_RECORD, 0);
+				putRecord(chunk, node, this.medianRecord, 0);
 
 				// Set the node to the correct one to follow.
-				if (cmp.compare(pdom, record, median) > 0) {
+				if (this.cmp.compare(this.pdom, record, median) > 0) {
 					node = newnode;
 					chunk = newchunk;
 				}
@@ -231,8 +231,8 @@ public class BTree {
 		}
 
 		// Binary search to find the insert point.
-		int lower= 0; 
-		int upper= MAX_RECORDS - 1;
+		int lower= 0;
+		int upper= this.maxRecords - 1;
 		while (lower < upper && getRecord(chunk, node, upper - 1) == 0) {
 			upper--;
 		}
@@ -243,7 +243,7 @@ public class BTree {
 			if (checkRec == 0) {
 				upper= middle;
 			} else {
-				int compare= cmp.compare(pdom, checkRec, record);
+				int compare= this.cmp.compare(this.pdom, checkRec, record);
 				if (compare > 0) {
 					upper= middle;
 				} else if (compare < 0) {
@@ -262,7 +262,7 @@ public class BTree {
 		} else {
 			// We are at the leaf, add us in.
 			// First copy everything after over one.
-			for (int j = MAX_RECORDS - 2; j >= i; --j) {
+			for (int j = this.maxRecords - 2; j >= i; --j) {
 				long r = getRecord(chunk, node, j);
 				if (r != 0)
 					putRecord(chunk, node, j + 1, r);
@@ -275,13 +275,13 @@ public class BTree {
 	private void firstInsert(long record) throws IndexException {
 		// Create the node and save it as root.
 		long root = allocateNode();
-		db.putRecPtr(rootPointer, root);
+		this.db.putRecPtr(this.rootPointer, root);
 		// Put the record in the first slot of the node.
-		putRecord(db.getChunk(root), root, 0, record); 
+		putRecord(this.db.getChunk(root), root, 0, record);
 	}
 
 	private long allocateNode() throws IndexException {
-		return db.malloc((2 * MAX_RECORDS + 1) * Database.INT_SIZE);
+		return this.db.malloc((2 * this.maxRecords + 1) * Database.INT_SIZE);
 	}
 
 	/**
@@ -290,11 +290,11 @@ public class BTree {
 	 * If the specified record is not present then this routine has no effect.
 	 * <p>
 	 * Specifying a record r for which there is another record q existing in the B-tree
-	 * where cmp.compare(r,q)==0 && r!=q will also have no effect   
+	 * where cmp.compare(r,q)==0 && r!=q will also have no effect
 	 * <p>
 	 * N.B. The record is not deleted itself - its storage is not deallocated.
 	 * The reference to the record in the btree is deleted.
-	 *  
+	 *
 	 * @param record the record to delete
 	 * @throws IndexException
 	 */
@@ -323,16 +323,16 @@ public class BTree {
 
 		BTNode(long node) throws IndexException {
 			this.node = node;
-			this.chunk = db.getChunk(node);
+			this.chunk = BTree.this.db.getChunk(node);
 			int i= 0;
-			while (i < MAX_RECORDS && getRecord(chunk, node, i) != 0)
+			while (i < BTree.this.maxRecords && getRecord(this.chunk, node, i) != 0)
 				i++;
-			keyCount = i;
+			this.keyCount = i;
 		}
 
-		private BTNode getChild(int index) throws IndexException {
-			if (0 <= index && index < MAX_CHILDREN) {
-				long child = BTree.this.getChild(chunk, node, index);
+		BTNode getChild(int index) throws IndexException {
+			if (0 <= index && index < BTree.this.maxChildren) {
+				long child = BTree.this.getChild(this.chunk, this.node, index);
 				if (child != 0)
 					return new BTNode(child);
 			}
@@ -353,7 +353,6 @@ public class BTree {
 	 * 	where DELMODE_NORMAL: locates the specified key/record using the comparator provided
 	 *        DELMODE_DELETE_MINIMUM: locates and deletes the minimum element in the subtree rooted at nodeRecord
 	 *        DELMODE_DELETE_MAXIMUM: locates and deletes the maximum element in the subtree rooted at nodeRecord
-	 * @param cmp the comparator used to locate the record in the tree
 	 * @return the address of the record removed from the B-tree
 	 * @throws IndexException
 	 */
@@ -385,22 +384,22 @@ public class BTree {
 					nodeContentDelete(node, node.keyCount - 1, 1);
 					return subst;
 				}
-				throw new BTreeKeyNotFoundException("Deletion on absent key " + key + ", mode = " + mode);
+				throw new BTreeKeyNotFoundException("Deletion on absent key " + key + ", mode = " + mode);  //$NON-NLS-1$//$NON-NLS-2$
 			}
 		} else {
 			if (keyIndexInNode != -1) {
 				/* Case 2: non-leaf node which contains the key itself */
 
 				BTNode succ = node.getChild(keyIndexInNode + 1);
-				if (succ != null && succ.keyCount > MIN_RECORDS) {
+				if (succ != null && succ.keyCount > this.minRecords) {
 					/* Case 2a: Delete key by overwriting it with its successor (which occurs in a leaf node) */
 					long subst = deleteImp(-1, succ.node, DELMODE_DELETE_MINIMUM);
 					putRecord(node.chunk, node.node, keyIndexInNode, subst);
 					return key;
 				}
 
-				BTNode pred = node.getChild(keyIndexInNode); 
-				if (pred != null && pred.keyCount > MIN_RECORDS) {
+				BTNode pred = node.getChild(keyIndexInNode);
+				if (pred != null && pred.keyCount > this.minRecords) {
 					/* Case 2b: Delete key by overwriting it with its predecessor (which occurs in a leaf node) */
 					long subst = deleteImp(-1, pred.node, DELMODE_DELETE_MAXIMUM);
 					putRecord(node.chunk, node.node, keyIndexInNode, subst);
@@ -421,9 +420,9 @@ public class BTree {
 				int subtreeIndex;
 				switch(mode) {
 				case DELMODE_NORMAL:
-					subtreeIndex = node.keyCount; 
+					subtreeIndex = node.keyCount;
 					for (int i= 0; i < node.keyCount; i++)
-						if (cmp.compare(pdom, getRecord(node.chunk, node.node, i), key)>0) {
+						if (this.cmp.compare(this.pdom, getRecord(node.chunk, node.node, i), key)>0) {
 							subtreeIndex = i;
 							break;
 						}
@@ -439,11 +438,11 @@ public class BTree {
 							"BTree integrity error (null child found)", null)); //$NON-NLS-1$
 				}
 
-				if (child.keyCount > MIN_RECORDS) {
+				if (child.keyCount > this.minRecords) {
 					return deleteImp(key, child.node, mode);
 				} else {
 					BTNode sibR = node.getChild(subtreeIndex + 1);
-					if (sibR != null && sibR.keyCount > MIN_RECORDS) {
+					if (sibR != null && sibR.keyCount > this.minRecords) {
 						/* Case 3a (i): child will underflow upon deletion, take a key from rightSibling */
 						long rightKey = getRecord(node.chunk, node.node, subtreeIndex);
 						long leftmostRightSiblingKey = getRecord(sibR.chunk, sibR.node, 0);
@@ -454,7 +453,7 @@ public class BTree {
 					}
 
 					BTNode sibL = node.getChild(subtreeIndex - 1);
-					if (sibL != null && sibL.keyCount > MIN_RECORDS) {
+					if (sibL != null && sibL.keyCount > this.minRecords) {
 						/* Case 3a (ii): child will underflow upon deletion, take a key from leftSibling */
 						long leftKey = getRecord(node.chunk, node.node, subtreeIndex - 1);
 						prepend(child, leftKey, getChild(sibL.chunk, sibL.node, sibL.keyCount));
@@ -494,13 +493,13 @@ public class BTree {
 	 * @param kIndex the index of the key in the node <i>mid</i> which is to become the new node's median key
 	 * @param dst the node which is the basis and result of the merge
 	 */
-	public void mergeNodes(BTNode src, BTNode keyProvider, int kIndex, BTNode dst) 
+	public void mergeNodes(BTNode src, BTNode keyProvider, int kIndex, BTNode dst)
 	throws IndexException {
 		nodeContentCopy(src, 0, dst, dst.keyCount + 1, src.keyCount + 1);
 		long midKey = getRecord(keyProvider.chunk, keyProvider.node, kIndex);
 		putRecord(dst.chunk, dst.node, dst.keyCount, midKey);
-		long keySucc = kIndex + 1 == MAX_RECORDS ? 0 : getRecord(keyProvider.chunk, keyProvider.node, kIndex + 1);
-		db.free(getChild(keyProvider.chunk, keyProvider.node,  kIndex + 1));
+		long keySucc = kIndex + 1 == this.maxRecords ? 0 : getRecord(keyProvider.chunk, keyProvider.node, kIndex + 1);
+		this.db.free(getChild(keyProvider.chunk, keyProvider.node,  kIndex + 1));
 		nodeContentDelete(keyProvider, kIndex + 1, 1);
 		putRecord(keyProvider.chunk, keyProvider.node, kIndex, keySucc);
 		if (kIndex == 0 && keySucc == 0) {
@@ -511,8 +510,8 @@ public class BTree {
 			 */
 			long rootNode = getRoot();
 			if (rootNode == keyProvider.node) {
-				db.putRecPtr(rootPointer, dst.node);
-				db.free(rootNode);
+				this.db.putRecPtr(this.rootPointer, dst.node);
+				this.db.free(rootNode);
 			}
 		}
 	}
@@ -581,13 +580,13 @@ public class BTree {
 	 * @param length the length of the sequence to delete
 	 */
 	private void nodeContentDelete(BTNode node, int i, int length) {
-		for (int index= i; index <= MAX_RECORDS; index++) {
+		for (int index= i; index <= this.maxRecords; index++) {
 			long newKey = (index + length) < node.keyCount ? getRecord(node.chunk, node.node, index + length) : 0;
 			long newChild = (index + length) < node.keyCount + 1 ? getChild(node.chunk, node.node, index + length) : 0;
-			if (index < MAX_RECORDS) {
+			if (index < this.maxRecords) {
 				putRecord(node.chunk, node.node, index, newKey);
 			}
-			if (index < MAX_CHILDREN) {
+			if (index < this.maxChildren) {
 				putChild(node.chunk, node.node, index, newChild);
 			}
 		}
@@ -596,11 +595,11 @@ public class BTree {
 	/**
 	 * Visit all nodes beginning when the visitor comparator
 	 * returns >= 0 until the visitor visit returns falls.
-	 * 
+	 *
 	 * @param visitor
 	 */
 	public void accept(IBTreeVisitor visitor) throws IndexException {
-		accept(db.getRecPtr(rootPointer), visitor);
+		accept(this.db.getRecPtr(this.rootPointer), visitor);
 	}
 
 	private boolean accept(long node, IBTreeVisitor visitor) throws IndexException {
@@ -616,11 +615,11 @@ public class BTree {
 		}
 
 		try {
-			Chunk chunk = db.getChunk(node);
-			
+			Chunk chunk = this.db.getChunk(node);
+
 			// Binary search to find first record greater or equal.
-			int lower= 0; 
-			int upper= MAX_RECORDS - 1;
+			int lower= 0;
+			int upper= this.maxRecords - 1;
 			while (lower < upper && getRecord(chunk, node, upper - 1) == 0) {
 				upper--;
 			}
@@ -638,20 +637,20 @@ public class BTree {
 					}
 				}
 			}
-			
+
 			// Start with first record greater or equal, reuse comparison results.
 			int i= lower;
-			for (; i < MAX_RECORDS; ++i) {
+			for (; i < this.maxRecords; ++i) {
 				long record = getRecord(chunk, node, i);
-				if (record == 0) 
+				if (record == 0)
 					break;
 
-				int compare= visitor.compare(record); 
+				int compare= visitor.compare(record);
 				if (compare > 0) {
 					// Start point is to the left.
 					return accept(getChild(chunk, node, i), visitor);
 				}  else if (compare == 0) {
-					if (!accept(getChild(chunk, node, i), visitor)) 
+					if (!accept(getChild(chunk, node, i), visitor))
 						return false;
 					if (!visitor.visit(record))
 						return false;
@@ -696,10 +695,11 @@ public class BTree {
 		Integer leafDepth;
 		int depth;
 
-		public String getMsg() { return msg; }
-		public boolean isValid() { return valid; }
+		public InvariantsChecker() {}
+		public String getMsg() { return this.msg; }
+		public boolean isValid() { return this.valid; }
 		@Override
-		public void postNode(long node) throws IndexException { depth--; }
+		public void postNode(long node) throws IndexException { this.depth--; }
 		@Override
 		public int compare(long record) throws IndexException { return 0; }
 		@Override
@@ -707,35 +707,35 @@ public class BTree {
 
 		@Override
 		public void preNode(long node) throws IndexException {
-			depth++;
+			this.depth++;
 
 			// Collect information for checking.
 			int keyCount = 0;
-			int indexFirstBlankKey = MAX_RECORDS;
-			int indexLastNonBlankKey = 0; 
-			for (int i= 0; i < MAX_RECORDS; i++) {
-				if (getRecord(db.getChunk(node), node, i) != 0) {
+			int indexFirstBlankKey = BTree.this.maxRecords;
+			int indexLastNonBlankKey = 0;
+			for (int i= 0; i < BTree.this.maxRecords; i++) {
+				if (getRecord(BTree.this.db.getChunk(node), node, i) != 0) {
 					keyCount++;
 					indexLastNonBlankKey = i;
-				} else if (indexFirstBlankKey == MAX_RECORDS) {
+				} else if (indexFirstBlankKey == BTree.this.maxRecords) {
 					indexFirstBlankKey = i;
 				}
 			}
 
 			int childCount = 0;
-			for (int i= 0; i < MAX_CHILDREN; i++) {
-				if (getChild(db.getChunk(node), node, i) != 0) {
+			for (int i= 0; i < BTree.this.maxChildren; i++) {
+				if (getChild(BTree.this.db.getChunk(node), node, i) != 0) {
 					childCount++;
 				}
 			}
 
 			// Check that non-blank keys are contiguous and blank key terminated.
 			if (indexFirstBlankKey != indexLastNonBlankKey + 1) {
-				boolean full = indexFirstBlankKey == MAX_RECORDS && indexLastNonBlankKey == MAX_RECORDS - 1;
+				boolean full = indexFirstBlankKey == BTree.this.maxRecords && indexLastNonBlankKey == BTree.this.maxRecords - 1;
 				boolean empty = indexFirstBlankKey == 0 && indexLastNonBlankKey == 0;
 				if (!full && !empty) {
-					valid = false;
-					msg += MessageFormat.format("[{0} blanks inconsistent b={1} nb={2}]", //$NON-NLS-1$
+					this.valid = false;
+					this.msg += MessageFormat.format("[{0} blanks inconsistent b={1} nb={2}]", //$NON-NLS-1$
 							new Object[] { new Long(node), new Integer(indexFirstBlankKey),
 									new Integer(indexLastNonBlankKey) });
 				}
@@ -743,30 +743,30 @@ public class BTree {
 
 			// Check: Key number constrains child numbers
 			if (childCount != 0 && childCount != keyCount + 1) {
-				valid = false;
-				msg += MessageFormat.format("[{0} wrong number of children with respect to key count]", //$NON-NLS-1$
+				this.valid = false;
+				this.msg += MessageFormat.format("[{0} wrong number of children with respect to key count]", //$NON-NLS-1$
 						new Object[] { new Long(node) });
 			}
 
 			// The root node is excused from the remaining node constraints.
-			if (node == db.getRecPtr(rootPointer)) {
-				return; 
+			if (node == BTree.this.db.getRecPtr(BTree.this.rootPointer)) {
+				return;
 			}
 
 			// Check: Non-root nodes must have a keyCount within a certain range
-			if (keyCount < MIN_RECORDS || keyCount > MAX_RECORDS) {
-				valid = false;
-				msg += MessageFormat.format("[{0} key count out of range]", new Object[] { new Long(node) }); //$NON-NLS-1$
+			if (keyCount < BTree.this.minRecords || keyCount > BTree.this.maxRecords) {
+				this.valid = false;
+				this.msg += MessageFormat.format("[{0} key count out of range]", new Object[] { new Long(node) }); //$NON-NLS-1$
 			}
 
 			// Check: All leaf nodes are at the same depth
 			if (childCount == 0) {
-				if (leafDepth == null) {
-					leafDepth = new Integer(depth);
+				if (this.leafDepth == null) {
+					this.leafDepth = new Integer(this.depth);
 				}
-				if (depth != leafDepth.intValue()) {
-					valid = false;
-					msg += "Leaf nodes at differing depths"; //$NON-NLS-1$
+				if (this.depth != this.leafDepth.intValue()) {
+					this.valid = false;
+					this.msg += "Leaf nodes at differing depths"; //$NON-NLS-1$
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
index e18cd83..68f7d8c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
@@ -24,21 +24,21 @@ final class Chunk {
 
 	final Database fDatabase;
 	final int fSequenceNumber;
-	
+
 	boolean fCacheHitFlag;
 	boolean fDirty;
 	boolean fLocked;	// locked chunks must not be released from cache.
 	int fCacheIndex= -1;
-		
+
 	Chunk(Database db, int sequenceNumber) {
-		fDatabase= db;
-		fSequenceNumber= sequenceNumber;
+		this.fDatabase= db;
+		this.fSequenceNumber= sequenceNumber;
 	}
 
 	void read() throws IndexException {
 		try {
-			final ByteBuffer buf= ByteBuffer.wrap(fBuffer);
-			fDatabase.read(buf, (long) fSequenceNumber * Database.CHUNK_SIZE);
+			final ByteBuffer buf= ByteBuffer.wrap(this.fBuffer);
+			this.fDatabase.read(buf, (long) this.fSequenceNumber * Database.CHUNK_SIZE);
 		} catch (IOException e) {
 			throw new IndexException(new DBStatus(e));
 		}
@@ -46,12 +46,12 @@ final class Chunk {
 
 	void flush() throws IndexException {
 		try {
-			final ByteBuffer buf= ByteBuffer.wrap(fBuffer);
-			fDatabase.write(buf, (long) fSequenceNumber * Database.CHUNK_SIZE);
+			final ByteBuffer buf= ByteBuffer.wrap(this.fBuffer);
+			this.fDatabase.write(buf, (long) this.fSequenceNumber * Database.CHUNK_SIZE);
 		} catch (IOException e) {
 			throw new IndexException(new DBStatus(e));
 		}
-		fDirty= false;
+		this.fDirty= false;
 	}
 
 	private static int recPtrToIndex(final long offset) {
@@ -59,32 +59,32 @@ final class Chunk {
 	}
 
 	public void putByte(final long offset, final byte value) {
-		assert fLocked;
-		fDirty= true;
-		fBuffer[recPtrToIndex(offset)]= value;
+		assert this.fLocked;
+		this.fDirty= true;
+		this.fBuffer[recPtrToIndex(offset)]= value;
 	}
-	
+
 	public byte getByte(final long offset) {
-		return fBuffer[recPtrToIndex(offset)];
+		return this.fBuffer[recPtrToIndex(offset)];
 	}
-	
+
 	public byte[] getBytes(final long offset, final int length) {
 		final byte[] bytes = new byte[length];
-		System.arraycopy(fBuffer, recPtrToIndex(offset), bytes, 0, length);
+		System.arraycopy(this.fBuffer, recPtrToIndex(offset), bytes, 0, length);
 		return bytes;
 	}
-	
+
 	public void putBytes(final long offset, final byte[] bytes) {
-		assert fLocked;
-		fDirty= true;
-		System.arraycopy(bytes, 0, fBuffer, recPtrToIndex(offset), bytes.length);
+		assert this.fLocked;
+		this.fDirty= true;
+		System.arraycopy(bytes, 0, this.fBuffer, recPtrToIndex(offset), bytes.length);
 	}
-	
+
 	public void putInt(final long offset, final int value) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset);
-		putInt(value, fBuffer, idx);
+		putInt(value, this.fBuffer, idx);
 	}
 
 	static final void putInt(final int value, final byte[] buffer, int idx) {
@@ -93,9 +93,9 @@ final class Chunk {
 		buffer[++idx]= (byte) (value >> 8);
 		buffer[++idx]= (byte) (value);
 	}
-	
+
 	public int getInt(final long offset) {
-		return getInt(fBuffer, recPtrToIndex(offset));
+		return getInt(this.fBuffer, recPtrToIndex(offset));
 	}
 
 	static final int getInt(final byte[] buffer, int idx) {
@@ -115,17 +115,17 @@ final class Chunk {
 		final int dense = (int) (value >> Database.BLOCK_SIZE_DELTA_BITS);
 		return dense;
 	}
-	
+
 	/**
 	 * A free Record Pointer is a pointer to a raw block,
 	 * i.e. the pointer is not moved past the BLOCK_HEADER_SIZE.
 	 */
 	static long expandToFreeRecPtr(int value) {
 		/*
-		 * We need to properly manage the integer that was read. The value will be sign-extended 
-		 * so if the most significant bit is set, the resulting long will look negative. By 
-		 * masking it with ((long)1 << 32) - 1 we remove all the sign-extended bits and just 
-		 * have an unsigned 32-bit value as a long. This gives us one more useful bit in the 
+		 * We need to properly manage the integer that was read. The value will be sign-extended
+		 * so if the most significant bit is set, the resulting long will look negative. By
+		 * masking it with ((long)1 << 32) - 1 we remove all the sign-extended bits and just
+		 * have an unsigned 32-bit value as a long. This gives us one more useful bit in the
 		 * stored record pointers.
 		 */
 		long address = value & 0xFFFFFFFFL;
@@ -137,73 +137,73 @@ final class Chunk {
 	 * This is a pointer to a block + BLOCK_HEADER_SIZE.
 	 */
 	public void putRecPtr(final long offset, final long value) {
-		assert fLocked;
-		fDirty = true;
+		assert this.fLocked;
+		this.fDirty = true;
 		int idx = recPtrToIndex(offset);
-		Database.putRecPtr(value, fBuffer, idx);
+		Database.putRecPtr(value, this.fBuffer, idx);
 	}
-	
+
 	/**
 	 * A free Record Pointer is a pointer to a raw block,
 	 * i.e. the pointer is not moved past the BLOCK_HEADER_SIZE.
 	 */
 	public void putFreeRecPtr(final long offset, final long value) {
-		assert fLocked;
-		fDirty = true;
+		assert this.fLocked;
+		this.fDirty = true;
 		int idx = recPtrToIndex(offset);
-		putInt(compressFreeRecPtr(value), fBuffer, idx);
+		putInt(compressFreeRecPtr(value), this.fBuffer, idx);
 	}
 
 	public long getRecPtr(final long offset) {
 		final int idx = recPtrToIndex(offset);
-		return Database.getRecPtr(fBuffer, idx);
+		return Database.getRecPtr(this.fBuffer, idx);
 	}
-	
+
 	public long getFreeRecPtr(final long offset) {
 		final int idx = recPtrToIndex(offset);
-		int value = getInt(fBuffer, idx);
+		int value = getInt(this.fBuffer, idx);
 		return expandToFreeRecPtr(value);
 	}
-	
+
 	public void put3ByteUnsignedInt(final long offset, final int value) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset);
-		fBuffer[idx]= (byte) (value >> 16);
-		fBuffer[++idx]= (byte) (value >> 8);
-		fBuffer[++idx]= (byte) (value);
+		this.fBuffer[idx]= (byte) (value >> 16);
+		this.fBuffer[++idx]= (byte) (value >> 8);
+		this.fBuffer[++idx]= (byte) (value);
 	}
-	
+
 	public int get3ByteUnsignedInt(final long offset) {
 		int idx= recPtrToIndex(offset);
-		return ((fBuffer[idx] & 0xff) << 16) |
-				((fBuffer[++idx] & 0xff) <<  8) |
-				((fBuffer[++idx] & 0xff) <<  0);
+		return ((this.fBuffer[idx] & 0xff) << 16) |
+				((this.fBuffer[++idx] & 0xff) <<  8) |
+				((this.fBuffer[++idx] & 0xff) <<  0);
 	}
 
 	public void putShort(final long offset, final short value) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset);
-		fBuffer[idx]= (byte) (value >> 8);
-		fBuffer[++idx]= (byte) (value);
+		this.fBuffer[idx]= (byte) (value >> 8);
+		this.fBuffer[++idx]= (byte) (value);
 	}
-	
+
 	public short getShort(final long offset) {
 		int idx= recPtrToIndex(offset);
-		return (short) (((fBuffer[idx] << 8) | (fBuffer[++idx] & 0xff)));
+		return (short) (((this.fBuffer[idx] << 8) | (this.fBuffer[++idx] & 0xff)));
 	}
 
 	public long getLong(final long offset) {
 		int idx= recPtrToIndex(offset);
-		return ((((long) fBuffer[idx] & 0xff) << 56) |
-				(((long) fBuffer[++idx] & 0xff) << 48) |
-				(((long) fBuffer[++idx] & 0xff) << 40) |
-				(((long) fBuffer[++idx] & 0xff) << 32) |
-				(((long) fBuffer[++idx] & 0xff) << 24) |
-				(((long) fBuffer[++idx] & 0xff) << 16) |
-				(((long) fBuffer[++idx] & 0xff) <<  8) |
-				(((long) fBuffer[++idx] & 0xff) <<  0));
+		return ((((long) this.fBuffer[idx] & 0xff) << 56) |
+				(((long) this.fBuffer[++idx] & 0xff) << 48) |
+				(((long) this.fBuffer[++idx] & 0xff) << 40) |
+				(((long) this.fBuffer[++idx] & 0xff) << 32) |
+				(((long) this.fBuffer[++idx] & 0xff) << 24) |
+				(((long) this.fBuffer[++idx] & 0xff) << 16) |
+				(((long) this.fBuffer[++idx] & 0xff) <<  8) |
+				(((long) this.fBuffer[++idx] & 0xff) <<  0));
 	}
 
 	public double getDouble(long offset) {
@@ -215,48 +215,48 @@ final class Chunk {
 	}
 
 	public void putLong(final long offset, final long value) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset);
 
-		fBuffer[idx]=   (byte) (value >> 56);
-		fBuffer[++idx]= (byte) (value >> 48);
-		fBuffer[++idx]= (byte) (value >> 40);
-		fBuffer[++idx]= (byte) (value >> 32);
-		fBuffer[++idx]= (byte) (value >> 24);
-		fBuffer[++idx]= (byte) (value >> 16);
-		fBuffer[++idx]= (byte) (value >> 8);
-		fBuffer[++idx]= (byte) (value);
+		this.fBuffer[idx]=   (byte) (value >> 56);
+		this.fBuffer[++idx]= (byte) (value >> 48);
+		this.fBuffer[++idx]= (byte) (value >> 40);
+		this.fBuffer[++idx]= (byte) (value >> 32);
+		this.fBuffer[++idx]= (byte) (value >> 24);
+		this.fBuffer[++idx]= (byte) (value >> 16);
+		this.fBuffer[++idx]= (byte) (value >> 8);
+		this.fBuffer[++idx]= (byte) (value);
 	}
-	
+
 	public void putChar(final long offset, final char value) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset);
-		fBuffer[idx]= (byte) (value >> 8);
-		fBuffer[++idx]= (byte) (value);
+		this.fBuffer[idx]= (byte) (value >> 8);
+		this.fBuffer[++idx]= (byte) (value);
 	}
-	
+
 	public void putChars(final long offset, char[] chars, int start, int len) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset)-1;
 		final int end= start + len;
 		for (int i = start; i < end; i++) {
 			char value= chars[i];
-			fBuffer[++idx]= (byte) (value >> 8);
-			fBuffer[++idx]= (byte) (value);
+			this.fBuffer[++idx]= (byte) (value >> 8);
+			this.fBuffer[++idx]= (byte) (value);
 		}
 	}
 
 	public void putCharsAsBytes(final long offset, char[] chars, int start, int len) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx= recPtrToIndex(offset)-1;
 		final int end= start + len;
 		for (int i = start; i < end; i++) {
 			char value= chars[i];
-			fBuffer[++idx]= (byte) (value);
+			this.fBuffer[++idx]= (byte) (value);
 		}
 	}
 
@@ -270,11 +270,11 @@ final class Chunk {
 
 	public char getChar(final long offset) {
 		int idx= recPtrToIndex(offset);
-		return (char) (((fBuffer[idx] << 8) | (fBuffer[++idx] & 0xff)));
+		return (char) (((this.fBuffer[idx] << 8) | (this.fBuffer[++idx] & 0xff)));
 	}
 
 	public void getChars(final long offset, final char[] result, int start, int len) {
-		final ByteBuffer buf= ByteBuffer.wrap(fBuffer);
+		final ByteBuffer buf= ByteBuffer.wrap(this.fBuffer);
 		buf.position(recPtrToIndex(offset));
 		buf.asCharBuffer().get(result, start, len);
 	}
@@ -282,37 +282,37 @@ final class Chunk {
 	public void getCharsFromBytes(final long offset, final char[] result, int start, int len) {
 		final int pos = recPtrToIndex(offset);
 		for (int i = 0; i < len; i++) {
-			result[start + i] =  (char) (fBuffer[pos + i] & 0xff);
+			result[start + i] =  (char) (this.fBuffer[pos + i] & 0xff);
 		}
 	}
 
 	void clear(final long offset, final int length) {
-		assert fLocked;
-		fDirty= true;
+		assert this.fLocked;
+		this.fDirty= true;
 		int idx = recPtrToIndex(offset);
 		final int end = idx + length;
 		for (; idx < end; idx++) {
-			fBuffer[idx] = 0;
+			this.fBuffer[idx] = 0;
 		}
 	}
 
 	void put(final long offset, final byte[] data, final int len) {
 		put(offset, data, 0, len);
 	}
-	
+
 	void put(final long offset, final byte[] data, int dataPos, final int len) {
-		assert fLocked;
-		fDirty = true;
+		assert this.fLocked;
+		this.fDirty = true;
 		int idx = recPtrToIndex(offset);
-		System.arraycopy(data, dataPos, fBuffer, idx, len);
+		System.arraycopy(data, dataPos, this.fBuffer, idx, len);
 	}
-	
+
 	public void get(final long offset, byte[] data) {
 		get(offset, data, 0, data.length);
 	}
 
 	public void get(final long offset, byte[] data, int dataPos, int len) {
 		int idx = recPtrToIndex(offset);
-		System.arraycopy(fBuffer, idx, data, dataPos, len);
+		System.arraycopy(this.fBuffer, idx, data, dataPos, len);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ChunkCache.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ChunkCache.java
index 0d26e17..ccc61f6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ChunkCache.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ChunkCache.java
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *     Markus Schorn - initial API and implementation
- *******************************************************************************/ 
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.db;
 
 /**
@@ -15,11 +15,11 @@ package org.eclipse.jdt.internal.core.nd.db;
  */
 public final class ChunkCache {
 	private static ChunkCache sSharedInstance= new ChunkCache();
-	
+
 	private Chunk[] fPageTable;
 	private boolean fTableIsFull;
 	private int fPointer;
-	
+
 	public static ChunkCache getSharedInstance() {
 		return sSharedInstance;
 	}
@@ -27,11 +27,11 @@ public final class ChunkCache {
 	public ChunkCache() {
 		this(5 * 1024 * 1024);
 	}
-	
+
 	public ChunkCache(long maxSize) {
-		fPageTable= new Chunk[computeLength(maxSize)];
+		this.fPageTable= new Chunk[computeLength(maxSize)];
 	}
-	
+
 	public synchronized void add(Chunk chunk, boolean locked) {
 		if (locked) {
 			chunk.fLocked= true;
@@ -40,27 +40,27 @@ public final class ChunkCache {
 			chunk.fCacheHitFlag= true;
 			return;
 		}
-		if (fTableIsFull) {
+		if (this.fTableIsFull) {
 			evictChunk();
-			chunk.fCacheIndex= fPointer;
-			fPageTable[fPointer]= chunk;
+			chunk.fCacheIndex= this.fPointer;
+			this.fPageTable[this.fPointer]= chunk;
 		} else {
-			chunk.fCacheIndex= fPointer;
-			fPageTable[fPointer]= chunk;
+			chunk.fCacheIndex= this.fPointer;
+			this.fPageTable[this.fPointer]= chunk;
 
-			fPointer++;
-			if (fPointer == fPageTable.length) {
-				fPointer= 0;
-				fTableIsFull= true;
+			this.fPointer++;
+			if (this.fPointer == this.fPageTable.length) {
+				this.fPointer= 0;
+				this.fTableIsFull= true;
 			}
 		}
 	}
-	
-	/**                                                                   
-	 * Evicts a chunk from the page table and the chunk table.            
+
+	/**
+	 * Evicts a chunk from the page table and the chunk table.
 	 * After this method returns, {@link #fPointer}  will contain
-	 * the index of the evicted chunk within the page table.              
-	 */                                                                   
+	 * the index of the evicted chunk within the page table.
+	 */
 	private void evictChunk() {
 		/*
 		 * Use the CLOCK algorithm to determine which chunk to evict.
@@ -70,14 +70,14 @@ public final class ChunkCache {
 		 * chunk in the current slot.
 		 */
 		while (true) {
-			Chunk chunk = fPageTable[fPointer];
+			Chunk chunk = this.fPageTable[this.fPointer];
 			if (chunk.fCacheHitFlag) {
 				chunk.fCacheHitFlag= false;
-				fPointer= (fPointer + 1) % fPageTable.length;
+				this.fPointer= (this.fPointer + 1) % this.fPageTable.length;
 			} else {
 				chunk.fDatabase.releaseChunk(chunk);
 				chunk.fCacheIndex= -1;
-				fPageTable[fPointer] = null;
+				this.fPageTable[this.fPointer] = null;
 				return;
 			}
 		}
@@ -86,54 +86,54 @@ public final class ChunkCache {
 	public synchronized void remove(Chunk chunk) {
 		final int idx= chunk.fCacheIndex;
 		if (idx >= 0) {
-			if (fTableIsFull) {
-				fPointer= fPageTable.length-1;
-				fTableIsFull= false;
+			if (this.fTableIsFull) {
+				this.fPointer= this.fPageTable.length-1;
+				this.fTableIsFull= false;
 			} else {
-				fPointer--;
+				this.fPointer--;
 			}
 			chunk.fCacheIndex= -1;
-			final Chunk move= fPageTable[fPointer];
-			fPageTable[idx]= move;
+			final Chunk move= this.fPageTable[this.fPointer];
+			this.fPageTable[idx]= move;
 			move.fCacheIndex= idx;
-			fPageTable[fPointer]= null;
-		}	
+			this.fPageTable[this.fPointer]= null;
+		}
 	}
 
-	/**                                                                           
+	/**
 	 * Returns the maximum size of the chunk cache in bytes.
-	 */                                                                           
+	 */
 	public synchronized long getMaxSize() {
-		return (long) fPageTable.length * Database.CHUNK_SIZE;
+		return (long) this.fPageTable.length * Database.CHUNK_SIZE;
 	}
 
-	/**                                                                           
+	/**
 	 * Clears the page table and changes it to hold chunks with
-	 * maximum total memory of <code>maxSize</code>.       
-	 * @param maxSize the total size of the chunks in bytes.                
-	 */                                                                           
+	 * maximum total memory of <code>maxSize</code>.
+	 * @param maxSize the total size of the chunks in bytes.
+	 */
 	public synchronized void setMaxSize(long maxSize) {
 		final int newLength= computeLength(maxSize);
-		final int oldLength= fTableIsFull ? fPageTable.length : fPointer;
+		final int oldLength= this.fTableIsFull ? this.fPageTable.length : this.fPointer;
 		if (newLength > oldLength) {
 			Chunk[] newTable= new Chunk[newLength];
-			System.arraycopy(fPageTable, 0, newTable, 0, oldLength);
-			fTableIsFull= false;
-			fPointer= oldLength;
-			fPageTable= newTable;
+			System.arraycopy(this.fPageTable, 0, newTable, 0, oldLength);
+			this.fTableIsFull= false;
+			this.fPointer= oldLength;
+			this.fPageTable= newTable;
 		} else {
 			for (int i= newLength; i < oldLength; i++) {
-				final Chunk chunk= fPageTable[i];
+				final Chunk chunk= this.fPageTable[i];
 				chunk.fDatabase.releaseChunk(chunk);
 				chunk.fCacheIndex= -1;
 			}
 			Chunk[] newTable= new Chunk[newLength];
-			System.arraycopy(fPageTable, 0, newTable, 0, newLength);
-			fTableIsFull= true;
-			fPointer= 0;
-			fPageTable= newTable;
-		}       
-	}                                                                             
+			System.arraycopy(this.fPageTable, 0, newTable, 0, newLength);
+			this.fTableIsFull= true;
+			this.fPointer= 0;
+			this.fPageTable= newTable;
+		}
+	}
 
 	private int computeLength(long maxSize) {
 		long maxLength= Math.min(maxSize / Database.CHUNK_SIZE, Integer.MAX_VALUE);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/DBProperties.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/DBProperties.java
index ab71f02..1cbf779 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/DBProperties.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/DBProperties.java
@@ -23,37 +23,32 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 public class DBProperties {
 	static final int PROP_INDEX = 0;
 	static final int RECORD_SIZE = 4;
-	
+
 	protected BTree index;
 	protected Database db;
 	protected long record;
-	
+
 	/**
 	 * Allocate storage for a new DBProperties record in the specified database
-	 * @param db
-	 * @throws IndexException
 	 */
 	public DBProperties(Nd pdom) throws IndexException {
-		Database db = pdom.getDB();
-		this.record= db.malloc(RECORD_SIZE);
-		this.index= new BTree(pdom, record + PROP_INDEX, DBProperty.getComparator());
-		this.db= db;
+		Database database = pdom.getDB();
+		this.record= database.malloc(RECORD_SIZE);
+		this.index= new BTree(pdom, this.record + PROP_INDEX, DBProperty.getComparator());
+		this.db= database;
 	}
-	
+
 	/**
 	 * Creates an object for accessing an existing DBProperties record at the specified location
 	 * of the specified database.
-	 * @param db
-	 * @param record
-	 * @throws IndexException
 	 */
 	public DBProperties(Nd pdom, long record) throws IndexException {
-		Database db = pdom.getDB();
+		Database database = pdom.getDB();
 		this.record= record;
 		this.index= new BTree(pdom, record + PROP_INDEX, DBProperty.getComparator());
-		this.db= db;
+		this.db= database;
 	}
-	
+
 	/**
 	 * Reads the named property from this properties storage.
 	 * @param key a case-sensitive identifier for a property, or null
@@ -63,14 +58,14 @@ public class DBProperties {
 	 */
 	public String getProperty(String key) throws IndexException {
 		if (key != null) {
-			DBProperty existing= DBProperty.search(db, index, key);
+			DBProperty existing= DBProperty.search(this.db, this.index, key);
 			if (existing != null) {
 				return existing.getValue().getString();
 			}
 		}
 		return null;
 	}
-	
+
 	/**
 	 * Reads the named property from this properties storage, returning the default value if there
 	 * is no such property.
@@ -91,7 +86,7 @@ public class DBProperties {
 	 * @throws IndexException
 	 */
 	public Set<String> getKeySet() throws IndexException {
-		return DBProperty.getKeySet(db, index);
+		return DBProperty.getKeySet(this.db, this.index);
 	}
 
 	/**
@@ -104,8 +99,8 @@ public class DBProperties {
 	 */
 	public void setProperty(String key, String value) throws IndexException {
 		removeProperty(key);
-		DBProperty newProperty= new DBProperty(db, key, value);
-		index.insert(newProperty.getRecord());
+		DBProperty newProperty= new DBProperty(this.db, key, value);
+		this.index.insert(newProperty.getRecord());
 	}
 
 	/**
@@ -117,35 +112,35 @@ public class DBProperties {
 	 */
 	public boolean removeProperty(String key) throws IndexException {
 		if (key != null) {
-			DBProperty existing= DBProperty.search(db, index, key);
+			DBProperty existing= DBProperty.search(this.db, this.index, key);
 			if (existing != null) {
-				index.delete(existing.getRecord());
+				this.index.delete(existing.getRecord());
 				existing.delete();
 				return true;
 			}
 		}
 		return false;
 	}
-	
+
 	/**
 	 * Deletes all properties, does not delete the record associated with the object itself
 	 * - that is it can be re-populated.
 	 * @throws IndexException
 	 */
 	public void clear() throws IndexException {
-		index.accept(new IBTreeVisitor(){
+		this.index.accept(new IBTreeVisitor(){
 			@Override
-			public int compare(long record) throws IndexException {
+			public int compare(long address) throws IndexException {
 				return 0;
 			}
 			@Override
-			public boolean visit(long record) throws IndexException {
-				new DBProperty(db, record).delete();
+			public boolean visit(long address) throws IndexException {
+				new DBProperty(DBProperties.this.db, address).delete();
 				return false; // there should never be duplicates
 			}
 		});
 	}
-	
+
 	/**
 	 * Deletes all properties stored in this object and the record associated with this object
 	 * itself.
@@ -155,26 +150,26 @@ public class DBProperties {
 	 */
 	public void delete() throws IndexException {
 		clear();
-		db.free(record);
+		this.db.free(this.record);
 	}
 
 	public long getRecord() {
-		return record;
+		return this.record;
 	}
-	
+
 	private static class DBProperty {
 		static final int KEY = 0;
 		static final int VALUE = 4;
 		@SuppressWarnings("hiding")
 		static final int RECORD_SIZE = 8;
-		
+
 		Database db;
 		long record;
-		
+
 		public long getRecord() {
-			return record;
+			return this.record;
 		}
-		
+
 		/**
 		 * Allocates and initializes a record in the specified database for a DBProperty record
 		 * @param db
@@ -188,11 +183,11 @@ public class DBProperties {
 			IString dbkey= db.newString(key);
 			IString dbvalue= db.newString(value);
 			this.record= db.malloc(RECORD_SIZE);
-			db.putRecPtr(record + KEY, dbkey.getRecord());
-			db.putRecPtr(record + VALUE, dbvalue.getRecord());
+			db.putRecPtr(this.record + KEY, dbkey.getRecord());
+			db.putRecPtr(this.record + VALUE, dbvalue.getRecord());
 			this.db= db;
 		}
-		
+
 		/**
 		 * Returns an object for accessing an existing DBProperty record at the specified location
 		 * in the specified database.
@@ -203,15 +198,15 @@ public class DBProperties {
 			this.record= record;
 			this.db= db;
 		}
-		
+
 		public IString getKey() throws IndexException {
-			return db.getString(db.getRecPtr(record + KEY));
+			return this.db.getString(this.db.getRecPtr(this.record + KEY));
 		}
-		
+
 		public IString getValue() throws IndexException {
-			return db.getString(db.getRecPtr(record + VALUE));
+			return this.db.getString(this.db.getRecPtr(this.record + VALUE));
 		}
-		
+
 		public static IBTreeComparator getComparator() {
 			return new IBTreeComparator() {
 				@Override
@@ -223,7 +218,7 @@ public class DBProperties {
 				}
 			};
 		}
-		
+
 		public static DBProperty search(final Database db, final BTree index, final String key) throws IndexException {
 			final DBProperty[] result= new DBProperty[1];
 			index.accept(new IBTreeVisitor(){
@@ -240,7 +235,7 @@ public class DBProperties {
 			});
 			return result[0];
 		}
-		
+
 		public static Set<String> getKeySet(final Database db, final BTree index) throws IndexException {
 			final Set<String> result= new HashSet<String>();
 			index.accept(new IBTreeVisitor(){
@@ -257,11 +252,11 @@ public class DBProperties {
 			});
 			return result;
 		}
-		
+
 		public void delete() throws IndexException {
-			db.getString(db.getRecPtr(record + KEY)).delete();
-			db.getString(db.getRecPtr(record + VALUE)).delete();
-			db.free(record);
+			this.db.getString(this.db.getRecPtr(this.record + KEY)).delete();
+			this.db.getString(this.db.getRecPtr(this.record + VALUE)).delete();
+			this.db.free(this.record);
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 805bf3f..6299cac 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -124,23 +124,23 @@ public class Database {
 	 */
 	public Database(File location, ChunkCache cache, int version, boolean openReadOnly) throws IndexException {
 		try {
-			fLocation = location;
-			fReadOnly= openReadOnly;
-			fCache= cache;
+			this.fLocation = location;
+			this.fReadOnly= openReadOnly;
+			this.fCache= cache;
 			openFile();
 
-			int nChunksOnDisk = (int) (fFile.length() / CHUNK_SIZE);
-			fHeaderChunk= new Chunk(this, 0);
-			fHeaderChunk.fLocked= true;		// Never makes it into the cache, needed to satisfy assertions.
+			int nChunksOnDisk = (int) (this.fFile.length() / CHUNK_SIZE);
+			this.fHeaderChunk= new Chunk(this, 0);
+			this.fHeaderChunk.fLocked= true;		// Never makes it into the cache, needed to satisfy assertions.
 			if (nChunksOnDisk <= 0) {
-				fVersion= version;
-				fChunks= new Chunk[1];
-				fChunksUsed = fChunksAllocated = fChunks.length;
+				this.fVersion= version;
+				this.fChunks= new Chunk[1];
+				this.fChunksUsed = this.fChunksAllocated = this.fChunks.length;
 			} else {
-				fHeaderChunk.read();
-				fVersion= fHeaderChunk.getInt(VERSION_OFFSET);
-				fChunks = new Chunk[nChunksOnDisk];	// chunk[0] is unused.
-				fChunksUsed = fChunksAllocated = nChunksOnDisk;
+				this.fHeaderChunk.read();
+				this.fVersion= this.fHeaderChunk.getInt(VERSION_OFFSET);
+				this.fChunks = new Chunk[nChunksOnDisk];	// chunk[0] is unused.
+				this.fChunksUsed = this.fChunksAllocated = nChunksOnDisk;
 			}
 		} catch (IOException e) {
 			throw new IndexException(new DBStatus(e));
@@ -148,14 +148,14 @@ public class Database {
 	}
 
 	private void openFile() throws FileNotFoundException {
-		fFile = new RandomAccessFile(fLocation, fReadOnly ? "r" : "rw"); //$NON-NLS-1$ //$NON-NLS-2$
+		this.fFile = new RandomAccessFile(this.fLocation, this.fReadOnly ? "r" : "rw"); //$NON-NLS-1$ //$NON-NLS-2$
 	}
 
 	void read(ByteBuffer buf, long position) throws IOException {
 		int retries= 0;
 		do {
 			try {
-				fFile.getChannel().read(buf, position);
+				this.fFile.getChannel().read(buf, position);
 				return;
 			} catch (ClosedChannelException e) {
 				// Bug 219834 file may have be closed by interrupting a thread during an I/O operation.
@@ -168,7 +168,7 @@ public class Database {
 		int retries= 0;
 		while (true) {
 			try {
-				fFile.getChannel().write(buf, position);
+				this.fFile.getChannel().write(buf, position);
 				return;
 			} catch (ClosedChannelException e) {
 				// Bug 219834 file may have be closed by interrupting a thread during an I/O operation.
@@ -186,8 +186,8 @@ public class Database {
 	}
 
 	public void transferTo(FileChannel target) throws IOException {
-		assert fLocked;
-        final FileChannel from= fFile.getChannel();
+		assert this.fLocked;
+        final FileChannel from= this.fFile.getChannel();
         long nRead = 0;
         long position = 0;
         long size = from.size();
@@ -202,13 +202,13 @@ public class Database {
 	}
 
 	public int getVersion() {
-		return fVersion;
+		return this.fVersion;
 	}
 
 	public void setVersion(int version) throws IndexException {
-		assert fExclusiveLock;
-		fHeaderChunk.putInt(VERSION_OFFSET, version);
-		fVersion= version;
+		assert this.fExclusiveLock;
+		this.fHeaderChunk.putInt(VERSION_OFFSET, version);
+		this.fVersion= version;
 	}
 
 	/**
@@ -216,22 +216,22 @@ public class Database {
 	 * @throws IndexException
 	 */
 	public void clear(int version) throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		removeChunksFromCache();
 
-		fVersion= version;
+		this.fVersion= version;
 		// Clear the first chunk.
-		fHeaderChunk.clear(0, CHUNK_SIZE);
+		this.fHeaderChunk.clear(0, CHUNK_SIZE);
 		// Chunks have been removed from the cache, so we may just reset the array of chunks.
-		fChunks = new Chunk[] {null};
-		fChunksUsed = fChunksAllocated = fChunks.length;
+		this.fChunks = new Chunk[] {null};
+		this.fChunksUsed = this.fChunksAllocated = this.fChunks.length;
 		try {
-			fHeaderChunk.flush();	// Zero out header chunk.
-			fFile.getChannel().truncate(CHUNK_SIZE);	// Truncate database.
+			this.fHeaderChunk.flush();	// Zero out header chunk.
+			this.fFile.getChannel().truncate(CHUNK_SIZE);	// Truncate database.
 		} catch (IOException e) {
 			Package.log(e);
 		}
-		malloced = freed = 0;
+		this.malloced = this.freed = 0;
 		/*
 		 * This is for debugging purposes in order to simulate having a very large PDOM database.
 		 * This will set aside the specified number of chunks.
@@ -250,12 +250,12 @@ public class Database {
 	}
 
 	private void removeChunksFromCache() {
-		synchronized (fCache) {
-			for (int i= 1; i < fChunks.length; i++) {
-				Chunk chunk= fChunks[i];
+		synchronized (this.fCache) {
+			for (int i= 1; i < this.fChunks.length; i++) {
+				Chunk chunk= this.fChunks[i];
 				if (chunk != null) {
-					fCache.remove(chunk);
-					fChunks[i]= null;
+					this.fCache.remove(chunk);
+					this.fChunks[i]= null;
 				}
 			}
 		}
@@ -267,29 +267,29 @@ public class Database {
 	 */
 	public Chunk getChunk(long offset) throws IndexException {
 		if (!this.fLocked) {
-			throw new IllegalStateException("Database not locked!");
+			throw new IllegalStateException("Database not locked!"); //$NON-NLS-1$
 		}
 		if (offset < CHUNK_SIZE) {
-			return fHeaderChunk;
+			return this.fHeaderChunk;
 		}
 		long long_index = offset / CHUNK_SIZE;
 		assert long_index < Integer.MAX_VALUE;
 
-		synchronized (fCache) {
-			assert fLocked;
+		synchronized (this.fCache) {
+			assert this.fLocked;
 			final int index = (int) long_index;
-			if (index < 0 || index >= fChunks.length) {
+			if (index < 0 || index >= this.fChunks.length) {
 				databaseCorruptionDetected();
 			}
-			Chunk chunk= fChunks[index];
+			Chunk chunk= this.fChunks[index];
 			if (chunk == null) {
-				cacheMisses++;
-				chunk = fChunks[index] = new Chunk(this, index);
+				this.cacheMisses++;
+				chunk = this.fChunks[index] = new Chunk(this, index);
 				chunk.read();
 			} else {
-				cacheHits++;
+				this.cacheHits++;
 			}
-			fCache.add(chunk, fExclusiveLock);
+			this.fCache.add(chunk, this.fExclusiveLock);
 			return chunk;
 		}
 	}
@@ -316,7 +316,7 @@ public class Database {
 	 * Allocate a block out of the database.
 	 */
 	public long malloc(final int datasize) throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		assert datasize >= 0;
 		assert datasize <= MAX_MALLOC_SIZE;
 
@@ -360,30 +360,30 @@ public class Database {
 		// Clear out the block, lots of people are expecting this.
 		chunk.clear(freeblock + BLOCK_HEADER_SIZE, usedSize - BLOCK_HEADER_SIZE);
 
-		malloced += usedSize;
+		this.malloced += usedSize;
 		return freeblock + BLOCK_HEADER_SIZE;
 	}
 
 	private long createNewChunk() throws IndexException {
-		assert fExclusiveLock;
-		synchronized (fCache) {
-			final int newChunkIndex = fChunksUsed; // fChunks.length;
+		assert this.fExclusiveLock;
+		synchronized (this.fCache) {
+			final int newChunkIndex = this.fChunksUsed; // fChunks.length;
 
 			final Chunk chunk = new Chunk(this, newChunkIndex);
 			chunk.fDirty = true;
 
-			if (newChunkIndex >= fChunksAllocated) {
-				int increment = Math.max(1024, fChunksAllocated / 20);
-				Chunk[] newchunks = new Chunk[fChunksAllocated + increment];
-				System.arraycopy(fChunks, 0, newchunks, 0, fChunksAllocated);
+			if (newChunkIndex >= this.fChunksAllocated) {
+				int increment = Math.max(1024, this.fChunksAllocated / 20);
+				Chunk[] newchunks = new Chunk[this.fChunksAllocated + increment];
+				System.arraycopy(this.fChunks, 0, newchunks, 0, this.fChunksAllocated);
 
-				fChunks = newchunks;
-				fChunksAllocated += increment;
+				this.fChunks = newchunks;
+				this.fChunksAllocated += increment;
 			}
-			fChunksUsed += 1;
-			fChunks[newChunkIndex] = chunk;
+			this.fChunksUsed += 1;
+			this.fChunks[newChunkIndex] = chunk;
 
-			fCache.add(chunk, true);
+			this.fCache.add(chunk, true);
 			long address = (long) newChunkIndex * CHUNK_SIZE;
 
 			/*
@@ -406,37 +406,37 @@ public class Database {
 	 * For testing purposes, only.
 	 */
 	private long createNewChunks(int numChunks) throws IndexException {
-		assert fExclusiveLock;
-		synchronized (fCache) {
-			final int oldLen= fChunks.length;
+		assert this.fExclusiveLock;
+		synchronized (this.fCache) {
+			final int oldLen= this.fChunks.length;
 			Chunk[] newchunks = new Chunk[oldLen + numChunks];
-			System.arraycopy(fChunks, 0, newchunks, 0, oldLen);
+			System.arraycopy(this.fChunks, 0, newchunks, 0, oldLen);
 			for (int i = oldLen; i < oldLen + numChunks; i++) {
 				newchunks[i]= null;
 			}
 			final Chunk chunk= new Chunk(this, oldLen + numChunks - 1);
 			chunk.fDirty= true;
 			newchunks[ oldLen + numChunks - 1 ] = chunk;
-			fChunks= newchunks;
-			fCache.add(chunk, true);
-			fChunksAllocated=oldLen + numChunks;
-			fChunksUsed=oldLen + numChunks;
+			this.fChunks= newchunks;
+			this.fCache.add(chunk, true);
+			this.fChunksAllocated=oldLen + numChunks;
+			this.fChunksUsed=oldLen + numChunks;
 			return (long) (oldLen + numChunks - 1) * CHUNK_SIZE;
 		}
 	}
 
 	private long getFirstBlock(int blocksize) throws IndexException {
-		assert fLocked;
-		return fHeaderChunk.getFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE);
+		assert this.fLocked;
+		return this.fHeaderChunk.getFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE);
 	}
 
 	private void setFirstBlock(int blocksize, long block) throws IndexException {
-		assert fExclusiveLock;
-		fHeaderChunk.putFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE, block);
+		assert this.fExclusiveLock;
+		this.fHeaderChunk.putFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE, block);
 	}
 
 	private void removeBlock(Chunk chunk, int blocksize, long block) throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		long prevblock = chunk.getFreeRecPtr(block + BLOCK_PREV_OFFSET);
 		long nextblock = chunk.getFreeRecPtr(block + BLOCK_NEXT_OFFSET);
 		if (prevblock != 0) {
@@ -450,7 +450,7 @@ public class Database {
 	}
 
 	private void addBlock(Chunk chunk, int blocksize, long block) throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		// Mark our size
 		chunk.putShort(block, (short) blocksize);
 
@@ -469,7 +469,7 @@ public class Database {
 	 * @param offset
 	 */
 	public void free(long offset) throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		// TODO Look for opportunities to merge blocks
 		long block = offset - BLOCK_HEADER_SIZE;
 		Chunk chunk = getChunk(block);
@@ -480,7 +480,7 @@ public class Database {
 					"Already freed record " + offset, new Exception())); //$NON-NLS-1$
 		}
 		addBlock(chunk, blocksize, block);
-		freed += blocksize;
+		this.freed += blocksize;
 	}
 
 	public void putByte(long offset, byte value) throws IndexException {
@@ -550,7 +550,7 @@ public class Database {
 	public double getDouble(long offset) throws IndexException {
 		return getChunk(offset).getDouble(offset);
 	}
-	
+
 	public float getFloat(long offset) throws IndexException {
 		return getChunk(offset).getFloat(offset);
 	}
@@ -625,10 +625,10 @@ public class Database {
 	 * For debugging purposes, only.
 	 */
 	public void reportFreeBlocks() throws IndexException {
-		System.out.println("Allocated size: " + fChunksUsed * CHUNK_SIZE); //$NON-NLS-1$
-		System.out.println("malloc'ed: " + malloced); //$NON-NLS-1$
-		System.out.println("free'd: " + freed); //$NON-NLS-1$
-		System.out.println("wasted: " + (fChunksUsed * CHUNK_SIZE - (malloced - freed))); //$NON-NLS-1$
+		System.out.println("Allocated size: " + this.fChunksUsed * CHUNK_SIZE); //$NON-NLS-1$
+		System.out.println("malloc'ed: " + this.malloced); //$NON-NLS-1$
+		System.out.println("free'd: " + this.freed); //$NON-NLS-1$
+		System.out.println("wasted: " + (this.fChunksUsed * CHUNK_SIZE - (this.malloced - this.freed))); //$NON-NLS-1$
 		System.out.println("Free blocks"); //$NON-NLS-1$
 		for (int bs = MIN_BLOCK_DELTAS*BLOCK_SIZE_DELTA; bs <= CHUNK_SIZE; bs += BLOCK_SIZE_DELTA) {
 			int count = 0;
@@ -649,17 +649,17 @@ public class Database {
 	 * @throws IndexException
 	 */
 	public void close() throws IndexException {
-		assert fExclusiveLock;
+		assert this.fExclusiveLock;
 		flush();
 		removeChunksFromCache();
 
 		// Chunks have been removed from the cache, so we are fine.
-		fHeaderChunk.clear(0, CHUNK_SIZE);
-		fHeaderChunk.fDirty= false;
-		fChunks= new Chunk[] { null };
-		fChunksUsed = fChunksAllocated = fChunks.length;
+		this.fHeaderChunk.clear(0, CHUNK_SIZE);
+		this.fHeaderChunk.fDirty= false;
+		this.fChunks= new Chunk[] { null };
+		this.fChunksUsed = this.fChunksAllocated = this.fChunks.length;
 		try {
-			fFile.close();
+			this.fFile.close();
 		} catch (IOException e) {
 			throw new IndexException(new DBStatus(e));
 		}
@@ -669,7 +669,7 @@ public class Database {
      * This method is public for testing purposes only.
      */
 	public File getLocation() {
-		return fLocation;
+		return this.fLocation;
 	}
 
 	/**
@@ -677,7 +677,7 @@ public class Database {
 	 */
 	void releaseChunk(final Chunk chunk) {
 		if (!chunk.fLocked) {
-			fChunks[chunk.fSequenceNumber]= null;
+			this.fChunks[chunk.fSequenceNumber]= null;
 		}
 	}
 
@@ -686,7 +686,7 @@ public class Database {
 	 * @since 4.0
 	 */
 	public ChunkCache getChunkCache() {
-		return fCache;
+		return this.fCache;
 	}
 
 	/**
@@ -694,21 +694,21 @@ public class Database {
 	 * write operations.
 	 */
 	public void setExclusiveLock() {
-		fExclusiveLock= true;
-		fLocked= true;
+		this.fExclusiveLock= true;
+		this.fLocked= true;
 	}
 
 	public void setLocked(boolean val) {
-		fLocked= val;
+		this.fLocked= val;
 	}
 
 	public void giveUpExclusiveLock(final boolean flush) throws IndexException {
-		if (fExclusiveLock) {
+		if (this.fExclusiveLock) {
 			try {
 				ArrayList<Chunk> dirtyChunks= new ArrayList<>();
-				synchronized (fCache) {
-					for (int i= 1; i < fChunksUsed; i++) {
-						Chunk chunk= fChunks[i];
+				synchronized (this.fCache) {
+					for (int i= 1; i < this.fChunksUsed; i++) {
+						Chunk chunk= this.fChunks[i];
 						if (chunk != null) {
 							if (chunk.fCacheIndex < 0) {
 								// Locked chunk that has been removed from cache.
@@ -716,7 +716,7 @@ public class Database {
 									dirtyChunks.add(chunk); // Keep in fChunks until it is flushed.
 								} else {
 									chunk.fLocked= false;
-									fChunks[i]= null;
+									this.fChunks[i]= null;
 								}
 							} else if (chunk.fLocked) {
 								// Locked chunk, still in cache.
@@ -736,14 +736,14 @@ public class Database {
 				// Also handles header chunk.
 				flushAndUnlockChunks(dirtyChunks, flush);
 			} finally {
-				fExclusiveLock= false;
+				this.fExclusiveLock= false;
 			}
 		}
 	}
 
 	public void flush() throws IndexException {
-		assert fLocked;
-		if (fExclusiveLock) {
+		assert this.fLocked;
+		if (this.fExclusiveLock) {
 			try {
 				giveUpExclusiveLock(true);
 			} finally {
@@ -754,9 +754,9 @@ public class Database {
 
 		// Be careful as other readers may access chunks concurrently.
 		ArrayList<Chunk> dirtyChunks= new ArrayList<>();
-		synchronized (fCache) {
-			for (int i= 1; i < fChunksUsed ; i++) {
-				Chunk chunk= fChunks[i];
+		synchronized (this.fCache) {
+			for (int i= 1; i < this.fChunksUsed ; i++) {
+				Chunk chunk= this.fChunks[i];
 				if (chunk != null && chunk.fDirty) {
 					dirtyChunks.add(chunk);
 				}
@@ -768,10 +768,10 @@ public class Database {
 	}
 
 	private void flushAndUnlockChunks(final ArrayList<Chunk> dirtyChunks, boolean isComplete) throws IndexException {
-		assert !Thread.holdsLock(fCache);
-		synchronized (fHeaderChunk) {
+		assert !Thread.holdsLock(this.fCache);
+		synchronized (this.fHeaderChunk) {
 			final boolean haveDirtyChunks = !dirtyChunks.isEmpty();
-			if (haveDirtyChunks || fHeaderChunk.fDirty) {
+			if (haveDirtyChunks || this.fHeaderChunk.fDirty) {
 				markFileIncomplete();
 			}
 			if (haveDirtyChunks) {
@@ -782,32 +782,32 @@ public class Database {
 				}
 
 				// Only after the chunks are flushed we may unlock and release them.
-				synchronized (fCache) {
+				synchronized (this.fCache) {
 					for (Chunk chunk : dirtyChunks) {
 						chunk.fLocked= false;
 						if (chunk.fCacheIndex < 0) {
-							fChunks[chunk.fSequenceNumber]= null;
+							this.fChunks[chunk.fSequenceNumber]= null;
 						}
 					}
 				}
 			}
 
 			if (isComplete) {
-				if (fHeaderChunk.fDirty || fIsMarkedIncomplete) {
-					fHeaderChunk.putInt(VERSION_OFFSET, fVersion);
-					fHeaderChunk.flush();
-					fIsMarkedIncomplete= false;
+				if (this.fHeaderChunk.fDirty || this.fIsMarkedIncomplete) {
+					this.fHeaderChunk.putInt(VERSION_OFFSET, this.fVersion);
+					this.fHeaderChunk.flush();
+					this.fIsMarkedIncomplete= false;
 				}
 			}
 		}
 	}
 
 	private void markFileIncomplete() throws IndexException {
-		if (!fIsMarkedIncomplete) {
-			fIsMarkedIncomplete= true;
+		if (!this.fIsMarkedIncomplete) {
+			this.fIsMarkedIncomplete= true;
 			try {
 				final ByteBuffer buf= ByteBuffer.wrap(new byte[4]);
-				fFile.getChannel().write(buf, 0);
+				this.fFile.getChannel().write(buf, 0);
 			} catch (IOException e) {
 				throw new IndexException(new DBStatus(e));
 			}
@@ -815,23 +815,19 @@ public class Database {
 	}
 
 	public void resetCacheCounters() {
-		cacheHits= cacheMisses= 0;
+		this.cacheHits= this.cacheMisses= 0;
 	}
 
 	public long getCacheHits() {
-		return cacheHits;
+		return this.cacheHits;
 	}
 
 	public long getCacheMisses() {
-		return cacheMisses;
+		return this.cacheMisses;
 	}
 
-	public long getSizeBytes() {
-		try {
-			return fFile.length();
-		} catch (IOException e) {
-		}
-		return 0;
+	public long getSizeBytes() throws IOException {
+		return this.fFile.length();
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/EmptyString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/EmptyString.java
index f5da0bf..ff592b2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/EmptyString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/EmptyString.java
@@ -11,7 +11,8 @@
 package org.eclipse.jdt.internal.core.nd.db;
 
 /**
- * TODO: Insert description here. (generated by sxenos)
+ * Represents an empty string.
+ *
  * @since 3.12
  */
 public class EmptyString implements IString {
@@ -22,11 +23,11 @@ public class EmptyString implements IString {
 	private EmptyString() {
 		this.compareResult = "".compareTo("a");  //$NON-NLS-1$//$NON-NLS-2$
 	}
-	
+
 	public static EmptyString create() {
 		return theEmptyString;
 	}
-	
+
 	@Override
 	public long getRecord() {
 		return 0;
@@ -92,6 +93,7 @@ public class EmptyString implements IString {
 
 	@Override
 	public void delete() {
+		// Can't be deleted
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
index 4882135..71584cc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
@@ -27,7 +27,7 @@ public class IndexException extends RuntimeException {
 	}
 
 	public IndexException(String message) {
-		this(new Status(Status.ERROR, "org.eclipse.jdt.core", message)); //$NON-NLS-1$
+		this(new Status(IStatus.ERROR, "org.eclipse.jdt.core", message)); //$NON-NLS-1$
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/LongString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/LongString.java
index 1a468b0..41108a1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/LongString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/LongString.java
@@ -16,7 +16,7 @@ package org.eclipse.jdt.internal.core.nd.db;
  * This is for strings that take up more than on chunk.
  * The string will need to be broken up into sections and then
  * reassembled when necessary.
- * 
+ *
  * @author Doug Schaefer
  * @since 3.12
  */
@@ -29,20 +29,20 @@ public class LongString implements IString {
 	private static final int LENGTH = 0; // Must be first to match ShortString.
 	private static final int NEXT1 = 4;
 	private static final int CHARS1 = 8;
-	
+
 	private static final int NUM_CHARS1 = (Database.MAX_MALLOC_SIZE - CHARS1) / 2;
-	
+
 	// Additional fields of subsequent records.
 	private static final int NEXTN = 0;
 	private static final int CHARSN = 4;
-	
+
 	private static final int NUM_CHARSN = (Database.MAX_MALLOC_SIZE - CHARSN) / 2;
-	
+
 	public LongString(Database db, long record) {
 		this.db = db;
 		this.record = record;
 	}
-	
+
 	public LongString(Database db, final char[] chars, boolean useBytes) throws IndexException {
 		final int numChars1 = useBytes ? NUM_CHARS1 * 2 : NUM_CHARS1;
 		final int numCharsn = useBytes ? NUM_CHARSN * 2 : NUM_CHARSN;
@@ -54,13 +54,13 @@ public class LongString implements IString {
 		final int length = chars.length;
 		db.putInt(this.record, useBytes ? -length : length);
 		Chunk chunk= db.getChunk(this.record);
-		
+
 		if (useBytes) {
 			chunk.putCharsAsBytes(this.record + CHARS1, chars, 0, numChars1);
 		} else {
 			chunk.putChars(this.record + CHARS1, chars, 0, numChars1);
 		}
-		
+
 		// Write the subsequent records.
 		long lastNext = this.record + NEXT1;
 		int start = numChars1;
@@ -76,7 +76,7 @@ public class LongString implements IString {
 			start += numCharsn;
 			lastNext = nextRecord + NEXTN;
 		}
-		
+
 		// Write the last record.
 		int remaining= length - start;
 		long nextRecord = db.malloc(CHARSN + (useBytes ? remaining : remaining * 2));
@@ -88,15 +88,15 @@ public class LongString implements IString {
 			chunk.putChars(nextRecord + CHARSN, chars, start, remaining);
 		}
 	}
-	
+
 	@Override
 	public long getRecord() {
-		return record;
+		return this.record;
 	}
 
 	@Override
 	public char[] getChars() throws IndexException {
-		int length = db.getInt(record + LENGTH);
+		int length = this.db.getInt(this.record + LENGTH);
 		final boolean useBytes = length < 0;
 		int numChars1 = NUM_CHARS1;
 		int numCharsn = NUM_CHARSN;
@@ -107,24 +107,24 @@ public class LongString implements IString {
 		}
 
 		final char[] chars = new char[length];
-	
+
 		// First record
-		long p = record;
-		Chunk chunk= db.getChunk(p);
+		long p = this.record;
+		Chunk chunk= this.db.getChunk(p);
 		if (useBytes) {
 			chunk.getCharsFromBytes(p + CHARS1, chars, 0, numChars1);
 		} else {
 			chunk.getChars(p + CHARS1, chars, 0, numChars1);
 		}
-		
+
 		int start= numChars1;
-		p= record + NEXT1;
-				
+		p= this.record + NEXT1;
+
 		// Other records
 		while (start < length) {
-			p = db.getRecPtr(p);
+			p = this.db.getRecPtr(p);
 			int partLen= Math.min(length - start, numCharsn);
-			chunk= db.getChunk(p);
+			chunk= this.db.getChunk(p);
 			if (useBytes) {
 				chunk.getCharsFromBytes(p + CHARSN, chars, start, partLen);
 			} else {
@@ -138,7 +138,7 @@ public class LongString implements IString {
 
 	@Override
 	public void delete() throws IndexException {
-		int length = db.getInt(record + LENGTH);
+		int length = this.db.getInt(this.record + LENGTH);
 		final boolean useBytes = length < 0;
 		int numChars1 = NUM_CHARS1;
 		int numCharsn = NUM_CHARSN;
@@ -147,22 +147,22 @@ public class LongString implements IString {
 			numChars1 *= 2;
 			numCharsn *= 2;
 		}
-		long nextRecord = db.getRecPtr(record + NEXT1);
-		db.free(record);
+		long nextRecord = this.db.getRecPtr(this.record + NEXT1);
+		this.db.free(this.record);
 		length -= numChars1;
-		
+
 		// Middle records.
 		while (length > numCharsn) {
 			length -= numCharsn;
-			long nextnext = db.getRecPtr(nextRecord + NEXTN);
-			db.free(nextRecord);
+			long nextnext = this.db.getRecPtr(nextRecord + NEXTN);
+			this.db.free(nextRecord);
 			nextRecord = nextnext;
 		}
-		
+
 		// Last record.
-		db.free(nextRecord);
+		this.db.free(nextRecord);
 	}
-	
+
 	@Override
 	public boolean equals(Object obj) {
 		if (obj == this)
@@ -170,7 +170,7 @@ public class LongString implements IString {
 		try {
 			if (obj instanceof LongString) {
 				LongString lstr = (LongString)obj;
-				if (db == lstr.db && record == lstr.record)
+				if (this.db == lstr.db && this.record == lstr.record)
 					return true;
 				return compare(lstr, true) == 0;
 			}
@@ -185,33 +185,30 @@ public class LongString implements IString {
 		}
 		return false;
 	}
-	
+
 	/**
 	 * Compatible with {@link String#hashCode()}
 	 */
 	@Override
 	public int hashCode() {
-		int h = hash;
+		int h = this.hash;
 		if (h == 0) {
 			char chars[];
-			try {
-				chars = getChars();
-				final int len = chars.length;
-				for (int i = 0; i < len; i++) {
-					h = 31 * h + chars[i];
-				}
-			} catch (IndexException e) {
+			chars = getChars();
+			final int len = chars.length;
+			for (int i = 0; i < len; i++) {
+				h = 31 * h + chars[i];
 			}
-			hash = h;
+			this.hash = h;
 		}
 		return h;
 	}
-	
+
 	@Override
 	public int compare(IString string, boolean caseSensitive) throws IndexException {
 		return ShortString.compare(getChars(), string.getChars(), caseSensitive);
 	}
-		
+
 	@Override
 	public int compare(String other, boolean caseSensitive) throws IndexException {
 		return ShortString.compare(getChars(), other.toCharArray(), caseSensitive);
@@ -221,12 +218,12 @@ public class LongString implements IString {
 	public int compare(char[] other, boolean caseSensitive) throws IndexException {
 		return ShortString.compare(getChars(), other, caseSensitive);
 	}
-	
+
 	@Override
 	public int compareCompatibleWithIgnoreCase(IString string) throws IndexException {
 		return ShortString.compareCompatibleWithIgnoreCase(getChars(), string.getChars());
 	}
-	
+
 	@Override
 	public int comparePrefix(char[] other, boolean caseSensitive) throws IndexException {
 		return ShortString.comparePrefix(getChars(), other, caseSensitive);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/NdStringSet.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/NdStringSet.java
index b4a4cb7..41b238f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/NdStringSet.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/NdStringSet.java
@@ -40,22 +40,22 @@ public class NdStringSet {
 		this.db = db;
 		this.ptr = ptr;
 
-		head = 0;
-		loaded = 0;
+		this.head = 0;
+		this.loaded = 0;
 	}
 
 	public void clearCaches() {
-		head = 0;
-		loaded = 0;
+		this.head = 0;
+		this.loaded = 0;
 
-		if (lazyCache != null)
-			lazyCache = null;
+		if (this.lazyCache != null)
+			this.lazyCache = null;
 	}
 
 	private long getHead() throws CoreException {
-		if (head == 0)
-			head = db.getRecPtr(ptr);
-		return head;
+		if (this.head == 0)
+			this.head = this.db.getRecPtr(this.ptr);
+		return this.head;
 	}
 
 	// A simple enum describing the type of the information that is stored in the Database. Each
@@ -71,12 +71,12 @@ public class NdStringSet {
 
 		/** Return the value of the pointer stored in this field in the given instance. */
 		public long get(Database db, long instance) throws CoreException {
-			return db.getRecPtr(instance + offset);
+			return db.getRecPtr(instance + this.offset);
 		}
 
 		/** Store the given pointer into this field in the given instance. */
 		public void put(Database db, long instance, long value) throws CoreException {
-			db.putRecPtr(instance + offset, value);
+			db.putRecPtr(instance + this.offset, value);
 		}
 	}
 
@@ -89,25 +89,25 @@ public class NdStringSet {
 		if (record != 0)
 			return record;
 
-		IString string = db.newString(str);
+		IString string = this.db.newString(str);
 		record = string.getRecord();
 
-		long new_node = db.malloc(NodeType.sizeof);
-		NodeType.Next.put(db, new_node, getHead());
-		NodeType.Item.put(db, new_node, record);
+		long new_node = this.db.malloc(NodeType.sizeof);
+		NodeType.Next.put(this.db, new_node, getHead());
+		NodeType.Item.put(this.db, new_node, record);
 
-		if (lazyCache == null)
-			lazyCache = new HashMap<String, Long>();
-		lazyCache.put(str, record);
+		if (this.lazyCache == null)
+			this.lazyCache = new HashMap<String, Long>();
+		this.lazyCache.put(str, record);
 
 		// If the Database has already been partially searched, then the loaded pointer will be after the
 		// head. Since we've already put this new record into the lazy cache, there is no reason to try to
 		// load it again. We put the new node at the start of the list so that it will be before the loaded
 		// pointer.
-		head = new_node;
-		if (loaded == 0)
-			loaded = new_node;
-		db.putRecPtr(ptr, new_node);
+		this.head = new_node;
+		if (this.loaded == 0)
+			this.loaded = new_node;
+		this.db.putRecPtr(this.ptr, new_node);
 		return record;
 	}
 
@@ -117,8 +117,8 @@ public class NdStringSet {
 	 * instance. Returns the record of the String.
 	 */
 	public long find(String str) throws CoreException {
-		if (lazyCache != null) {
-			Long l = lazyCache.get(str);
+		if (this.lazyCache != null) {
+			Long l = this.lazyCache.get(str);
 			if (l != null)
 				return l.longValue();
 		}
@@ -128,27 +128,27 @@ public class NdStringSet {
 			return 0;
 
 		// otherwise prepare the cache for the data that is about to be loaded
-		if (lazyCache == null)
-			lazyCache = new HashMap<String, Long>();
+		if (this.lazyCache == null)
+			this.lazyCache = new HashMap<String, Long>();
 
 		// if nothing has been loaded, then start loading with the head node, otherwise continue
 		// loading from whatever is after the last loaded node
-		long curr = loaded == 0 ? getHead() : NodeType.Next.get(db, loaded);
+		long curr = this.loaded == 0 ? getHead() : NodeType.Next.get(this.db, this.loaded);
 		while (curr != 0) {
-			long next = NodeType.Next.get(db, curr);
-			long item = NodeType.Item.get(db, curr);
+			long next = NodeType.Next.get(this.db, curr);
+			long item = NodeType.Item.get(this.db, curr);
 
-			IString string = db.getString(item);
+			IString string = this.db.getString(item);
 
 			// put the value into the cache
-			lazyCache.put(string.getString(), Long.valueOf(item));
+			this.lazyCache.put(string.getString(), Long.valueOf(item));
 
 			// return immediately if this is the target
 			if (string.compare(str, true) == 0)
 				return item;
 
 			// otherwise keep looking
-			loaded = curr;
+			this.loaded = curr;
 			curr = next;
 		}
 
@@ -159,26 +159,26 @@ public class NdStringSet {
 	 * Return a pointer to the record of the String that was removed.
 	 */
 	public long remove(String str) throws CoreException {
-		if (lazyCache != null)
-			lazyCache.remove(str);
+		if (this.lazyCache != null)
+			this.lazyCache.remove(str);
 
 		long prev = 0;
 		long curr = getHead();
 		while (curr != 0) {
-			long next = NodeType.Next.get(db, curr);
-			long item = NodeType.Item.get(db, curr);
+			long next = NodeType.Next.get(this.db, curr);
+			long item = NodeType.Item.get(this.db, curr);
 
-			IString string = db.getString(item);
+			IString string = this.db.getString(item);
 
 			if (string.compare(str, true) == 0) {
-				if (head != curr)
-					NodeType.Next.put(db, prev, next);
+				if (this.head != curr)
+					NodeType.Next.put(this.db, prev, next);
 				else {
-					db.putRecPtr(ptr, next);
-					head = next;
+					this.db.putRecPtr(this.ptr, next);
+					this.head = next;
 				}
 
-				db.free(curr);
+				this.db.free(curr);
 				return item;
 			}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Package.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Package.java
index 74ffa1a..c6f4ed4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Package.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Package.java
@@ -15,7 +15,7 @@ import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.JavaCore;
 
 /**
- * @noreference This class is not intended to be referenced by clients
+ * This class is not intended to be referenced by clients
  */
 /* package */ class Package {
 	public static String PLUGIN_ID = JavaCore.PLUGIN_ID;
@@ -25,10 +25,7 @@ import org.eclipse.jdt.core.JavaCore;
 	 * @since 5.2
 	 */
 	public static final int STATUS_PDOM_TOO_LARGE = 4;
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static void log(Throwable e) {
 		String msg= e.getMessage();
 		if (msg == null) {
@@ -37,24 +34,15 @@ import org.eclipse.jdt.core.JavaCore;
 			log("Error: " + msg, e); //$NON-NLS-1$
 		}
 	}
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static void log(String message, Throwable e) {
 		log(createStatus(message, e));
 	}
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static IStatus createStatus(String msg, Throwable e) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg, e);
 	}
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static void log(IStatus status) {
 		JavaCore.getPlugin().getLog().log(status);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ShortString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ShortString.java
index 396bbee..b93e727 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ShortString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ShortString.java
@@ -16,20 +16,19 @@ import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 
 /**
  * This is for strings that fit inside a single chunk.
- * 
- * @author Doug Schaefer
+ *
  * @since 3.12
  */
 public class ShortString implements IString {
 	private final Database db;
 	private final long record;
 	private int hash;
-	
+
 	private static final int LENGTH = 0;
 	private static final int CHARS = 4;
-	
+
 	public static final int MAX_BYTE_LENGTH = Database.MAX_MALLOC_SIZE - CHARS;
-	
+
 	public ShortString(Database db, long offset) {
 		this.db = db;
 		this.record = offset;
@@ -38,47 +37,47 @@ public class ShortString implements IString {
 	public ShortString(Database db, char[] chars, boolean useBytes) throws IndexException {
 		final int n = chars.length;
 		this.db = db;
-		
+
 		this.record = db.malloc(CHARS + (useBytes ? n : 2 * n));
-		Chunk chunk = db.getChunk(record);
-		chunk.putInt(record + LENGTH, useBytes ? -n : n);
-		long p = record + CHARS;
+		Chunk chunk = db.getChunk(this.record);
+		chunk.putInt(this.record + LENGTH, useBytes ? -n : n);
+		long p = this.record + CHARS;
 		if (useBytes) {
 			chunk.putCharsAsBytes(p, chars, 0, n);
 		} else {
 			chunk.putChars(p, chars, 0, n);
 		}
 	}
-	
+
 	@Override
 	public long getRecord() {
-		return record;
+		return this.record;
 	}
-	
+
 	@Override
 	public void delete() throws IndexException {
-		db.free(record);
+		this.db.free(this.record);
 	}
-	
+
 	@Override
 	public char[] getChars() throws IndexException {
-		final Chunk chunk = db.getChunk(record);
-		final int l = chunk.getInt(record + LENGTH);
+		final Chunk chunk = this.db.getChunk(this.record);
+		final int l = chunk.getInt(this.record + LENGTH);
 		final int length = Math.abs(l);
 		final char[] chars = new char[length];
 		if (l < 0) {
-			chunk.getCharsFromBytes(record + CHARS, chars, 0, length);
+			chunk.getCharsFromBytes(this.record + CHARS, chars, 0, length);
 		} else {
-			chunk.getChars(record + CHARS, chars, 0, length);
+			chunk.getChars(this.record + CHARS, chars, 0, length);
 		}
 		return chars;
 	}
-	
+
 	@Override
 	public String getString() throws IndexException {
 		return new String(getChars());
 	}
-	
+
 	@Override
 	public boolean equals(Object obj) {
 		if (obj == this)
@@ -87,32 +86,32 @@ public class ShortString implements IString {
 		try {
 			if (obj instanceof ShortString) {
 				ShortString string = (ShortString)obj;
-				if (db == string.db && record == string.record)
+				if (this.db == string.db && this.record == string.record)
 					return true;
 
-				Chunk chunk1 = db.getChunk(record);
+				Chunk chunk1 = this.db.getChunk(this.record);
 				Chunk chunk2 = string.db.getChunk(string.record);
-				
-				int n1 = chunk1.getInt(record); 
+
+				int n1 = chunk1.getInt(this.record);
 				int n2 = chunk2.getInt(string.record);
 				if (n1 != n2)
 					return false;
-				
+
 				return CharArrayUtils.equals(getChars(), string.getChars());
-			} 
+			}
 			if (obj instanceof char[]) {
 				char[] chars = (char[])obj;
 
 				// Make sure size is the same
 				if (length() != chars.length)
 					return false;
-				
+
 				return CharArrayUtils.equals(getChars(), chars);
 			} else if (obj instanceof String) {
 				String string = (String)obj;
 				if (length() != string.length())
 					return false;
-				
+
 				return CharArrayUtils.equals(getChars(), string.toCharArray());
 			}
 		} catch (IndexException e) {
@@ -120,28 +119,25 @@ public class ShortString implements IString {
 		}
 		return false;
 	}
-	
+
 	/**
 	 * Compatible with {@link String#hashCode()}
 	 */
 	@Override
 	public int hashCode() {
-		int h = hash;
+		int h = this.hash;
 		if (h == 0) {
 			char chars[];
-			try {
-				chars = getChars();
-				final int len = chars.length;
-				for (int i = 0; i < len; i++) {
-					h = 31 * h + chars[i];
-				}
-			} catch (IndexException e) {
+			chars = getChars();
+			final int len = chars.length;
+			for (int i = 0; i < len; i++) {
+				h = 31 * h + chars[i];
 			}
-			hash = h;
+			this.hash = h;
 		}
 		return h;
 	}
-	
+
 	public static int compare(final char[] chars, char[] other, boolean caseSensitive) {
 		final int n = Math.min(chars.length, other.length);
 		for (int i = 0; i < n; i++) {
@@ -161,7 +157,7 @@ public class ShortString implements IString {
 	public int compare(IString string, boolean caseSensitive) throws IndexException {
 		return compare(getChars(), string.getChars(), caseSensitive);
 	}
-		
+
 	@Override
 	public int compare(String other, boolean caseSensitive) throws IndexException {
 		return compare(getChars(), other.toCharArray(), caseSensitive);
@@ -171,7 +167,7 @@ public class ShortString implements IString {
 	public int compareCompatibleWithIgnoreCase(IString string) throws IndexException {
 		return compareCompatibleWithIgnoreCase(string.getChars());
 	}
-	
+
 	@Override
 	public int compareCompatibleWithIgnoreCase(char[] other) throws IndexException {
 		return compareCompatibleWithIgnoreCase(getChars(), other);
@@ -188,7 +184,7 @@ public class ShortString implements IString {
 				int cmp= compareChars(c1, c2, false); // insensitive
 				if (cmp != 0)
 					return cmp;
-				
+
 				if (sensitiveCmp == 0) {
 					if (c1 < c2) {
 						sensitiveCmp= -1;
@@ -201,10 +197,10 @@ public class ShortString implements IString {
 		int cmp= chars.length - other.length;
 		if (cmp != 0)
 			return cmp;
-		
+
 		return sensitiveCmp;
 	}
-	
+
 	@Override
 	public int comparePrefix(char[] other, boolean caseSensitive) throws IndexException {
 		return comparePrefix(getChars(), other, caseSensitive);
@@ -212,7 +208,7 @@ public class ShortString implements IString {
 
 	public static int comparePrefix(final char[] chars, char[] other, boolean caseSensitive) {
 		final int n = Math.min(chars.length, other.length);
-		
+
 		for (int i = 0; i < n; i++) {
 			int cmp= compareChars(chars[i], other[i], caseSensitive);
 			if (cmp != 0)
@@ -220,18 +216,18 @@ public class ShortString implements IString {
 		}
 		if (chars.length < other.length)
 			return -1;
-			
+
 		return 0;
 	}
 
 	/**
 	 * Compare characters case-sensitively, or case-insensitively.
-	 * 
+	 *
 	 * <b>Limitation</b> This only maps the range a-z,A-Z onto each other
 	 * @param a a character
 	 * @param b a character
 	 * @param caseSensitive whether to compare case-sensitively
-	 * @return 
+	 * @return
 	 * <ul>
 	 * <li>-1 if a < b
 	 * <li>0 if a == b
@@ -256,10 +252,10 @@ public class ShortString implements IString {
 		}
 		return 0;
 	}
-	
+
 /* TODO - this is more correct than the above implementation, but we need to
  * benchmark first.
- * 
+ *
  * public static int compareChars(char a, char b, boolean caseSensitive) {
 		if (caseSensitive) {
 			if (a < b)
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
index f86f07d..0d35f77 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
@@ -48,28 +48,28 @@ public class BindingToIndexConverter {
 				addMemberValuePair(parent, (IMemberValuePairBinding) binding, monitor);
 				break;
 			default:
-				Package.log("Encountered unknown binding type: " + binding.getKind(), null);
+				Package.log("Encountered unknown binding type: " + binding.getKind(), null); //$NON-NLS-1$
 		}
 	}
 
 	public void addMemberValuePair(NdTreeNode parent, IMemberValuePairBinding binding, IProgressMonitor monitor) {
-		logInfo("Adding member value pair: " + binding.getName());
+		logInfo("Adding member value pair: " + binding.getName()); //$NON-NLS-1$
 	}
 
 	public void addPackage(NdTreeNode parent, IPackageBinding binding, IProgressMonitor monitor) {
-		logInfo("Adding package: " + binding.getName());
+		logInfo("Adding package: " + binding.getName()); //$NON-NLS-1$
 	}
 
 	public void addVariable(NdTreeNode parent, IVariableBinding binding, IProgressMonitor monitor) {
-		logInfo("Adding variable: " + binding.getName());
+		logInfo("Adding variable: " + binding.getName()); //$NON-NLS-1$
 	}
 
 	public void addMethod(NdTreeNode parent, IMethodBinding binding, IProgressMonitor monitor) {
-		logInfo("Adding method: " + binding.getName());
+		logInfo("Adding method: " + binding.getName()); //$NON-NLS-1$
 	}
 
 	public void addAnnotation(NdTreeNode parent, IAnnotationBinding binding, IProgressMonitor monitor) {
-		logInfo("Adding annotation: " + binding.getName());
+		logInfo("Adding annotation: " + binding.getName()); //$NON-NLS-1$
 	}
 
 	public NdType addType(ITypeBinding binding, IProgressMonitor monitor) {
@@ -108,6 +108,6 @@ public class BindingToIndexConverter {
 	}
 
 	private Nd getPDOM() {
-		return resource.getPDOM();
+		return this.resource.getPDOM();
 	}
 }
commit ca3e6c1f4d856c53ab132f965ec5d5ab6e23bdc5
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 10:02:14 2016 -0800

    Bug 481796 - Fix warnings in org.eclipse.jdt.internal.core.nd
    
    Change-Id: Idcb4f2ca24f769a582a9041416d87c283f82ded3
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

6	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/AbstractTypeFactory.java
3	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IIndexFileLocation.java
14	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexFileLocation.java
82	91	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
2	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
1	25	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Package.java
31	31	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/StreamHasher.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/AbstractTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/AbstractTypeFactory.java
index 7129015..5432b28 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/AbstractTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/AbstractTypeFactory.java
@@ -17,10 +17,14 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef.DeletionSemantics;
  */
 public abstract class AbstractTypeFactory<T> implements ITypeFactory<T> {
 	@Override
-	public void destructFields(Nd dom, long address) {}
+	public void destructFields(Nd dom, long address) {
+		// No nested fields by default
+	}
 
 	@Override
-	public void destruct(Nd dom, long address) {}
+	public void destruct(Nd dom, long address) {
+		// Nothing to destruct by default
+	}
 
 	@Override
 	public boolean hasDestructor() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IIndexFileLocation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IIndexFileLocation.java
index ce1328c..a8f5251 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IIndexFileLocation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IIndexFileLocation.java
@@ -13,10 +13,9 @@ package org.eclipse.jdt.internal.core.nd;
 import java.net.URI;
 
 /**
- * Files in the index are (conceptually) partitioned into workspace and non-workspace (external) files. Clients can
- * obtain instances of IIndexFileLocation implementations from {@link IndexLocationFactory}. Two index file locations
- * are considered equal if their URIs are equal.
- * 
+ * Files in the index are (conceptually) partitioned into workspace and non-workspace (external) files. Two index file
+ * locations are considered equal if their URIs are equal.
+ *
  * @noextend This interface is not intended to be extended by clients.
  * @noimplement This interface is not intended to be implemented by clients.
  * @since 3.12
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexFileLocation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexFileLocation.java
index 7ae84c1..fe2b582 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexFileLocation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexFileLocation.java
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *   Stefan Xenos (Google) - Initial implementation
- *******************************************************************************/ 
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd;
 
 import java.net.URI;
@@ -19,42 +19,42 @@ import java.net.URI;
 public class IndexFileLocation implements IIndexFileLocation {
 	private final URI uri;
 	private final String fullPath;
-	
+
 	public IndexFileLocation(URI uri, String fullPath) {
 		if (uri == null)
 			throw new IllegalArgumentException();
 		this.uri = uri;
 		this.fullPath = fullPath;
 	}
-	
+
 	@Override
 	public String getFullPath() {
-		return fullPath;
+		return this.fullPath;
 	}
-	
+
 	@Override
 	public URI getURI() {
-		return uri;
+		return this.uri;
 	}
-	
+
 	@Override
 	public boolean equals(Object obj) {
 		if (obj instanceof IIndexFileLocation) {
-			return uri.equals(((IIndexFileLocation) obj).getURI());
+			return this.uri.equals(((IIndexFileLocation) obj).getURI());
 		}
 		return false;
 	}
-	
+
 	@Override
 	public int hashCode() {
-		return uri.hashCode();
+		return this.uri.hashCode();
 	}
-	
+
 	@Override
 	public String toString() {
-		if (fullPath == null) {
-			return uri.toString();
+		if (this.fullPath == null) {
+			return this.uri.toString();
 		}
-		return fullPath.toString() + " (" + uri.toString() + ')'; //$NON-NLS-1$
+		return this.fullPath.toString() + " (" + this.uri.toString() + ')'; //$NON-NLS-1$
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index c84c798..f6df0d8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -69,7 +69,7 @@ public class Nd {
 		return "" + major + '.' + minor; //$NON-NLS-1$
 	}
 
-	public static final int LINKAGES = Database.DATA_AREA;
+	//public static final int LINKAGES = Database.DATA_AREA;
 	public static final int FILE_INDEX = Database.DATA_AREA + 4;
 	public static final int INDEX_OF_DEFECTIVE_FILES = Database.DATA_AREA + 8;
 	public static final int INDEX_OF_FILES_WITH_UNRESOLVED_INCLUDES = Database.DATA_AREA + 12;
@@ -87,38 +87,38 @@ public class Nd {
 		private boolean fReloaded;
 		private boolean fNewFiles;
 
-		private void setCleared() {
-			fCleared= true;
-			fReloaded= false;
-			fNewFiles= false;
-
-			fClearedFiles.clear();
-			fFilesWritten.clear();
-		}
+//		private void setCleared() {
+//			this.fCleared= true;
+//			this.fReloaded= false;
+//			this.fNewFiles= false;
+//
+//			this.fClearedFiles.clear();
+//			this.fFilesWritten.clear();
+//		}
 
 		public boolean isCleared() {
-			return fCleared;
+			return this.fCleared;
 		}
 
 		public void setReloaded() {
-			fReloaded= true;
+			this.fReloaded= true;
 		}
 
 		public boolean isReloaded() {
-			return fReloaded;
+			return this.fReloaded;
 		}
 
 		public void setHasNewFiles() {
-			fNewFiles = true;
+			this.fNewFiles = true;
 		}
 
 		public boolean hasNewFiles() {
-			return fNewFiles;
+			return this.fNewFiles;
 		}
 
 		public boolean isTrivial() {
-			return !fCleared && !fReloaded && !fNewFiles && fClearedFiles.isEmpty() &&
-					fFilesWritten.isEmpty();
+			return !this.fCleared && !this.fReloaded && !this.fNewFiles && this.fClearedFiles.isEmpty() &&
+					this.fFilesWritten.isEmpty();
 		}
 	}
 
@@ -154,7 +154,7 @@ public class Nd {
 		// a bug.
 		if (this.pendingDeletions.containsKey(addressOfNodeToDelete)) {
 			Package.log("PDOM object queued for deletion twice", new RuntimeException()); //$NON-NLS-1$
-			Package.log("Earlier deletion stack was this:", pendingDeletions.get(addressOfNodeToDelete));
+			Package.log("Earlier deletion stack was this:", this.pendingDeletions.get(addressOfNodeToDelete)); //$NON-NLS-1$
 			return;
 		}
 		this.pendingDeletions.put(addressOfNodeToDelete, new RuntimeException());
@@ -181,30 +181,26 @@ public class Nd {
 	}
 
 	private void loadDatabase(File dbPath, ChunkCache cache) throws IndexException {
-		fPath= dbPath;
-		final boolean lockDB= db == null || lockCount != 0;
+		this.fPath= dbPath;
+		final boolean lockDB= this.db == null || this.lockCount != 0;
 
 		clearCaches();
-		db = new Database(fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
+		this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
 
-		db.setLocked(lockDB);
+		this.db.setLocked(lockDB);
 		if (!isSupportedVersion()) {
-			Package.log("Index database is uses an unsupported version " + db.getVersion()
-				+ " Deleting and recreating.", null);
-			db.close();
-			fPath.delete();
-			db = new Database(fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
-			db.setLocked(lockDB);
+			Package.log("Index database is uses an unsupported version " + this.db.getVersion() //$NON-NLS-1$
+				+ " Deleting and recreating.", null); //$NON-NLS-1$
+			this.db.close();
+			this.fPath.delete();
+			this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
+			this.db.setLocked(lockDB);
 		}
-		db.setLocked(lockCount != 0);
+		this.db.setLocked(this.lockCount != 0);
 	}
 
 	public Database getDB() {
-		return db;
-	}
-
-	private long getFirstLinkageRecord() throws IndexException {
-		return db.getRecPtr(LINKAGES);
+		return this.db;
 	}
 
 	// Read-write lock rules. Readers don't conflict with other readers,
@@ -219,23 +215,23 @@ public class Nd {
 	public void acquireReadLock() {
 		try {
 			long t = sDEBUG_LOCKS ? System.nanoTime() : 0;
-			synchronized (mutex) {
-				++waitingReaders;
+			synchronized (this.mutex) {
+				++this.waitingReaders;
 				try {
-					while (lockCount < 0)
-						mutex.wait();
+					while (this.lockCount < 0)
+						this.mutex.wait();
 				} finally {
-					--waitingReaders;
+					--this.waitingReaders;
 				}
-				++lockCount;
-				db.setLocked(true);
+				++this.lockCount;
+				this.db.setLocked(true);
 
 				if (sDEBUG_LOCKS) {
 					t = (System.nanoTime() - t) / 1000000;
 					if (t >= LONG_READ_LOCK_WAIT_REPORT_THRESHOLD) {
 						System.out.println("Acquired index read lock after " + t + " ms wait."); //$NON-NLS-1$//$NON-NLS-2$
 					}
-					incReadLock(fLockDebugging);
+					incReadLock(this.fLockDebugging);
 				}
 			}
 		} catch (InterruptedException e) {
@@ -244,17 +240,17 @@ public class Nd {
 	}
 
 	public void releaseReadLock() {
-		synchronized (mutex) {
-			assert lockCount > 0: "No lock to release"; //$NON-NLS-1$
+		synchronized (this.mutex) {
+			assert this.lockCount > 0: "No lock to release"; //$NON-NLS-1$
 			if (sDEBUG_LOCKS) {
-				decReadLock(fLockDebugging);
+				decReadLock(this.fLockDebugging);
 			}
 
-			lastReadAccess= System.currentTimeMillis();
-			if (lockCount > 0)
-				--lockCount;
-			mutex.notifyAll();
-			db.setLocked(lockCount != 0);
+			this.lastReadAccess= System.currentTimeMillis();
+			if (this.lockCount > 0)
+				--this.lockCount;
+			this.mutex.notifyAll();
+			this.db.setLocked(this.lockCount != 0);
 		}
 		// A lock release probably means that some AST is going away. The result cache has to be
 		// cleared since it may contain objects belonging to the AST that is going away. A failure
@@ -267,7 +263,7 @@ public class Nd {
 
 	/**
 	 * Acquire a write lock on this PDOM. Blocks until any existing read/write locks are released.
-	 * @throws InterruptedException
+	 * @throws OperationCanceledException
 	 * @throws IllegalStateException if this PDOM is not writable
 	 */
 	public void acquireWriteLock(IProgressMonitor monitor) {
@@ -286,16 +282,16 @@ public class Nd {
 	 */
 	public void acquireWriteLock(int giveupReadLocks, IProgressMonitor monitor) throws InterruptedException {
 		assert !isPermanentlyReadOnly();
-		synchronized (mutex) {
+		synchronized (this.mutex) {
 			if (sDEBUG_LOCKS) {
 				incWriteLock(giveupReadLocks);
 			}
 
 			if (giveupReadLocks > 0) {
 				// give up on read locks
-				assert lockCount >= giveupReadLocks: "Not enough locks to release"; //$NON-NLS-1$
-				if (lockCount < giveupReadLocks) {
-					giveupReadLocks= lockCount;
+				assert this.lockCount >= giveupReadLocks: "Not enough locks to release"; //$NON-NLS-1$
+				if (this.lockCount < giveupReadLocks) {
+					giveupReadLocks= this.lockCount;
 				}
 			} else {
 				giveupReadLocks= 0;
@@ -303,8 +299,8 @@ public class Nd {
 
 			// Let the readers go first
 			long start= sDEBUG_LOCKS ? System.currentTimeMillis() : 0;
-			while (lockCount > giveupReadLocks || waitingReaders > 0) {
-				mutex.wait(CANCELLATION_CHECK_INTERVAL);
+			while (this.lockCount > giveupReadLocks || this.waitingReaders > 0) {
+				this.mutex.wait(CANCELLATION_CHECK_INTERVAL);
 				if (monitor != null && monitor.isCanceled()) {
 					throw new OperationCanceledException();
 				}
@@ -312,10 +308,10 @@ public class Nd {
 					start = reportBlockedWriteLock(start, giveupReadLocks);
 				}
 			}
-			lockCount= -1;
+			this.lockCount= -1;
 			if (sDEBUG_LOCKS)
-				timeWriteLockAcquired = System.currentTimeMillis();
-			db.setExclusiveLock();
+				this.timeWriteLockAcquired = System.currentTimeMillis();
+			this.db.setExclusiveLock();
 		}
 	}
 
@@ -335,24 +331,24 @@ public class Nd {
 		} catch (IndexException e) {
 			Package.log(e);
 		}
-		assert lockCount == -1;
-		if (!fEvent.isTrivial())
-			lastWriteAccess= System.currentTimeMillis();
-		final ChangeEvent event= fEvent;
-		fEvent= new ChangeEvent();
-		synchronized (mutex) {
+		assert this.lockCount == -1;
+		if (!this.fEvent.isTrivial())
+			this.lastWriteAccess= System.currentTimeMillis();
+		//final ChangeEvent event= this.fEvent;
+		this.fEvent= new ChangeEvent();
+		synchronized (this.mutex) {
 			if (sDEBUG_LOCKS) {
-				long timeHeld = lastWriteAccess - timeWriteLockAcquired;
+				long timeHeld = this.lastWriteAccess - this.timeWriteLockAcquired;
 				if (timeHeld >= LONG_WRITE_LOCK_REPORT_THRESHOLD) {
 					System.out.println("Index write lock held for " + timeHeld + " ms");
 				}
 				decWriteLock(establishReadLocks);
 			}
 
-			if (lockCount < 0)
-				lockCount= establishReadLocks;
-			mutex.notifyAll();
-			db.setLocked(lockCount != 0);
+			if (this.lockCount < 0)
+				this.lockCount= establishReadLocks;
+			this.mutex.notifyAll();
+			this.db.setLocked(this.lockCount != 0);
 		}
 		//fireChange(event);
 	}
@@ -430,14 +426,14 @@ public class Nd {
 		List<StackTraceElement[]> fTraces= new ArrayList<>();
 
 		public int addTrace() {
-			fTraces.add(Thread.currentThread().getStackTrace());
-			return fTraces.size();
+			this.fTraces.add(Thread.currentThread().getStackTrace());
+			return this.fTraces.size();
 		}
 
 		@SuppressWarnings("nls")
 		public void write(String threadName) {
-			System.out.println("Thread: '" + threadName + "': " + fReadLocks + " readlocks, " + fWriteLocks + " writelocks");
-			for (StackTraceElement[] trace : fTraces) {
+			System.out.println("Thread: '" + threadName + "': " + this.fReadLocks + " readlocks, " + this.fWriteLocks + " writelocks");
+			for (StackTraceElement[] trace : this.fTraces) {
 				System.out.println("  Stacktrace:");
 				for (StackTraceElement ste : trace) {
 					System.out.println("    " + ste);
@@ -446,9 +442,9 @@ public class Nd {
 		}
 
 		public void inc(DebugLockInfo val) {
-			fReadLocks+= val.fReadLocks;
-			fWriteLocks+= val.fWriteLocks;
-			fTraces.addAll(val.fTraces);
+			this.fReadLocks+= val.fReadLocks;
+			this.fWriteLocks+= val.fWriteLocks;
+			this.fTraces.addAll(val.fTraces);
 		}
 	}
 
@@ -499,9 +495,9 @@ public class Nd {
 	// For debugging lock issues
 	@SuppressWarnings("nls")
 	private void incWriteLock(int giveupReadLocks) throws AssertionError {
-		DebugLockInfo info = getLockInfo(fLockDebugging);
+		DebugLockInfo info = getLockInfo(this.fLockDebugging);
 		if (info.fReadLocks != giveupReadLocks) {
-			outputReadLocks(fLockDebugging);
+			outputReadLocks(this.fLockDebugging);
 			throw new AssertionError("write lock with " + giveupReadLocks + " readlocks, expected " + info.fReadLocks);
 		}
 		if (info.fWriteLocks != 0)
@@ -511,14 +507,14 @@ public class Nd {
 
 	// For debugging lock issues
 	private void decWriteLock(int establishReadLocks) throws AssertionError {
-		DebugLockInfo info = getLockInfo(fLockDebugging);
+		DebugLockInfo info = getLockInfo(this.fLockDebugging);
 		if (info.fReadLocks != establishReadLocks)
 			throw new AssertionError("release write lock with " + establishReadLocks + " readlocks, expected " + info.fReadLocks); //$NON-NLS-1$ //$NON-NLS-2$
 		if (info.fWriteLocks != 1)
 			throw new AssertionError("Wrong release write lock"); //$NON-NLS-1$
 		info.fWriteLocks= 0;
 		if (info.fReadLocks == 0) {
-			fLockDebugging.remove(Thread.currentThread());
+			this.fLockDebugging.remove(Thread.currentThread());
 		}
 	}
 
@@ -529,8 +525,8 @@ public class Nd {
 		if (now >= start + BLOCKED_WRITE_LOCK_OUTPUT_INTERVAL) {
 			System.out.println();
 			System.out.println("Blocked writeLock");
-			System.out.println("  lockcount= " + lockCount + ", giveupReadLocks=" + giveupReadLocks + ", waitingReaders=" + waitingReaders);
-			outputReadLocks(fLockDebugging);
+			System.out.println("  lockcount= " + this.lockCount + ", giveupReadLocks=" + giveupReadLocks + ", waitingReaders=" + this.waitingReaders);
+			outputReadLocks(this.fLockDebugging);
 			start= now;
 		}
 		return start;
@@ -552,24 +548,19 @@ public class Nd {
 		for (Thread th : lockDebugging.keySet()) {
 			DebugLockInfo val= lockDebugging.get(th);
 			if (val.fReadLocks > 0) {
-				DebugLockInfo myval= fLockDebugging.get(th);
+				DebugLockInfo myval= this.fLockDebugging.get(th);
 				if (myval == null) {
 					myval= new DebugLockInfo();
-					fLockDebugging.put(th, myval);
+					this.fLockDebugging.put(th, myval);
 				}
 				myval.inc(val);
 				for (int i = 0; i < val.fReadLocks; i++) {
-					decReadLock(fLockDebugging);
+					decReadLock(this.fLockDebugging);
 				}
 			}
 		}
 	}
 
-    /**
-     * @param address
-     * @param nodeType
-     * @return
-     */
     public NdNode getNode(long address, short nodeType) throws IndexException {
     	return this.fNodeTypeRegistry.createNode(this, address, nodeType);
     }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
index 0a13086..7580c69 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
@@ -17,7 +17,7 @@ import org.eclipse.jdt.internal.core.nd.db.IndexException;
  */
 public final class NdLinkedList<T> {
 	private final NdRawLinkedList rawList;
-	private final ITypeFactory<T> elementFactory;
+	final ITypeFactory<T> elementFactory;
 
 	public static interface ILinkedListVisitor<T> {
 		public void visit(T record, short metadataBits, int index) throws IndexException;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index 2aec482..b7f93e3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -182,6 +182,7 @@ public abstract class NdNode implements IDestructable {
 	 * method.
 	 */
 	public void destruct() {
+		// Nothing to do by default. Subclasses will provide an implementation if necessary.
 	}
 
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
index d073d49..9d5efc9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
@@ -190,8 +190,8 @@ public class NdRawLinkedList {
 		return blockRecordStart + ELEMENT_START_POSITION + elementNumber * this.elementRecordSize;
 	}
 
-	private long getAddressOfMetadata(long blockRecordStart, int recordCount) {
-		return getAddressOfElement(blockRecordStart, recordCount);
+	private long getAddressOfMetadata(long blockRecordStart, int blockRecordCount) {
+		return getAddressOfElement(blockRecordStart, blockRecordCount);
 	}
 
 	public void accept(ILinkedListVisitor visitor) throws IndexException {
@@ -250,11 +250,6 @@ public class NdRawLinkedList {
 		}
 	}
 
-	/**
-	 * @param blockAddress
-	 * @param pointerToNextBlock
-	 * @return
-	 */
 	private boolean isLastBlock(long blockAddress, long pointerToNextBlock) {
 		return pointerToNextBlock == 0 || pointerToNextBlock == blockAddress;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Package.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Package.java
index 79f6c0f..3422a1a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Package.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Package.java
@@ -14,22 +14,16 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.JavaCore;
 
-/**
- * @noreference This class is not intended to be referenced by clients
- */
 /* package */ class Package {
 	public static String PLUGIN_ID = JavaCore.PLUGIN_ID;
 
 	/**
 	 * Status code for core exception that is thrown if a pdom grew larger than the supported limit.
-	 * 
+	 *
 	 * @since 5.2
 	 */
 	public static final int STATUS_PDOM_TOO_LARGE = 4;
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(Throwable e) {
 		String msg = e.getMessage();
 		if (msg == null) {
@@ -39,44 +33,26 @@ import org.eclipse.jdt.core.JavaCore;
 		}
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(String message, Throwable e) {
 		log(createStatus(message, e));
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void logInfo(String message) {
 		log(createStatus(IStatus.INFO, message, null));
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(int statusCode, String msg, Throwable e) {
 		return new Status(statusCode, PLUGIN_ID, msg, e);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(String msg, Throwable e) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg, e);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(String msg) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(IStatus status) {
 		JavaCore.getPlugin().getLog().log(status);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/StreamHasher.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/StreamHasher.java
index b6acacb..9799e1d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/StreamHasher.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/StreamHasher.java
@@ -73,10 +73,10 @@ public final class StreamHasher {
 
 	public StreamHasher() {
 		// Set up the internal state.
-		hashedOffset = 0;
-		state = 0;
-		a = b = c = (int) SEED;
-		c += SEED >>> 32;
+		this.hashedOffset = 0;
+		this.state = 0;
+		this.a = this.b = this.c = (int) SEED;
+		this.c += SEED >>> 32;
 	}
 
 	/**
@@ -84,26 +84,26 @@ public final class StreamHasher {
 	 * @param chunk Contents of the chunk.
 	 */
 	public void addChunk(char[] chunk) {
-		for (int pos = 0; pos < chunk.length; pos++, hashedOffset++) {
+		for (int pos = 0; pos < chunk.length; pos++, this.hashedOffset++) {
 			char cc = chunk[pos];
-			switch (state++) {
+			switch (this.state++) {
 			case -1:
 				throw new IllegalStateException("addChunk is called after computeHash."); //$NON-NLS-1$
 			case 0:
 			case 2:
 			case 4:
-				previousCharacter = cc;
+				this.previousCharacter = cc;
 				break;
 			case 1:
-				a += previousCharacter | (cc << 16);
+				this.a += this.previousCharacter | (cc << 16);
 				break;
 			case 3:
-				b += previousCharacter | (cc << 16);
+				this.b += this.previousCharacter | (cc << 16);
 				break;
 			case 5:
-				c += previousCharacter | (cc << 16);
+				this.c += this.previousCharacter | (cc << 16);
 				mix();
-				state = 0;
+				this.state = 0;
 				break;
 			}
 		}
@@ -114,27 +114,27 @@ public final class StreamHasher {
 	 * @return The hash value of the character stream.
 	 */
 	public long computeHash() {
-		if (state < 0) {
+		if (this.state < 0) {
 			throw new IllegalStateException("computeHash method is called more than once."); //$NON-NLS-1$
 		}
 		return computeHashInternal() ^ EMPTY_STRING_HASH;
 	}
 
 	private long computeHashInternal() {
-		switch (state) {
+		switch (this.state) {
 		case 1:
-			a += previousCharacter;
+			this.a += this.previousCharacter;
 			break;
 		case 3:
-			b += previousCharacter;
+			this.b += this.previousCharacter;
 			break;
 		case 5:
-			c += previousCharacter;
+			this.c += this.previousCharacter;
 			break;
 		}
-		state = -1;  // Protect against subsequent calls.
+		this.state = -1;  // Protect against subsequent calls.
 		finalMix();
-		return (c & 0xFFFFFFFFL) | ((long) b << 32);
+		return (this.c & 0xFFFFFFFFL) | ((long) this.b << 32);
 	}
 
 	/**
@@ -193,12 +193,12 @@ public final class StreamHasher {
 	 * rotates.
 	 */
 	private void mix() {
-		a -= c;  a ^= Integer.rotateLeft(c, 4);  c += b;
-		b -= a;  b ^= Integer.rotateLeft(a, 6);  a += c;
-		c -= b;  c ^= Integer.rotateLeft(b, 8);  b += a;
-		a -= c;  a ^= Integer.rotateLeft(c, 16); c += b;
-		b -= a;  b ^= Integer.rotateLeft(a, 19); a += c;
-		c -= b;  c ^= Integer.rotateLeft(b, 4);  b += a;
+		this.a -= this.c;  this.a ^= Integer.rotateLeft(this.c, 4);  this.c += this.b;
+		this.b -= this.a;  this.b ^= Integer.rotateLeft(this.a, 6);  this.a += this.c;
+		this.c -= this.b;  this.c ^= Integer.rotateLeft(this.b, 8);  this.b += this.a;
+		this.a -= this.c;  this.a ^= Integer.rotateLeft(this.c, 16); this.c += this.b;
+		this.b -= this.a;  this.b ^= Integer.rotateLeft(this.a, 19); this.a += this.c;
+		this.c -= this.b;  this.c ^= Integer.rotateLeft(this.b, 4);  this.b += this.a;
 	}
 
 	/**
@@ -225,12 +225,12 @@ public final class StreamHasher {
 	 *  11  8 15 26 3 22 24
 	 */
 	private void finalMix() {
-		c ^= b; c -= Integer.rotateLeft(b, 14);
-		a ^= c; a -= Integer.rotateLeft(c, 11);
-		b ^= a; b -= Integer.rotateLeft(a, 25);
-		c ^= b; c -= Integer.rotateLeft(b, 16);
-		a ^= c; a -= Integer.rotateLeft(c, 4);
-		b ^= a; b -= Integer.rotateLeft(a, 14);
-		c ^= b; c -= Integer.rotateLeft(b, 24);
+		this.c ^= this.b; this.c -= Integer.rotateLeft(this.b, 14);
+		this.a ^= this.c; this.a -= Integer.rotateLeft(this.c, 11);
+		this.b ^= this.a; this.b -= Integer.rotateLeft(this.a, 25);
+		this.c ^= this.b; this.c -= Integer.rotateLeft(this.b, 16);
+		this.a ^= this.c; this.a -= Integer.rotateLeft(this.c, 4);
+		this.b ^= this.a; this.b -= Integer.rotateLeft(this.a, 14);
+		this.c ^= this.b; this.c -= Integer.rotateLeft(this.b, 24);
 	}
 }
commit fb4a187a4d1bd371f94e1de8216c5a74add70cc5
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 10:49:50 2016 -0800

    Bug 481796 - Fix warnings in org.eclipse.jdt.internal.core.nd.indexer
    
    Change-Id: If6e22c9d0b66a1625f7d3ddf0fb8d8b7251ccb66
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

0	45	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/CharUtil.java
37	42	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
21	22	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
0	132	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexVisitor.java
24	43	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
15	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Messages.java
1	19	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Package.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/messages.properties
13	11	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
83	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/CharUtil.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/CharUtil.java
deleted file mode 100644
index be2043f..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/CharUtil.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.eclipse.jdt.internal.core.nd.indexer;
-
-/**
- */
-public class CharUtil {
-
-	public static final char[] EMPTY_CHAR_ARRAY = new char[0];
-
-	/**
-	 * Answers a new array which is the concatenation of all the given arrays.
-	 *
-	 * @param toCatenate
-	 * @return
-	 * @since 3.12
-	 */
-	public static char[] concat(char[]... toCatenate) {
-		int totalSize = 0;
-		for (char[] next: toCatenate) {
-			totalSize += next.length;
-		}
-
-		char[] result = new char[totalSize];
-		int writeIndex = 0;
-		for (char[] next: toCatenate) {
-			System.arraycopy(next, 0, result, writeIndex, next.length);
-			writeIndex += next.length;
-		}
-		return result;
-	}
-
-	public static boolean startsWith(char[] fieldDescriptor, char c) {
-		return fieldDescriptor.length > 0 && fieldDescriptor[0] == c;
-	}
-
-	public static char[] substring(char[] inputString, int index) {
-		if (inputString.length <= index) {
-			return EMPTY_CHAR_ARRAY;
-		}
-
-		char[] result = new char[inputString.length - index];
-		System.arraycopy(inputString, index, result, 0, result.length);
-		return result;
-	}
-
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index a4688ff..4516218 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -47,6 +47,7 @@ import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
 import org.eclipse.jdt.internal.core.nd.java.NdVariable;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class ClassFileToIndexConverter {
@@ -130,7 +131,8 @@ public class ClassFileToIndexConverter {
 		}
 
 		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
-		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short)-1, binaryType.getSuperclassName());
+		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short) -1,
+				binaryType.getSuperclassName());
 
 		type.setTypeId(name);
 
@@ -154,9 +156,8 @@ public class ClassFileToIndexConverter {
 			// this characteristic. In such cases, we take what's in the generic signature and discard what's in the
 			// interfaces list.
 			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
-			new NdTypeInterface(getPDOM(), type, createTypeSignature(
-					typeAnnotations.toSupertype(interfaceIdx, interfaceSpec),
-					signatureWrapper));
+			new NdTypeInterface(getPDOM(), type,
+					createTypeSignature(typeAnnotations.toSupertype(interfaceIdx, interfaceSpec), signatureWrapper));
 			interfaceIdx++;
 		}
 
@@ -194,6 +195,7 @@ public class ClassFileToIndexConverter {
 
 	/**
 	 * Adds the given method to the given type
+	 *
 	 * @throws CoreException
 	 */
 	private void addMethod(NdType type, IBinaryMethod next, char[] binaryTypeName) throws CoreException {
@@ -217,8 +219,7 @@ public class ClassFileToIndexConverter {
 				break;
 			}
 			NdMethodParameter parameter = new NdMethodParameter(method,
-					createTypeSignature(typeAnnotations.toMethodParameter(parameterIdx),
-					signature));
+					createTypeSignature(typeAnnotations.toMethodParameter(parameterIdx), signature));
 
 			if (parameterNames != null && parameterNames.length > parameterIdx) {
 				parameter.setName(parameterNames[parameterIdx]);
@@ -231,8 +232,7 @@ public class ClassFileToIndexConverter {
 		int throwsIdx = 0;
 		while (!signature.atEnd() && signature.charAtStart() == '^') {
 			signature.start++;
-			new NdMethodException(method,
-					createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature));
+			new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature));
 			throwsIdx++;
 		}
 
@@ -241,8 +241,7 @@ public class ClassFileToIndexConverter {
 			method.setDefaultValue(createConstantFromMixedType(defaultValue));
 		}
 
-		method.setMethodId(
-				createMethodId(binaryTypeName, next.getSelector(), next.getMethodDescriptor()));
+		method.setMethodId(createMethodId(binaryTypeName, next.getSelector(), next.getMethodDescriptor()));
 
 		method.setModifiers(next.getModifiers());
 	}
@@ -271,8 +270,9 @@ public class ClassFileToIndexConverter {
 	}
 
 	/**
-	 * Reads and attaches any generic type parameters at the current start position in the given wrapper.
-	 * Sets wrapper.start to the character following the type parameters.
+	 * Reads and attaches any generic type parameters at the current start position in the given wrapper. Sets
+	 * wrapper.start to the character following the type parameters.
+	 *
 	 * @throws CoreException
 	 */
 	private void readTypeParameters(NdBinding type, ITypeAnnotationWalker annotationWalker, SignatureWrapper wrapper)
@@ -305,8 +305,7 @@ public class ClassFileToIndexConverter {
 			}
 
 			NdTypeSignature boundSignature = createTypeSignature(
-					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short)boundIndex),
-					wrapper);
+					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short) boundIndex), wrapper);
 
 			new NdTypeBound(parameter, boundSignature);
 			boundIndex++;
@@ -319,16 +318,17 @@ public class ClassFileToIndexConverter {
 
 	/**
 	 * Reads a type signature from the given {@link SignatureWrapper}, starting at the character pointed to by
-	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature.
-	 * Returns null if given an empty signature or the signature for the void type.
+	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature. Returns
+	 * null if given an empty signature or the signature for the void type.
 	 *
-	 * @param supertypeAnnotations
-	 * @param superclassName
-	 * @param genericSignature
-	 * @return
+	 * @param annotations
+	 *            the type annotations for this type
+	 * @param wrapper
+	 *            the generic signature to parse
 	 * @throws CoreException
 	 */
-	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
+	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper wrapper)
+			throws CoreException {
 		char[] genericSignature = wrapper.signature;
 
 		if (genericSignature == null || genericSignature.length == 0) {
@@ -353,14 +353,15 @@ public class ClassFileToIndexConverter {
 				// We encode arrays as though they were a one-argument generic type called '[' whose element
 				// type is the generic argument.
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getPDOM());
-				typeSignature.setRawType(createTypeIdFromFieldDescriptor(new char[] {'['}));
+				typeSignature.setRawType(createTypeIdFromFieldDescriptor(new char[] { '[' }));
 				NdTypeArgument typeArgument = new NdTypeArgument(getPDOM(), typeSignature);
 				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
 				typeArgument.setType(elementType);
 				attachAnnotations(typeSignature, annotations);
 				return typeSignature;
 			}
-			case 'V': return null;
+			case 'V':
+				return null;
 			case 'B':
 			case 'C':
 			case 'D':
@@ -370,7 +371,7 @@ public class ClassFileToIndexConverter {
 			case 'S':
 			case 'Z':
 				wrapper.start++;
-				return createTypeIdFromFieldDescriptor(new char[]{firstChar});
+				return createTypeIdFromFieldDescriptor(new char[] { firstChar });
 			case 'L':
 				return parseClassTypeSignature(null, annotations, wrapper);
 			case '+':
@@ -385,16 +386,9 @@ public class ClassFileToIndexConverter {
 	}
 
 	/**
-	 * Parses a ClassTypeSignature (as described in section 4.7.9.1 of the Java VM Specification Java SE 8 Edition).
-	 * The read pointer should be located just after the identifier. The caller is expected to have already read
-	 * the field descriptor for the type.
-	 *
-	 * @param annotations
-	 * @param wrapper
-	 * @param genericSignature
-	 * @param fieldDescriptor
-	 * @return
-	 * @throws CoreException
+	 * Parses a ClassTypeSignature (as described in section 4.7.9.1 of the Java VM Specification Java SE 8 Edition). The
+	 * read pointer should be located just after the identifier. The caller is expected to have already read the field
+	 * descriptor for the type.
 	 */
 	private NdTypeSignature parseClassTypeSignature(NdComplexTypeSignature parentTypeOrNull,
 			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
@@ -402,15 +396,15 @@ public class ClassFileToIndexConverter {
 		char[] fieldDescriptor;
 
 		if (parentTypeOrNull != null) {
-			fieldDescriptor = CharUtil.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
-					new char[] {'$'},
-					identifier);
+			fieldDescriptor = CharArrayUtils.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
+					new char[] { '$' }, identifier);
 		} else {
 			fieldDescriptor = identifier;
 		}
 
 		char[] genericSignature = wrapper.signature;
-		boolean hasGenericArguments = (genericSignature.length > wrapper.start) && genericSignature[wrapper.start] == '<';
+		boolean hasGenericArguments = (genericSignature.length > wrapper.start)
+				&& genericSignature[wrapper.start] == '<';
 		boolean isRawTypeWithNestedClass = genericSignature[wrapper.start] == '.';
 		NdTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
 		NdTypeSignature result = rawType;
@@ -431,7 +425,7 @@ public class ClassFileToIndexConverter {
 				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
 					NdTypeArgument typeArgument = new NdTypeArgument(getPDOM(), typeSignature);
 
-					switch(genericSignature[wrapper.start]) {
+					switch (genericSignature[wrapper.start]) {
 						case '+': {
 							typeArgument.setWildcard(NdTypeArgument.WILDCARD_SUPER);
 							wrapper.start++;
@@ -450,7 +444,8 @@ public class ClassFileToIndexConverter {
 						}
 					}
 
-					NdTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex), wrapper);
+					NdTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex),
+							wrapper);
 					typeArgument.setType(nextSignature);
 					argumentIndex++;
 				}
@@ -486,7 +481,7 @@ public class ClassFileToIndexConverter {
 	private void attachAnnotations(NdComplexTypeSignature typeSignature, ITypeAnnotationWalker annotations) {
 		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
 
-		for (IBinaryAnnotation next: annotationList) {
+		for (IBinaryAnnotation next : annotationList) {
 			NdAnnotation annotation = createAnnotation(next);
 
 			annotation.setParent(typeSignature);
@@ -563,7 +558,7 @@ public class ClassFileToIndexConverter {
 	/**
 	 *
 	 * @param value
-	 *            accepts all values returned from {@link {@link IBinaryElementValuePair#getValue()}
+	 *            accepts all values returned from {@link IBinaryElementValuePair#getValue()}
 	 */
 	public NdConstant createConstantFromMixedType(Object value) {
 		if (value instanceof Constant) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
index 2b0c0f5..3ffc874 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
@@ -4,6 +4,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
@@ -62,7 +63,7 @@ public class GenericSignatures {
 				toCatenate[catIndex + 2] = suffix;
 			}
 
-			genericSignature = CharUtil.concat(toCatenate);
+			genericSignature = CharArrayUtils.concat(toCatenate);
 		}
 
 		SignatureWrapper signatureWrapper = new SignatureWrapper(genericSignature);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
index c38b43a..1e82faf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
@@ -13,7 +13,7 @@ package org.eclipse.jdt.internal.core.nd.indexer;
 import org.eclipse.jdt.core.dom.*;
 
 /**
- * 
+ *
  * <p>
  * This class provides a convenient behaviour-only extension mechanism for the ASTNode hierarchy. If
  * you feel like you would like to add a method to the ASTNode hierarchy (or a subtree of the
@@ -24,11 +24,11 @@ import org.eclipse.jdt.core.dom.*;
  * in visit(Foo). This class will provide appropriate dispatch, just as if the method
  * implementations had been added to the ASTNode hierarchy.
  * </p>
- * 
+ *
  * <p>
  * <b>Details:<b>
  * </p>
- * 
+ *
  * <p>
  * This class has a visit(XX node) method for every class (concrete or abstract) XX in the ASTNode
  * hierarchy. In this class' default implementations of these methods, the method corresponding to a
@@ -36,7 +36,7 @@ import org.eclipse.jdt.core.dom.*;
  * for it's superclass YY, with the exception of the visit(ASTNode) method which simply returns
  * true, since ASTNode doesn't have a superclass that is within the ASTNode hierarchy.
  * </p>
- * 
+ *
  * <p>
  * Because of this organization, when visit(XX) methods are overridden in a subclass, and the
  * visitor is applied to a node, only the most specialized overridden method implementation for the
@@ -45,15 +45,14 @@ import org.eclipse.jdt.core.dom.*;
  * must be XX) which will invoke this class' implementation of the method, which will, in turn,
  * invoke the visit(YY) method corresponding to the superclass, YY.
  * </p>
- * 
+ *
  * <p>
  * Thus, the dispatching behaviour achieved when HierarchicalASTVisitors' visit(XX) methods,
  * corresponding to a particular concrete or abstract ASTNode descendant class, are overridden is
  * exactly analogous to the dispatching behaviour obtained when method implementations are added to
  * the same ASTNode descendant classes.
  * </p>
- * 
- * @see JDTUIHelperClasses
+ *
  */
 /*
  * IMPORTANT NOTE:
@@ -73,7 +72,7 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	 * <p>
 	 * The default implementation does nothing and return true. Subclasses may reimplement.
 	 * </p>
-	 * 
+	 *
 	 * @param node the node to visit
 	 * @return <code>true</code> if the children of this node should be visited, and
 	 *         <code>false</code> if the children of this node should be skipped
@@ -87,7 +86,7 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	 * <p>
 	 * The default implementation does nothing. Subclasses may reimplement.
 	 * </p>
-	 * 
+	 *
 	 * @param node the node to visit
 	 */
 	public void endVisit(ASTNode node) {
@@ -271,12 +270,12 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(Dimension node) {
 		return visit((ASTNode)node);
 	}
-	
+
 	@Override
 	public void endVisit(Dimension node) {
 		endVisit((ASTNode)node);
 	}
-	
+
 //---- Begin Expression Hierarchy ----------------------------------
 	public boolean visit(Expression node) {
 		return visit((ASTNode)node);
@@ -451,12 +450,12 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(LambdaExpression node) {
 		return visit((Expression)node);
 	}
-	
+
 	@Override
 	public void endVisit(LambdaExpression node) {
 		endVisit((Expression)node);
 	}
-	
+
 	@Override
 	public boolean visit(MethodInvocation node) {
 		return visit((Expression)node);
@@ -471,7 +470,7 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(MethodReference node) {
 		return visit((Expression)node);
 	}
-	
+
 	public void endVisit(MethodReference node) {
 		endVisit((Expression)node);
 	}
@@ -490,32 +489,32 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(ExpressionMethodReference node) {
 		return visit((MethodReference)node);
 	}
-	
+
 	@Override
 	public void endVisit(ExpressionMethodReference node) {
 		endVisit((MethodReference)node);
 	}
-	
+
 	@Override
 	public boolean visit(SuperMethodReference node) {
 		return visit((MethodReference)node);
 	}
-	
+
 	@Override
 	public void endVisit(SuperMethodReference node) {
 		endVisit((MethodReference)node);
 	}
-	
+
 	@Override
 	public boolean visit(TypeMethodReference node) {
 		return visit((MethodReference)node);
 	}
-	
+
 	@Override
 	public void endVisit(TypeMethodReference node) {
 		endVisit((MethodReference)node);
 	}
-	
+
 	//---- End MethodReference Hierarchy ------------------------------------
 
 	//---- Begin Name Hierarchy ----------------------------------
@@ -997,7 +996,7 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(AnnotatableType node) {
 		return visit((Type)node);
 	}
-	
+
 	public void endVisit(AnnotatableType node) {
 		endVisit((Type)node);
 	}
@@ -1067,7 +1066,7 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 	public boolean visit(IntersectionType node) {
 		return visit((Type)node);
 	}
-	
+
 	@Override
 	public void endVisit(IntersectionType node) {
 		endVisit((Type)node);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexVisitor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexVisitor.java
deleted file mode 100644
index c3feda0..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexVisitor.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package org.eclipse.jdt.internal.core.nd.indexer;
-
-import java.util.Stack;
-
-import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
-import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
-import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
-import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.internal.core.nd.Nd;
-import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
-import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
-import org.eclipse.jdt.internal.core.nd.java.NdTreeNode;
-
-final class IndexVisitor extends HierarchicalASTVisitor {
-	private IJavaElement currentElement;
-	private NdResourceFile file;
-	private JavaIndex javaIndex;
-	private Stack<NdTreeNode> nodeStack;
-	private Nd pdom;
-	private String packageName = "";
-	private BindingToIndexConverter converter;
-
-	public IndexVisitor(IJavaElement currentElement, NdResourceFile file) {
-		super();
-		this.currentElement = currentElement;
-		this.file = file;
-		this.nodeStack = new Stack<>();
-		this.nodeStack.push(file);
-		this.pdom = file.getPDOM();
-		this.javaIndex = JavaIndex.getIndex(this.pdom);
-		this.converter = new BindingToIndexConverter(file);
-	}
-
-	@Override
-	public boolean visit(PackageDeclaration node) {
-		this.packageName = node.getName().getFullyQualifiedName();
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(AbstractTypeDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(TypeDeclaration node) {
-//		ITypeBinding typeBinding = node.resolveBinding();
-//
-//		if (typeBinding != null) {
-//			this.converter.addType(typeBinding, null);
-//		}
-//		typeBinding.get
-//		
-//		PDOMType newType = new PDOMType(this.pdom, this.nodeStack.lastElement());
-//		newType.setFile(this.file);
-//
-//		PDOMNamedNode parentName = createParentNamedNode();
-//		if (parentName != null) {
-//			SimpleName name = node.getName();
-//			String fqName = name.getFullyQualifiedName();
-//			PDOMTypeId typeId = this.javaIndex.createTypeId(createParentNamedNode(), fqName.toCharArray());
-//			newType.setTypeId(typeId);
-//		}
-//
-//		ITypeBinding typeBinding = node.resolveBinding();
-//		ITypeBinding superclass = typeBinding.getSuperclass();
-//
-//		
-//		Type superclass = node.getSuperclassType();
-//
-//		if (superclass != null) {
-//			if (superclass.isNameQualifiedType()) {
-//				NameQualifiedType named = (NameQualifiedType)superclass;
-//				SimpleName name = named.getName();
-//	
-//				String fqName = name.getFullyQualifiedName();
-//				String identifier = name.getIdentifier();
-//	
-//				identifier = identifier;
-//			}
-//		}
-
-		return true;
-	}
-	
-	@Override
-	public void endVisit(AbstractTypeDeclaration node) {
-		super.endVisit(node);
-	}
-
-	@Override
-	public boolean visit(MethodDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(AnnotationTypeMemberDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(AnonymousClassDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(EnumConstantDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(EnumDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(FieldDeclaration node) {
-		return super.visit(node);
-	}
-
-	@Override
-	public boolean visit(SingleVariableDeclaration node) {
-		return super.visit(node);
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 5f872ad..9bd5f67 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -26,7 +26,6 @@ import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.core.runtime.jobs.Job;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.IClasspathEntry;
-import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
@@ -38,19 +37,19 @@ import org.eclipse.jdt.core.dom.ASTParser;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.java.FileFingerprint;
+import org.eclipse.jdt.internal.core.nd.java.FileFingerprint.FingerprintTestResult;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
-import org.eclipse.jdt.internal.core.nd.java.FileFingerprint.FingerprintTestResult;
 
 public final class Indexer {
 	private Nd pdom;
 	private IWorkspaceRoot root;
-	
+
 	private static Indexer indexer;
 	private static final Object mutex = new Object();
 	private static final long MS_TO_NS = 1000000;
 
-	private Job rescanJob = Job.create("Updating index", new ICoreRunnable() {
+	private Job rescanJob = Job.create(Messages.Indexer_updating_index_job_name, new ICoreRunnable() {
 		@Override
 		public void run(IProgressMonitor monitor) throws CoreException {
 			rescan(monitor);
@@ -70,7 +69,7 @@ public final class Indexer {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 
 		long startTimeNs = System.nanoTime();
-		Package.logInfo("Indexer running rescan");
+		Package.logInfo("Indexer running rescan"); //$NON-NLS-1$
 
 		// Gather all the IPackageFragmentRoots in the workspace
 		List<IJavaElement> allRoots = getAllIndexableObjectsInWorkspace(subMonitor.split(3));
@@ -80,17 +79,17 @@ public final class Indexer {
 		allRoots = removeDuplicatePaths(allRoots);
 
 		long startGarbageCollectionNs = System.nanoTime();
-		
+
 		// Remove all files in the index which aren't referenced in the workspace
 		cleanGarbage(allRoots, subMonitor.split(4));
 
 		long startFingerprintTestNs = System.nanoTime();
-		
+
 		Map<IJavaElement, FingerprintTestResult> fingerprints = testFingerprints(allRoots, subMonitor.split(7));
 		List<IJavaElement> rootsWithChanges = getRootsThatHaveChanged(allRoots, fingerprints);
 
 		long startIndexingNs = System.nanoTime();
-		
+
 		int classesIndexed = 0;
 		SubMonitor loopMonitor = subMonitor.split(85).setWorkRemaining(rootsWithChanges.size());
 		for (IJavaElement next : rootsWithChanges) {
@@ -98,19 +97,19 @@ public final class Indexer {
 		}
 
 		long endIndexingNs = System.nanoTime();
-		
+
 		long fingerprintTimeMs = (startIndexingNs - startFingerprintTestNs) / MS_TO_NS;
 		long locateRootsTimeMs = (startGarbageCollectionNs - startTimeNs) / MS_TO_NS;
 		long indexingTimeMs = (endIndexingNs - startIndexingNs) / MS_TO_NS;
 
 		double averageIndexTimeMs = classesIndexed == 0 ? 0 : (double)indexingTimeMs / (double)classesIndexed;
-		double averageFingerprintTimeMs = allRoots.size() == 0 ? 0 : (double)fingerprintTimeMs / (double)allRoots.size(); 
+		double averageFingerprintTimeMs = allRoots.size() == 0 ? 0 : (double)fingerprintTimeMs / (double)allRoots.size();
 
 		Package.logInfo(
-				"Indexing done.\n"
-				+ "  Located " + totalRoots + " roots in " + locateRootsTimeMs + "ms\n"
-				+ "  Tested " + allRoots.size() + " fingerprints in " + fingerprintTimeMs + "ms, average time = " + averageFingerprintTimeMs + "ms\n"
-				+ "  Indexed " + classesIndexed + " classes in " + indexingTimeMs + "ms, average time = " + averageIndexTimeMs + "ms\n");
+				"Indexing done.\n" //$NON-NLS-1$
+				+ "  Located " + totalRoots + " roots in " + locateRootsTimeMs + "ms\n" //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+				+ "  Tested " + allRoots.size() + " fingerprints in " + fingerprintTimeMs + "ms, average time = " + averageFingerprintTimeMs + "ms\n" //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				+ "  Indexed " + classesIndexed + " classes in " + indexingTimeMs + "ms, average time = " + averageIndexTimeMs + "ms\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
 	}
 
 	private void cleanGarbage(List<IJavaElement> allRoots, IProgressMonitor monitor) {
@@ -156,11 +155,6 @@ public final class Indexer {
 
 	/**
 	 * Rescans an archive (a jar, zip, or class file on the filesystem). Returns the number of classes indexed.
-	 * 
-	 * @param element
-	 * @param fingerprint
-	 * @param monitor
-	 * @return
 	 * @throws JavaModelException
 	 */
 	private int rescanArchive(IJavaElement element, FileFingerprint fingerprint, IProgressMonitor monitor)
@@ -173,7 +167,7 @@ public final class Indexer {
 
 		File theFile = thePath.toFile();
 		if (!(theFile.exists() && theFile.isFile())) {
-			Package.log("the file " + pathString + " does not exist", null);
+			Package.log("the file " + pathString + " does not exist", null); //$NON-NLS-1$ //$NON-NLS-2$
 			return 0;
 		}
 
@@ -187,7 +181,7 @@ public final class Indexer {
 			this.pdom.releaseWriteLock();
 		}
 
-		Package.logInfo("rescanning " + thePath.toString());
+		Package.logInfo("rescanning " + thePath.toString()); //$NON-NLS-1$
 		int result = addElement(resourceFile, element, subMonitor.newChild(90));
 
 		// Now update the timestamp and delete all older versions of this resource that exist in the index
@@ -196,7 +190,7 @@ public final class Indexer {
 			if (resourceFile.isInIndex()) {
 				resourceFile.setFingerprint(fingerprint);
 				List<NdResourceFile> resourceFiles = javaIndex.getAllResourceFiles(pathString);
-	
+
 				for (NdResourceFile next : resourceFiles) {
 					if (!next.equals(resourceFile)) {
 						next.delete();
@@ -212,7 +206,7 @@ public final class Indexer {
 
 	/**
 	 * Returns the set of IClassFile and ICompilationUnits contained within the given IJavaElement
-	 * 
+	 *
 	 * @throws JavaModelException
 	 */
 	private List<IJavaElement> getBindableElements(IJavaElement input, IProgressMonitor monitor)
@@ -244,7 +238,7 @@ public final class Indexer {
 
 	/**
 	 * Adds an archive to the index, under the given PDOMResourceFile.
-	 * 
+	 *
 	 * @param resourceFile
 	 * @param element
 	 * @param monitor
@@ -299,17 +293,6 @@ public final class Indexer {
 		return result;
 	}
 
-	private List<ICompilationUnit> getCompilationUnits(List<IJavaElement> bindableElements) {
-		List<ICompilationUnit> result = new ArrayList<>();
-
-		for (IJavaElement next : bindableElements) {
-			if (next.getElementType() == IJavaElement.COMPILATION_UNIT) {
-				result.add((ICompilationUnit)next);
-			}
-		}
-		return result;
-	}
-
 	private List<IJavaElement> getAllIndexableObjectsInWorkspace(IProgressMonitor monitor) throws CoreException {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 2);
 		List<IJavaElement> allRoots = new ArrayList<>();
@@ -324,7 +307,7 @@ public final class Indexer {
 		}
 
 		Set<IPath> scannedPaths = new HashSet<>();
-		Set<IResource> resourcesToScan = new HashSet<>(); 
+		Set<IResource> resourcesToScan = new HashSet<>();
 		SubMonitor projectLoopMonitor = subMonitor.split(1).setWorkRemaining(projectsToScan.size());
 		for (IProject project : projectsToScan) {
 			SubMonitor iterationMonitor = projectLoopMonitor.split(1);
@@ -384,8 +367,6 @@ public final class Indexer {
 			IProgressMonitor monitor) {
 		SubMonitor subMonitor = SubMonitor.convert(monitor);
 
-		JavaCore javaCore = JavaCore.getJavaCore();
-
 		ArrayDeque<IResource> resources = new ArrayDeque<>();
 		resources.addAll(toScan);
 
@@ -408,14 +389,14 @@ public final class Indexer {
 				IFile file = (IFile) next;
 
 				String extension = file.getFileExtension();
-				if (Objects.equals(extension, "class")) {
-					IJavaElement element = javaCore.create(file);
+				if (Objects.equals(extension, "class")) { //$NON-NLS-1$
+					IJavaElement element = JavaCore.create(file);
 
 					if (element instanceof IClassFile) {
 						result.add((IClassFile)element);
 					}
 				}
-			} 
+			}
 		}
 	}
 
@@ -434,7 +415,7 @@ public final class Indexer {
 					result.add((IClassFile)child);
 				} else if (child instanceof IParent) {
 					IParent parent = (IParent) child;
-	
+
 					collectAllClassFiles(result, parent);
 				}
 			} catch (CoreException e) {
@@ -489,7 +470,7 @@ public final class Indexer {
 		IResource resource = next.getResource();
 
 		if (resource != null) {
-			return resource.getLocation() == null ? new Path("") : resource.getLocation();
+			return resource.getLocation() == null ? new Path("") : resource.getLocation(); //$NON-NLS-1$
 		}
 
 		return next.getPath();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Messages.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Messages.java
new file mode 100644
index 0000000..ba33818
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Messages.java
@@ -0,0 +1,15 @@
+package org.eclipse.jdt.internal.core.nd.indexer;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	private static final String BUNDLE_NAME = "org.eclipse.jdt.internal.core.nd.indexer.messages"; //$NON-NLS-1$
+	public static String Indexer_updating_index_job_name;
+	static {
+		// initialize resource bundle
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Package.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Package.java
index 48e7e9b..1640ff8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Package.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Package.java
@@ -14,22 +14,16 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.JavaCore;
 
-/**
- * @noreference This class is not intended to be referenced by clients
- */
 /* package */ class Package {
 	public static String PLUGIN_ID = JavaCore.PLUGIN_ID;
 
 	/**
 	 * Status code for core exception that is thrown if a pdom grew larger than the supported limit.
-	 * 
+	 *
 	 * @since 5.2
 	 */
 	public static final int STATUS_PDOM_TOO_LARGE = 4;
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(Throwable e) {
 		String msg = e.getMessage();
 		if (msg == null) {
@@ -39,23 +33,14 @@ import org.eclipse.jdt.core.JavaCore;
 		}
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(String message, Throwable e) {
 		log(createStatus(message, e));
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(String msg, Throwable e) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg, e);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(String msg) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg);
 	}
@@ -64,9 +49,6 @@ import org.eclipse.jdt.core.JavaCore;
 		log(new Status(IStatus.INFO, PLUGIN_ID, message));
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(IStatus status) {
 		JavaCore.getPlugin().getLog().log(status);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/messages.properties b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/messages.properties
new file mode 100644
index 0000000..f835143
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/messages.properties
@@ -0,0 +1 @@
+Indexer_updating_index_job_name=Updating index
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 504a31f..d47362a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -3,7 +3,7 @@ package org.eclipse.jdt.internal.core.nd.java;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.core.nd.indexer.CharUtil;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
@@ -23,7 +23,7 @@ public class JavaNames {
 				Math.max(CharOperation.lastIndexOf('$', binaryName), CharOperation.lastIndexOf('.', binaryName)),
 				CharOperation.lastIndexOf('/', binaryName)) + 1;
 
-		return CharUtil.substring(binaryName, skipIndex);
+		return CharArrayUtils.substring(binaryName, skipIndex);
 	}
 
 	/**
@@ -44,7 +44,7 @@ public class JavaNames {
 	}
 
 	public static char[] fullyQualifiedNameToFieldDescriptor(char[] fullyQualifiedName) {
-		char[] result = CharUtil.concat(FIELD_DESCRIPTOR_PREFIX, fullyQualifiedName);
+		char[] result = CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, fullyQualifiedName);
 		CharOperation.replace(result, '.', '/');
 		return result;
 	}
@@ -58,11 +58,11 @@ public class JavaNames {
 		char[] filename = resourceFile.getFilename().getChars();
 		char[] binaryName = type.getTypeId().getBinaryName();
 
-		return CharUtil.concat(filename, JAR_FILE_ENTRY_SEPARATOR, binaryNameToResourceRelativePath(binaryName));
+		return CharArrayUtils.concat(filename, JAR_FILE_ENTRY_SEPARATOR, binaryNameToResourceRelativePath(binaryName));
 	}
 
 	public static char[] binaryNameToFieldDescriptor(char[] binaryName) {
-		return CharUtil.concat(FIELD_DESCRIPTOR_PREFIX, binaryName);
+		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, binaryName);
 	}
 
 	public static char[] fieldDescriptorToJavaName(char[] fieldDescriptor, boolean fullyQualified) {
@@ -79,7 +79,7 @@ public class JavaNames {
 				case 'I' : result.append("int"); break; //$NON-NLS-1$
 				case 'J' : result.append("long"); break; //$NON-NLS-1$
 				case 'L' : {
-					char[] binaryName = CharUtil.substring(fieldDescriptor, scanPosition + 1);
+					char[] binaryName = CharArrayUtils.substring(fieldDescriptor, scanPosition + 1);
 					if (fullyQualified) {
 						// Modify the binaryName string in-place to change it into a fully qualified name
 						CharOperation.replace(binaryName, '/', '.');
@@ -114,11 +114,13 @@ public class JavaNames {
 	 * @return a method id suitable for looking up a PDOMMethodId
 	 */
 	public static char[] getMethodId(char[] parentTypeBinaryName, char[] methodSelectorAndDescriptor) {
-		return CharUtil.concat(FIELD_DESCRIPTOR_PREFIX, parentTypeBinaryName, METHOD_ID_SEPARATOR, methodSelectorAndDescriptor);
+		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, parentTypeBinaryName, METHOD_ID_SEPARATOR,
+				methodSelectorAndDescriptor);
 	}
 
 	public static char[] getMethodId(char[] parentTypeBinaryName, char[] methodSelector, char[] methodDescriptor) {
-		return CharUtil.concat(FIELD_DESCRIPTOR_PREFIX, parentTypeBinaryName, METHOD_ID_SEPARATOR, methodSelector, methodDescriptor);
+		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, parentTypeBinaryName, METHOD_ID_SEPARATOR, methodSelector,
+				methodDescriptor);
 	}
 
 	/**
@@ -129,9 +131,9 @@ public class JavaNames {
 	 * @return ""
 	 */
 	public static char[] fieldDescriptorToBinaryName(char[] fieldDescriptor) {
-		if (CharUtil.startsWith(fieldDescriptor, 'L')) {
-			return CharUtil.substring(fieldDescriptor, 1);
+		if (CharArrayUtils.startsWith(fieldDescriptor, 'L')) {
+			return CharArrayUtils.substring(fieldDescriptor, 1);
 		}
-		return CharUtil.EMPTY_CHAR_ARRAY;
+		return CharArrayUtils.EMPTY_CHAR_ARRAY;
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
index 46dc526..904ec77 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
@@ -189,6 +189,70 @@ public class CharArrayUtils {
 		return result;
 	}
 
+	public static final char[] concat(char[] first, char[] second, char[] third) {
+		if (first == null)
+			return concat(second, third);
+		if (second == null)
+			return concat(first, third);
+		if (third == null)
+			return concat(first, second);
+
+		int length1 = first.length;
+		int length2 = second.length;
+		int length3 = third.length;
+		char[] result = new char[length1 + length2 + length3];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		System.arraycopy(third, 0, result, length1 + length2, length3);
+		return result;
+	}
+
+	public static final char[] concat(char[] first, char[] second, char[] third, char[] fourth) {
+		if (first == null)
+			return concat(second, third, fourth);
+		if (second == null)
+			return concat(first, third, fourth);
+		if (third == null)
+			return concat(first, second, fourth);
+		if (fourth == null)
+			return concat(first, second, third);
+
+		int length1 = first.length;
+		int length2 = second.length;
+		int length3 = third.length;
+		int length4 = fourth.length;
+		char[] result = new char[length1 + length2 + length3 + length4];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		System.arraycopy(third, 0, result, length1 + length2, length3);
+		System.arraycopy(third, 0, result, length1 + length2 + length3, length4);
+		return result;
+	}
+
+	/**
+	 * Answers a new array which is the concatenation of all the given arrays.
+	 *
+	 * @param toCatenate
+	 * @since 3.12
+	 */
+	public static char[] concat(char[]... toCatenate) {
+		int totalSize = 0;
+		for (char[] next: toCatenate) {
+			totalSize += next.length;
+		}
+
+		char[] result = new char[totalSize];
+		int writeIndex = 0;
+		for (char[] next: toCatenate) {
+			if (next == null) {
+				continue;
+			}
+			System.arraycopy(next, 0, result, writeIndex, next.length);
+			writeIndex += next.length;
+		}
+		return result;
+	}
+
 	public static final char[] replace(char[] array, char[] toBeReplaced, char[] replacementChars) {
 		int max = array.length;
 		int replacedLength = toBeReplaced.length;
@@ -303,14 +367,14 @@ public class CharArrayUtils {
 	public static final int lastIndexOf(char[] toBeFound, char[] array) {
 		return lastIndexOf(toBeFound, array, 0);
 	}
-	
+
 	/**
 	 * @since 5.11
 	 */
 	public static int lastIndexOf(char toBeFound, char[] array) {
 		return lastIndexOf(toBeFound, array, 0);
 	}
-	
+
 	/**
 	 * @since 5.11
 	 */
@@ -322,7 +386,7 @@ public class CharArrayUtils {
 		}
 		return -1;
 	}
-	
+
 	/**
 	 * @since 5.11
 	 */
@@ -340,7 +404,7 @@ public class CharArrayUtils {
 			}
 		}
 	}
-	
+
 	static final public char[] trim(char[] chars) {
 		if (chars == null)
 			return null;
@@ -355,6 +419,7 @@ public class CharArrayUtils {
 
 		int end = length;
 		while (--end > start && chars[end] == ' ') {
+			// Nothing to do
 		}
 		end++;
 		if (start == 0 && end == length)
@@ -408,4 +473,18 @@ public class CharArrayUtils {
 		buf.getChars(0, len, result, 0);
 		return result;
 	}
+
+	public static char[] substring(char[] inputString, int index) {
+		if (inputString.length <= index) {
+			return EMPTY_CHAR_ARRAY;
+		}
+
+		char[] result = new char[inputString.length - index];
+		System.arraycopy(inputString, index, result, 0, result.length);
+		return result;
+	}
+
+	public static boolean startsWith(char[] fieldDescriptor, char c) {
+		return fieldDescriptor.length > 0 && fieldDescriptor[0] == c;
+	}
 }
commit ee0254473b44a30e7bba98c0a7c0d329abd8c54d
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 11:04:09 2016 -0800

    Bug 481796 - Fix remaining warnings in jdt.core
    
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>
    Change-Id: Ica91ee59537299f964e0fa39eebef02c2feb4e9d

1	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
0	24	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/CacheConstants.java
6	11	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
1	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
8	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
15	16	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
3	21	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/Package.java
13	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
76	77	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayMap.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index 74004fd..2057694 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -510,10 +510,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 				continue;
 			}
 
-			SubMonitor iterationMonitor = subMonitor
-					.setWorkRemaining(Math.max(typesToVisit.size(), 10))
-					.split(1)
-					.setWorkRemaining(3);
+			subMonitor.setWorkRemaining(Math.max(typesToVisit.size(), 10)).split(1);
 
 			boolean isLocalClass = nextType.getDeclaringType() != null;
 			pathRequestor.acceptPath(typePath, isLocalClass);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/CacheConstants.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/CacheConstants.java
deleted file mode 100644
index bf0e4f3..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/CacheConstants.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Stefan Xenos (Google) - Initial implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core.nd.java;
-
-/**
- * Holds constants for accessing the PDOM cache
- * @since 3.12
- */
-public class CacheConstants {
-	public final static int CACHE_MEMBERS= 0;
-	public final static int CACHE_BASES= 1;
-	public final static int CACHE_INSTANCES= 2;
-	public final static int CACHE_INSTANCE_SCOPE= 3;
-
-	private CacheConstants() {};
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
index 575c962..830936f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
@@ -18,7 +18,7 @@ public class FileFingerprint {
 	private long time;
 	private long hash;
 	private long size;
-	
+
 	private static final FileFingerprint EMPTY = new FileFingerprint(0,0,0);
 
 	public static final FileFingerprint getEmpty() {
@@ -98,18 +98,13 @@ public class FileFingerprint {
 	}
 
 	/**
-	 * Compares the given File with the receiver. If the fingerprint matches (ie: the file 
-	 * 
-	 * @param toTest
-	 * @param monitor
-	 * @return
-	 * @throws IOException 
+	 * Compares the given File with the receiver. If the fingerprint matches (ie: the file
 	 */
 	public FingerprintTestResult test(File toTest, IProgressMonitor monitor) throws CoreException {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 		long lastModified = toTest.lastModified();
 		subMonitor.split(5);
-		
+
 		long fileSize = toTest.length();
 		subMonitor.split(5);
 		if (lastModified == this.time && fileSize == this.size) {
@@ -120,7 +115,7 @@ public class FileFingerprint {
 		try {
 			hashCode = computeHashCode(toTest, fileSize, subMonitor.split(90));
 		} catch (IOException e) {
-			throw new CoreException(Package.createStatus("An error occurred computing a hash code", e));
+			throw new CoreException(Package.createStatus("An error occurred computing a hash code", e)); //$NON-NLS-1$
 		}
 		boolean matches = (hashCode == this.hash && fileSize == this.size);
 
@@ -140,14 +135,14 @@ public class FileFingerprint {
 				while (true) {
 					subMonitor.split(1);
 					int bytesRead = readUntilBufferFull(inputStream, byteBuffer);
-	
+
 					if (bytesRead < byteBuffer.length) {
 						charBuffer = new char[(bytesRead + 1) / 2];
 						copyByteArrayToCharArray(charBuffer, byteBuffer, bytesRead);
 						hasher.addChunk(charBuffer);
 						break;
 					}
-	
+
 					copyByteArrayToCharArray(charBuffer, byteBuffer, bytesRead);
 					hasher.addChunk(charBuffer);
 				}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index 1ceebeb..c4e980a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -58,9 +58,7 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 	}
 
 	/**
-	 * If this type is a variable, this returns the identifier
-	 *
-	 * @return
+	 * If this type is a type variable, this returns the variable's identifier.
 	 */
 	public IString getVariableIdentifier() {
 		return VARIABLE_IDENTIFIER.get(getPDOM(), this.address);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index a9b47ae..2a6dac4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -46,13 +46,13 @@ public class NdMethod extends NdBinding {
 		type.done();
 	}
 
-	private static final int METHOD_IS_CONSTRUCTOR = 0x0001;
-	private static final int METHOD_IS_DEFAULT_CONSTRUCTOR = 0x0002;
-	private static final int METHOD_IS_ANNOTATION_MEMBER = 0x0004;
-	private static final int METHOD_IS_GENERIC = 0x0008;
-	private static final int METHOD_IS_PARAMETERIZED = 0x0010;
-	private static final int METHOD_IS_RAW = 0x0020;
-	private static final int METHOD_IS_VARARGS = 0x0040;
+//	private static final int METHOD_IS_CONSTRUCTOR = 0x0001;
+//	private static final int METHOD_IS_DEFAULT_CONSTRUCTOR = 0x0002;
+//	private static final int METHOD_IS_ANNOTATION_MEMBER = 0x0004;
+//	private static final int METHOD_IS_GENERIC = 0x0008;
+//	private static final int METHOD_IS_PARAMETERIZED = 0x0010;
+//	private static final int METHOD_IS_RAW = 0x0020;
+//	private static final int METHOD_IS_VARARGS = 0x0040;
 
 	/**
 	 * @param pdom
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
index 24cd3a9..1f0ae07 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
@@ -28,7 +28,8 @@ public abstract class NdTreeNode extends NdNode {
 	public static final FieldManyToOne<NdTreeNode> PARENT;
 	public static final FieldOneToMany<NdTreeNode> CHILDREN;
 
-	public static final StructDef<NdTreeNode> type; 
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdTreeNode> type;
 
 	static {
 		type = StructDef.create(NdTreeNode.class, NdNode.type);
@@ -52,8 +53,8 @@ public abstract class NdTreeNode extends NdNode {
 	 * this looks for an exact match. It will not return subtypes of the given type.
 	 */
 	@SuppressWarnings("unchecked")
-	public <T extends NdTreeNode> T getAncestorOfType(Class<T> type) {
-		long targetType = getPDOM().getNodeType(type);
+	public <T extends NdTreeNode> T getAncestorOfType(Class<T> ancestorType) {
+		long targetType = getPDOM().getNodeType(ancestorType);
 
 		Nd pdom = getPDOM();
 		long current = PARENT.getAddress(pdom, this.address);
@@ -64,12 +65,12 @@ public abstract class NdTreeNode extends NdNode {
 			if (currentType == targetType) {
 				NdNode result = load(pdom, current);
 
-				if (type.isInstance(result)) {
+				if (ancestorType.isInstance(result)) {
 					return (T) result;
 				} else {
-					throw new IndexException("The node at address " + current + 
-							" should have been an instance of " + type.getName() + 
-							" but was an instance of " + result.getClass().getName());
+					throw new IndexException("The node at address " + current +  //$NON-NLS-1$
+							" should have been an instance of " + ancestorType.getName() +  //$NON-NLS-1$
+							" but was an instance of " + result.getClass().getName()); //$NON-NLS-1$
 				}
 			}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
index a6d00d1..0db32b9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
@@ -14,6 +14,7 @@ public class NdTypeArgument extends NdNode {
 	public static final FieldManyToOne<NdTypeSignature> TYPE_SIGNATURE;
 	public static final FieldByte WILDCARD;
 
+	@SuppressWarnings("hiding")
 	public static final StructDef<NdTypeArgument> type;
 
 	static {
@@ -41,7 +42,7 @@ public class NdTypeArgument extends NdNode {
 
 	/**
 	 * Sets the wildcard to use, one of the WILDCARD_* constants.
-	 * 
+	 *
 	 * @param wildcard
 	 */
 	public void setWildcard(int wildcard) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
index a81d5da..a6727ef 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
@@ -8,13 +8,14 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
 /**
  * Represents the bound on a generic parameter (a ClassBound or InterfaceBound in
  * the sense of the Java VM spec Java SE 8 Edition, section 4.7.9.1)
- * 
+ *
  * @since 3.12
  */
 public class NdTypeBound extends NdNode {
 	public static final FieldManyToOne<NdTypeParameter> PARENT;
 	public static final FieldManyToOne<NdTypeSignature> TYPE;
 
+	@SuppressWarnings("hiding")
 	public static final StructDef<NdTypeBound> type;
 
 	static {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
index 660c3cf..8da96e9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
@@ -17,11 +17,12 @@ public class NdTypeParameter extends NdNode {
 	public static final FieldString IDENTIFIER;
 	public static final FieldOneToMany<NdTypeBound> BOUNDS;
 
+	@SuppressWarnings("hiding")
 	public static final StructDef<NdTypeParameter> type;
 
 	static {
 		type = StructDef.create(NdTypeParameter.class, NdNode.type);
-		PARENT = FieldManyToOne.createOwner(type, NdType.TYPE_PARAMETERS);
+		PARENT = FieldManyToOne.createOwner(type, NdBinding.TYPE_PARAMETERS);
 		IDENTIFIER = type.addString();
 		BOUNDS = FieldOneToMany.create(type, NdTypeBound.PARENT);
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index 7afca79..79a4d4a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -14,7 +14,6 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.field.FieldInt;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
-import org.eclipse.jdt.internal.core.nd.field.FieldShort;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
@@ -22,7 +21,7 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  * @since 3.12
  */
 public class NdVariable extends NdBinding {
-	public static final FieldShort VARIABLE_FLAGS;
+	//public static final FieldShort VARIABLE_FLAGS;
 	public static final FieldManyToOne<NdTypeSignature> TYPE;
 	public static final FieldInt VARIABLE_ID;
 	public static final FieldManyToOne<NdMethod> DECLARING_METHOD;
@@ -33,14 +32,14 @@ public class NdVariable extends NdBinding {
 	@SuppressWarnings("hiding")
 	public static StructDef<NdVariable> type;
 
-	public static final int FLG_VARIABLE_FIELD 				= 0x01;
-	public static final int FLG_VARIABLE_ENUM_CONSTANT 		= 0x02;
-	public static final int FLG_VARIABLE_PARAMETER 			= 0x04;
-	public static final int FLG_VARIABLE_EFFECTIVELY_FINAL 	= 0x08;
+//	public static final int FLG_VARIABLE_FIELD 				= 0x01;
+//	public static final int FLG_VARIABLE_ENUM_CONSTANT 		= 0x02;
+//	public static final int FLG_VARIABLE_PARAMETER 			= 0x04;
+//	public static final int FLG_VARIABLE_EFFECTIVELY_FINAL 	= 0x08;
 
 	static {
 		type = StructDef.create(NdVariable.class, NdBinding.type);
-		VARIABLE_FLAGS = type.addShort();
+		//VARIABLE_FLAGS = type.addShort();
 		TYPE = FieldManyToOne.create(type, NdTypeSignature.VARIABLES_OF_TYPE);
 		VARIABLE_ID = type.addInt();
 		DECLARING_METHOD = FieldManyToOne.create(type, NdMethod.DECLARED_VARIABLES);
@@ -59,15 +58,15 @@ public class NdVariable extends NdBinding {
 
 		PARENT.put(getPDOM(), this.address, parent);
 	}
-
-	private boolean hasVariableFlag(int toTest) {
-		return (VARIABLE_FLAGS.get(getPDOM(), this.address) & toTest) != 0;
-	}
-
-	private void setVariableFlag(int toSet) {
-		int newFlags = VARIABLE_FLAGS.get(getPDOM(), this.address) | toSet;
-		VARIABLE_FLAGS.put(getPDOM(), this.address, (short)newFlags);
-	}
+//
+//	private boolean hasVariableFlag(int toTest) {
+//		return (VARIABLE_FLAGS.get(getPDOM(), this.address) & toTest) != 0;
+//	}
+//
+//	private void setVariableFlag(int toSet) {
+//		int newFlags = VARIABLE_FLAGS.get(getPDOM(), this.address) | toSet;
+//		VARIABLE_FLAGS.put(getPDOM(), this.address, (short)newFlags);
+//	}
 
 	public void setName(char[] name) {
 		NAME.put(getPDOM(), this.address, name);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/Package.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/Package.java
index ff6537d..e352de8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/Package.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/Package.java
@@ -14,9 +14,6 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.JavaCore;
 
-/**
- * @noreference This class is not intended to be referenced by clients
- */
 /* package */ class Package {
 	public static String PLUGIN_ID = JavaCore.PLUGIN_ID;
 
@@ -25,10 +22,7 @@ import org.eclipse.jdt.core.JavaCore;
 	 * @since 5.2
 	 */
 	public static final int STATUS_PDOM_TOO_LARGE = 4;
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static void log(Throwable e) {
 		String msg= e.getMessage();
 		if (msg == null) {
@@ -37,31 +31,19 @@ import org.eclipse.jdt.core.JavaCore;
 			log("Error: " + msg, e); //$NON-NLS-1$
 		}
 	}
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static void log(String message, Throwable e) {
 		log(createStatus(message, e));
 	}
-	
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
+
 	public static IStatus createStatus(String msg, Throwable e) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg, e);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static IStatus createStatus(String msg) {
 		return new Status(IStatus.ERROR, PLUGIN_ID, msg);
 	}
 
-	/**
-	 * @noreference This method is not intended to be referenced by clients.
-	 */
 	public static void log(IStatus status) {
 		JavaCore.getPlugin().getLog().log(status);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
index 4032d21..52d585a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
@@ -17,15 +17,19 @@ public abstract class TagTreeReader {
 		abstract public T read(Nd pdom, long address, TagTreeReader reader, int[] bytesRead);
 		abstract public void write(Nd pdom, long address, TagTreeReader reader, T toWrite, int[] bytesWritten);
 		abstract public int getSize(Nd pdom, T object, TagTreeReader reader);
-		public void destruct(Nd pdom, long address, TagTreeReader reader) {}
+		public void destruct(Nd pdom, long address, TagTreeReader reader) {
+			// Nothing to do by default
+		}
 	}
 
 	public static abstract class FixedSizeTagHandler<T> extends TagHandler<T> {
 		protected abstract T read(Nd pdom, long address);
 		protected abstract void write(Nd pdom, long address, T value);
 		protected abstract int getSize();
-		protected void destruct(Nd pdom, long address) {}
-		
+		protected void destruct(Nd pdom, long address) {
+			// Nothing to do by default
+		}
+
 		public final T read(Nd pdom, long address, TagTreeReader reader, int[] bytesRead) {
 			bytesRead[0] = getSize();
 			return read(pdom, address);
@@ -79,16 +83,18 @@ public abstract class TagTreeReader {
 		write(pdom, address, toWrite, UNUSED_RESULT);
 	}
 
+	@SuppressWarnings("unchecked")
 	public final void write(Nd pdom, long address, Object toWrite, int[] bytesWritten) {
 		byte key = getKeyFor(toWrite);
 
+		@SuppressWarnings("rawtypes")
 		TagHandler handler = this.readers[key];
 
 		if (handler == null) {
 			throw new IndexException("Invalid key " + key + " returned from getKeyFor(...)"); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
-		handler.write(pdom, address, this, (Object) toWrite, bytesWritten);
+		handler.write(pdom, address, this, toWrite, bytesWritten);
 	}
 
 	public final void destruct(Nd pdom, long address) {
@@ -105,14 +111,15 @@ public abstract class TagTreeReader {
 		handler.destruct(pdom, readAddress, this);
 	}
 
+	@SuppressWarnings("unchecked")
 	public final int getSize(Nd pdom, Object toMeasure) {
-		Database db = pdom.getDB();
 		byte key = getKeyFor(toMeasure);
 
+		@SuppressWarnings("rawtypes")
 		TagHandler handler = this.readers[key];
 		if (handler == null) {
 			throw new IndexException("Attempted to get size of object " + toMeasure.toString() + " with unknown key " //$NON-NLS-1$//$NON-NLS-2$
-					+ key); 
+					+ key);
 		}
 
 		return handler.getSize(pdom, toMeasure, this);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayMap.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayMap.java
index 3096b81..979fce7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayMap.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayMap.java
@@ -19,29 +19,29 @@ import java.util.TreeMap;
 
 
 /**
- * Provides functionality similar to a Map, with the feature that char arrays 
+ * Provides functionality similar to a Map, with the feature that char arrays
  * and sections of char arrays (known as slices) may be used as keys.
- * 
+ *
  * This class is useful because small pieces of an existing large char[] buffer
- * can be directly used as map keys. This avoids the need to create many String 
+ * can be directly used as map keys. This avoids the need to create many String
  * objects as would normally be needed as keys in a standard java.util.Map.
  * Thus performance is improved in the CDT core.
  *
  * Most methods are overloaded with two versions, one that uses a
  * section of a char[] as the key (a slice), and one that uses
  * the entire char[] as the key.
- * 
+ *
  * This class is intended as a replacement for CharArrayObjectMap.
- * 
+ *
  * ex:
  * char[] key = "one two three".toCharArray();
  * map.put(key, 4, 3, new Integer(99));
  * map.get(key, 4, 3); // returns 99
  * map.get("two".toCharArray()); // returns 99
- * 
+ *
  * @author Mike Kucera
  *
- * @param <V>  
+ * @param <V>
  * @since 3.12
  */
 public final class CharArrayMap<V> {
@@ -50,21 +50,21 @@ public final class CharArrayMap<V> {
 	 * Wrapper class used as keys in the map. The purpose
 	 * of this class is to provide implementations of
 	 * equals() and hashCode() that operate on array slices.
-	 * 
+	 *
 	 * This class is private so it is assumed that the arguments
 	 * passed to the constructor are legal.
 	 */
     private static final class Key implements Comparable<Key>{
-        private final char[] buffer;
-        private final int start;
-        private final int length;
+        final char[] buffer;
+        final int start;
+        final int length;
 
         public Key(char[] buffer, int start, int length) {
             this.buffer = buffer;
             this.length = length;
             this.start = start;
         }
-        
+
         /**
          * @throws NullPointerException if buffer is null
          */
@@ -73,60 +73,60 @@ public final class CharArrayMap<V> {
         	this.length = buffer.length; // throws NPE
         	this.start = 0;
         }
-        
-        @Override 
+
+        @Override
         public boolean equals(Object x) {
-        	if(this == x) 
+        	if(this == x)
         		return true;
-        	if(!(x instanceof Key))  
+        	if(!(x instanceof Key))
         		return false;
-        	
+
             Key k = (Key) x;
-            if(length != k.length)
+            if(this.length != k.length)
             	return false;
-            
-            for(int i = start, j = k.start; i < length; i++, j++) {
-            	if(buffer[i] != k.buffer[j]) {
+
+            for(int i = this.start, j = k.start; i < this.length; i++, j++) {
+            	if(this.buffer[i] != k.buffer[j]) {
             		return false;
             	}
             }
             return true;
         }
-        
-        @Override 
+
+        @Override
         public int hashCode() {
             int result = 17;
-            for(int i = start; i < start+length; i++) {
-            	result = 37 * result + buffer[i];
+            for(int i = this.start; i < this.start+this.length; i++) {
+            	result = 37 * result + this.buffer[i];
             }
             return result;
         }
-        
+
         @SuppressWarnings("nls")
-		@Override 
+		@Override
         public String toString() {
-        	String slice = new String(buffer, start, length);
-        	return "'" + slice + "'@(" + start + "," + length + ")"; 
+        	String slice = new String(this.buffer, this.start, this.length);
+        	return "'" + slice + "'@(" + this.start + "," + this.length + ")";
         }
-        
-        
+
+
         @Override
 		public int compareTo(Key other) {
-        	char[] b1 = buffer, b2 = other.buffer;
-        	
-        	for(int i = start, j = other.start; i < b1.length && j < b2.length; i++, j++) {
+        	char[] b1 = this.buffer, b2 = other.buffer;
+
+        	for(int i = this.start, j = other.start; i < b1.length && j < b2.length; i++, j++) {
         		if(b1[i] != b2[j])
         			return b1[i] < b2[j] ? -1 : 1;
         	}
         	return b1.length - b2.length;
         }
     }
-    
+
 
     /**
-     * Used to enforce preconditions. 
+     * Used to enforce preconditions.
      * Note that the NPE thrown by mutator methods is thrown from the Key constructor.
-     * 
+     *
      * @throws IndexOutOfBoundsException if boundaries are wrong in any way
      */
     private static void checkBoundaries(char[] chars, int start, int length) {
@@ -135,45 +135,45 @@ public final class CharArrayMap<V> {
     				                          ", Start index: " + start + //$NON-NLS-1$
     				                          ", Length: " + length); //$NON-NLS-1$
     }
-    
-    
+
+
     private final Map<Key,V> map;
 
-    
+
     /**
      * Constructs an empty CharArrayMap with default initial capacity.
      */
     public CharArrayMap() {
-    	map = new HashMap<Key,V>();
+    	this.map = new HashMap<Key,V>();
     }
-    
-    
+
+
     /**
      * Static factory method that constructs an empty CharArrayMap with default initial capacity,
      * and the map will be kept in ascending key order.
-     * 
+     *
      * Characters are compared using a strictly numerical comparison; it is not locale-dependent.
      */
     public static <V> CharArrayMap<V> createOrderedMap() {
     	// TreeMap does not have a constructor that takes an initial capacity
     	return new CharArrayMap<V>(new TreeMap<Key, V>());
     }
-    
-    
+
+
     private CharArrayMap(Map<Key, V> map) {
     	assert map != null;
     	this.map = map;
     }
-    
-    
+
+
     /**
      * Constructs an empty CharArrayMap with the given initial capacity.
      * @throws IllegalArgumentException if the initial capacity is negative
      */
     public CharArrayMap(int initialCapacity) {
-    	map = new HashMap<Key,V>(initialCapacity);
+    	this.map = new HashMap<Key,V>(initialCapacity);
     }
-    
+
     /**
 	 * Creates a new mapping in this map, uses the given array slice as the key.
 	 * If the map previously contained a mapping for this key, the old value is replaced.
@@ -182,7 +182,7 @@ public final class CharArrayMap<V> {
 	 */
     public void put(char[] chars, int start, int length, V value) {
     	checkBoundaries(chars, start, length);
-        map.put(new Key(chars, start, length), value);
+        this.map.put(new Key(chars, start, length), value);
     }
 
     /**
@@ -191,27 +191,27 @@ public final class CharArrayMap<V> {
 	 * @throws NullPointerException if chars is null
 	 */
     public void put(char[] chars, V value) {
-        map.put(new Key(chars), value);
+        this.map.put(new Key(chars), value);
     }
 
     /**
-	 * Returns the value to which the specified array slice is mapped in this map, 
-	 * or null if the map contains no mapping for this key. 
+	 * Returns the value to which the specified array slice is mapped in this map,
+	 * or null if the map contains no mapping for this key.
 	 * @throws NullPointerException if chars is null
 	 * @throws IndexOutOfBoundsException if the boundaries specified by start and length are out of range
 	 */
     public V get(char[] chars, int start, int length) {
     	checkBoundaries(chars, start, length);
-        return map.get(new Key(chars, start, length));
+        return this.map.get(new Key(chars, start, length));
     }
 
     /**
-	 * Returns the value to which the specified array is mapped in this map, 
-	 * or null if the map contains no mapping for this key. 
+	 * Returns the value to which the specified array is mapped in this map,
+	 * or null if the map contains no mapping for this key.
 	 * @throws NullPointerException if chars is null
 	 */
     public V get(char[] chars) {
-        return map.get(new Key(chars));
+        return this.map.get(new Key(chars));
     }
 
     /**
@@ -223,9 +223,9 @@ public final class CharArrayMap<V> {
 	 */
     public V remove(char[] chars, int start, int length) {
     	checkBoundaries(chars, start, length);
-    	return map.remove(new Key(chars, start, length));
+    	return this.map.remove(new Key(chars, start, length));
     }
-    
+
     /**
 	 * Removes the mapping for the given array if present.
 	 * Returns the value object that corresponded to the key
@@ -233,7 +233,7 @@ public final class CharArrayMap<V> {
 	 * @throws NullPointerException if chars is null
 	 */
     public V remove(char[] chars) {
-    	return map.remove(new Key(chars));
+    	return this.map.remove(new Key(chars));
     }
 
     /**
@@ -243,7 +243,7 @@ public final class CharArrayMap<V> {
 	 */
     public boolean containsKey(char[] chars, int start, int length) {
     	checkBoundaries(chars, start, length);
-    	return map.containsKey(new Key(chars, start, length));
+    	return this.map.containsKey(new Key(chars, start, length));
     }
 
     /**
@@ -251,28 +251,28 @@ public final class CharArrayMap<V> {
 	 * @throws NullPointerException if chars is null
 	 */
     public boolean containsKey(char[] chars) {
-    	return map.containsKey(new Key(chars));
+    	return this.map.containsKey(new Key(chars));
     }
-    
+
     /**
 	 * Returns true if the given value is contained in the map.
 	 */
     public boolean containsValue(V value) {
-    	return map.containsValue(value);
+    	return this.map.containsValue(value);
     }
 
-    /** 
+    /**
 	 * Use this in a foreach loop.
 	 */
     public Collection<V> values() {
-        return map.values();
+        return this.map.values();
     }
 
     /**
 	 * Returns the keys stored in the map.
 	 */
     public Collection<char[]> keys() {
-    	Set<Key> keys= map.keySet();
+    	Set<Key> keys= this.map.keySet();
     	ArrayList<char[]> r= new ArrayList<char[]>(keys.size());
     	for (Key key : keys) {
     		r.add(CharArrayUtils.extract(key.buffer, key.start, key.length));
@@ -284,31 +284,30 @@ public final class CharArrayMap<V> {
 	 * Removes all mappings from the map.
 	 */
     public void clear() {
-    	map.clear();
+    	this.map.clear();
     }
 
     /**
 	 * Returns the number of mappings.
 	 */
     public int size() {
-    	return map.size();
+    	return this.map.size();
     }
 
     /**
 	 * Returns true if the map is empty.
 	 */
     public boolean isEmpty() {
-    	return map.isEmpty();
+    	return this.map.isEmpty();
     }
-    
-    
+
+
     /**
      * Returns a String representation of the map.
      */
-    @Override 
+    @Override
     public String toString() {
-    	return map.toString();
+    	return this.map.toString();
     }
-   
-}
 
+}
commit fe9ec2fcca9ef652ef17e55f8302f72965e2a52f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 11:08:44 2016 -0800

    Bug 481796 - Bump minor version number to 13
    
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>
    Change-Id: Ica91ee59537299f964e0fa39eebef02c2feb4e9d

4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index dc1deca..0c722f3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -21,18 +21,18 @@ import org.eclipse.jdt.internal.core.nd.NdNodeTypeRegistry;
 import org.eclipse.jdt.internal.core.nd.db.ChunkCache;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex;
-import org.eclipse.jdt.internal.core.nd.field.StructDef;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.IResultRank;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.SearchCriteria;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
  * @since 3.12
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 12);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 12);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 12);
+	static final int CURRENT_VERSION = Nd.version(1, 13);
+	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 13);
+	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 13);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
commit 9d5a9350b7024cabbf7a0b553f0529f8553ebe22
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 12:08:33 2016 -0800

    Bug 481796 - Add missing type names to the index
    
    Change-Id: I6fc0e8fe8ba6e73e4cd897134e62482fb3c26eb9
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

27	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
12	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 4516218..92892e2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -48,12 +48,15 @@ import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
 import org.eclipse.jdt.internal.core.nd.java.NdVariable;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class ClassFileToIndexConverter {
+	private static final char[] COMMA = new char[]{','};
 	private static final char[][] EMPTY_CHAR_ARRAY_ARRAY = new char[0][];
 	private static final boolean ENABLE_LOGGING = false;
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
+	private static final char[] PATH_SEPARATOR = new char[]{'/'};
 	private NdResourceFile resource;
 	private JavaIndex index;
 
@@ -182,6 +185,30 @@ public class ClassFileToIndexConverter {
 			}
 		}
 
+		char[][][] missingTypeNames = binaryType.getMissingTypeNames();
+		if (missingTypeNames != null) {
+			CharArrayBuffer builder = new CharArrayBuffer();
+			for (int typeIdx = 0; typeIdx < missingTypeNames.length; typeIdx++) {
+				char[][] next = missingTypeNames[typeIdx];
+				if (typeIdx != 0) {
+					builder.append(COMMA);
+				}
+				if (next == null) {
+					continue;
+				}
+				for (int segmentIdx = 0; segmentIdx < next.length; segmentIdx++) {
+					char[] segment = next[segmentIdx];
+					if (segment == null) {
+						continue;
+					}
+					if (segmentIdx != 0) {
+						builder.append(PATH_SEPARATOR);
+					}
+					builder.append(segment);
+				}
+			}
+			type.setMissingTypeNames(builder.getContents());
+		}
 		return type;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 14f4ecb..463ff98 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -10,15 +10,16 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.internal.core.nd.IPDOMVisitor;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
+import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
-import java.util.List;
-
 /**
  * @since 3.12
  */
@@ -29,6 +30,7 @@ public class NdType extends NdBinding {
 	public static final FieldManyToOne<NdTypeId> DECLARING_TYPE;
 	public static final FieldManyToOne<NdMethodId> DECLARING_METHOD;
 	public static final FieldOneToMany<NdMethod> METHODS;
+	public static final FieldString MISSING_TYPE_NAMES;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdType> type;
@@ -41,6 +43,7 @@ public class NdType extends NdBinding {
 		SUPERCLASS = FieldManyToOne.create(type, NdTypeSignature.SUBCLASSES);
 		DECLARING_METHOD = FieldManyToOne.create(type, NdMethodId.DECLARED_TYPES);
 		METHODS = FieldOneToMany.create(type, NdMethod.PARENT, 6);
+		MISSING_TYPE_NAMES = type.addString();
 		type.done();
 	}
 
@@ -129,4 +132,11 @@ public class NdType extends NdBinding {
 	public NdTypeId getDeclaringType() {
 		return DECLARING_TYPE.get(getPDOM(), this.address);
 	}
+
+	/**
+	 * Sets the missing type names (if any) for this class. The names are encoded in a comma-separated list.
+	 */
+	public void setMissingTypeNames(char[] contents) {
+		MISSING_TYPE_NAMES.put(getPDOM(), this.address, contents);
+	}
 }
commit 48e3ddc97a372ba17e3a8fb05bd8c143189dd168
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 12:11:36 2016 -0800

    Bug 481796 - Fix ArrayIndexOutOfBoundsException
    
    Change-Id: Ib1cded7b613262929f0c906a04bd69a523311141
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
index 904ec77..a846094 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
@@ -225,7 +225,7 @@ public class CharArrayUtils {
 		System.arraycopy(first, 0, result, 0, length1);
 		System.arraycopy(second, 0, result, length1, length2);
 		System.arraycopy(third, 0, result, length1 + length2, length3);
-		System.arraycopy(third, 0, result, length1 + length2 + length3, length4);
+		System.arraycopy(fourth, 0, result, length1 + length2 + length3, length4);
 		return result;
 	}
 
commit 5b7cb38c8981091f82d173627654ec45f206b14b
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 12:12:00 2016 -0800

    Bug 481796 - Bump database minar version to 14
    
    Change-Id: I0f0e4cc39db7f7e02301914f3e294563f6f9ad55
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 0c722f3..e32e1d3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -30,9 +30,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 13);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 13);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 13);
+	static final int CURRENT_VERSION = Nd.version(1, 14);
+	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 14);
+	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 14);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
commit 5905a31cfe4714d5b5ba22ce0f27865127105843
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 12:14:18 2016 -0800

    Bug 481796 - Add getter for missing type names
    
    Change-Id: Icaf71d551c8880625e410e6635c4c2e1a938d215
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

8	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 463ff98..839fcfd 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -15,6 +15,7 @@ import java.util.List;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.internal.core.nd.IPDOMVisitor;
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -139,4 +140,11 @@ public class NdType extends NdBinding {
 	public void setMissingTypeNames(char[] contents) {
 		MISSING_TYPE_NAMES.put(getPDOM(), this.address, contents);
 	}
+
+	/**
+	 * Returns the missing type names as a comma-separated list
+	 */
+	public IString getMissingTypeNames() {
+		return MISSING_TYPE_NAMES.get(getPDOM(), this.address);
+	}
 }
commit e37a51362f6e667d7de78ac98d1a6527c4335f08
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 12:42:08 2016 -0800

    Bug 481796 - Extract getMissingTypeString helper method.
    
    Change-Id: I3fd4c9893a60d93efcf16fb1e1e269f16c2f5086
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

4	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
11	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
index c31d887..ddf9428 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
@@ -22,6 +22,7 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
  */
 public class FieldString implements IDestructableField, IField {
 	public static final int RECORD_SIZE = Database.STRING_SIZE;
+	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private int offset;
 
 	public FieldString() {
@@ -38,6 +39,9 @@ public class FieldString implements IDestructableField, IField {
 	}
 
 	public void put(Nd pdom, long address, char[] newString) {
+		if (newString == null) {
+			newString = EMPTY_CHAR_ARRAY;
+		}
 		final Database db= pdom.getDB();
 		IString name= get(pdom, address);
 		if (name.compare(newString, true) != 0) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 92892e2..1e0e724 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -186,6 +186,15 @@ public class ClassFileToIndexConverter {
 		}
 
 		char[][][] missingTypeNames = binaryType.getMissingTypeNames();
+		char[] missingTypeString = getMissingTypeString(missingTypeNames);
+
+		type.setMissingTypeNames(missingTypeString);
+
+		return type;
+	}
+
+	private static char[] getMissingTypeString(char[][][] missingTypeNames) {
+		char[] missingTypeString = null;
 		if (missingTypeNames != null) {
 			CharArrayBuffer builder = new CharArrayBuffer();
 			for (int typeIdx = 0; typeIdx < missingTypeNames.length; typeIdx++) {
@@ -207,9 +216,9 @@ public class ClassFileToIndexConverter {
 					builder.append(segment);
 				}
 			}
-			type.setMissingTypeNames(builder.getContents());
+			missingTypeString = builder.getContents();
 		}
-		return type;
+		return missingTypeString;
 	}
 
 	private void attachAnnotations(NdBinding type, IBinaryAnnotation[] annotations) {
commit 4322b00e240a6e436eb9b2ed5667d3bc823e490d
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 13:12:37 2016 -0800

    Bug 481796 - Add more attributes to NdType.
    
    Add sourceFileName, isAnonymous, isLocal, and isMember to NdType.
    
    Change-Id: Id8170ab7b23e182485cde32ac29742954c7803bb
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

4	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
50	20	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 1e0e724..5da5e48 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -189,6 +189,10 @@ public class ClassFileToIndexConverter {
 		char[] missingTypeString = getMissingTypeString(missingTypeNames);
 
 		type.setMissingTypeNames(missingTypeString);
+		type.setSourceFileName(binaryType.sourceFileName());
+		type.setAnonymous(binaryType.isAnonymous());
+		type.setIsLocal(binaryType.isLocal());
+		type.setIsMember(binaryType.isMember());
 
 		return type;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index e32e1d3..4a2cfac 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -30,9 +30,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 14);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 14);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 14);
+	static final int CURRENT_VERSION = Nd.version(1, 15);
+	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 15);
+	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 15);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 839fcfd..5190b2a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -16,6 +16,7 @@ import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.internal.core.nd.IPDOMVisitor;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -32,6 +33,8 @@ public class NdType extends NdBinding {
 	public static final FieldManyToOne<NdMethodId> DECLARING_METHOD;
 	public static final FieldOneToMany<NdMethod> METHODS;
 	public static final FieldString MISSING_TYPE_NAMES;
+	public static final FieldString SOURCE_FILE_NAME;
+	public static final FieldByte FLAGS;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdType> type;
@@ -45,29 +48,14 @@ public class NdType extends NdBinding {
 		DECLARING_METHOD = FieldManyToOne.create(type, NdMethodId.DECLARED_TYPES);
 		METHODS = FieldOneToMany.create(type, NdMethod.PARENT, 6);
 		MISSING_TYPE_NAMES = type.addString();
+		SOURCE_FILE_NAME = type.addString();
+		FLAGS = type.addByte();
 		type.done();
 	}
 
-	public static final long FLG_TYPE_ANNOTATION 	= 0x00000001;
-	public static final long FLG_TYPE_ANONYMOUS 	= 0x00000002;
-	public static final long FLG_TYPE_ARRAY 		= 0x00000004;
-	public static final long FLG_TYPE_CAPTURE 		= 0x00000008;
-	public static final long FLG_TYPE_CLASS 		= 0x00000010;
-	public static final long FLG_TYPE_ENUM 			= 0x00000020;
-	public static final long FLG_TYPE_FROM_SOURCE 	= 0x00000040;
-	public static final long FLG_TYPE_GENERIC 		= 0x00000080;
-	public static final long FLG_TYPE_INTERFACE 	= 0x00000100;
-	public static final long FLG_TYPE_LOCAL 		= 0x00000200;
-	public static final long FLG_TYPE_MEMBER 		= 0x00000400;
-	public static final long FLG_TYPE_NESTED 		= 0x00000800;
-	public static final long FLG_TYPE_NULLTYPE 		= 0x00001000;
-	public static final long FLG_TYPE_PARAMETERIZED = 0x00002000;
-	public static final long FLG_TYPE_PRIMITIVE 	= 0x00004000;
-	public static final long FLG_TYPE_RAW			= 0x00008000;
-	public static final long FLG_TYPE_TOP_LEVEL 	= 0x00010000;
-	public static final long FLG_TYPE_VARIABLE 		= 0x00020000;
-	public static final long FLG_TYPE_UPPER_BOUND 	= 0x00040000;
-	public static final long FLG_TYPE_WILDCARD 		= 0x00080000;
+	public static final byte FLG_TYPE_ANONYMOUS 	= 0x0001;
+	public static final byte FLG_TYPE_LOCAL 		= 0x0002;
+	public static final byte FLG_TYPE_MEMBER 		= 0x0004;
 
 	public NdType(Nd pdom, long address) {
 		super(pdom, address);
@@ -147,4 +135,46 @@ public class NdType extends NdBinding {
 	public IString getMissingTypeNames() {
 		return MISSING_TYPE_NAMES.get(getPDOM(), this.address);
 	}
+
+	public void setSourceFileName(char[] sourceFileName) {
+		SOURCE_FILE_NAME.put(getPDOM(), this.address, sourceFileName);
+	}
+
+	public IString getSourceFileName() {
+		return SOURCE_FILE_NAME.get(getPDOM(), this.address);
+	}
+
+	public void setAnonymous(boolean anonymous) {
+		setFlag(FLG_TYPE_ANONYMOUS, anonymous);
+	}
+
+	public void setIsLocal(boolean local) {
+		setFlag(FLG_TYPE_LOCAL, local);
+	}
+
+	public void setIsMember(boolean member) {
+		setFlag(FLG_TYPE_MEMBER, member);
+	}
+
+	public boolean isAnonymous() {
+		return getFlag(FLG_TYPE_ANONYMOUS);
+	}
+
+	public boolean isLocal() {
+		return getFlag(FLG_TYPE_LOCAL);
+	}
+
+	public boolean isMember() {
+		return getFlag(FLG_TYPE_MEMBER);
+	}
+
+	private void setFlag(byte flagConstant, boolean value) {
+		int oldFlags = FLAGS.get(getPDOM(), this.address);
+		int newFlags =  ((oldFlags & ~flagConstant) | (value ? flagConstant : 0));
+		FLAGS.put(getPDOM(), this.address, (byte)newFlags);
+	}
+
+	private boolean getFlag(byte flagConstant) {
+		return (FLAGS.get(getPDOM(), this.address) & flagConstant) != 0;
+	}
 }
commit 9df473995fc54f9f9d5bba15ae91252393f13558
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Jan 27 13:14:06 2016 -0800

    Bug 481796 - Rename getPDOM() to getNd()
    
    Change-Id: Ibd0e5bca9c27747730c84106f1d31984359212ea
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

12	12	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantArray.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantBoolean.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantByte.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantChar.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantClass.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantDouble.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantEnum.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantFloat.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantInt.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantLong.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantShort.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantString.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
10	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
17	17	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
5	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
5	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeInterface.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
index c859fcd..ad5dec4 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/FieldBackPointerTest.java
@@ -42,19 +42,19 @@ public class FieldBackPointerTest extends BaseTestCase {
 		}
 
 		public void setBp(BackPointerStruct toSet) {
-			FORWARD.put(getPDOM(), this.address, toSet);
+			FORWARD.put(getNd(), this.address, toSet);
 		}
 
 		public BackPointerStruct getBp() {
-			return FORWARD.get(getPDOM(), this.address);
+			return FORWARD.get(getNd(), this.address);
 		}
 
 		public void setOwner(BackPointerStruct owner) {
-			OWNER.put(getPDOM(), this.address, owner);
+			OWNER.put(getNd(), this.address, owner);
 		}
 
 		public BackPointerStruct getOwner() {
-			return OWNER.get(getPDOM(), this.address);
+			return OWNER.get(getNd(), this.address);
 		}
 	}
 
@@ -87,35 +87,35 @@ public class FieldBackPointerTest extends BaseTestCase {
 		}
 
 		public void ensureBackPointerCapacity(int capacity) {
-			BACK.ensureCapacity(getPDOM(), this.address, capacity);
+			BACK.ensureCapacity(getNd(), this.address, capacity);
 		}
 
 		public int getBackPointerCapacity() {
-			return BACK.getCapacity(getPDOM(), this.address);
+			return BACK.getCapacity(getNd(), this.address);
 		}
 
 		public List<ForwardPointerStruct> getBackPointers() {
-			return BACK.asList(getPDOM(), this.address);
+			return BACK.asList(getNd(), this.address);
 		}
 
 		public List<ForwardPointerStruct> getOwned() {
-			return OWNED.asList(getPDOM(), this.address);
+			return OWNED.asList(getNd(), this.address);
 		}
 
 		public int backPointerSize() {
-			return BACK.size(getPDOM(), this.address);
+			return BACK.size(getNd(), this.address);
 		}
 
 		public boolean backPointersAreEmpty() {
-			return BACK.isEmpty(getPDOM(), this.address);
+			return BACK.isEmpty(getNd(), this.address);
 		}
 
 		public boolean ownedPointersAreEmpty() {
-			return OWNED.isEmpty(getPDOM(), this.address);
+			return OWNED.isEmpty(getNd(), this.address);
 		}
 
 		public ForwardPointerStruct getBackPointer(int i) {
-			return BACK.get(getPDOM(), this.address, i);
+			return BACK.get(getNd(), this.address, i);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
index c35461f..783304e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/InheritenceTests.java
@@ -39,11 +39,11 @@ public class InheritenceTests extends BaseTestCase {
 		}
 
 		boolean contains(BaseClass toTest) {
-			return BASE_CLASS_INSTANCES.asList(getPDOM(), this.address).contains(toTest);
+			return BASE_CLASS_INSTANCES.asList(getNd(), this.address).contains(toTest);
 		}
 
 		boolean contains(Reference toTest) {
-			return REFERENCE_INSTANCES.asList(getPDOM(), this.address).contains(toTest);
+			return REFERENCE_INSTANCES.asList(getNd(), this.address).contains(toTest);
 		}
 	}
 
@@ -127,15 +127,15 @@ public class InheritenceTests extends BaseTestCase {
 		}
 
 		public void setBaseClassReference(BaseClass target) {
-			BASE_CLASS_REFERENCE.put(getPDOM(), this.address, target);
+			BASE_CLASS_REFERENCE.put(getNd(), this.address, target);
 		}
 
 		public void setOwner(BaseClass target) {
-			OWNER.put(getPDOM(), this.address, target);
+			OWNER.put(getNd(), this.address, target);
 		}
 
 		public void setSubClassReference(SubClass target) {
-			SUB_CLASS_REFERENCE.put(getPDOM(), this.address, target);
+			SUB_CLASS_REFERENCE.put(getNd(), this.address, target);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
index 8556bff..e79031c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
@@ -77,11 +77,11 @@ public class SearchKeyTests extends BaseTestCase {
 		}
 
 		public void setName(String searchStringA) {
-			NAME.put(getPDOM(), this.address, searchStringA);
+			NAME.put(getNd(), this.address, searchStringA);
 		}
 
 		public void setNickName(String searchStringA) {
-			NICKNAME.put(getPDOM(), this.address, searchStringA);
+			NICKNAME.put(getNd(), this.address, searchStringA);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index b7f93e3..04506b7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -79,7 +79,7 @@ public abstract class NdNode implements IDestructable {
 	 * Invokes the destructor on this node and frees up its memory
 	 */
 	public final void delete() {
-		getPDOM().delete(this.address);
+		getNd().delete(this.address);
 	}
 
 	protected NdNode(Nd pdom, long address) {
@@ -103,7 +103,7 @@ public abstract class NdNode implements IDestructable {
 		return this.pdom.getDB();
 	}
 
-	public Nd getPDOM() {
+	public Nd getNd() {
 		return this.pdom;
 	}
 
@@ -130,7 +130,7 @@ public abstract class NdNode implements IDestructable {
 			return true;
 		if (obj instanceof NdNode) {
 			NdNode other = (NdNode) obj;
-			return getPDOM() == other.getPDOM() && this.address == other.address;
+			return getNd() == other.getNd() && this.address == other.address;
 		}
 
 		return super.equals(obj);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
index 0d35f77..c1d7b98 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
@@ -24,7 +24,7 @@ public class BindingToIndexConverter {
 
 	public BindingToIndexConverter(NdResourceFile resource) {
 		this.resource = resource;
-		this.index = JavaIndex.getIndex(resource.getPDOM());
+		this.index = JavaIndex.getIndex(resource.getNd());
 	}
 
 	public void addBinding(NdTreeNode parent, IBinding binding, IProgressMonitor monitor) {
@@ -108,6 +108,6 @@ public class BindingToIndexConverter {
 	}
 
 	private Nd getPDOM() {
-		return this.resource.getPDOM();
+		return this.resource.getNd();
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 5da5e48..cb4925d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -62,11 +62,11 @@ public class ClassFileToIndexConverter {
 
 	public ClassFileToIndexConverter(NdResourceFile resourceFile) {
 		this.resource = resourceFile;
-		this.index = JavaIndex.getIndex(resourceFile.getPDOM());
+		this.index = JavaIndex.getIndex(resourceFile.getNd());
 	}
 
 	private Nd getPDOM() {
-		return this.resource.getPDOM();
+		return this.resource.getNd();
 	}
 
 	public static IBinaryType getTypeFromClassFile(IClassFile iClassFile, IProgressMonitor monitor)
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
index ec6e484..f9eaf06 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
@@ -47,26 +47,26 @@ public class NdAnnotation extends NdNode {
 	public NdAnnotation(Nd pdom, NdTypeSignature type) {
 		super(pdom);
 
-		ANNOTATION_TYPE.put(getPDOM(), this.address, type);
+		ANNOTATION_TYPE.put(getNd(), this.address, type);
 	}
 
 	public void setParent(NdBinding binding) {
-		PARENT_BINDING.put(getPDOM(), this.address, binding);
+		PARENT_BINDING.put(getNd(), this.address, binding);
 	}
 
 	public void setParent(NdConstantAnnotation constant) {
-		PARENT_CONSTANT.put(getPDOM(), this.address, constant);
+		PARENT_CONSTANT.put(getNd(), this.address, constant);
 	}
 
 	public void setParent(NdComplexTypeSignature signature) {
-		PARENT_TYPE_SIGNATURE.put(getPDOM(), this.address, signature);
+		PARENT_TYPE_SIGNATURE.put(getNd(), this.address, signature);
 	}
 
 	public NdTypeSignature getType() {
-		return ANNOTATION_TYPE.get(getPDOM(), this.address);
+		return ANNOTATION_TYPE.get(getNd(), this.address);
 	}
 
 	public NdBinding getAppliesTo() {
-		return PARENT_BINDING.get(getPDOM(), this.address);
+		return PARENT_BINDING.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
index 08401da..544415a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
@@ -32,32 +32,32 @@ public class NdAnnotationValuePair extends NdNode {
 	}
 
 	public NdAnnotationValuePair(NdAnnotation annotation, char[] name) {
-		super(annotation.getPDOM());
-		Nd pdom = annotation.getPDOM();
+		super(annotation.getNd());
+		Nd pdom = annotation.getNd();
 		APPLIES_TO.put(pdom, this.address, annotation);
 		NAME.put(pdom, this.address, name);
 	}
 
 	public NdAnnotation getAnnotation() {
-		return APPLIES_TO.get(getPDOM(), this.address);
+		return APPLIES_TO.get(getNd(), this.address);
 	}
 
 	public IString getName() {
-		return NAME.get(getPDOM(), this.address);
+		return NAME.get(getNd(), this.address);
 	}
 
 	public void setName(String name) {
-		NAME.put(getPDOM(), this.address, name);
+		NAME.put(getNd(), this.address, name);
 	}
 
 	/**
 	 * Returns the value of this annotation or null if none
 	 */
 	public NdConstant getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 
 	public void setValue(NdConstant value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index 84374dd..6cd7044 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -60,22 +60,22 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	 * Tests whether this binding has one of the flags defined in {@link Flags}
 	 */
 	public boolean hasModifier(int toTest) {
-		return (MODIFIERS.get(getPDOM(), this.address) & toTest) != 0;
+		return (MODIFIERS.get(getNd(), this.address) & toTest) != 0;
 	}
 
 	/**
 	 * Sets the modifiers for this binding (defined in {@link Flags})
 	 */
 	public void setModifiers(int toSet) {
-		MODIFIERS.put(getPDOM(), this.address, toSet);
+		MODIFIERS.put(getNd(), this.address, toSet);
 	}
 
 	public int getModifiers() {
-		return MODIFIERS.get(getPDOM(), this.address);
+		return MODIFIERS.get(getNd(), this.address);
 	}
 
 	public NdAnnotation[] getAnnotations() {
-		int numAnnotations = ANNOTATIONS.size(getPDOM(), this.address);
+		int numAnnotations = ANNOTATIONS.size(getNd(), this.address);
 
 		if (numAnnotations == 0) {
 			return NO_ANNOTATIONS;
@@ -84,7 +84,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		final NdAnnotation[] result = new NdAnnotation[numAnnotations];
 
 		// If we got this far, the pointer to the linked list is non-null
-		ANNOTATIONS.accept(getPDOM(), this.address, new FieldOneToMany.Visitor<NdAnnotation>() {
+		ANNOTATIONS.accept(getNd(), this.address, new FieldOneToMany.Visitor<NdAnnotation>() {
 			@Override
 			public void visit(int index, NdAnnotation toVisit) {
 				result[index] = toVisit;
@@ -462,11 +462,11 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	}
 
 	public void setFile(NdResourceFile file) {
-		FILE.put(getPDOM(), this.address, file);
+		FILE.put(getNd(), this.address, file);
 	}
 
 	public NdResourceFile getFile() {
-		return FILE.get(getPDOM(), this.address);
+		return FILE.get(getNd(), this.address);
 	}
 
 	// @Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index c4e980a..cc97594 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -50,26 +50,26 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 
 	@Override
 	public NdTypeId getRawType() {
-		return RAW_TYPE.get(getPDOM(), this.address);
+		return RAW_TYPE.get(getNd(), this.address);
 	}
 
 	public void setVariableIdentifier(char[] variableIdentifier) {
-		VARIABLE_IDENTIFIER.put(getPDOM(), this.address, variableIdentifier);
+		VARIABLE_IDENTIFIER.put(getNd(), this.address, variableIdentifier);
 	}
 
 	/**
 	 * If this type is a type variable, this returns the variable's identifier.
 	 */
 	public IString getVariableIdentifier() {
-		return VARIABLE_IDENTIFIER.get(getPDOM(), this.address);
+		return VARIABLE_IDENTIFIER.get(getNd(), this.address);
 	}
 
 	public void setRawType(NdTypeId rawType) {
-		RAW_TYPE.put(getPDOM(), this.address, rawType);
+		RAW_TYPE.put(getNd(), this.address, rawType);
 	}
 
 	public void setGenericDeclaringType(NdComplexTypeSignature enclosingType) {
-		DECLARING_TYPE.put(getPDOM(), this.address, enclosingType);
+		DECLARING_TYPE.put(getNd(), this.address, enclosingType);
 	}
 
 	/**
@@ -81,6 +81,6 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 	 * and neither will non-nested classes.
 	 */
 	public NdComplexTypeSignature getGenericDeclaringType() {
-		return DECLARING_TYPE.get(getPDOM(), this.address);
+		return DECLARING_TYPE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
index c655ded..dfbb222 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
@@ -71,6 +71,6 @@ public abstract class NdConstant extends NdNode {
 	}
 
 	public void setParent(NdConstantArray result) {
-		PARENT_ARRAY.put(getPDOM(), this.address, result);
+		PARENT_ARRAY.put(getNd(), this.address, result);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
index 79734db..6f94abe 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
@@ -34,10 +34,10 @@ public final class NdConstantAnnotation extends NdConstant {
 	}
 
 	public void setValue(NdAnnotation value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public NdAnnotation getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantArray.java
index 21f2087..4adb51d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantArray.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantArray.java
@@ -30,6 +30,6 @@ public final class NdConstantArray extends NdConstant {
 	}
 
 	public List<NdConstant> getValue() {
-		return ELEMENTS.asList(getPDOM(), this.address);
+		return ELEMENTS.asList(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantBoolean.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantBoolean.java
index 3f4d2bd..11c277d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantBoolean.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantBoolean.java
@@ -34,10 +34,10 @@ public final class NdConstantBoolean extends NdConstant {
 	}
 
 	public void setValue(boolean value) {
-		VALUE.put(getPDOM(), this.address, value ? (byte)1 : (byte)0);
+		VALUE.put(getNd(), this.address, value ? (byte)1 : (byte)0);
 	}
 
 	public boolean getValue() {
-		return VALUE.get(getPDOM(), this.address) != 0;
+		return VALUE.get(getNd(), this.address) != 0;
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantByte.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantByte.java
index c4a5836..33ac190 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantByte.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantByte.java
@@ -34,10 +34,10 @@ public final class NdConstantByte extends NdConstant {
 	}
 
 	public void setValue(byte value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public byte getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantChar.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantChar.java
index 87bbeb8..bddb704 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantChar.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantChar.java
@@ -34,10 +34,10 @@ public final class NdConstantChar extends NdConstant {
 	}
 
 	public void setValue(char value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public char getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantClass.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantClass.java
index bdbcd00..bec6045 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantClass.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantClass.java
@@ -34,10 +34,10 @@ public final class NdConstantClass extends NdConstant {
 	}
 
 	public void setValue(NdTypeSignature value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public NdTypeSignature getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantDouble.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantDouble.java
index e922749..6d4a172 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantDouble.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantDouble.java
@@ -34,10 +34,10 @@ public final class NdConstantDouble extends NdConstant {
 	}
 
 	public void setValue(double value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public double getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantEnum.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantEnum.java
index ba6e580..6cf87ba 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantEnum.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantEnum.java
@@ -31,21 +31,21 @@ public final class NdConstantEnum extends NdConstant {
 	}
 
 	public static NdConstantEnum create(NdTypeSignature enumType, String enumValue) {
-		NdConstantEnum result = new NdConstantEnum(enumType.getPDOM());
+		NdConstantEnum result = new NdConstantEnum(enumType.getNd());
 		result.setEnumType(enumType);
 		result.setEnumValue(enumValue);
 		return result;
 	}
 
 	public void setEnumType(NdTypeSignature enumType) {
-		ENUM_TYPE.put(getPDOM(), this.address, enumType);
+		ENUM_TYPE.put(getNd(), this.address, enumType);
 	}
 
 	public void setEnumValue(String enumType) {
-		ENUM_VALUE.put(getPDOM(), this.address, enumType);
+		ENUM_VALUE.put(getNd(), this.address, enumType);
 	}
 
 	public NdTypeSignature getValue() {
-		return ENUM_TYPE.get(getPDOM(), this.address);
+		return ENUM_TYPE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantFloat.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantFloat.java
index eea0c1f..20ccab5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantFloat.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantFloat.java
@@ -34,10 +34,10 @@ public final class NdConstantFloat extends NdConstant {
 	}
 
 	public void setValue(float value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public float getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantInt.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantInt.java
index 399e3ed..96117ae 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantInt.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantInt.java
@@ -34,10 +34,10 @@ public final class NdConstantInt extends NdConstant {
 	}
 
 	public void setValue(int value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public int getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantLong.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantLong.java
index fb22b41..a22f3f4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantLong.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantLong.java
@@ -34,10 +34,10 @@ public final class NdConstantLong extends NdConstant {
 	}
 
 	public void setValue(long value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public long getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantShort.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantShort.java
index e08671d..cc52b27 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantShort.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantShort.java
@@ -34,10 +34,10 @@ public final class NdConstantShort extends NdConstant {
 	}
 
 	public void setValue(short value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public short getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantString.java
index 1220fce..0d0f050 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantString.java
@@ -35,10 +35,10 @@ public final class NdConstantString extends NdConstant {
 	}
 
 	public void setValue(String value) {
-		VALUE.put(getPDOM(), this.address, value);
+		VALUE.put(getNd(), this.address, value);
 	}
 
 	public IString getValue() {
-		return VALUE.get(getPDOM(), this.address);
+		return VALUE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index 2a6dac4..0c8c289 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -63,26 +63,26 @@ public class NdMethod extends NdBinding {
 	}
 
 	public NdMethod(NdType parent) {
-		super(parent.getPDOM(), parent.getFile());
+		super(parent.getNd(), parent.getFile());
 	}
 
 	public NdMethodId getMethodId() {
-		return METHOD_ID.get(getPDOM(), this.address);
+		return METHOD_ID.get(getNd(), this.address);
 	}
 
 	public void setDefaultValue(NdConstant value) {
-		DEFAULT_VALUE.put(getPDOM(), this.address, value);
+		DEFAULT_VALUE.put(getNd(), this.address, value);
 	}
 
 	public NdConstant getDefaultValue() {
-		return DEFAULT_VALUE.get(getPDOM(), this.address);
+		return DEFAULT_VALUE.get(getNd(), this.address);
 	}
 
 	public void setReturnType(NdTypeSignature createTypeSignature) {
-		RETURN_TYPE.put(getPDOM(), this.address, createTypeSignature);
+		RETURN_TYPE.put(getNd(), this.address, createTypeSignature);
 	}
 
 	public void setMethodId(NdMethodId methodId) {
-		METHOD_ID.put(getPDOM(), this.address, methodId);
+		METHOD_ID.put(getNd(), this.address, methodId);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
index 14b14a6..ee9f430 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
@@ -25,10 +25,10 @@ public class NdMethodException extends NdNode {
 	}
 
 	public NdMethodException(NdMethod method, NdTypeSignature createTypeSignature) {
-		super(method.getPDOM());
+		super(method.getNd());
 
-		PARENT.put(getPDOM(), this.address, method);
-		EXCEPTION_TYPE.put(getPDOM(), this.address, createTypeSignature);
+		PARENT.put(getNd(), this.address, method);
+		EXCEPTION_TYPE.put(getNd(), this.address, createTypeSignature);
 	}
 
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
index c6e6a27..31a6714 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
@@ -63,7 +63,7 @@ public class NdMethodId extends NdNode {
 	}
 
 	public List<NdType> getDeclaredTypes() {
-		return DECLARED_TYPES.asList(getPDOM(), this.address);
+		return DECLARED_TYPES.asList(getNd(), this.address);
 	}
 
 	/**
@@ -71,6 +71,6 @@ public class NdMethodId extends NdNode {
 	 * followed by the method descriptor. For example, "Lorg/eclipse/MyClass#foo()Ljava/lang/Object;V"
 	 */
 	public IString getMethodName() {
-		return METHOD_NAME.get(getPDOM(), this.address);
+		return METHOD_NAME.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
index e8ef09b..02c0c30 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
@@ -27,13 +27,13 @@ public class NdMethodParameter extends NdNode {
 	}
 
 	public NdMethodParameter(NdMethod parent, NdTypeSignature argumentType) {
-		super(parent.getPDOM());
+		super(parent.getNd());
 
-		PARENT.put(getPDOM(), this.address, parent);
-		ARGUMENT_TYPE.put(getPDOM(), this.address, argumentType);
+		PARENT.put(getNd(), this.address, parent);
+		ARGUMENT_TYPE.put(getNd(), this.address, argumentType);
 	}
 
 	public void setName(char[] name) {
-		NAME.put(getPDOM(), this.address, name);
+		NAME.put(getNd(), this.address, name);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 605bc73..56dffd9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -60,14 +60,14 @@ public class NdResourceFile extends NdTreeNode {
 	 */
 	public boolean isInIndex() {
 		try {
-			Nd pdom = getPDOM();
+			Nd pdom = getNd();
 			// In the common case where the resource file was deleted and the memory hasn't yet been reused,
 			// this will fail.
 			if (NODE_TYPE.get(pdom, this.address) != pdom.getNodeType(getClass())) {
 				return false;
 			}
 
-			char[] filename = FILENAME.get(getPDOM(), this.address).getChars();
+			char[] filename = FILENAME.get(getNd(), this.address).getChars();
 
 			NdResourceFile result = JavaIndex.FILES.findBest(pdom, Database.DATA_AREA,
 					SearchCriteria.create(filename), new IResultRank() {
@@ -90,11 +90,11 @@ public class NdResourceFile extends NdTreeNode {
 	}
 
 	public IString getFilename() {
-		return FILENAME.get(getPDOM(), this.address);
+		return FILENAME.get(getNd(), this.address);
 	}
 
 	public void setFilename(String filename) {
-		FILENAME.put(getPDOM(), this.address, filename);
+		FILENAME.put(getNd(), this.address, filename);
 	}
 
 	public FileFingerprint getFingerprint() {
@@ -105,20 +105,20 @@ public class NdResourceFile extends NdTreeNode {
 	}
 
 	private long getHashcodeLastScanned() {
-		return HASHCODE_LAST_SCANNED.get(getPDOM(), this.address);
+		return HASHCODE_LAST_SCANNED.get(getNd(), this.address);
 	}
 
 	public long getTimeLastScanned() {
-		return TIME_LAST_SCANNED.get(getPDOM(), this.address);
+		return TIME_LAST_SCANNED.get(getNd(), this.address);
 	}
 
 	public long getSizeLastScanned() {
-		return SIZE_LAST_SCANNED.get(getPDOM(), this.address);
+		return SIZE_LAST_SCANNED.get(getNd(), this.address);
 	}
 
 	public void setFingerprint(FileFingerprint newFingerprint) {
-		TIME_LAST_SCANNED.put(getPDOM(), this.address, newFingerprint.getTime());
-		HASHCODE_LAST_SCANNED.put(getPDOM(), this.address, newFingerprint.getHash());
-		SIZE_LAST_SCANNED.put(getPDOM(), this.address, newFingerprint.getSize());
+		TIME_LAST_SCANNED.put(getNd(), this.address, newFingerprint.getTime());
+		HASHCODE_LAST_SCANNED.put(getNd(), this.address, newFingerprint.getHash());
+		SIZE_LAST_SCANNED.put(getNd(), this.address, newFingerprint.getSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
index 1f0ae07..b862cfb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
@@ -54,9 +54,9 @@ public abstract class NdTreeNode extends NdNode {
 	 */
 	@SuppressWarnings("unchecked")
 	public <T extends NdTreeNode> T getAncestorOfType(Class<T> ancestorType) {
-		long targetType = getPDOM().getNodeType(ancestorType);
+		long targetType = getNd().getNodeType(ancestorType);
 
-		Nd pdom = getPDOM();
+		Nd pdom = getNd();
 		long current = PARENT.getAddress(pdom, this.address);
 
 		while (current != 0) {
@@ -81,7 +81,7 @@ public abstract class NdTreeNode extends NdNode {
 	}
 
 	NdTreeNode getParentNode() {
-		return PARENT.get(getPDOM(), this.address);
+		return PARENT.get(getNd(), this.address);
 	}
 
 	public NdBinding getParentBinding() throws IndexException {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 5190b2a..e56f341 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -80,68 +80,68 @@ public class NdType extends NdBinding {
 	}
 
 	public NdTypeId getTypeId() {
-		return TYPENAME.get(getPDOM(), this.address);
+		return TYPENAME.get(getNd(), this.address);
 	}
 
 	public void setTypeId(NdTypeId typeId) {
-		TYPENAME.put(getPDOM(), this.address, typeId);
+		TYPENAME.put(getNd(), this.address, typeId);
 	}
 
 	public long getResourceAddress() {
-		return FILE.getAddress(getPDOM(), this.address);
+		return FILE.getAddress(getNd(), this.address);
 	}
 
 	public void setSuperclass(NdTypeSignature superclassTypeName) {
-		SUPERCLASS.put(getPDOM(), this.address, superclassTypeName);
+		SUPERCLASS.put(getNd(), this.address, superclassTypeName);
 	}
 
 	public NdTypeSignature getSuperclass() {
-		return SUPERCLASS.get(getPDOM(), this.address);
+		return SUPERCLASS.get(getNd(), this.address);
 	}
 
 	public List<NdTypeInterface> getInterfaces() {
-		return INTERFACES.asList(getPDOM(), this.address);
+		return INTERFACES.asList(getNd(), this.address);
 	}
 
 	public NdResourceFile getResourceFile() {
-		return FILE.get(getPDOM(), this.address);
+		return FILE.get(getNd(), this.address);
 	}
 
 	public void setDeclaringMethod(NdMethodId createMethodId) {
-		DECLARING_METHOD.put(getPDOM(), this.address, createMethodId);
+		DECLARING_METHOD.put(getNd(), this.address, createMethodId);
 	}
 
 	/**
 	 * @param createTypeIdFromBinaryName
 	 */
 	public void setDeclaringType(NdTypeId createTypeIdFromBinaryName) {
-		DECLARING_TYPE.put(getPDOM(), this.address, createTypeIdFromBinaryName);
+		DECLARING_TYPE.put(getNd(), this.address, createTypeIdFromBinaryName);
 	}
 
 	public NdTypeId getDeclaringType() {
-		return DECLARING_TYPE.get(getPDOM(), this.address);
+		return DECLARING_TYPE.get(getNd(), this.address);
 	}
 
 	/**
 	 * Sets the missing type names (if any) for this class. The names are encoded in a comma-separated list.
 	 */
 	public void setMissingTypeNames(char[] contents) {
-		MISSING_TYPE_NAMES.put(getPDOM(), this.address, contents);
+		MISSING_TYPE_NAMES.put(getNd(), this.address, contents);
 	}
 
 	/**
 	 * Returns the missing type names as a comma-separated list
 	 */
 	public IString getMissingTypeNames() {
-		return MISSING_TYPE_NAMES.get(getPDOM(), this.address);
+		return MISSING_TYPE_NAMES.get(getNd(), this.address);
 	}
 
 	public void setSourceFileName(char[] sourceFileName) {
-		SOURCE_FILE_NAME.put(getPDOM(), this.address, sourceFileName);
+		SOURCE_FILE_NAME.put(getNd(), this.address, sourceFileName);
 	}
 
 	public IString getSourceFileName() {
-		return SOURCE_FILE_NAME.get(getPDOM(), this.address);
+		return SOURCE_FILE_NAME.get(getNd(), this.address);
 	}
 
 	public void setAnonymous(boolean anonymous) {
@@ -169,12 +169,12 @@ public class NdType extends NdBinding {
 	}
 
 	private void setFlag(byte flagConstant, boolean value) {
-		int oldFlags = FLAGS.get(getPDOM(), this.address);
+		int oldFlags = FLAGS.get(getNd(), this.address);
 		int newFlags =  ((oldFlags & ~flagConstant) | (value ? flagConstant : 0));
-		FLAGS.put(getPDOM(), this.address, (byte)newFlags);
+		FLAGS.put(getNd(), this.address, (byte)newFlags);
 	}
 
 	private boolean getFlag(byte flagConstant) {
-		return (FLAGS.get(getPDOM(), this.address) & flagConstant) != 0;
+		return (FLAGS.get(getNd(), this.address) & flagConstant) != 0;
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
index 0db32b9..0a6c324 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
@@ -46,22 +46,22 @@ public class NdTypeArgument extends NdNode {
 	 * @param wildcard
 	 */
 	public void setWildcard(int wildcard) {
-		WILDCARD.put(getPDOM(), this.address, (byte) wildcard);
+		WILDCARD.put(getNd(), this.address, (byte) wildcard);
 	}
 
 	public void setType(NdTypeSignature typeSignature) {
-		TYPE_SIGNATURE.put(getPDOM(), this.address, typeSignature);
+		TYPE_SIGNATURE.put(getNd(), this.address, typeSignature);
 	}
 
 	public int getWildcard() {
-		return WILDCARD.get(getPDOM(), this.address);
+		return WILDCARD.get(getNd(), this.address);
 	}
 
 	public NdComplexTypeSignature getParent() {
-		return PARENT.get(getPDOM(), this.address);
+		return PARENT.get(getNd(), this.address);
 	}
 
 	public NdTypeSignature getType() {
-		return TYPE_SIGNATURE.get(getPDOM(), this.address);
+		return TYPE_SIGNATURE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
index a6727ef..0e5abec 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
@@ -31,17 +31,17 @@ public class NdTypeBound extends NdNode {
 	}
 
 	public NdTypeBound(NdTypeParameter parent, NdTypeSignature signature) {
-		super(parent.getPDOM());
+		super(parent.getNd());
 
-		PARENT.put(getPDOM(), this.address, parent);
-		TYPE.put(getPDOM(), this.address, signature);
+		PARENT.put(getNd(), this.address, parent);
+		TYPE.put(getNd(), this.address, signature);
 	}
 
 	public NdTypeParameter getParent() {
-		return PARENT.get(getPDOM(), this.address);
+		return PARENT.get(getNd(), this.address);
 	}
 
 	public NdTypeSignature getType() {
-		return TYPE.get(getPDOM(), this.address);
+		return TYPE.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 44ce82c..81f1f3e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -47,9 +47,9 @@ public class NdTypeId extends NdTypeSignature {
 	}
 
 	public NdType findTypeByResourceAddress(long resourceAddress) {
-		int size = TYPES.size(getPDOM(), this.address);
+		int size = TYPES.size(getNd(), this.address);
 		for (int idx = 0; idx < size; idx++) {
-			NdType next = TYPES.get(getPDOM(), this.address, idx);
+			NdType next = TYPES.get(getNd(), this.address, idx);
 
 			if (next.getResourceAddress() == resourceAddress) {
 				return next;
@@ -59,11 +59,11 @@ public class NdTypeId extends NdTypeSignature {
 	}
 
 	public List<NdType> getTypes() {
-		return TYPES.asList(getPDOM(), this.address);
+		return TYPES.asList(getNd(), this.address);
 	}
 
 	public IString getFieldDescriptor() {
-		return FIELD_DESCRIPTOR.get(getPDOM(), this.address);
+		return FIELD_DESCRIPTOR.get(getNd(), this.address);
 	}
 
 	public char[] getBinaryName() {
@@ -71,7 +71,7 @@ public class NdTypeId extends NdTypeSignature {
 	}
 
 	public IString getSimpleName() {
-		return SIMPLE_NAME.get(getPDOM(), this.address);
+		return SIMPLE_NAME.get(getNd(), this.address);
 	}
 
 	public char[] getSimpleNameCharArray() {
@@ -93,7 +93,7 @@ public class NdTypeId extends NdTypeSignature {
 			return;
 		}
 		this.fName = name;
-		SIMPLE_NAME.put(getPDOM(), this.address, name);
+		SIMPLE_NAME.put(getNd(), this.address, name);
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeInterface.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeInterface.java
index a1c7aeb..6244c03 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeInterface.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeInterface.java
@@ -48,10 +48,10 @@ public class NdTypeInterface extends NdNode {
 	}
 
 	public NdType getImplementation() {
-		return APPLIES_TO.get(getPDOM(), this.address);
+		return APPLIES_TO.get(getNd(), this.address);
 	}
 
 	public NdTypeSignature getInterface() {
-		return IMPLEMENTS.get(getPDOM(), this.address);
+		return IMPLEMENTS.get(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
index 8da96e9..8f6fa4b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
@@ -34,9 +34,9 @@ public class NdTypeParameter extends NdNode {
 	}
 
 	public NdTypeParameter(NdBinding parent, char[] identifier) {
-		super(parent.getPDOM());
+		super(parent.getNd());
 
-		PARENT.put(getPDOM(), this.address, parent);
-		IDENTIFIER.put(getPDOM(), this.address, identifier);
+		PARENT.put(getNd(), this.address, parent);
+		IDENTIFIER.put(getNd(), this.address, identifier);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index f2c43ba..fe66a38 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -76,11 +76,11 @@ public abstract class NdTypeSignature extends NdNode {
 	}
 
 	public List<NdType> getSubclasses() {
-		return SUBCLASSES.asList(getPDOM(), this.address);
+		return SUBCLASSES.asList(getNd(), this.address);
 	}
 
 	public List<NdTypeInterface> getImplementations() {
-		return IMPLEMENTATIONS.asList(getPDOM(), this.address);
+		return IMPLEMENTATIONS.asList(getNd(), this.address);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index 79a4d4a..df12ff5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -54,9 +54,9 @@ public class NdVariable extends NdBinding {
 	}
 
 	public NdVariable(NdBinding parent) {
-		super(parent.getPDOM(), parent.getFile());
+		super(parent.getNd(), parent.getFile());
 
-		PARENT.put(getPDOM(), this.address, parent);
+		PARENT.put(getNd(), this.address, parent);
 	}
 //
 //	private boolean hasVariableFlag(int toTest) {
@@ -69,18 +69,18 @@ public class NdVariable extends NdBinding {
 //	}
 
 	public void setName(char[] name) {
-		NAME.put(getPDOM(), this.address, name);
+		NAME.put(getNd(), this.address, name);
 	}
 
 	public String getName() {
-		return NAME.get(getPDOM(), this.address).getString();
+		return NAME.get(getNd(), this.address).getString();
 	}
 
 	public void setType(NdTypeSignature typeId) {
-		TYPE.put(getPDOM(), this.address, typeId);
+		TYPE.put(getNd(), this.address, typeId);
 	}
 
 	public void setConstant(NdConstant constant) {
-		CONSTANT.put(getPDOM(), this.address, constant);
+		CONSTANT.put(getNd(), this.address, constant);
 	}
 }
commit 00a1b2826e14b716c5fa5d219a15e733f3cbc20a
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Jan 28 10:47:56 2016 -0800

    Bug 481796 - Rename getPDOM() to getNd()
    
    Change-Id: I979c16ae37f24040ab6703523774b3f2049293f5
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
14	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
8	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index 2057694..81b72d7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -486,7 +486,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 		IPathRequestor pathRequestor, int waitingPolicy, IProgressMonitor progressMonitor) {
 	SubMonitor subMonitor = SubMonitor.convert(progressMonitor);
 	JavaIndex index = JavaIndex.getIndex();
-	Nd pdom = index.getPDOM();
+	Nd pdom = index.getNd();
 	char[] fieldDefinition = JavaNames.fullyQualifiedNameToFieldDescriptor(type.getFullyQualifiedName().toCharArray());
 	pdom.acquireReadLock();
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
index 7580c69..182e73b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdLinkedList.java
@@ -48,7 +48,7 @@ public final class NdLinkedList<T> {
 	public T addMember(short metadataBits) throws IndexException {
 		long address = this.rawList.addMember(metadataBits);
 
-		return this.elementFactory.create(this.rawList.getPDOM(), address);
+		return this.elementFactory.create(this.rawList.getNd(), address);
 	}
 
 	public void accept(final ILinkedListVisitor<T> visitor) throws IndexException {
@@ -57,7 +57,7 @@ public final class NdLinkedList<T> {
 		localRawList.accept(new NdRawLinkedList.ILinkedListVisitor() {
 			@Override
 			public void visit(long address, short metadataBits, int index) throws IndexException {
-				visitor.visit(localElementFactory.create(localRawList.getPDOM(),
+				visitor.visit(localElementFactory.create(localRawList.getNd(),
 						address), metadataBits, index);
 			}
 		});
@@ -110,7 +110,7 @@ public final class NdLinkedList<T> {
 	 */
 	protected void destruct() {
 		if (this.elementFactory.hasDestructor()) {
-			final Nd pdom = this.rawList.getPDOM();
+			final Nd pdom = this.rawList.getNd();
 			this.rawList.accept(new NdRawLinkedList.ILinkedListVisitor() {
 				@Override
 				public void visit(long address, short metadataBits, int index) throws IndexException {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
index 9d5efc9..eecef43 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdRawLinkedList.java
@@ -101,7 +101,7 @@ public class NdRawLinkedList {
 		return Database.PTR_SIZE + elementRecordSize * recordsPerBlock + metadataSize;
 	}
 
-	public Nd getPDOM() {
+	public Nd getNd() {
 		return this.dom;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
index c1d7b98..83b188b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/BindingToIndexConverter.java
@@ -79,7 +79,7 @@ public class BindingToIndexConverter {
 		NdType type = name.findTypeByResourceAddress(this.resource.address);
 
 		if (type == null) {
-			type = new NdType(getPDOM(), this.resource);
+			type = new NdType(getNd(), this.resource);
 		}
 
 		type.setTypeId(name);
@@ -91,7 +91,7 @@ public class BindingToIndexConverter {
 		}
 
 		for (ITypeBinding next : binding.getInterfaces()) {
-			new NdTypeInterface(getPDOM(), type, makeTypeId(next));
+			new NdTypeInterface(getNd(), type, makeTypeId(next));
 		}
 
 		return type;
@@ -107,7 +107,7 @@ public class BindingToIndexConverter {
 		return this.index.createTypeId(JavaNames.binaryNameToFieldDescriptor(forBinding.getBinaryName().toCharArray()));
 	}
 
-	private Nd getPDOM() {
+	private Nd getNd() {
 		return this.resource.getNd();
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index cb4925d..504edd5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -65,7 +65,7 @@ public class ClassFileToIndexConverter {
 		this.index = JavaIndex.getIndex(resourceFile.getNd());
 	}
 
-	private Nd getPDOM() {
+	private Nd getNd() {
 		return this.resource.getNd();
 	}
 
@@ -130,7 +130,7 @@ public class ClassFileToIndexConverter {
 		NdType type = name.findTypeByResourceAddress(this.resource.address);
 
 		if (type == null) {
-			type = new NdType(getPDOM(), this.resource);
+			type = new NdType(getNd(), this.resource);
 		}
 
 		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
@@ -159,7 +159,7 @@ public class ClassFileToIndexConverter {
 			// this characteristic. In such cases, we take what's in the generic signature and discard what's in the
 			// interfaces list.
 			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
-			new NdTypeInterface(getPDOM(), type,
+			new NdTypeInterface(getNd(), type,
 					createTypeSignature(typeAnnotations.toSupertype(interfaceIdx, interfaceSpec), signatureWrapper));
 			interfaceIdx++;
 		}
@@ -301,7 +301,7 @@ public class ClassFileToIndexConverter {
 			}
 		}
 
-		variable.setConstant(NdConstant.create(getPDOM(), nextField.getConstant()));
+		variable.setConstant(NdConstant.create(getNd(), nextField.getConstant()));
 		variable.setModifiers(nextField.getModifiers());
 		SignatureWrapper nextTypeSignature = GenericSignatures.getGenericSignatureFor(nextField);
 
@@ -380,7 +380,7 @@ public class ClassFileToIndexConverter {
 			case 'T': {
 				// Skip the 'T' prefix
 				wrapper.start++;
-				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getPDOM());
+				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
 				typeSignature.setVariableIdentifier(wrapper.nextWord());
 				attachAnnotations(typeSignature, annotations);
 				// Skip the trailing semicolon
@@ -392,9 +392,9 @@ public class ClassFileToIndexConverter {
 				wrapper.start++;
 				// We encode arrays as though they were a one-argument generic type called '[' whose element
 				// type is the generic argument.
-				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getPDOM());
+				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
 				typeSignature.setRawType(createTypeIdFromFieldDescriptor(new char[] { '[' }));
-				NdTypeArgument typeArgument = new NdTypeArgument(getPDOM(), typeSignature);
+				NdTypeArgument typeArgument = new NdTypeArgument(getNd(), typeSignature);
 				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
 				typeArgument.setType(elementType);
 				attachAnnotations(typeSignature, annotations);
@@ -455,7 +455,7 @@ public class ClassFileToIndexConverter {
 		// set on a PDOMComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
 		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
 		if (annotationList.length != 0 || hasGenericArguments || parentTypeOrNull != null || isRawTypeWithNestedClass) {
-			NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getPDOM());
+			NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
 			typeSignature.setRawType(rawType);
 			attachAnnotations(typeSignature, annotations);
 
@@ -463,7 +463,7 @@ public class ClassFileToIndexConverter {
 				wrapper.start++;
 				short argumentIndex = 0;
 				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
-					NdTypeArgument typeArgument = new NdTypeArgument(getPDOM(), typeSignature);
+					NdTypeArgument typeArgument = new NdTypeArgument(getNd(), typeSignature);
 
 					switch (genericSignature[wrapper.start]) {
 						case '+': {
@@ -567,7 +567,7 @@ public class ClassFileToIndexConverter {
 	}
 
 	private NdAnnotation createAnnotation(IBinaryAnnotation next) {
-		NdAnnotation result = new NdAnnotation(getPDOM(), createTypeIdFromBinaryName(next.getTypeName()));
+		NdAnnotation result = new NdAnnotation(getNd(), createTypeIdFromBinaryName(next.getTypeName()));
 
 		IBinaryElementValuePair[] pairs = next.getElementValuePairs();
 
@@ -604,19 +604,19 @@ public class ClassFileToIndexConverter {
 		if (value instanceof Constant) {
 			Constant constant = (Constant) value;
 
-			return NdConstant.create(getPDOM(), constant);
+			return NdConstant.create(getNd(), constant);
 		} else if (value instanceof ClassSignature) {
 			ClassSignature signature = (ClassSignature) value;
 
 			char[] binaryName = JavaNames.binaryNameToFieldDescriptor(signature.getTypeName());
 			NdTypeSignature typeId = this.index.createTypeId(binaryName);
-			return NdConstantClass.create(getPDOM(), typeId);
+			return NdConstantClass.create(getNd(), typeId);
 		} else if (value instanceof IBinaryAnnotation) {
 			IBinaryAnnotation binaryAnnotation = (IBinaryAnnotation) value;
 
-			return NdConstantAnnotation.create(getPDOM(), createAnnotation(binaryAnnotation));
+			return NdConstantAnnotation.create(getNd(), createAnnotation(binaryAnnotation));
 		} else if (value instanceof Object[]) {
-			NdConstantArray result = new NdConstantArray(getPDOM());
+			NdConstantArray result = new NdConstantArray(getNd());
 			Object[] array = (Object[]) value;
 
 			for (Object next : array) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 4a2cfac..6e3cd2c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -110,7 +110,7 @@ public class JavaIndex {
 		return new NdTypeId(this.pdom, fieldDescriptor);
 	}
 
-	public Nd getPDOM() {
+	public Nd getNd() {
 		return this.pdom;
 	}
 
@@ -220,7 +220,7 @@ public class JavaIndex {
 //		if (existingType != null) {
 //			return existingType;
 //		}
-//		return new PDOMMethodId(getPDOM(), new String(binaryName));
+//		return new PDOMMethodId(getNd(), new String(binaryName));
 //	}
 //
 //	public PDOMMethodId createMethodId(char[] binaryName) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index 6cd7044..0180dbc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -21,7 +21,7 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
  * Base class for bindings in the PDOM.
- * 
+ *
  * @since 3.12
  */
 public abstract class NdBinding extends NdNode implements IAdaptable {
@@ -104,10 +104,10 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		// the PDOMBinding is deleted. However, PDOMBinding's don't get deleted, so there is no way
 		// to trigger deleting of the tags. If the implementation is changed so that PDOMBindings
 		// do get deleted, then it should call:
-		// PDOMTagIndex.setTags(getPDOM(), pdomBinding.address, Collections.<ITag>emptyList());
+		// PDOMTagIndex.setTags(getNd(), pdomBinding.address, Collections.<ITag>emptyList());
 		// to clear out all tags for the binding.
 		// if (adapter.isAssignableFrom(ITagReader.class))
-		// return new PDOMTaggable(getPDOM(), getRecord());
+		// return new PDOMTaggable(getNd(), getRecord());
 
 		return null;
 	}
@@ -167,7 +167,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// // contexts that don't know which type of list they are iterating over. E.g., this is
 	// // used when deleting names from a PDOMFile.
 	// if (!getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).add(name);
+	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).add(name);
 	// return;
 	// }
 	//
@@ -209,7 +209,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// * not return null.
 	// */
 	// public IPDOMIterator<PDOMName> getExternalReferences() throws IndexException {
-	// return new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).getIterator();
+	// return new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).getIterator();
 	// }
 	//
 	// /**
@@ -220,7 +220,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// if (linkage.equals(getLinkage())) {
 	// setFirstReference(name);
 	// } else {
-	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).setFirstReference(linkage, name);
+	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).setFirstReference(linkage, name);
 	// }
 	// }
 	//
@@ -230,7 +230,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	// // used when deleting names from a PDOMFile.
 	// if (name != null
 	// && !getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getPDOM(), address + FIRST_EXTREF_OFFSET).add(name);
+	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).add(name);
 	// return;
 	// }
 	//
@@ -305,7 +305,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 	//
 	// @Override
 	// public IIndexFragment getFragment() {
-	// return getPDOM();
+	// return getNd();
 	// }
 	// /** For debug purposes only. */
 	// @Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index e56f341..2f49e6d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -75,7 +75,7 @@ public class NdType extends NdBinding {
 	 */
 	public void acceptUncached(IPDOMVisitor visitor) throws CoreException {
 		super.accept(visitor);
-//		PDOMRawLinkedList list = new PDOMRawLinkedList(getPDOM(), this.address + MEMBERLIST);
+//		PDOMRawLinkedList list = new PDOMRawLinkedList(getNd(), this.address + MEMBERLIST);
 //		list.accept(visitor);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index df12ff5..c0b3dc6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -60,12 +60,12 @@ public class NdVariable extends NdBinding {
 	}
 //
 //	private boolean hasVariableFlag(int toTest) {
-//		return (VARIABLE_FLAGS.get(getPDOM(), this.address) & toTest) != 0;
+//		return (VARIABLE_FLAGS.get(getNd(), this.address) & toTest) != 0;
 //	}
 //
 //	private void setVariableFlag(int toSet) {
-//		int newFlags = VARIABLE_FLAGS.get(getPDOM(), this.address) | toSet;
-//		VARIABLE_FLAGS.put(getPDOM(), this.address, (short)newFlags);
+//		int newFlags = VARIABLE_FLAGS.get(getNd(), this.address) | toSet;
+//		VARIABLE_FLAGS.put(getNd(), this.address, (short)newFlags);
 //	}
 
 	public void setName(char[] name) {
commit 2fecc0d8aacfd570541b76a25fd41afbb2f6904e
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Jan 28 12:13:55 2016 -0800

    Bug 481796 - Remove unnecessary code.
    
    Change-Id: I6c6c643fef2d8c1d8a81078fd915a89b939fe001
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

0	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 9bd5f67..db19936 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -32,8 +32,6 @@ import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IParent;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.ASTParser;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.java.FileFingerprint;
@@ -252,10 +250,6 @@ public final class Indexer {
 		List<IClassFile> classFiles = getClassFiles(bindableElements);
 		IJavaProject javaProject = element.getJavaProject();
 
-		ASTParser parser = ASTParser.newParser(AST.JLS8);
-		parser.setProject(javaProject);
-		parser.setResolveBindings(true);
-
 		subMonitor.setWorkRemaining(classFiles.size());
 
 		int classesIndexed = 0;
commit 472be6f08a488fae0d21db79ad13712e1c465b9c
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Fri Jan 29 12:34:54 2016 -0800

    Bug 481796 - Work on the type hierarchy view.
    
    - Add type parameters to the hierarchy view's data.
    - Record the workspace path of all resource files.
    - Fix bug where IndexBasedHierarchyBuilder wasn't recording the eclosing
      type name correctly.
    - Add source names to the index.
    - Fix bug in the encoding of generic type argument wildcards in the index
    - Add a preference (org.eclipse.jdt.ui/enableNewJavaIndex)
    
    Change-Id: I6c6c643fef2d8c1d8a81078fd915a89b939fe001
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

11	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
2	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
4	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
109	31	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
7	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
28	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
19	379	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
55	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
57	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
27	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
11	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
6	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
11	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
19	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
9	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
46	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index 81b72d7..6e0758e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -22,6 +22,8 @@ import java.util.Set;
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.SubMonitor;
@@ -490,6 +492,8 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 	char[] fieldDefinition = JavaNames.fullyQualifiedNameToFieldDescriptor(type.getFullyQualifiedName().toCharArray());
 	pdom.acquireReadLock();
 
+	IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+
 	try {
 		NdTypeId foundType = index.findType(fieldDefinition);
 
@@ -504,15 +508,16 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 
 		while (!typesToVisit.isEmpty()) {
 			NdType nextType = typesToVisit.removeFirst();
+			NdTypeId typeId = nextType.getTypeId();
 
-			String typePath = new String(JavaNames.getIndexPathFor(nextType));
+			String typePath = new String(JavaNames.getIndexPathFor(nextType, root));
 			if (!scope2.encloses(typePath)) {
 				continue;
 			}
 
 			subMonitor.setWorkRemaining(Math.max(typesToVisit.size(), 10)).split(1);
 
-			boolean isLocalClass = nextType.getDeclaringType() != null;
+			boolean isLocalClass = nextType.isLocal() || nextType.isAnonymous();
 			pathRequestor.acceptPath(typePath, isLocalClass);
 
 			HierarchyBinaryType binaryType = (HierarchyBinaryType)binariesFromIndexMatches2.get(typePath);
@@ -521,7 +526,7 @@ private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope sc
 				binariesFromIndexMatches2.put(typePath, binaryType);
 			}
 
-			for (NdType subType : nextType.getTypeId().getSubTypes()) {
+			for (NdType subType : typeId.getSubTypes()) {
 				if (!discoveredTypes.contains(subType)) {
 					discoveredTypes.add(subType);
 					typesToVisit.add(subType);
@@ -537,13 +542,12 @@ private static HierarchyBinaryType createBinaryTypeFrom(NdType type) {
 	char[] enclosingTypeName = null;
 	NdTypeSignature enclosingType = type.getDeclaringType();
 	if (enclosingType != null) {
-		enclosingTypeName = enclosingType.getRawType().getSimpleName().getChars();
+		enclosingTypeName = enclosingType.getRawType().getBinaryName();
 	}
-	//final char[][] typeParameterSignatures;
+	char[][] typeParameters = type.getTypeParameterSignatures();
 	NdTypeId typeId = type.getTypeId();
 	HierarchyBinaryType result = new HierarchyBinaryType(type.getModifiers(), typeId.getBinaryName(),
-			typeId.getSimpleName().getChars(), enclosingTypeName, null);
-	// TODO(sxenos): Fill in the correct generic signature rather than passing null here
+		type.getSourceName(), enclosingTypeName, typeParameters.length == 0 ? null : typeParameters);
 
 	NdTypeSignature superClass = type.getSuperclass();
 	if (superClass != null) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index 04506b7..a528e32 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -16,9 +16,8 @@ import org.eclipse.jdt.internal.core.nd.field.FieldShort;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
- * This is a basic node in the PDOM database.
- * PDOM nodes form a multi-root tree.
- * This class managed the parent pointer.
+ * This is a basic node in the network database.
+ *
  * @since 3.12
  */
 public abstract class NdNode implements IDestructable {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 504edd5..fdd82f9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -194,6 +194,10 @@ public class ClassFileToIndexConverter {
 		type.setIsLocal(binaryType.isLocal());
 		type.setIsMember(binaryType.isMember());
 
+		if (binaryType.isLocal()) {
+			type.setInnerTypeSourceName(binaryType.getSourceName());
+		}
+
 		return type;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index db19936..3c2d034 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -8,6 +8,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
 
@@ -38,6 +39,7 @@ import org.eclipse.jdt.internal.core.nd.java.FileFingerprint;
 import org.eclipse.jdt.internal.core.nd.java.FileFingerprint.FingerprintTestResult;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
+import org.eclipse.jdt.internal.core.nd.java.NdWorkspaceLocation;
 
 public final class Indexer {
 	private Nd pdom;
@@ -70,47 +72,87 @@ public final class Indexer {
 		Package.logInfo("Indexer running rescan"); //$NON-NLS-1$
 
 		// Gather all the IPackageFragmentRoots in the workspace
-		List<IJavaElement> allRoots = getAllIndexableObjectsInWorkspace(subMonitor.split(3));
+		List<IJavaElement> unfilteredRoots = getAllIndexableObjectsInWorkspace(subMonitor.split(3));
 
-		int totalRoots = allRoots.size();
+		int totalRoots = unfilteredRoots.size();
 		// Remove all duplicate roots (jars which are referenced by more than one project)
-		allRoots = removeDuplicatePaths(allRoots);
+		Map<IPath, List<IJavaElement>> allRoots = removeDuplicatePaths(unfilteredRoots);
 
 		long startGarbageCollectionNs = System.nanoTime();
 
 		// Remove all files in the index which aren't referenced in the workspace
-		cleanGarbage(allRoots, subMonitor.split(4));
+		cleanGarbage(allRoots.keySet(), subMonitor.split(4));
 
 		long startFingerprintTestNs = System.nanoTime();
 
-		Map<IJavaElement, FingerprintTestResult> fingerprints = testFingerprints(allRoots, subMonitor.split(7));
-		List<IJavaElement> rootsWithChanges = getRootsThatHaveChanged(allRoots, fingerprints);
+		Map<IPath, FingerprintTestResult> fingerprints = testFingerprints(allRoots.keySet(), subMonitor.split(7));
+		Set<IPath> rootsWithChanges = new HashSet<>(getRootsThatHaveChanged(allRoots.keySet(), fingerprints));
 
 		long startIndexingNs = System.nanoTime();
 
 		int classesIndexed = 0;
-		SubMonitor loopMonitor = subMonitor.split(85).setWorkRemaining(rootsWithChanges.size());
-		for (IJavaElement next : rootsWithChanges) {
-			classesIndexed += rescanArchive(next, fingerprints.get(next).getNewFingerprint(), loopMonitor.split(1));
+		SubMonitor loopMonitor = subMonitor.split(80).setWorkRemaining(rootsWithChanges.size());
+		for (IPath next : rootsWithChanges) {
+			classesIndexed += rescanArchive(next, allRoots.get(next), fingerprints.get(next).getNewFingerprint(),
+					loopMonitor.split(1));
 		}
 
 		long endIndexingNs = System.nanoTime();
 
+		Map<IPath, List<IJavaElement>> pathsToUpdate = new HashMap<>();
+
+		for (IPath next : allRoots.keySet()) {
+			if (!rootsWithChanges.contains(next)) {
+				pathsToUpdate.put(next, allRoots.get(next));
+				continue;
+			}
+		}
+
+		updateResourceMappings(pathsToUpdate, subMonitor.split(5));
+
+		long endResourceMappingNs = System.nanoTime();
+
 		long fingerprintTimeMs = (startIndexingNs - startFingerprintTestNs) / MS_TO_NS;
 		long locateRootsTimeMs = (startGarbageCollectionNs - startTimeNs) / MS_TO_NS;
 		long indexingTimeMs = (endIndexingNs - startIndexingNs) / MS_TO_NS;
+		long resourceMappingTimeMs = (endResourceMappingNs - endIndexingNs) / MS_TO_NS;
 
 		double averageIndexTimeMs = classesIndexed == 0 ? 0 : (double)indexingTimeMs / (double)classesIndexed;
 		double averageFingerprintTimeMs = allRoots.size() == 0 ? 0 : (double)fingerprintTimeMs / (double)allRoots.size();
+		double averageResourceMappingMs = pathsToUpdate.size() == 0 ? 0 : (double)resourceMappingTimeMs / (double)pathsToUpdate.size();
 
 		Package.logInfo(
 				"Indexing done.\n" //$NON-NLS-1$
 				+ "  Located " + totalRoots + " roots in " + locateRootsTimeMs + "ms\n" //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 				+ "  Tested " + allRoots.size() + " fingerprints in " + fingerprintTimeMs + "ms, average time = " + averageFingerprintTimeMs + "ms\n" //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
-				+ "  Indexed " + classesIndexed + " classes in " + indexingTimeMs + "ms, average time = " + averageIndexTimeMs + "ms\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				+ "  Indexed " + classesIndexed + " classes in " + indexingTimeMs + "ms, average time = " + averageIndexTimeMs + "ms\n" //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				+ "  Updated " + pathsToUpdate.size() + " paths in " + resourceMappingTimeMs + "ms, average time = " + averageResourceMappingMs + "ms\n"); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$
+	}
+
+	private void updateResourceMappings(Map<IPath, List<IJavaElement>> pathsToUpdate, IProgressMonitor monitor) {
+		SubMonitor subMonitor = SubMonitor.convert(monitor, pathsToUpdate.keySet().size());
+
+		JavaIndex index = JavaIndex.getIndex(this.pdom);
+
+		for (Entry<IPath, List<IJavaElement>> entry : pathsToUpdate.entrySet()) {
+			SubMonitor iterationMonitor = subMonitor.split(1).setWorkRemaining(10);
+
+			this.pdom.acquireWriteLock(iterationMonitor.split(1));
+			try {
+				NdResourceFile resourceFile = index.getResourceFile(entry.getKey().toString());
+				if (resourceFile == null) {
+					continue;
+				}
+
+				attachWorkspaceFilesToResource(entry.getValue(), resourceFile);
+			} finally {
+				this.pdom.releaseWriteLock();
+			}
+
+		}
 	}
 
-	private void cleanGarbage(List<IJavaElement> allRoots, IProgressMonitor monitor) {
+	private void cleanGarbage(Collection<IPath> allRoots, IProgressMonitor monitor) {
 		// TODO: lazily clean up unneeded files here... but only do so if we're under heavy space pressure
 		// or it's been a long time since the file was last scanned. Being too eager about removing old files
 		// means that operations which temporarily cause a file to become unreferenced will run really slowly
@@ -121,30 +163,51 @@ public final class Indexer {
 		// will never be useful.
 	}
 
-	private List<IJavaElement> removeDuplicatePaths(List<IJavaElement> allRoots) {
-		Set<IPath> paths = new HashSet<>();
-		List<IJavaElement> result = new ArrayList<>();
+	private Map<IPath, List<IJavaElement>> removeDuplicatePaths(List<IJavaElement> allRoots) {
+		Map<IPath, List<IJavaElement>> paths = new HashMap<>();
 
+		HashSet<IPath> workspacePaths = new HashSet<IPath>();
 		for (IJavaElement next : allRoots) {
 			IPath nextPath = getFilesystemPathForRoot(next);
+			IPath workspacePath = getWorkspacePathForRoot(next);
 
-			if (paths.contains(nextPath)) {
-				continue;
+			List<IJavaElement> value = paths.get(nextPath);
+
+			if (value == null) {
+				value = new ArrayList<IJavaElement>();
+				paths.put(nextPath, value);
+			} else {
+				if (workspacePath != null) {
+					if (workspacePaths.contains(workspacePath)) {
+						continue;
+					}
+					if (!workspacePath.isEmpty()) {
+						Package.logInfo("Found duplicate workspace path for " + workspacePath.toString()); //$NON-NLS-1$
+					}
+					workspacePaths.add(workspacePath);
+				}
 			}
 
-			paths.add(nextPath);
-			result.add(next);
+			value.add(next);
 		}
 
-		return result;
+		return paths;
 	}
 
-	private Map<IJavaElement, FingerprintTestResult> testFingerprints(List<IJavaElement> allRoots,
+	private IPath getWorkspacePathForRoot(IJavaElement next) {
+		IResource resource = next.getResource();
+		if (resource != null) {
+			return resource.getFullPath();
+		}
+		return Path.EMPTY;
+	}
+
+	private Map<IPath, FingerprintTestResult> testFingerprints(Collection<IPath> allRoots,
 			IProgressMonitor monitor) throws CoreException {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, allRoots.size());
-		Map<IJavaElement, FingerprintTestResult> result = new HashMap<>();
+		Map<IPath, FingerprintTestResult> result = new HashMap<>();
 
-		for (IJavaElement next : allRoots) {
+		for (IPath next : allRoots) {
 			result.put(next, testForChanges(next, subMonitor.newChild(1)));
 		}
 
@@ -155,11 +218,15 @@ public final class Indexer {
 	 * Rescans an archive (a jar, zip, or class file on the filesystem). Returns the number of classes indexed.
 	 * @throws JavaModelException
 	 */
-	private int rescanArchive(IJavaElement element, FileFingerprint fingerprint, IProgressMonitor monitor)
-			throws JavaModelException {
+	private int rescanArchive(IPath thePath, List<IJavaElement> elementsMappingOntoLocation,
+			FileFingerprint fingerprint, IProgressMonitor monitor) throws JavaModelException {
+		if (elementsMappingOntoLocation.isEmpty()) {
+			return 0;
+		}
+
+		IJavaElement element = elementsMappingOntoLocation.get(0);
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 
-		IPath thePath = getFilesystemPathForRoot(element);
 		String pathString = thePath.toString();
 		JavaIndex javaIndex = JavaIndex.getIndex(this.pdom);
 
@@ -175,6 +242,7 @@ public final class Indexer {
 		try {
 			resourceFile = new NdResourceFile(this.pdom);
 			resourceFile.setFilename(pathString);
+			attachWorkspaceFilesToResource(elementsMappingOntoLocation, resourceFile);
 		} finally {
 			this.pdom.releaseWriteLock();
 		}
@@ -202,6 +270,17 @@ public final class Indexer {
 		return result;
 	}
 
+	private void attachWorkspaceFilesToResource(List<IJavaElement> elementsMappingOntoLocation,
+			NdResourceFile resourceFile) {
+		for (IJavaElement next : elementsMappingOntoLocation) {
+			IResource nextResource = next.getResource();
+			if (nextResource != null) {
+				new NdWorkspaceLocation(this.pdom, resourceFile,
+						nextResource.getFullPath().toString().toCharArray());
+			}
+		}
+	}
+
 	/**
 	 * Returns the set of IClassFile and ICompilationUnits contained within the given IJavaElement
 	 *
@@ -423,10 +502,10 @@ public final class Indexer {
 	 * Given a list of fragment roots, returns the subset of roots that have changed since the last time they were
 	 * indexed.
 	 */
-	private List<IJavaElement> getRootsThatHaveChanged(List<IJavaElement> roots,
-			Map<IJavaElement, FingerprintTestResult> fingerprints) {
-		List<IJavaElement> rootsWithChanges = new ArrayList<>();
-		for (IJavaElement next : roots) {
+	private List<IPath> getRootsThatHaveChanged(Collection<IPath> roots,
+			Map<IPath, FingerprintTestResult> fingerprints) {
+		List<IPath> rootsWithChanges = new ArrayList<>();
+		for (IPath next : roots) {
 			FingerprintTestResult testResult = fingerprints.get(next);
 
 			if (!testResult.matches()) {
@@ -436,10 +515,9 @@ public final class Indexer {
 		return rootsWithChanges;
 	}
 
-	private FingerprintTestResult testForChanges(IJavaElement next, IProgressMonitor monitor) throws CoreException {
+	private FingerprintTestResult testForChanges(IPath thePath, IProgressMonitor monitor) throws CoreException {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 		JavaIndex javaIndex = JavaIndex.getIndex(this.pdom);
-		IPath thePath = getFilesystemPathForRoot(next);
 		String pathString = thePath.toString();
 
 		// Package.log("Indexer testing: " + pathString, null);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 6e3cd2c..3e3332d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -14,6 +14,7 @@ import java.io.File;
 import java.util.List;
 
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Platform;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
@@ -30,9 +31,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 15);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 15);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 15);
+	static final int CURRENT_VERSION = Nd.version(1, 19);
+	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 19);
+	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 19);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
@@ -131,7 +132,8 @@ public class JavaIndex {
 	}
 
 	public static boolean isEnabled() {
-		return true;
+		return Platform.getPreferencesService().getBoolean("org.eclipse.jdt.ui", "enableNewJavaIndex", false, //$NON-NLS-1$ //$NON-NLS-2$
+				null);
 	}
 
 	public static Nd getGlobalPDOM() {
@@ -207,6 +209,7 @@ public class JavaIndex {
 		registry.register(0x01D0, NdTypeId.type.getFactory());
 		registry.register(0x01E0, NdTypeInterface.type.getFactory());
 		registry.register(0x01F0, NdVariable.type.getFactory());
+		registry.register(0x0200, NdWorkspaceLocation.type.getFactory());
 		return registry;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index d47362a..380d040 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -1,5 +1,6 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
+import org.eclipse.core.resources.IWorkspaceRoot;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
@@ -31,12 +32,7 @@ public class JavaNames {
 	 * jar, including the .class extension.
 	 */
 	public static char[] binaryNameToResourceRelativePath(char[] binaryName) {
-		char[] relativePath = binaryName;
-		int indexOfSeparator = CharOperation.indexOf('$', relativePath);
-		if (indexOfSeparator >= 0) {
-			relativePath = CharOperation.subarray(relativePath, 0, indexOfSeparator);
-		}
-		return CharOperation.concat(relativePath, CLASS_FILE_SUFFIX);
+		return CharOperation.concat(binaryName, CLASS_FILE_SUFFIX);
 	}
 
 	public static char[] fullyQualifiedNameToBinaryName(char[] fullyQualifiedName) {
@@ -52,13 +48,22 @@ public class JavaNames {
 	/**
 	 * Given a PDOMType, returns its identifier in the form accepted by {@link IJavaSearchScope#encloses(String)}
 	 */
-	public static char[] getIndexPathFor(NdType type) {
+	public static char[] getIndexPathFor(NdType type, IWorkspaceRoot root) {
 		NdResourceFile resourceFile = type.getResourceFile();
 
-		char[] filename = resourceFile.getFilename().getChars();
 		char[] binaryName = type.getTypeId().getBinaryName();
 
-		return CharArrayUtils.concat(filename, JAR_FILE_ENTRY_SEPARATOR, binaryNameToResourceRelativePath(binaryName));
+		char[] workspaceLocation = null;
+		if (root != null) {
+			workspaceLocation = resourceFile.getAnyOpenWorkspaceLocation(root).toString().toCharArray();
+		}
+
+		if (workspaceLocation == null) {
+			workspaceLocation = resourceFile.getFilename().getChars();
+		}
+
+		return CharArrayUtils.concat(workspaceLocation, JAR_FILE_ENTRY_SEPARATOR,
+				binaryNameToResourceRelativePath(binaryName));
 	}
 
 	public static char[] binaryNameToFieldDescriptor(char[] binaryName) {
@@ -136,4 +141,18 @@ public class JavaNames {
 		}
 		return CharArrayUtils.EMPTY_CHAR_ARRAY;
 	}
+
+	/**
+	 * Given a simple name, this returns the source name for the type. Note that this won't work for classes that
+	 * contain a $ in their source name.
+	 */
+	public static char[] simpleNameToSourceName(char[] chars) {
+		int lastSlash = CharOperation.lastIndexOf('/', chars);
+		int lastDollar = CharOperation.lastIndexOf('$', chars);
+		int startPosition = Math.max(lastSlash, lastDollar) + 1;
+		while (startPosition < chars.length && Character.isDigit(chars[startPosition])) {
+			startPosition++;
+		}
+		return CharArrayUtils.substring(chars, startPosition);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index 0180dbc..70ad894 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.core.runtime.IAdaptable;
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.internal.core.nd.Nd;
@@ -18,6 +20,7 @@ import org.eclipse.jdt.internal.core.nd.field.FieldInt;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * Base class for bindings in the PDOM.
@@ -112,351 +115,6 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		return null;
 	}
 
-	// /**
-	// * Is the binding as the record orphaned, i.e., has no declarations
-	// * or references.
-	// * Watch out, a binding may also be used in a type (e.g. pointer to class)
-	// *
-	// * @param pdom
-	// * @param address
-	// * @return <code>true</code> if the binding is orphaned.
-	// * @throws IndexException
-	// */
-	// public static boolean isOrphaned(PDOM pdom, long address) throws IndexException {
-	// Database db = pdom.getDB();
-	// return db.getRecPtr(address + FIRST_DECL_OFFSET) == 0
-	// && db.getRecPtr(address + FIRST_DEF_OFFSET) == 0
-	// && db.getRecPtr(address + FIRST_REF_OFFSET) == 0
-	// && db.getRecPtr(address + FIRST_EXTREF_OFFSET) == 0;
-	// }
-	//
-	// public final boolean hasDeclaration() throws IndexException {
-	// if (hasDeclaration == -1) {
-	// final Database db = getDB();
-	// if (db.getRecPtr(address + FIRST_DECL_OFFSET) != 0
-	// || db.getRecPtr(address + FIRST_DEF_OFFSET) != 0) {
-	// hasDeclaration= 1;
-	// return true;
-	// }
-	// hasDeclaration= 0;
-	// return false;
-	// }
-	// return hasDeclaration != 0;
-	// }
-
-	// public final void addDeclaration(PDOMName name) throws IndexException {
-	// PDOMName first = getFirstDeclaration();
-	// if (first != null) {
-	// first.setPrevInBinding(name);
-	// name.setNextInBinding(first);
-	// }
-	// setFirstDeclaration(name);
-	// }
-	//
-	// public final void addDefinition(PDOMName name) throws IndexException {
-	// PDOMName first = getFirstDefinition();
-	// if (first != null) {
-	// first.setPrevInBinding(name);
-	// name.setNextInBinding(first);
-	// }
-	// setFirstDefinition(name);
-	// }
-	//
-	// public final void addReference(PDOMName name) throws IndexException {
-	// // This needs to filter between the local and external lists because it can be used in
-	// // contexts that don't know which type of list they are iterating over. E.g., this is
-	// // used when deleting names from a PDOMFile.
-	// if (!getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).add(name);
-	// return;
-	// }
-	//
-	// PDOMName first = getFirstReference();
-	// if (first != null) {
-	// first.setPrevInBinding(name);
-	// name.setNextInBinding(first);
-	// }
-	// setFirstReference(name);
-	// }
-	//
-	// public PDOMName getFirstDeclaration() throws IndexException {
-	// long namerec = getDB().getRecPtr(address + FIRST_DECL_OFFSET);
-	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
-	// }
-	//
-	// public void setFirstDeclaration(PDOMName name) throws IndexException {
-	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(address + FIRST_DECL_OFFSET, namerec);
-	// }
-	//
-	// public PDOMName getFirstDefinition() throws IndexException {
-	// long namerec = getDB().getRecPtr(address + FIRST_DEF_OFFSET);
-	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
-	// }
-	//
-	// public void setFirstDefinition(PDOMName name) throws IndexException {
-	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(address + FIRST_DEF_OFFSET, namerec);
-	// }
-	//
-	// public PDOMName getFirstReference() throws IndexException {
-	// long namerec = getDB().getRecPtr(address + FIRST_REF_OFFSET);
-	// return namerec != 0 ? new PDOMName(getLinkage(), namerec) : null;
-	// }
-	//
-	// /**
-	// * Returns an iterator over the names in other linkages that reference this binding. Does
-	// * not return null.
-	// */
-	// public IPDOMIterator<PDOMName> getExternalReferences() throws IndexException {
-	// return new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).getIterator();
-	// }
-	//
-	// /**
-	// * In most cases the linkage can be found from the linkage of the name. However, when the
-	// * list is being cleared (there is no next), the linkage must be passed in.
-	// */
-	// public void setFirstReference(PDOMLinkage linkage, PDOMName name) throws IndexException {
-	// if (linkage.equals(getLinkage())) {
-	// setFirstReference(name);
-	// } else {
-	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).setFirstReference(linkage, name);
-	// }
-	// }
-	//
-	// private void setFirstReference(PDOMName name) throws IndexException {
-	// // This needs to filter between the local and external lists because it can be used in
-	// // contexts that don't know which type of list they are iterating over. E.g., this is
-	// // used when deleting names from a PDOMFile.
-	// if (name != null
-	// && !getLinkage().equals(name.getLinkage())) {
-	// new PDOMExternalReferencesList(getNd(), address + FIRST_EXTREF_OFFSET).add(name);
-	// return;
-	// }
-	//
-	// // Otherwise put the reference into list of locals.
-	// long namerec = name != null ? name.getRecord() : 0;
-	// getDB().putRecPtr(address + FIRST_REF_OFFSET, namerec);
-	// }
-	//
-	// @Override
-	// public final PDOMFile getLocalToFile() throws IndexException {
-	// final long filerec = getLocalToFileRec(getDB(), address);
-	// return filerec == 0 ? null : new PDOMFile(getLinkage(), filerec);
-	// }
-	//
-	// public final long getLocalToFileRec() throws IndexException {
-	// return getLocalToFileRec(getDB(), address);
-	// }
-
-	// public static long getLocalToFileRec(Database db, long address) throws IndexException {
-	// return db.getRecPtr(address + LOCAL_TO_FILE);
-	// }
-	//
-	// public final void setLocalToFileRec(long rec) throws IndexException {
-	// getDB().putRecPtr(address + LOCAL_TO_FILE, rec);
-	// }
-
-	// public String getName() {
-	// try {
-	// return super.getDBName().getString();
-	// } catch (IndexException e) {
-	// Package.log(e);
-	// }
-	// return ""; //$NON-NLS-1$
-	// }
-	//
-	//
-	// public char[] getNameCharArray() {
-	//
-	// try {
-	// return super.getNameCharArray();
-	// } catch (IndexException e) {
-	// Package.log(e);
-	// }
-	// return CharArrayUtils.EMPTY;
-	// }
-	//
-	// public IIndexScope getParent() {
-	// try {
-	// IBinding parent = getParentBinding();
-	// if (parent instanceof IIndexScope) {
-	// return (IIndexScope) parent;
-	// }
-	// } catch (IndexException e) {
-	// CCorePlugin.log(e);
-	// }
-	// return getLinkage().getGlobalScope();
-	// }
-	//
-	// @Override
-	// public IIndexScope getScope() {
-	// // The parent node in the binding hierarchy is the scope.
-	// try {
-	// IBinding parent= getParentBinding();
-	// if (parent instanceof IIndexScope) {
-	// return (IIndexScope) parent;
-	// }
-	// } catch (IndexException e) {
-	// CCorePlugin.log(e);
-	// }
-	// return getLinkage().getGlobalScope();
-	// }
-	//
-	// @Override
-	// public IIndexFragment getFragment() {
-	// return getNd();
-	// }
-	// /** For debug purposes only. */
-	// @Override
-	// public final String toString() {
-	// String name = toStringBase();
-	// try {
-	// PDOMFile localToFile = getLocalToFile();
-	// if (localToFile != null)
-	// return name + " (local to " + localToFile.getLocation().getURI().getPath() + ")"; //$NON-NLS-1$ //$NON-NLS-2$
-	// } catch (IndexException e) {
-	// }
-	// return name;
-	// }
-	//
-	// protected String toStringBase() {
-	// if (this instanceof IType) {
-	// return ASTTypeUtil.getType((IType) this);
-	// } else if (this instanceof IFunction) {
-	// IFunctionType t= null;
-	// t = ((IFunction) this).getType();
-	// if (t != null) {
-	// return getName() + ASTTypeUtil.getParameterTypeString(t);
-	// } else {
-	// return getName() + "()"; //$NON-NLS-1$
-	// }
-	// }
-	// return getName();
-	// }
-	//
-	// /**
-	// * For debug purposes only.
-	// * @param linkage
-	// * @param value
-	// * @return String representation of <code>value</code>.
-	// */
-	// protected static String getConstantNameForValue(PDOMLinkage linkage, int value) {
-	// Class<? extends PDOMLinkage> c= linkage.getClass();
-	// Field[] fields= c.getFields();
-	// for (Field field : fields) {
-	// try {
-	// field.setAccessible(true);
-	// if ((field.getModifiers() & Modifier.STATIC) != 0) {
-	// if (int.class.equals(field.getType())) {
-	// int fvalue= field.getInt(null);
-	// if (fvalue == value)
-	// return field.getName();
-	// }
-	// }
-	// } catch (IllegalAccessException e) {
-	// continue;
-	// } catch (IllegalArgumentException e) {
-	// continue;
-	// }
-	// }
-	// return Integer.toString(value);
-	// }
-	//
-	// public PDOMName getScopeName() {
-	// try {
-	// PDOMName name = getFirstDefinition();
-	// if (name == null)
-	// name = getFirstDeclaration();
-	// return name;
-	// } catch (IndexException e) {
-	// CCorePlugin.log(e);
-	// return null;
-	// }
-	// }
-	//
-	// @Override
-	// public String[] getQualifiedName() {
-	// return new String[] { getName() };
-	// }
-	//
-	// @Override
-	// final public boolean isFileLocal() throws IndexException {
-	// return getDB().getRecPtr(address + LOCAL_TO_FILE) != 0;
-	// }
-	//
-	// @Override
-	// public boolean hasDefinition() throws IndexException {
-	// return getDB().getRecPtr(address + FIRST_DEF_OFFSET) != 0;
-	// }
-	//
-	// /**
-	// * Compares two binding fully qualified names. If b0 has
-	// * less segments than b1 then -1 is returned, if b0 has
-	// * more segments than b1 then 1 is returned. If the segment
-	// * lengths are equal then comparison is lexicographical on each
-	// * component name, beginning with the most nested name and working
-	// * outward.
-	// * If one of the bindings in the hierarchy is file-local it is treated as a different
-	// * binding.
-	// * The first non-zero comparison is returned as the result.
-	// * @param b0
-	// * @param b1
-	// * @return <ul><li> -1 if b0 &lt; b1
-	// * <li> 0 if b0 == b1
-	// * <li> 1 if b0 &gt; b1
-	// * </ul>
-	// * @throws IndexException
-	// */
-	// private static int comparePDOMBindingQNs(PDOMBinding b0, PDOMBinding b1) {
-	// try {
-	// int cmp = 0;
-	// do {
-	// IString s0 = b0.getDBName(), s1 = b1.getDBName();
-	// cmp = s0.compare(s1, true);
-	// if (cmp == 0) {
-	// long l1= b0.getLocalToFileRec();
-	// long l2= b1.getLocalToFileRec();
-	// if (l1 != l2) {
-	// return l1 < l2 ? -1 : 1;
-	// }
-	// b0 = (PDOMBinding) b0.getParentBinding();
-	// b1 = (PDOMBinding) b1.getParentBinding();
-	// if (b0 == null || b1 == null) {
-	// cmp = b0 == b1 ? 0 : (b0 == null ? -1 : 1);
-	// }
-	// }
-	// } while (cmp == 0 && b1 != null && b0 != null);
-	// return cmp;
-	// } catch (IndexException ce) {
-	// Package.log(ce);
-	// return -1;
-	// }
-	// }
-	//
-	// /**
-	// * Compares two PDOMBinding objects in accordance with
-	// * {@link IIndexFragmentBindingComparator#compare(IIndexFragmentBinding, IIndexFragmentBinding)}
-	// * @param other
-	// * @return comparison result, -1, 0, or 1.
-	// */
-	// public int pdomCompareTo(PDOMBinding other) {
-	// int cmp = comparePDOMBindingQNs(this, other);
-	// if (cmp == 0) {
-	// int t1 = getNodeType();
-	// int t2 = other.getNodeType();
-	// return t1 < t2 ? -1 : (t1 > t2 ? 1 : 0);
-	// }
-	// return cmp;
-	// }
-	//
-	// /**
-	// * Returns whether pdomCompareTo returns zero
-	// */
-	// public final boolean pdomEquals(PDOMBinding other) {
-	// return pdomCompareTo(other)==0;
-	// }
-
 	public final int getBindingConstant() {
 		return getNodeType();
 	}
@@ -469,38 +127,20 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		return FILE.get(getNd(), this.address);
 	}
 
-	// @Override
-	// final public void delete() throws IndexException {
-	// assert false;
-	// }
-	//
-	// /**
-	// * Bindings may set additional flags for their occurrences
-	// * Return a combination of flags defined in {@link PDOMName}.
-	// * @since 5.0
-	// */
-	// public int getAdditionalNameFlags(int standardFlags, IASTName name) {
-	// return 0;
-	// }
-	//
-	// public final IBinding getBinding(IASTName name, boolean resolve) {
-	// return getBinding(name, resolve, null);
-	// }
-	//
-	// public IBinding getBinding(IASTName name, boolean resolve, IIndexFileSet fileSet) {
-	// return null;
-	// }
-	//
-	// public final IBinding[] getBindings(IASTName name, boolean resolve, boolean prefix) {
-	// return getBindings(new ScopeLookupData(name, resolve, prefix));
-	// }
-	//
-	// @Deprecated
-	// public IBinding[] getBindings(IASTName name, boolean resolve, boolean prefix, IIndexFileSet fileSet) {
-	// return IBinding.EMPTY_BINDING_ARRAY;
-	// }
-	//
-	// public IBinding[] getBindings(ScopeLookupData lookup) {
-	// return IBinding.EMPTY_BINDING_ARRAY;
-	// }
+	public char[][] getTypeParameterSignatures() {
+		List<NdTypeParameter> parameters = getTypeParameters();
+		char[][] result = new char[parameters.size()][];
+
+		int idx = 0;
+		for (NdTypeParameter next : parameters) {
+			CharArrayBuffer nextArray = new CharArrayBuffer();
+			next.getSignature(nextArray);
+			result[idx] = nextArray.getContents();
+		}
+		return result;
+	}
+
+	private List<NdTypeParameter> getTypeParameters() {
+		return TYPE_PARAMETERS.asList(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index cc97594..d0c8b68 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -1,11 +1,15 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * Represents a type signature that is anything other than a trivial reference to a concrete
@@ -83,4 +87,55 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 	public NdComplexTypeSignature getGenericDeclaringType() {
 		return DECLARING_TYPE.get(getNd(), this.address);
 	}
+
+	public List<NdTypeArgument> getTypeArguments() {
+		return TYPE_ARGUMENTS.asList(getNd(), this.address);
+	}
+
+	@Override
+	public void getSignature(CharArrayBuffer result) {
+		NdComplexTypeSignature parentSignature = getGenericDeclaringType();
+
+		if (parentSignature != null) {
+			parentSignature.getSignature(result);
+			result.append('.');
+			return;
+		}
+
+		if (isArrayType()) {
+			long size = TYPE_ARGUMENTS.size(getNd(), this.address);
+
+			if (size != 1) {
+				throw new IndexException("Array types should have exactly one argument"); //$NON-NLS-1$
+			}
+
+			NdTypeArgument argument = TYPE_ARGUMENTS.get(getNd(), this.address, 0);
+
+			result.append('[');
+			argument.getType().getSignature(result);
+			return;
+		}
+
+		if (isTypeVariable()) {
+			result.append('T');
+			result.append(getVariableIdentifier().getChars());
+			return;
+		}
+
+		result.append(getRawType().getFieldDescriptor().getChars());
+
+		List<NdTypeArgument> arguments = getTypeArguments();
+		if (!arguments.isEmpty()) {
+			result.append('<');
+			for (NdTypeArgument next : arguments) {
+				next.getSignature(result);
+			}
+			result.append('>');
+		}
+	}
+
+	@Override
+	public boolean isTypeVariable() {
+		return getVariableIdentifier().length() != 0;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 56dffd9..410e14c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -10,16 +10,24 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.field.FieldLong;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
-import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
-import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany.Visitor;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.IResultRank;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.SearchCriteria;
+import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
  * Represents a source of java classes (such as a .jar or .class file).
@@ -31,6 +39,7 @@ public class NdResourceFile extends NdTreeNode {
 	public static final FieldLong TIME_LAST_SCANNED;
 	public static final FieldLong SIZE_LAST_SCANNED;
 	public static final FieldLong HASHCODE_LAST_SCANNED;
+	public static final FieldOneToMany<NdWorkspaceLocation> WORKSPACE_MAPPINGS;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdResourceFile> type;
@@ -42,6 +51,7 @@ public class NdResourceFile extends NdTreeNode {
 		TIME_LAST_SCANNED = type.addLong();
 		SIZE_LAST_SCANNED = type.addLong();
 		HASHCODE_LAST_SCANNED = type.addLong();
+		WORKSPACE_MAPPINGS = FieldOneToMany.create(type, NdWorkspaceLocation.RESOURCE);
 		type.done();
 	}
 
@@ -89,6 +99,51 @@ public class NdResourceFile extends NdTreeNode {
 		}
 	}
 
+	public List<IPath> getAllWorkspaceLocations() {
+		final List<IPath> result = new ArrayList<>();
+
+		WORKSPACE_MAPPINGS.accept(getNd(), this.address, new Visitor<NdWorkspaceLocation>() {
+			@Override
+			public void visit(int index, NdWorkspaceLocation toVisit) {
+				result.add(new Path(toVisit.getPath().getString()));
+			}
+		});
+
+		return result;
+	}
+
+	public IPath getFirstWorkspaceLocation() {
+		if (WORKSPACE_MAPPINGS.isEmpty(getNd(), this.address)) {
+			return Path.EMPTY;
+		}
+
+		return new Path(WORKSPACE_MAPPINGS.get(getNd(), this.address, 0).getPath().toString());
+	}
+
+	public IPath getAnyOpenWorkspaceLocation(IWorkspaceRoot root) {
+		int numMappings = WORKSPACE_MAPPINGS.size(getNd(), this.address);
+
+		for (int mapping = 0; mapping < numMappings; mapping++) {
+			NdWorkspaceLocation nextMapping = WORKSPACE_MAPPINGS.get(getNd(), this.address, mapping);
+
+			IPath nextPath = new Path(nextMapping.getPath().getString());
+			if (nextPath.isEmpty()) {
+				continue;
+			}
+
+			IProject project = root.getProject(nextPath.segment(0));
+			if (project.isOpen()) {
+				return nextPath;
+			}
+		}
+
+		return Path.EMPTY;
+	}
+
+	public List<NdWorkspaceLocation> getWorkspaceMappings() {
+		return WORKSPACE_MAPPINGS.asList(getNd(), this.address);
+	}
+
 	public IString getFilename() {
 		return FILENAME.get(getNd(), this.address);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 2f49e6d..2e13745 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -16,6 +16,7 @@ import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.internal.core.nd.IPDOMVisitor;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
@@ -34,6 +35,7 @@ public class NdType extends NdBinding {
 	public static final FieldOneToMany<NdMethod> METHODS;
 	public static final FieldString MISSING_TYPE_NAMES;
 	public static final FieldString SOURCE_FILE_NAME;
+	public static final FieldString INNER_CLASS_SOURCE_NAME;
 	public static final FieldByte FLAGS;
 
 	@SuppressWarnings("hiding")
@@ -49,6 +51,7 @@ public class NdType extends NdBinding {
 		METHODS = FieldOneToMany.create(type, NdMethod.PARENT, 6);
 		MISSING_TYPE_NAMES = type.addString();
 		SOURCE_FILE_NAME = type.addString();
+		INNER_CLASS_SOURCE_NAME = type.addString();
 		FLAGS = type.addByte();
 		type.done();
 	}
@@ -87,6 +90,14 @@ public class NdType extends NdBinding {
 		TYPENAME.put(getNd(), this.address, typeId);
 	}
 
+	public void setInnerTypeSourceName(char[] sourceName) {
+		INNER_CLASS_SOURCE_NAME.put(getNd(), this.address, sourceName);
+	}
+
+	public char[] getInnerTypeSourceName() {
+		return INNER_CLASS_SOURCE_NAME.get(getNd(), this.address).getChars();
+	}
+
 	public long getResourceAddress() {
 		return FILE.getAddress(getNd(), this.address);
 	}
@@ -177,4 +188,20 @@ public class NdType extends NdBinding {
 	private boolean getFlag(byte flagConstant) {
 		return (FLAGS.get(getNd(), this.address) & flagConstant) != 0;
 	}
+
+	public char[] getSourceName() {
+		if (isLocal()) {
+			return getInnerTypeSourceName();
+		}
+		return getTypeId().getSimpleNameCharArray();
+	}
+
+	@Override
+	public String toString() {
+		try {
+			return "class " + new String(getSourceName()); //$NON-NLS-1$
+		} catch (IndexException e) {
+			return super.toString();
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
index 0a6c324..2466564 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
@@ -5,6 +5,7 @@ import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * @since 3.12
@@ -28,7 +29,7 @@ public class NdTypeArgument extends NdNode {
 	public static final int WILDCARD_NONE = 0;
 	public static final int WILDCARD_EXTENDS = 1;
 	public static final int WILDCARD_SUPER = 2;
-	public static final int WILDCARD_QUESTION = 2;
+	public static final int WILDCARD_QUESTION = 3;
 
 	public NdTypeArgument(Nd pdom, long address) {
 		super(pdom, address);
@@ -64,4 +65,13 @@ public class NdTypeArgument extends NdNode {
 	public NdTypeSignature getType() {
 		return TYPE_SIGNATURE.get(getNd(), this.address);
 	}
+
+	public void getSignature(CharArrayBuffer result) {
+		switch (getWildcard()) {
+			case NdTypeArgument.WILDCARD_EXTENDS: result.append('-'); break;
+			case NdTypeArgument.WILDCARD_QUESTION: result.append('*'); break;
+			case NdTypeArgument.WILDCARD_SUPER: result.append('+'); break;
+		}
+		getType().getSignature(result);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
index 0e5abec..d337e37 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeBound.java
@@ -4,6 +4,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * Represents the bound on a generic parameter (a ClassBound or InterfaceBound in
@@ -44,4 +45,9 @@ public class NdTypeBound extends NdNode {
 	public NdTypeSignature getType() {
 		return TYPE.get(getNd(), this.address);
 	}
+
+	public void getSignature(CharArrayBuffer result) {
+		result.append(':');
+		getType().getSignature(result);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 81f1f3e..5a023d3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -8,6 +8,7 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * @since 3.12
@@ -100,4 +101,14 @@ public class NdTypeId extends NdTypeSignature {
 	public NdTypeId getRawType() {
 		return this;
 	}
+
+	@Override
+	public void getSignature(CharArrayBuffer result) {
+		result.append(getFieldDescriptor().getChars());
+	}
+
+	@Override
+	public boolean isTypeVariable() {
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
index 8f6fa4b..4b41ef4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
@@ -1,11 +1,14 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * Represents a TypeParameter, as described in Section 4.7.9.1 of
@@ -39,4 +42,20 @@ public class NdTypeParameter extends NdNode {
 		PARENT.put(getNd(), this.address, parent);
 		IDENTIFIER.put(getNd(), this.address, identifier);
 	}
+
+	public char[] getIdentifier() {
+		return IDENTIFIER.get(getNd(), this.address).getChars();
+	}
+
+	public List<NdTypeBound> getBounds() {
+		return BOUNDS.asList(getNd(), this.address);
+	}
+
+	public void getSignature(CharArrayBuffer result) {
+		result.append(getIdentifier());
+
+		for (NdTypeBound next : getBounds()) {
+			next.getSignature(result);
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index fe66a38..86c90f2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -17,6 +17,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
  * Corresponds roughly to a JavaTypeSignature, as described in section 4.7.9.1 of the Java VM spec version 4, with the
@@ -103,4 +104,12 @@ public abstract class NdTypeSignature extends NdNode {
 	 * of this signature doesn't have a raw type, for example if it is a type variable.
 	 */
 	public abstract NdTypeId getRawType();
+
+	public abstract void getSignature(CharArrayBuffer result);
+
+	public final boolean isArrayType() {
+		return getRawType().hasSimpleName("["); //$NON-NLS-1$
+	}
+
+	public abstract boolean isTypeVariable();
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
new file mode 100644
index 0000000..c21dcfa
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
@@ -0,0 +1,46 @@
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.NdNode;
+import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.FieldString;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+/**
+ * Holds a location in the Eclipse workspace where a given resource was found. Note that a given
+ * resource might be mapped to multiple locations in the workspace.
+ */
+public class NdWorkspaceLocation extends NdNode {
+	public static final FieldManyToOne<NdResourceFile> RESOURCE;
+	public static final FieldString PATH;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdWorkspaceLocation> type;
+
+	static {
+		type = StructDef.create(NdWorkspaceLocation.class, NdNode.type);
+		RESOURCE = FieldManyToOne.createOwner(type, NdResourceFile.WORKSPACE_MAPPINGS);
+		PATH = type.addString();
+		type.done();
+	}
+
+	public NdWorkspaceLocation(Nd pdom, long address) {
+		super(pdom, address);
+	}
+
+	public NdWorkspaceLocation(Nd pdom, NdResourceFile resource, char[] path) {
+		super(pdom);
+
+		RESOURCE.put(getNd(), this.address, resource);
+		PATH.put(getNd(), this.address, path);
+	}
+
+	public IString getPath() {
+		return PATH.get(getNd(), this.address);
+	}
+
+	public NdResourceFile getResourceFile() {
+		return RESOURCE.get(getNd(), this.address);
+	}
+}
commit 5f048c1238ac75d0905f56c190c6625fe437e116
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 08:18:39 2016 -0800

    Bug 481796 - Add a global write counter
    
    The database header now gets a global counter that increments on every
    write. This can be used to determine if data has changed or not.
    
    Change-Id: I7936e32b239e597c20644c8097c68c77866b442e
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

12	11	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
10	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
6	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index f6df0d8..b8bc4f6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -69,17 +69,6 @@ public class Nd {
 		return "" + major + '.' + minor; //$NON-NLS-1$
 	}
 
-	//public static final int LINKAGES = Database.DATA_AREA;
-	public static final int FILE_INDEX = Database.DATA_AREA + 4;
-	public static final int INDEX_OF_DEFECTIVE_FILES = Database.DATA_AREA + 8;
-	public static final int INDEX_OF_FILES_WITH_UNRESOLVED_INCLUDES = Database.DATA_AREA + 12;
-	public static final int PROPERTIES = Database.DATA_AREA + 16;
-	public static final int TAG_INDEX = Database.DATA_AREA + 20;
-	public static final int END= Database.DATA_AREA + 24;
-	static {
-		assert END <= Database.CHUNK_SIZE;
-	}
-
 	public static class ChangeEvent {
 		public Set<IIndexFileLocation> fClearedFiles= new HashSet<>();
 		public Set<IIndexFileLocation> fFilesWritten= new HashSet<>();
@@ -130,6 +119,12 @@ public class Nd {
 	private final NdNodeTypeRegistry<NdNode> fNodeTypeRegistry;
 	private HashMap<Long, Throwable> pendingDeletions = new HashMap<>();
 
+	/**
+	 * This long is incremented every time a change is written to the database. Can be used to determine if the database
+	 * has changed.
+	 */
+	private long fWriteNumber;
+
 	public Nd(File dbPath, NdNodeTypeRegistry<NdNode> nodeTypes, int minVersion, int maxVersion,
 			int currentVersion) throws IndexException {
 		this(dbPath, ChunkCache.getSharedInstance(), nodeTypes, minVersion, maxVersion, currentVersion);
@@ -148,6 +143,10 @@ public class Nd {
 		}
 	}
 
+	public long getWriteNumber() {
+		return this.fWriteNumber;
+	}
+
 	public void scheduleDeletion(long addressOfNodeToDelete) {
 		// Sometimes an object can be scheduled for deletion twice, if it is created and then discarded shortly
 		// afterward during indexing. This may indicate an inefficiency in the indexer but is not necessarily
@@ -196,6 +195,7 @@ public class Nd {
 			this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
 			this.db.setLocked(lockDB);
 		}
+		this.fWriteNumber = this.db.getLong(Database.WRITE_NUMBER_OFFSET);
 		this.db.setLocked(this.lockCount != 0);
 	}
 
@@ -324,6 +324,7 @@ public class Nd {
 		// When all locks are released we can clear the result cache.
 		if (establishReadLocks == 0) {
 			processDeletions();
+			this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
 			clearResultCache();
 		}
 		try {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 6299cac..1de9ee7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -43,13 +43,14 @@ import com.ibm.icu.text.MessageFormat;
  *
  * ===== The first chunk is used by Database itself for house-keeping purposes and has structure
  *
- * offset            content
- * 	                 _____________________________
- * 0                | version number
- * INT_SIZE         | pointer to head of linked list of blocks of size MIN_BLOCK_DELTAS*BLOCK_SIZE_DELTA
- * ..               | ...
- * INT_SIZE * m (1) | pointer to head of linked list of blocks of size (m + MIN_BLOCK_DELTAS) * BLOCK_SIZE_DELTA
- * DATA_AREA        | undefined (PDOM stores its own house-keeping data in this area)
+ * offset                content
+ * 	                     _____________________________
+ * 0                    | version number
+ * INT_SIZE             | pointer to head of linked list of blocks of size MIN_BLOCK_DELTAS*BLOCK_SIZE_DELTA
+ * ..                   | ...
+ * INT_SIZE * m (1)     | pointer to head of linked list of blocks of size (m + MIN_BLOCK_DELTAS) * BLOCK_SIZE_DELTA
+ * WRITE_NUMBER_OFFSET  | long integer which is incremented on every write
+ * DATA_AREA            | undefined (PDOM stores its own house-keeping data in this area)
  *
  * (1) where 2 <= m <= CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1
  *
@@ -90,7 +91,8 @@ public class Database {
 	public static final long MAX_DB_SIZE= ((long) 1 << (Integer.SIZE + BLOCK_SIZE_DELTA_BITS));
 
 	public static final int VERSION_OFFSET = 0;
-	public static final int DATA_AREA = (CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 2) * INT_SIZE;
+	public static final int WRITE_NUMBER_OFFSET = (CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 2) * INT_SIZE;
+	public static final int DATA_AREA = WRITE_NUMBER_OFFSET + LONG_SIZE;
 
 	private static final int BLOCK_PREV_OFFSET = BLOCK_HEADER_SIZE;
 	private static final int BLOCK_NEXT_OFFSET = BLOCK_HEADER_SIZE + INT_SIZE;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 3e3332d..b8e07b4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -31,9 +31,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 19);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 19);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 19);
+	static final int CURRENT_VERSION = Nd.version(1, 20);
+	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 20);
+	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 20);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
@@ -50,6 +50,9 @@ public class JavaIndex {
 		TYPES = FieldSearchIndex.create(type, NdTypeId.FIELD_DESCRIPTOR);
 		METHODS = FieldSearchIndex.create(type, NdMethodId.METHOD_NAME);
 		type.done();
+
+		// This struct needs to fit within the first database chunk.
+		assert type.getFactory().getRecordSize() <= Database.CHUNK_SIZE;
 	}
 
 	private final static class BestResourceFile implements FieldSearchIndex.IResultRank {
commit f2e4c3b3146d50ca95b6c2bf4208de3223004c4f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 09:04:46 2016 -0800

    Bug 481796 - Add a DatabaseRef class
    
    It can be used to retain references to objects after the read lock is
    released.
    
    Change-Id: I1ecefc68fe920dd460a0419a217454eafd2af2b8
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

46	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
11	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
new file mode 100644
index 0000000..b29370a
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
@@ -0,0 +1,46 @@
+package org.eclipse.jdt.internal.core.nd;
+
+/**
+ * Holds a reference to a database entity that may be retained across read locks. In normal circumstances, it
+ * is unsafe to retain a database address after a read lock is released since the object pointed to at that
+ * address may have been deleted in the meantime. This class addresses this problem by remembering both the
+ * address itself and enough information to determine whether that address is invalid and search for an
+ * equivalent object if the original is lost.
+ */
+public class DatabaseRef<T extends NdNode> implements Supplier<T> {
+	private final Nd nd;
+	private T lastResult;
+	private long writeCounter;
+	private final Supplier<T> searchFunction;
+
+	/**
+	 * Constructs a new {@link DatabaseRef} that will search for its target using the given search function.
+	 */
+	public DatabaseRef(Nd nd, Supplier<T> searchFunction) {
+		this.nd = nd;
+		this.searchFunction = searchFunction;
+		this.writeCounter = -1;
+	}
+
+	/**
+	 * Constructs a new {@link DatabaseRef} that will search for its target using the given search function.
+	 */
+	public DatabaseRef(Nd nd, Supplier<T> searchFunction, T initialResult) {
+		this.nd = nd;
+		this.searchFunction = searchFunction;
+		this.lastResult = initialResult;
+		this.writeCounter = this.nd.getWriteNumber();
+	}
+
+	public T get() {
+		long ndWriteNumber = this.nd.getWriteNumber();
+		if (this.writeCounter == ndWriteNumber) {
+			return this.lastResult;
+		}
+
+		T result = this.searchFunction.get();
+		this.writeCounter = ndWriteNumber;
+		this.lastResult = result;
+		return result;
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
new file mode 100644
index 0000000..235964e
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
@@ -0,0 +1,11 @@
+package org.eclipse.jdt.internal.core.nd;
+
+/**
+ * TODO: Remove me once we can use the Java 8 interface
+ */
+public interface Supplier<T> {
+	/**
+	 * Returns the result.
+	 */
+	T get();
+}
\ No newline at end of file
commit 6c740c2ba3f0dd3fd9d0c9a22b8ddee4ae32e3a7
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 09:56:56 2016 -0800

    Bug 481796 - Proposal for a faster JDT index
    
    Add ReferenceUtil, for constructing DatabaseRef objects.
    
    Change-Id: I33e5e01d940579a88b01092fd902a3432aebb4d2
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
72	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
index b29370a..800405f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
@@ -32,6 +32,9 @@ public class DatabaseRef<T extends NdNode> implements Supplier<T> {
 		this.writeCounter = this.nd.getWriteNumber();
 	}
 
+	/**
+	 * Returns the referenced object or null if the object is no longer present in the database.
+	 */
 	public T get() {
 		long ndWriteNumber = this.nd.getWriteNumber();
 		if (this.writeCounter == ndWriteNumber) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
new file mode 100644
index 0000000..a852016
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
@@ -0,0 +1,72 @@
+package org.eclipse.jdt.internal.core.nd.java;
+
+import java.util.List;
+
+import org.eclipse.jdt.internal.core.nd.DatabaseRef;
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.Supplier;
+
+/**
+ * Holds utility functions for constructing {@link DatabaseRef} objects to java Nd types. Such references
+ * can be retained while releasing and reacquiring a read lock, unlike ordinary pointers to database objects,
+ * which must be discarded every time a read lock is released.
+ */
+public final class ReferenceUtil {
+	/**
+	 * Creates a {@link DatabaseRef} to the given {@link NdType}.
+	 */
+	public static DatabaseRef<NdType> createTypeRef(NdType type) {
+		final Nd nd = type.getNd();
+		final char[] fieldDescriptor = type.getTypeId().getRawType().getFieldDescriptor().getChars();
+		final char[] fileName = type.getResourceFile().getFilename().getChars();
+		return new DatabaseRef<NdType>(type.getNd(), getTypeSupplier(nd, fileName, fieldDescriptor), type);
+	}
+
+	/**
+	 * Creates a {@link DatabaseRef} to the {@link NdType} with the given resource path and field descriptor.
+	 */
+	public static DatabaseRef<NdType> createTypeRef(Nd nd, char[] resourcePath, char[] fieldDescriptor) {
+		return new DatabaseRef<NdType>(nd, getTypeSupplier(nd, resourcePath, fieldDescriptor));
+	}
+
+	/**
+	 * Creates a {@link DatabaseRef} to the given {@link NdTypeId}.
+	 */
+	public static DatabaseRef<NdTypeId> createTypeIdRef(NdTypeId typeId) {
+		return new DatabaseRef<NdTypeId>(typeId.getNd(),
+				getTypeIdSupplier(typeId.getNd(), typeId.getFieldDescriptor().getChars()));
+	}
+
+	/**
+	 * Creates a {@link DatabaseRef} to the {@link NdTypeId} with the given field descriptor.
+	 */
+	public static DatabaseRef<NdTypeId> createTypeIdRef(Nd nd, char[] fieldDescriptor) {
+		return new DatabaseRef<NdTypeId>(nd, getTypeIdSupplier(nd, fieldDescriptor));
+	}
+
+	private static Supplier<NdTypeId> getTypeIdSupplier(final Nd nd, final char[] fieldDescriptor) {
+		return new Supplier<NdTypeId>() {
+			@Override
+			public NdTypeId get() {
+				return JavaIndex.getIndex(nd).findType(fieldDescriptor);
+			}
+		};
+	}
+
+	private static Supplier<NdType> getTypeSupplier(final Nd nd, final char[] fileName, final char[] fieldDescriptor) {
+		return new Supplier<NdType>() {
+			@Override
+			public NdType get() {
+				NdTypeId typeId = JavaIndex.getIndex(nd).findType(fieldDescriptor);
+
+				List<NdType> implementations = typeId.getTypes();
+				for (NdType next : implementations) {
+					if (next.getResourceFile().getFilename().compare(fileName, false) == 0) {
+						return next;
+					}
+				}
+				return null;
+			}
+		};
+	}
+}
commit 519e1a1a7e6c8ac5e51d71d46144dc97998dcb12
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 09:57:11 2016 -0800

    Bug 481796 - Proposal for a faster JDT index
    
    Add a TODO
    
    Change-Id: I9350f7a1c5a0f89afb380ce28345ddbba7e1e425
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
index 037147b..cccd867 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
@@ -57,6 +57,8 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 
 	public void put(Nd pdom, long address, char[] newString) {
 		BTree btree = this.searchIndex.get(pdom, Database.DATA_AREA);
+		// TODO: there's no need to invoke this "delete" method on the first initialization of a search key. We could
+		// detect this case and optimize out this call when possible.
 		btree.delete(address);
 
 		this.key.put(pdom, address, newString);
commit 0a7d32fba208ab874740c22a3f8bab6fdc7318dd
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 10:40:14 2016 -0800

    Bug 481796 - Proposal for a faster JDT index
    
    Fix NPE in type hierarchy view.
    
    Change-Id: I912db9e5a05af242e28afd15a073335a86c7623f
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
6	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index d0c8b68..cb4cd68 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -102,6 +102,12 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			return;
 		}
 
+		if (isTypeVariable()) {
+			result.append('T');
+			result.append(getVariableIdentifier().getChars());
+			return;
+		}
+
 		if (isArrayType()) {
 			long size = TYPE_ARGUMENTS.size(getNd(), this.address);
 
@@ -116,12 +122,6 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			return;
 		}
 
-		if (isTypeVariable()) {
-			result.append('T');
-			result.append(getVariableIdentifier().getChars());
-			return;
-		}
-
 		result.append(getRawType().getFieldDescriptor().getChars());
 
 		List<NdTypeArgument> arguments = getTypeArguments();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
index 2466564..99a736f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeArgument.java
@@ -69,9 +69,13 @@ public class NdTypeArgument extends NdNode {
 	public void getSignature(CharArrayBuffer result) {
 		switch (getWildcard()) {
 			case NdTypeArgument.WILDCARD_EXTENDS: result.append('-'); break;
-			case NdTypeArgument.WILDCARD_QUESTION: result.append('*'); break;
+			case NdTypeArgument.WILDCARD_QUESTION: result.append('*'); return;
 			case NdTypeArgument.WILDCARD_SUPER: result.append('+'); break;
 		}
-		getType().getSignature(result);
+
+		NdTypeSignature theType = getType();
+		if (theType != null) {
+			theType.getSignature(result);
+		}
 	}
 }
commit ee355a11f59245ebb7f5af64c820354e5aa5c533
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 2 10:43:38 2016 -0800

    Bug 481796 - Proposal for a faster JDT index
    
    Avoid trying to remove keys from the index if they have never been
    inserted yet.
    
    Change-Id: If3b4ae302d3f3e61aca0e94b82f8bcb652488c15
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

48	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
index cccd867..a882443 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
@@ -14,6 +14,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.db.BTree;
 import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.EmptyString;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 
 /**
@@ -21,12 +22,10 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
  * @since 3.12
  */
 public class FieldSearchKey<T> implements IField, IDestructableField {
-	private final FieldString key;
+	private int offset;
 	FieldSearchIndex<?> searchIndex;
 
 	private FieldSearchKey(FieldSearchIndex<?> searchIndex) {
-		this.key = new FieldString();
-
 		if (searchIndex != null) {
 			if (searchIndex.searchKey != null && searchIndex.searchKey != this) {
 				throw new IllegalArgumentException(
@@ -55,32 +54,67 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 		put(pdom, address, newString.toCharArray());
 	}
 
+	/**
+	 * Sets the value of the key and inserts it into the index if it is not already present
+	 */
 	public void put(Nd pdom, long address, char[] newString) {
-		BTree btree = this.searchIndex.get(pdom, Database.DATA_AREA);
-		// TODO: there's no need to invoke this "delete" method on the first initialization of a search key. We could
-		// detect this case and optimize out this call when possible.
-		btree.delete(address);
-
-		this.key.put(pdom, address, newString);
+		cleanup(pdom, address);
 
+		Database db = pdom.getDB();
+		BTree btree = this.searchIndex.get(pdom, Database.DATA_AREA);
+		db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
 		btree.insert(address);
 	}
 
 	public IString get(Nd pdom, long address) {
-		return this.key.get(pdom, address);
+		Database db = pdom.getDB();
+		long namerec = db.getRecPtr(address + this.offset);
+
+		if (namerec == 0) {
+			return EmptyString.create();
+		}
+		return db.getString(namerec);
 	}
 
 	@Override
 	public void destruct(Nd pdom, long address) {
-		// Remove this entry from the search index
-		this.searchIndex.get(pdom, Database.DATA_AREA).delete(address);
+		cleanup(pdom, address);
+	}
+
+	private void cleanup(Nd pdom, long address) {
+		boolean isInIndex = isInIndex(pdom, address);
+
+		if (isInIndex) {
+			// Remove this entry from the search index
+			this.searchIndex.get(pdom, Database.DATA_AREA).delete(address);
+
+			get(pdom, address).delete();
+			pdom.getDB().putRecPtr(address + this.offset, 0);
+		}
+	}
+
+	/**
+	 * Clears this key and removes it from the search index
+	 */
+	public void removeFromIndex(Nd nd, long address) {
+		cleanup(nd, address);
+	}
+
+	/**
+	 * Returns true iff this key is currently in the index
+	 */
+	public boolean isInIndex(Nd pdom, long address) {
+		long fieldAddress = address + this.offset;
+		Database db = pdom.getDB();
+		long namerec = db.getRecPtr(fieldAddress);
 
-		this.key.destruct(pdom, address);
+		boolean isInIndex = namerec != 0;
+		return isInIndex;
 	}
 
 	@Override
 	public void setOffset(int offset) {
-		this.key.setOffset(offset);
+		this.offset = offset;
 	}
 
 	@Override
commit 563a6c1b3c46816e70f6750424130cf3088344fe
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Feb 8 19:34:40 2016 -0800

    Bug 481796 - Implement an index-backed implementation of IBinaryType
    
    Change-Id: Ice04141c82455161a870befa3246d1e258875183
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
13	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
6	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
14	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
10	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
7	19	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
38	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
7	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
25	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
18	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
19	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
20	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
9	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
5	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
22	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
166	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
32	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryNestedType.java
649	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
0	335	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexType.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
index bfdfa50..5d200fe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
@@ -21,6 +21,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.util.Util;
+import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 
 @SuppressWarnings("rawtypes")
 public class MethodInfo extends ClassFileStruct implements IBinaryMethod, Comparable {
@@ -226,6 +227,7 @@ public int compareTo(Object o) {
 	if (result != 0) return result;
 	return new String(getMethodDescriptor()).compareTo(new String(otherMethod.getMethodDescriptor()));
 }
+@Override
 public boolean equals(Object o) {
 	if (!(o instanceof MethodInfo)) {
 		return false;
@@ -234,6 +236,7 @@ public boolean equals(Object o) {
 	return CharOperation.equals(getSelector(), otherMethod.getSelector())
 			&& CharOperation.equals(getMethodDescriptor(), otherMethod.getMethodDescriptor());
 }
+@Override
 public int hashCode() {
 	return CharOperation.hashCode(getSelector()) + CharOperation.hashCode(getMethodDescriptor());
 }
@@ -354,16 +357,14 @@ protected void initialize() {
  * @return boolean
  */
 public boolean isClinit() {
-	char[] selector = getSelector();
-	return selector[0] == '<' && selector.length == 8; // Can only match <clinit>
+	return JavaNames.isClinit(getSelector());
 }
 /**
  * Answer true if the method is a constructor, false otherwise.
  * @return boolean
  */
 public boolean isConstructor() {
-	char[] selector = getSelector();
-	return selector[0] == '<' && selector.length == 6; // Can only match <init>
+	return JavaNames.isConstructor(getSelector());
 }
 /**
  * Return true if the field is a synthetic method, false otherwise.
@@ -442,6 +443,7 @@ public int sizeInBytes() {
 	return this.attributeBytes;
 }
 
+@Override
 public String toString() {
 	StringBuffer buffer = new StringBuffer();
 	toString(buffer);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index fdd82f9..f7a306d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -193,6 +193,7 @@ public class ClassFileToIndexConverter {
 		type.setAnonymous(binaryType.isAnonymous());
 		type.setIsLocal(binaryType.isLocal());
 		type.setIsMember(binaryType.isMember());
+		type.setTagBits(binaryType.getTagBits());
 
 		if (binaryType.isLocal()) {
 			type.setInnerTypeSourceName(binaryType.getSourceName());
@@ -255,6 +256,7 @@ public class ClassFileToIndexConverter {
 			signature.start++;
 		}
 
+		int annotatedParametersCount = next.getAnnotatedParametersCount();
 		char[][] parameterNames = next.getArgumentNames();
 		short parameterIdx = 0;
 		while (!signature.atEnd()) {
@@ -265,6 +267,15 @@ public class ClassFileToIndexConverter {
 			NdMethodParameter parameter = new NdMethodParameter(method,
 					createTypeSignature(typeAnnotations.toMethodParameter(parameterIdx), signature));
 
+			if (parameterIdx < annotatedParametersCount) {
+				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(parameterIdx, binaryTypeName);
+
+				if (parameterAnnotations != null) {
+					for (IBinaryAnnotation nextAnnotation : parameterAnnotations) {
+						createAnnotation(nextAnnotation).setParent(parameter);
+					}
+				}
+			}
 			if (parameterNames != null && parameterNames.length > parameterIdx) {
 				parameter.setName(parameterNames[parameterIdx]);
 			}
@@ -286,8 +297,8 @@ public class ClassFileToIndexConverter {
 		}
 
 		method.setMethodId(createMethodId(binaryTypeName, next.getSelector(), next.getMethodDescriptor()));
-
 		method.setModifiers(next.getModifiers());
+		method.setTagBits(next.getTagBits());
 	}
 
 	/**
@@ -311,6 +322,7 @@ public class ClassFileToIndexConverter {
 
 		ITypeAnnotationWalker annotationWalker = getTypeAnnotationWalker(nextField.getTypeAnnotations());
 		variable.setType(createTypeSignature(annotationWalker, nextTypeSignature));
+		variable.setTagBits(nextField.getTagBits());
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 3c2d034..135b448 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -242,6 +242,12 @@ public final class Indexer {
 		try {
 			resourceFile = new NdResourceFile(this.pdom);
 			resourceFile.setFilename(pathString);
+			IPackageFragmentRoot packageFragmentRoot = (IPackageFragmentRoot) element
+					.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+			IPath rootPathString = getFilesystemPathForRoot(packageFragmentRoot);
+			if (!rootPathString.equals(thePath)) {
+				resourceFile.setPackageFragmentRoot(rootPathString.toString().toCharArray());
+			}
 			attachWorkspaceFilesToResource(elementsMappingOntoLocation, resourceFile);
 		} finally {
 			this.pdom.releaseWriteLock();
@@ -327,7 +333,6 @@ public final class Indexer {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 		List<IJavaElement> bindableElements = getBindableElements(element, subMonitor.newChild(10));
 		List<IClassFile> classFiles = getClassFiles(bindableElements);
-		IJavaProject javaProject = element.getJavaProject();
 
 		subMonitor.setWorkRemaining(classFiles.size());
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 08770bb..37275c0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -31,9 +31,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 20);
-	static final int MAX_SUPPORTED_VERSION= Nd.version(1, 21);
-	static final int MIN_SUPPORTED_VERSION= Nd.version(1, 21);
+	static final int CURRENT_VERSION = Nd.version(1, 22);
+	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 22);
+	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 22);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 380d040..7c320bc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -155,4 +155,18 @@ public class JavaNames {
 		}
 		return CharArrayUtils.substring(chars, startPosition);
 	}
+
+	/**
+	 * Returns true iff the given method selector is a constructor.
+	 */
+	public static boolean isConstructor(char[] selector) {
+		return selector[0] == '<' && selector.length == 6; // Can only match <init>
+	}
+
+	/**
+	 * Returns true iff the given method selector is clinit.
+	 */
+	public static boolean isClinit(char[] selector) {
+		return selector[0] == '<' && selector.length == 8; // Can only match <clinit>
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
index bf2c200..f59fbdc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
@@ -28,6 +28,7 @@ public class NdAnnotation extends NdNode {
 	public static final FieldOneToMany<NdAnnotationValuePair> ELEMENT_VALUE_PAIRS;
 	public static final FieldOneToOne<NdConstantAnnotation> PARENT_CONSTANT;
 	public static final FieldManyToOne<NdComplexTypeSignature> PARENT_TYPE_SIGNATURE;
+	public static final FieldManyToOne<NdMethodParameter> PARENT_METHOD_PARAMETER;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdAnnotation> type;
@@ -39,6 +40,7 @@ public class NdAnnotation extends NdNode {
 		ELEMENT_VALUE_PAIRS = FieldOneToMany.create(type, NdAnnotationValuePair.APPLIES_TO);
 		PARENT_CONSTANT = FieldOneToOne.createOwner(type, NdConstantAnnotation.class, NdConstantAnnotation.VALUE);
 		PARENT_TYPE_SIGNATURE = FieldManyToOne.createOwner(type, NdComplexTypeSignature.ANNOTATIONS);
+		PARENT_METHOD_PARAMETER = FieldManyToOne.createOwner(type, NdMethodParameter.ANNOTATIONS);
 		type.done();
 	}
 
@@ -75,4 +77,12 @@ public class NdAnnotation extends NdNode {
 	public List<NdAnnotationValuePair> getElementValuePairs() {
 		return ELEMENT_VALUE_PAIRS.asList(getNd(), this.address);
 	}
+
+	public void setParent(NdMethodParameter parameter) {
+		PARENT_METHOD_PARAMETER.put(getNd(), this.address, parameter);
+	}
+
+	public NdMethodParameter getMethodParameter() {
+		return PARENT_METHOD_PARAMETER.get(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index 70ad894..a1e8974 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -59,6 +59,10 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		FILE.put(pdom, this.address, resource);
 	}
 
+	public List<NdVariable> getVariables() {
+		return VARIABLES.asList(getNd(), this.address);
+	}
+
 	/**
 	 * Tests whether this binding has one of the flags defined in {@link Flags}
 	 */
@@ -77,24 +81,8 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		return MODIFIERS.get(getNd(), this.address);
 	}
 
-	public NdAnnotation[] getAnnotations() {
-		int numAnnotations = ANNOTATIONS.size(getNd(), this.address);
-
-		if (numAnnotations == 0) {
-			return NO_ANNOTATIONS;
-		}
-
-		final NdAnnotation[] result = new NdAnnotation[numAnnotations];
-
-		// If we got this far, the pointer to the linked list is non-null
-		ANNOTATIONS.accept(getNd(), this.address, new FieldOneToMany.Visitor<NdAnnotation>() {
-			@Override
-			public void visit(int index, NdAnnotation toVisit) {
-				result[index] = toVisit;
-			}
-		});
-
-		return result;
+	public List<NdAnnotation> getAnnotations() {
+		return ANNOTATIONS.asList(getNd(), this.address);
 	}
 
 	@Override
@@ -140,7 +128,7 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		return result;
 	}
 
-	private List<NdTypeParameter> getTypeParameters() {
+	public List<NdTypeParameter> getTypeParameters() {
 		return TYPE_PARAMETERS.asList(getNd(), this.address);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index 0c8c289..2d6456f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -10,7 +10,10 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldLong;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
@@ -29,6 +32,7 @@ public class NdMethod extends NdBinding {
 	public static final FieldOneToOne<NdConstant> DEFAULT_VALUE;
 	public static final FieldOneToMany<NdMethodException> EXCEPTIONS;
 	public static final FieldManyToOne<NdTypeSignature> RETURN_TYPE;
+	public static final FieldLong TAG_BITS;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdMethod> type;
@@ -43,6 +47,7 @@ public class NdMethod extends NdBinding {
 		DEFAULT_VALUE = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_METHOD);
 		EXCEPTIONS = FieldOneToMany.create(type, NdMethodException.PARENT);
 		RETURN_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_RETURN_TYPE);
+		TAG_BITS = type.addLong();
 		type.done();
 	}
 
@@ -70,6 +75,20 @@ public class NdMethod extends NdBinding {
 		return METHOD_ID.get(getNd(), this.address);
 	}
 
+	public char[][] getArgumentNames() {
+		List<NdMethodParameter> params = getMethodParameters();
+
+		char[][] result = new char[params.size()][];
+		for (int idx = 0; idx < result.length; idx++) {
+			result[idx] = params.get(idx).getName().getChars();
+		}
+		return result;
+	}
+
+	public List<NdMethodParameter> getMethodParameters() {
+		return PARAMETERS.asList(getNd(), this.address);
+	}
+
 	public void setDefaultValue(NdConstant value) {
 		DEFAULT_VALUE.put(getNd(), this.address, value);
 	}
@@ -85,4 +104,23 @@ public class NdMethod extends NdBinding {
 	public void setMethodId(NdMethodId methodId) {
 		METHOD_ID.put(getNd(), this.address, methodId);
 	}
+
+	public List<NdMethodException> getExceptions() {
+		return EXCEPTIONS.asList(getNd(), this.address);
+	}
+
+	/**
+	 * Returns the return type for this method or null if the method returns void
+	 */
+	public NdTypeSignature getReturnType() {
+		return RETURN_TYPE.get(getNd(), this.address);
+	}
+
+	public void setTagBits(long bits) {
+		TAG_BITS.put(getNd(), this.address, bits);
+	}
+
+	public long getTagBits() {
+		return TAG_BITS.get(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
index ee9f430..20c3297 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
@@ -31,4 +31,11 @@ public class NdMethodException extends NdNode {
 		EXCEPTION_TYPE.put(getNd(), this.address, createTypeSignature);
 	}
 
+	public NdTypeSignature getExceptionType() {
+		return EXCEPTION_TYPE.get(getNd(), this.address);
+	}
+
+	public NdMethod getParent() {
+		return PARENT.get(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
index 31a6714..4d06029 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
@@ -18,6 +18,7 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 
 /**
  * Represents the fully-qualified signature a method. Holds back-pointers to all the entities that refer to the name,
@@ -73,4 +74,28 @@ public class NdMethodId extends NdNode {
 	public IString getMethodName() {
 		return METHOD_NAME.get(getNd(), this.address);
 	}
+
+	public char[] getSelector() {
+		char[] name = getMethodName().getChars();
+		int selectorStart = CharArrayUtils.indexOf('#', name) + 1;
+		int selectorEnd = CharArrayUtils.indexOf('(', name, selectorStart, name.length);
+		if (selectorEnd == -1) {
+			selectorEnd = name.length;
+		}
+		return CharArrayUtils.subarray(name, selectorStart, selectorEnd);
+	}
+
+	public boolean isConstructor() {
+		return JavaNames.isConstructor(getSelector());
+	}
+
+	public char[] getMethodDescriptor() {
+		char[] name = getMethodName().getChars();
+		int descriptorStart = CharArrayUtils.indexOf('(', name, 0, name.length);
+		return CharArrayUtils.subarray(name, descriptorStart, name.length);
+	}
+
+	public boolean isClInit() {
+		return JavaNames.isClinit(getSelector());
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
index 02c0c30..9f3e793 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
@@ -1,8 +1,12 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
+import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
@@ -10,6 +14,7 @@ public class NdMethodParameter extends NdNode {
 	public static final FieldManyToOne<NdMethod> PARENT;
 	public static final FieldManyToOne<NdTypeSignature> ARGUMENT_TYPE;
 	public static final FieldString NAME;
+	public static final FieldOneToMany<NdAnnotation> ANNOTATIONS;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<NdMethodParameter> type;
@@ -19,6 +24,7 @@ public class NdMethodParameter extends NdNode {
 		PARENT = FieldManyToOne.create(type, NdMethod.PARAMETERS);
 		ARGUMENT_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_METHOD_ARGUMENT);
 		NAME = type.addString();
+		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotation.PARENT_METHOD_PARAMETER);
 		type.done();
 	}
 
@@ -33,7 +39,19 @@ public class NdMethodParameter extends NdNode {
 		ARGUMENT_TYPE.put(getNd(), this.address, argumentType);
 	}
 
+	public NdTypeSignature getType() {
+		return ARGUMENT_TYPE.get(getNd(), this.address);
+	}
+
 	public void setName(char[] name) {
 		NAME.put(getNd(), this.address, name);
 	}
+
+	public IString getName() {
+		return NAME.get(getNd(), this.address);
+	}
+
+	public List<NdAnnotation> getAnnotations() {
+		return ANNOTATIONS.asList(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 410e14c..2b4e3cf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -27,6 +27,7 @@ import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany.Visitor;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.IResultRank;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.SearchCriteria;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
+import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
@@ -40,6 +41,7 @@ public class NdResourceFile extends NdTreeNode {
 	public static final FieldLong SIZE_LAST_SCANNED;
 	public static final FieldLong HASHCODE_LAST_SCANNED;
 	public static final FieldOneToMany<NdWorkspaceLocation> WORKSPACE_MAPPINGS;
+	public static final FieldString JAVA_ROOT;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdResourceFile> type;
@@ -52,6 +54,7 @@ public class NdResourceFile extends NdTreeNode {
 		SIZE_LAST_SCANNED = type.addLong();
 		HASHCODE_LAST_SCANNED = type.addLong();
 		WORKSPACE_MAPPINGS = FieldOneToMany.create(type, NdWorkspaceLocation.RESOURCE);
+		JAVA_ROOT = type.addString();
 		type.done();
 	}
 
@@ -176,4 +179,20 @@ public class NdResourceFile extends NdTreeNode {
 		HASHCODE_LAST_SCANNED.put(getNd(), this.address, newFingerprint.getHash());
 		SIZE_LAST_SCANNED.put(getNd(), this.address, newFingerprint.getSize());
 	}
+
+	public void setPackageFragmentRoot(char[] javaRoot) {
+		JAVA_ROOT.put(getNd(), this.address, javaRoot);
+	}
+
+	/**
+	 * Returns the absolute path to the java root for this .jar or .class file. If this is a .jar file, it returns its
+	 * own filename.
+	 */
+	public IString getPackageFragmentRoot() {
+		IString javaRoot = JAVA_ROOT.get(getNd(), this.address);
+		if (javaRoot.length() == 0) {
+			return getFilename();
+		}
+		return javaRoot;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 5c9b4c4..aa2ebba 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -18,6 +18,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.field.FieldByte;
+import org.eclipse.jdt.internal.core.nd.field.FieldLong;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -37,6 +38,7 @@ public class NdType extends NdBinding {
 	public static final FieldString SOURCE_FILE_NAME;
 	public static final FieldString INNER_CLASS_SOURCE_NAME;
 	public static final FieldByte FLAGS;
+	public static final FieldLong TAG_BITS;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdType> type;
@@ -53,6 +55,7 @@ public class NdType extends NdBinding {
 		SOURCE_FILE_NAME = type.addString();
 		INNER_CLASS_SOURCE_NAME = type.addString();
 		FLAGS = type.addByte();
+		TAG_BITS = type.addLong();
 		type.done();
 	}
 
@@ -201,6 +204,15 @@ public class NdType extends NdBinding {
 	}
 
 	@Override
+	public List<NdTypeParameter> getTypeParameters() {
+		return TYPE_PARAMETERS.asList(getNd(), this.address);
+	}
+
+	public List<NdMethod> getMethods() {
+		return METHODS.asList(getNd(), this.address);
+	}
+
+	@Override
 	public String toString() {
 		try {
 			return "class " + new String(getSourceName()); //$NON-NLS-1$
@@ -208,4 +220,12 @@ public class NdType extends NdBinding {
 			return super.toString();
 		}
 	}
+
+	public void setTagBits(long tagBits) {
+		TAG_BITS.put(getNd(), this.address, tagBits);
+	}
+
+	public long getTagBits() {
+		return TAG_BITS.get(getNd(), this.address);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 9992a49..fddd704 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -98,6 +98,10 @@ public class NdTypeId extends NdTypeSignature {
 		SIMPLE_NAME.put(getNd(), this.address, name);
 	}
 
+	public List<NdType> getDeclaredTypes() {
+		return DECLARED_TYPES.asList(getNd(), this.address);
+	}
+
 	@Override
 	public NdTypeId getRawType() {
 		return this;
@@ -127,4 +131,9 @@ public class NdTypeId extends NdTypeSignature {
 	public NdTypeSignature getArrayDimensionType() {
 		return null;
 	}
+
+	@Override
+	public List<NdTypeArgument> getTypeArguments() {
+		return Collections.emptyList();
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index 5de47c7..015240c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -129,4 +129,9 @@ public abstract class NdTypeSignature extends NdNode {
 	 * this is not an array type.
 	 */
 	public abstract NdTypeSignature getArrayDimensionType();
+
+	/**
+	 * Returns the type arguments for this type signature, if any. Returns the empty list if none.
+	 */
+	public abstract List<NdTypeArgument> getTypeArguments();
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index c0b3dc6..00d8a5c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -11,7 +11,9 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldInt;
+import org.eclipse.jdt.internal.core.nd.field.FieldLong;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -28,6 +30,7 @@ public class NdVariable extends NdBinding {
 	public static final FieldManyToOne<NdBinding> PARENT;
 	public static final FieldString NAME;
 	public static final FieldOneToOne<NdConstant> CONSTANT;
+	public static final FieldLong TAG_BITS;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<NdVariable> type;
@@ -46,6 +49,7 @@ public class NdVariable extends NdBinding {
 		PARENT = FieldManyToOne.create(type, NdBinding.VARIABLES);
 		NAME = type.addString();
 		CONSTANT = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_VARIABLE);
+		TAG_BITS = type.addLong();
 		type.done();
 	}
 
@@ -72,8 +76,8 @@ public class NdVariable extends NdBinding {
 		NAME.put(getNd(), this.address, name);
 	}
 
-	public String getName() {
-		return NAME.get(getNd(), this.address).getString();
+	public IString getName() {
+		return NAME.get(getNd(), this.address);
 	}
 
 	public void setType(NdTypeSignature typeId) {
@@ -83,4 +87,20 @@ public class NdVariable extends NdBinding {
 	public void setConstant(NdConstant constant) {
 		CONSTANT.put(getNd(), this.address, constant);
 	}
+
+	public NdConstant getConstant() {
+		return CONSTANT.get(getNd(), this.address);
+	}
+
+	public NdTypeSignature getType() {
+		return TYPE.get(getNd(), this.address);
+	}
+
+	public long getTagBits() {
+		return TAG_BITS.get(getNd(), this.address);
+	}
+
+	public void setTagBits(long tagBits) {
+		TAG_BITS.put(getNd(), this.address, tagBits);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
index 62fdb99..20b8735 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
@@ -12,11 +12,11 @@ public class IndexBinaryField implements IBinaryField {
 	private Constant constant;
 	private char[] genericSignature;
 	private char[] name;
-	private int tagBits;
+	private long tagBits;
 	private char[] typeName;
 
-	public IndexBinaryField(IBinaryAnnotation[] annotations, Constant constant, char[] genericSignature,
-			int modifiers, char[] name, int tagBits, IBinaryTypeAnnotation[] typeAnnotations, char[] typeName) {
+	public IndexBinaryField(IBinaryAnnotation[] annotations, Constant constant, char[] genericSignature, int modifiers,
+			char[] name, long tagBits, IBinaryTypeAnnotation[] typeAnnotations, char[] typeName) {
 		super();
 		this.modifiers = modifiers;
 		this.annotations = annotations;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
new file mode 100644
index 0000000..63f8d3f
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
@@ -0,0 +1,166 @@
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+
+public final class IndexBinaryMethod implements IBinaryMethod {
+	private int modifiers;
+	private boolean isConstructor;
+	private char[][] argumentNames;
+	private IBinaryAnnotation[] annotations;
+	private Object defaultValue;
+	private char[][] exceptionTypeNames;
+	private char[] genericSignature;
+	private char[] methodDescriptor;
+	private IBinaryAnnotation[][] parameterAnnotations;
+	private char[] selector;
+	private long tagBits;
+	private boolean isClInit;
+	private IBinaryTypeAnnotation[] typeAnnotations;
+
+	public static IndexBinaryMethod create() {
+		return new IndexBinaryMethod();
+	}
+
+	public IndexBinaryMethod setModifiers(int modifiers) {
+		this.modifiers = modifiers;
+		return this;
+	}
+
+	public IndexBinaryMethod setIsConstructor(boolean isConstructor) {
+		this.isConstructor = isConstructor;
+		return this;
+	}
+
+	public IndexBinaryMethod setArgumentNames(char[][] argumentNames) {
+		this.argumentNames = argumentNames;
+		return this;
+	}
+
+	public IndexBinaryMethod setAnnotations(IBinaryAnnotation[] annotations) {
+		this.annotations = annotations;
+		return this;
+	}
+
+	public IndexBinaryMethod setDefaultValue(Object defaultValue) {
+		this.defaultValue = defaultValue;
+		return this;
+	}
+
+	public IndexBinaryMethod setExceptionTypeNames(char[][] exceptionTypeNames) {
+		this.exceptionTypeNames = exceptionTypeNames;
+		return this;
+	}
+
+	public IndexBinaryMethod setGenericSignature(char[] genericSignature) {
+		this.genericSignature = genericSignature;
+		return this;
+	}
+
+	public IndexBinaryMethod setMethodDescriptor(char[] methodDescriptor) {
+		this.methodDescriptor = methodDescriptor;
+		return this;
+	}
+
+	public IndexBinaryMethod setParameterAnnotations(IBinaryAnnotation[][] parameterAnnotations) {
+		this.parameterAnnotations = parameterAnnotations;
+		return this;
+	}
+
+	public IndexBinaryMethod setSelector(char[] selector) {
+		this.selector = selector;
+		return this;
+	}
+
+	public IndexBinaryMethod setTagBits(long tagBits) {
+		this.tagBits = tagBits;
+		return this;
+	}
+
+	public IndexBinaryMethod setIsClInit(boolean isClInit) {
+		this.isClInit = isClInit;
+		return this;
+	}
+
+	public IndexBinaryMethod setTypeAnnotations(IBinaryTypeAnnotation[] typeAnnotations) {
+		this.typeAnnotations = typeAnnotations;
+		return this;
+	}
+
+	@Override
+	public int getModifiers() {
+		return this.modifiers;
+	}
+
+	@Override
+	public boolean isConstructor() {
+		return this.isConstructor;
+	}
+
+	@Override
+	public char[][] getArgumentNames() {
+		return this.argumentNames;
+	}
+
+	@Override
+	public IBinaryAnnotation[] getAnnotations() {
+		return this.annotations;
+	}
+
+	@Override
+	public Object getDefaultValue() {
+		return this.defaultValue;
+	}
+
+	@Override
+	public char[][] getExceptionTypeNames() {
+		return this.exceptionTypeNames;
+	}
+
+	@Override
+	public char[] getGenericSignature() {
+		return this.genericSignature;
+	}
+
+	@Override
+	public char[] getMethodDescriptor() {
+		return this.methodDescriptor;
+	}
+
+	@Override
+	public IBinaryAnnotation[] getParameterAnnotations(int index, char[] classFileName) {
+		if (this.parameterAnnotations == null || this.parameterAnnotations.length <= index) {
+			return null;
+		}
+		return this.parameterAnnotations[index];
+	}
+
+	@Override
+	public int getAnnotatedParametersCount() {
+		if (this.parameterAnnotations == null) {
+			return 0;
+		}
+		return this.parameterAnnotations.length;
+	}
+
+	@Override
+	public char[] getSelector() {
+		return this.selector;
+	}
+
+	@Override
+	public long getTagBits() {
+		return this.tagBits;
+	}
+
+	@Override
+	public boolean isClinit() {
+		return this.isClInit;
+	}
+
+	@Override
+	public IBinaryTypeAnnotation[] getTypeAnnotations() {
+		return this.typeAnnotations;
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryNestedType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryNestedType.java
new file mode 100644
index 0000000..0112a3f
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryNestedType.java
@@ -0,0 +1,32 @@
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
+
+public class IndexBinaryNestedType implements IBinaryNestedType {
+	private char[] enclosingTypeName;
+	private char[] name;
+	private int modifiers;
+
+	public IndexBinaryNestedType(char[] name, char[] enclosingTypeName, int modifiers) {
+		super();
+		this.name = name;
+		this.enclosingTypeName = enclosingTypeName;
+		this.modifiers = modifiers;
+	}
+
+	@Override
+	public char[] getEnclosingTypeName() {
+		return this.enclosingTypeName;
+	}
+
+	@Override
+	public int getModifiers() {
+		return this.modifiers;
+	}
+
+	@Override
+	public char[] getName() {
+		return this.name;
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
new file mode 100644
index 0000000..6649fb7
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -0,0 +1,649 @@
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ElementValuePairInfo;
+import org.eclipse.jdt.internal.compiler.env.ClassSignature;
+import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryField;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.core.nd.DatabaseRef;
+import org.eclipse.jdt.internal.core.nd.IReader;
+import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.java.JavaNames;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotation;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationValuePair;
+import org.eclipse.jdt.internal.core.nd.java.NdConstant;
+import org.eclipse.jdt.internal.core.nd.java.NdConstantAnnotation;
+import org.eclipse.jdt.internal.core.nd.java.NdConstantArray;
+import org.eclipse.jdt.internal.core.nd.java.NdConstantClass;
+import org.eclipse.jdt.internal.core.nd.java.NdConstantEnum;
+import org.eclipse.jdt.internal.core.nd.java.NdMethod;
+import org.eclipse.jdt.internal.core.nd.java.NdMethodException;
+import org.eclipse.jdt.internal.core.nd.java.NdMethodId;
+import org.eclipse.jdt.internal.core.nd.java.NdMethodParameter;
+import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
+import org.eclipse.jdt.internal.core.nd.java.NdType;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeArgument;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeBound;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
+import org.eclipse.jdt.internal.core.nd.java.NdVariable;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
+import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
+
+/**
+ * Implementation of {@link IBinaryType} that reads all its content from the index
+ */
+public class IndexBinaryType implements IBinaryType {
+	private final DatabaseRef<NdType> typeRef;
+
+	private boolean enclosingInitialized;
+	private char[] enclosingMethod;
+	private char[] enclosingType;
+
+	public IndexBinaryType(DatabaseRef<NdType> type) {
+		this.typeRef = type;
+	}
+
+	@Override
+	public int getModifiers() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getModifiers();
+			} else {
+				return 0;
+			}
+		}
+	}
+
+	@Override
+	public boolean isBinaryType() {
+		return true;
+	}
+
+	@Override
+	public char[] getFileName() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getFile().getFilename().getChars();
+			} else {
+				return new char[0];
+			}
+		}
+	}
+
+	@Override
+	public IBinaryAnnotation[] getAnnotations() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return toAnnotationArray(this.typeRef.get().getAnnotations());
+			} else {
+				return null;
+			}
+		}
+	}
+
+	private static IBinaryAnnotation[] toAnnotationArray(List<NdAnnotation> annotations) {
+		if (annotations.isEmpty()) {
+			return null;
+		}
+		IBinaryAnnotation[] result = new IBinaryAnnotation[annotations.size()];
+
+		for (int idx = 0; idx < result.length; idx++) {
+			result[idx] = createBinaryAnnotation(annotations.get(idx));
+		}
+		return result;
+	}
+
+	@Override
+	public IBinaryTypeAnnotation[] getTypeAnnotations() {
+		List<IBinaryTypeAnnotation> result = new ArrayList<>();
+		ITypeAnnotationBuilder annotationBuilder = TypeAnnotationBuilder.create();
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				NdTypeSignature superclass = type.getSuperclass();
+				if (superclass != null) {
+					buildAnnotations(result, annotationBuilder.toSupertype((short)-1), superclass);
+				}
+
+				List<NdTypeInterface> interfaces = type.getInterfaces();
+
+				for (short interfaceIdx = 0; interfaceIdx < interfaces.size(); interfaceIdx++) {
+					NdTypeInterface next = interfaces.get(interfaceIdx);
+
+					buildAnnotations(result, annotationBuilder.toSupertype(interfaceIdx), next.getInterface());
+				}
+			}
+		}
+		return toTypeAnnotationArray(result);
+	}
+
+	@Override
+	public char[] getEnclosingMethod() {
+		initEnclosing();
+
+		return this.enclosingMethod;
+	}
+
+	@Override
+	public char[] getEnclosingTypeName() {
+		initEnclosing();
+
+		return this.enclosingType;
+	}
+
+	@Override
+	public IBinaryField[] getFields() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				List<NdVariable> variables = type.getVariables();
+
+				IBinaryField[] result = new IBinaryField[variables.size()];
+				for (int fieldIdx = 0; fieldIdx < variables.size(); fieldIdx++) {
+					result[fieldIdx] = createBinaryField(variables.get(fieldIdx));
+				}
+				return result;
+			} else {
+				return new IBinaryField[0];
+			}
+		}
+	}
+
+	@Override
+	public char[] getGenericSignature() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				CharArrayBuffer buffer = new CharArrayBuffer();
+
+				getSignature(buffer, type.getTypeParameters());
+
+				NdTypeSignature superclass = type.getSuperclass();
+				superclass.getSignature(buffer);
+				for (NdTypeInterface nextInterface : type.getInterfaces()) {
+					nextInterface.getInterface().getSignature(buffer);
+				}
+				return buffer.getContents();
+			} else {
+				return null;
+			}
+		}
+	}
+
+	@Override
+	public char[][] getInterfaceNames() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				List<NdTypeInterface> interfaces = type.getInterfaces();
+
+				char[][] result = new char[interfaces.size()][];
+				for (int idx = 0; idx < interfaces.size(); idx++) {
+					NdTypeSignature nextInterface = interfaces.get(idx).getInterface();
+
+					result[idx] = nextInterface.getRawType().getBinaryName();
+				}
+				return result;
+			} else {
+				return null;
+			}
+		}
+	}
+
+	@Override
+	public IBinaryNestedType[] getMemberTypes() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				List<NdType> declaredTypes = type.getTypeId().getDeclaredTypes();
+				if (declaredTypes.isEmpty()) {
+					return null;
+				}
+
+				NdResourceFile resFile = type.getResourceFile();
+				IString javaRoot = resFile.getPackageFragmentRoot();
+
+				// Filter out all the declared types which are at different java roots (only keep the ones belonging
+				// to the same .jar file or to another .class file in the same folder).
+				List<IBinaryNestedType> result = new ArrayList<>();
+				for (NdType next : declaredTypes) {
+					NdResourceFile nextResFile = next.getResourceFile();
+
+					if (nextResFile.getPackageFragmentRoot().compare(javaRoot, true) == 0) {
+						result.add(createBinaryNestedType(next));
+					}
+				}
+				return result.isEmpty() ? null : result.toArray(new IBinaryNestedType[result.size()]);
+			} else {
+				return null;
+			}
+		}
+	}
+
+	private IBinaryNestedType createBinaryNestedType(NdType next) {
+		return new IndexBinaryNestedType(next.getTypeId().getBinaryName(), next.getDeclaringType().getBinaryName(),
+				next.getModifiers());
+	}
+
+	@Override
+	public IBinaryMethod[] getMethods() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				List<NdMethod> methods = type.getMethods();
+
+				if (methods.isEmpty()) {
+					return null;
+				}
+
+				IBinaryMethod[] result = new IBinaryMethod[methods.size()];
+				for (int idx = 0; idx < result.length; idx++) {
+					result[idx] = createBinaryMethod(methods.get(idx));
+				}
+
+				return result;
+			} else {
+				return null;
+			}
+		}
+	}
+
+	@Override
+	public char[][][] getMissingTypeNames() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				IString string = type.getMissingTypeNames();
+				if (string.length() == 0) {
+					return null;
+				}
+				char[] missingTypeNames = string.getChars();
+				char[][] paths = CharOperation.splitOn(',', missingTypeNames);
+				char[][][] result = new char[paths.length][][];
+				for (int idx = 0; idx < paths.length; idx++) {
+					result[idx] = CharOperation.splitOn('/', paths[idx]);
+				}
+				return result;
+			} else {
+				return null;
+			}
+		}
+	}
+
+	@Override
+	public char[] getName() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getTypeId().getBinaryName();
+			} else {
+				return new char[0];
+			}
+		}
+	}
+
+	@Override
+	public char[] getSourceName() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getSourceName();
+			} else {
+				return new char[0];
+			}
+		}
+	}
+
+	@Override
+	public char[] getSuperclassName() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getSuperclass().getRawType().getBinaryName();
+			} else {
+				return new char[0];
+			}
+		}
+	}
+
+	@Override
+	public long getTagBits() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getTagBits();
+			} else {
+				return 0;
+			}
+		}
+	}
+
+	@Override
+	public boolean isAnonymous() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.isAnonymous();
+			} else {
+				return false;
+			}
+		}
+	}
+
+	@Override
+	public boolean isLocal() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.isLocal();
+			} else {
+				return false;
+			}
+		}
+	}
+
+	@Override
+	public boolean isMember() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.isMember();
+			} else {
+				return false;
+			}
+		}
+	}
+
+	@Override
+	public char[] sourceFileName() {
+		try (IReader rl = this.typeRef.lock()) {
+			NdType type = this.typeRef.get();
+			if (type != null) {
+				return type.getSourceFileName().getChars();
+			} else {
+				return new char[0];
+			}
+		}
+	}
+
+	@Override
+	public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member,
+			LookupEnvironment environment) {
+		return walker;
+	}
+
+	private void getSignature(CharArrayBuffer buffer, List<NdTypeParameter> params) {
+		if (!params.isEmpty()) {
+			buffer.append('<');
+			for (NdTypeParameter next : params) {
+				next.getSignature(buffer);
+			}
+			buffer.append('>');
+		}
+	}
+
+	private IBinaryMethod createBinaryMethod(NdMethod ndMethod) {
+		NdMethodId methodId = ndMethod.getMethodId();
+
+		List<IBinaryTypeAnnotation> typeAnnotations = new ArrayList<>();
+		ITypeAnnotationBuilder annotationBuilder = TypeAnnotationBuilder.create();
+
+		List<NdTypeParameter> typeParameters = ndMethod.getTypeParameters();
+		for (int parameterIdx = 0; parameterIdx < typeParameters.size(); parameterIdx++) {
+			NdTypeParameter next = typeParameters.get(parameterIdx);
+
+			List<NdTypeBound> bounds = next.getBounds();
+			for (int boundsIdx = 0; boundsIdx < bounds.size(); boundsIdx++) {
+				NdTypeBound nextBound = bounds.get(boundsIdx);
+
+				NdTypeSignature type = nextBound.getType();
+
+				if (type != null) {
+					buildAnnotations(typeAnnotations,
+							annotationBuilder.toTypeParameter(false, parameterIdx).toTypeBound((short) boundsIdx),
+							type);
+				}
+			}
+		}
+
+		List<NdMethodParameter> args = ndMethod.getMethodParameters();
+		for (int argIdx = 0; argIdx < args.size(); argIdx++) {
+			buildAnnotations(typeAnnotations, annotationBuilder.toMethodParameter((short) argIdx),
+					args.get(argIdx).getAnnotations());
+		}
+
+		buildAnnotations(typeAnnotations, annotationBuilder.toMethodReturn(), ndMethod.getReturnType());
+
+		List<NdMethodException> exceptions = ndMethod.getExceptions();
+
+		for (int exceptionIdx = 0; exceptionIdx < exceptions.size(); exceptionIdx++) {
+			NdMethodException next = exceptions.get(exceptionIdx);
+
+			buildAnnotations(typeAnnotations, annotationBuilder.toThrows(exceptionIdx), next.getExceptionType());
+		}
+
+		return IndexBinaryMethod.create().setAnnotations(toAnnotationArray(ndMethod.getAnnotations()))
+				.setModifiers(ndMethod.getModifiers()).setIsConstructor(methodId.isConstructor())
+				.setArgumentNames(ndMethod.getArgumentNames()).setDefaultValue(unpackValue(ndMethod.getDefaultValue()))
+				.setExceptionTypeNames(getExceptionTypeNames(ndMethod))
+				.setGenericSignature(getGenericSignatureFor(ndMethod))
+				.setMethodDescriptor(methodId.getMethodDescriptor())
+				.setParameterAnnotations(getParameterAnnotations(ndMethod))
+				.setSelector(ndMethod.getMethodId().getSelector()).setTagBits(ndMethod.getTagBits())
+				.setIsClInit(methodId.isClInit()).setTypeAnnotations(toTypeAnnotationArray(typeAnnotations));
+	}
+
+	private IBinaryTypeAnnotation[] toTypeAnnotationArray(List<IBinaryTypeAnnotation> result) {
+		return result.isEmpty() ? null
+				: (IBinaryTypeAnnotation[]) result.toArray(new IBinaryTypeAnnotation[result.size()]);
+	}
+
+	private IBinaryAnnotation[][] getParameterAnnotations(NdMethod ndMethod) {
+		List<NdMethodParameter> parameters = ndMethod.getMethodParameters();
+		if (parameters.isEmpty()) {
+			return null;
+		}
+
+		IBinaryAnnotation[][] result = new IBinaryAnnotation[parameters.size()][];
+		for (int idx = 0; idx < parameters.size(); idx++) {
+			NdMethodParameter next = parameters.get(idx);
+
+			result[idx] = toAnnotationArray(next.getAnnotations());
+		}
+		return result;
+	}
+
+	private char[] getGenericSignatureFor(NdMethod method) {
+		CharArrayBuffer result = new CharArrayBuffer();
+		getSignature(result, method.getTypeParameters());
+
+		result.append('(');
+		for (NdMethodParameter next : method.getMethodParameters()) {
+			next.getType().getSignature(result);
+		}
+		result.append(')');
+		NdTypeSignature returnType = method.getReturnType();
+		if (returnType == null) {
+			result.append('V');
+		} else {
+			returnType.getSignature(result);
+		}
+		List<NdMethodException> exceptions = method.getExceptions();
+		for (NdMethodException next : exceptions) {
+			result.append('^');
+			next.getExceptionType().getSignature(result);
+		}
+		return result.getContents();
+	}
+
+	private char[][] getExceptionTypeNames(NdMethod ndMethod) {
+		List<NdMethodException> exceptions = ndMethod.getExceptions();
+
+		if (exceptions.isEmpty()) {
+			return null;
+		}
+
+		char[][] result = new char[exceptions.size()][];
+		for (int idx = 0; idx < exceptions.size(); idx++) {
+			NdMethodException next = exceptions.get(idx);
+
+			result[idx] = next.getExceptionType().getRawType().getBinaryName();
+		}
+		return result;
+	}
+
+	public static IBinaryField createBinaryField(NdVariable ndVariable) {
+		char[] name = ndVariable.getName().getChars();
+		Constant constant = null;
+		NdConstant ndConstant = ndVariable.getConstant();
+		if (ndConstant != null) {
+			constant = ndConstant.getConstant();
+		}
+
+		List<IBinaryTypeAnnotation> typeAnnotations = new ArrayList<>();
+		NdTypeSignature type = ndVariable.getType();
+		buildAnnotations(typeAnnotations, TypeAnnotationBuilder.create(), type);
+		IBinaryTypeAnnotation[] typeAnnotationArray = typeAnnotations.isEmpty() ? null
+				: (IBinaryTypeAnnotation[]) typeAnnotations.toArray(new IBinaryTypeAnnotation[typeAnnotations.size()]);
+
+		IBinaryAnnotation[] annotations = toAnnotationArray(ndVariable.getAnnotations());
+
+		CharArrayBuffer signature = new CharArrayBuffer();
+		type.getSignature(signature);
+
+		long tagBits = ndVariable.getTagBits();
+		return new IndexBinaryField(annotations, constant, signature.getContents(), ndVariable.getModifiers(), name,
+				tagBits, typeAnnotationArray, type.getRawType().getBinaryName());
+	}
+
+	public static IBinaryAnnotation createBinaryAnnotation(NdAnnotation ndAnnotation) {
+		List<NdAnnotationValuePair> elementValuePairs = ndAnnotation.getElementValuePairs();
+
+		final IBinaryElementValuePair[] resultingPair = new IBinaryElementValuePair[elementValuePairs.size()];
+
+		for (int idx = 0; idx < elementValuePairs.size(); idx++) {
+			NdAnnotationValuePair next = elementValuePairs.get(idx);
+
+			resultingPair[idx] = new ElementValuePairInfo(next.getName().getChars(), unpackValue(next.getValue()));
+		}
+
+		final char[] binaryName = JavaNames
+				.fieldDescriptorToBinaryName(ndAnnotation.getType().getRawType().getFieldDescriptor().getChars());
+
+		return new IBinaryAnnotation() {
+			@Override
+			public char[] getTypeName() {
+				return binaryName;
+			}
+
+			@Override
+			public IBinaryElementValuePair[] getElementValuePairs() {
+				return resultingPair;
+			}
+		};
+	}
+
+	private static void buildAnnotations(List<IBinaryTypeAnnotation> result, ITypeAnnotationBuilder builder,
+			NdTypeSignature signature) {
+		ITypeAnnotationBuilder nextAnnotations = builder;
+		List<NdTypeSignature> declaringTypes = signature.getDeclaringTypeChain();
+
+		for (NdTypeSignature next : declaringTypes) {
+			buildAnnotations(result, nextAnnotations, next.getAnnotations());
+
+			NdTypeSignature arrayArgument = next.getArrayDimensionType();
+			if (arrayArgument != null) {
+				buildAnnotations(result, nextAnnotations.toNextArrayDimension(), arrayArgument);
+			}
+
+			List<NdTypeArgument> typeArguments = next.getTypeArguments();
+			for (int rank = 0; rank < typeArguments.size(); rank++) {
+				NdTypeArgument argument = typeArguments.get(rank);
+
+				NdTypeSignature argumentType = argument.getType();
+				if (argumentType != null) {
+					buildAnnotations(result, nextAnnotations.toTypeArgument(rank), argumentType);
+				}
+			}
+
+			nextAnnotations = nextAnnotations.toNextNestedType();
+		}
+	}
+
+	private static void buildAnnotations(List<IBinaryTypeAnnotation> result, ITypeAnnotationBuilder builder,
+			List<NdAnnotation> annotations) {
+		for (NdAnnotation next : annotations) {
+			result.add(builder.build(createBinaryAnnotation(next)));
+		}
+	}
+
+	private void initEnclosing() {
+		if (!this.enclosingInitialized) {
+			this.enclosingInitialized = true;
+
+			try (IReader rl = this.typeRef.lock()) {
+				NdType type = this.typeRef.get();
+				if (type != null) {
+					NdMethodId methodId = type.getDeclaringMethod();
+
+					if (methodId != null) {
+						char[] methodName = methodId.getMethodName().getChars();
+						int startIdx = CharArrayUtils.lastIndexOf('#', methodName);
+						this.enclosingMethod = CharArrayUtils.substring(methodName, startIdx + 1);
+						this.enclosingType = CharArrayUtils.subarray(methodName, 0, startIdx);
+					}
+				}
+			}
+		}
+	}
+
+	private static Object unpackValue(NdConstant value) {
+		if (value instanceof NdConstantAnnotation) {
+			NdConstantAnnotation annotation = (NdConstantAnnotation) value;
+
+			return createBinaryAnnotation(annotation.getValue());
+		}
+		if (value instanceof NdConstantArray) {
+			NdConstantArray array = (NdConstantArray) value;
+
+			List<NdConstant> arrayContents = array.getValue();
+
+			Object[] result = new Object[arrayContents.size()];
+			for (int idx = 0; idx < arrayContents.size(); idx++) {
+				result[idx] = unpackValue(arrayContents.get(idx));
+			}
+			return result;
+		}
+		if (value instanceof NdConstantEnum) {
+			NdConstantEnum ndConstantEnum = (NdConstantEnum) value;
+
+			NdTypeSignature signature = ndConstantEnum.getType();
+
+			return new EnumConstantSignature(signature.getRawType().getBinaryName(), ndConstantEnum.getValue());
+		}
+		if (value instanceof NdConstantClass) {
+			NdConstantClass constant = (NdConstantClass) value;
+
+			return new ClassSignature(constant.getValue().getRawType().getBinaryName());
+		}
+
+		return value.getConstant();
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexType.java
deleted file mode 100644
index c8cbd6c..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexType.java
+++ /dev/null
@@ -1,335 +0,0 @@
-package org.eclipse.jdt.internal.core.nd.java.model;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.eclipse.jdt.internal.compiler.classfmt.ElementValuePairInfo;
-import org.eclipse.jdt.internal.compiler.env.ClassSignature;
-import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
-import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
-import org.eclipse.jdt.internal.compiler.env.IBinaryField;
-import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
-import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
-import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
-import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
-import org.eclipse.jdt.internal.core.nd.DatabaseRef;
-import org.eclipse.jdt.internal.core.nd.IReader;
-import org.eclipse.jdt.internal.core.nd.java.JavaNames;
-import org.eclipse.jdt.internal.core.nd.java.NdAnnotation;
-import org.eclipse.jdt.internal.core.nd.java.NdAnnotationValuePair;
-import org.eclipse.jdt.internal.core.nd.java.NdConstant;
-import org.eclipse.jdt.internal.core.nd.java.NdConstantAnnotation;
-import org.eclipse.jdt.internal.core.nd.java.NdConstantArray;
-import org.eclipse.jdt.internal.core.nd.java.NdConstantClass;
-import org.eclipse.jdt.internal.core.nd.java.NdConstantEnum;
-import org.eclipse.jdt.internal.core.nd.java.NdMethodId;
-import org.eclipse.jdt.internal.core.nd.java.NdType;
-import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
-import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
-
-/**
- *
- *
- */
-public class IndexType implements IBinaryType {
-
-	private final DatabaseRef<NdType> typeRef;
-
-	private boolean enclosingInitialized;
-	private char[] enclosingMethod;
-	private char[] enclosingType;
-
-	public IndexType(DatabaseRef<NdType> type) {
-		this.typeRef = type;
-	}
-
-	@Override
-	public int getModifiers() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getModifiers();
-			} else {
-				return 0;
-			}
-		}
-	}
-
-	@Override
-	public boolean isBinaryType() {
-		return true;
-	}
-
-	@Override
-	public char[] getFileName() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getFile().getFilename().getChars();
-			} else {
-				return new char[0];
-			}
-		}
-	}
-
-	@Override
-	public IBinaryAnnotation[] getAnnotations() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				NdAnnotation[] annotations = this.typeRef.get().getAnnotations();
-
-				IBinaryAnnotation[] result = new IBinaryAnnotation[annotations.length];
-
-				for (int idx = 0; idx < annotations.length; idx++) {
-					result[idx] = createBinaryAnnotation(annotations[idx]);
-				}
-
-				return result;
-			} else {
-				return null;
-			}
-		}
-	}
-
-	public static IBinaryAnnotation createBinaryAnnotation(NdAnnotation ndAnnotation) {
-		List<NdAnnotationValuePair> elementValuePairs = ndAnnotation.getElementValuePairs();
-
-		final IBinaryElementValuePair[] resultingPair = new IBinaryElementValuePair[elementValuePairs.size()];
-
-		for (int idx = 0; idx < elementValuePairs.size(); idx++) {
-			NdAnnotationValuePair next = elementValuePairs.get(idx);
-
-			resultingPair[idx] = new ElementValuePairInfo(next.getName().getChars(), unpackValue(next.getValue()));
-		}
-
-		final char[] binaryName = JavaNames.fieldDescriptorToBinaryName(ndAnnotation.getType().getRawType().getFieldDescriptor().getChars());
-
-		return new IBinaryAnnotation() {
-			@Override
-			public char[] getTypeName() {
-				return binaryName;
-			}
-
-			@Override
-			public IBinaryElementValuePair[] getElementValuePairs() {
-				return resultingPair;
-			}
-		};
-	}
-
-	private static Object unpackValue(NdConstant value) {
-		if (value instanceof NdConstantAnnotation) {
-			NdConstantAnnotation annotation = (NdConstantAnnotation)value;
-
-			return createBinaryAnnotation(annotation.getValue());
-		}
-		if (value instanceof NdConstantArray) {
-			NdConstantArray array = (NdConstantArray) value;
-
-			List<NdConstant> arrayContents = array.getValue();
-
-			Object[] result = new Object[arrayContents.size()];
-			for (int idx = 0; idx < arrayContents.size(); idx++) {
-				result[idx] = unpackValue(arrayContents.get(idx));
-			}
-			return result;
-		}
-		if (value instanceof NdConstantEnum) {
-			NdConstantEnum ndConstantEnum = (NdConstantEnum) value;
-
-			NdTypeSignature signature = ndConstantEnum.getType();
-
-			return new EnumConstantSignature(signature.getRawType().getBinaryName(), ndConstantEnum.getValue());
-		}
-		if (value instanceof NdConstantClass) {
-			NdConstantClass constant = (NdConstantClass) value;
-
-			return new ClassSignature(constant.getValue().getRawType().getBinaryName());
-		}
-
-		return value.getConstant();
-	}
-
-	@Override
-	public IBinaryTypeAnnotation[] getTypeAnnotations() {
-		List<IBinaryTypeAnnotation> result = new ArrayList<>();
-		ITypeAnnotationBuilder annotationBuilder = TypeAnnotationBuilder.create();
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				NdTypeSignature superclass = type.getSuperclass();
-				if (superclass != null) {
-					buildAnnotations(result, annotationBuilder.toSupertype((short)-1), superclass);
-				}
-			}
-		}
-		return result.toArray(new IBinaryTypeAnnotation[result.size()]);
-	}
-
-	private void buildAnnotations(List<IBinaryTypeAnnotation> result,
-			ITypeAnnotationBuilder builder, NdTypeSignature signature) {
-		ITypeAnnotationBuilder nextAnnotations = builder;
-		List<NdTypeSignature> declaringTypes = signature.getDeclaringTypeChain();
-
-		for (NdTypeSignature next : declaringTypes) {
-			List<NdAnnotation> annotations = next.getAnnotations();
-
-			result.addAll(buildAnnotations(nextAnnotations, annotations));
-
-			NdTypeSignature arrayArgument = next.getArrayDimensionType();
-			if (arrayArgument != null) {
-				buildAnnotations(result, nextAnnotations.toNextArrayDimension(), arrayArgument);
-			}
-
-			asantoh
-			nextAnnotations = nextAnnotations.toNextNestedType();
-		}
-	}
-
-	private List<IBinaryTypeAnnotation> buildAnnotations(ITypeAnnotationBuilder builder,
-			List<NdAnnotation> annotations) {
-
-		if (annotations.isEmpty()) {
-			return Collections.emptyList();
-		}
-
-		List<IBinaryTypeAnnotation> result = new ArrayList<>();
-		for (NdAnnotation next : annotations) {
-			result.add(builder.build(createBinaryAnnotation(next)));
-		}
-
-		return result;
-	}
-
-	private void initEnclosing() {
-		if (!this.enclosingInitialized) {
-			this.enclosingInitialized = true;
-
-			try (IReader rl = this.typeRef.lock()) {
-				NdType type = this.typeRef.get();
-				if (type != null) {
-					NdMethodId methodId = type.getDeclaringMethod();
-
-					if (methodId != null) {
-						char[] methodName = methodId.getMethodName().getChars();
-						int startIdx = CharArrayUtils.lastIndexOf('#', methodName);
-						this.enclosingMethod = CharArrayUtils.substring(methodName, startIdx + 1);
-						this.enclosingType = CharArrayUtils.subarray(methodName, 0, startIdx);
-					}
-				}
-			}
-		}
-	}
-
-	@Override
-	public char[] getEnclosingMethod() {
-		initEnclosing();
-
-		return this.enclosingMethod;
-	}
-
-	@Override
-	public char[] getEnclosingTypeName() {
-		initEnclosing();
-
-		return this.enclosingType;
-	}
-
-	@Override
-	public IBinaryField[] getFields() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[] getGenericSignature() {
-
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[][] getInterfaceNames() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public IBinaryNestedType[] getMemberTypes() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public IBinaryMethod[] getMethods() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[][][] getMissingTypeNames() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[] getName() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[] getSourceName() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public char[] getSuperclassName() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public long getTagBits() {
-		// TODO Auto-generated method stub
-		return 0;
-	}
-
-	@Override
-	public boolean isAnonymous() {
-		// TODO Auto-generated method stub
-		return false;
-	}
-
-	@Override
-	public boolean isLocal() {
-		// TODO Auto-generated method stub
-		return false;
-	}
-
-	@Override
-	public boolean isMember() {
-		// TODO Auto-generated method stub
-		return false;
-	}
-
-	@Override
-	public char[] sourceFileName() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member,
-			LookupEnvironment environment) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-}
commit 4449916f7ae9bf0077243ec6942f55d397111f10
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 9 08:55:48 2016 -0800

    Bug 481796 - Write some self-test code for the indexer
    
    It reads back every type that is written to the index to ensure it matches
    what was written.
    
    Change-Id: I7c35266a6fe555639230615f4b76eb54b9e55f4b
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

7	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
175	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index f7a306d..c2dcc29 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -47,6 +47,8 @@ import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
 import org.eclipse.jdt.internal.core.nd.java.NdVariable;
+import org.eclipse.jdt.internal.core.nd.java.ReferenceUtil;
+import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -57,6 +59,7 @@ public class ClassFileToIndexConverter {
 	private static final boolean ENABLE_LOGGING = false;
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private static final char[] PATH_SEPARATOR = new char[]{'/'};
+	private static final boolean ENABLE_SELF_TEST = true;
 	private NdResourceFile resource;
 	private JavaIndex index;
 
@@ -199,6 +202,10 @@ public class ClassFileToIndexConverter {
 			type.setInnerTypeSourceName(binaryType.getSourceName());
 		}
 
+		if (ENABLE_SELF_TEST) {
+			IndexTester.testType(binaryType, new IndexBinaryType(ReferenceUtil.createTypeRef(type)));
+		}
+
 		return type;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
new file mode 100644
index 0000000..daaa770
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -0,0 +1,175 @@
+package org.eclipse.jdt.internal.core.nd.indexer;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eclipse.jdt.internal.compiler.env.ClassSignature;
+import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+
+public class IndexTester {
+
+	private static final class TypeAnnotationWrapper {
+		private IBinaryTypeAnnotation annotation;
+
+		public TypeAnnotationWrapper(IBinaryTypeAnnotation next) {
+			this.annotation = next;
+		}
+
+		@Override
+		public int hashCode() {
+			int hashCode;
+			int[] typePath = this.annotation.getTypePath();
+
+			hashCode = Arrays.hashCode(typePath);
+			hashCode = hashCode * 31 + this.annotation.getTargetType();
+			hashCode = hashCode * 31 + this.annotation.getTypeParameterIndex();
+			return hashCode;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj.getClass() != TypeAnnotationWrapper.class) {
+				return false;
+			}
+
+			TypeAnnotationWrapper wrapper = (TypeAnnotationWrapper) obj;
+			IBinaryTypeAnnotation otherAnnotation = wrapper.annotation;
+
+			int[] typePath = this.annotation.getTypePath();
+			int[] otherTypePath = otherAnnotation.getTypePath();
+
+			if (!Arrays.equals(typePath, otherTypePath)) {
+				return false;
+			}
+
+			if (this.annotation.getTargetType() != otherAnnotation.getTargetType()) {
+				return false;
+			}
+
+			if (this.annotation.getBoundIndex() != otherAnnotation.getBoundIndex()) {
+				return false;
+			}
+
+			if (this.annotation.getMethodFormalParameterIndex() != otherAnnotation.getMethodFormalParameterIndex()) {
+				return false;
+			}
+
+			if (this.annotation.getSupertypeIndex() != otherAnnotation.getSupertypeIndex()) {
+				return false;
+			}
+
+			if (this.annotation.getThrowsTypeIndex() != otherAnnotation.getThrowsTypeIndex()) {
+				return false;
+			}
+
+			if (this.annotation.getTypeParameterIndex() != otherAnnotation.getTypeParameterIndex()) {
+				return false;
+			}
+
+			IBinaryAnnotation binaryAnnotation = this.annotation.getAnnotation();
+			IBinaryAnnotation otherBinaryAnnotation = otherAnnotation.getAnnotation();
+
+			IBinaryElementValuePair[] elementValuePairs = binaryAnnotation.getElementValuePairs();
+			IBinaryElementValuePair[] otherElementValuePairs = otherBinaryAnnotation.getElementValuePairs();
+
+			if (elementValuePairs.length != otherElementValuePairs.length) {
+				return false;
+			}
+
+			for (int idx = 0; idx < elementValuePairs.length; idx++) {
+				IBinaryElementValuePair next = elementValuePairs[idx];
+				IBinaryElementValuePair otherNext = otherElementValuePairs[idx];
+
+				char[] nextName = next.getName();
+				char[] otherNextName = otherNext.getName();
+
+				if (!Arrays.equals(nextName, otherNextName)) {
+					return false;
+				}
+
+				if (!constantsEqual(next.getValue(), otherNext.getValue())) {
+					return false;
+				}
+			}
+			return true;
+		}
+	}
+
+	public static void testType(IBinaryType expected, IBinaryType actual) {
+		Set<TypeAnnotationWrapper> expectedAnnotations = new HashSet<>();
+
+		IBinaryTypeAnnotation[] expectedTypeAnnotations = expected.getTypeAnnotations();
+
+		if (expectedTypeAnnotations != null) {
+			for (IBinaryTypeAnnotation next : expectedTypeAnnotations) {
+				expectedAnnotations.add(new TypeAnnotationWrapper(next));
+			}
+		}
+
+		Set<TypeAnnotationWrapper> actualAnnotations = new HashSet<>();
+
+		IBinaryTypeAnnotation[] actualTypeAnnotations = actual.getTypeAnnotations();
+		if (actualTypeAnnotations != null) {
+			for (IBinaryTypeAnnotation next : actualTypeAnnotations) {
+				actualAnnotations.add(new TypeAnnotationWrapper(next));
+			}
+		}
+
+		for (TypeAnnotationWrapper nextExpected : expectedAnnotations) {
+			if (!actualAnnotations.contains(nextExpected)) {
+				throw new IllegalStateException(
+						"The index was missing an expected type annotation: " + nextExpected.toString()); //$NON-NLS-1$
+			}
+		}
+
+		for (TypeAnnotationWrapper nextActual : actualAnnotations) {
+			if (!expectedAnnotations.contains(nextActual)) {
+				throw new IllegalStateException(
+						"The index contained an unexpected type annotation: " + nextActual.toString()); //$NON-NLS-1$
+			}
+		}
+	}
+
+	public static boolean constantsEqual(Object value, Object value2) {
+		if (value instanceof ClassSignature) {
+			if (!(value2 instanceof ClassSignature)) {
+				return false;
+			}
+
+			ClassSignature sig1 = (ClassSignature) value;
+			ClassSignature sig2 = (ClassSignature) value2;
+
+			return Arrays.equals(sig1.getTypeName(), sig2.getTypeName());
+		}
+		if (value instanceof Constant) {
+			if (!(value2 instanceof Constant)) {
+				return false;
+			}
+
+			Constant const1 = (Constant) value;
+			Constant const2 = (Constant) value2;
+
+			return const1.hasSameValue(const2);
+		}
+		if (value instanceof EnumConstantSignature) {
+			if (!(value2 instanceof EnumConstantSignature)) {
+				return false;
+			}
+
+			EnumConstantSignature enum1 = (EnumConstantSignature) value;
+			EnumConstantSignature enum2 = (EnumConstantSignature) value2;
+
+			return Arrays.equals(enum1.getEnumConstantName(), enum2.getEnumConstantName())
+					&& Arrays.equals(enum1.getTypeName(), enum2.getTypeName());
+		}
+
+		return false;
+	}
+
+}
commit 724d5f67ae2cd3042a8ea953035f85f105c1d678
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 9 09:44:48 2016 -0800

    Bug 481796 - Write some self-test code for the indexer
    
    Replace the custom locking code with a ReentrantReadWriteLock.
    
    Change-Id: I617636dab3d68181bc9a7bfcd6ec7a90f3c50dcd
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

49	283	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index 9a7efb8..fd6ef92 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -11,12 +11,10 @@
 package org.eclipse.jdt.internal.core.nd;
 
 import java.io.File;
-import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
@@ -40,6 +38,13 @@ public class Nd {
 	private final int maxVersion;
 	private final int minVersion;
 
+	// Read-write lock rules. Readers don't conflict with other readers,
+	// Writers conflict with readers, and everyone conflicts with writers.
+	private final Object lockMutex = new Object();
+	private long lastWriteAccess = 0;
+	private long lastReadAccess = 0;
+	private ReentrantReadWriteLock lock;
+
 	public static int version(int major, int minor) {
 		return (major << 16) + minor;
 	}
@@ -139,15 +144,16 @@ public class Nd {
 
 	public Nd(File dbPath, ChunkCache chunkCache, NdNodeTypeRegistry<NdNode> nodeTypes, int minVersion,
 			int maxVersion, int currentVersion) throws IndexException {
+		this.lock = new ReentrantReadWriteLock();
 		this.currentVersion = currentVersion;
 		this.maxVersion = maxVersion;
 		this.minVersion = minVersion;
 		this.fNodeTypeRegistry = nodeTypes;
 		loadDatabase(dbPath, chunkCache);
-		if (sDEBUG_LOCKS) {
-			this.fLockDebugging = new HashMap<>();
-			System.out.println("Debugging PDOM Locks"); //$NON-NLS-1$
-		}
+		// if (sDEBUG_LOCKS) {
+		// this.fLockDebugging = new HashMap<>();
+		// System.out.println("Debugging PDOM Locks"); //$NON-NLS-1$
+		// }
 	}
 
 	public long getWriteNumber() {
@@ -188,82 +194,52 @@ public class Nd {
 
 	private void loadDatabase(File dbPath, ChunkCache cache) throws IndexException {
 		this.fPath= dbPath;
-		final boolean lockDB= this.db == null || this.lockCount != 0;
+		final boolean lockDB = this.db == null;
 
 		clearCaches();
 		this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
 
-		this.db.setLocked(lockDB);
+		this.db.setLocked(true);
 		if (!isSupportedVersion()) {
 			Package.log("Index database is uses an unsupported version " + this.db.getVersion() //$NON-NLS-1$
 				+ " Deleting and recreating.", null); //$NON-NLS-1$
 			this.db.close();
 			this.fPath.delete();
 			this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
-			this.db.setLocked(lockDB);
+			this.db.setLocked(true);
 		}
 		this.fWriteNumber = this.db.getLong(Database.WRITE_NUMBER_OFFSET);
-		this.db.setLocked(this.lockCount != 0);
+		synchronized (this.lockMutex) {
+			syncLockedState();
+		}
+	}
+
+	void syncLockedState() {
+		int writeLocks = this.lock.getWriteHoldCount();
+		int readLocks = this.lock.getReadLockCount();
+
+		this.db.setLocked(writeLocks != 0 || readLocks != 0);
 	}
 
 	public Database getDB() {
 		return this.db;
 	}
 
-	// Read-write lock rules. Readers don't conflict with other readers,
-	// Writers conflict with readers, and everyone conflicts with writers.
-	private final Object mutex = new Object();
-	private int lockCount;
-	private int waitingReaders;
-	private long lastWriteAccess= 0;
-	private long lastReadAccess= 0;
-	private long timeWriteLockAcquired;
-
 	public IReader acquireReadLock() {
-		try {
-			long t = sDEBUG_LOCKS ? System.nanoTime() : 0;
-			synchronized (this.mutex) {
-				++this.waitingReaders;
-				try {
-					while (this.lockCount < 0)
-						this.mutex.wait();
-				} finally {
-					--this.waitingReaders;
-				}
-				++this.lockCount;
-				this.db.setLocked(true);
-
-				if (sDEBUG_LOCKS) {
-					t = (System.nanoTime() - t) / 1000000;
-					if (t >= LONG_READ_LOCK_WAIT_REPORT_THRESHOLD) {
-						System.out.println("Acquired index read lock after " + t + " ms wait."); //$NON-NLS-1$//$NON-NLS-2$
-					}
-					incReadLock(this.fLockDebugging);
-				}
-				return this.fReader;
-			}
-		} catch (InterruptedException e) {
-			throw new OperationCanceledException();
+		this.lock.readLock().lock();
+		synchronized (this.lockMutex) {
+			syncLockedState();
 		}
+		return this.fReader;
 	}
 
 	public void releaseReadLock() {
-		synchronized (this.mutex) {
-			assert this.lockCount > 0: "No lock to release"; //$NON-NLS-1$
-			if (sDEBUG_LOCKS) {
-				decReadLock(this.fLockDebugging);
-			}
-
-			this.lastReadAccess= System.currentTimeMillis();
-			if (this.lockCount > 0)
-				--this.lockCount;
-			this.mutex.notifyAll();
-			this.db.setLocked(this.lockCount != 0);
+		synchronized (this.lockMutex) {
+			this.lock.readLock().unlock();
+			syncLockedState();
+			this.lastReadAccess = System.currentTimeMillis();
 		}
-		// A lock release probably means that some AST is going away. The result cache has to be
-		// cleared since it may contain objects belonging to the AST that is going away. A failure
-		// to release an AST object would cause a memory leak since the whole AST would remain
-		// pinned to memory.
+
 		// TODO(sprigogin): It would be more efficient to replace the global result cache with
 		// separate caches for each AST.
 		clearResultCache();
@@ -275,97 +251,29 @@ public class Nd {
 	 * @throws IllegalStateException if this PDOM is not writable
 	 */
 	public void acquireWriteLock(IProgressMonitor monitor) {
-		try {
-			acquireWriteLock(0, monitor);
-		} catch (InterruptedException e) {
-			throw new OperationCanceledException();
-		}
-	}
-
-	/**
-	 * Acquire a write lock on this PDOM, giving up the specified number of read locks first. Blocks
-	 * until any existing read/write locks are released.
-	 * @throws InterruptedException
-	 * @throws IllegalStateException if this PDOM is not writable
-	 */
-	public void acquireWriteLock(int giveupReadLocks, IProgressMonitor monitor) throws InterruptedException {
 		assert !isPermanentlyReadOnly();
-		synchronized (this.mutex) {
-			if (sDEBUG_LOCKS) {
-				incWriteLock(giveupReadLocks);
-			}
-
-			if (giveupReadLocks > 0) {
-				// give up on read locks
-				assert this.lockCount >= giveupReadLocks: "Not enough locks to release"; //$NON-NLS-1$
-				if (this.lockCount < giveupReadLocks) {
-					giveupReadLocks= this.lockCount;
-				}
-			} else {
-				giveupReadLocks= 0;
-			}
-
-			// Let the readers go first
-			long start= sDEBUG_LOCKS ? System.currentTimeMillis() : 0;
-			while (this.lockCount > giveupReadLocks || this.waitingReaders > 0) {
-				this.mutex.wait(CANCELLATION_CHECK_INTERVAL);
-				if (monitor != null && monitor.isCanceled()) {
-					throw new OperationCanceledException();
-				}
-				if (sDEBUG_LOCKS) {
-					start = reportBlockedWriteLock(start, giveupReadLocks);
-				}
-			}
-			this.lockCount= -1;
-			if (sDEBUG_LOCKS)
-				this.timeWriteLockAcquired = System.currentTimeMillis();
-			this.db.setExclusiveLock();
-		}
+		this.lock.writeLock().lock();
+		this.db.setExclusiveLock();
 	}
 
 	final public void releaseWriteLock() {
-		releaseWriteLock(0, true);
-	}
-
-	@SuppressWarnings("nls")
-	public void releaseWriteLock(int establishReadLocks, boolean flush) {
-		// When all locks are released we can clear the result cache.
-		if (establishReadLocks == 0) {
-			processDeletions();
-			this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
-			clearResultCache();
-		}
-		try {
-			this.db.giveUpExclusiveLock(flush);
-		} catch (IndexException e) {
-			Package.log(e);
-		}
-		assert this.lockCount == -1;
-		if (!this.fEvent.isTrivial())
-			this.lastWriteAccess= System.currentTimeMillis();
-		//final ChangeEvent event= this.fEvent;
-		this.fEvent= new ChangeEvent();
-		synchronized (this.mutex) {
-			if (sDEBUG_LOCKS) {
-				long timeHeld = this.lastWriteAccess - this.timeWriteLockAcquired;
-				if (timeHeld >= LONG_WRITE_LOCK_REPORT_THRESHOLD) {
-					System.out.println("Index write lock held for " + timeHeld + " ms");
-				}
-				decWriteLock(establishReadLocks);
+		synchronized (this.lockMutex) {
+			int writeHoldCount = this.lock.getWriteHoldCount();
+			assert writeHoldCount >= 1;
+			if (writeHoldCount == 1) {
+				processDeletions();
+				this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
+				clearResultCache();
+				this.db.giveUpExclusiveLock(true);
+				this.lastWriteAccess = System.currentTimeMillis();
 			}
-
-			if (this.lockCount < 0)
-				this.lockCount= establishReadLocks;
-			this.mutex.notifyAll();
-			this.db.setLocked(this.lockCount != 0);
+			this.lock.writeLock().unlock();
+			syncLockedState();
 		}
-		//fireChange(event);
 	}
 
 	public boolean hasWaitingReaders() {
-		synchronized (this.mutex) {
-			return this.waitingReaders > 0;
-		}
+		return this.lock.hasQueuedThreads();
 	}
 
 	public long getLastWriteAccess() {
@@ -428,148 +336,6 @@ public class Nd {
 		}
 	}
 
-	// For debugging lock issues
-	static class DebugLockInfo {
-		int fReadLocks;
-		int fWriteLocks;
-		List<StackTraceElement[]> fTraces= new ArrayList<>();
-
-		public int addTrace() {
-			this.fTraces.add(Thread.currentThread().getStackTrace());
-			return this.fTraces.size();
-		}
-
-		@SuppressWarnings("nls")
-		public void write(String threadName) {
-			System.out.println("Thread: '" + threadName + "': " + this.fReadLocks + " readlocks, " + this.fWriteLocks + " writelocks");
-			for (StackTraceElement[] trace : this.fTraces) {
-				System.out.println("  Stacktrace:");
-				for (StackTraceElement ste : trace) {
-					System.out.println("    " + ste);
-				}
-			}
-		}
-
-		public void inc(DebugLockInfo val) {
-			this.fReadLocks+= val.fReadLocks;
-			this.fWriteLocks+= val.fWriteLocks;
-			this.fTraces.addAll(val.fTraces);
-		}
-	}
-
-	// For debugging lock issues
-	private Map<Thread, DebugLockInfo> fLockDebugging;
-
-	// For debugging lock issues
-	private static DebugLockInfo getLockInfo(Map<Thread, DebugLockInfo> lockDebugging) {
-		assert sDEBUG_LOCKS;
-
-		Thread key = Thread.currentThread();
-		DebugLockInfo result= lockDebugging.get(key);
-		if (result == null) {
-			result= new DebugLockInfo();
-			lockDebugging.put(key, result);
-		}
-		return result;
-	}
-
-	// For debugging lock issues
-	static void incReadLock(Map<Thread, DebugLockInfo> lockDebugging) {
-		DebugLockInfo info = getLockInfo(lockDebugging);
-		info.fReadLocks++;
-		if (info.addTrace() > 10) {
-			outputReadLocks(lockDebugging);
-		}
-	}
-
-	// For debugging lock issues
-	@SuppressWarnings("nls")
-	static void decReadLock(Map<Thread, DebugLockInfo> lockDebugging) throws AssertionError {
-		DebugLockInfo info = getLockInfo(lockDebugging);
-		if (info.fReadLocks <= 0) {
-			outputReadLocks(lockDebugging);
-			throw new AssertionError("Superfluous releaseReadLock");
-		}
-		if (info.fWriteLocks != 0) {
-			outputReadLocks(lockDebugging);
-			throw new AssertionError("Releasing readlock while holding write lock");
-		}
-		if (--info.fReadLocks == 0) {
-			lockDebugging.remove(Thread.currentThread());
-		} else {
-			info.addTrace();
-		}
-	}
-
-	// For debugging lock issues
-	@SuppressWarnings("nls")
-	private void incWriteLock(int giveupReadLocks) throws AssertionError {
-		DebugLockInfo info = getLockInfo(this.fLockDebugging);
-		if (info.fReadLocks != giveupReadLocks) {
-			outputReadLocks(this.fLockDebugging);
-			throw new AssertionError("write lock with " + giveupReadLocks + " readlocks, expected " + info.fReadLocks);
-		}
-		if (info.fWriteLocks != 0)
-			throw new AssertionError("Duplicate write lock");
-		info.fWriteLocks++;
-	}
-
-	// For debugging lock issues
-	private void decWriteLock(int establishReadLocks) throws AssertionError {
-		DebugLockInfo info = getLockInfo(this.fLockDebugging);
-		if (info.fReadLocks != establishReadLocks)
-			throw new AssertionError("release write lock with " + establishReadLocks + " readlocks, expected " + info.fReadLocks); //$NON-NLS-1$ //$NON-NLS-2$
-		if (info.fWriteLocks != 1)
-			throw new AssertionError("Wrong release write lock"); //$NON-NLS-1$
-		info.fWriteLocks= 0;
-		if (info.fReadLocks == 0) {
-			this.fLockDebugging.remove(Thread.currentThread());
-		}
-	}
-
-	// For debugging lock issues
-	@SuppressWarnings("nls")
-	private long reportBlockedWriteLock(long start, int giveupReadLocks) {
-		long now= System.currentTimeMillis();
-		if (now >= start + BLOCKED_WRITE_LOCK_OUTPUT_INTERVAL) {
-			System.out.println();
-			System.out.println("Blocked writeLock");
-			System.out.println("  lockcount= " + this.lockCount + ", giveupReadLocks=" + giveupReadLocks + ", waitingReaders=" + this.waitingReaders);
-			outputReadLocks(this.fLockDebugging);
-			start= now;
-		}
-		return start;
-	}
-
-	// For debugging lock issues
-	@SuppressWarnings("nls")
-	private static void outputReadLocks(Map<Thread, DebugLockInfo> lockDebugging) {
-		System.out.println("---------------------  Lock Debugging -------------------------");
-		for (Thread th: lockDebugging.keySet()) {
-			DebugLockInfo info = lockDebugging.get(th);
-			info.write(th.getName());
-		}
-		System.out.println("---------------------------------------------------------------");
-	}
-
-	// For debugging lock issues
-	public void adjustThreadForReadLock(Map<Thread, DebugLockInfo> lockDebugging) {
-		for (Thread th : lockDebugging.keySet()) {
-			DebugLockInfo val= lockDebugging.get(th);
-			if (val.fReadLocks > 0) {
-				DebugLockInfo myval= this.fLockDebugging.get(th);
-				if (myval == null) {
-					myval= new DebugLockInfo();
-					this.fLockDebugging.put(th, myval);
-				}
-				myval.inc(val);
-				for (int i = 0; i < val.fReadLocks; i++) {
-					decReadLock(this.fLockDebugging);
-				}
-			}
-		}
-	}
-
     public NdNode getNode(long address, short nodeType) throws IndexException {
     	return this.fNodeTypeRegistry.createNode(this, address, nodeType);
     }
commit 6af8a31540bc8bb8fa27b23adfb79c4af6b50ae0
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 9 10:05:35 2016 -0800

    Bug 481796 - Fix exceptions in the indexer
    
    Change-Id: I4147b1f7e0d4c512a62fa48aa3817ec4dffd6d69
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

3	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
3	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index 663e1d8..b68adf4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -90,6 +90,7 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 		return DECLARING_TYPE.get(getNd(), this.address);
 	}
 
+	@Override
 	public List<NdTypeArgument> getTypeArguments() {
 		return TYPE_ARGUMENTS.asList(getNd(), this.address);
 	}
@@ -170,9 +171,9 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 		NdComplexTypeSignature declaringType = getGenericDeclaringType();
 
 		if (declaringType != null) {
-			computeDeclaringTypes(result);
+			declaringType.computeDeclaringTypes(result);
 		}
 
-		result.add(declaringType);
+		result.add(this);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index 015240c..2d12cb7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -113,7 +113,9 @@ public abstract class NdTypeSignature extends NdNode {
 	public abstract void getSignature(CharArrayBuffer result);
 
 	public final boolean isArrayType() {
-		return getRawType().hasSimpleName("["); //$NON-NLS-1$
+		NdTypeId rawType = getRawType();
+
+		return rawType != null && rawType.hasSimpleName("["); //$NON-NLS-1$
 	}
 
 	public abstract boolean isTypeVariable();
commit 108e5ce44b2a2d9f83fc883ba03ef528568facd9
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 9 22:15:42 2016 -0800

    Bug 481796 - Add additional self-tests to indexer + bugfixes
    
    (Note: The tests still fail -- this code should be considered unstable.)
    
    Change-Id: I02ec30ea7603856804c056bf8e294d5f6382b426
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

9	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
29	22	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
4	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
229	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
13	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
17	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
9	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
10	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
16	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
19	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
38	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
6	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index e81bfcc..0427355 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -60,6 +60,14 @@ public HierarchyBinaryType(int modifiers, char[] binaryName, char[] sourceName,
 	this.name = binaryName;
 	this.enclosingTypeName = enclosingTypeBinaryName;
 	this.typeParameterSignatures = typeParameterSignatures;
+
+	if (typeParameterSignatures != null) {
+		for (char[] next : typeParameterSignatures) {
+			if (next == null) {
+				throw new IllegalArgumentException("Parameter's type signature must not be null"); //$NON-NLS-1$
+			}
+		}
+	}
 }
 
 /**
@@ -253,6 +261,7 @@ public void recordInterface(char[] binaryName) {
 public char[] sourceFileName() {
 	return null;
 }
+@Override
 public String toString() {
 	StringBuffer buffer = new StringBuffer();
 	if (this.modifiers == ClassFileConstants.AccPublic) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
index 6d2084a..bb88ae9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
@@ -27,6 +27,9 @@ import org.eclipse.jdt.internal.compiler.env.IGenericType;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.core.*;
+import org.eclipse.jdt.internal.core.nd.indexer.Indexer;
+import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
 import org.eclipse.jdt.internal.core.util.ResourceCompilationUnit;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -266,6 +269,7 @@ public abstract class HierarchyBuilder {
 protected ICompilationUnit createCompilationUnitFromPath(Openable handle, IFile file) {
 	final char[] elementName = handle.getElementName().toCharArray();
 	return new ResourceCompilationUnit(file) {
+		@Override
 		public char[] getFileName() {
 			return elementName;
 		}
@@ -305,29 +309,32 @@ protected IBinaryType createInfoFromClassFileInJar(Openable classFile) {
 	PackageFragment pkg = (PackageFragment) classFile.getParent();
 	String classFilePath = Util.concatWith(pkg.names, classFile.getElementName(), '/');
 	IBinaryType info = null;
-	java.util.zip.ZipFile zipFile = null;
-	try {
-		zipFile = ((JarPackageFragmentRoot)pkg.getParent()).getJar();
-		info = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(
-			zipFile,
-			classFilePath);
-	} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {
-		if (TypeHierarchy.DEBUG) {
-			e.printStackTrace();
-		}
-		return null;
-	} catch (java.io.IOException e) {
-		if (TypeHierarchy.DEBUG) {
-			e.printStackTrace();
-		}
-		return null;
-	} catch (CoreException e) {
-		if (TypeHierarchy.DEBUG) {
-			e.printStackTrace();
+
+	if (JavaIndex.isEnabled()) {
+		info = BinaryTypeFactory.create(Indexer.getLocationForElement(classFile.getParent()), classFilePath);
+	} else {
+		java.util.zip.ZipFile zipFile = null;
+		try {
+			zipFile = ((JarPackageFragmentRoot) pkg.getParent()).getJar();
+			info = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(zipFile, classFilePath);
+		} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {
+			if (TypeHierarchy.DEBUG) {
+				e.printStackTrace();
+			}
+			return null;
+		} catch (java.io.IOException e) {
+			if (TypeHierarchy.DEBUG) {
+				e.printStackTrace();
+			}
+			return null;
+		} catch (CoreException e) {
+			if (TypeHierarchy.DEBUG) {
+				e.printStackTrace();
+			}
+			return null;
+		} finally {
+			JavaModelManager.getJavaModelManager().closeZipFile(zipFile);
 		}
-		return null;
-	} finally {
-		JavaModelManager.getJavaModelManager().closeZipFile(zipFile);
 	}
 	this.infoToHandle.put(info, classFile);
 	return info;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index c2dcc29..417af1b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -54,6 +54,8 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class ClassFileToIndexConverter {
+	private static final char[] INNER_TYPE_SEPARATOR = new char[] { '$' };
+	private static final char[] FIELD_DESCRIPTOR_SUFFIX = new char[] { ';' };
 	private static final char[] COMMA = new char[]{','};
 	private static final char[][] EMPTY_CHAR_ARRAY_ARRAY = new char[0][];
 	private static final boolean ENABLE_LOGGING = false;
@@ -460,9 +462,9 @@ public class ClassFileToIndexConverter {
 
 		if (parentTypeOrNull != null) {
 			fieldDescriptor = CharArrayUtils.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
-					new char[] { '$' }, identifier);
+					INNER_TYPE_SEPARATOR, identifier, FIELD_DESCRIPTOR_SUFFIX);
 		} else {
-			fieldDescriptor = identifier;
+			fieldDescriptor = CharArrayUtils.concat(identifier, FIELD_DESCRIPTOR_SUFFIX);
 		}
 
 		char[] genericSignature = wrapper.signature;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index f1118d0..88ba2dc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -2,15 +2,19 @@ package org.eclipse.jdt.internal.core.nd.indexer;
 
 import java.util.Arrays;
 import java.util.HashSet;
+import java.util.Objects;
 import java.util.Set;
 
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryField;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 
 public class IndexTester {
 
@@ -80,10 +84,185 @@ public class IndexTester {
 	}
 
 	public static void testType(IBinaryType expected, IBinaryType actual) {
-		Set<TypeAnnotationWrapper> expectedAnnotations = new HashSet<>();
 
 		IBinaryTypeAnnotation[] expectedTypeAnnotations = expected.getTypeAnnotations();
+		IBinaryTypeAnnotation[] actualTypeAnnotations = actual.getTypeAnnotations();
+
+		compareTypeAnnotations(expectedTypeAnnotations, actualTypeAnnotations);
+
+		IBinaryAnnotation[] expectedBinaryAnnotations = expected.getAnnotations();
+		IBinaryAnnotation[] actualBinaryAnnotations = actual.getAnnotations();
+
+		compareAnnotations(expectedBinaryAnnotations, actualBinaryAnnotations);
+
+		if (expected.getGenericSignature() != null) {
+			assertEquals("The generic signature did not match", expected.getGenericSignature(), //$NON-NLS-1$
+					actual.getGenericSignature());
+		}
 
+		assertEquals("The enclosing method name did not match", expected.getEnclosingMethod(), //$NON-NLS-1$
+				actual.getEnclosingMethod());
+		assertEquals("The enclosing method name did not match", expected.getEnclosingTypeName(), //$NON-NLS-1$
+				actual.getEnclosingTypeName());
+
+		IBinaryField[] expectedFields = expected.getFields();
+		IBinaryField[] actualFields = actual.getFields();
+
+		if (expectedFields != actualFields) {
+			if (expectedFields == null && actualFields != null) {
+				throw new IllegalStateException("Expected fields was null -- actual fields were not"); //$NON-NLS-1$
+			}
+			if (expectedFields.length != actualFields.length) {
+				throw new IllegalStateException("The expected and actual number of fields did not match"); //$NON-NLS-1$
+			}
+
+			for (int fieldIdx = 0; fieldIdx < actualFields.length; fieldIdx++) {
+				compareFields(expectedFields[fieldIdx], actualFields[fieldIdx]);
+			}
+		}
+
+		assertEquals("The file name did not match", expected.getFileName(), actual.getFileName()); //$NON-NLS-1$
+		assertEquals("The interface names did not match", expected.getInterfaceNames(), actual.getInterfaceNames()); //$NON-NLS-1$
+
+		// Member types are not expected to match during indexing since the index uses discovered cross-references,
+		// not the member types encoded in the .class file.
+		// expected.getMemberTypes() != actual.getMemberTypes()
+
+		IBinaryMethod[] expectedMethods = expected.getMethods();
+		IBinaryMethod[] actualMethods = actual.getMethods();
+
+		if (expectedMethods != actualMethods) {
+			if (expectedMethods == null || actualMethods == null) {
+				throw new IllegalStateException("One of the method arrays was null"); //$NON-NLS-1$
+			}
+
+			if (expectedMethods.length != actualMethods.length) {
+				throw new IllegalStateException("The number of methods didn't match"); //$NON-NLS-1$
+			}
+
+			for (int i = 0; i < actualMethods.length; i++) {
+				IBinaryMethod actualMethod = actualMethods[i];
+				IBinaryMethod expectedMethod = expectedMethods[i];
+
+				compareMethods(expectedMethod, actualMethod);
+			}
+		}
+
+		assertEquals("The missing type names did not match", expected.getMissingTypeNames(), //$NON-NLS-1$
+				actual.getMissingTypeNames());
+		assertEquals("The modifiers don't match", expected.getModifiers(), actual.getModifiers()); //$NON-NLS-1$
+		assertEquals("The names don't match.", expected.getName(), actual.getName()); //$NON-NLS-1$
+		assertEquals("The source name doesn't match", expected.getSourceName(), actual.getSourceName()); //$NON-NLS-1$
+		assertEquals("The superclass name doesn't match", expected.getSuperclassName(), actual.getSuperclassName()); //$NON-NLS-1$
+		assertEquals("The tag bits don't match.", expected.getTagBits(), actual.getTagBits()); //$NON-NLS-1$
+
+		compareTypeAnnotations(expected.getTypeAnnotations(), actual.getTypeAnnotations());
+	}
+
+	private static <T> void assertEquals(String message, T o1, T o2) {
+		if (!isEqual(o1, o2)) {
+			throw new IllegalStateException(message);
+		}
+	}
+
+	private static <T> boolean isEqual(T o1, T o2) {
+		if (o1 == o2) {
+			return true;
+		}
+
+		if (o1 == null || o2 == null) {
+			return false;
+		}
+
+		if (o1 instanceof char[]) {
+			char[] c1 = (char[]) o1;
+			char[] c2 = (char[]) o2;
+
+			return CharArrayUtils.equals(c1, c2);
+		}
+
+		if (o1 instanceof char[][]) {
+			char[][] c1 = (char[][]) o1;
+			char[][] c2 = (char[][]) o2;
+
+			return CharArrayUtils.equals(c1, c2);
+		}
+
+		if (o1 instanceof char[][][]) {
+			char[][][] c1 = (char[][][]) o1;
+			char[][][] c2 = (char[][][]) o2;
+
+			if (c1.length != c2.length) {
+				return false;
+			}
+
+			for (int i = 0; i < c1.length; i++) {
+				if (!isEqual(c1[i], c2[i])) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+		if (o1 instanceof IBinaryMethod[]) {
+			IBinaryMethod[] a1 = (IBinaryMethod[]) o1;
+			IBinaryMethod[] a2 = (IBinaryMethod[]) o2;
+
+			if (a1.length != a2.length) {
+				return false;
+			}
+
+			for (int i = 0; i < a1.length; i++) {
+				IBinaryMethod m1 = a1[i];
+				IBinaryMethod m2 = a2[i];
+
+				compareMethods(m1, m2);
+			}
+		}
+
+		return Objects.equals(o1, o2);
+	}
+
+	private static void compareMethods(IBinaryMethod expectedMethod, IBinaryMethod actualMethod) {
+		assertEquals("The annotated parameter count didn't match", actualMethod.getAnnotatedParametersCount(), //$NON-NLS-1$
+				expectedMethod.getAnnotatedParametersCount());
+
+		compareAnnotations(expectedMethod.getAnnotations(), actualMethod.getAnnotations());
+
+		assertEquals("The argument names didn't match.", expectedMethod.getArgumentNames(), //$NON-NLS-1$
+				actualMethod.getArgumentNames());
+
+		if (!constantsEqual(expectedMethod.getDefaultValue(), actualMethod.getDefaultValue())) {
+			throw new IllegalStateException("The default values didn't match."); //$NON-NLS-1$
+		}
+
+		assertEquals("The exception type names did not match.", expectedMethod.getExceptionTypeNames(), //$NON-NLS-1$
+				actualMethod.getExceptionTypeNames());
+
+		if (expectedMethod.getGenericSignature() != null) {
+			assertEquals("The method's generic signature did not match", expectedMethod.getGenericSignature(), //$NON-NLS-1$
+					actualMethod.getGenericSignature());
+		}
+
+		assertEquals("The method descriptors did not match.", expectedMethod.getMethodDescriptor(), //$NON-NLS-1$
+				actualMethod.getMethodDescriptor());
+		assertEquals("The modifiers didn't match.", expectedMethod.getModifiers(), actualMethod.getModifiers()); //$NON-NLS-1$
+
+		for (int idx = 0; idx < actualMethod.getAnnotatedParametersCount(); idx++) {
+			char[] classFileName = "".toCharArray(); //$NON-NLS-1$
+			compareAnnotations(expectedMethod.getParameterAnnotations(idx, classFileName),
+					actualMethod.getParameterAnnotations(idx, classFileName));
+		}
+
+		assertEquals("The selectors did not match", expectedMethod.getSelector(), actualMethod.getSelector()); //$NON-NLS-1$
+		assertEquals("The tag bits did not match", expectedMethod.getTagBits(), actualMethod.getTagBits()); //$NON-NLS-1$
+
+		compareTypeAnnotations(expectedMethod.getTypeAnnotations(), actualMethod.getTypeAnnotations());
+	}
+
+	private static void compareTypeAnnotations(IBinaryTypeAnnotation[] expectedTypeAnnotations,
+			IBinaryTypeAnnotation[] actualTypeAnnotations) {
+		Set<TypeAnnotationWrapper> expectedAnnotations = new HashSet<>();
 		if (expectedTypeAnnotations != null) {
 			for (IBinaryTypeAnnotation next : expectedTypeAnnotations) {
 				expectedAnnotations.add(new TypeAnnotationWrapper(next));
@@ -92,7 +271,6 @@ public class IndexTester {
 
 		Set<TypeAnnotationWrapper> actualAnnotations = new HashSet<>();
 
-		IBinaryTypeAnnotation[] actualTypeAnnotations = actual.getTypeAnnotations();
 		if (actualTypeAnnotations != null) {
 			for (IBinaryTypeAnnotation next : actualTypeAnnotations) {
 				actualAnnotations.add(new TypeAnnotationWrapper(next));
@@ -114,7 +292,51 @@ public class IndexTester {
 		}
 	}
 
+	private static void compareAnnotations(IBinaryAnnotation[] expectedBinaryAnnotations,
+			IBinaryAnnotation[] actualBinaryAnnotations) {
+		if (expectedBinaryAnnotations == null) {
+			if (actualBinaryAnnotations != null) {
+				throw new IllegalStateException("Expected null for the binary annotations"); //$NON-NLS-1$
+			} else {
+				return;
+			}
+		}
+		if (actualBinaryAnnotations == null) {
+			throw new IllegalStateException("Actual null for the binary annotations"); //$NON-NLS-1$
+		}
+		if (expectedBinaryAnnotations.length != actualBinaryAnnotations.length) {
+			throw new IllegalStateException("The expected and actual number of annotations differed"); //$NON-NLS-1$
+		}
+
+		for (int idx = 0; idx < expectedBinaryAnnotations.length; idx++) {
+			if (!annotationsEqual(expectedBinaryAnnotations[idx], actualBinaryAnnotations[idx])) {
+				throw new IllegalStateException("An annotation had an unexpected value"); //$NON-NLS-1$
+			}
+		}
+	}
+
+	private static void compareFields(IBinaryField field1, IBinaryField field2) {
+		compareAnnotations(field1.getAnnotations(), field2.getAnnotations());
+		if (!constantsEqual(field1.getConstant(), field2.getConstant())) {
+			throw new IllegalStateException("Constants not equal"); //$NON-NLS-1$
+		}
+		assertEquals("The generic signature did not match", field1.getGenericSignature(), field2.getGenericSignature()); //$NON-NLS-1$
+		assertEquals("The modifiers did not match", field1.getModifiers(), field2.getModifiers()); //$NON-NLS-1$
+		assertEquals("The tag bits did not match", field1.getTagBits(), field2.getTagBits()); //$NON-NLS-1$
+		assertEquals("The names did not match", field1.getName(), field2.getName()); //$NON-NLS-1$
+
+		compareTypeAnnotations(field1.getTypeAnnotations(), field2.getTypeAnnotations());
+		assertEquals("The type names did not match", field1.getTypeName(), field2.getTypeName()); //$NON-NLS-1$
+	}
+
 	public static boolean constantsEqual(Object value, Object value2) {
+		if (value == value2) {
+			return true;
+		}
+		if (value == null) {
+			return value2 == null;
+		}
+
 		if (value instanceof ClassSignature) {
 			if (!(value2 instanceof ClassSignature)) {
 				return false;
@@ -154,22 +376,22 @@ public class IndexTester {
 			IBinaryAnnotation otherBinaryAnnotation) {
 		IBinaryElementValuePair[] elementValuePairs = binaryAnnotation.getElementValuePairs();
 		IBinaryElementValuePair[] otherElementValuePairs = otherBinaryAnnotation.getElementValuePairs();
-	
+
 		if (elementValuePairs.length != otherElementValuePairs.length) {
 			return false;
 		}
-	
+
 		for (int idx = 0; idx < elementValuePairs.length; idx++) {
 			IBinaryElementValuePair next = elementValuePairs[idx];
 			IBinaryElementValuePair otherNext = otherElementValuePairs[idx];
-	
+
 			char[] nextName = next.getName();
 			char[] otherNextName = otherNext.getName();
-	
+
 			if (!Arrays.equals(nextName, otherNextName)) {
 				return false;
 			}
-	
+
 			if (!constantsEqual(next.getValue(), otherNext.getValue())) {
 				return false;
 			}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 135b448..250c7cf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -110,6 +110,14 @@ public final class Indexer {
 
 		updateResourceMappings(pathsToUpdate, subMonitor.split(5));
 
+		// Flush the database to disk
+		this.pdom.acquireWriteLock(subMonitor.newChild(5));
+		try {
+			this.pdom.getDB().flush();
+		} finally {
+			this.pdom.releaseWriteLock();
+		}
+
 		long endResourceMappingNs = System.nanoTime();
 
 		long fingerprintTimeMs = (startIndexingNs - startFingerprintTestNs) / MS_TO_NS;
@@ -168,7 +176,7 @@ public final class Indexer {
 
 		HashSet<IPath> workspacePaths = new HashSet<IPath>();
 		for (IJavaElement next : allRoots) {
-			IPath nextPath = getFilesystemPathForRoot(next);
+			IPath nextPath = getLocationForElement(next);
 			IPath workspacePath = getWorkspacePathForRoot(next);
 
 			List<IJavaElement> value = paths.get(nextPath);
@@ -241,10 +249,10 @@ public final class Indexer {
 		this.pdom.acquireWriteLock(subMonitor.newChild(5));
 		try {
 			resourceFile = new NdResourceFile(this.pdom);
-			resourceFile.setFilename(pathString);
+			resourceFile.setLocation(pathString);
 			IPackageFragmentRoot packageFragmentRoot = (IPackageFragmentRoot) element
 					.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
-			IPath rootPathString = getFilesystemPathForRoot(packageFragmentRoot);
+			IPath rootPathString = getLocationForElement(packageFragmentRoot);
 			if (!rootPathString.equals(thePath)) {
 				resourceFile.setPackageFragmentRoot(rootPathString.toString().toCharArray());
 			}
@@ -416,7 +424,7 @@ public final class Indexer {
 						if (!nextRoot.exists()) {
 							continue;
 						}
-						IPath filesystemPath = getFilesystemPathForRoot(nextRoot);
+						IPath filesystemPath = getLocationForElement(nextRoot);
 						if (scannedPaths.contains(filesystemPath)) {
 							continue;
 						}
@@ -543,7 +551,7 @@ public final class Indexer {
 		return fingerprint.test(thePath.toFile(), subMonitor.split(50));
 	}
 
-	private IPath getFilesystemPathForRoot(IJavaElement next) {
+	public static IPath getLocationForElement(IJavaElement next) {
 		IResource resource = next.getResource();
 
 		if (resource != null) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 37275c0..892d996 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -24,6 +24,7 @@ import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.IResultRank;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.SearchCriteria;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
@@ -31,9 +32,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 22);
-	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 22);
-	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 22);
+	static final int CURRENT_VERSION = Nd.version(1, 24);
+	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 25);
+	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 25);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
@@ -111,7 +112,19 @@ public class JavaIndex {
 			return existingType;
 		}
 
-		return new NdTypeId(this.pdom, fieldDescriptor);
+		if (fieldDescriptor.length > 1) {
+			if (fieldDescriptor[0] == 'L') {
+				if (fieldDescriptor[fieldDescriptor.length - 1] != ';') {
+					throw new IllegalStateException(new String(fieldDescriptor) + " is not a valid field descriptor"); //$NON-NLS-1$
+				}
+			}
+		}
+
+		NdTypeId result = new NdTypeId(this.pdom, fieldDescriptor);
+		if (!CharArrayUtils.equals(result.getFieldDescriptor().getChars(), fieldDescriptor)) {
+			throw new IllegalStateException("Field descriptor didn't match"); //$NON-NLS-1$
+		}
+		return result;
 	}
 
 	public Nd getNd() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 7c320bc..bd561c2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -12,8 +12,9 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
  */
 public class JavaNames {
 	private static final char[] CLASS_FILE_SUFFIX = ".class".toCharArray(); //$NON-NLS-1$
-	private static final char[] FIELD_DESCRIPTOR_PREFIX = new char[]{'L'};
-	private static final char[] METHOD_ID_SEPARATOR = new char[]{'#'};
+	private static final char[] FIELD_DESCRIPTOR_PREFIX = new char[] { 'L' };
+	private static final char[] FIELD_DESCRIPTOR_SUFFIX = new char[] { ';' };
+	private static final char[] METHOD_ID_SEPARATOR = new char[] { '#' };
 	private static final char[] JAR_FILE_ENTRY_SEPARATOR = IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR.toCharArray();
 
 	/**
@@ -58,8 +59,8 @@ public class JavaNames {
 			workspaceLocation = resourceFile.getAnyOpenWorkspaceLocation(root).toString().toCharArray();
 		}
 
-		if (workspaceLocation == null) {
-			workspaceLocation = resourceFile.getFilename().getChars();
+		if (workspaceLocation == null || workspaceLocation.length == 0) {
+			workspaceLocation = resourceFile.getLocation().getChars();
 		}
 
 		return CharArrayUtils.concat(workspaceLocation, JAR_FILE_ENTRY_SEPARATOR,
@@ -67,7 +68,7 @@ public class JavaNames {
 	}
 
 	public static char[] binaryNameToFieldDescriptor(char[] binaryName) {
-		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, binaryName);
+		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, binaryName, FIELD_DESCRIPTOR_SUFFIX);
 	}
 
 	public static char[] fieldDescriptorToJavaName(char[] fieldDescriptor, boolean fullyQualified) {
@@ -84,7 +85,8 @@ public class JavaNames {
 				case 'I' : result.append("int"); break; //$NON-NLS-1$
 				case 'J' : result.append("long"); break; //$NON-NLS-1$
 				case 'L' : {
-					char[] binaryName = CharArrayUtils.substring(fieldDescriptor, scanPosition + 1);
+					char[] binaryName = CharArrayUtils.subarray(fieldDescriptor, scanPosition + 1,
+							fieldDescriptor.length - 1);
 					if (fullyQualified) {
 						// Modify the binaryName string in-place to change it into a fully qualified name
 						CharOperation.replace(binaryName, '/', '.');
@@ -137,7 +139,7 @@ public class JavaNames {
 	 */
 	public static char[] fieldDescriptorToBinaryName(char[] fieldDescriptor) {
 		if (CharArrayUtils.startsWith(fieldDescriptor, 'L')) {
-			return CharArrayUtils.substring(fieldDescriptor, 1);
+			return CharArrayUtils.subarray(fieldDescriptor, 1, fieldDescriptor.length - 1);
 		}
 		return CharArrayUtils.EMPTY_CHAR_ARRAY;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index a1e8974..7527bff 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -121,13 +121,20 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 
 		int idx = 0;
 		for (NdTypeParameter next : parameters) {
-			CharArrayBuffer nextArray = new CharArrayBuffer();
-			next.getSignature(nextArray);
-			result[idx] = nextArray.getContents();
+			char[] nextContents = getSignatureFor(next);
+			result[idx] = nextContents;
+			idx++;
 		}
 		return result;
 	}
 
+	private char[] getSignatureFor(NdTypeParameter next) {
+		CharArrayBuffer nextArray = new CharArrayBuffer();
+		next.getSignature(nextArray);
+		char[] nextContents = nextArray.getContents();
+		return nextContents;
+	}
+
 	public List<NdTypeParameter> getTypeParameters() {
 		return TYPE_PARAMETERS.asList(getNd(), this.address);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index 2d6456f..d173e14 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -69,6 +69,8 @@ public class NdMethod extends NdBinding {
 
 	public NdMethod(NdType parent) {
 		super(parent.getNd(), parent.getFile());
+
+		PARENT.put(getNd(), this.address, parent);
 	}
 
 	public NdMethodId getMethodId() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 2b4e3cf..9baff34 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -143,15 +143,28 @@ public class NdResourceFile extends NdTreeNode {
 		return Path.EMPTY;
 	}
 
+	/**
+	 * Returns a workspace path to this resource if possible and the absolute filesystem location if not.
+	 */
+	public IPath getPath() {
+		IPath workspacePath = getFirstWorkspaceLocation();
+
+		if (workspacePath.isEmpty()) {
+			return new Path(getLocation().getString());
+		}
+
+		return workspacePath;
+	}
+
 	public List<NdWorkspaceLocation> getWorkspaceMappings() {
 		return WORKSPACE_MAPPINGS.asList(getNd(), this.address);
 	}
 
-	public IString getFilename() {
+	public IString getLocation() {
 		return FILENAME.get(getNd(), this.address);
 	}
 
-	public void setFilename(String filename) {
+	public void setLocation(String filename) {
 		FILENAME.put(getNd(), this.address, filename);
 	}
 
@@ -191,7 +204,7 @@ public class NdResourceFile extends NdTreeNode {
 	public IString getPackageFragmentRoot() {
 		IString javaRoot = JAVA_ROOT.get(getNd(), this.address);
 		if (javaRoot.length() == 0) {
-			return getFilename();
+			return getLocation();
 		}
 		return javaRoot;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index aa2ebba..9ebc7c3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 
 /**
  * @since 3.12
@@ -196,7 +197,9 @@ public class NdType extends NdBinding {
 		if (isLocal()) {
 			return getInnerTypeSourceName();
 		}
-		return getTypeId().getSimpleNameCharArray();
+		char[] simpleName = getTypeId().getSimpleNameCharArray();
+		int lastIndex = CharArrayUtils.lastIndexOf('.', simpleName) + 1;
+		return CharArrayUtils.substring(simpleName, lastIndex);
 	}
 
 	public NdMethodId getDeclaringMethod() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
index a852016..7d78c80 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
@@ -18,7 +18,7 @@ public final class ReferenceUtil {
 	public static DatabaseRef<NdType> createTypeRef(NdType type) {
 		final Nd nd = type.getNd();
 		final char[] fieldDescriptor = type.getTypeId().getRawType().getFieldDescriptor().getChars();
-		final char[] fileName = type.getResourceFile().getFilename().getChars();
+		final char[] fileName = type.getResourceFile().getLocation().getChars();
 		return new DatabaseRef<NdType>(type.getNd(), getTypeSupplier(nd, fileName, fieldDescriptor), type);
 	}
 
@@ -61,7 +61,7 @@ public final class ReferenceUtil {
 
 				List<NdType> implementations = typeId.getTypes();
 				for (NdType next : implementations) {
-					if (next.getResourceFile().getFilename().compare(fileName, false) == 0) {
+					if (next.getResourceFile().getLocation().compare(fileName, false) == 0) {
 						return next;
 					}
 				}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
new file mode 100644
index 0000000..7b2da1b
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -0,0 +1,19 @@
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.core.nd.DatabaseRef;
+import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+import org.eclipse.jdt.internal.core.nd.java.JavaNames;
+import org.eclipse.jdt.internal.core.nd.java.NdType;
+import org.eclipse.jdt.internal.core.nd.java.ReferenceUtil;
+
+public class BinaryTypeFactory {
+	public static IBinaryType create(IPath fileSystemPath, String binaryName) {
+		JavaIndex index = JavaIndex.getIndex();
+		DatabaseRef<NdType> typeRef = ReferenceUtil.createTypeRef(index.getNd(),
+				fileSystemPath.toString().toCharArray(),
+				JavaNames.binaryNameToFieldDescriptor(binaryName.toCharArray()));
+		return new IndexBinaryType(typeRef);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 6649fb7..58c48ac 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -79,7 +79,7 @@ public class IndexBinaryType implements IBinaryType {
 		try (IReader rl = this.typeRef.lock()) {
 			NdType type = this.typeRef.get();
 			if (type != null) {
-				return type.getFile().getFilename().getChars();
+				return type.getFile().getPath().toString().toCharArray();
 			} else {
 				return new char[0];
 			}
@@ -155,6 +155,10 @@ public class IndexBinaryType implements IBinaryType {
 			if (type != null) {
 				List<NdVariable> variables = type.getVariables();
 
+				if (variables.isEmpty()) {
+					return null;
+				}
+
 				IBinaryField[] result = new IBinaryField[variables.size()];
 				for (int fieldIdx = 0; fieldIdx < variables.size(); fieldIdx++) {
 					result[fieldIdx] = createBinaryField(variables.get(fieldIdx));
@@ -194,6 +198,10 @@ public class IndexBinaryType implements IBinaryType {
 			if (type != null) {
 				List<NdTypeInterface> interfaces = type.getInterfaces();
 
+				if (interfaces.isEmpty()) {
+					return null;
+				}
+
 				char[][] result = new char[interfaces.size()][];
 				for (int idx = 0; idx < interfaces.size(); idx++) {
 					NdTypeSignature nextInterface = interfaces.get(idx).getInterface();
@@ -467,6 +475,21 @@ public class IndexBinaryType implements IBinaryType {
 
 			result[idx] = toAnnotationArray(next.getAnnotations());
 		}
+
+		int newLength = result.length;
+		while (newLength > 0 && result[newLength - 1] == null) {
+			--newLength;
+		}
+
+		if (newLength < result.length) {
+			if (newLength == 0) {
+				return null;
+			}
+			IBinaryAnnotation[][] newResult = new IBinaryAnnotation[newLength][];
+			System.arraycopy(result, 0, newResult, 0, newLength);
+			result = newResult;
+		}
+
 		return result;
 	}
 
@@ -496,9 +519,14 @@ public class IndexBinaryType implements IBinaryType {
 	private char[][] getExceptionTypeNames(NdMethod ndMethod) {
 		List<NdMethodException> exceptions = ndMethod.getExceptions();
 
-		if (exceptions.isEmpty()) {
-			return null;
-		}
+		// Although the JavaDoc for IBinaryMethod says that the exception list will be null if empty,
+		// the implementation in MethodInfo returns an empty array rather than null. We copy the
+		// same behavior here in case something is relying on it. Uncomment the following if the "null"
+		// version is deemed correct.
+
+		// if (exceptions.isEmpty()) {
+		// return null;
+		// }
 
 		char[][] result = new char[exceptions.size()][];
 		for (int idx = 0; idx < exceptions.size(); idx++) {
@@ -562,6 +590,9 @@ public class IndexBinaryType implements IBinaryType {
 
 	private static void buildAnnotations(List<IBinaryTypeAnnotation> result, ITypeAnnotationBuilder builder,
 			NdTypeSignature signature) {
+		if (signature == null) {
+			return;
+		}
 		ITypeAnnotationBuilder nextAnnotations = builder;
 		List<NdTypeSignature> declaringTypes = signature.getDeclaringTypeChain();
 
@@ -615,6 +646,9 @@ public class IndexBinaryType implements IBinaryType {
 	}
 
 	private static Object unpackValue(NdConstant value) {
+		if (value == null) {
+			return null;
+		}
 		if (value instanceof NdConstantAnnotation) {
 			NdConstantAnnotation annotation = (NdConstantAnnotation) value;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
index a846094..52889bf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
@@ -49,6 +49,12 @@ public class CharArrayUtils {
 	}
 
 	public static final boolean equals(char[][] strarr1, char[][] strarr2) {
+		if (strarr1 == strarr2) {
+			return true;
+		}
+		if (strarr1 == null || strarr2 == null) {
+			return false;
+		}
 		if (strarr1.length != strarr2.length) {
 			return false;
 		}
commit 3981a91aafeabea021e8633e0c47a1b84bedddce
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Feb 10 18:22:08 2016 -0800

    Bug 481796 - Lots of bugfixes for the new index
    
    Change-Id: I65a123c66054fb897f014df4f1d30390853ac10d
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

4	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
74	83	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
20	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
14	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
15	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
34	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 417af1b..8f9e8db 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -131,7 +131,8 @@ public class ClassFileToIndexConverter {
 		char[] binaryName = binaryType.getName();
 		logInfo("adding binary type " + new String(binaryName)); //$NON-NLS-1$
 
-		NdTypeId name = createTypeIdFromBinaryName(binaryName);
+		char[] fieldDescriptor = JavaNames.binaryNameToFieldDescriptor(binaryName);
+		NdTypeId name = createTypeIdFromFieldDescriptor(fieldDescriptor);
 		NdType type = name.findTypeByResourceAddress(this.resource.address);
 
 		if (type == null) {
@@ -199,10 +200,7 @@ public class ClassFileToIndexConverter {
 		type.setIsLocal(binaryType.isLocal());
 		type.setIsMember(binaryType.isMember());
 		type.setTagBits(binaryType.getTagBits());
-
-		if (binaryType.isLocal()) {
-			type.setInnerTypeSourceName(binaryType.getSourceName());
-		}
+		type.setSourceNameOverride(binaryType.getSourceName());
 
 		if (ENABLE_SELF_TEST) {
 			IndexTester.testType(binaryType, new IndexBinaryType(ReferenceUtil.createTypeRef(type)));
@@ -426,6 +424,7 @@ public class ClassFileToIndexConverter {
 				return typeSignature;
 			}
 			case 'V':
+				wrapper.start++;
 				return null;
 			case 'B':
 			case 'C':
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 88ba2dc..19a08c1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -76,10 +76,7 @@ public class IndexTester {
 				return false;
 			}
 
-			IBinaryAnnotation binaryAnnotation = this.annotation.getAnnotation();
-			IBinaryAnnotation otherBinaryAnnotation = otherAnnotation.getAnnotation();
-
-			return IndexTester.annotationsEqual(binaryAnnotation, otherBinaryAnnotation);
+			return IndexTester.isEqual(this.annotation.getAnnotation(), otherAnnotation.getAnnotation());
 		}
 	}
 
@@ -121,7 +118,9 @@ public class IndexTester {
 			}
 		}
 
-		assertEquals("The file name did not match", expected.getFileName(), actual.getFileName()); //$NON-NLS-1$
+		// Commented this out because the "expected" values often appear to be invalid paths when the "actual"
+		// ones are correct.
+		// assertEquals("The file name did not match", expected.getFileName(), actual.getFileName()); //$NON-NLS-1$
 		assertEquals("The interface names did not match", expected.getInterfaceNames(), actual.getInterfaceNames()); //$NON-NLS-1$
 
 		// Member types are not expected to match during indexing since the index uses discovered cross-references,
@@ -165,7 +164,7 @@ public class IndexTester {
 		}
 	}
 
-	private static <T> boolean isEqual(T o1, T o2) {
+	static <T> boolean isEqual(T o1, T o2) {
 		if (o1 == o2) {
 			return true;
 		}
@@ -174,6 +173,68 @@ public class IndexTester {
 			return false;
 		}
 
+		if (o1 instanceof ClassSignature) {
+			if (!(o2 instanceof ClassSignature)) {
+				return false;
+			}
+
+			ClassSignature sig1 = (ClassSignature) o1;
+			ClassSignature sig2 = (ClassSignature) o2;
+
+			return Arrays.equals(sig1.getTypeName(), sig2.getTypeName());
+		}
+
+		if (o1 instanceof IBinaryAnnotation) {
+			IBinaryAnnotation binaryAnnotation = (IBinaryAnnotation) o1;
+			IBinaryAnnotation otherBinaryAnnotation = (IBinaryAnnotation) o2;
+			IBinaryElementValuePair[] elementValuePairs = binaryAnnotation.getElementValuePairs();
+			IBinaryElementValuePair[] otherElementValuePairs = otherBinaryAnnotation.getElementValuePairs();
+
+			if (elementValuePairs.length != otherElementValuePairs.length) {
+				return false;
+			}
+
+			for (int idx = 0; idx < elementValuePairs.length; idx++) {
+				IBinaryElementValuePair next = elementValuePairs[idx];
+				IBinaryElementValuePair otherNext = otherElementValuePairs[idx];
+
+				char[] nextName = next.getName();
+				char[] otherNextName = otherNext.getName();
+
+				if (!Arrays.equals(nextName, otherNextName)) {
+					return false;
+				}
+
+				if (!isEqual(next.getValue(), otherNext.getValue())) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+		if (o1 instanceof Constant) {
+			if (!(o2 instanceof Constant)) {
+				return false;
+			}
+
+			Constant const1 = (Constant) o1;
+			Constant const2 = (Constant) o2;
+
+			return const1.hasSameValue(const2);
+		}
+
+		if (o1 instanceof EnumConstantSignature) {
+			if (!(o2 instanceof EnumConstantSignature)) {
+				return false;
+			}
+
+			EnumConstantSignature enum1 = (EnumConstantSignature) o1;
+			EnumConstantSignature enum2 = (EnumConstantSignature) o2;
+
+			return Arrays.equals(enum1.getEnumConstantName(), enum2.getEnumConstantName())
+					&& Arrays.equals(enum1.getTypeName(), enum2.getTypeName());
+		}
+
 		if (o1 instanceof char[]) {
 			char[] c1 = (char[]) o1;
 			char[] c2 = (char[]) o2;
@@ -232,9 +293,8 @@ public class IndexTester {
 		assertEquals("The argument names didn't match.", expectedMethod.getArgumentNames(), //$NON-NLS-1$
 				actualMethod.getArgumentNames());
 
-		if (!constantsEqual(expectedMethod.getDefaultValue(), actualMethod.getDefaultValue())) {
-			throw new IllegalStateException("The default values didn't match."); //$NON-NLS-1$
-		}
+		assertEquals("The default values didn't match.", expectedMethod.getDefaultValue(), //$NON-NLS-1$
+				actualMethod.getDefaultValue());
 
 		assertEquals("The exception type names did not match.", expectedMethod.getExceptionTypeNames(), //$NON-NLS-1$
 				actualMethod.getExceptionTypeNames());
@@ -309,7 +369,7 @@ public class IndexTester {
 		}
 
 		for (int idx = 0; idx < expectedBinaryAnnotations.length; idx++) {
-			if (!annotationsEqual(expectedBinaryAnnotations[idx], actualBinaryAnnotations[idx])) {
+			if (!isEqual(expectedBinaryAnnotations[idx], actualBinaryAnnotations[idx])) {
 				throw new IllegalStateException("An annotation had an unexpected value"); //$NON-NLS-1$
 			}
 		}
@@ -317,10 +377,11 @@ public class IndexTester {
 
 	private static void compareFields(IBinaryField field1, IBinaryField field2) {
 		compareAnnotations(field1.getAnnotations(), field2.getAnnotations());
-		if (!constantsEqual(field1.getConstant(), field2.getConstant())) {
-			throw new IllegalStateException("Constants not equal"); //$NON-NLS-1$
+		assertEquals("Constants not equal", field1.getConstant(), field2.getConstant()); //$NON-NLS-1$
+		if (field1.getGenericSignature() != null) {
+			assertEquals("The generic signature did not match", field1.getGenericSignature(), //$NON-NLS-1$
+					field2.getGenericSignature());
 		}
-		assertEquals("The generic signature did not match", field1.getGenericSignature(), field2.getGenericSignature()); //$NON-NLS-1$
 		assertEquals("The modifiers did not match", field1.getModifiers(), field2.getModifiers()); //$NON-NLS-1$
 		assertEquals("The tag bits did not match", field1.getTagBits(), field2.getTagBits()); //$NON-NLS-1$
 		assertEquals("The names did not match", field1.getName(), field2.getName()); //$NON-NLS-1$
@@ -329,74 +390,4 @@ public class IndexTester {
 		assertEquals("The type names did not match", field1.getTypeName(), field2.getTypeName()); //$NON-NLS-1$
 	}
 
-	public static boolean constantsEqual(Object value, Object value2) {
-		if (value == value2) {
-			return true;
-		}
-		if (value == null) {
-			return value2 == null;
-		}
-
-		if (value instanceof ClassSignature) {
-			if (!(value2 instanceof ClassSignature)) {
-				return false;
-			}
-
-			ClassSignature sig1 = (ClassSignature) value;
-			ClassSignature sig2 = (ClassSignature) value2;
-
-			return Arrays.equals(sig1.getTypeName(), sig2.getTypeName());
-		}
-		if (value instanceof Constant) {
-			if (!(value2 instanceof Constant)) {
-				return false;
-			}
-
-			Constant const1 = (Constant) value;
-			Constant const2 = (Constant) value2;
-
-			return const1.hasSameValue(const2);
-		}
-		if (value instanceof EnumConstantSignature) {
-			if (!(value2 instanceof EnumConstantSignature)) {
-				return false;
-			}
-
-			EnumConstantSignature enum1 = (EnumConstantSignature) value;
-			EnumConstantSignature enum2 = (EnumConstantSignature) value2;
-
-			return Arrays.equals(enum1.getEnumConstantName(), enum2.getEnumConstantName())
-					&& Arrays.equals(enum1.getTypeName(), enum2.getTypeName());
-		}
-
-		return false;
-	}
-
-	static boolean annotationsEqual(IBinaryAnnotation binaryAnnotation,
-			IBinaryAnnotation otherBinaryAnnotation) {
-		IBinaryElementValuePair[] elementValuePairs = binaryAnnotation.getElementValuePairs();
-		IBinaryElementValuePair[] otherElementValuePairs = otherBinaryAnnotation.getElementValuePairs();
-
-		if (elementValuePairs.length != otherElementValuePairs.length) {
-			return false;
-		}
-
-		for (int idx = 0; idx < elementValuePairs.length; idx++) {
-			IBinaryElementValuePair next = elementValuePairs[idx];
-			IBinaryElementValuePair otherNext = otherElementValuePairs[idx];
-
-			char[] nextName = next.getName();
-			char[] otherNextName = otherNext.getName();
-
-			if (!Arrays.equals(nextName, otherNextName)) {
-				return false;
-			}
-
-			if (!constantsEqual(next.getValue(), otherNext.getValue())) {
-				return false;
-			}
-		}
-		return true;
-	}
-
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index bd561c2..017a505 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -67,10 +67,17 @@ public class JavaNames {
 				binaryNameToResourceRelativePath(binaryName));
 	}
 
+	/**
+	 * Converts a binary name to a field descriptor (without the trailing ';')
+	 */
 	public static char[] binaryNameToFieldDescriptor(char[] binaryName) {
 		return CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, binaryName, FIELD_DESCRIPTOR_SUFFIX);
 	}
 
+	/**
+	 * Converts a field descriptor to a java name. If fullyQualified is true, it returns a fully qualified class name.
+	 * If it is false, it returns a source name.
+	 */
 	public static char[] fieldDescriptorToJavaName(char[] fieldDescriptor, boolean fullyQualified) {
 		int arrayCount = 0;
 		CharArrayBuffer result = new CharArrayBuffer();
@@ -85,15 +92,17 @@ public class JavaNames {
 				case 'I' : result.append("int"); break; //$NON-NLS-1$
 				case 'J' : result.append("long"); break; //$NON-NLS-1$
 				case 'L' : {
-					char[] binaryName = CharArrayUtils.subarray(fieldDescriptor, scanPosition + 1,
-							fieldDescriptor.length - 1);
+					int end = fieldDescriptor.length - 1;
+					char[] binaryName = CharArrayUtils.subarray(fieldDescriptor, scanPosition + 1, end);
 					if (fullyQualified) {
 						// Modify the binaryName string in-place to change it into a fully qualified name
 						CharOperation.replace(binaryName, '/', '.');
-						result.append(binaryName); break;
+						result.append(binaryName);
 					} else {
-						result.append(binaryNameToSimpleName(binaryName)); break;
+						result.append(binaryNameToSimpleName(binaryName));
 					}
+					scanPosition += binaryName.length;
+					break;
 				}
 				case 'S' : result.append("short"); break; //$NON-NLS-1$
 				case 'Z' : result.append("boolean"); break; //$NON-NLS-1$
@@ -131,15 +140,17 @@ public class JavaNames {
 	}
 
 	/**
-	 * Given a field descriptor, if the field descriptor points to a class this returns the binary name of the class.
-	 * If the field descriptor points to any other type, this returns the empty string.
+	 * Given a field descriptor, if the field descriptor points to a class this returns the binary name of the class. If
+	 * the field descriptor points to any other type, this returns the empty string. The field descriptor may optionally
+	 * contain a trailing ';'.
 	 *
 	 * @param fieldDescriptor
 	 * @return ""
 	 */
 	public static char[] fieldDescriptorToBinaryName(char[] fieldDescriptor) {
 		if (CharArrayUtils.startsWith(fieldDescriptor, 'L')) {
-			return CharArrayUtils.subarray(fieldDescriptor, 1, fieldDescriptor.length - 1);
+			int end = fieldDescriptor.length - 1;
+			return CharArrayUtils.subarray(fieldDescriptor, 1, end);
 		}
 		return CharArrayUtils.EMPTY_CHAR_ARRAY;
 	}
@@ -151,7 +162,8 @@ public class JavaNames {
 	public static char[] simpleNameToSourceName(char[] chars) {
 		int lastSlash = CharOperation.lastIndexOf('/', chars);
 		int lastDollar = CharOperation.lastIndexOf('$', chars);
-		int startPosition = Math.max(lastSlash, lastDollar) + 1;
+		int lastDot = CharOperation.lastIndexOf('.', chars);
+		int startPosition = Math.max(Math.max(lastSlash, lastDollar), lastDot) + 1;
 		while (startPosition < chars.length && Character.isDigit(chars[startPosition])) {
 			startPosition++;
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index b68adf4..3974f17 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -137,7 +137,7 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			return;
 		}
 
-		result.append(getRawType().getFieldDescriptor().getChars());
+		result.append(getRawType().getFieldDescriptorWithoutTrailingSemicolon());
 
 		List<NdTypeArgument> arguments = getTypeArguments();
 		if (!arguments.isEmpty()) {
@@ -147,6 +147,7 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			}
 			result.append('>');
 		}
+		result.append(';');
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
index 4d06029..313b716 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodId.java
@@ -68,8 +68,8 @@ public class NdMethodId extends NdNode {
 	}
 
 	/**
-	 * Returns the field descriptor for the type followed by a # followed by the method selector
-	 * followed by the method descriptor. For example, "Lorg/eclipse/MyClass#foo()Ljava/lang/Object;V"
+	 * Returns the field descriptor for the type (without a trailing ';') followed by a # followed by the method
+	 * selector followed by the method descriptor. For example, "Lorg/eclipse/MyClass#foo()Ljava/lang/Object;V"
 	 */
 	public IString getMethodName() {
 		return METHOD_NAME.get(getNd(), this.address);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 9ebc7c3..4d886f6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -94,12 +94,18 @@ public class NdType extends NdBinding {
 		TYPENAME.put(getNd(), this.address, typeId);
 	}
 
-	public void setInnerTypeSourceName(char[] sourceName) {
-		INNER_CLASS_SOURCE_NAME.put(getNd(), this.address, sourceName);
+	/**
+	 * Sets the source name for this type.
+	 */
+	public void setSourceNameOverride(char[] sourceName) {
+		char[] oldSourceName = getSourceName();
+		if (!CharArrayUtils.equals(oldSourceName, sourceName)) {
+			INNER_CLASS_SOURCE_NAME.put(getNd(), this.address, sourceName);
+		}
 	}
 
-	public char[] getInnerTypeSourceName() {
-		return INNER_CLASS_SOURCE_NAME.get(getNd(), this.address).getChars();
+	public IString getSourceNameOverride() {
+		return INNER_CLASS_SOURCE_NAME.get(getNd(), this.address);
 	}
 
 	public long getResourceAddress() {
@@ -194,12 +200,12 @@ public class NdType extends NdBinding {
 	}
 
 	public char[] getSourceName() {
-		if (isLocal()) {
-			return getInnerTypeSourceName();
+		IString sourceName = getSourceNameOverride();
+		if (sourceName.length() != 0) {
+			return sourceName.getChars();
 		}
 		char[] simpleName = getTypeId().getSimpleNameCharArray();
-		int lastIndex = CharArrayUtils.lastIndexOf('.', simpleName) + 1;
-		return CharArrayUtils.substring(simpleName, lastIndex);
+		return JavaNames.simpleNameToSourceName(simpleName);
 	}
 
 	public NdMethodId getDeclaringMethod() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index fddd704..09e860d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -9,6 +9,7 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchKey;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
 /**
@@ -64,10 +65,24 @@ public class NdTypeId extends NdTypeSignature {
 		return TYPES.asList(getNd(), this.address);
 	}
 
+	/**
+	 * Returns the field descriptor.
+	 */
 	public IString getFieldDescriptor() {
 		return FIELD_DESCRIPTOR.get(getNd(), this.address);
 	}
 
+	public char[] getFieldDescriptorWithoutTrailingSemicolon() {
+		char[] fieldDescriptor = getFieldDescriptor().getChars();
+
+		int end = fieldDescriptor.length;
+		if (fieldDescriptor.length > 0 && fieldDescriptor[end - 1] == ';') {
+			end--;
+		}
+
+		return CharArrayUtils.subarray(fieldDescriptor, 0, end);
+	}
+
 	public char[] getBinaryName() {
 		return JavaNames.fieldDescriptorToBinaryName(getFieldDescriptor().getChars());
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
index 20b8735..7a0ad32 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryField.java
@@ -16,7 +16,7 @@ public class IndexBinaryField implements IBinaryField {
 	private char[] typeName;
 
 	public IndexBinaryField(IBinaryAnnotation[] annotations, Constant constant, char[] genericSignature, int modifiers,
-			char[] name, long tagBits, IBinaryTypeAnnotation[] typeAnnotations, char[] typeName) {
+			char[] name, long tagBits, IBinaryTypeAnnotation[] typeAnnotations, char[] fieldDescriptor) {
 		super();
 		this.modifiers = modifiers;
 		this.annotations = annotations;
@@ -25,7 +25,7 @@ public class IndexBinaryField implements IBinaryField {
 		this.genericSignature = genericSignature;
 		this.name = name;
 		this.tagBits = tagBits;
-		this.typeName = typeName;
+		this.typeName = fieldDescriptor;
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 58c48ac..73d6e7a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -36,6 +36,7 @@ import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
 import org.eclipse.jdt.internal.core.nd.java.NdType;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeArgument;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeBound;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeId;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
@@ -449,7 +450,7 @@ public class IndexBinaryType implements IBinaryType {
 
 		return IndexBinaryMethod.create().setAnnotations(toAnnotationArray(ndMethod.getAnnotations()))
 				.setModifiers(ndMethod.getModifiers()).setIsConstructor(methodId.isConstructor())
-				.setArgumentNames(ndMethod.getArgumentNames()).setDefaultValue(unpackValue(ndMethod.getDefaultValue()))
+				.setArgumentNames(getArgumentNames(ndMethod)).setDefaultValue(unpackValue(ndMethod.getDefaultValue()))
 				.setExceptionTypeNames(getExceptionTypeNames(ndMethod))
 				.setGenericSignature(getGenericSignatureFor(ndMethod))
 				.setMethodDescriptor(methodId.getMethodDescriptor())
@@ -458,6 +459,25 @@ public class IndexBinaryType implements IBinaryType {
 				.setIsClInit(methodId.isClInit()).setTypeAnnotations(toTypeAnnotationArray(typeAnnotations));
 	}
 
+	private char[][] getArgumentNames(NdMethod ndMethod) {
+		// Unlike what its JavaDoc says, IBinaryType returns an empty array if no argument names are available, so
+		// we replicate this weird undocumented corner case here.
+		char[][] result = ndMethod.getArgumentNames();
+		int lastNonEmpty = -1;
+		for (int idx = 0; idx < result.length; idx++) {
+			if (result[idx] != null && result[idx].length != 0) {
+				lastNonEmpty = idx;
+			}
+		}
+
+		if (lastNonEmpty != result.length - 1) {
+			char[][] newResult = new char[lastNonEmpty + 1][];
+			System.arraycopy(result, 0, newResult, 0, lastNonEmpty + 1);
+			return newResult;
+		}
+		return result;
+	}
+
 	private IBinaryTypeAnnotation[] toTypeAnnotationArray(List<IBinaryTypeAnnotation> result) {
 		return result.isEmpty() ? null
 				: (IBinaryTypeAnnotation[]) result.toArray(new IBinaryTypeAnnotation[result.size()]);
@@ -544,6 +564,9 @@ public class IndexBinaryType implements IBinaryType {
 		if (ndConstant != null) {
 			constant = ndConstant.getConstant();
 		}
+		if (constant == null) {
+			constant = Constant.NotAConstant;
+		}
 
 		List<IBinaryTypeAnnotation> typeAnnotations = new ArrayList<>();
 		NdTypeSignature type = ndVariable.getType();
@@ -558,7 +581,7 @@ public class IndexBinaryType implements IBinaryType {
 
 		long tagBits = ndVariable.getTagBits();
 		return new IndexBinaryField(annotations, constant, signature.getContents(), ndVariable.getModifiers(), name,
-				tagBits, typeAnnotationArray, type.getRawType().getBinaryName());
+				tagBits, typeAnnotationArray, type.getRawType().getFieldDescriptor().getChars());
 	}
 
 	public static IBinaryAnnotation createBinaryAnnotation(NdAnnotation ndAnnotation) {
@@ -572,8 +595,8 @@ public class IndexBinaryType implements IBinaryType {
 			resultingPair[idx] = new ElementValuePairInfo(next.getName().getChars(), unpackValue(next.getValue()));
 		}
 
-		final char[] binaryName = JavaNames
-				.fieldDescriptorToBinaryName(ndAnnotation.getType().getRawType().getFieldDescriptor().getChars());
+		final char[] binaryName = JavaNames.fieldDescriptorToBinaryName(
+				ndAnnotation.getType().getRawType().getFieldDescriptor().getChars());
 
 		return new IBinaryAnnotation() {
 			@Override
@@ -638,7 +661,13 @@ public class IndexBinaryType implements IBinaryType {
 						char[] methodName = methodId.getMethodName().getChars();
 						int startIdx = CharArrayUtils.lastIndexOf('#', methodName);
 						this.enclosingMethod = CharArrayUtils.substring(methodName, startIdx + 1);
-						this.enclosingType = CharArrayUtils.subarray(methodName, 0, startIdx);
+						this.enclosingType = CharArrayUtils.subarray(methodName, 1, startIdx);
+					} else {
+						NdTypeId typeId = type.getDeclaringType();
+
+						if (typeId != null) {
+							this.enclosingType = typeId.getBinaryName();
+						}
 					}
 				}
 			}
commit 6f6b882228ce89eb1c8aadd8ca3f7ee4e4817709
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 11 08:39:41 2016 -0800

    Bug 481796 - Change the way array types are indexed
    
    The new format ensure that arrays receive correct field descriptors and
    that array types will be found in the index when searching for an array
    type's field descirptor.
    
    Change-Id: I65a123c66054fb897f014df4f1d30390853ac10d
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

8	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
15	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
9	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
14	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 8f9e8db..eecb206 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -62,6 +62,7 @@ public class ClassFileToIndexConverter {
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private static final char[] PATH_SEPARATOR = new char[]{'/'};
 	private static final boolean ENABLE_SELF_TEST = true;
+	private static final char[] ARRAY_FIELD_DESCRIPTOR_PREFIX = new char[] { '[' };
 	private NdResourceFile resource;
 	private JavaIndex index;
 
@@ -413,12 +414,16 @@ public class ClassFileToIndexConverter {
 			case '[': {
 				// Skip the '[' prefix
 				wrapper.start++;
-				// We encode arrays as though they were a one-argument generic type called '[' whose element
+				// Determine the array argument type
+				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
+				char[] fieldDescriptor = CharArrayUtils.concat(ARRAY_FIELD_DESCRIPTOR_PREFIX,
+						elementType.getRawType().getFieldDescriptor().getChars());
+				NdTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
+				// We encode signatures as though they were a one-argument generic type whose element
 				// type is the generic argument.
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
-				typeSignature.setRawType(createTypeIdFromFieldDescriptor(new char[] { '[' }));
+				typeSignature.setRawType(rawType);
 				NdTypeArgument typeArgument = new NdTypeArgument(getNd(), typeSignature);
-				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
 				typeArgument.setType(elementType);
 				attachAnnotations(typeSignature, annotations);
 				return typeSignature;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 017a505..0977c48 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -16,6 +16,7 @@ public class JavaNames {
 	private static final char[] FIELD_DESCRIPTOR_SUFFIX = new char[] { ';' };
 	private static final char[] METHOD_ID_SEPARATOR = new char[] { '#' };
 	private static final char[] JAR_FILE_ENTRY_SEPARATOR = IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR.toCharArray();
+	public static final char[] ARRAY_FIELD_DESCRIPTOR_PREFIX = new char[] { '[' };
 
 	/**
 	 * Converts a java binary name to a simple name.
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index 3974f17..151da2a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -177,4 +177,19 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 
 		result.add(this);
 	}
+
+	@Override
+	public boolean isArrayType() {
+		NdTypeId rawType = getRawType();
+
+		if (rawType == null) {
+			return false;
+		}
+
+		if (rawType.getFieldDescriptor().comparePrefix(JavaNames.ARRAY_FIELD_DESCRIPTOR_PREFIX, true) == 0) { // $NON-NLS-1$
+			return true;
+		}
+
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 09e860d..2e425af 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -98,6 +98,10 @@ public class NdTypeId extends NdTypeSignature {
 		return this.fName.toCharArray();
 	}
 
+	public boolean hasFieldDescriptor(String name) {
+		return this.getFieldDescriptor().compare(name, true) == 0;
+	}
+
 	public boolean hasSimpleName(String name) {
 		if (this.fName != null)
 			return this.fName.equals(name);
@@ -151,4 +155,9 @@ public class NdTypeId extends NdTypeSignature {
 	public List<NdTypeArgument> getTypeArguments() {
 		return Collections.emptyList();
 	}
+
+	@Override
+	public boolean isArrayType() {
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index 2d12cb7..0ba0595 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -112,11 +112,20 @@ public abstract class NdTypeSignature extends NdNode {
 
 	public abstract void getSignature(CharArrayBuffer result);
 
-	public final boolean isArrayType() {
-		NdTypeId rawType = getRawType();
-
-		return rawType != null && rawType.hasSimpleName("["); //$NON-NLS-1$
-	}
+	/**
+	 * Returns true iff this is an array type signature (ie: that getArrayDimensionType() will return a non-null
+	 * answer). Note that this only returns true for the type signature that holds the reference to the array dimension
+	 * type. The raw type for that signature will return false, even though it has a field descriptor starting with '['.
+	 * <p>
+	 * In other words:
+	 *
+	 * <pre>
+	 * NdVariable someVariable = getSomeVariableWithAnArrayType()
+	 * System.out.println(someVariable.getType().isArrayType()); // true
+	 * System.out.println(someVariable.getType().getRawType().isArrayType()); // false
+	 * </pre>
+	 */
+	public abstract boolean isArrayType();
 
 	public abstract boolean isTypeVariable();
 
commit d7e189dd159a61131a189e6b427d71c538681204
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 11 10:13:31 2016 -0800

    Bug 481796 - Extract helper methods for IBinaryType's toString methods.
    
    Move the toString methods in implementations of IBinaryMethod and
    IBinaryAnnotation into static helper methods.
    
    Change-Id: I69605c4345e1f78f9115568c5b899a41e32433e8
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
0	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfo.java
0	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfoWithAnnotations.java
126	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/BinaryTypePrinter.java
1	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
0	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithAnnotations.java
0	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
0	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
1	32	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
index 9081769..63b00ba 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
@@ -377,20 +377,7 @@ private int scanElementValue(int offset) {
 	return currentOffset;
 }
 public String toString() {
-	StringBuffer buffer = new StringBuffer();
-	buffer.append('@');
-	buffer.append(this.typename);
-	if (this.pairs != null) {
-		buffer.append('(');
-		buffer.append("\n\t"); //$NON-NLS-1$
-		for (int i = 0, len = this.pairs.length; i < len; i++) {
-			if (i > 0)
-				buffer.append(",\n\t"); //$NON-NLS-1$
-			buffer.append(this.pairs[i]);
-		}
-		buffer.append(')');
-	}
-	return buffer.toString();
+	return BinaryTypePrinter.printAnnotation(this);
 }
 public int hashCode() {
 	final int prime = 31;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfo.java
index 6ddba77..0b76bfe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfo.java
@@ -93,23 +93,4 @@ AnnotationMethodInfo(MethodInfo methodInfo, Object defaultValue) {
 public Object getDefaultValue() {
 	return this.defaultValue;
 }
-protected void toStringContent(StringBuffer buffer) {
-	super.toStringContent(buffer);
-	if (this.defaultValue != null) {
-		buffer.append(" default "); //$NON-NLS-1$
-		if (this.defaultValue instanceof Object[]) {
-			buffer.append('{');
-			Object[] elements = (Object[]) this.defaultValue;
-			for (int i = 0, len = elements.length; i < len; i++) {
-				if (i > 0)
-					buffer.append(", "); //$NON-NLS-1$
-				buffer.append(elements[i]);
-			}
-			buffer.append('}');
-		} else {
-			buffer.append(this.defaultValue);
-		}
-		buffer.append('\n');
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfoWithAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfoWithAnnotations.java
index bd1cce8..26ca917 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfoWithAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationMethodInfoWithAnnotations.java
@@ -34,11 +34,4 @@ protected void reset() {
 			this.annotations[i].reset();
 	super.reset();
 }
-protected void toStringContent(StringBuffer buffer) {
-	super.toStringContent(buffer);
-	for (int i = 0, l = this.annotations == null ? 0 : this.annotations.length; i < l; i++) {
-		buffer.append(this.annotations[i]);
-		buffer.append('\n');
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/BinaryTypePrinter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/BinaryTypePrinter.java
new file mode 100644
index 0000000..79e9506
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/BinaryTypePrinter.java
@@ -0,0 +1,126 @@
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+public class BinaryTypePrinter {
+
+	public static String printAnnotation(IBinaryAnnotation annotation) {
+		StringBuffer buffer = new StringBuffer();
+		buffer.append('@');
+		buffer.append(annotation.getTypeName());
+		IBinaryElementValuePair[] valuePairs = annotation.getElementValuePairs();
+		if (valuePairs != null) {
+			buffer.append('(');
+			buffer.append("\n\t"); //$NON-NLS-1$
+			for (int i = 0, len = valuePairs.length; i < len; i++) {
+				if (i > 0)
+					buffer.append(",\n\t"); //$NON-NLS-1$
+				buffer.append(valuePairs[i]);
+			}
+			buffer.append(')');
+		}
+		return buffer.toString();
+	}
+
+	public static String printTypeAnnotation(IBinaryTypeAnnotation typeAnnotation) {
+		StringBuffer buffer = new StringBuffer();
+		buffer.append(typeAnnotation.getAnnotation());
+		buffer.append(' ');
+		// Not fully decoding it here, just including all the information in the string
+		buffer.append("target_type=").append(typeAnnotation.getTargetType()); //$NON-NLS-1$
+		buffer.append(", info=").append(typeAnnotation.getSupertypeIndex()); //$NON-NLS-1$
+		buffer.append(", info2=").append(typeAnnotation.getBoundIndex()); //$NON-NLS-1$
+		int[] theTypePath = typeAnnotation.getTypePath();
+		if (theTypePath != null && theTypePath.length != 0) {
+			buffer.append(", location=["); //$NON-NLS-1$
+			for (int i = 0, max = theTypePath.length; i < max; i += 2) {
+				if (i > 0) {
+					buffer.append(", "); //$NON-NLS-1$
+				}
+				switch (theTypePath[i]) {
+					case 0:
+						buffer.append("ARRAY"); //$NON-NLS-1$
+						break;
+					case 1:
+						buffer.append("INNER_TYPE"); //$NON-NLS-1$
+						break;
+					case 2:
+						buffer.append("WILDCARD"); //$NON-NLS-1$
+						break;
+					case 3:
+						buffer.append("TYPE_ARGUMENT(").append(theTypePath[i+1]).append(')'); //$NON-NLS-1$
+						break;
+				}
+			}
+			buffer.append(']');
+		}
+		return buffer.toString();
+	}
+
+	public static String printMethod(IBinaryMethod method) {
+		StringBuffer result = new StringBuffer();
+		toStringContent(result, method);
+		return result.toString();
+	}
+
+	public static void toStringContent(StringBuffer buffer, IBinaryMethod method) {
+		int modifiers = method.getModifiers();
+		char[] desc = method.getGenericSignature();
+		if (desc == null)
+			desc = method.getMethodDescriptor();
+		buffer
+			.append('{')
+			.append(
+				((modifiers & ClassFileConstants.AccDeprecated) != 0 ? "deprecated " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0001) == 1 ? "public " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0002) == 0x0002 ? "private " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0004) == 0x0004 ? "protected " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0008) == 0x000008 ? "static " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0010) == 0x0010 ? "final " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0040) == 0x0040 ? "bridge " : Util.EMPTY_STRING) //$NON-NLS-1$
+					+ ((modifiers & 0x0080) == 0x0080 ? "varargs " : Util.EMPTY_STRING)) //$NON-NLS-1$
+			.append(method.getSelector())
+			.append(desc)
+			.append('}');
+
+		Object defaultValue = method.getDefaultValue();
+		if (defaultValue != null) {
+			buffer.append(" default "); //$NON-NLS-1$
+			if (defaultValue instanceof Object[]) {
+				buffer.append('{');
+				Object[] elements = (Object[]) defaultValue;
+				for (int i = 0, len = elements.length; i < len; i++) {
+					if (i > 0)
+						buffer.append(", "); //$NON-NLS-1$
+					buffer.append(elements[i]);
+				}
+				buffer.append('}');
+			} else {
+				buffer.append(defaultValue);
+			}
+			buffer.append('\n');
+		}
+
+		IBinaryAnnotation[] annotations = method.getAnnotations();
+		for (int i = 0, l = annotations == null ? 0 : annotations.length; i < l; i++) {
+			buffer.append(annotations[i]);
+			buffer.append('\n');
+		}
+
+		int annotatedParameterCount = method.getAnnotatedParametersCount();
+		for (int i = 0; i < annotatedParameterCount; i++) {
+			buffer.append("param" + (i - 1)); //$NON-NLS-1$
+			buffer.append('\n');
+			IBinaryAnnotation[] infos = method.getParameterAnnotations(i, new char[0]);
+			for (int j = 0, k = infos == null ? 0 : infos.length; j < k; j++) {
+				buffer.append(infos[j]);
+				buffer.append('\n');
+			}
+		}
+	}
+
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
index 5d200fe..ded6cb5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
@@ -20,7 +20,6 @@ import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 
 @SuppressWarnings("rawtypes")
@@ -454,24 +453,7 @@ void toString(StringBuffer buffer) {
 	toStringContent(buffer);
 }
 protected void toStringContent(StringBuffer buffer) {
-	int modifiers = getModifiers();
-	char[] desc = getGenericSignature();
-	if (desc == null)
-		desc = getMethodDescriptor();
-	buffer
-	.append('{')
-	.append(
-		((modifiers & ClassFileConstants.AccDeprecated) != 0 ? "deprecated " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0001) == 1 ? "public " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0002) == 0x0002 ? "private " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0004) == 0x0004 ? "protected " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0008) == 0x000008 ? "static " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0010) == 0x0010 ? "final " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0040) == 0x0040 ? "bridge " : Util.EMPTY_STRING) //$NON-NLS-1$
-			+ ((modifiers & 0x0080) == 0x0080 ? "varargs " : Util.EMPTY_STRING)) //$NON-NLS-1$
-	.append(getSelector())
-	.append(desc)
-	.append('}');
+	BinaryTypePrinter.toStringContent(buffer, this);
 }
 private void readCodeAttribute() {
 	int attributesCount = u2At(6);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithAnnotations.java
index 4db5b95..214496f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithAnnotations.java
@@ -43,11 +43,4 @@ protected void reset() {
 			this.annotations[i].reset();
 	super.reset();
 }
-protected void toStringContent(StringBuffer buffer) {
-	super.toStringContent(buffer);
-	for (int i = 0, l = this.annotations == null ? 0 : this.annotations.length; i < l; i++) {
-		buffer.append(this.annotations[i]);
-		buffer.append('\n');
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
index d29206f..fa7ed52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
@@ -61,16 +61,4 @@ protected void reset() {
 	}
 	super.reset();
 }
-protected void toStringContent(StringBuffer buffer) {
-	super.toStringContent(buffer);
-	for (int i = 0, l = this.parameterAnnotations == null ? 0 : this.parameterAnnotations.length; i < l; i++) {
-		buffer.append("param" + (i - 1)); //$NON-NLS-1$
-		buffer.append('\n');
-		AnnotationInfo[] infos = this.parameterAnnotations[i];
-		for (int j = 0, k = infos == null ? 0 : infos.length; j < k; j++) {
-			buffer.append(infos[j]);
-			buffer.append('\n');
-		}
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
index 54c75dc..f409c94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
@@ -36,12 +36,4 @@ protected void reset() {
 	}
 	super.reset();
 }
-protected void toStringContent(StringBuffer buffer) {
-	super.toStringContent(buffer);
-	buffer.append("type annotations = \n");//$NON-NLS-1$
-	for (int i = 0, l = this.typeAnnotations == null ? 0 : this.typeAnnotations.length; i < l; i++) {
-		buffer.append(this.typeAnnotations[i].toString());
-		buffer.append('\n');
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
index f58de40..18d26b4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
@@ -123,40 +123,9 @@ protected void reset() {
 }
 
 public String toString() {
-	StringBuffer buffer = new StringBuffer();
-	buffer.append(this.annotation);
-	buffer.append(' ');
-	// Not fully decoding it here, just including all the information in the string
-	buffer.append("target_type=").append(this.targetType); //$NON-NLS-1$
-	buffer.append(", info=").append(this.info); //$NON-NLS-1$
-	buffer.append(", info2=").append(this.info2); //$NON-NLS-1$
-	if (this.typePath != NO_TYPE_PATH) {
-		buffer.append(", location=["); //$NON-NLS-1$
-		for (int i = 0, max = this.typePath.length; i < max; i += 2) {
-			if (i > 0) {
-				buffer.append(", "); //$NON-NLS-1$
-			}
-			switch (this.typePath[i]) {
-				case 0:
-					buffer.append("ARRAY"); //$NON-NLS-1$
-					break;
-				case 1:
-					buffer.append("INNER_TYPE"); //$NON-NLS-1$
-					break;
-				case 2:
-					buffer.append("WILDCARD"); //$NON-NLS-1$
-					break;
-				case 3:
-					buffer.append("TYPE_ARGUMENT(").append(this.typePath[i+1]).append(')'); //$NON-NLS-1$
-					break;
-			}
-		}
-		buffer.append(']');
-	}
-	return buffer.toString();
+	return BinaryTypePrinter.printTypeAnnotation(this);
 }
 
-
 public int getTargetType() {
 	return this.targetType;
 }
commit 5d6d74eecc247654e026de267daf557acc74659e
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 11 10:14:08 2016 -0800

    Bug 481796 - Add meaningful toString methods to several data types.
    
    Change-Id: I91d280320af000015b6de6908169fffbdd4aad06
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

7	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
6	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
6	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
5	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryTypeAnnotation.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 19a08c1..41f59b5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -37,6 +37,11 @@ public class IndexTester {
 		}
 
 		@Override
+		public String toString() {
+			return this.annotation.toString();
+		}
+
+		@Override
 		public boolean equals(Object obj) {
 			if (obj.getClass() != TypeAnnotationWrapper.class) {
 				return false;
@@ -285,8 +290,8 @@ public class IndexTester {
 	}
 
 	private static void compareMethods(IBinaryMethod expectedMethod, IBinaryMethod actualMethod) {
-		assertEquals("The annotated parameter count didn't match", actualMethod.getAnnotatedParametersCount(), //$NON-NLS-1$
-				expectedMethod.getAnnotatedParametersCount());
+		assertEquals("The annotated parameter count didn't match", expectedMethod.getAnnotatedParametersCount(), //$NON-NLS-1$
+				actualMethod.getAnnotatedParametersCount());
 
 		compareAnnotations(expectedMethod.getAnnotations(), actualMethod.getAnnotations());
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
index 63f8d3f..29031c9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryMethod.java
@@ -1,5 +1,6 @@
 package org.eclipse.jdt.internal.core.nd.java.model;
 
+import org.eclipse.jdt.internal.compiler.classfmt.BinaryTypePrinter;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
@@ -163,4 +164,9 @@ public final class IndexBinaryMethod implements IBinaryMethod {
 	public IBinaryTypeAnnotation[] getTypeAnnotations() {
 		return this.typeAnnotations;
 	}
+
+	@Override
+	public String toString() {
+		return BinaryTypePrinter.printMethod(this);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 73d6e7a..d242cde 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.BinaryTypePrinter;
 import org.eclipse.jdt.internal.compiler.classfmt.ElementValuePairInfo;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
@@ -608,6 +609,11 @@ public class IndexBinaryType implements IBinaryType {
 			public IBinaryElementValuePair[] getElementValuePairs() {
 				return resultingPair;
 			}
+
+			@Override
+			public String toString() {
+				return BinaryTypePrinter.printAnnotation(this);
+			}
 		};
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryTypeAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryTypeAnnotation.java
index 9f3e4c1..f7a710c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryTypeAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryTypeAnnotation.java
@@ -1,5 +1,6 @@
 package org.eclipse.jdt.internal.core.nd.java.model;
 
+import org.eclipse.jdt.internal.compiler.classfmt.BinaryTypePrinter;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 
@@ -72,4 +73,8 @@ public class IndexBinaryTypeAnnotation implements IBinaryTypeAnnotation {
 		return this.info;
 	}
 
+	@Override
+	public String toString() {
+		return BinaryTypePrinter.printTypeAnnotation(this);
+	}
 }
commit 0223f791cce471b8e0a1d1b96e2c9fee5284144a
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 11 13:19:09 2016 -0800

    Bug 481796 - A number of bugfixes.
    
    Change-Id: Ie7d574f602bf327aa31fc05b445b35150378c8ec
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

17	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
13	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
40	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
33	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index eecb206..64eb8ae 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -54,6 +54,7 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class ClassFileToIndexConverter {
+	private static final char[] JAVA_LANG_OBJECT_FIELD_DESCRIPTOR = "Ljava/lang/Object;".toCharArray(); //$NON-NLS-1$
 	private static final char[] INNER_TYPE_SEPARATOR = new char[] { '$' };
 	private static final char[] FIELD_DESCRIPTOR_SUFFIX = new char[] { ';' };
 	private static final char[] COMMA = new char[]{','};
@@ -299,6 +300,15 @@ public class ClassFileToIndexConverter {
 			throwsIdx++;
 		}
 
+		// char[][] exceptionTypeNames = next.getExceptionTypeNames();
+		// int numExceptions = exceptionTypeNames == null ? 0 : exceptionTypeNames.length;
+		//
+		// if (throwsIdx != numExceptions) {
+		// throw new IllegalStateException(
+		// "The number of exceptions in getExceptionTypeNames() didn't match the number of exceptions in the generic
+		// signature"); //$NON-NLS-1$
+		// }
+
 		Object defaultValue = next.getDefaultValue();
 		if (defaultValue != null) {
 			method.setDefaultValue(createConstantFromMixedType(defaultValue));
@@ -331,6 +341,10 @@ public class ClassFileToIndexConverter {
 		ITypeAnnotationWalker annotationWalker = getTypeAnnotationWalker(nextField.getTypeAnnotations());
 		variable.setType(createTypeSignature(annotationWalker, nextTypeSignature));
 		variable.setTagBits(nextField.getTagBits());
+
+		// char[] fieldDescriptor = nextField.getTypeName();
+		// // DO NOT SUBMIT:
+		// IBinaryField bf = IndexBinaryType.createBinaryField(variable);
 	}
 
 	/**
@@ -357,6 +371,7 @@ public class ClassFileToIndexConverter {
 			if (colonPos > wrapper.start) {
 				char[] identifier = CharOperation.subarray(genericSignature, wrapper.start, colonPos);
 				parameter = new NdTypeParameter(type, identifier);
+				parameter.setFirstBoundIsClass(true);
 				wrapper.start = colonPos + 1;
 				parameterIndex++;
 				boundIndex = 0;
@@ -365,6 +380,7 @@ public class ClassFileToIndexConverter {
 			// Class files insert an empty bound if there is an interface bound but no class bound. We just omit
 			// the bound entirely.
 			while (genericSignature[wrapper.start] == ':') {
+				parameter.setFirstBoundIsClass(false);
 				wrapper.start++;
 			}
 
@@ -405,6 +421,7 @@ public class ClassFileToIndexConverter {
 				// Skip the 'T' prefix
 				wrapper.start++;
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
+				typeSignature.setRawType(createTypeIdFromFieldDescriptor(JAVA_LANG_OBJECT_FIELD_DESCRIPTOR));
 				typeSignature.setVariableIdentifier(wrapper.nextWord());
 				attachAnnotations(typeSignature, annotations);
 				// Skip the trailing semicolon
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
index 3ffc874..50cbdfa 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/GenericSignatures.java
@@ -15,14 +15,20 @@ public class GenericSignatures {
 
 	public static SignatureWrapper getGenericSignature(IBinaryMethod next) {
 		char[] signature = next.getGenericSignature();
+		char[][] exceptionTypeNames = next.getExceptionTypeNames();
 		if (signature == null) {
-			char[][] exceptionTypeNames = next.getExceptionTypeNames();
-			if (exceptionTypeNames == null) {
-				// If there are no exception types then the method descriptor will work as a generic signature
-				signature = next.getMethodDescriptor();
-			} else {
+			signature = next.getMethodDescriptor();
+		}
+
+		// The compiler is allowed to omit thrown exceptions from the generic signature
+		// if the thrown exceptions don't make use of generics or type variables. However, we rely
+		// on them so we reinsert the missing exception declarations if they're not present.
+		if (exceptionTypeNames != null && exceptionTypeNames.length > 0) {
+			// If there are no exceptions mentioned the signature but there are exceptions
+			// in the IBinaryMethod, the compiler has omitted them... so put them back.
+			if (CharArrayUtils.indexOf('^', signature) == -1) {
 				CharArrayBuffer builder = new CharArrayBuffer();
-				builder.append(next.getMethodDescriptor());
+				builder.append(signature);
 				for(char[] nextException : exceptionTypeNames) {
 					builder.append("^L"); //$NON-NLS-1$
 					builder.append(nextException);
@@ -31,6 +37,7 @@ public class GenericSignatures {
 				signature = builder.getContents();
 			}
 		}
+
 		return new SignatureWrapper(signature);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 41f59b5..7ab519e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -97,10 +97,8 @@ public class IndexTester {
 
 		compareAnnotations(expectedBinaryAnnotations, actualBinaryAnnotations);
 
-		if (expected.getGenericSignature() != null) {
-			assertEquals("The generic signature did not match", expected.getGenericSignature(), //$NON-NLS-1$
+		compareGenericSignatures("The generic signature did not match", expected.getGenericSignature(), //$NON-NLS-1$
 					actual.getGenericSignature());
-		}
 
 		assertEquals("The enclosing method name did not match", expected.getEnclosingMethod(), //$NON-NLS-1$
 				actual.getEnclosingMethod());
@@ -286,6 +284,22 @@ public class IndexTester {
 			}
 		}
 
+		if (o1 instanceof Object[]) {
+			Object[] a1 = (Object[]) o1;
+			Object[] a2 = (Object[]) o2;
+
+			if (a1.length != a2.length) {
+				return false;
+			}
+
+			for (int idx = 0; idx < a1.length; idx++) {
+				if (!isEqual(a1[idx], a2[idx])) {
+					return false;
+				}
+			}
+			return true;
+		}
+
 		return Objects.equals(o1, o2);
 	}
 
@@ -304,10 +318,8 @@ public class IndexTester {
 		assertEquals("The exception type names did not match.", expectedMethod.getExceptionTypeNames(), //$NON-NLS-1$
 				actualMethod.getExceptionTypeNames());
 
-		if (expectedMethod.getGenericSignature() != null) {
-			assertEquals("The method's generic signature did not match", expectedMethod.getGenericSignature(), //$NON-NLS-1$
-					actualMethod.getGenericSignature());
-		}
+		compareGenericSignatures("The method's generic signature did not match", expectedMethod.getGenericSignature(), //$NON-NLS-1$
+				actualMethod.getGenericSignature());
 
 		assertEquals("The method descriptors did not match.", expectedMethod.getMethodDescriptor(), //$NON-NLS-1$
 				actualMethod.getMethodDescriptor());
@@ -325,6 +337,27 @@ public class IndexTester {
 		compareTypeAnnotations(expectedMethod.getTypeAnnotations(), actualMethod.getTypeAnnotations());
 	}
 
+	/**
+	 * The index always provides complete generic signatures whereas some or all of the generic signature is optional
+	 * for class files, so the generic signatures are expected to differ in certain situations.
+	 */
+	private static void compareGenericSignatures(String message, char[] expected, char[] actual) {
+		// If the whole generic signature was omitted by the compiler, there's nothing to compare
+		if (expected == null) {
+			return;
+		}
+
+		// If the expected value was missing the optional section for exceptions then it only needs to match
+		// a prefix of the actual signature
+		if (CharArrayUtils.indexOf('^', expected) == -1 && actual.length > expected.length) {
+			if (CharArrayUtils.equals(expected, CharArrayUtils.subarray(actual, 0, expected.length))) {
+				return;
+			}
+		}
+
+		assertEquals(message, expected, actual);
+	}
+
 	private static void compareTypeAnnotations(IBinaryTypeAnnotation[] expectedTypeAnnotations,
 			IBinaryTypeAnnotation[] actualTypeAnnotations) {
 		Set<TypeAnnotationWrapper> expectedAnnotations = new HashSet<>();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index 151da2a..d96bd71 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -127,6 +127,7 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 		if (isTypeVariable()) {
 			result.append('T');
 			result.append(getVariableIdentifier().getChars());
+			result.append(';');
 			return;
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
index 4b41ef4..8c786c6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeParameter.java
@@ -4,6 +4,7 @@ import java.util.List;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
+import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -19,6 +20,9 @@ public class NdTypeParameter extends NdNode {
 	public static final FieldManyToOne<NdBinding> PARENT;
 	public static final FieldString IDENTIFIER;
 	public static final FieldOneToMany<NdTypeBound> BOUNDS;
+	public static final FieldByte TYPE_PARAMETER_FLAGS;
+
+	public static final byte FLG_FIRST_BOUND_IS_A_CLASS = 0x01;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdTypeParameter> type;
@@ -28,6 +32,7 @@ public class NdTypeParameter extends NdNode {
 		PARENT = FieldManyToOne.createOwner(type, NdBinding.TYPE_PARAMETERS);
 		IDENTIFIER = type.addString();
 		BOUNDS = FieldOneToMany.create(type, NdTypeBound.PARENT);
+		TYPE_PARAMETER_FLAGS = type.addByte();
 
 		type.done();
 	}
@@ -47,6 +52,25 @@ public class NdTypeParameter extends NdNode {
 		return IDENTIFIER.get(getNd(), this.address).getChars();
 	}
 
+	public void setFirstBoundIsClass(boolean isClass) {
+		setFlag(FLG_FIRST_BOUND_IS_A_CLASS, isClass);
+	}
+
+	public boolean isFirstBoundAClass() {
+		return (TYPE_PARAMETER_FLAGS.get(getNd(), this.address) & FLG_FIRST_BOUND_IS_A_CLASS) != 0;
+	}
+
+	private void setFlag(byte flag, boolean value) {
+		byte oldValue = TYPE_PARAMETER_FLAGS.get(getNd(), this.address);
+		byte newValue;
+		if (value) {
+			newValue = (byte) (oldValue | flag);
+		} else {
+			newValue = (byte) (oldValue & ~flag);
+		}
+		TYPE_PARAMETER_FLAGS.put(getNd(), this.address, newValue);
+	}
+
 	public List<NdTypeBound> getBounds() {
 		return BOUNDS.asList(getNd(), this.address);
 	}
@@ -54,7 +78,15 @@ public class NdTypeParameter extends NdNode {
 	public void getSignature(CharArrayBuffer result) {
 		result.append(getIdentifier());
 
-		for (NdTypeBound next : getBounds()) {
+		List<NdTypeBound> bounds = getBounds();
+
+		// If none of the bounds are classes and there is at least one bound, then insert a double-colon
+		// in the type signature.
+		if (!bounds.isEmpty() && !isFirstBoundAClass()) {
+			result.append(':');
+		}
+
+		for (NdTypeBound next : bounds) {
 			next.getSignature(result);
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index d242cde..775a861 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -436,7 +436,7 @@ public class IndexBinaryType implements IBinaryType {
 		List<NdMethodParameter> args = ndMethod.getMethodParameters();
 		for (int argIdx = 0; argIdx < args.size(); argIdx++) {
 			buildAnnotations(typeAnnotations, annotationBuilder.toMethodParameter((short) argIdx),
-					args.get(argIdx).getAnnotations());
+					args.get(argIdx).getType().getAnnotations());
 		}
 
 		buildAnnotations(typeAnnotations, annotationBuilder.toMethodReturn(), ndMethod.getReturnType());
commit 5ea673db0a29742bf4872c157a9457147472b2c2
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 11 20:09:27 2016 -0800

    Bug 481796 - More bugfixes
    
    Change-Id: Ic6a4b84c8ea71737e3c4552825a323bb1aec744f
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

98	30	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
13	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
15	11	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
7	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
5	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
13	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 64eb8ae..960acd8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.Openable;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.NdAnnotation;
@@ -158,7 +159,15 @@ public class ClassFileToIndexConverter {
 		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));
 
 		readTypeParameters(type, typeAnnotations, signatureWrapper);
-		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper));
+
+		char[] superclassFieldDescriptor;
+		char[] superclassBinaryName = binaryType.getSuperclassName();
+		if (superclassBinaryName == null) {
+			superclassFieldDescriptor = JAVA_LANG_OBJECT_FIELD_DESCRIPTOR;
+		} else {
+			superclassFieldDescriptor = JavaNames.binaryNameToFieldDescriptor(superclassBinaryName);
+		}
+		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper, superclassFieldDescriptor));
 
 		short interfaceIdx = 0;
 		while (signatureWrapper.start < signatureWrapper.signature.length) {
@@ -168,7 +177,8 @@ public class ClassFileToIndexConverter {
 			// interfaces list.
 			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
 			new NdTypeInterface(getNd(), type,
-					createTypeSignature(typeAnnotations.toSupertype(interfaceIdx, interfaceSpec), signatureWrapper));
+					createTypeSignature(typeAnnotations.toSupertype(interfaceIdx, interfaceSpec), signatureWrapper,
+							JavaNames.binaryNameToFieldDescriptor(interfaceSpec)));
 			interfaceIdx++;
 		}
 
@@ -259,11 +269,11 @@ public class ClassFileToIndexConverter {
 
 		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(next.getTypeAnnotations());
 		SignatureWrapper signature = GenericSignatures.getGenericSignature(next);
+		SignatureWrapper descriptor = new SignatureWrapper(next.getMethodDescriptor());
 		readTypeParameters(method, typeAnnotations, signature);
 
-		if (signature.charAtStart() == '(') {
-			signature.start++;
-		}
+		skipChar(signature, '(');
+		skipChar(descriptor, '(');
 
 		int annotatedParametersCount = next.getAnnotatedParametersCount();
 		char[][] parameterNames = next.getArgumentNames();
@@ -273,8 +283,9 @@ public class ClassFileToIndexConverter {
 				signature.start++;
 				break;
 			}
-			NdMethodParameter parameter = new NdMethodParameter(method,
-					createTypeSignature(typeAnnotations.toMethodParameter(parameterIdx), signature));
+			char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
+			NdMethodParameter parameter = new NdMethodParameter(method, createTypeSignature(
+					typeAnnotations.toMethodParameter(parameterIdx), signature, nextFieldDescriptor));
 
 			if (parameterIdx < annotatedParametersCount) {
 				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(parameterIdx, binaryTypeName);
@@ -291,12 +302,16 @@ public class ClassFileToIndexConverter {
 			parameterIdx++;
 		}
 
-		method.setReturnType(createTypeSignature(typeAnnotations.toMethodReturn(), signature));
+		skipChar(descriptor, ')');
+		char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
+		method.setReturnType(createTypeSignature(typeAnnotations.toMethodReturn(), signature, nextFieldDescriptor));
 
+		char[][] exceptionTypes = next.getExceptionTypeNames();
 		int throwsIdx = 0;
 		while (!signature.atEnd() && signature.charAtStart() == '^') {
 			signature.start++;
-			new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature));
+			new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature,
+					JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx])));
 			throwsIdx++;
 		}
 
@@ -319,6 +334,12 @@ public class ClassFileToIndexConverter {
 		method.setTagBits(next.getTagBits());
 	}
 
+	private void skipChar(SignatureWrapper signature, char toSkip) {
+		if (signature.charAtStart() == toSkip) {
+			signature.start++;
+		}
+	}
+
 	/**
 	 * Adds the given field to the given type
 	 */
@@ -339,7 +360,7 @@ public class ClassFileToIndexConverter {
 		SignatureWrapper nextTypeSignature = GenericSignatures.getGenericSignatureFor(nextField);
 
 		ITypeAnnotationWalker annotationWalker = getTypeAnnotationWalker(nextField.getTypeAnnotations());
-		variable.setType(createTypeSignature(annotationWalker, nextTypeSignature));
+		variable.setType(createTypeSignature(annotationWalker, nextTypeSignature, nextField.getTypeName()));
 		variable.setTagBits(nextField.getTagBits());
 
 		// char[] fieldDescriptor = nextField.getTypeName();
@@ -385,7 +406,8 @@ public class ClassFileToIndexConverter {
 			}
 
 			NdTypeSignature boundSignature = createTypeSignature(
-					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short) boundIndex), wrapper);
+					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short) boundIndex), wrapper,
+					JAVA_LANG_OBJECT_FIELD_DESCRIPTOR);
 
 			new NdTypeBound(parameter, boundSignature);
 			boundIndex++;
@@ -396,6 +418,50 @@ public class ClassFileToIndexConverter {
 		}
 	}
 
+	private char[] readNextFieldDescriptor(SignatureWrapper genericSignature) {
+		int endPosition = findEndOfFieldDescriptor(genericSignature);
+
+		char[] result = CharArrayUtils.subarray(genericSignature.signature, genericSignature.start, endPosition);
+		genericSignature.start = endPosition;
+		return result;
+	}
+
+	private int findEndOfFieldDescriptor(SignatureWrapper genericSignature) {
+		char[] signature = genericSignature.signature;
+
+		if (signature == null || signature.length == 0) {
+			return genericSignature.start;
+		}
+		int current = genericSignature.start;
+		while (current < signature.length) {
+			char firstChar = signature[current];
+			switch (firstChar) {
+				case 'L':
+				case 'T': {
+					return CharArrayUtils.indexOf(';', signature, current, signature.length) + 1;
+				}
+				case '[': {
+					current++;
+					break;
+				}
+				case 'V':
+				case 'B':
+				case 'C':
+				case 'D':
+				case 'F':
+				case 'I':
+				case 'J':
+				case 'S':
+				case 'Z':
+					return current + 1;
+				default:
+					throw new IndexException(Package.createStatus("Field descriptor starts with unknown character: " //$NON-NLS-1$
+							+ genericSignature.toString()));
+			}
+		}
+		return current;
+	}
+
 	/**
 	 * Reads a type signature from the given {@link SignatureWrapper}, starting at the character pointed to by
 	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature. Returns
@@ -403,39 +469,41 @@ public class ClassFileToIndexConverter {
 	 *
 	 * @param annotations
 	 *            the type annotations for this type
-	 * @param wrapper
+	 * @param genericSignature
 	 *            the generic signature to parse
 	 * @throws CoreException
 	 */
-	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper wrapper)
+	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper genericSignature,
+			char[] fieldDescriptorIfVariable)
 			throws CoreException {
-		char[] genericSignature = wrapper.signature;
+		char[] signature = genericSignature.signature;
 
-		if (genericSignature == null || genericSignature.length == 0) {
+		if (signature == null || signature.length == 0) {
 			return null;
 		}
 
-		char firstChar = genericSignature[wrapper.start];
+		char firstChar = signature[genericSignature.start];
 		switch (firstChar) {
 			case 'T': {
 				// Skip the 'T' prefix
-				wrapper.start++;
+				genericSignature.start++;
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
-				typeSignature.setRawType(createTypeIdFromFieldDescriptor(JAVA_LANG_OBJECT_FIELD_DESCRIPTOR));
-				typeSignature.setVariableIdentifier(wrapper.nextWord());
+				typeSignature.setRawType(createTypeIdFromFieldDescriptor(fieldDescriptorIfVariable));
+				typeSignature.setVariableIdentifier(genericSignature.nextWord());
 				attachAnnotations(typeSignature, annotations);
 				// Skip the trailing semicolon
-				wrapper.start++;
+				genericSignature.start++;
 				return typeSignature;
 			}
 			case '[': {
 				// Skip the '[' prefix
-				wrapper.start++;
+				genericSignature.start++;
 				// Determine the array argument type
-				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), wrapper);
-				char[] fieldDescriptor = CharArrayUtils.concat(ARRAY_FIELD_DESCRIPTOR_PREFIX,
+				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), genericSignature,
+						CharArrayUtils.substring(fieldDescriptorIfVariable, 1));
+				char[] computedFieldDescriptor = CharArrayUtils.concat(ARRAY_FIELD_DESCRIPTOR_PREFIX,
 						elementType.getRawType().getFieldDescriptor().getChars());
-				NdTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
+				NdTypeId rawType = createTypeIdFromFieldDescriptor(computedFieldDescriptor);
 				// We encode signatures as though they were a one-argument generic type whose element
 				// type is the generic argument.
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
@@ -446,7 +514,7 @@ public class ClassFileToIndexConverter {
 				return typeSignature;
 			}
 			case 'V':
-				wrapper.start++;
+				genericSignature.start++;
 				return null;
 			case 'B':
 			case 'C':
@@ -456,18 +524,18 @@ public class ClassFileToIndexConverter {
 			case 'J':
 			case 'S':
 			case 'Z':
-				wrapper.start++;
+				genericSignature.start++;
 				return createTypeIdFromFieldDescriptor(new char[] { firstChar });
 			case 'L':
-				return parseClassTypeSignature(null, annotations, wrapper);
+				return parseClassTypeSignature(null, annotations, genericSignature);
 			case '+':
 			case '-':
 			case '*':
 				throw new CoreException(Package.createStatus("Unexpected wildcard in top-level of generic signature: " //$NON-NLS-1$
-						+ wrapper.toString()));
+						+ genericSignature.toString()));
 			default:
 				throw new CoreException(Package.createStatus("Generic signature starts with unknown character: " //$NON-NLS-1$
-						+ wrapper.toString()));
+						+ genericSignature.toString()));
 		}
 	}
 
@@ -531,7 +599,7 @@ public class ClassFileToIndexConverter {
 					}
 
 					NdTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex),
-							wrapper);
+							wrapper, JAVA_LANG_OBJECT_FIELD_DESCRIPTOR);
 					typeArgument.setType(nextSignature);
 					argumentIndex++;
 				}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 7ab519e..443446a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -304,9 +304,6 @@ public class IndexTester {
 	}
 
 	private static void compareMethods(IBinaryMethod expectedMethod, IBinaryMethod actualMethod) {
-		assertEquals("The annotated parameter count didn't match", expectedMethod.getAnnotatedParametersCount(), //$NON-NLS-1$
-				actualMethod.getAnnotatedParametersCount());
-
 		compareAnnotations(expectedMethod.getAnnotations(), actualMethod.getAnnotations());
 
 		assertEquals("The argument names didn't match.", expectedMethod.getArgumentNames(), //$NON-NLS-1$
@@ -325,11 +322,19 @@ public class IndexTester {
 				actualMethod.getMethodDescriptor());
 		assertEquals("The modifiers didn't match.", expectedMethod.getModifiers(), actualMethod.getModifiers()); //$NON-NLS-1$
 
-		for (int idx = 0; idx < actualMethod.getAnnotatedParametersCount(); idx++) {
-			char[] classFileName = "".toCharArray(); //$NON-NLS-1$
+		char[] classFileName = "".toCharArray(); //$NON-NLS-1$
+		int minAnnotatedParameters = Math.min(expectedMethod.getAnnotatedParametersCount(),
+				actualMethod.getAnnotatedParametersCount());
+		for (int idx = 0; idx < minAnnotatedParameters; idx++) {
 			compareAnnotations(expectedMethod.getParameterAnnotations(idx, classFileName),
 					actualMethod.getParameterAnnotations(idx, classFileName));
 		}
+		for (int idx = minAnnotatedParameters; idx < expectedMethod.getAnnotatedParametersCount(); idx++) {
+			compareAnnotations(expectedMethod.getParameterAnnotations(idx, classFileName), new IBinaryAnnotation[0]);
+		}
+		for (int idx = minAnnotatedParameters; idx < actualMethod.getAnnotatedParametersCount(); idx++) {
+			compareAnnotations(new IBinaryAnnotation[0], expectedMethod.getParameterAnnotations(idx, classFileName));
+		}
 
 		assertEquals("The selectors did not match", expectedMethod.getSelector(), actualMethod.getSelector()); //$NON-NLS-1$
 		assertEquals("The tag bits did not match", expectedMethod.getTagBits(), actualMethod.getTagBits()); //$NON-NLS-1$
@@ -392,8 +397,8 @@ public class IndexTester {
 
 	private static void compareAnnotations(IBinaryAnnotation[] expectedBinaryAnnotations,
 			IBinaryAnnotation[] actualBinaryAnnotations) {
-		if (expectedBinaryAnnotations == null) {
-			if (actualBinaryAnnotations != null) {
+		if (expectedBinaryAnnotations == null || expectedBinaryAnnotations.length == 0) {
+			if (actualBinaryAnnotations != null && actualBinaryAnnotations.length != 0) {
 				throw new IllegalStateException("Expected null for the binary annotations"); //$NON-NLS-1$
 			} else {
 				return;
@@ -416,10 +421,8 @@ public class IndexTester {
 	private static void compareFields(IBinaryField field1, IBinaryField field2) {
 		compareAnnotations(field1.getAnnotations(), field2.getAnnotations());
 		assertEquals("Constants not equal", field1.getConstant(), field2.getConstant()); //$NON-NLS-1$
-		if (field1.getGenericSignature() != null) {
-			assertEquals("The generic signature did not match", field1.getGenericSignature(), //$NON-NLS-1$
+		compareGenericSignatures("The generic signature did not match", field1.getGenericSignature(), //$NON-NLS-1$
 					field2.getGenericSignature());
-		}
 		assertEquals("The modifiers did not match", field1.getModifiers(), field2.getModifiers()); //$NON-NLS-1$
 		assertEquals("The tag bits did not match", field1.getTagBits(), field2.getTagBits()); //$NON-NLS-1$
 		assertEquals("The names did not match", field1.getName(), field2.getName()); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index d96bd71..5fe111e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -115,19 +115,15 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 	}
 
 	@Override
-	public void getSignature(CharArrayBuffer result) {
+	public void getSignature(CharArrayBuffer result, boolean includeTrailingSemicolon) {
 		NdComplexTypeSignature parentSignature = getGenericDeclaringType();
 
-		if (parentSignature != null) {
-			parentSignature.getSignature(result);
-			result.append('.');
-			return;
-		}
-
 		if (isTypeVariable()) {
 			result.append('T');
 			result.append(getVariableIdentifier().getChars());
-			result.append(';');
+			if (includeTrailingSemicolon) {
+				result.append(';');
+			}
 			return;
 		}
 
@@ -137,8 +133,14 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			arrayDimension.getSignature(result);
 			return;
 		}
-
-		result.append(getRawType().getFieldDescriptorWithoutTrailingSemicolon());
+		if (parentSignature != null) {
+			parentSignature.getSignature(result, false);
+			result.append('.');
+			char[] simpleName = getRawType().getSimpleName().getChars();
+			result.append(simpleName);
+		} else {
+			result.append(getRawType().getFieldDescriptorWithoutTrailingSemicolon());
+		}
 
 		List<NdTypeArgument> arguments = getTypeArguments();
 		if (!arguments.isEmpty()) {
@@ -148,7 +150,9 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			}
 			result.append('>');
 		}
-		result.append(';');
+		if (includeTrailingSemicolon) {
+			result.append(';');
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 2e425af..c662c9c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -44,7 +44,7 @@ public class NdTypeId extends NdTypeSignature {
 	public NdTypeId(Nd pdom, char[] fieldDescriptor) {
 		super(pdom);
 
-		char[] simpleName = JavaNames.fieldDescriptorToJavaName(fieldDescriptor, true);
+		char[] simpleName = JavaNames.fieldDescriptorToJavaName(fieldDescriptor, false);
 		FIELD_DESCRIPTOR.put(pdom, this.address, fieldDescriptor);
 		SIMPLE_NAME.put(pdom, this.address, simpleName);
 	}
@@ -132,8 +132,12 @@ public class NdTypeId extends NdTypeSignature {
 	}
 
 	@Override
-	public void getSignature(CharArrayBuffer result) {
-		result.append(getFieldDescriptor().getChars());
+	public void getSignature(CharArrayBuffer result, boolean includeTrailingSemicolon) {
+		if (includeTrailingSemicolon) {
+			result.append(getFieldDescriptor().getChars());
+		} else {
+			result.append(getFieldDescriptorWithoutTrailingSemicolon());
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index 0ba0595..5736502 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -110,7 +110,11 @@ public abstract class NdTypeSignature extends NdNode {
 	 */
 	public abstract List<NdAnnotation> getAnnotations();
 
-	public abstract void getSignature(CharArrayBuffer result);
+	public final void getSignature(CharArrayBuffer result) {
+		getSignature(result, true);
+	}
+
+	public abstract void getSignature(CharArrayBuffer result, boolean includeTrailingSemicolon);
 
 	/**
 	 * Returns true iff this is an array type signature (ie: that getArrayDimensionType() will return a non-null
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 775a861..029bec1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -497,19 +497,19 @@ public class IndexBinaryType implements IBinaryType {
 			result[idx] = toAnnotationArray(next.getAnnotations());
 		}
 
-		int newLength = result.length;
-		while (newLength > 0 && result[newLength - 1] == null) {
-			--newLength;
-		}
-
-		if (newLength < result.length) {
-			if (newLength == 0) {
-				return null;
-			}
-			IBinaryAnnotation[][] newResult = new IBinaryAnnotation[newLength][];
-			System.arraycopy(result, 0, newResult, 0, newLength);
-			result = newResult;
-		}
+		// int newLength = result.length;
+		// while (newLength > 0 && result[newLength - 1] == null) {
+		// --newLength;
+		// }
+		//
+		// if (newLength < result.length) {
+		// if (newLength == 0) {
+		// return null;
+		// }
+		// IBinaryAnnotation[][] newResult = new IBinaryAnnotation[newLength][];
+		// System.arraycopy(result, 0, newResult, 0, newLength);
+		// result = newResult;
+		// }
 
 		return result;
 	}
commit ea5ad20452e64479476cc505b1b9a26ac1e4a45a
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 16 08:24:34 2016 -0800

    Bug 481796 - Fix encoding of field descriptors for inner classes
    
    Change-Id: Id3497a538b85e0ab40e0fe7336eccadbd8f2c807
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

8	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 960acd8..858d8b1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -335,7 +335,7 @@ public class ClassFileToIndexConverter {
 	}
 
 	private void skipChar(SignatureWrapper signature, char toSkip) {
-		if (signature.charAtStart() == toSkip) {
+		if (signature.start < signature.signature.length && signature.charAtStart() == toSkip) {
 			signature.start++;
 		}
 	}
@@ -550,7 +550,8 @@ public class ClassFileToIndexConverter {
 		char[] fieldDescriptor;
 
 		if (parentTypeOrNull != null) {
-			fieldDescriptor = CharArrayUtils.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
+			fieldDescriptor = CharArrayUtils.concat(
+					parentTypeOrNull.getRawType().getFieldDescriptorWithoutTrailingSemicolon(),
 					INNER_TYPE_SEPARATOR, identifier, FIELD_DESCRIPTOR_SUFFIX);
 		} else {
 			fieldDescriptor = CharArrayUtils.concat(identifier, FIELD_DESCRIPTOR_SUFFIX);
@@ -604,8 +605,7 @@ public class ClassFileToIndexConverter {
 					argumentIndex++;
 				}
 
-				// Skip over the trailing '>'
-				wrapper.start++;
+				skipChar(wrapper, '>');
 			}
 			result = typeSignature;
 
@@ -617,12 +617,14 @@ public class ClassFileToIndexConverter {
 				// Don't check for a semicolon if we hit this branch since the recursive call to parseClassTypeSignature
 				// will do this
 				checkForSemicolon = false;
+				// Identifiers shouldn't start with '.'
+				skipChar(wrapper, '.');
 				result = parseClassTypeSignature(typeSignature, annotations.toNextNestedType(), wrapper);
 			}
 		}
 
-		if (checkForSemicolon && wrapper.start < genericSignature.length && genericSignature[wrapper.start] == ';') {
-			wrapper.start++;
+		if (checkForSemicolon) {
+			skipChar(wrapper, ';');
 		}
 
 		return result;
commit 722b6037ea46737ddc37af11cf4c1c02fee844a4
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 16 08:51:02 2016 -0800

    Bug 481796 - Fix encoding of generic signatures for inner classes
    
    Problem case: generic class that contains a nongeneric class that contains
    another inner class. The signature for the innermost class was being
    computed incorrectly.
    
    Change-Id: Id3497a538b85e0ab40e0fe7336eccadbd8f2c807
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 858d8b1..b46e25e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -546,7 +546,7 @@ public class ClassFileToIndexConverter {
 	 */
 	private NdTypeSignature parseClassTypeSignature(NdComplexTypeSignature parentTypeOrNull,
 			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
-		char[] identifier = wrapper.nextName();
+		char[] identifier = wrapper.nextWord();
 		char[] fieldDescriptor;
 
 		if (parentTypeOrNull != null) {
commit dd821046d14ab9026bdbd6afe5cd2f8cbb93ed5f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 16 18:28:02 2016 -0800

    Bug 481796 - Add support for compiler-defined method arguments
    
    Add support for method arguments that are used by the VM but don't appear
    in the source code or generic signatures.
    
    Change-Id: Iabdba2874943c6c6c645edfc70d8c6e94052577a
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

42	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
23	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index b46e25e..696653b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -5,6 +5,8 @@ import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.dom.Modifier;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
@@ -199,7 +201,7 @@ public class ClassFileToIndexConverter {
 
 		if (methods != null) {
 			for (IBinaryMethod next : methods) {
-				addMethod(type, next, binaryName);
+				addMethod(type, next, binaryType, binaryName);
 			}
 		}
 
@@ -262,7 +264,8 @@ public class ClassFileToIndexConverter {
 	 *
 	 * @throws CoreException
 	 */
-	private void addMethod(NdType type, IBinaryMethod next, char[] binaryTypeName) throws CoreException {
+	private void addMethod(NdType type, IBinaryMethod next, IBinaryType binaryType, char[] binaryTypeName)
+			throws CoreException {
 		NdMethod method = new NdMethod(type);
 
 		attachAnnotations(method, next.getAnnotations());
@@ -275,20 +278,46 @@ public class ClassFileToIndexConverter {
 		skipChar(signature, '(');
 		skipChar(descriptor, '(');
 
+		int numCompilerDefinedParameters = 0;
+		if (next.isConstructor()) {
+			if ((binaryType.isLocal() || binaryType.isMember()) && (binaryType.getModifiers() & Modifier.STATIC) == 0) {
+				numCompilerDefinedParameters = 1;
+			}
+			if ((binaryType.getModifiers() & ClassFileConstants.AccEnum) != 0) {
+				numCompilerDefinedParameters = 2;
+			}
+		}
+
+		boolean compilerDefinedParametersAreIncludedInSignature = (next.getGenericSignature() == null);
+
 		int annotatedParametersCount = next.getAnnotatedParametersCount();
 		char[][] parameterNames = next.getArgumentNames();
-		short parameterIdx = 0;
-		while (!signature.atEnd()) {
-			if (signature.charAtStart() == ')') {
-				signature.start++;
+		short descriptorParameterIdx = 0;
+		while (!descriptor.atEnd()) {
+			if (descriptor.charAtStart() == ')') {
+				skipChar(descriptor, ')');
+				skipChar(signature, ')');
 				break;
 			}
 			char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
-			NdMethodParameter parameter = new NdMethodParameter(method, createTypeSignature(
-					typeAnnotations.toMethodParameter(parameterIdx), signature, nextFieldDescriptor));
+			/**
+			 * True iff this a parameter which is part of the field descriptor but not the generic signature -- that is,
+			 * it is a compiler-defined parameter.
+			 */
+			boolean isCompilerDefined = descriptorParameterIdx < numCompilerDefinedParameters;
+			SignatureWrapper nextFieldSignature = signature;
+			if (isCompilerDefined && !compilerDefinedParametersAreIncludedInSignature) {
+				nextFieldSignature = new SignatureWrapper(nextFieldDescriptor);
+			}
+			NdMethodParameter parameter = new NdMethodParameter(method,
+					createTypeSignature(typeAnnotations.toMethodParameter(descriptorParameterIdx), nextFieldSignature,
+							nextFieldDescriptor));
+
+			parameter.setCompilerDefined(isCompilerDefined);
 
-			if (parameterIdx < annotatedParametersCount) {
-				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(parameterIdx, binaryTypeName);
+			if (descriptorParameterIdx < annotatedParametersCount) {
+				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(descriptorParameterIdx,
+						binaryTypeName);
 
 				if (parameterAnnotations != null) {
 					for (IBinaryAnnotation nextAnnotation : parameterAnnotations) {
@@ -296,10 +325,10 @@ public class ClassFileToIndexConverter {
 					}
 				}
 			}
-			if (parameterNames != null && parameterNames.length > parameterIdx) {
-				parameter.setName(parameterNames[parameterIdx]);
+			if (parameterNames != null && parameterNames.length > descriptorParameterIdx) {
+				parameter.setName(parameterNames[descriptorParameterIdx]);
 			}
-			parameterIdx++;
+			descriptorParameterIdx++;
 		}
 
 		skipChar(descriptor, ')');
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
index 9f3e793..636b7ea 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
@@ -5,6 +5,7 @@ import java.util.List;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.db.IString;
+import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -15,6 +16,9 @@ public class NdMethodParameter extends NdNode {
 	public static final FieldManyToOne<NdTypeSignature> ARGUMENT_TYPE;
 	public static final FieldString NAME;
 	public static final FieldOneToMany<NdAnnotation> ANNOTATIONS;
+	public static final FieldByte FLAGS;
+
+	private static final byte FLG_COMPILER_DEFINED = 0x01;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<NdMethodParameter> type;
@@ -25,6 +29,7 @@ public class NdMethodParameter extends NdNode {
 		ARGUMENT_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_METHOD_ARGUMENT);
 		NAME = type.addString();
 		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotation.PARENT_METHOD_PARAMETER);
+		FLAGS = type.addByte();
 		type.done();
 	}
 
@@ -54,4 +59,22 @@ public class NdMethodParameter extends NdNode {
 	public List<NdAnnotation> getAnnotations() {
 		return ANNOTATIONS.asList(getNd(), this.address);
 	}
+
+	private void setFlag(byte flagConstant, boolean value) {
+		int oldFlags = FLAGS.get(getNd(), this.address);
+		int newFlags = ((oldFlags & ~flagConstant) | (value ? flagConstant : 0));
+		FLAGS.put(getNd(), this.address, (byte) newFlags);
+	}
+
+	private boolean getFlag(byte flagConstant) {
+		return (FLAGS.get(getNd(), this.address) & flagConstant) != 0;
+	}
+
+	public void setCompilerDefined(boolean isCompilerDefined) {
+		setFlag(FLG_COMPILER_DEFINED, isCompilerDefined);
+	}
+
+	public boolean isCompilerDefined() {
+		return getFlag(FLG_COMPILER_DEFINED);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 029bec1..dfa7f3b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -520,7 +520,10 @@ public class IndexBinaryType implements IBinaryType {
 
 		result.append('(');
 		for (NdMethodParameter next : method.getMethodParameters()) {
-			next.getType().getSignature(result);
+			// Compiler-defined arguments don't show up in the generic signature
+			if (!next.isCompilerDefined()) {
+				next.getType().getSignature(result);
+			}
 		}
 		result.append(')');
 		NdTypeSignature returnType = method.getReturnType();
commit ead55ea771f454b731f785f4b43e358e49e117cc
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 16 20:56:40 2016 -0800

    Bug 481796 - Fix a number of corner-cases in the indexer
    
    Change-Id: I1d6d5a1e5f9fb50ae3b7f4faf1a6f3f7f1fd16d9
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

101	32	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
22	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
8	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
10	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 696653b..281c831 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -1,12 +1,13 @@
 package org.eclipse.jdt.internal.core.nd.indexer;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.core.dom.Modifier;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
@@ -65,7 +66,7 @@ public class ClassFileToIndexConverter {
 	private static final boolean ENABLE_LOGGING = false;
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private static final char[] PATH_SEPARATOR = new char[]{'/'};
-	private static final boolean ENABLE_SELF_TEST = true;
+	private static final boolean ENABLE_SELF_TEST = false;
 	private static final char[] ARRAY_FIELD_DESCRIPTOR_PREFIX = new char[] { '[' };
 	private NdResourceFile resource;
 	private JavaIndex index;
@@ -201,7 +202,7 @@ public class ClassFileToIndexConverter {
 
 		if (methods != null) {
 			for (IBinaryMethod next : methods) {
-				addMethod(type, next, binaryType, binaryName);
+				addMethod(type, next, binaryType);
 			}
 		}
 
@@ -264,7 +265,7 @@ public class ClassFileToIndexConverter {
 	 *
 	 * @throws CoreException
 	 */
-	private void addMethod(NdType type, IBinaryMethod next, IBinaryType binaryType, char[] binaryTypeName)
+	private void addMethod(NdType type, IBinaryMethod next, IBinaryType binaryType)
 			throws CoreException {
 		NdMethod method = new NdMethod(type);
 
@@ -278,28 +279,31 @@ public class ClassFileToIndexConverter {
 		skipChar(signature, '(');
 		skipChar(descriptor, '(');
 
-		int numCompilerDefinedParameters = 0;
-		if (next.isConstructor()) {
-			if ((binaryType.isLocal() || binaryType.isMember()) && (binaryType.getModifiers() & Modifier.STATIC) == 0) {
-				numCompilerDefinedParameters = 1;
-			}
-			if ((binaryType.getModifiers() & ClassFileConstants.AccEnum) != 0) {
-				numCompilerDefinedParameters = 2;
+		List<char[]> parameterFieldDescriptors = new ArrayList<>();
+		while (!descriptor.atEnd()) {
+			if (descriptor.charAtStart() == ')') {
+				skipChar(descriptor, ')');
+				break;
 			}
+			parameterFieldDescriptors.add(readNextFieldDescriptor(descriptor));
 		}
 
+		int numArgumentsInGenericSignature = countMethodArguments(signature);
+		int numCompilerDefinedParameters = Math.max(0,
+				parameterFieldDescriptors.size() - numArgumentsInGenericSignature);
+
 		boolean compilerDefinedParametersAreIncludedInSignature = (next.getGenericSignature() == null);
 
 		int annotatedParametersCount = next.getAnnotatedParametersCount();
 		char[][] parameterNames = next.getArgumentNames();
 		short descriptorParameterIdx = 0;
-		while (!descriptor.atEnd()) {
-			if (descriptor.charAtStart() == ')') {
-				skipChar(descriptor, ')');
+		char[] binaryTypeName = binaryType.getName();
+		while (!signature.atEnd()) {
+			if (signature.charAtStart() == ')') {
 				skipChar(signature, ')');
 				break;
 			}
-			char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
+			char[] nextFieldDescriptor = parameterFieldDescriptors.get(descriptorParameterIdx);
 			/**
 			 * True iff this a parameter which is part of the field descriptor but not the generic signature -- that is,
 			 * it is a compiler-defined parameter.
@@ -358,7 +362,7 @@ public class ClassFileToIndexConverter {
 			method.setDefaultValue(createConstantFromMixedType(defaultValue));
 		}
 
-		method.setMethodId(createMethodId(binaryTypeName, next.getSelector(), next.getMethodDescriptor()));
+		method.setMethodId(createMethodId(binaryType.getName(), next.getSelector(), next.getMethodDescriptor()));
 		method.setModifiers(next.getModifiers());
 		method.setTagBits(next.getTagBits());
 	}
@@ -421,18 +425,14 @@ public class ClassFileToIndexConverter {
 			if (colonPos > wrapper.start) {
 				char[] identifier = CharOperation.subarray(genericSignature, wrapper.start, colonPos);
 				parameter = new NdTypeParameter(type, identifier);
-				parameter.setFirstBoundIsClass(true);
 				wrapper.start = colonPos + 1;
+				// The first bound is a class as long as it doesn't start with a double-colon
+				parameter.setFirstBoundIsClass(wrapper.charAtStart() != ':');
 				parameterIndex++;
 				boundIndex = 0;
 			}
 
-			// Class files insert an empty bound if there is an interface bound but no class bound. We just omit
-			// the bound entirely.
-			while (genericSignature[wrapper.start] == ':') {
-				parameter.setFirstBoundIsClass(false);
-				wrapper.start++;
-			}
+			skipChar(wrapper, ':');
 
 			NdTypeSignature boundSignature = createTypeSignature(
 					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short) boundIndex), wrapper,
@@ -442,9 +442,7 @@ public class ClassFileToIndexConverter {
 			boundIndex++;
 		}
 
-		if (genericSignature[wrapper.start] == '>') {
-			wrapper.start++;
-		}
+		skipChar(wrapper, '>');
 	}
 
 	private char[] readNextFieldDescriptor(SignatureWrapper genericSignature) {
@@ -492,6 +490,65 @@ public class ClassFileToIndexConverter {
 	}
 
 	/**
+	 * Given a generic signature which is positioned at the open brace for method arguments, this returns the number of
+	 * method arguments. The start position of the given signature is not modified.
+	 */
+	private int countMethodArguments(SignatureWrapper genericSignature) {
+		SignatureWrapper lookaheadSignature = new SignatureWrapper(genericSignature.signature);
+		lookaheadSignature.start = genericSignature.start;
+		skipChar(lookaheadSignature, '(');
+		int argumentCount = 0;
+		while (!lookaheadSignature.atEnd() && !(lookaheadSignature.charAtStart() == ')')) {
+			switch (lookaheadSignature.charAtStart()) {
+				case 'T': {
+					// Skip the 'T' prefix
+					lookaheadSignature.nextWord();
+					skipChar(lookaheadSignature, ';');
+					argumentCount++;
+					break;
+				}
+				case '[': {
+					// Skip the '[' prefix
+					lookaheadSignature.start++;
+					break;
+				}
+				case 'V':
+				case 'B':
+				case 'C':
+				case 'D':
+				case 'F':
+				case 'I':
+				case 'J':
+				case 'S':
+				case 'Z':
+					argumentCount++;
+					lookaheadSignature.start++;
+					break;
+				case 'L':
+					for (;;) {
+						lookaheadSignature.nextWord();
+						lookaheadSignature.start = lookaheadSignature.skipAngleContents(lookaheadSignature.start);
+						char nextChar = lookaheadSignature.charAtStart();
+						if (nextChar == ';') {
+							break;
+						}
+						if (nextChar != '.') {
+							throw new IllegalStateException(
+									"Unknown char in generic signature " + lookaheadSignature.toString()); //$NON-NLS-1$
+						}
+					}
+					skipChar(lookaheadSignature, ';');
+					argumentCount++;
+					break;
+				default:
+					throw new IllegalStateException("Generic signature starts with unknown character: " //$NON-NLS-1$
+							+ lookaheadSignature.toString());
+			}
+		}
+		return argumentCount;
+	}
+
+	/**
 	 * Reads a type signature from the given {@link SignatureWrapper}, starting at the character pointed to by
 	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature. Returns
 	 * null if given an empty signature or the signature for the void type.
@@ -500,6 +557,9 @@ public class ClassFileToIndexConverter {
 	 *            the type annotations for this type
 	 * @param genericSignature
 	 *            the generic signature to parse
+	 * @param fieldDescriptorIfVariable
+	 *            the field descriptor to use if the type is a type variable -- or null if unknown (the field descriptor
+	 *            for java.lang.Object will be used)
 	 * @throws CoreException
 	 */
 	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper genericSignature,
@@ -511,25 +571,34 @@ public class ClassFileToIndexConverter {
 			return null;
 		}
 
-		char firstChar = signature[genericSignature.start];
+		char firstChar = genericSignature.charAtStart();
 		switch (firstChar) {
 			case 'T': {
 				// Skip the 'T' prefix
 				genericSignature.start++;
 				NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
-				typeSignature.setRawType(createTypeIdFromFieldDescriptor(fieldDescriptorIfVariable));
+				char[] fieldDescriptor = fieldDescriptorIfVariable;
+				if (fieldDescriptor == null) {
+					fieldDescriptor = JAVA_LANG_OBJECT_FIELD_DESCRIPTOR;
+				}
+				typeSignature.setRawType(createTypeIdFromFieldDescriptor(fieldDescriptor));
 				typeSignature.setVariableIdentifier(genericSignature.nextWord());
 				attachAnnotations(typeSignature, annotations);
 				// Skip the trailing semicolon
-				genericSignature.start++;
+				skipChar(genericSignature, ';');
 				return typeSignature;
 			}
 			case '[': {
 				// Skip the '[' prefix
 				genericSignature.start++;
+				char[] nestedFieldDescriptor = null;
+				if (fieldDescriptorIfVariable != null && fieldDescriptorIfVariable.length > 0
+						&& fieldDescriptorIfVariable[0] == '[') {
+					nestedFieldDescriptor = CharArrayUtils.substring(fieldDescriptorIfVariable, 1);
+				}
 				// Determine the array argument type
 				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), genericSignature,
-						CharArrayUtils.substring(fieldDescriptorIfVariable, 1));
+						nestedFieldDescriptor);
 				char[] computedFieldDescriptor = CharArrayUtils.concat(ARRAY_FIELD_DESCRIPTOR_PREFIX,
 						elementType.getRawType().getFieldDescriptor().getChars());
 				NdTypeId rawType = createTypeIdFromFieldDescriptor(computedFieldDescriptor);
@@ -629,7 +698,7 @@ public class ClassFileToIndexConverter {
 					}
 
 					NdTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex),
-							wrapper, JAVA_LANG_OBJECT_FIELD_DESCRIPTOR);
+							wrapper, null);
 					typeArgument.setType(nextSignature);
 					argumentIndex++;
 				}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 443446a..8f53b3b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -14,6 +14,8 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.impl.DoubleConstant;
+import org.eclipse.jdt.internal.compiler.impl.FloatConstant;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 
 public class IndexTester {
@@ -220,6 +222,24 @@ public class IndexTester {
 				return false;
 			}
 
+			if (o1 instanceof DoubleConstant && o2 instanceof DoubleConstant) {
+				DoubleConstant d1 = (DoubleConstant) o1;
+				DoubleConstant d2 = (DoubleConstant) o2;
+
+				if (Double.isNaN(d1.doubleValue()) && Double.isNaN(d2.doubleValue())) {
+					return true;
+				}
+			}
+
+			if (o1 instanceof FloatConstant && o2 instanceof FloatConstant) {
+				FloatConstant d1 = (FloatConstant) o1;
+				FloatConstant d2 = (FloatConstant) o2;
+
+				if (Float.isNaN(d1.floatValue()) && Float.isNaN(d2.floatValue())) {
+					return true;
+				}
+			}
+
 			Constant const1 = (Constant) o1;
 			Constant const2 = (Constant) o2;
 
@@ -330,10 +350,10 @@ public class IndexTester {
 					actualMethod.getParameterAnnotations(idx, classFileName));
 		}
 		for (int idx = minAnnotatedParameters; idx < expectedMethod.getAnnotatedParametersCount(); idx++) {
-			compareAnnotations(expectedMethod.getParameterAnnotations(idx, classFileName), new IBinaryAnnotation[0]);
+			compareAnnotations(new IBinaryAnnotation[0], expectedMethod.getParameterAnnotations(idx, classFileName));
 		}
 		for (int idx = minAnnotatedParameters; idx < actualMethod.getAnnotatedParametersCount(); idx++) {
-			compareAnnotations(new IBinaryAnnotation[0], expectedMethod.getParameterAnnotations(idx, classFileName));
+			compareAnnotations(new IBinaryAnnotation[0], actualMethod.getParameterAnnotations(idx, classFileName));
 		}
 
 		assertEquals("The selectors did not match", expectedMethod.getSelector(), actualMethod.getSelector()); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 892d996..dd98b3b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -32,7 +32,7 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 24);
+	static final int CURRENT_VERSION = Nd.version(1, 25);
 	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 25);
 	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 25);
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 0977c48..69c68ef 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -115,7 +115,7 @@ public class JavaNames {
 			result.append("[]"); //$NON-NLS-1$
 		}
 
-		return result.getContents();
+		return CharArrayUtils.notNull(result.getContents());
 	}
 
 	public static char[] binaryNameToFullyQualifiedName(char[] binaryName) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index dfa7f3b..5231604 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -182,7 +182,9 @@ public class IndexBinaryType implements IBinaryType {
 				getSignature(buffer, type.getTypeParameters());
 
 				NdTypeSignature superclass = type.getSuperclass();
-				superclass.getSignature(buffer);
+				if (superclass != null) {
+					superclass.getSignature(buffer);
+				}
 				for (NdTypeInterface nextInterface : type.getInterfaces()) {
 					nextInterface.getInterface().getSignature(buffer);
 				}
@@ -326,7 +328,11 @@ public class IndexBinaryType implements IBinaryType {
 		try (IReader rl = this.typeRef.lock()) {
 			NdType type = this.typeRef.get();
 			if (type != null) {
-				return type.getSuperclass().getRawType().getBinaryName();
+				NdTypeSignature superclass = type.getSuperclass();
+				if (superclass != null) {
+					return superclass.getRawType().getBinaryName();
+				}
+				return null;
 			} else {
 				return new char[0];
 			}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
index 52889bf..b0342f6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
@@ -493,4 +493,14 @@ public class CharArrayUtils {
 	public static boolean startsWith(char[] fieldDescriptor, char c) {
 		return fieldDescriptor.length > 0 && fieldDescriptor[0] == c;
 	}
+
+	/**
+	 * If the given array is null, returns the empty array. Otherwise, returns the argument.
+	 */
+	public static char[] notNull(char[] contents) {
+		if (contents == null) {
+			return EMPTY_CHAR_ARRAY;
+		}
+		return contents;
+	}
 }
commit 4dcc193980d68c87577d45bb030a703cad168ea0
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:36:12 2016 -0800

    Bug 481796 - Revert the adoption of ReentrantReadWriteLock
    
    This reverts commit 0e35b385f5ce96a4ea594fce30642cc605aa212d.
    
    Change-Id: I5c1c8ab1b778c0d1459c12eb1564d1ce4d9f2834
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

283	49	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index fd6ef92..9a7efb8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -11,10 +11,12 @@
 package org.eclipse.jdt.internal.core.nd;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
@@ -38,13 +40,6 @@ public class Nd {
 	private final int maxVersion;
 	private final int minVersion;
 
-	// Read-write lock rules. Readers don't conflict with other readers,
-	// Writers conflict with readers, and everyone conflicts with writers.
-	private final Object lockMutex = new Object();
-	private long lastWriteAccess = 0;
-	private long lastReadAccess = 0;
-	private ReentrantReadWriteLock lock;
-
 	public static int version(int major, int minor) {
 		return (major << 16) + minor;
 	}
@@ -144,16 +139,15 @@ public class Nd {
 
 	public Nd(File dbPath, ChunkCache chunkCache, NdNodeTypeRegistry<NdNode> nodeTypes, int minVersion,
 			int maxVersion, int currentVersion) throws IndexException {
-		this.lock = new ReentrantReadWriteLock();
 		this.currentVersion = currentVersion;
 		this.maxVersion = maxVersion;
 		this.minVersion = minVersion;
 		this.fNodeTypeRegistry = nodeTypes;
 		loadDatabase(dbPath, chunkCache);
-		// if (sDEBUG_LOCKS) {
-		// this.fLockDebugging = new HashMap<>();
-		// System.out.println("Debugging PDOM Locks"); //$NON-NLS-1$
-		// }
+		if (sDEBUG_LOCKS) {
+			this.fLockDebugging = new HashMap<>();
+			System.out.println("Debugging PDOM Locks"); //$NON-NLS-1$
+		}
 	}
 
 	public long getWriteNumber() {
@@ -194,52 +188,82 @@ public class Nd {
 
 	private void loadDatabase(File dbPath, ChunkCache cache) throws IndexException {
 		this.fPath= dbPath;
-		final boolean lockDB = this.db == null;
+		final boolean lockDB= this.db == null || this.lockCount != 0;
 
 		clearCaches();
 		this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
 
-		this.db.setLocked(true);
+		this.db.setLocked(lockDB);
 		if (!isSupportedVersion()) {
 			Package.log("Index database is uses an unsupported version " + this.db.getVersion() //$NON-NLS-1$
 				+ " Deleting and recreating.", null); //$NON-NLS-1$
 			this.db.close();
 			this.fPath.delete();
 			this.db = new Database(this.fPath, cache, getDefaultVersion(), isPermanentlyReadOnly());
-			this.db.setLocked(true);
+			this.db.setLocked(lockDB);
 		}
 		this.fWriteNumber = this.db.getLong(Database.WRITE_NUMBER_OFFSET);
-		synchronized (this.lockMutex) {
-			syncLockedState();
-		}
-	}
-
-	void syncLockedState() {
-		int writeLocks = this.lock.getWriteHoldCount();
-		int readLocks = this.lock.getReadLockCount();
-
-		this.db.setLocked(writeLocks != 0 || readLocks != 0);
+		this.db.setLocked(this.lockCount != 0);
 	}
 
 	public Database getDB() {
 		return this.db;
 	}
 
+	// Read-write lock rules. Readers don't conflict with other readers,
+	// Writers conflict with readers, and everyone conflicts with writers.
+	private final Object mutex = new Object();
+	private int lockCount;
+	private int waitingReaders;
+	private long lastWriteAccess= 0;
+	private long lastReadAccess= 0;
+	private long timeWriteLockAcquired;
+
 	public IReader acquireReadLock() {
-		this.lock.readLock().lock();
-		synchronized (this.lockMutex) {
-			syncLockedState();
+		try {
+			long t = sDEBUG_LOCKS ? System.nanoTime() : 0;
+			synchronized (this.mutex) {
+				++this.waitingReaders;
+				try {
+					while (this.lockCount < 0)
+						this.mutex.wait();
+				} finally {
+					--this.waitingReaders;
+				}
+				++this.lockCount;
+				this.db.setLocked(true);
+
+				if (sDEBUG_LOCKS) {
+					t = (System.nanoTime() - t) / 1000000;
+					if (t >= LONG_READ_LOCK_WAIT_REPORT_THRESHOLD) {
+						System.out.println("Acquired index read lock after " + t + " ms wait."); //$NON-NLS-1$//$NON-NLS-2$
+					}
+					incReadLock(this.fLockDebugging);
+				}
+				return this.fReader;
+			}
+		} catch (InterruptedException e) {
+			throw new OperationCanceledException();
 		}
-		return this.fReader;
 	}
 
 	public void releaseReadLock() {
-		synchronized (this.lockMutex) {
-			this.lock.readLock().unlock();
-			syncLockedState();
-			this.lastReadAccess = System.currentTimeMillis();
-		}
+		synchronized (this.mutex) {
+			assert this.lockCount > 0: "No lock to release"; //$NON-NLS-1$
+			if (sDEBUG_LOCKS) {
+				decReadLock(this.fLockDebugging);
+			}
 
+			this.lastReadAccess= System.currentTimeMillis();
+			if (this.lockCount > 0)
+				--this.lockCount;
+			this.mutex.notifyAll();
+			this.db.setLocked(this.lockCount != 0);
+		}
+		// A lock release probably means that some AST is going away. The result cache has to be
+		// cleared since it may contain objects belonging to the AST that is going away. A failure
+		// to release an AST object would cause a memory leak since the whole AST would remain
+		// pinned to memory.
 		// TODO(sprigogin): It would be more efficient to replace the global result cache with
 		// separate caches for each AST.
 		clearResultCache();
@@ -251,29 +275,97 @@ public class Nd {
 	 * @throws IllegalStateException if this PDOM is not writable
 	 */
 	public void acquireWriteLock(IProgressMonitor monitor) {
+		try {
+			acquireWriteLock(0, monitor);
+		} catch (InterruptedException e) {
+			throw new OperationCanceledException();
+		}
+	}
+
+	/**
+	 * Acquire a write lock on this PDOM, giving up the specified number of read locks first. Blocks
+	 * until any existing read/write locks are released.
+	 * @throws InterruptedException
+	 * @throws IllegalStateException if this PDOM is not writable
+	 */
+	public void acquireWriteLock(int giveupReadLocks, IProgressMonitor monitor) throws InterruptedException {
 		assert !isPermanentlyReadOnly();
-		this.lock.writeLock().lock();
-		this.db.setExclusiveLock();
+		synchronized (this.mutex) {
+			if (sDEBUG_LOCKS) {
+				incWriteLock(giveupReadLocks);
+			}
+
+			if (giveupReadLocks > 0) {
+				// give up on read locks
+				assert this.lockCount >= giveupReadLocks: "Not enough locks to release"; //$NON-NLS-1$
+				if (this.lockCount < giveupReadLocks) {
+					giveupReadLocks= this.lockCount;
+				}
+			} else {
+				giveupReadLocks= 0;
+			}
+
+			// Let the readers go first
+			long start= sDEBUG_LOCKS ? System.currentTimeMillis() : 0;
+			while (this.lockCount > giveupReadLocks || this.waitingReaders > 0) {
+				this.mutex.wait(CANCELLATION_CHECK_INTERVAL);
+				if (monitor != null && monitor.isCanceled()) {
+					throw new OperationCanceledException();
+				}
+				if (sDEBUG_LOCKS) {
+					start = reportBlockedWriteLock(start, giveupReadLocks);
+				}
+			}
+			this.lockCount= -1;
+			if (sDEBUG_LOCKS)
+				this.timeWriteLockAcquired = System.currentTimeMillis();
+			this.db.setExclusiveLock();
+		}
 	}
 
 	final public void releaseWriteLock() {
-		synchronized (this.lockMutex) {
-			int writeHoldCount = this.lock.getWriteHoldCount();
-			assert writeHoldCount >= 1;
-			if (writeHoldCount == 1) {
-				processDeletions();
-				this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
-				clearResultCache();
-				this.db.giveUpExclusiveLock(true);
-				this.lastWriteAccess = System.currentTimeMillis();
+		releaseWriteLock(0, true);
+	}
+
+	@SuppressWarnings("nls")
+	public void releaseWriteLock(int establishReadLocks, boolean flush) {
+		// When all locks are released we can clear the result cache.
+		if (establishReadLocks == 0) {
+			processDeletions();
+			this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
+			clearResultCache();
+		}
+		try {
+			this.db.giveUpExclusiveLock(flush);
+		} catch (IndexException e) {
+			Package.log(e);
+		}
+		assert this.lockCount == -1;
+		if (!this.fEvent.isTrivial())
+			this.lastWriteAccess= System.currentTimeMillis();
+		//final ChangeEvent event= this.fEvent;
+		this.fEvent= new ChangeEvent();
+		synchronized (this.mutex) {
+			if (sDEBUG_LOCKS) {
+				long timeHeld = this.lastWriteAccess - this.timeWriteLockAcquired;
+				if (timeHeld >= LONG_WRITE_LOCK_REPORT_THRESHOLD) {
+					System.out.println("Index write lock held for " + timeHeld + " ms");
+				}
+				decWriteLock(establishReadLocks);
 			}
-			this.lock.writeLock().unlock();
-			syncLockedState();
+
+			if (this.lockCount < 0)
+				this.lockCount= establishReadLocks;
+			this.mutex.notifyAll();
+			this.db.setLocked(this.lockCount != 0);
 		}
+		//fireChange(event);
 	}
 
 	public boolean hasWaitingReaders() {
-		return this.lock.hasQueuedThreads();
+		synchronized (this.mutex) {
+			return this.waitingReaders > 0;
+		}
 	}
 
 	public long getLastWriteAccess() {
@@ -336,6 +428,148 @@ public class Nd {
 		}
 	}
 
+	// For debugging lock issues
+	static class DebugLockInfo {
+		int fReadLocks;
+		int fWriteLocks;
+		List<StackTraceElement[]> fTraces= new ArrayList<>();
+
+		public int addTrace() {
+			this.fTraces.add(Thread.currentThread().getStackTrace());
+			return this.fTraces.size();
+		}
+
+		@SuppressWarnings("nls")
+		public void write(String threadName) {
+			System.out.println("Thread: '" + threadName + "': " + this.fReadLocks + " readlocks, " + this.fWriteLocks + " writelocks");
+			for (StackTraceElement[] trace : this.fTraces) {
+				System.out.println("  Stacktrace:");
+				for (StackTraceElement ste : trace) {
+					System.out.println("    " + ste);
+				}
+			}
+		}
+
+		public void inc(DebugLockInfo val) {
+			this.fReadLocks+= val.fReadLocks;
+			this.fWriteLocks+= val.fWriteLocks;
+			this.fTraces.addAll(val.fTraces);
+		}
+	}
+
+	// For debugging lock issues
+	private Map<Thread, DebugLockInfo> fLockDebugging;
+
+	// For debugging lock issues
+	private static DebugLockInfo getLockInfo(Map<Thread, DebugLockInfo> lockDebugging) {
+		assert sDEBUG_LOCKS;
+
+		Thread key = Thread.currentThread();
+		DebugLockInfo result= lockDebugging.get(key);
+		if (result == null) {
+			result= new DebugLockInfo();
+			lockDebugging.put(key, result);
+		}
+		return result;
+	}
+
+	// For debugging lock issues
+	static void incReadLock(Map<Thread, DebugLockInfo> lockDebugging) {
+		DebugLockInfo info = getLockInfo(lockDebugging);
+		info.fReadLocks++;
+		if (info.addTrace() > 10) {
+			outputReadLocks(lockDebugging);
+		}
+	}
+
+	// For debugging lock issues
+	@SuppressWarnings("nls")
+	static void decReadLock(Map<Thread, DebugLockInfo> lockDebugging) throws AssertionError {
+		DebugLockInfo info = getLockInfo(lockDebugging);
+		if (info.fReadLocks <= 0) {
+			outputReadLocks(lockDebugging);
+			throw new AssertionError("Superfluous releaseReadLock");
+		}
+		if (info.fWriteLocks != 0) {
+			outputReadLocks(lockDebugging);
+			throw new AssertionError("Releasing readlock while holding write lock");
+		}
+		if (--info.fReadLocks == 0) {
+			lockDebugging.remove(Thread.currentThread());
+		} else {
+			info.addTrace();
+		}
+	}
+
+	// For debugging lock issues
+	@SuppressWarnings("nls")
+	private void incWriteLock(int giveupReadLocks) throws AssertionError {
+		DebugLockInfo info = getLockInfo(this.fLockDebugging);
+		if (info.fReadLocks != giveupReadLocks) {
+			outputReadLocks(this.fLockDebugging);
+			throw new AssertionError("write lock with " + giveupReadLocks + " readlocks, expected " + info.fReadLocks);
+		}
+		if (info.fWriteLocks != 0)
+			throw new AssertionError("Duplicate write lock");
+		info.fWriteLocks++;
+	}
+
+	// For debugging lock issues
+	private void decWriteLock(int establishReadLocks) throws AssertionError {
+		DebugLockInfo info = getLockInfo(this.fLockDebugging);
+		if (info.fReadLocks != establishReadLocks)
+			throw new AssertionError("release write lock with " + establishReadLocks + " readlocks, expected " + info.fReadLocks); //$NON-NLS-1$ //$NON-NLS-2$
+		if (info.fWriteLocks != 1)
+			throw new AssertionError("Wrong release write lock"); //$NON-NLS-1$
+		info.fWriteLocks= 0;
+		if (info.fReadLocks == 0) {
+			this.fLockDebugging.remove(Thread.currentThread());
+		}
+	}
+
+	// For debugging lock issues
+	@SuppressWarnings("nls")
+	private long reportBlockedWriteLock(long start, int giveupReadLocks) {
+		long now= System.currentTimeMillis();
+		if (now >= start + BLOCKED_WRITE_LOCK_OUTPUT_INTERVAL) {
+			System.out.println();
+			System.out.println("Blocked writeLock");
+			System.out.println("  lockcount= " + this.lockCount + ", giveupReadLocks=" + giveupReadLocks + ", waitingReaders=" + this.waitingReaders);
+			outputReadLocks(this.fLockDebugging);
+			start= now;
+		}
+		return start;
+	}
+
+	// For debugging lock issues
+	@SuppressWarnings("nls")
+	private static void outputReadLocks(Map<Thread, DebugLockInfo> lockDebugging) {
+		System.out.println("---------------------  Lock Debugging -------------------------");
+		for (Thread th: lockDebugging.keySet()) {
+			DebugLockInfo info = lockDebugging.get(th);
+			info.write(th.getName());
+		}
+		System.out.println("---------------------------------------------------------------");
+	}
+
+	// For debugging lock issues
+	public void adjustThreadForReadLock(Map<Thread, DebugLockInfo> lockDebugging) {
+		for (Thread th : lockDebugging.keySet()) {
+			DebugLockInfo val= lockDebugging.get(th);
+			if (val.fReadLocks > 0) {
+				DebugLockInfo myval= this.fLockDebugging.get(th);
+				if (myval == null) {
+					myval= new DebugLockInfo();
+					this.fLockDebugging.put(th, myval);
+				}
+				myval.inc(val);
+				for (int i = 0; i < val.fReadLocks; i++) {
+					decReadLock(this.fLockDebugging);
+				}
+			}
+		}
+	}
+
     public NdNode getNode(long address, short nodeType) throws IndexException {
     	return this.fNodeTypeRegistry.createNode(this, address, nodeType);
     }
commit b13f351a7f671fd2f1b8eb50838dc4a5b0a82963
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:38:02 2016 -0800

    Bug 481796 - Temporarily disable the self-test code.
    
    The self-test code relied on reentrant locks. It will have to be rewritten
    in a way that is compatible with the CDT-style locks.
    
    Change-Id: I5dee85b4d0462dc24d44c523ace2ea07beddad0a
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

0	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 281c831..09b4b8a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -51,8 +51,6 @@ import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
 import org.eclipse.jdt.internal.core.nd.java.NdVariable;
-import org.eclipse.jdt.internal.core.nd.java.ReferenceUtil;
-import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -66,7 +64,6 @@ public class ClassFileToIndexConverter {
 	private static final boolean ENABLE_LOGGING = false;
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
 	private static final char[] PATH_SEPARATOR = new char[]{'/'};
-	private static final boolean ENABLE_SELF_TEST = false;
 	private static final char[] ARRAY_FIELD_DESCRIPTOR_PREFIX = new char[] { '[' };
 	private NdResourceFile resource;
 	private JavaIndex index;
@@ -217,10 +214,6 @@ public class ClassFileToIndexConverter {
 		type.setTagBits(binaryType.getTagBits());
 		type.setSourceNameOverride(binaryType.getSourceName());
 
-		if (ENABLE_SELF_TEST) {
-			IndexTester.testType(binaryType, new IndexBinaryType(ReferenceUtil.createTypeRef(type)));
-		}
-
 		return type;
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 250c7cf..7cc9ec1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -363,6 +363,9 @@ public final class Indexer {
 			} finally {
 				this.pdom.releaseWriteLock();
 			}
+//			if (ENABLE_SELF_TEST) {
+//				IndexTester.testType(binaryType, new IndexBinaryType(ReferenceUtil.createTypeRef(type)));
+//			}
 		}
 
 		return classesIndexed;
commit 590f94568db810ffd7bf16613d9c19f99ac593ec
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:49:05 2016 -0800

    Bug 481796 - IndexBinaryType bugfixes and refactoring
    
    Fixed a number of return types which should have returned null but were
    returning empty arrays in error situations.
    
    Wrote a new TypeRef object to use instead of DatabaseRef<NdType>, and
    adopted it. The extra generality of the generic version was making it
    harder and more verbose to use directly.
    
    Change-Id: I8a2976d90232bf33bf4aaa887facb62a6c5b3188
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
3	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
25	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
0	72	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
87	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TypeRef.java
2	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
7	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
index bb88ae9..243e3ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
@@ -27,7 +27,6 @@ import org.eclipse.jdt.internal.compiler.env.IGenericType;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.core.*;
-import org.eclipse.jdt.internal.core.nd.indexer.Indexer;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
 import org.eclipse.jdt.internal.core.util.ResourceCompilationUnit;
@@ -311,7 +310,7 @@ protected IBinaryType createInfoFromClassFileInJar(Openable classFile) {
 	IBinaryType info = null;
 
 	if (JavaIndex.isEnabled()) {
-		info = BinaryTypeFactory.create(Indexer.getLocationForElement(classFile.getParent()), classFilePath);
+		info = BinaryTypeFactory.create(JavaIndex.getLocationForElement(classFile.getParent()), classFilePath);
 	} else {
 		java.util.zip.ZipFile zipFile = null;
 		try {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 7cc9ec1..954f87c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -176,7 +176,7 @@ public final class Indexer {
 
 		HashSet<IPath> workspacePaths = new HashSet<IPath>();
 		for (IJavaElement next : allRoots) {
-			IPath nextPath = getLocationForElement(next);
+			IPath nextPath = JavaIndex.getLocationForElement(next);
 			IPath workspacePath = getWorkspacePathForRoot(next);
 
 			List<IJavaElement> value = paths.get(nextPath);
@@ -252,7 +252,7 @@ public final class Indexer {
 			resourceFile.setLocation(pathString);
 			IPackageFragmentRoot packageFragmentRoot = (IPackageFragmentRoot) element
 					.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
-			IPath rootPathString = getLocationForElement(packageFragmentRoot);
+			IPath rootPathString = JavaIndex.getLocationForElement(packageFragmentRoot);
 			if (!rootPathString.equals(thePath)) {
 				resourceFile.setPackageFragmentRoot(rootPathString.toString().toCharArray());
 			}
@@ -427,7 +427,7 @@ public final class Indexer {
 						if (!nextRoot.exists()) {
 							continue;
 						}
-						IPath filesystemPath = getLocationForElement(nextRoot);
+						IPath filesystemPath = JavaIndex.getLocationForElement(nextRoot);
 						if (scannedPaths.contains(filesystemPath)) {
 							continue;
 						}
@@ -554,16 +554,6 @@ public final class Indexer {
 		return fingerprint.test(thePath.toFile(), subMonitor.split(50));
 	}
 
-	public static IPath getLocationForElement(IJavaElement next) {
-		IResource resource = next.getResource();
-
-		if (resource != null) {
-			return resource.getLocation() == null ? new Path("") : resource.getLocation(); //$NON-NLS-1$
-		}
-
-		return next.getPath();
-	}
-
 	public Indexer(Nd toPopulate, IWorkspaceRoot workspaceRoot) {
 		this.pdom = toPopulate;
 		this.root = workspaceRoot;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index dd98b3b..faf7c7f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -13,8 +13,11 @@ package org.eclipse.jdt.internal.core.nd.java;
 import java.io.File;
 import java.util.List;
 
+import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
@@ -32,9 +35,9 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 25);
-	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 25);
-	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 25);
+	static final int CURRENT_VERSION = Nd.version(1, 26);
+	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 26);
+	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 26);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
@@ -147,6 +150,19 @@ public class JavaIndex {
 		return new NdMethodId(this.pdom, methodId);
 	}
 
+	/**
+	 * Returns the absolute filesystem location of the given element or null if none
+	 */
+	public static IPath getLocationForElement(IJavaElement next) {
+		IResource resource = next.getResource();
+
+		if (resource != null) {
+			return resource.getLocation() == null ? new Path("") : resource.getLocation(); //$NON-NLS-1$
+		}
+
+		return next.getPath();
+	}
+
 	public static boolean isEnabled() {
 		return Platform.getPreferencesService().getBoolean("org.eclipse.jdt.ui", "enableNewJavaIndex", false, //$NON-NLS-1$ //$NON-NLS-2$
 				null);
@@ -192,7 +208,7 @@ public class JavaIndex {
 
 	static NdNodeTypeRegistry<NdNode> createTypeRegistry() {
 		NdNodeTypeRegistry<NdNode> registry = new NdNodeTypeRegistry<>();
-		registry.register(0x0000, NdAnnotation.type.getFactory());
+		registry.register(0x0001, NdAnnotation.type.getFactory());
 		registry.register(0x0010, NdAnnotationValuePair.type.getFactory());
 		registry.register(0x0020, NdBinding.type.getFactory());
 		registry.register(0x0028, NdComplexTypeSignature.type.getFactory());
@@ -229,6 +245,11 @@ public class JavaIndex {
 		return registry;
 	}
 
+	// TODO: delete and recreate the index
+	public void rebuildIndex() {
+
+	}
+
 //	/**
 //	 * Returns a method ID or creates a new one if it does not exist. The caller must
 //	 * attach a reference to it after calling this method or it may leak.
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
deleted file mode 100644
index 7d78c80..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/ReferenceUtil.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.eclipse.jdt.internal.core.nd.java;
-
-import java.util.List;
-
-import org.eclipse.jdt.internal.core.nd.DatabaseRef;
-import org.eclipse.jdt.internal.core.nd.Nd;
-import org.eclipse.jdt.internal.core.nd.Supplier;
-
-/**
- * Holds utility functions for constructing {@link DatabaseRef} objects to java Nd types. Such references
- * can be retained while releasing and reacquiring a read lock, unlike ordinary pointers to database objects,
- * which must be discarded every time a read lock is released.
- */
-public final class ReferenceUtil {
-	/**
-	 * Creates a {@link DatabaseRef} to the given {@link NdType}.
-	 */
-	public static DatabaseRef<NdType> createTypeRef(NdType type) {
-		final Nd nd = type.getNd();
-		final char[] fieldDescriptor = type.getTypeId().getRawType().getFieldDescriptor().getChars();
-		final char[] fileName = type.getResourceFile().getLocation().getChars();
-		return new DatabaseRef<NdType>(type.getNd(), getTypeSupplier(nd, fileName, fieldDescriptor), type);
-	}
-
-	/**
-	 * Creates a {@link DatabaseRef} to the {@link NdType} with the given resource path and field descriptor.
-	 */
-	public static DatabaseRef<NdType> createTypeRef(Nd nd, char[] resourcePath, char[] fieldDescriptor) {
-		return new DatabaseRef<NdType>(nd, getTypeSupplier(nd, resourcePath, fieldDescriptor));
-	}
-
-	/**
-	 * Creates a {@link DatabaseRef} to the given {@link NdTypeId}.
-	 */
-	public static DatabaseRef<NdTypeId> createTypeIdRef(NdTypeId typeId) {
-		return new DatabaseRef<NdTypeId>(typeId.getNd(),
-				getTypeIdSupplier(typeId.getNd(), typeId.getFieldDescriptor().getChars()));
-	}
-
-	/**
-	 * Creates a {@link DatabaseRef} to the {@link NdTypeId} with the given field descriptor.
-	 */
-	public static DatabaseRef<NdTypeId> createTypeIdRef(Nd nd, char[] fieldDescriptor) {
-		return new DatabaseRef<NdTypeId>(nd, getTypeIdSupplier(nd, fieldDescriptor));
-	}
-
-	private static Supplier<NdTypeId> getTypeIdSupplier(final Nd nd, final char[] fieldDescriptor) {
-		return new Supplier<NdTypeId>() {
-			@Override
-			public NdTypeId get() {
-				return JavaIndex.getIndex(nd).findType(fieldDescriptor);
-			}
-		};
-	}
-
-	private static Supplier<NdType> getTypeSupplier(final Nd nd, final char[] fileName, final char[] fieldDescriptor) {
-		return new Supplier<NdType>() {
-			@Override
-			public NdType get() {
-				NdTypeId typeId = JavaIndex.getIndex(nd).findType(fieldDescriptor);
-
-				List<NdType> implementations = typeId.getTypes();
-				for (NdType next : implementations) {
-					if (next.getResourceFile().getLocation().compare(fileName, false) == 0) {
-						return next;
-					}
-				}
-				return null;
-			}
-		};
-	}
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TypeRef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TypeRef.java
new file mode 100644
index 0000000..5442f90
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TypeRef.java
@@ -0,0 +1,87 @@
+package org.eclipse.jdt.internal.core.nd.java;
+
+import java.util.List;
+
+import org.eclipse.jdt.internal.core.nd.DatabaseRef;
+import org.eclipse.jdt.internal.core.nd.IReader;
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.Supplier;
+
+/**
+ * Holds a reference to an NdType that can be retained while releasing and reacquiring a read lock.
+ */
+public final class TypeRef implements Supplier<NdType> {
+	final DatabaseRef<NdType> ref;
+	final char[] fileName;
+	final char[] fieldDescriptor;
+	final TypeSupplier typeSupplier = new TypeSupplier();
+	private final class TypeSupplier implements Supplier<NdType> {
+		public TypeSupplier() {
+		}
+
+		@Override
+		public NdType get() {
+			NdTypeId typeId = JavaIndex.getIndex(TypeRef.this.ref.getNd()).findType(TypeRef.this.fieldDescriptor);
+
+			if (typeId == null) {
+				return null;
+			}
+
+			List<NdType> implementations = typeId.getTypes();
+			for (NdType next : implementations) {
+				NdResourceFile nextResourceFile = next.getResourceFile();
+				if (nextResourceFile.getLocation().compare(TypeRef.this.fileName, false) == 0) {
+					if (nextResourceFile.isDoneIndexing()) {
+						return next;
+					}
+				}
+			}
+			return null;
+		}
+	}
+
+	private TypeRef(NdType type) {
+		super();
+		this.fieldDescriptor = type.getTypeId().getRawType().getFieldDescriptor().getChars();
+		this.fileName = type.getResourceFile().getLocation().getChars();
+		this.ref = new DatabaseRef<NdType>(type.getNd(), this.typeSupplier, type);
+	}
+
+	private TypeRef(Nd nd, char[] resourcePath, char[] fieldDescriptor) {
+		super();
+		this.fieldDescriptor = fieldDescriptor;
+		this.fileName = resourcePath;
+		this.ref = new DatabaseRef<NdType>(nd, this.typeSupplier);
+	}
+
+	public char[] getFieldDescriptor() {
+		return this.fieldDescriptor;
+	}
+
+	public char[] getFileName() {
+		return this.fileName;
+	}
+
+	/**
+	 * Creates a {@link DatabaseRef} to the given {@link NdType}.
+	 */
+	public static TypeRef create(NdType type) {
+		return new TypeRef(type);
+	}
+
+	/**
+	 * Creates a {@link DatabaseRef} to the {@link NdType} with the given resource path and field descriptor.
+	 */
+	public static TypeRef create(Nd nd, char[] resourcePath, char[] fieldDescriptor) {
+		return new TypeRef(nd, resourcePath, fieldDescriptor);
+	}
+
+	public IReader lock() {
+		return this.ref.lock();
+	}
+
+	@Override
+	public NdType get() {
+		return this.ref.get();
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
index 7b2da1b..fdb1a6d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -2,16 +2,14 @@ package org.eclipse.jdt.internal.core.nd.java.model;
 
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.core.nd.DatabaseRef;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
-import org.eclipse.jdt.internal.core.nd.java.NdType;
-import org.eclipse.jdt.internal.core.nd.java.ReferenceUtil;
+import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 
 public class BinaryTypeFactory {
 	public static IBinaryType create(IPath fileSystemPath, String binaryName) {
 		JavaIndex index = JavaIndex.getIndex();
-		DatabaseRef<NdType> typeRef = ReferenceUtil.createTypeRef(index.getNd(),
+		TypeRef typeRef = TypeRef.create(index.getNd(),
 				fileSystemPath.toString().toCharArray(),
 				JavaNames.binaryNameToFieldDescriptor(binaryName.toCharArray()));
 		return new IndexBinaryType(typeRef);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 5231604..eecbf39 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -18,7 +18,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
-import org.eclipse.jdt.internal.core.nd.DatabaseRef;
 import org.eclipse.jdt.internal.core.nd.IReader;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
@@ -42,6 +41,7 @@ import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeSignature;
 import org.eclipse.jdt.internal.core.nd.java.NdVariable;
+import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 
@@ -49,13 +49,13 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
  * Implementation of {@link IBinaryType} that reads all its content from the index
  */
 public class IndexBinaryType implements IBinaryType {
-	private final DatabaseRef<NdType> typeRef;
+	private final TypeRef typeRef;
 
 	private boolean enclosingInitialized;
 	private char[] enclosingMethod;
 	private char[] enclosingType;
 
-	public IndexBinaryType(DatabaseRef<NdType> type) {
+	public IndexBinaryType(TypeRef type) {
 		this.typeRef = type;
 	}
 
@@ -83,7 +83,7 @@ public class IndexBinaryType implements IBinaryType {
 			if (type != null) {
 				return type.getFile().getPath().toString().toCharArray();
 			} else {
-				return new char[0];
+				return null;
 			}
 		}
 	}
@@ -167,7 +167,7 @@ public class IndexBinaryType implements IBinaryType {
 				}
 				return result;
 			} else {
-				return new IBinaryField[0];
+				return null;
 			}
 		}
 	}
@@ -301,14 +301,7 @@ public class IndexBinaryType implements IBinaryType {
 
 	@Override
 	public char[] getName() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getTypeId().getBinaryName();
-			} else {
-				return new char[0];
-			}
-		}
+		return JavaNames.fieldDescriptorToBinaryName(this.typeRef.getFieldDescriptor());
 	}
 
 	@Override
@@ -334,7 +327,7 @@ public class IndexBinaryType implements IBinaryType {
 				}
 				return null;
 			} else {
-				return new char[0];
+				return null;
 			}
 		}
 	}
commit 25763ef7aa35fbaf1ec370de820365f5834ceecb
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:50:05 2016 -0800

    Bug 481796 - Fix fullyQualifiedNameToFieldDescriptor
    
    The method was missing the trailing ';' for field descriptors of user
    types.
    
    Change-Id: I32d3854625094a0a914d0e35e869d4d84c96cfb5
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index 69c68ef..b0782e7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -42,7 +42,7 @@ public class JavaNames {
 	}
 
 	public static char[] fullyQualifiedNameToFieldDescriptor(char[] fullyQualifiedName) {
-		char[] result = CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, fullyQualifiedName);
+		char[] result = CharArrayUtils.concat(FIELD_DESCRIPTOR_PREFIX, fullyQualifiedName, FIELD_DESCRIPTOR_SUFFIX);
 		CharOperation.replace(result, '.', '/');
 		return result;
 	}
commit a4b7151b95a163caebc380872b616f547698ab1e
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:50:47 2016 -0800

    Bug 481796 - Improve error messages for unexpected node types
    
    Change-Id: Id78fccacf837d0bab9f31e7b1da2bd7ac7ab3686
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index a528e32..493c06b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -68,7 +68,7 @@ public abstract class NdNode implements IDestructable {
 
 		if (!clazz.isAssignableFrom(result.getClass())) {
 			throw new IndexException("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
-				clazz.getClass() + " but found " + result.getClass()); //$NON-NLS-1$
+					clazz + " but found " + result.getClass()); //$NON-NLS-1$
 		}
 
 		return (T)result;
commit a528bad3c2ac43691caa229f4d794f3ad5b58b19
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 18 19:53:13 2016 -0800

    Bug 481796 - Adopt the new index in ClassFile.getJarBinaryTypeInfo
    
    If the requested class file can be found in the index and the index
    version is up-to-date, use the version from the index rather than
    reading it from the .jar file.
    
    Change-Id: Ib65d02029fbd54a388708abb83800d32ba560e86
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

43	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
10	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index cef1ba4..645e970 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -39,6 +39,14 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IDependent;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.nd.IReader;
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
+import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
+import org.eclipse.jdt.internal.core.nd.java.TypeRef;
+import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -347,7 +355,40 @@ public byte[] getBytes() throws JavaModelException {
 		return Util.getResourceContentsAsByteArray(file);
 	}
 }
+
 private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyInitialize) throws CoreException, IOException, ClassFormatException {
+	// If the new index is enabled, check if we have this class file cached in the index already
+	if (JavaIndex.isEnabled()) {
+		IPath location = JavaIndex.getLocationForElement(pkg.getParent());
+		JavaIndex index = JavaIndex.getIndex();
+		Nd nd = index.getNd();
+
+		// We don't currently cache package-info files in the index
+		if (location != null && !this.name.equals("package-info")) { //$NON-NLS-1$
+			String locationString = location.toString();
+			// Acquire a read lock on the index
+			try (IReader lock = nd.acquireReadLock()) {
+				NdResourceFile file = index.getResourceFile(locationString);
+
+				if (file != null && file.isDoneIndexing()) {
+					// If this file is in the index and its fingerprint matches the content most recently indexed
+					// then read our result from the index
+					if (file.getFingerprint().test(location.toFile(), null).matches()) {
+						char[] fieldDescriptor = CharArrayUtils.concat(new char[] { 'L' },
+								Util.concatWith(pkg.names, this.name, '/').toCharArray(),
+								new char[] { ';' });
+
+						return new IndexBinaryType(
+								TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor));
+					}
+				}
+			} catch (IndexException e) {
+				// Index corrupted. Rebuild it.
+				index.rebuildIndex();
+			}
+		}
+	}
+
 	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
 	ZipFile zip = null;
 	ZipFile annotationZip = null;
@@ -366,7 +407,7 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 					IProject project = javaProject.getProject();
 					IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project, false); // unresolved for use in ExternalAnnotationTracker
 					if (externalAnnotationPath != null) {
-						setupExternalAnnotationProvider(project, externalAnnotationPath, annotationZip, reader, 
+						setupExternalAnnotationProvider(project, externalAnnotationPath, annotationZip, reader,
 								entryName.substring(0, entryName.length() - SuffixConstants.SUFFIX_CLASS.length));
 					} else if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
 						reader.markAsFromSource();
@@ -398,7 +439,7 @@ private void setupExternalAnnotationProvider(IProject project, final IPath exter
 	String resolvedPath;
 	if (resource.exists()) {
 		if (resource.isVirtual()) {
-			Util.log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID, 
+			Util.log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
 					"Virtual resource "+externalAnnotationPath+" cannot be used as annotationpath for project "+project.getName())); //$NON-NLS-1$ //$NON-NLS-2$
 			return;
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 9baff34..5dc8737 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -179,6 +179,16 @@ public class NdResourceFile extends NdTreeNode {
 		return HASHCODE_LAST_SCANNED.get(getNd(), this.address);
 	}
 
+	/**
+	 * Returns true iff the indexer has finished writing the contents of this file to the index. Returns false if
+	 * indexing may still be going on. If this returns false, readers should ignore all contents of this file.
+	 *
+	 * @return true iff the contents of this file are usable
+	 */
+	public boolean isDoneIndexing() {
+		return getTimeLastScanned() != 0;
+	}
+
 	public long getTimeLastScanned() {
 		return TIME_LAST_SCANNED.get(getNd(), this.address);
 	}
commit 910fc402d1ffa5486fa46994590b4f80e9c425cb
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Fri Feb 19 11:12:31 2016 -0800

    Bug 481796 - Performance tuning
    
    Fetch a number of attributes for IndexBinaryType in a batch to reduce
    the amount of database locking and unlocking.
    
    Change-Id: I52654e5eba5571f3ad4020272c257532c69a3781
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

26	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
7	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
8	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
48	67	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 645e970..c2e4812 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -97,6 +97,7 @@ public ICompilationUnit becomeWorkingCopy(IProblemRequestor problemRequestor, Wo
  * @see Openable
  * @see Signature
  */
+@Override
 protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException {
 	IBinaryType typeInfo = getBinaryTypeInfo((IFile) underlyingResource);
 	if (typeInfo == null) {
@@ -120,6 +121,7 @@ protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm,
  * @see ICodeAssist#codeComplete(int, ICompletionRequestor)
  * @deprecated
  */
+@Deprecated
 public void codeComplete(int offset, ICompletionRequestor requestor) throws JavaModelException {
 	codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY);
 }
@@ -127,6 +129,7 @@ public void codeComplete(int offset, ICompletionRequestor requestor) throws Java
  * @see ICodeAssist#codeComplete(int, ICompletionRequestor, WorkingCopyOwner)
  * @deprecated
  */
+@Deprecated
 public void codeComplete(int offset, ICompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
 	if (requestor == null) {
 		throw new IllegalArgumentException("Completion requestor cannot be null"); //$NON-NLS-1$
@@ -193,9 +196,11 @@ public IJavaElement[] codeSelect(int offset, int length, WorkingCopyOwner owner)
 /**
  * Returns a new element info for this element.
  */
+@Override
 protected Object createElementInfo() {
 	return new ClassFileInfo();
 }
+@Override
 public boolean equals(Object o) {
 	if (!(o instanceof ClassFile)) return false;
 	ClassFile other = (ClassFile) o;
@@ -273,6 +278,7 @@ public IType findPrimaryType() {
 	}
 	return null;
 }
+@Override
 public String getAttachedJavadoc(IProgressMonitor monitor) throws JavaModelException {
 	return getType().getAttachedJavadoc(monitor);
 }
@@ -357,6 +363,7 @@ public byte[] getBytes() throws JavaModelException {
 }
 
 private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyInitialize) throws CoreException, IOException, ClassFormatException {
+	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
 	// If the new index is enabled, check if we have this class file cached in the index already
 	if (JavaIndex.isEnabled()) {
 		IPath location = JavaIndex.getLocationForElement(pkg.getParent());
@@ -378,8 +385,12 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 								Util.concatWith(pkg.names, this.name, '/').toCharArray(),
 								new char[] { ';' });
 
+						String entryName = Util.concatWith(pkg.names, getElementName(), '/');
+						String indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
+
 						return new IndexBinaryType(
-								TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor));
+								TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor),
+								indexPath.toCharArray());
 					}
 				}
 			} catch (IndexException e) {
@@ -389,7 +400,6 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 		}
 	}
 
-	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
 	ZipFile zip = null;
 	ZipFile annotationZip = null;
 	try {
@@ -480,6 +490,7 @@ public void close() throws JavaModelException {
 	}
 	super.close();
 }
+@Override
 public IBuffer getBuffer() throws JavaModelException {
 	IStatus status = validateClassFile();
 	if (status.isOK()) {
@@ -497,6 +508,7 @@ public IBuffer getBuffer() throws JavaModelException {
 /**
  * @see IMember
  */
+@Override
 public IClassFile getClassFile() {
 	return this;
 }
@@ -512,6 +524,7 @@ public ITypeRoot getTypeRoot() {
  *
  * @see IJavaElement
  */
+@Override
 public IResource getCorrespondingResource() throws JavaModelException {
 	IPackageFragmentRoot root= (IPackageFragmentRoot)getParent().getParent();
 	if (root.isArchive()) {
@@ -583,6 +596,7 @@ public IJavaElement getElementAtConsideringSibling(int position) throws JavaMode
 		return null;
 	}
 }
+@Override
 public String getElementName() {
 	return this.name + SuffixConstants.SUFFIX_STRING_class;
 }
@@ -595,6 +609,7 @@ public int getElementType() {
 /*
  * @see JavaElement
  */
+@Override
 public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner owner) {
 	switch (token.charAt(0)) {
 		case JEM_TYPE:
@@ -608,6 +623,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 /**
  * @see JavaElement#getHandleMemento()
  */
+@Override
 protected char getHandleMementoDelimiter() {
 	return JavaElement.JEM_CLASSFILE;
 }
@@ -625,6 +641,7 @@ public IPath getPath() {
 /*
  * @see IJavaElement
  */
+@Override
 public IResource resource(PackageFragmentRoot root) {
 	return ((IContainer) ((Openable) this.parent).resource(root)).getFile(new Path(getElementName()));
 }
@@ -697,15 +714,18 @@ public ICompilationUnit getWorkingCopy(WorkingCopyOwner owner, IProgressMonitor
  * @see IClassFile
  * @deprecated
  */
+@Deprecated
 public IJavaElement getWorkingCopy(IProgressMonitor monitor, org.eclipse.jdt.core.IBufferFactory factory) throws JavaModelException {
 	return getWorkingCopy(BufferFactoryWrapper.create(factory), monitor);
 }
 /**
  * @see Openable
  */
+@Override
 protected boolean hasBuffer() {
 	return true;
 }
+@Override
 public int hashCode() {
 	return Util.combineHashCodes(this.name.hashCode(), this.parent.hashCode());
 }
@@ -724,6 +744,7 @@ public boolean isInterface() throws JavaModelException {
 /**
  * Returns true - class files are always read only.
  */
+@Override
 public boolean isReadOnly() {
 	return true;
 }
@@ -746,6 +767,7 @@ private IStatus validateClassFile() {
  *
  * @see Openable
  */
+@Override
 protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException {
 	// Check the cache for the top-level type first
 	IType outerMostEnclosingType = getOuterMostEnclosingType();
@@ -886,6 +908,7 @@ public static char[] translatedName(char[] name) {
  * @see ICodeAssist#codeComplete(int, ICodeCompletionRequestor)
  * @deprecated - should use codeComplete(int, ICompletionRequestor) instead
  */
+@Deprecated
 public void codeComplete(int offset, final org.eclipse.jdt.core.ICodeCompletionRequestor requestor) throws JavaModelException {
 
 	if (requestor == null){
@@ -941,6 +964,7 @@ public void codeComplete(int offset, final org.eclipse.jdt.core.ICodeCompletionR
 		});
 }
 
+@Override
 protected IStatus validateExistence(IResource underlyingResource) {
 	// check whether the class file can be opened
 	IStatus status = validateClassFile();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
index 243e3ea..202e4d8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java
@@ -28,6 +28,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.core.*;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
 import org.eclipse.jdt.internal.core.util.ResourceCompilationUnit;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -310,7 +311,7 @@ protected IBinaryType createInfoFromClassFileInJar(Openable classFile) {
 	IBinaryType info = null;
 
 	if (JavaIndex.isEnabled()) {
-		info = BinaryTypeFactory.create(JavaIndex.getLocationForElement(classFile.getParent()), classFilePath);
+		info = BinaryTypeFactory.create(classFile.getParent(), JavaNames.classFilePathToBinaryName(classFilePath));
 	} else {
 		java.util.zip.ZipFile zipFile = null;
 		try {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index b0782e7..d4e662a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -184,4 +184,11 @@ public class JavaNames {
 	public static boolean isClinit(char[] selector) {
 		return selector[0] == '<' && selector.length == 8; // Can only match <clinit>
 	}
+
+	public static String classFilePathToBinaryName(String classFilePath) {
+		if (classFilePath.endsWith(".class")) { //$NON-NLS-1$
+			return classFilePath.substring(0, classFilePath.length() - 6);
+		}
+		return classFilePath;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
index fdb1a6d..c5446d4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -1,17 +1,22 @@
 package org.eclipse.jdt.internal.core.nd.java.model;
 
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 
 public class BinaryTypeFactory {
-	public static IBinaryType create(IPath fileSystemPath, String binaryName) {
+	public static IBinaryType create(IJavaElement javaElement, String binaryName) {
+		IPath filesystemLocation = JavaIndex.getLocationForElement(javaElement);
+
 		JavaIndex index = JavaIndex.getIndex();
 		TypeRef typeRef = TypeRef.create(index.getNd(),
-				fileSystemPath.toString().toCharArray(),
+				filesystemLocation.toString().toCharArray(),
 				JavaNames.binaryNameToFieldDescriptor(binaryName.toCharArray()));
-		return new IndexBinaryType(typeRef);
+
+		char[] indexPath = (javaElement.getPath().toString() + "|" + binaryName + ".class").toCharArray(); //$NON-NLS-1$//$NON-NLS-2$
+		return new IndexBinaryType(typeRef, indexPath);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index eecbf39..b8fd78e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -51,24 +51,28 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 public class IndexBinaryType implements IBinaryType {
 	private final TypeRef typeRef;
 
-	private boolean enclosingInitialized;
+	private boolean simpleAttributesInitialized;
 	private char[] enclosingMethod;
 	private char[] enclosingType;
+	private char[] fileName;
+	private char[] superclassName;
+	private int modifiers;
+	private boolean isAnonymous;
+	private boolean isLocal;
+	private boolean isMember;
 
-	public IndexBinaryType(TypeRef type) {
+	private long tagBits;
+
+	public IndexBinaryType(TypeRef type, char[] indexPath) {
 		this.typeRef = type;
+		this.fileName = indexPath;
 	}
 
 	@Override
 	public int getModifiers() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getModifiers();
-			} else {
-				return 0;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.modifiers;
 	}
 
 	@Override
@@ -78,14 +82,7 @@ public class IndexBinaryType implements IBinaryType {
 
 	@Override
 	public char[] getFileName() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getFile().getPath().toString().toCharArray();
-			} else {
-				return null;
-			}
-		}
+		return this.fileName;
 	}
 
 	@Override
@@ -138,14 +135,14 @@ public class IndexBinaryType implements IBinaryType {
 
 	@Override
 	public char[] getEnclosingMethod() {
-		initEnclosing();
+		initSimpleAttributes();
 
 		return this.enclosingMethod;
 	}
 
 	@Override
 	public char[] getEnclosingTypeName() {
-		initEnclosing();
+		initSimpleAttributes();
 
 		return this.enclosingType;
 	}
@@ -318,66 +315,37 @@ public class IndexBinaryType implements IBinaryType {
 
 	@Override
 	public char[] getSuperclassName() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				NdTypeSignature superclass = type.getSuperclass();
-				if (superclass != null) {
-					return superclass.getRawType().getBinaryName();
-				}
-				return null;
-			} else {
-				return null;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.superclassName;
 	}
 
 	@Override
 	public long getTagBits() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.getTagBits();
-			} else {
-				return 0;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.tagBits;
 	}
 
 	@Override
 	public boolean isAnonymous() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.isAnonymous();
-			} else {
-				return false;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.isAnonymous;
 	}
 
 	@Override
 	public boolean isLocal() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.isLocal();
-			} else {
-				return false;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.isLocal;
 	}
 
 	@Override
 	public boolean isMember() {
-		try (IReader rl = this.typeRef.lock()) {
-			NdType type = this.typeRef.get();
-			if (type != null) {
-				return type.isMember();
-			} else {
-				return false;
-			}
-		}
+		initSimpleAttributes();
+
+		return this.isMember;
 	}
 
 	@Override
@@ -656,9 +624,9 @@ public class IndexBinaryType implements IBinaryType {
 		}
 	}
 
-	private void initEnclosing() {
-		if (!this.enclosingInitialized) {
-			this.enclosingInitialized = true;
+	private void initSimpleAttributes() {
+		if (!this.simpleAttributesInitialized) {
+			this.simpleAttributesInitialized = true;
 
 			try (IReader rl = this.typeRef.lock()) {
 				NdType type = this.typeRef.get();
@@ -677,6 +645,19 @@ public class IndexBinaryType implements IBinaryType {
 							this.enclosingType = typeId.getBinaryName();
 						}
 					}
+
+					this.modifiers = type.getModifiers();
+					this.isAnonymous = type.isAnonymous();
+					this.isLocal = type.isLocal();
+					this.isMember = type.isMember();
+					this.tagBits = type.getTagBits();
+
+					NdTypeSignature superclass = type.getSuperclass();
+					if (superclass != null) {
+						this.superclassName = superclass.getRawType().getBinaryName();
+					} else {
+						this.superclassName = null;
+					}
 				}
 			}
 		}
commit 330d8b39a3cbdfd2e740dae28cfedba9f5d49bf4
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Feb 23 08:34:05 2016 -0800

    Bug 481796 - Add @since tags to get rid of bogus API errors
    
    Change-Id: Ia85ceef8b60983c58a63673f2d2b7f9ad757acfc
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IReader.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
index a23d52b..55df206 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/DatabaseRef.java
@@ -6,6 +6,8 @@ package org.eclipse.jdt.internal.core.nd;
  * address may have been deleted in the meantime. This class addresses this problem by remembering both the
  * address itself and enough information to determine whether that address is invalid and search for an
  * equivalent object if the original is lost.
+ * 
+ * @since 3.12
  */
 public class DatabaseRef<T extends NdNode> implements Supplier<T> {
 	private final Nd nd;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IReader.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IReader.java
index ff8c7b9..c5508ac 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IReader.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IReader.java
@@ -1,5 +1,8 @@
 package org.eclipse.jdt.internal.core.nd;
 
+/**
+ * @since 3.12
+ */
 public interface IReader extends AutoCloseable {
 	@Override
 	void close();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
index 235964e..b02881f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Supplier.java
@@ -2,6 +2,7 @@ package org.eclipse.jdt.internal.core.nd;
 
 /**
  * TODO: Remove me once we can use the Java 8 interface
+ * @since 3.12
  */
 public interface Supplier<T> {
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
index 20c3297..13b781b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodException.java
@@ -5,6 +5,9 @@ import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public class NdMethodException extends NdNode {
 
 	public static final FieldManyToOne<NdMethod> PARENT;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
index 636b7ea..585ecfe 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
@@ -11,6 +11,9 @@ import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
+/**
+ * @since 3.12
+ */
 public class NdMethodParameter extends NdNode {
 	public static final FieldManyToOne<NdMethod> PARENT;
 	public static final FieldManyToOne<NdTypeSignature> ARGUMENT_TYPE;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
index c21dcfa..ba637b7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdWorkspaceLocation.java
@@ -10,6 +10,7 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
 /**
  * Holds a location in the Eclipse workspace where a given resource was found. Note that a given
  * resource might be mapped to multiple locations in the workspace.
+ * @since 3.12
  */
 public class NdWorkspaceLocation extends NdNode {
 	public static final FieldManyToOne<NdResourceFile> RESOURCE;
commit 46463d3f20edce6713458d6b601d4450ca91cb9f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Feb 24 17:10:10 2016 -0800

    Bug 481796 - Fix ClassFile.getJarBinaryFile when requesting nonexistent types
    
    The method now returns null when requesting a nonexistent type.
    
    Change-Id: I05d6050830197b26a48ca746d1a46e4d5024a2e0
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

22	9	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index c2e4812..01c05ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -14,12 +14,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IFolder;
@@ -44,12 +38,19 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
+import org.eclipse.jdt.internal.core.nd.java.NdType;
 import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Util;
 
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
 /**
  * @see IClassFile
  */
@@ -388,9 +389,21 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 						String entryName = Util.concatWith(pkg.names, getElementName(), '/');
 						String indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
 
-						return new IndexBinaryType(
-								TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor),
-								indexPath.toCharArray());
+						TypeRef typeRef = TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor);
+
+						NdType type = typeRef.get();
+
+						if (type == null) {
+							return null;
+						}
+
+						IndexBinaryType result = new IndexBinaryType(typeRef, indexPath.toCharArray());
+
+						// We already have the database lock open and have located the element, so we may as well
+						// prefetch the inexpensive attributes.
+						result.initSimpleAttributes();
+
+						return result;
 					}
 				}
 			} catch (IndexException e) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index b8fd78e..04938fb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -624,7 +624,7 @@ public class IndexBinaryType implements IBinaryType {
 		}
 	}
 
-	private void initSimpleAttributes() {
+	public void initSimpleAttributes() {
 		if (!this.simpleAttributesInitialized) {
 			this.simpleAttributesInitialized = true;
 
commit dcbf9c021d76afbc2be463085c3cc49319d6f7ed
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Feb 24 20:40:54 2016 -0800

    Bug 481796 - Remove some exhaustive searches from HierarchyResolver
    
    Replace the linear searches with hashmap lookups.
    
    Change-Id: I3d96a8115b63f9da82a66993903b69bd8ad05d40
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

45	11	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
index 8ce5dd1..9278f3b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
@@ -74,6 +74,39 @@ public class HierarchyResolver implements ITypeRequestor {
 	private CompilerOptions options;
 	HierarchyBuilder builder;
 	private ReferenceBinding[] typeBindings;
+	private Map<ReferenceHolder, IGenericType> bindingMap = new HashMap<>();
+
+	private static class ReferenceHolder {
+		private final ReferenceBinding key;
+		private int hashCode;
+
+		public ReferenceHolder(ReferenceBinding key) {
+			this.key = key;
+			this.hashCode = computeHashCode();
+		}
+
+		@Override
+		public int hashCode() {
+			return this.hashCode;
+		}
+
+		private int computeHashCode() {
+			if (this.key.id == TypeIds.NoId) {
+				return System.identityHashCode(this.key);
+			}
+			return this.key.id;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj instanceof ReferenceHolder) {
+				ReferenceHolder refHolder = (ReferenceHolder) obj;
+
+				return TypeBinding.equalsEquals(this.key, refHolder.key);
+			}
+			return false;
+		}
+	}
 
 	private int typeIndex;
 	private IGenericType[] typeModels;
@@ -212,10 +245,9 @@ private IType findSuperClass(IGenericType type, ReferenceBinding typeBinding) {
 				}
 			}
 		}
-		for (int t = this.typeIndex; t >= 0; t--) {
-			if (TypeBinding.equalsEquals(this.typeBindings[t], superBinding)) {
-				return this.builder.getHandle(this.typeModels[t], superBinding);
-			}
+		IGenericType typeModel = this.bindingMap.get(new ReferenceHolder(superBinding));
+		if (typeModel != null) {
+			return this.builder.getHandle(typeModel, superBinding);
 		}
 	}
 	return null;
@@ -291,13 +323,12 @@ private IType[] findSuperInterfaces(IGenericType type, ReferenceBinding typeBind
 			// ensure that the binding corresponds to the interface defined by the user
 			if (CharOperation.equals(simpleName, interfaceBinding.sourceName)) {
 				bindingIndex++;
-				for (int t = this.typeIndex; t >= 0; t--) {
-					if (TypeBinding.equalsEquals(this.typeBindings[t], interfaceBinding)) {
-						IType handle = this.builder.getHandle(this.typeModels[t], interfaceBinding);
-						if (handle != null) {
-							superinterfaces[index++] = handle;
-							continue next;
-						}
+				IGenericType genericType = this.bindingMap.get(new ReferenceHolder(interfaceBinding));
+				if (genericType != null) {
+					IType handle = this.builder.getHandle(genericType, interfaceBinding);
+					if (handle != null) {
+						superinterfaces[index++] = handle;
+						continue next;
 					}
 				}
 			}
@@ -393,6 +424,7 @@ private void remember(IGenericType suppliedType, ReferenceBinding typeBinding) {
 	}
 	this.typeModels[this.typeIndex] = suppliedType;
 	this.typeBindings[this.typeIndex] = typeBinding;
+	this.bindingMap.put(new ReferenceHolder(typeBinding), suppliedType);
 }
 private void remember(IType type, ReferenceBinding typeBinding) {
 	if (((CompilationUnit)type.getCompilationUnit()).isOpen()) {
@@ -582,6 +614,7 @@ private void reset(){
 	this.typeIndex = -1;
 	this.typeModels = new IGenericType[5];
 	this.typeBindings = new ReferenceBinding[5];
+	this.bindingMap.clear();
 }
 
 /**
@@ -868,6 +901,7 @@ private void setEnvironment(LookupEnvironment lookupEnvironment, HierarchyBuilde
 	this.typeIndex = -1;
 	this.typeModels = new IGenericType[5];
 	this.typeBindings = new ReferenceBinding[5];
+	this.bindingMap.clear();
 }
 
 /*
commit 5bda4c2d2b989a76ab843a3bd550def12013579f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Feb 24 20:42:11 2016 -0800

    Bug 481796 - Stop recording the last read access time
    
    Nothing was using the last access time, so stop computing it.
    
    Change-Id: I1071ffebc1523867887753c3794cc107b3beb15f
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index 9a7efb8..ee63f4d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -216,7 +216,7 @@ public class Nd {
 	private int lockCount;
 	private int waitingReaders;
 	private long lastWriteAccess= 0;
-	private long lastReadAccess= 0;
+	//private long lastReadAccess= 0;
 	private long timeWriteLockAcquired;
 
 	public IReader acquireReadLock() {
@@ -254,7 +254,7 @@ public class Nd {
 				decReadLock(this.fLockDebugging);
 			}
 
-			this.lastReadAccess= System.currentTimeMillis();
+			//this.lastReadAccess= System.currentTimeMillis();
 			if (this.lockCount > 0)
 				--this.lockCount;
 			this.mutex.notifyAll();
@@ -266,7 +266,7 @@ public class Nd {
 		// pinned to memory.
 		// TODO(sprigogin): It would be more efficient to replace the global result cache with
 		// separate caches for each AST.
-		clearResultCache();
+		//clearResultCache();
 	}
 
 	/**
@@ -372,9 +372,9 @@ public class Nd {
 		return this.lastWriteAccess;
 	}
 
-	public long getLastReadAccess() {
-		return this.lastReadAccess;
-	}
+//	public long getLastReadAccess() {
+//		return this.lastReadAccess;
+//	}
 
 	public boolean isSupportedVersion() throws IndexException {
 		final int version = this.db.getVersion();
commit f7fd749ae9dddc4df41b9f8745a12c01375b55e1
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Feb 24 21:41:08 2016 -0800

    Bug 481796 - Remove the exhaustive search in TypeVector.contains
    
    Once the type vector grows beyond a certain minimum number of elements,
    create a hashmap that allows rapid lookups.
    
    Change-Id: I19fc61becaf70c649b07a39ebc32517c5a879c1d
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/TypeVector.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/TypeVector.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/TypeVector.java
index 8489d2c..7084588 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/TypeVector.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/TypeVector.java
@@ -15,6 +15,10 @@ import java.util.HashMap;
 
 import org.eclipse.jdt.core.IType;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+
 public final class TypeVector {
 	static int INITIAL_SIZE = 10;
 	static int MIN_ELEMENTS_FOR_HASHSET = 8;
commit 44b981802ccef0d64abae1bc30a491691984adae
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 25 15:07:12 2016 -0800

    Bug 481796 - Make BinaryType lazy
    
    Don't precache all the attributes of IBinaryType
    
    Change-Id: I41a8e59ae60052fae182e932abfcdc25fa06e82b
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

55	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
34	84	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
23	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
24	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
20	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeDescriptor.java
167	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
21	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
index a2ced80..ad9db5d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
@@ -10,15 +10,28 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
-import java.io.InputStream;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-
 import org.eclipse.core.runtime.Assert;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
-import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.core.CompletionRequestor;
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.ICompletionRequestor;
+import org.eclipse.jdt.core.IField;
+import org.eclipse.jdt.core.IInitializer;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeHierarchy;
+import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.IWorkingCopy;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.SearchEngine;
 import org.eclipse.jdt.internal.codeassist.CompletionEngine;
@@ -30,10 +43,19 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.JavaModelManager.PerProjectInfo;
 import org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy;
+import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeDescriptor;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory.NotInIndexException;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Messages;
 import org.eclipse.jdt.internal.core.util.Util;
 
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+
 /**
  * Parent is an IClassFile.
  *
@@ -48,6 +70,7 @@ public class BinaryType extends BinaryMember implements IType, SuffixConstants {
 	private static final IType[] NO_TYPES = new IType[0];
 	private static final IInitializer[] NO_INITIALIZERS = new IInitializer[0];
 	public static final JavadocContents EMPTY_JAVADOC = new JavadocContents(null, org.eclipse.jdt.internal.compiler.util.Util.EMPTY_STRING);
+	private IBinaryType cachedBinaryType;
 
 protected BinaryType(JavaElement parent, String name) {
 	super(parent, name);
@@ -284,8 +307,34 @@ public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException
 	JavaModelManager manager = JavaModelManager.getJavaModelManager();
 	Object info = manager.getInfo(this);
 	if (info != null && info != JavaModelCache.NON_EXISTING_JAR_TYPE_INFO) return info;
+
+	if (this.cachedBinaryType != null) {
+		return this.cachedBinaryType;
+	}
+
+	// Check if we can return this type directly from the index
+	if (JavaIndex.isEnabled()) {
+		BinaryTypeDescriptor descriptor = BinaryTypeFactory.createDescriptor(this);
+
+		if (descriptor != null) {
+			IBinaryType result;
+			try {
+				result = BinaryTypeFactory.readFromIndex(descriptor, monitor);
+				this.cachedBinaryType = result;
+				if (result == null) {
+					ClassFile classFile = (ClassFile)getClassFile();
+					throw classFile.newNotPresentException();
+				}
+				return result;
+			} catch (NotInIndexException e) {
+				// Else fall back to openWhenClosed, below
+			}
+		}
+	}
 	return openWhenClosed(createElementInfo(), false, monitor);
 }
+
+
 /*
  * @see IJavaElement
  */
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 01c05ea..8a40f70 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -31,16 +31,10 @@ import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.env.IDependent;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
-import org.eclipse.jdt.internal.core.nd.IReader;
-import org.eclipse.jdt.internal.core.nd.Nd;
-import org.eclipse.jdt.internal.core.nd.db.IndexException;
-import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
-import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
-import org.eclipse.jdt.internal.core.nd.java.NdType;
-import org.eclipse.jdt.internal.core.nd.java.TypeRef;
-import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
+import org.eclipse.jdt.internal.core.nd.java.JavaNames;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeDescriptor;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -363,87 +357,43 @@ public byte[] getBytes() throws JavaModelException {
 	}
 }
 
+public String getName() {
+	return this.name;
+}
+
 private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyInitialize) throws CoreException, IOException, ClassFormatException {
-	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
-	// If the new index is enabled, check if we have this class file cached in the index already
-	if (JavaIndex.isEnabled()) {
-		IPath location = JavaIndex.getLocationForElement(pkg.getParent());
-		JavaIndex index = JavaIndex.getIndex();
-		Nd nd = index.getNd();
-
-		// We don't currently cache package-info files in the index
-		if (location != null && !this.name.equals("package-info")) { //$NON-NLS-1$
-			String locationString = location.toString();
-			// Acquire a read lock on the index
-			try (IReader lock = nd.acquireReadLock()) {
-				NdResourceFile file = index.getResourceFile(locationString);
-
-				if (file != null && file.isDoneIndexing()) {
-					// If this file is in the index and its fingerprint matches the content most recently indexed
-					// then read our result from the index
-					if (file.getFingerprint().test(location.toFile(), null).matches()) {
-						char[] fieldDescriptor = CharArrayUtils.concat(new char[] { 'L' },
-								Util.concatWith(pkg.names, this.name, '/').toCharArray(),
-								new char[] { ';' });
-
-						String entryName = Util.concatWith(pkg.names, getElementName(), '/');
-						String indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
-
-						TypeRef typeRef = TypeRef.create(nd, locationString.toCharArray(), fieldDescriptor);
-
-						NdType type = typeRef.get();
-
-						if (type == null) {
-							return null;
-						}
-
-						IndexBinaryType result = new IndexBinaryType(typeRef, indexPath.toCharArray());
-
-						// We already have the database lock open and have located the element, so we may as well
-						// prefetch the inexpensive attributes.
-						result.initSimpleAttributes();
-
-						return result;
-					}
-				}
-			} catch (IndexException e) {
-				// Index corrupted. Rebuild it.
-				index.rebuildIndex();
-			}
-		}
+	BinaryTypeDescriptor descriptor = BinaryTypeFactory.createDescriptor(pkg, this);
+
+	if (descriptor == null) {
+		return null;
 	}
 
-	ZipFile zip = null;
-	ZipFile annotationZip = null;
-	try {
-		zip = root.getJar();
-		String entryName = Util.concatWith(pkg.names, getElementName(), '/');
-		ZipEntry ze = zip.getEntry(entryName);
-		if (ze != null) {
-			byte contents[] = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
-			String fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
-			ClassFileReader reader = new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
-			if (root.getKind() == IPackageFragmentRoot.K_BINARY) {
-				JavaProject javaProject = (JavaProject) getAncestor(IJavaElement.JAVA_PROJECT);
-				IClasspathEntry entry = javaProject.getClasspathEntryFor(getPath());
-				if (entry != null) {
-					IProject project = javaProject.getProject();
-					IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project, false); // unresolved for use in ExternalAnnotationTracker
-					if (externalAnnotationPath != null) {
-						setupExternalAnnotationProvider(project, externalAnnotationPath, annotationZip, reader,
-								entryName.substring(0, entryName.length() - SuffixConstants.SUFFIX_CLASS.length));
-					} else if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
-						reader.markAsFromSource();
-					}
-				}
+	IBinaryType type = BinaryTypeFactory.readType(descriptor, fullyInitialize, null);
+
+	// TODO(sxenos): setup the external annotation provider if the IBinaryType came from the index
+	// TODO(sxenos): the old code always passed null as the third argument to setupExternalAnnotationProvider,
+	// but this looks like a bug. I've preserved it for now but we need to figure out what was supposed to go
+	// there.
+	if (type instanceof ClassFileReader) {
+		ClassFileReader reader = (ClassFileReader) type;
+
+		JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
+		if (root.getKind() == IPackageFragmentRoot.K_BINARY) {
+			JavaProject javaProject = (JavaProject) getAncestor(IJavaElement.JAVA_PROJECT);
+			IClasspathEntry entry = javaProject.getClasspathEntryFor(getPath());
+			if (entry != null) {
+				String entryName = new String(CharArrayUtils.concat(
+						JavaNames.fieldDescriptorToBinaryName(descriptor.fieldDescriptor), SuffixConstants.SUFFIX_CLASS));
+				IProject project = javaProject.getProject();
+				IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project, false); // unresolved for use in ExternalAnnotationTracker
+				if (externalAnnotationPath != null)
+					setupExternalAnnotationProvider(project, externalAnnotationPath, null, reader,
+							entryName.substring(0, entryName.length() - SuffixConstants.SUFFIX_CLASS.length));
 			}
-			return reader;
 		}
-	} finally {
-		JavaModelManager.getJavaModelManager().closeZipFile(zip);
-		JavaModelManager.getJavaModelManager().closeZipFile(annotationZip);
 	}
-	return null;
+
+	return type;
 }
 
 private void setupExternalAnnotationProvider(IProject project, final IPath externalAnnotationPath,
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index 09b4b8a..f68c813 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -587,7 +587,7 @@ public class ClassFileToIndexConverter {
 				char[] nestedFieldDescriptor = null;
 				if (fieldDescriptorIfVariable != null && fieldDescriptorIfVariable.length > 0
 						&& fieldDescriptorIfVariable[0] == '[') {
-					nestedFieldDescriptor = CharArrayUtils.substring(fieldDescriptorIfVariable, 1);
+					nestedFieldDescriptor = CharArrayUtils.subarray(fieldDescriptorIfVariable, 1);
 				}
 				// Determine the array argument type
 				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), genericSignature,
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 954f87c..1505b3a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -147,7 +147,7 @@ public final class Indexer {
 
 			this.pdom.acquireWriteLock(iterationMonitor.split(1));
 			try {
-				NdResourceFile resourceFile = index.getResourceFile(entry.getKey().toString());
+				NdResourceFile resourceFile = index.getResourceFile(entry.getKey().toString().toCharArray());
 				if (resourceFile == null) {
 					continue;
 				}
@@ -542,7 +542,7 @@ public final class Indexer {
 		FileFingerprint fingerprint = FileFingerprint.getEmpty();
 		this.pdom.acquireReadLock();
 		try {
-			NdResourceFile resourceFile = javaIndex.getResourceFile(pathString);
+			NdResourceFile resourceFile = javaIndex.getResourceFile(pathString.toCharArray());
 
 			if (resourceFile != null) {
 				fingerprint = resourceFile.getFingerprint();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index faf7c7f..89184c9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -10,10 +10,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
-import java.io.File;
-import java.util.List;
-
 import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
@@ -27,8 +25,11 @@ import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.IResultRank;
 import org.eclipse.jdt.internal.core.nd.field.FieldSearchIndex.SearchCriteria;
-import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
+
+import java.io.File;
+import java.util.List;
 
 /**
  * @since 3.12
@@ -90,11 +91,27 @@ public class JavaIndex {
 	/**
 	 * Returns the most-recently-scanned resource file with the given name or null if none
 	 */
-	public NdResourceFile getResourceFile(String thePath) {
-		return FILES.findBest(this.pdom, this.address, FieldSearchIndex.SearchCriteria.create(thePath.toCharArray()),
+	public NdResourceFile getResourceFile(char[] location) {
+		return FILES.findBest(this.pdom, this.address, FieldSearchIndex.SearchCriteria.create(location),
 				bestResourceFile);
 	}
 
+	/**
+	 * Returns true iff the given resource file is up-to-date with the filesystem.
+	 * @throws CoreException 
+	 */
+	public boolean isUpToDate(char[] location) throws CoreException {
+		// Acquire a read lock on the index
+		NdResourceFile file = getResourceFile(location);
+		if (file != null && file.isDoneIndexing()) {
+			File locationFile = new File(new String(location));
+			if (file.getFingerprint().test(locationFile, null).matches()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
 	public List<NdResourceFile> getAllResourceFiles(String thePath) {
 		return FILES.findAll(this.pdom, this.address, FieldSearchIndex.SearchCriteria.create(thePath.toCharArray()));
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
index d4e662a..2b5b8fe 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaNames.java
@@ -26,7 +26,7 @@ public class JavaNames {
 				Math.max(CharOperation.lastIndexOf('$', binaryName), CharOperation.lastIndexOf('.', binaryName)),
 				CharOperation.lastIndexOf('/', binaryName)) + 1;
 
-		return CharArrayUtils.substring(binaryName, skipIndex);
+		return CharArrayUtils.subarray(binaryName, skipIndex);
 	}
 
 	/**
@@ -76,6 +76,28 @@ public class JavaNames {
 	}
 
 	/**
+	 * Converts a field descriptor to a simple class name. Returns null if the given field descriptor
+	 * doesn't refer to a class or is badly-formed.
+	 */
+	public static char[] fieldDescriptorToSimpleName(char[] fieldDescriptor) {
+		if (!CharArrayUtils.startsWith(fieldDescriptor, 'L')) {
+			return null;
+		}
+
+		if (!CharArrayUtils.endsWith(fieldDescriptor, ';')) {
+			return null;
+		}
+
+		int separatorPosition = CharArrayUtils.lastIndexOf('/', fieldDescriptor);
+		if (separatorPosition == -1) {
+			separatorPosition = 0;
+		}
+
+		char[] className = CharArrayUtils.subarray(fieldDescriptor, separatorPosition + 1, fieldDescriptor.length - 1);
+		return className;
+	}
+	
+	/**
 	 * Converts a field descriptor to a java name. If fullyQualified is true, it returns a fully qualified class name.
 	 * If it is false, it returns a source name.
 	 */
@@ -168,7 +190,7 @@ public class JavaNames {
 		while (startPosition < chars.length && Character.isDigit(chars[startPosition])) {
 			startPosition++;
 		}
-		return CharArrayUtils.substring(chars, startPosition);
+		return CharArrayUtils.subarray(chars, startPosition);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeDescriptor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeDescriptor.java
new file mode 100644
index 0000000..7ec5c8c
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeDescriptor.java
@@ -0,0 +1,20 @@
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+/**
+ * Holds a lightweight identifier for an IBinaryType, with sufficient information to either read it from
+ * disk or read it from the index.
+ */
+public final class BinaryTypeDescriptor {
+	public final char[] indexPath;
+	public final char[] fieldDescriptor;
+	public final char[] location;
+	public final char[] workspacePath;
+
+	public BinaryTypeDescriptor(char[] location, char[] fieldDescriptor, char[] workspacePath, char[] indexPath) {
+		super();
+		this.location = location;
+		this.fieldDescriptor = fieldDescriptor;
+		this.indexPath = indexPath;
+		this.workspacePath = workspacePath;
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
index c5446d4..19c61a7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -1,13 +1,80 @@
 package org.eclipse.jdt.internal.core.nd.java.model;
 
+import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.ClassFile;
+import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
+import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.PackageFragment;
+import org.eclipse.jdt.internal.core.nd.IReader;
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
+import org.eclipse.jdt.internal.core.nd.java.NdType;
 import org.eclipse.jdt.internal.core.nd.java.TypeRef;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
+import org.eclipse.jdt.internal.core.util.Util;
+
+import java.io.IOException;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 
 public class BinaryTypeFactory {
+
+	public static final class NotInIndexException extends Exception {
+		private static final long serialVersionUID = 2859848007651528256L;
+
+		public NotInIndexException() {
+		}
+	}
+	
+	private final static char[] PACKAGE_INFO = "package-info".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * Returns a descriptor for the given class within the given package fragment, or null if the fragment doesn't have
+	 * a location on the filesystem.
+	 */
+	public static BinaryTypeDescriptor createDescriptor(PackageFragment pkg, ClassFile classFile) {
+		String name = classFile.getName();
+		JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
+		IPath location = JavaIndex.getLocationForElement(root);
+		String entryName = Util.concatWith(pkg.names, classFile.getElementName(), '/');
+		char[] fieldDescriptor = CharArrayUtils.concat(new char[] { 'L' },
+				Util.concatWith(pkg.names, name, '/').toCharArray(), new char[] { ';' });
+		String indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
+
+		if (location == null) {
+			return null;
+		}
+
+		return new BinaryTypeDescriptor(location.toString().toCharArray(), fieldDescriptor,
+				root.getPath().toString().toCharArray(), indexPath.toCharArray());
+	}
+
+	public static BinaryTypeDescriptor createDescriptor(IType type) {
+		IPackageFragment packageFragment = type.getPackageFragment();
+		IClassFile classFile = type.getClassFile();
+		if (classFile instanceof ClassFile && packageFragment instanceof PackageFragment) {
+			return createDescriptor((PackageFragment)packageFragment, (ClassFile)classFile);
+		}
+		return null;
+	}
+
 	public static IBinaryType create(IJavaElement javaElement, String binaryName) {
 		IPath filesystemLocation = JavaIndex.getLocationForElement(javaElement);
 
@@ -19,4 +86,104 @@ public class BinaryTypeFactory {
 		char[] indexPath = (javaElement.getPath().toString() + "|" + binaryName + ".class").toCharArray(); //$NON-NLS-1$//$NON-NLS-2$
 		return new IndexBinaryType(typeRef, indexPath);
 	}
+
+	/**
+	 * Reads the given binary type. If the type can be found in the index with a fingerprint that exactly matches
+	 * the file on disk, the type is read from the index. Otherwise the type is read from disk. Returns null if
+	 * no such type exists.
+	 */
+	public static IBinaryType readType(BinaryTypeDescriptor descriptor, boolean fullyInitialize,
+			IProgressMonitor monitor) throws JavaModelException {
+		
+		if (JavaIndex.isEnabled()) {
+			try {
+				return readFromIndex(descriptor, monitor);
+			} catch (NotInIndexException e) {
+				// fall back to reading the zip file, below
+			}
+		}
+
+		ZipFile zip = null;
+		try {
+			zip = JavaModelManager.getJavaModelManager().getZipFile(new Path(new String(descriptor.workspacePath)));
+			char[] entryNameCharArray = CharArrayUtils.concat(
+					JavaNames.fieldDescriptorToBinaryName(descriptor.fieldDescriptor), SuffixConstants.SUFFIX_class);
+			String entryName = new String(entryNameCharArray);
+			ZipEntry ze = zip.getEntry(entryName);
+			if (ze != null) {
+				byte contents[];
+				try {
+					contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
+				} catch (IOException ioe) {
+					throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
+				}
+				ClassFileReader reader;
+				try {
+					reader = new ClassFileReader(contents, descriptor.indexPath, fullyInitialize);
+				} catch (ClassFormatException e) {
+					if (JavaCore.getPlugin().isDebugging()) {
+						e.printStackTrace(System.err);
+					}
+					return null;
+				}
+				return reader;
+			}
+		} catch (CoreException e) {
+			throw new JavaModelException(e);
+		} finally {
+			JavaModelManager.getJavaModelManager().closeZipFile(zip);
+		}
+		return null;
+	}
+
+	/**
+	 * Tries to read the given IBinaryType from the index. The return value is lightweight and may be cached
+	 * with minimal memory cost. Returns an IBinaryType if the type was found in the index and the index
+	 * was up-to-date. Throws a NotInIndexException if the index does not contain an up-to-date cache of the
+	 * requested file. Returns null if the index contains an up-to-date cache of the requested file and it was
+	 * able to determine that the requested class does not exist in that file.
+	 */
+	public static IBinaryType readFromIndex(BinaryTypeDescriptor descriptor, IProgressMonitor monitor) throws JavaModelException, NotInIndexException {
+		char[] className = JavaNames.fieldDescriptorToSimpleName(descriptor.fieldDescriptor);
+
+		// If the new index is enabled, check if we have this class file cached in the index already		
+		char[] fieldDescriptor = descriptor.fieldDescriptor;
+		
+		if (!CharArrayUtils.equals(PACKAGE_INFO, className)) {
+			JavaIndex index = JavaIndex.getIndex();
+			Nd nd = index.getNd();
+
+			// We don't currently cache package-info files in the index
+			if (descriptor.location != null) {
+				// Acquire a read lock on the index
+				try (IReader lock = nd.acquireReadLock()) {
+					try {
+						if (index.isUpToDate(descriptor.location)) {
+							TypeRef typeRef = TypeRef.create(nd, descriptor.location, fieldDescriptor);
+							NdType type = typeRef.get();
+
+							if (type == null) {
+								return null;
+							}
+
+							IndexBinaryType result = new IndexBinaryType(typeRef, descriptor.indexPath);
+
+							// We already have the database lock open and have located the element, so we may as
+							// well prefetch the inexpensive attributes.
+							result.initSimpleAttributes();
+
+							return result;
+						}
+					} catch (CoreException e) {
+						throw new JavaModelException(e);
+					}
+				} catch (IndexException e) {
+					// Index corrupted. Rebuild it.
+					index.rebuildIndex();
+				}
+			}
+		}
+		
+		throw new NotInIndexException();
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 04938fb..ed335f0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -636,7 +636,7 @@ public class IndexBinaryType implements IBinaryType {
 					if (methodId != null) {
 						char[] methodName = methodId.getMethodName().getChars();
 						int startIdx = CharArrayUtils.lastIndexOf('#', methodName);
-						this.enclosingMethod = CharArrayUtils.substring(methodName, startIdx + 1);
+						this.enclosingMethod = CharArrayUtils.subarray(methodName, startIdx + 1);
 						this.enclosingType = CharArrayUtils.subarray(methodName, 1, startIdx);
 					} else {
 						NdTypeId typeId = type.getDeclaringType();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
index b0342f6..ac8a810 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/util/CharArrayUtils.java
@@ -84,8 +84,19 @@ public class CharArrayUtils {
 	}
 
 	/**
-	 * Returns {@code true} if the contents of a section of a character array are the same as
-	 * contents of a string.
+	 * Returns true iff the given array contains the given char at the given position
+	 */
+	public static final boolean hasCharAt(char toLookFor, int position, char[] toSearch) {
+		if (toSearch.length <= position) {
+			return false;
+		}
+
+		return toSearch[position] == toLookFor;
+	}
+
+	/**
+	 * Returns {@code true} if the contents of a section of a character array are the same as contents of a string.
+	 * 
 	 * @since 5.5
 	 */
 	public static final boolean equals(char[] str1, int start1, int length1, String str2) {
@@ -480,7 +491,7 @@ public class CharArrayUtils {
 		return result;
 	}
 
-	public static char[] substring(char[] inputString, int index) {
+	public static char[] subarray(char[] inputString, int index) {
 		if (inputString.length <= index) {
 			return EMPTY_CHAR_ARRAY;
 		}
@@ -503,4 +514,11 @@ public class CharArrayUtils {
 		}
 		return contents;
 	}
+
+	public static boolean endsWith(char[] fieldDescriptor, char c) {
+		if (fieldDescriptor.length == 0) {
+			return false;
+		}
+		return fieldDescriptor[fieldDescriptor.length - 1] == c;
+	}
 }
commit 890073b410e2973363398cdd826c5e27c9eff174
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 25 15:31:59 2016 -0800

    Bug 481796 - Temporarily disable the checks for the index being up-to-date
    
    We're going to replace this with a more efficient mechanism later, and
    we don't want this temporary approach interfering with benchmarks.
    
    Change-Id: Ic82c9b4a40ad4f3a19c83212e2d3f8263310f1c2
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

9	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 89184c9..a6a9a5a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -104,10 +104,15 @@ public class JavaIndex {
 		// Acquire a read lock on the index
 		NdResourceFile file = getResourceFile(location);
 		if (file != null && file.isDoneIndexing()) {
-			File locationFile = new File(new String(location));
-			if (file.getFingerprint().test(locationFile, null).matches()) {
-				return true;
-			}
+			return true;
+			// TODO(sxenos): uncomment this after EclipseCon, then replace it with a more efficient
+			// mechanism for determining if the index matches the file system. Perhaps some sort of
+			// explicit callback that JDT can invoke whenever it writes a .class or .jar file?
+
+//			File locationFile = new File(new String(location));
+//			if (file.getFingerprint().test(locationFile, null).matches()) {
+//				return true;
+//			}
 		}
 		return false;
 	}
commit 0843580f924cca72ce4a0ecd5b81e4ae52a98da7
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Feb 25 16:24:37 2016 -0800

    Bug 481796 - Replace usage of the JDK File with EFS.
    
    Change-Id: I113be506d4257602e45fd84bfa744d01b0ec2f07
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
16	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 1505b3a..4c71455 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -551,7 +551,7 @@ public final class Indexer {
 			this.pdom.releaseReadLock();
 		}
 
-		return fingerprint.test(thePath.toFile(), subMonitor.split(50));
+		return fingerprint.test(thePath, subMonitor.split(50));
 	}
 
 	public Indexer(Nd toPopulate, IWorkspaceRoot workspaceRoot) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
index 830936f..be5bdf5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/FileFingerprint.java
@@ -1,16 +1,20 @@
 package org.eclipse.jdt.internal.core.nd.java;
 
+import org.eclipse.core.filesystem.EFS;
+import org.eclipse.core.filesystem.IFileInfo;
+import org.eclipse.core.filesystem.IFileStore;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.jdt.internal.core.nd.StreamHasher;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
-import org.eclipse.jdt.internal.core.nd.StreamHasher;
-
 /**
  * @since 3.12
  */
@@ -100,12 +104,15 @@ public class FileFingerprint {
 	/**
 	 * Compares the given File with the receiver. If the fingerprint matches (ie: the file
 	 */
-	public FingerprintTestResult test(File toTest, IProgressMonitor monitor) throws CoreException {
+	public FingerprintTestResult test(IPath path, IProgressMonitor monitor) throws CoreException {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
-		long lastModified = toTest.lastModified();
+		IFileStore store = EFS.getLocalFileSystem().getStore(path);
+		IFileInfo fileInfo = store.fetchInfo();
+
+		long lastModified = fileInfo.getLastModified();
 		subMonitor.split(5);
 
-		long fileSize = toTest.length();
+		long fileSize = fileInfo.getLength();
 		subMonitor.split(5);
 		if (lastModified == this.time && fileSize == this.size) {
 			return new FingerprintTestResult(true, false, this);
@@ -113,7 +120,7 @@ public class FileFingerprint {
 
 		long hashCode;
 		try {
-			hashCode = computeHashCode(toTest, fileSize, subMonitor.split(90));
+			hashCode = computeHashCode(path.toFile(), fileSize, subMonitor.split(90));
 		} catch (IOException e) {
 			throw new CoreException(Package.createStatus("An error occurred computing a hash code", e)); //$NON-NLS-1$
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index a6a9a5a..cd8762d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -109,8 +109,8 @@ public class JavaIndex {
 			// mechanism for determining if the index matches the file system. Perhaps some sort of
 			// explicit callback that JDT can invoke whenever it writes a .class or .jar file?
 
-//			File locationFile = new File(new String(location));
-//			if (file.getFingerprint().test(locationFile, null).matches()) {
+//			Path locationPath = new Path(new String(location));
+//			if (file.getFingerprint().test(locationPath, null).matches()) {
 //				return true;
 //			}
 		}
commit 4fc109c95282c8997769f14fef6967a6bc4ee27b
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Mar 2 09:41:05 2016 -0800

    Bug 481796 - Optimizations for readFromIndex
    
    Change the order of checks in order to reduce
    the number of index searches. Search for the type
    id before searching for the resource since - if
    we find the type itself - we can follow a pointer
    to the resource rather than performing a second
    search for it.
    
    Change-Id: I3ee0fc4e8169d76ba6c93ec6452cd1997f4feddf
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

5	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
16	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index cd8762d..c374e48 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -97,12 +97,13 @@ public class JavaIndex {
 	}
 
 	/**
-	 * Returns true iff the given resource file is up-to-date with the filesystem.
+	 * Returns true iff the given resource file is up-to-date with the filesystem. Returns false
+	 * if the argument is out-of-date with the file system or null.
+	 * 
+	 * @param file the index file to look up or null
 	 * @throws CoreException 
 	 */
-	public boolean isUpToDate(char[] location) throws CoreException {
-		// Acquire a read lock on the index
-		NdResourceFile file = getResourceFile(location);
+	public boolean isUpToDate(NdResourceFile file) throws CoreException {
 		if (file != null && file.isDoneIndexing()) {
 			return true;
 			// TODO(sxenos): uncomment this after EclipseCon, then replace it with a more efficient
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
index 19c61a7..6c5b288 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -25,6 +25,7 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
+import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
 import org.eclipse.jdt.internal.core.nd.java.NdType;
 import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
@@ -148,7 +149,7 @@ public class BinaryTypeFactory {
 
 		// If the new index is enabled, check if we have this class file cached in the index already		
 		char[] fieldDescriptor = descriptor.fieldDescriptor;
-		
+
 		if (!CharArrayUtils.equals(PACKAGE_INFO, className)) {
 			JavaIndex index = JavaIndex.getIndex();
 			Nd nd = index.getNd();
@@ -158,14 +159,22 @@ public class BinaryTypeFactory {
 				// Acquire a read lock on the index
 				try (IReader lock = nd.acquireReadLock()) {
 					try {
-						if (index.isUpToDate(descriptor.location)) {
-							TypeRef typeRef = TypeRef.create(nd, descriptor.location, fieldDescriptor);
-							NdType type = typeRef.get();
+						TypeRef typeRef = TypeRef.create(nd, descriptor.location, fieldDescriptor);
+						NdType type = typeRef.get();
+
+						if (type == null) {
+							// If we couldn't find the type in the index, determine whether the cause is
+							// that the type is known not to exist or whether the resource just hasn't
+							// been indexed yet
 
-							if (type == null) {
+							NdResourceFile resourceFile = index.getResourceFile(descriptor.location);
+							if (index.isUpToDate(resourceFile)) {
 								return null;
 							}
-
+							throw new NotInIndexException();
+						}
+						NdResourceFile resourceFile = type.getResourceFile();
+						if (index.isUpToDate(resourceFile)) {
 							IndexBinaryType result = new IndexBinaryType(typeRef, descriptor.indexPath);
 
 							// We already have the database lock open and have located the element, so we may as
@@ -174,6 +183,7 @@ public class BinaryTypeFactory {
 
 							return result;
 						}
+						throw new NotInIndexException();
 					} catch (CoreException e) {
 						throw new JavaModelException(e);
 					}
commit e672313be6ab9c9193371ae7887be8f214f3621a
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Fri Mar 18 11:30:47 2016 -0700

    Bug 481796 - Re-enable staleness checks for resource files
    
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

11	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index c374e48..1ce5bf7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -105,15 +105,17 @@ public class JavaIndex {
 	 */
 	public boolean isUpToDate(NdResourceFile file) throws CoreException {
 		if (file != null && file.isDoneIndexing()) {
-			return true;
-			// TODO(sxenos): uncomment this after EclipseCon, then replace it with a more efficient
-			// mechanism for determining if the index matches the file system. Perhaps some sort of
-			// explicit callback that JDT can invoke whenever it writes a .class or .jar file?
-
-//			Path locationPath = new Path(new String(location));
-//			if (file.getFingerprint().test(locationPath, null).matches()) {
-//				return true;
-//			}
+			// TODO(sxenos): It would be much more efficient to mark files as being in one
+			// of three states: unknown, dirty, or clean. Files would start in the unknown
+			// state and move into the dirty state when we see them in a java model change
+			// event. They would move into the clean state after passing this sort of
+			// fingerprint test... but by caching the state of all tested files (in memory),
+			// it would eliminate the vast majority of these (slow) fingerprint tests.
+			
+			Path locationPath = new Path(file.getLocation().getString());
+			if (file.getFingerprint().test(locationPath, null).matches()) {
+				return true;
+			}
 		}
 		return false;
 	}
commit 14472d4b311478f20ef6ad99ff42b14895e2f084
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Mar 29 13:08:13 2016 -0700

    Bug 481796 - Proposal for a faster JDT index
    
    Further documentation corrections.
    
    Change-Id: I2924812df8e9c77473a8fdc81d9a44ef4011310b
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 724ba9a..68dd958 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -48,11 +48,11 @@ import com.ibm.icu.text.MessageFormat;
  * 0                    | version number
  * INT_SIZE             | pointer to head of linked list of blocks of size MIN_BLOCK_DELTAS*BLOCK_SIZE_DELTA
  * ..                   | ...
- * INT_SIZE * m (1)     | pointer to head of linked list of blocks of size (m + MIN_BLOCK_DELTAS) * BLOCK_SIZE_DELTA
+ * INT_SIZE * (M + 1)   | pointer to head of linked list of blocks of size (M + MIN_BLOCK_DELTAS) * BLOCK_SIZE_DELTA
  * WRITE_NUMBER_OFFSET  | long integer which is incremented on every write
- * DATA_AREA            | undefined (PDOM stores its own house-keeping data in this area)
+ * DATA_AREA            | The database singletons are stored here and use the remainder of chunk 0
  *
- * (1) where 2 <= m <= CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1
+ * M = CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS
  *
  * ===== block structure (for free/unused blocks)
  *
commit 46fd468d2044e5bb950cda2904924425c677b767
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Mar 31 13:30:51 2016 -0700

    Bug 481796 - Minor cleanup suggested during code review.
    
    Change-Id: I772f123771237851d1ce3705eb963fef1293acbb
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

5	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
index fc4b054..34d81cb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
@@ -124,15 +124,13 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 
 			this.backPointer.remove(nd, oldTargetAddress, oldIndex);
 
-			if (oldTargetAddress != 0) {
-				short targetTypeId = NdNode.NODE_TYPE.get(nd, oldTargetAddress);
+			short targetTypeId = NdNode.NODE_TYPE.get(nd, oldTargetAddress);
 
-				ITypeFactory<T> typeFactory = nd.getTypeFactory(targetTypeId);
+			ITypeFactory<T> typeFactory = nd.getTypeFactory(targetTypeId);
 
-				if (typeFactory.getDeletionSemantics() == StructDef.DeletionSemantics.REFCOUNTED 
-						&& typeFactory.isReadyForDeletion(nd, oldTargetAddress)) {
-					nd.scheduleDeletion(oldTargetAddress);
-				}
+			if (typeFactory.getDeletionSemantics() == StructDef.DeletionSemantics.REFCOUNTED 
+					&& typeFactory.isReadyForDeletion(nd, oldTargetAddress)) {
+				nd.scheduleDeletion(oldTargetAddress);
 			}
 		}
 		TARGET.put(nd, fieldStart, newTargetAddress);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
index 14f1f2c..5d3ad82 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
@@ -24,7 +24,7 @@ import org.eclipse.jdt.internal.core.nd.db.IndexException;
 
 /**
  * Declares a field representing a case-insensitive search tree over elements which are a subtype of NdNode.
- * This field may only ever  
+ *
  * @since 3.12
  */
 public class FieldSearchIndex<T extends NdNode> implements IField, IDestructableField {
