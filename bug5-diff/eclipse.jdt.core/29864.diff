commit 0fb012af3c6557520ab00415c58833602b027192
Author: Jerome lanneluc <jlanneluc>
Date:   Thu Jan 23 16:24:56 2003 +0000

    Fix for bug 29864

15	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
4	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathInitializerTests.java
12	12	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaConventionTests.java
13	13	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElementDeltaTests.java
4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java
437	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyNotificationTests.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
3	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java
22	11	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
20	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
2	15	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
26	33	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
13	12	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index b338681..6512e4e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -337,7 +337,7 @@ protected IJavaProject createJavaProject(final String projectName, final String[
 					if (JavaCore.getClasspathVariable("JCL_LIB") == null) {
 						JavaCore.setClasspathVariables(
 							new String[] {"JCL_LIB", "JCL_SRC", "JCL_SRCROOT"},
-							new Path[] {new Path(getExternalJCLPath()), new Path(getExternalJCLSourcePath()), new Path(getExternalJCLRootSourcePath())},
+							new IPath[] {getExternalJCLPath(), getExternalJCLSourcePath(), getExternalJCLRootSourcePath()},
 							null);
 					}
 				}
@@ -560,22 +560,28 @@ protected IJavaElementDelta getDeltaFor(IJavaElement element, boolean returnFirs
 	return result;
 }
 /**
+ * Returns the IPath to the external java class library (e.g. jclMin.jar)
+ */
+protected IPath getExternalJCLPath() {
+	return new Path(getExternalJCLPathString());
+}
+/**
  * Returns the java.io path to the external java class library (e.g. jclMin.jar)
  */
-protected String getExternalJCLPath() {
+protected String getExternalJCLPathString() {
 	return EXTERNAL_JAR_DIR_PATH + File.separator + "jclMin.jar";
 }
 /**
- * Returns the java.io path to the root source of the external java class library (e.g. "src")
+ * Returns the IPath to the root source of the external java class library (e.g. "src")
  */
-protected String getExternalJCLRootSourcePath() {
-	return "";
+protected IPath getExternalJCLRootSourcePath() {
+	return Path.EMPTY;
 }
 /**
- * Returns the java.io path to the source of the external java class library (e.g. jclMinsrc.zip)
+ * Returns the IPath to the source of the external java class library (e.g. jclMinsrc.zip)
  */
-protected String getExternalJCLSourcePath() {
-	return EXTERNAL_JAR_DIR_PATH + File.separator + "jclMinsrc.zip";
+protected IPath getExternalJCLSourcePath() {
+	return new Path(EXTERNAL_JAR_DIR_PATH + File.separator + "jclMinsrc.zip");
 }
 /**
  * Returns the Java Model this test suite is running on.
@@ -796,7 +802,7 @@ protected IJavaProject setUpJavaProject(final String projectName) throws CoreExc
 	if (JavaCore.getClasspathVariable("JCL_LIB") == null) {
 		JavaCore.setClasspathVariables(
 			new String[] {"JCL_LIB", "JCL_SRC", "JCL_SRCROOT"},
-			new Path[] {new Path(getExternalJCLPath()), new Path(getExternalJCLSourcePath()), new Path(getExternalJCLRootSourcePath())},
+			new IPath[] {getExternalJCLPath(), getExternalJCLSourcePath(), getExternalJCLRootSourcePath()},
 			null);
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index 87716f5..6875e94 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -116,9 +116,12 @@ public static Test suite() {
 	// Variable initializers and container initializers tests
 	suite.addTest(ClasspathInitializerTests.suite());
 
-	//Java Model Factory tests
+	// Java Model Factory tests
 	suite.addTest(FactoryTests.suite());
 			
+	// Java Element persistence tests
+	suite.addTest(MementoTests.suite());
+
 	return suite;
 }
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathInitializerTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathInitializerTests.java
index ff79955..506fe7e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathInitializerTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathInitializerTests.java
@@ -182,8 +182,8 @@ public void testContainerInitializer3() throws CoreException {
 		assertDeltas(
 			"Unexpected delta on startup", 
 			"P2[*]: {CHILDREN}\n" + 
-			"	lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
-			"	lib2.jar[*]: {ADDED TO CLASSPATH}"
+			"	/P1/lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
+			"	/P1/lib2.jar[*]: {ADDED TO CLASSPATH}"
 		);
 	} finally {
 		this.deleteProject("P1");
@@ -413,8 +413,8 @@ public void testVariableInitializer7() throws CoreException {
 		assertDeltas(
 			"Unexpected delta on startup", 
 			"P2[*]: {CHILDREN}\n" + 
-			"	lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
-			"	lib2.jar[*]: {ADDED TO CLASSPATH}"
+			"	/P1/lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
+			"	/P1/lib2.jar[*]: {ADDED TO CLASSPATH}"
 		);
 	} finally {
 		//JavaModelManager.CP_RESOLVE_VERBOSE=false;		
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
index 69898d0..4b8d4be 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
@@ -146,8 +146,8 @@ public void testClasspathChangeExternalResources() throws CoreException {
 		IJavaProject proj = this.createJavaProject("P", new String[] {"src"}, "bin");
 
 		IClasspathEntry[] newEntries = new IClasspathEntry[2];
-		newEntries[0] = JavaCore.newLibraryEntry(new Path(getExternalJCLPath()), null, null, false);
-		newEntries[1] = JavaCore.newLibraryEntry(new Path(getExternalJCLSourcePath()), null, null, false);
+		newEntries[0] = JavaCore.newLibraryEntry(getExternalJCLPath(), null, null, false);
+		newEntries[1] = JavaCore.newLibraryEntry(getExternalJCLSourcePath(), null, null, false);
 		setClasspath(proj, newEntries);
 		startDeltas();
 		IClasspathEntry[] swappedEntries = new IClasspathEntry[2];
@@ -270,9 +270,9 @@ public void testClasspathCreateLibraryEntry() throws CoreException {
 public void testClasspathCreateLocalJarLibraryEntry() throws CoreException {
 	IJavaProject proj = this.createJavaProject("P", new String[] {""}, "");
 	IPackageFragmentRoot root = getPackageFragmentRoot("P", "");
-	IClasspathEntry newEntry= JavaCore.newLibraryEntry(new Path(getExternalJCLPath()), null, null, false);
+	IClasspathEntry newEntry= JavaCore.newLibraryEntry(getExternalJCLPath(), null, null, false);
 	IClasspathEntry[] newEntries= new IClasspathEntry[]{newEntry};
-	IPackageFragmentRoot newRoot= proj.getPackageFragmentRoot(getExternalJCLPath());
+	IPackageFragmentRoot newRoot= proj.getPackageFragmentRoot(getExternalJCLPathString());
 
 	startDeltas();
 	
@@ -329,7 +329,7 @@ public void testClasspathCrossProject() throws CoreException {
  * Delete a root and ensure the classpath is not updated (i.e. entry isn't removed).
  */
 public void testClasspathDeleteNestedRoot() throws CoreException {
-	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPath()}, "bin");
+	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPathString()}, "bin");
 	IPackageFragmentRoot root= getPackageFragmentRoot("P", "nested/src");
 	IClasspathEntry[] originalCP= project.getRawClasspath();
 
@@ -373,7 +373,7 @@ public void testClasspathDiamond() throws CoreException {
  * not updated (i.e. entry isn't removed).
  */
 public void testClasspathDeleteNestedRootParent() throws CoreException {
-	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPath()}, "bin");
+	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPathString()}, "bin");
 	IPackageFragmentRoot root= getPackageFragmentRoot("P", "nested/src");
 	IClasspathEntry[] originalCP= project.getRawClasspath();
 
@@ -400,7 +400,7 @@ public void testClasspathDeleteNestedRootParent() throws CoreException {
  */
 public void testClasspathExternalize() throws CoreException {
 	try {
-		IJavaProject project= this.createJavaProject("P", new String[] {}, new String[] {getExternalJCLPath()}, "");
+		IJavaProject project= this.createJavaProject("P", new String[] {}, new String[] {getExternalJCLPathString()}, "");
 		IClasspathEntry[] classpath= project.getRawClasspath();
 		IClasspathEntry jar= null;
 		for (int i= 0; i < classpath.length; i++) {
@@ -427,7 +427,7 @@ public void testClasspathExternalize() throws CoreException {
  * Move a root and ensure the classpath is not updated (i.e. entry not renamed).
  */
 public void testClasspathMoveNestedRoot() throws CoreException {
-	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPath()}, "bin");
+	IJavaProject project = this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPathString()}, "bin");
 	IPackageFragmentRoot root= getPackageFragmentRoot("P", "nested/src");
 	IClasspathEntry[] originalCP= project.getRawClasspath();
 
@@ -469,7 +469,7 @@ public void testClasspathMoveNestedRoot() throws CoreException {
  */
 public void testClasspathMoveNestedRootParent() throws CoreException {
 	try {
-		IJavaProject project =this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPath()}, "bin");
+		IJavaProject project =this.createJavaProject("P", new String[] {"nested/src"}, new String[] {getExternalJCLPathString()}, "bin");
 		IPackageFragmentRoot root= getPackageFragmentRoot("P", "nested/src");
 		IClasspathEntry[] originalCP= project.getRawClasspath();
 	
@@ -527,7 +527,7 @@ public void testClasspathNoChanges() throws CoreException {
  * the correct deltas.
  */
 public void testClasspathReordering() throws CoreException {
-	IJavaProject proj = this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPath()}, "bin");
+	IJavaProject proj = this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPathString()}, "bin");
 	IClasspathEntry[] originalCP = proj.getRawClasspath();
 	IPackageFragmentRoot root = getPackageFragmentRoot("P", "src");
 	try {
@@ -1214,7 +1214,7 @@ public void testExportContainer() throws CoreException {
 				new TestContainer(
 					new Path("container/default"),
 					new IClasspathEntry[] {
-						JavaCore.newLibraryEntry(new Path(getExternalJCLPath()), null, null)
+						JavaCore.newLibraryEntry(getExternalJCLPath(), null, null)
 					}) 
 			}, 
 			null);
@@ -1230,7 +1230,7 @@ public void testExportContainer() throws CoreException {
 		// ensure container is exported to P2
 		assertEquals("Unexpected number of classpath entries", 2, classpath.length);
 		assertEquals("Unexpected first entry", "/P1", classpath[0].getPath().toString());
-		assertEquals("Unexpected second entry", getExternalJCLPath(), classpath[1].getPath().toOSString());
+		assertEquals("Unexpected second entry", getExternalJCLPathString(), classpath[1].getPath().toOSString());
 	} finally {
 		this.deleteProject("P1");
 		this.deleteProject("P2");
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
index 0deae72..8f4a585 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
@@ -25,7 +25,7 @@ public CompilationUnitTests(String name) {
 public void setUpSuite() throws Exception {
 	super.setUpSuite();
 	
-	this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPath()}, "bin");
+	this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPathString()}, "bin");
 	this.createFolder("/P/src/p");
 	this.createFile(
 		"/P/src/p/X.java",
@@ -342,7 +342,7 @@ public void testNotPresent1() {
  * (regression test for PR #1G2RKD2)
  */
 public void testNotPresent2() throws CoreException {
-	ICompilationUnit cu = getPackageFragment("P", getExternalJCLPath(), "java.lang").getCompilationUnit("DoesNotExist.java");
+	ICompilationUnit cu = getPackageFragment("P", getExternalJCLPathString(), "java.lang").getCompilationUnit("DoesNotExist.java");
 	assertTrue("CU should not be open", !cu.isOpen());
 	assertTrue("CU should not exist", !cu.exists());
 	assertTrue("CU should still not be open", !cu.isOpen());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaConventionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaConventionTests.java
index 9e702c4..14b1c51 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaConventionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaConventionTests.java
@@ -77,7 +77,7 @@ public void testInvalidImportDeclaration3() {
 public void testPackageFragmentRootOverlap() throws Exception {
 	try {
 		IJavaProject project = this.createJavaProject("P1", new String[] {"src"}, new String[] {"/P1/jclMin.jar"}, "bin");
-		this.copy(new java.io.File(getExternalJCLPath()), new java.io.File(getWorkspaceRoot().getLocation().toOSString() + java.io.File.separator + "P1" + java.io.File.separator + "jclMin.jar"));
+		this.copy(new java.io.File(getExternalJCLPathString()), new java.io.File(getWorkspaceRoot().getLocation().toOSString() + java.io.File.separator + "P1" + java.io.File.separator + "jclMin.jar"));
 		project.getProject().refreshLocal(IResource.DEPTH_INFINITE, null);
 		
 		IPackageFragmentRoot p1Zip= getPackageFragmentRoot("P1", "jclMin.jar");
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElementDeltaTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElementDeltaTests.java
index 720daac..cdaa356 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElementDeltaTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaElementDeltaTests.java
@@ -445,7 +445,7 @@ public void testBuildProjectUsedAsLib() throws CoreException {
 		assertDeltas(
 			"Unexpected delta (1)",
 			"P2[*]: {CHILDREN}\n" + 
-			"	bin1[*]: {CHILDREN}\n" + 
+			"	/P1/bin1[*]: {CHILDREN}\n" + 
 			"		[default][*]: {CHILDREN}\n" + 
 			"			X.class[+]: {}"
 			);
@@ -464,7 +464,7 @@ public void testBuildProjectUsedAsLib() throws CoreException {
 		assertDeltas(
 			"Unexpected delta (2)",
 			"P2[*]: {CHILDREN}\n" + 
-			"	bin1[*]: {CHILDREN}\n" + 
+			"	/P1/bin1[*]: {CHILDREN}\n" + 
 			"		[default][*]: {CHILDREN}\n" + 
 			"			X.class[*]: {CONTENT}\n" + 
 			"			Y.class[+]: {}"
@@ -564,7 +564,7 @@ public void testDeleteInnerJar() throws CoreException {
 		assertDeltas(
 			"Unexpected deltas",
 			"P[*]: {CHILDREN}\n" + 
-			"	lib/x.jar[-]: {}"
+			"	/P/lib/x.jar[-]: {}"
 		);
 	} finally {
 		this.stopDeltas();
@@ -664,7 +664,7 @@ public void testCloseNonJavaProjectUpdateDependent() throws CoreException {
 		assertDeltas(
 			"Unexpected delta", 
 			"JP[*]: {CHILDREN}\n" + 
-			"	x.jar[-]: {}\n" + 
+			"	/SP/x.jar[-]: {}\n" + 
 			"ResourceDelta(/SP)"
 		);
 	} finally {
@@ -1370,7 +1370,7 @@ public void testRemoveAddBinaryProject() throws CoreException {
 		assertDeltas(
 			"Unexpected delta", 
 			"P[*]: {CHILDREN}\n" + 
-			"	lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
+			"	/P/lib.jar[*]: {REMOVED FROM CLASSPATH}\n" + 
 			"	[project root][*]: {ADDED TO CLASSPATH}\n" + 
 			"	ResourceDelta(/P/.classpath)[*]\n" + 
 			"	ResourceDelta(/P/.project)[*]\n" + 
@@ -1555,7 +1555,7 @@ public void testRemoveNonJavaProjectUpdateDependent() throws CoreException {
 		assertDeltas(
 			"Unexpected delta", 
 			"JP[*]: {CHILDREN}\n" + 
-			"	x.jar[-]: {}\n" + 
+			"	/SP/x.jar[-]: {}\n" + 
 			"ResourceDelta(/SP)"
 		);
 	} finally {
@@ -1742,8 +1742,8 @@ public void testSetClasspathVariable1() throws CoreException {
 		assertDeltas(
 			"Unexpected delta after setting classpath variable", 
 			"P[*]: {CHILDREN}\n" +
-			"	mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
-			"	otherlib.jar[*]: {ADDED TO CLASSPATH}"
+			"	/LibProj/mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
+			"	/LibProj/otherlib.jar[*]: {ADDED TO CLASSPATH}"
 		);
 	} finally {
 		this.stopDeltas();
@@ -1768,11 +1768,11 @@ public void testSetClasspathVariable2() throws CoreException {
 		assertEquals(
 			"Unexpected delta after setting classpath variable", 
 			"P1[*]: {CHILDREN}\n" +
-			"	mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
-			"	otherlib.jar[*]: {ADDED TO CLASSPATH}\n" + 
+			"	/LibProj/mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
+			"	/LibProj/otherlib.jar[*]: {ADDED TO CLASSPATH}\n" + 
 			"P2[*]: {CHILDREN}\n" +
-			"	mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
-			"	otherlib.jar[*]: {ADDED TO CLASSPATH}", 
+			"	/LibProj/mylib.jar[*]: {REMOVED FROM CLASSPATH}\n" +
+			"	/LibProj/otherlib.jar[*]: {ADDED TO CLASSPATH}", 
 			this.getSortedByProjectDeltas());
 	} finally {
 		this.stopDeltas();
@@ -1810,7 +1810,7 @@ public void testSetClasspathOnFreshProject() throws CoreException {
 			"P1[*]: {CHILDREN}\n" + 
 			"	[project root][*]: {REMOVED FROM CLASSPATH}\n" + 
 			"	src2[*]: {ADDED TO CLASSPATH}\n" + 
-			"	mylib.jar[*]: {ADDED TO CLASSPATH}\n" + 
+			"	/LibProj/mylib.jar[*]: {ADDED TO CLASSPATH}\n" + 
 			"	ResourceDelta(/P1/.classpath)[*]");
 	} finally {
 		this.stopDeltas();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
index d84feca..a589a1c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
@@ -257,7 +257,7 @@ public void testDeletePackageWithAutobuild() throws JavaModelException, CoreExce
  */
 public void testExternalArchiveCorrespondingResource() throws JavaModelException {
 	IJavaProject project= getJavaProject("JavaProjectTests");
-	IPackageFragmentRoot element= project.getPackageFragmentRoot(getExternalJCLPath());
+	IPackageFragmentRoot element= project.getPackageFragmentRoot(getExternalJCLPathString());
 	IResource corr= element.getCorrespondingResource();
 	assertTrue("incorrect corresponding resource", corr == null);
 }
@@ -352,7 +352,7 @@ public void testFindPackageFragmentRootFromClasspathEntry() throws JavaModelExce
 	IClasspathEntry entry = JavaCore.newLibraryEntry(new Path("/JavaProjectTests/lib.jar"), null, null);
 	IPackageFragmentRoot[] roots = project.findPackageFragmentRoots(entry);
 	assertEquals("Unexpected number of roots for existing entry", 1, roots.length);
-	assertEquals("Unexpected root", "lib.jar", roots[0].getElementName());
+	assertEquals("Unexpected root", "/JavaProjectTests/lib.jar", roots[0].getElementName());
 	
 	// non-existing classpath entry
 	entry = JavaCore.newSourceEntry(new Path("/JavaProjectTests/nonExisting"));
@@ -587,8 +587,8 @@ public void testPackageFragmentHasSubpackages() throws JavaModelException {
 	assertTrue("x should have subpackages",								x.hasSubpackages());
 	assertTrue("x.y should NOT have subpackages",		!y.hasSubpackages());
 
-	IPackageFragment java = getPackageFragment("JavaProjectTests", getExternalJCLPath(), "java");
-	IPackageFragment lang= getPackageFragment("JavaProjectTests", getExternalJCLPath(), "java.lang");
+	IPackageFragment java = getPackageFragment("JavaProjectTests", getExternalJCLPathString(), "java");
+	IPackageFragment lang= getPackageFragment("JavaProjectTests", getExternalJCLPathString(), "java.lang");
 
 	assertTrue("java should have subpackages",					java.hasSubpackages());
 	assertTrue("java.lang  should NOT have subpackages",			!lang.hasSubpackages());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java
index e0b418e..51b3ed4 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java
@@ -612,7 +612,7 @@ public void testDeclarationOfReferencedTypes1() throws JavaModelException, CoreE
 		"src/a3/b/A.java a3.b.A [A]\n" +
 		"src/a3/b/A.java a3.b.A$B$C [C]\n" +
 		"src/a3/b/A.java a3.b.A$B [B]\n" +
-		getExternalJCLPath() + " java.lang.Object\n" +
+		getExternalJCLPathString() + " java.lang.Object\n" +
 		"src/a3/Y.java a3.Y [Y]\n" +
 		"src/a3/b/B.java a3.b.B [B]", 
 		resultCollector.toString());
@@ -1565,7 +1565,7 @@ public void testMethodReference4() throws JavaModelException, CoreException {
  * (regression test for 1GHDA2V: ITPJCORE:WINNT - ClassCastException when doing a search)
  */
 public void testMethodReferenceThroughArray() throws JavaModelException, CoreException {
-	IType type = getClassFile("JavaSearch", getExternalJCLPath(), "java.lang", "Object.class").getType();
+	IType type = getClassFile("JavaSearch", getExternalJCLPathString(), "java.lang", "Object.class").getType();
 	IMethod method = type.getMethod("clone", new String[] {});
 	JavaSearchResultCollector resultCollector = new JavaSearchResultCollector();
 	new SearchEngine().search(
@@ -2277,7 +2277,7 @@ public void testTypeDeclarationInJar3() throws CoreException {
 			resultCollector);
 		assertEquals(
 			"Unexpected result in scope of P1",
-			getExternalJCLPath() + " [in P1] java.lang.Object", 
+			getExternalJCLPathString() + " [in P1] java.lang.Object", 
 			resultCollector.toString());
 			
 		scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {p2});
@@ -2292,7 +2292,7 @@ public void testTypeDeclarationInJar3() throws CoreException {
 			resultCollector);
 		assertEquals(
 			"Unexpected result in scope of P2",
-			getExternalJCLPath() + " [in P2] java.lang.Object", 
+			getExternalJCLPathString() + " [in P2] java.lang.Object", 
 			resultCollector.toString());
 		} finally {
 		this.deleteProject("P1");
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
new file mode 100644
index 0000000..ebcd8d1
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
@@ -0,0 +1,437 @@
+/*******************************************************************************
+ * Copyright (c) 2003 IBM Corp. and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0 
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import org.eclipse.core.resources.*;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.core.tests.util.Util;
+import junit.framework.Test;
+
+public class MementoTests extends ModifyingResourceTests {
+public MementoTests(String name) {
+	super(name);
+}
+public static Test suite() {
+	return new Suite(MementoTests.class);
+}
+protected void assertMemento(String expected, IJavaElement element) {
+	String actual = element.getHandleIdentifier();
+	if (!expected.equals(actual)){
+	 	System.out.println(Util.displayString(actual, 2));
+	}
+	assertEquals(
+		"Unexpected memento for " + element,
+		expected,
+		actual);
+	IJavaElement restored = JavaCore.create(actual);
+	assertEquals(
+		"Unexpected restored element",
+		element,
+		restored);
+}
+public void setUpSuite() throws Exception {
+	super.setUpSuite();
+	
+	this.createJavaProject(
+			"P", 
+			new String[] {"src"}, 
+			new String[] {
+				getExternalJCLPathString(), 
+				"/P/lib",
+				"/P/lib/myLib.jar",
+				"/OtherProj/lib", 
+				"/OtherProj/lib/myLib.jar",
+			},
+			"bin");
+}
+public void tearDownSuite() throws Exception {
+	this.deleteProject("P");
+	super.tearDownSuite();
+}
+/**
+ * Tests that a binary field can be persisted and restored using its memento.
+ */
+public void testBinaryFieldMemento() throws JavaModelException {
+	IField field = getClassFile("/P/lib/p/X.class").getType().getField("field");
+	assertMemento(
+		"=P/lib<p(X.class[X^field",
+		field);
+}
+/**
+ * Tests that an inner type, inner field and inner method can be persisted and restored
+ * using mementos.
+ */
+public void testBinaryInnerTypeMemento() throws JavaModelException {
+	IType type = getClassFile("/P/lib/p/X$Inner.class").getType();
+
+	assertMemento(
+		"=P/lib<p(X$Inner.class[Inner",
+		type);
+
+	IField innerField = type.getField("field");
+	assertMemento(
+		"=P/lib<p(X$Inner.class[Inner^field",
+		innerField);
+	
+	IMethod innerMethod = type.getMethod("foo", new String[] {"I", "Ljava.lang.String;"});
+	assertMemento(
+		"=P/lib<p(X$Inner.class[Inner~foo~I~Ljava.lang.String;",
+		innerMethod);
+}
+/**
+ * Tests that a binary method can be persisted and restored using its memento.
+ */
+public void testBinaryMethodMemento() throws JavaModelException {
+	IType type = getClassFile("/P/lib/p/X.class").getType();
+
+	IMethod method = type.getMethod("foo", new String[] {"I", "Ljava.lang.String;"});
+	assertMemento(
+		"=P/lib<p(X.class[X~foo~I~Ljava.lang.String;",
+		method);
+		
+	method = type.getMethod("bar", new String[] {});
+	assertMemento(
+		"=P/lib<p(X.class[X~bar",
+		method);
+		
+	method = type.getMethod("fred", new String[] {"[Z"});
+	assertMemento(
+		"=P/lib<p(X.class[X~fred~[Z",
+		method);
+}
+/**
+ * Tests that a binary type can be persisted and restored using its memento.
+ */
+public void testBinaryTypeMemento() throws JavaModelException {
+	IType type = getClassFile("/P/lib/p/X.class").getType();
+	assertMemento(
+		"=P/lib<p(X.class[X",
+		type);
+}
+/**
+ * Tests that a class file can be persisted and restored using its memento.
+ */
+public void testClassFileMemento() throws JavaModelException {
+	IClassFile cf =  getClassFile("/P/lib/p/X.class");
+	assertMemento(
+		"=P/lib<p(X.class",
+		cf);
+
+	cf = getClassFile("/P/lib/Y.class");
+	assertMemento(
+		"=P/lib<(Y.class",
+		cf);
+	
+}
+/**
+ * Tests that a compilation unit can be persisted and restored using its memento.
+ */
+public void testCompilationUnitMemento() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("/P/src/p/X.java");
+	assertMemento(
+		"=P/src<p{X.java",
+		cu);
+		
+	cu = getCompilationUnit("/P/src/Y.java");
+	assertMemento(
+		"=P/src<{Y.java",
+		cu);
+}
+/**
+ * Tests that an import declaration can be persisted and restored using its memento.
+ */
+public void testImportDeclarationMemento() throws JavaModelException {
+	IImportDeclaration importDecl = getCompilationUnit("/P/src/p/X.java").getImport("java.io.Serializable");
+	assertMemento(
+		"=P/src<p{X.java#java.io.Serializable",
+		importDecl);
+	
+	importDecl = getCompilationUnit("/P/src/p/X.java").getImport("java.util.*");
+	assertMemento(
+		"=P/src<p{X.java#java.util.*",
+		importDecl);
+}
+/**
+ * Tests that an initializer can be persisted and restored using its memento.
+ */
+public void testInitializerMemento() throws JavaModelException {
+	IType type = getCompilationUnit("/P/src/p/X.java").getType("X");
+	
+	IInitializer initializer = type.getInitializer(1);
+	assertMemento(
+		"=P/src<p{X.java[X|1",
+		initializer);
+	
+	initializer = type.getInitializer(2);
+	assertMemento(
+		"=P/src<p{X.java[X|2",
+		initializer);
+}
+/**
+ * Tests that a binary field in an internal jar can be persisted and restored using its memento.
+ */
+public void testInternalJarBinaryFieldMemento() throws JavaModelException {	
+	IType type = getPackageFragmentRoot("/P/lib/myLib.jar").getPackageFragment("p").getClassFile("X.class").getType();
+	IField field = type.getField("field");
+	assertMemento(
+		"=P//P/lib/myLib.jar<p(X.class[X^field",
+		field);
+}
+/**
+ * Tests that a inner binary type and field in an internal jar can be persisted and restored using its memento.
+ */
+public void testInternalJarBinaryInnerTypeMemento() throws JavaModelException {	
+	IType type = getPackageFragmentRoot("/P/lib/myLib.jar").getPackageFragment("p").getClassFile("X$Inner.class").getType();
+	assertMemento(
+		"=P//P/lib/myLib.jar<p(X$Inner.class[Inner",
+		type);
+}
+/**
+ * Tests that a binary method in an internal jar can be persisted and restored using its memento.
+ */
+public void testInternalJarBinaryMethodMemento() throws JavaModelException {	
+	IType type = getPackageFragmentRoot("/P/lib/myLib.jar").getPackageFragment("p").getClassFile("X.class").getType();
+	IMethod method = type.getMethod("foo", new String[] {"[Ljava.lang.String;"});
+	assertMemento(
+		"=P//P/lib/myLib.jar<p(X.class[X~foo~[Ljava.lang.String;",
+		method);
+}
+/**
+ * Tests that a binary type in an internal jar can be persisted and restored using its memento.
+ */
+public void testInternalJarBinaryTypeMemento() throws JavaModelException {	
+	IType type = getPackageFragmentRoot("/P/lib/myLib.jar").getPackageFragment("p").getClassFile("X.class").getType();
+	assertMemento(
+		"=P//P/lib/myLib.jar<p(X.class[X",
+		type);	
+}
+/**
+ * Tests that a binary field in an external jar can be persisted and restored using its memento.
+ */
+public void testExternalJarBinaryFieldMemento() throws JavaModelException {	
+	IType type = getClassFile("P", getExternalJCLPathString(), "p", "X.class").getType();
+	IField field = type.getField("field");
+	assertMemento(
+		"=P/" + getExternalJCLPath() + "<p(X.class[X^field",
+		field);
+}
+/**
+ * Tests that a inner binary type and field in an external jar can be persisted and restored using its memento.
+ */
+public void testExternalJarBinaryInnerTypeMemento() throws JavaModelException {
+	IType type = getClassFile("P", getExternalJCLPathString(), "p", "X$Inner.class").getType();
+	assertMemento(
+		"=P/" + getExternalJCLPath() + "<p(X$Inner.class[Inner",
+		type);
+}
+/**
+ * Tests that a binary method in an external jar can be persisted and restored using its memento.
+ */
+public void testExternalJarBinaryMethodMemento() throws JavaModelException {	
+	IType type = getClassFile("P", getExternalJCLPathString(), "p", "X.class").getType();
+	IMethod method = type.getMethod("foo", new String[] {"[Ljava.lang.String;"});
+	assertMemento(
+		"=P/" + getExternalJCLPath() + "<p(X.class[X~foo~[Ljava.lang.String;",
+		method);
+}
+/**
+ * Tests that a binary type in an external jar can be persisted and restored using its memento.
+ */
+public void testExternalJarBinaryTypeMemento() throws JavaModelException {	
+	IType type = getClassFile("P", getExternalJCLPathString(), "p", "X.class").getType();
+	assertMemento(
+		"=P/" + getExternalJCLPath() + "<p(X.class[X",
+		type);	
+}
+/**
+ * Tests that a package declaration can be persisted and restored using its memento.
+ */
+public void testPackageDeclarationMemento() throws JavaModelException {
+	IPackageDeclaration declaration = getCompilationUnit("/P/src/p/X.java").getPackageDeclaration("p");
+	assertMemento(
+		"=P/src<p{X.java%p",
+		declaration);
+		
+	declaration = getCompilationUnit("/P/src/p1/p2/X.java").getPackageDeclaration("p1.p2");
+	assertMemento(
+		"=P/src<p1.p2{X.java%p1.p2",
+		declaration);
+}
+/**
+ * Tests that a package fragment can be persisted and restored using its memento.
+ */
+public void testPackageFragmentMemento() throws JavaModelException {
+	IPackageFragment pkg = getPackage("/P/src/p");
+	assertMemento(
+		"=P/src<p",
+		pkg);
+		
+	pkg = getPackage("/P/src/p1/p2");
+	assertMemento(
+		"=P/src<p1.p2",
+		pkg);
+
+	pkg = getPackage("/P/src");
+	assertMemento(
+		"=P/src<",
+		pkg);
+}
+/**
+ * Tests that a source folder package fragment root can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento1() throws CoreException {
+	IJavaProject project = getJavaProject("P");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(project.getProject().getFolder("src"));
+	assertMemento(
+		"=P/src",
+		root);
+}
+/**
+ * Tests that a source folder package fragment root corresponding to the project
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento2() throws CoreException {
+	try {
+		IJavaProject project = this.createJavaProject("P1", new String[] {""}, "");
+		IPackageFragmentRoot root = project.getPackageFragmentRoot(project.getProject());
+		assertMemento(
+			"=P1/",
+			root);
+	} finally {
+		this.deleteProject("P1");
+	}		
+}	
+/**
+ * Tests that a library folder package fragment root in the same project
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento3() throws CoreException {
+	IJavaProject project = getJavaProject("P");
+	IFolder libFolder = project.getProject().getFolder("lib");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(libFolder);
+	assertMemento(
+		"=P/lib",
+		root);
+}
+/**
+ * Tests that a library folder package fragment root in another project
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento4() throws CoreException {
+	IJavaProject project = getJavaProject("P");
+	IFolder otherLibFolder = getFolder("/OtherProj/lib");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(otherLibFolder);
+	assertMemento(
+		"=P//OtherProj/lib",
+		root);
+}
+/**
+ * Tests that a jar package fragment root in the same project
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento5() throws CoreException {
+	IJavaProject project = getJavaProject("P");
+	IFile jar = getFile("/P/lib/myLib.jar");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(jar);
+	assertMemento(
+		"=P//P/lib/myLib.jar",
+		root);
+}
+/**
+ * Tests that a jar package fragment root in another project
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento6() throws CoreException {
+	IJavaProject project = getJavaProject("P");
+	IFile jar = getFile("/OtherProj/lib/myLib.jar");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(jar);
+	assertMemento(
+		"=P//OtherProj/lib/myLib.jar",
+		root);
+}
+/**
+ * Tests that an external jar package fragment root
+ * can be persisted and restored using its memento.
+ */
+public void testPackageFragmentRootMemento7() throws CoreException {
+	IPackageFragmentRoot root = getPackageFragmentRoot("P", getExternalJCLPathString());
+	assertMemento(
+		"=P/" + getExternalJCLPath(),
+		root);
+}
+/**
+ * Tests that a project can be persisted and restored using its memento.
+ */
+public void testProjectMemento() throws JavaModelException {
+	IJavaProject project = getJavaProject("P");
+	assertMemento(
+		"=P",
+		project);
+}
+/**
+ * Tests that a bogus memento cannot be restored.
+ */
+public void testRestoreBogusMemento() throws JavaModelException {
+	IJavaElement restored = JavaCore.create("bogus");
+	assertEquals("should not be able to restore a bogus memento", null, restored);
+}
+/**
+ * Tests that a source field can be persisted and restored using its memento.
+ */
+public void testSourceFieldMemento() throws JavaModelException {
+	IField field = getCompilationUnit("/P/src/p/X.java").getType("X").getField("field");
+	assertMemento(
+		"=P/src<p{X.java[X^field",
+		field);
+}
+/**
+ * Tests that a source inner type, inner field and inner method can be persisted and restored
+ * using mementos.
+ */
+public void testSourceInnerTypeMemento() throws JavaModelException {
+	IType innerType = getCompilationUnit("/P/src/p/X.java").getType("X").getType("Inner");
+	assertMemento(
+		"=P/src<p{X.java[X[Inner",
+		innerType);
+}
+/**
+ * Tests that a source method can be persisted and restored using its memento.
+ */
+public void testSourceMethodMemento() throws JavaModelException {
+	IType type = getCompilationUnit("/P/src/p/X.java").getType("X");
+
+	IMethod method = type.getMethod("foo", new String[] {"I", "Ljava.lang.String;"});
+	assertMemento(
+		"=P/src<p{X.java[X~foo~I~Ljava.lang.String;",
+		method);
+		
+	method = type.getMethod("bar", new String[] {});
+	assertMemento(
+		"=P/src<p{X.java[X~bar",
+		method);
+		
+	method = type.getMethod("fred", new String[] {"[Z"});
+	assertMemento(
+		"=P/src<p{X.java[X~fred~[Z",
+		method);
+}
+/**
+ * Tests that a source type can be persisted and restored using its memento.
+ */
+public void testSourceTypeMemento() throws JavaModelException {
+	IType type = getCompilationUnit("/P/src/p/X.java").getType("X");
+	assertMemento(
+		"=P/src<p{X.java[X",
+		type);
+}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
index c76120f..2f500b5 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
@@ -35,7 +35,7 @@ public SortCompilationUnitElementsTests(String name) {
 public void setUpSuite() throws Exception {
 	super.setUpSuite();
 	
-	this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPath()}, "bin");
+	this.createJavaProject("P", new String[] {"src"}, new String[] {getExternalJCLPathString()}, "bin");
 	this.createFolder("/P/src/p");
 }
 private void sortUnit(ICompilationUnit unit, String expectedResult) throws CoreException {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyNotificationTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyNotificationTests.java
index e531133..23b52d2 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyNotificationTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyNotificationTests.java
@@ -288,7 +288,7 @@ public void testAddCompilationUnitInRegion() throws JavaModelException, CoreExce
 			assertCreation(newCU3);
 			this.assertOneChange(h);
 			h.refresh(null);
-			IType throwableClass = getClassFile("TypeHierarchyNotification", getExternalJCLPath(), "java.lang", "Throwable.class").getType();
+			IType throwableClass = getClassFile("TypeHierarchyNotification", getExternalJCLPathString(), "java.lang", "Throwable.class").getType();
 			assertEquals("Superclass of Z3 should be java.lang.Throwable", throwableClass, h.getSuperclass(newCU3.getType("Z3")));
 		} finally {
 			// cleanup	
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
index c7e1483..3f38d83 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
@@ -138,7 +138,7 @@ public void testContains() throws JavaModelException {
 	assertTrue("X must be included", this.typeHierarchy.contains(type));
 
 	// root class
-	cf = getClassFile("TypeHierarchy", getExternalJCLPath(), "java.lang", "Object.class");
+	cf = getClassFile("TypeHierarchy", getExternalJCLPathString(), "java.lang", "Object.class");
 	type = cf.getType();
 	assertTrue("Object must be included", this.typeHierarchy.contains(type));
 
@@ -290,7 +290,7 @@ public void testSourceTypeGetSuperInterfaces() throws JavaModelException {
  * Ensures that no subclasses exist in a super type hierarchy for the focus type.
  */
 public void testSupertypeHierarchyGetSubclasses() throws JavaModelException {
-	IType type = getClassFile("TypeHierarchy", getExternalJCLPath(), "java.lang", "Object.class").getType();
+	IType type = getClassFile("TypeHierarchy", getExternalJCLPathString(), "java.lang", "Object.class").getType();
 	ITypeHierarchy typeHierarchy = type.newSupertypeHierarchy(null);
 	IType[] types = typeHierarchy.getSubclasses(type);
 	assertTypesEqual(
@@ -311,7 +311,7 @@ public void testSupertypeHierarchyGetSubclasses() throws JavaModelException {
  * Ensures that no subtypes exist in a super type hierarchy for the focus type.
  */
 public void testSupertypeHierarchyGetSubtypes() throws JavaModelException {
-	IType type = getClassFile("TypeHierarchy", getExternalJCLPath(), "java.lang", "Object.class").getType();
+	IType type = getClassFile("TypeHierarchy", getExternalJCLPathString(), "java.lang", "Object.class").getType();
 	ITypeHierarchy typeHierarchy = type.newSupertypeHierarchy(null);
 	IType[] types = typeHierarchy.getSubtypes(type);
 	assertTypesEqual(
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java
index 9eade7a..4d446df 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java
@@ -247,7 +247,7 @@ protected void setUp() {
 		this.createJavaProject(
 			"P", 
 			new String[] {"src"}, 
-			new String[] {this.getExternalJCLPath(), "lib"}, 
+			new String[] {this.getExternalJCLPathString(), "lib"}, 
 			"bin");
 		this.createFolder("P/src/x/y");
 		this.createFile("P/src/x/y/A.java", 
@@ -336,8 +336,8 @@ public void testContents() throws CoreException {
  * Test creating a working copy on a class file with a customized buffer.
  */
 public void testOnClassFile() throws JavaModelException {
-	this.attachSource(this.getPackageFragmentRoot("P", this.getExternalJCLPath()), this.getExternalJCLSourcePath(), "src");
-	IClassFile classFile = this.getClassFile("P", this.getExternalJCLPath(), "java.lang", "Object.class");
+	this.attachSource(this.getPackageFragmentRoot("P", this.getExternalJCLPathString()), this.getExternalJCLSourcePath().toOSString(), "src");
+	IClassFile classFile = this.getClassFile("P", this.getExternalJCLPathString(), "java.lang", "Object.class");
 	IBufferFactory factory = new BufferFactory();
 	IJavaElement customizedCopy = classFile.getWorkingCopy(null, factory);
 	try {
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 148b2c9..04ae2f1 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -50,7 +50,9 @@ preference <code>"org.eclipse.jdt.core.compiler.problem.incompatibleNonInherited
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=28044">28044</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=29864">29864</a>
+Unable to restore working set item - cannot instantiate item: org.eclipse.jdt.ui.PersistableJavaElementFactory 
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=28044">28044</a>
 weird errors not reported anywhere but in text and overview ruler
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=30013">30013</a>
 Project compiler setting workspace | project do not persist
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java
index d7ffd2f..8f0ad8d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java
@@ -167,7 +167,7 @@ public class HandleFactory {
 			if (index < length) {
 				System.arraycopy(projects, 0, projects = new IJavaProject[index], 0, index);
 			}
-			IPackageFragmentRoot root = getJarPkgFragmentRoot(jarPathString, jarPath, target, projects);
+			IPackageFragmentRoot root = getJarPkgFragmentRoot(jarPath, target, projects);
 			if (root != null) {
 				return root;
 			}
@@ -180,10 +180,9 @@ public class HandleFactory {
 			// java model is not accessible
 			return null;
 		}
-		return getJarPkgFragmentRoot(jarPathString, jarPath, target, projects);
+		return getJarPkgFragmentRoot(jarPath, target, projects);
 	}
 	private IPackageFragmentRoot getJarPkgFragmentRoot(
-		String jarPathString,
 		IPath jarPath,
 		Object target,
 		IJavaProject[] projects) {
@@ -198,7 +197,7 @@ public class HandleFactory {
 							return javaProject.getPackageFragmentRoot((IFile)target);
 						} else {
 							// external jar
-							return javaProject.getPackageFragmentRoot0(jarPathString);
+							return javaProject.getPackageFragmentRoot0(jarPath);
 						}
 					}
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index ea11b6e..933542f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -18,7 +18,6 @@ import org.eclipse.core.resources.IResource;
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.*;
 
 /**
@@ -48,16 +47,16 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	 * based on a JAR file that is not contained in a <code>IJavaProject</code> and
 	 * does not have an associated <code>IResource</code>.
 	 */
-	protected JarPackageFragmentRoot(String jarPath, IJavaProject project) {
-		super(null, project, jarPath);
-		this.jarPath = new Path(jarPath);
+	protected JarPackageFragmentRoot(IPath jarPath, IJavaProject project) {
+		super(null, project, jarPath.toString());
+		this.jarPath = jarPath;
 	}
 	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy 
 	 * based on a JAR file.
 	 */
 	protected JarPackageFragmentRoot(IResource resource, IJavaProject project) {
-		super(resource, project);
+		super(resource, project, resource.getFullPath().toString());
 		this.jarPath = resource.getFullPath();
 	}
 
@@ -255,18 +254,30 @@ protected void computeJarChildren(JarPackageFragmentRootInfo info, ArrayList vCh
 	 * @see IPackageFragmentRoot
 	 */
 	public IPath getPath() {
-		if (fResource == null) {
+		if (isExternal()) {
 			return this.jarPath;
 		} else {
 			return super.getPath();
 		}
 	}
+	public IResource getResource() {
+		if (this.resource == null) {
+			this.resource = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), this.jarPath, false);
+		}
+		if (this.resource instanceof IResource) {
+			return super.getResource();
+		} else {
+			// external jar
+			return null;
+		}
+	}
+
 
 	/**
 	 * @see IJavaElement
 	 */
 	public IResource getUnderlyingResource() throws JavaModelException {
-		if (fResource == null) {
+		if (isExternal()) {
 			if (!exists()) throw newNotPresentException();
 			return null;
 		} else {
@@ -298,7 +309,7 @@ protected void computeJarChildren(JarPackageFragmentRootInfo info, ArrayList vCh
 	 * @see IPackageFragmentRoot
 	 */
 	public boolean isExternal() {
-		return fResource == null;
+		return getResource() == null;
 	}
 	/**
 	 * Jars and jar entries are all read only
@@ -331,15 +342,15 @@ protected boolean resourceExists() {
  * @see JavaElement#rootedAt(IJavaProject)
  */
 public IJavaElement rootedAt(IJavaProject project) {
-	if (fResource == null) {
+	if (isExternal()) {
 		return
 			new JarPackageFragmentRoot(
-				this.jarPath.toString(),
+				this.jarPath,
 				project);
 	} else {
 		return
 			new JarPackageFragmentRoot(
-				fResource,
+				getResource(),
 				project);
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
index 57d4b25..38e24f4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
@@ -199,6 +199,26 @@ protected IJavaElement getHandleFromMementoForBinaryMembers(String memento, IPac
 	return cf.getType();
 }
 /**
+ * Returns the <code>IPackageFragmentRoot</code> represented by the <code>String</code>
+ * memento.
+ * @see getHandleMemento()
+ */
+protected IPackageFragmentRoot getHandleFromMementoForRoot(String memento, JavaProject project, int projectEnd, int rootEnd) {
+	String rootName = null;
+	if (rootEnd == projectEnd - 1) {
+		//default root
+		rootName = IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH;
+	} else {
+		rootName = memento.substring(projectEnd + 1, rootEnd);
+	}
+	IPath rootPath = new Path(rootName);
+	if (rootPath.isAbsolute()) {
+		return project.getPackageFragmentRoot(rootPath);
+	} else {
+		return project.getPackageFragmentRoot(project.getProject().getFullPath().append(rootName));
+	}
+}
+/**
  * Returns the <code>IJavaElement</code> represented by the <code>String</code>
  * memento.
  * @see getHandleMemento()
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index f8699c2..4350c05 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -846,22 +846,9 @@ public class JavaModelManager implements ISaveParticipant {
 		}
 		int rootEnd= memento.indexOf(JavaElement.JEM_PACKAGEFRAGMENT, projectEnd + 1);
 		if (rootEnd == -1) {
-			return proj.getPackageFragmentRoot(new Path(Path.SEPARATOR + memento.substring(modelEnd + 1)));
-		}
-		String rootName= null;
-		if (rootEnd == projectEnd - 1) {
-			//default root
-			rootName= IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH;
-		} else {
-			rootName= memento.substring(projectEnd + 1, rootEnd);
-		}
-		IPath rootPath= new Path(rootName);
-		IPackageFragmentRoot root= null;
-		if (rootPath.isAbsolute()) {
-			root= proj.getPackageFragmentRoot(rootPath);
-		} else {
-			root= proj.getPackageFragmentRoot(proj.getProject().getFullPath().append(rootName));
+			return model.getHandleFromMementoForRoot(memento, proj, projectEnd, memento.length());
 		}
+		IPackageFragmentRoot root = model.getHandleFromMementoForRoot(memento, proj, projectEnd, rootEnd);
 		if (root == null)
 			return null;
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index ad07aaa..47a7d43 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -210,6 +210,8 @@ public class JavaProject
 		super.closing(info);
 	}
 	
+
+
 	/**
 	 * Internal computation of an expanded classpath. It will eliminate duplicates, and produce copies
 	 * of exported classpath entries to avoid possible side-effects ever after.
@@ -364,7 +366,7 @@ public class JavaProject
 					// external target - only JARs allowed
 					if (((java.io.File)target).isFile() && (Util.isArchiveFileName(entryPath.lastSegment()))) {
 						accumulatedRoots.add(
-							new JarPackageFragmentRoot(entryPath.toOSString(), this));
+							new JarPackageFragmentRoot(entryPath, this));
 						rootIDs.add(rootID);
 					}
 				}
@@ -1081,39 +1083,26 @@ public class JavaProject
 	 * @return A handle to the package fragment root identified by the given path.
 	 * This method is handle-only and the element may or may not exist. Returns
 	 * <code>null</code> if unable to generate a handle from the path (for example,
-	 * an absolute path that has less than 2 segments. The path may be relative or
+	 * an absolute path that has less than 1 segment. The path may be relative or
 	 * absolute.
 	 */
 	public IPackageFragmentRoot getPackageFragmentRoot(IPath path) {
-		Object target = JavaModel.getTarget(getProject().getWorkspace().getRoot(), path, false);
-		if (target == null) {
-			if (path.segmentCount() > 0) {
-				String ext = path.getFileExtension();
-				if (ext == null) {
-					return getPackageFragmentRoot(getProject().getFolder(path));
-				} else {
-					// resource jar
-					return getPackageFragmentRoot(getProject().getFile(path));
-				}
-			} else {
+		if (!path.isAbsolute()) {
+			path = getPath().append(path);
+		}
+		int segmentCount = path.segmentCount();
+		switch (segmentCount) {
+			case 0:
+				return null;
+			case 1:
 				// default root
 				return getPackageFragmentRoot(getProject());
-			}
-		} else {
-			if (target instanceof IResource) {
-				return this.getPackageFragmentRoot((IResource)target);
-			} else {
-				String ext = path.getFileExtension();
-				if (((java.io.File)target).isFile()
-					&& ("jar".equalsIgnoreCase(ext)  //$NON-NLS-1$
-						|| "zip".equalsIgnoreCase(ext))) { //$NON-NLS-1$
-					// external jar
-					return getPackageFragmentRoot0(path.toOSString());
+			default:
+				if (Util.isArchiveFileName(path.lastSegment())) {
+					return getPackageFragmentRoot0(path);
 				} else {
-					// unknown path
-					return null;
+					return getPackageFragmentRoot(getProject().getWorkspace().getRoot().getFolder(path));
 				}
-			}
 		}
 	}
 	
@@ -1122,13 +1111,17 @@ public class JavaProject
 	 */
 	public IPackageFragmentRoot getPackageFragmentRoot(IResource resource) {
 
-		String name = resource.getName();
 		if (resource.getType() == IResource.FILE
-			&& (Util.endsWithIgnoreCase(name, ".jar") //$NON-NLS-1$
-				|| Util.endsWithIgnoreCase(name, ".zip"))) { //$NON-NLS-1$ 
+			&& (Util.isArchiveFileName(resource.getName()))) {
 			return new JarPackageFragmentRoot(resource, this);
 		} else {
-			return new PackageFragmentRoot(resource, this);
+			if (resource.getProject().equals(getProject())) {
+				// name of root will be the project relative path (source forlders and library folder in same project)
+				return new PackageFragmentRoot(resource, this);
+			} else {
+				// name of root will be the full path (library folder in another project)
+				return new PackageFragmentRoot(resource, this, resource.getFullPath().toString());
+			}
 		}
 	}
 
@@ -1137,13 +1130,13 @@ public class JavaProject
 	 */
 	public IPackageFragmentRoot getPackageFragmentRoot(String jarPath) {
 
-		return getPackageFragmentRoot0(JavaProject.canonicalizedPath(new Path(jarPath)).toString());
+		return getPackageFragmentRoot0(JavaProject.canonicalizedPath(new Path(jarPath)));
 	}
 	
 	/**
 	 * no path canonicalization
 	 */
-	public IPackageFragmentRoot getPackageFragmentRoot0(String jarPath) {
+	public IPackageFragmentRoot getPackageFragmentRoot0(IPath jarPath) {
 
 		return new JarPackageFragmentRoot(jarPath, this);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 38c907c..68cf7b0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -42,9 +42,9 @@ public class PackageFragmentRoot extends Openable implements IPackageFragmentRoo
 
 	/**
 	 * The resource associated with this root.
-	 * @see IResource
+	 * (an IResource or a java.io.File (for external jar only))
 	 */
-	protected IResource fResource;
+	protected Object resource;
 	
 /**
  * Constructs a package fragment root which is the root of the java package
@@ -52,7 +52,7 @@ public class PackageFragmentRoot extends Openable implements IPackageFragmentRoo
  */
 protected PackageFragmentRoot(IResource resource, IJavaProject project) {
 	this(resource, project, resource.getProjectRelativePath().toString());
-	fResource = resource;
+	this.resource = resource;
 }
 
 /**
@@ -61,7 +61,7 @@ protected PackageFragmentRoot(IResource resource, IJavaProject project) {
  */
 protected PackageFragmentRoot(IResource resource, IJavaProject project, String path) {
 	super(PACKAGE_FRAGMENT_ROOT, project, path);
-	fResource = resource;
+	this.resource = resource;
 }
 
 /**
@@ -192,10 +192,11 @@ protected boolean computeChildren(OpenableElementInfo info) throws JavaModelExce
 	try {
 		// the underlying resource may be a folder or a project (in the case that the project folder
 		// is actually the package fragment root)
-		if (fResource.getType() == IResource.FOLDER || fResource.getType() == IResource.PROJECT) {
+		IResource resource = getResource();
+		if (resource.getType() == IResource.FOLDER || resource.getType() == IResource.PROJECT) {
 			ArrayList vChildren = new ArrayList(5);
 			char[][] exclusionPatterns = fullExclusionPatternChars();
-			computeFolderChildren((IContainer) fResource, "", vChildren, exclusionPatterns); //$NON-NLS-1$
+			computeFolderChildren((IContainer) resource, "", vChildren, exclusionPatterns); //$NON-NLS-1$
 			IJavaElement[] children = new IJavaElement[vChildren.size()];
 			vChildren.toArray(children);
 			info.setChildren(children);
@@ -309,7 +310,7 @@ public boolean equals(Object o) {
 		return false;
 	PackageFragmentRoot other = (PackageFragmentRoot) o;
 	return getJavaModel().equals(other.getJavaModel()) && 
-			fResource.equals(other.fResource) &&
+			this.resource.equals(other.resource) &&
 			fOccurrenceCount == other.fOccurrenceCount;
 }
 
@@ -482,7 +483,7 @@ protected String getPackageName(IFolder folder) throws JavaModelException {
  * @see IJavaElement
  */
 public IPath getPath() {
-	return fResource.getFullPath();
+	return getResource().getFullPath();
 }
 
 /*
@@ -527,7 +528,7 @@ public IClasspathEntry getRawClasspathEntry() throws JavaModelException {
  * @see IJavaElement
  */
 public IResource getResource() {
-	return fResource;
+	return (IResource)this.resource;
 }
 
 /**
@@ -669,11 +670,11 @@ public SourceMapper getSourceMapper() {
  */
 public IResource getUnderlyingResource() throws JavaModelException {
 	if (!exists()) throw newNotPresentException();
-	return fResource;
+	return getResource();
 }
 
 public int hashCode() {
-	return fResource.hashCode();
+	return this.resource.hashCode();
 }
 
 /**
@@ -742,7 +743,7 @@ public void refreshChildren() {
 public IJavaElement rootedAt(IJavaProject project) {
 	return
 		new PackageFragmentRoot(
-			fResource,
+			getResource(),
 			project, 
 			fName);
 }
