commit 23d8503fe2d61d8cf3b306490509a8902b8a8f50
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Mon Jun 19 14:17:08 2017 +0530

    Fix for bug 518282: [9] Classes from automatic module seen in Content
    assist but using it gives Compilation error
    
    Change-Id: Iff2b7f03e2eebccaa19f4c02e83a2d01e429ca2c

555	38	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
11	0	org.eclipse.jdt.core.tests.model/workspace/test_automodules/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/test_automodules/.project
-	-	org.eclipse.jdt.core.tests.model/workspace/test_automodules/lib/junit.jar
5	0	org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/module-info.java
9	0	org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/test_automodules/Test.java
5	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
0	221	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
6	19	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
30	45	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
5	20	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
48	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
22	16	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index b7d11ba..d3fe6a3 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -31,6 +31,7 @@ import org.eclipse.core.resources.IncrementalProjectBuilder;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClasspathAttribute;
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaModelMarker;
@@ -40,9 +41,12 @@ import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IProblemRequestor;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.core.ClasspathAttribute;
+import org.eclipse.jdt.internal.core.ClasspathEntry;
 import org.eclipse.jdt.internal.core.util.Messages;
 
 import junit.framework.Test;
@@ -223,8 +227,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 	private IJavaProject setupP2() throws CoreException {
 		IJavaProject project = createJava9Project("P2");
-		IClasspathEntry projectEntry = 
-				JavaCore.newProjectEntry(new Path("/P1"), true);
+		IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+		IClasspathEntry projectEntry = JavaCore.newProjectEntry(new Path("/P1"), null, false,
+			new IClasspathAttribute[] {modAttr},
+			true);
 		IClasspathEntry[] old = project.getRawClasspath();
 		IClasspathEntry[] newPath = new IClasspathEntry[old.length +1];
 		System.arraycopy(old, 0, newPath, 0, old.length);
@@ -378,8 +384,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 	private IJavaProject setupP3() throws CoreException {
 		IJavaProject project = createJava9Project("P3");
-		IClasspathEntry projectEntry = 
-				JavaCore.newProjectEntry(new Path("/P2"), true);
+		IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+		IClasspathEntry projectEntry = JavaCore.newProjectEntry(new Path("/P2"), null, false,
+			new IClasspathAttribute[] {modAttr},
+			true);
 		IClasspathEntry[] old = project.getRawClasspath();
 		IClasspathEntry[] newPath = new IClasspathEntry[old.length +1];
 		System.arraycopy(old, 0, newPath, 0, old.length);
@@ -734,7 +742,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"module com.greetings {\n" +
@@ -772,7 +783,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"module com.greetings {\n" +
@@ -809,7 +823,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -852,7 +869,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -895,7 +915,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -938,7 +961,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -981,7 +1007,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1029,7 +1058,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1062,7 +1094,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1226,7 +1261,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1274,7 +1312,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1340,7 +1381,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1377,7 +1421,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1504,7 +1551,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -1552,7 +1602,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}"
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] {
 				"src/module-info.java",
 				"module com.greetings {\n" +
@@ -2227,7 +2280,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.World;\n" +
@@ -2278,7 +2334,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.World;\n" +
@@ -2652,7 +2711,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"public @interface Foo {}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.Foo;\n" +
@@ -2699,7 +2761,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"public @interface Foo {}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.Foo;\n" +
@@ -2747,7 +2812,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"public @interface Foo {}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.Foo;\n" +
@@ -2798,7 +2866,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"public @interface Foo {}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.Foo;\n" +
@@ -2848,7 +2919,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"public @interface Foo {}" 
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", sources);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			String[] src = new String[] { 
 					"src/module-info.java",
 					"import org.astro.Foo;\n" +
@@ -2964,7 +3038,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 								"}\n"
 							};
 			IJavaProject p1 = setupModuleProject("mod.one", sources1);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 
 			String[] sources2 = {
@@ -3028,7 +3105,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 						"}\n"
 					};
 			IJavaProject p1 = setupModuleProject("mod.one", sources1);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 
 			String[] sources2 = {
@@ -3083,7 +3163,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"}\n"
 			};
 			IJavaProject p1 = setupModuleProject("mod.one", sources1);
-			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 
 			String[] sources2 = {
@@ -3397,8 +3480,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"	}\n" +
 				"}"
 			};
-			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath());
-			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			IJavaProject p3 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep1, dep2 });
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
@@ -3446,7 +3534,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"	}\n" +
 				"}"
 			};
-			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep1 });
 			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
@@ -3495,8 +3586,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"	}\n" +
 				"}"
 			};
-			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath());
-			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			IJavaProject p3 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep1, dep2 });
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
@@ -3548,8 +3644,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"	}\n" +
 				"}"
 			};
-			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath());
-			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			IJavaProject p3 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep1, dep2 });
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
@@ -3597,8 +3698,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"	}\n" +
 				"}"
 			};
-			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath());
-			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath());
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep1 = JavaCore.newProjectEntry(p1.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
 			IJavaProject p3 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep1, dep2 });
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
@@ -3632,6 +3738,417 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			 JavaCore.setOptions(javaCoreOptions);
 		}
 	}
+	// basic test for automatic modules - external jars
+	public void testBug518280() throws CoreException, IOException {
+		if (!isJRE9) return;
+		try {
+			String libPath = "externalLib/test.jar";
+			Util.createJar(
+					new String[] {
+						"test/src/org/astro/World.java", //$NON-NLS-1$
+						"package org.astro;\n" +
+						"public interface World {\n" +
+						"	public String name();\n" +
+						"}",
+					},
+					null,
+					new HashMap<>(),
+					null,
+					getExternalResourcePath(libPath));
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module com.greetings {\n" +
+					"	requires test;\n" +
+					"	exports com.greetings;\n" +
+					"}",
+					"src/com/greetings/MyWorld.java",
+					"package com.greetings;\n" +
+					"import org.astro.World;\n"	+
+					"public class MyWorld implements World {\n" +
+					"	public String name() {\n" +
+					"		return \" My World!!\";\n" +
+					"	}\n" +
+					"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null, ClasspathEntry.NO_ACCESS_RULES,
+					new IClasspathAttribute[] {modAttr},
+					false/*not exported*/);
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "", markers);
+		} finally {
+			deleteExternalResource("externalLib");
+			this.deleteProject("com.greetings");
+		}
+	}
+	// basic test for automatic modules - workspace jars
+	public void testBug518282() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		try {
+			setUpJavaProject("test_automodules", "9");
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			assertNoErrors();
+		} finally {
+			this.deleteProject("test_automodules");
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// Only the project using a jar as an automatic module should be able to
+	// resolve one as such
+	public void testBug518282a() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		try {
+			IJavaProject p1 = setUpJavaProject("test_automodules", "9");
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			assertNoErrors();
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module com.greetings {\n" +
+					"	requires junit; // This should not be resolved\n" +
+					"	exports com.greetings;\n" +
+					"}",
+					"src/com/greetings/Test.java",
+					"package com.greetings;\n" +
+					"public class Test {\n" +
+					"	public String name() {\n" +
+					"		return \" My World!!\";\n" +
+					"	}\n" +
+					"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "false");
+			IClasspathEntry dep = JavaCore.newLibraryEntry(p1.getProject().findMember("lib/junit.jar").getFullPath(), null, null,
+					ClasspathEntry.NO_ACCESS_RULES,
+					new IClasspathAttribute[] {modAttr},
+					false/*not exported*/);
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", 
+					"junit cannot be resolved to a module", markers);
+		} finally {
+			this.deleteProject("test_automodules");
+			this.deleteProject("com.greetings");
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// A modular jar on the module path of a project should behave as a regular module and not
+	// as an automatic module
+	public void testBug518282b() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		String libPath = "externalLib/test.jar";
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module com.greetings {\n" +
+					"	exports com.greetings;\n" +
+					"}",
+					"src/com/greetings/Test.java",
+					"package com.greetings;\n" +
+					"public class Test {\n" +
+					"	public String name() {\n" +
+					"		return \" My World!!\";\n" +
+					"	}\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("test", src);
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			File rootDir = new File(p1.getProject().findMember("bin").getLocation().toString());
+			Util.zip(rootDir, getExternalResourcePath(libPath));
+			src = new String[] { 
+					"src/module-info.java",
+					"module test_automodules {\n" +
+					"	requires com.greetings;\n" +
+					"}",
+					"src/test/Main.java",
+					"package test;\n" +
+					"import com.greetings.Test;\n" +
+					"public class Main {\n" +
+					"	public static void main(String[] args) {\n" +
+					"		System.out.println(new Test().name());\n" +
+					"	}\n" +
+					"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IJavaProject p2 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("test_automodules");
+			deleteExternalResource(libPath);
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// A modular jar on the class path of a module project - shouldn't be
+	// treated as a module and shouldn't be readable
+	public void testBug518282c() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		String libPath = "externalLib/test.jar";
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module test {\n" +
+					"	exports com.greetings;\n" +
+					"}",
+					"src/com/greetings/Test.java",
+					"package com.greetings;\n" +
+					"public class Test {\n" +
+					"	public String name() {\n" +
+					"		return \" My World!!\";\n" +
+					"	}\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("test", src);
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			File rootDir = new File(p1.getProject().findMember("bin").getLocation().toString());
+			Util.zip(rootDir, getExternalResourcePath(libPath));
+			src = new String[] { 
+					"src/module-info.java",
+					"module test_automodules {\n" +
+					"	requires test;\n" +
+					"}",
+					"src/test/Main.java",
+					"package test;\n" +
+					"import com.greetings.Test;\n" +
+					"public class Main {\n" +
+					"	public static void main(String[] args) {\n" +
+					"		System.out.println(new Test().name());\n" +
+					"	}\n" +
+					"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "false");
+			IClasspathEntry dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IJavaProject p2 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertTrue("Compilation succeeds unexpectedly", markers.length > 0);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("test_automodules");
+			deleteExternalResource(libPath);
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// An automatic module grants implied readability to all other automatic modules
+	public void _testBug518282d() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		String libPath = "externalLib/test.jar";
+		try {
+			String[] src = new String[] { 
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] { 
+				"src/com/greetings/Test.java",
+				"package com.greetings;\n" +
+				"import  org.astro.World;\n" +
+				"public class Test implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IJavaProject p2 = setupModuleProject("test", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			File rootDir = new File(p2.getProject().findMember("bin").getLocation().toString());
+			Util.zip(rootDir, getExternalResourcePath(libPath));
+			src = new String[] { 
+				"src/module-info.java",
+				"module test_automodules {\n" +
+				"	requires test;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import com.greetings.Test;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		org.astro.World world = new Test();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IClasspathEntry dep2 = JavaCore.newLibraryEntry(p1.getProject().findMember("bin").getFullPath(), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IJavaProject p3 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("test_automodules");
+			this.deleteProject("org.astro");
+			deleteExternalResource(libPath);
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// Automatic module should not allow access to other explicit modules without
+	// requires
+	public void testBug518282e() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		String libPath = "externalLib/test.jar";
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module org.astro {\n" +
+					"	exports org.astro;\n" +
+					"}",
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] { 
+				"src/com/greetings/Test.java",
+				"package com.greetings;\n" +
+				"import  org.astro.World;\n" +
+				"public class Test implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IJavaProject p2 = setupModuleProject("test", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			File rootDir = new File(p2.getProject().findMember("bin").getLocation().toString());
+			Util.zip(rootDir, getExternalResourcePath(libPath));
+			src = new String[] { 
+				"src/module-info.java",
+				"module test_automodules {\n" +
+				"	requires test;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import com.greetings.Test;\n" +
+				"import org.astro.*;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		World world = new Test();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p1.getPath(), null, true,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IJavaProject p3 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "World cannot be resolved to a type", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("test_automodules");
+			this.deleteProject("org.astro");
+			deleteExternalResource(libPath);
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	// An automatic module shouldn't allow access to classpath
+	public void testBug518282f() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		String libPath = "externalLib/test.jar";
+		try {
+			String[] src = new String[] { 
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] { 
+				"src/com/greetings/Test.java",
+				"package com.greetings;\n" +
+				"import  org.astro.World;\n" +
+				"public class Test implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			IJavaProject p2 = setupModuleProject("test", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			File rootDir = new File(p2.getProject().findMember("bin").getLocation().toString());
+			Util.zip(rootDir, getExternalResourcePath(libPath));
+			src = new String[] { 
+				"src/module-info.java",
+				"module test_automodules {\n" +
+				"	requires test;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import com.greetings.Test;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		org.astro.World world = new Test();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			dep = JavaCore.newLibraryEntry(new Path(getExternalResourcePath(libPath)), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			modAttr = new ClasspathAttribute("module", "false");
+			IClasspathEntry dep2 = JavaCore.newLibraryEntry(p1.getProject().findMember("bin").getFullPath(), null, null,
+				ClasspathEntry.NO_ACCESS_RULES,
+				new IClasspathAttribute[] {modAttr},
+				false/*not exported*/);
+			IJavaProject p3 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "org cannot be resolved to a type", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("test_automodules");
+			this.deleteProject("org.astro");
+			deleteExternalResource(libPath);
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
 	protected void assertNoErrors() throws CoreException {
 		for (IProject p : getWorkspace().getRoot().getProjects()) {
 			int maxSeverity = p.findMaxProblemSeverity(null, true, IResource.DEPTH_INFINITE);
diff --git a/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.classpath b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.classpath
new file mode 100644
index 0000000..aa89527
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.classpath
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/junit.jar">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.project b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.project
new file mode 100644
index 0000000..1d074e0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>test_automodules</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/test_automodules/lib/junit.jar b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/lib/junit.jar
new file mode 100644
index 0000000..3a7fc26
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/lib/junit.jar differ
diff --git a/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/module-info.java b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/module-info.java
new file mode 100644
index 0000000..a8f62fd
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/module-info.java
@@ -0,0 +1,5 @@
+module test_automodules {
+
+	requires junit;
+
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/test_automodules/Test.java b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/test_automodules/Test.java
new file mode 100644
index 0000000..a3c3ced
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/test_automodules/src/test_automodules/Test.java
@@ -0,0 +1,9 @@
+package test_automodules;
+
+import org.junit.runners.JUnit4;
+
+public class Test {
+
+	JUnit4 runner = null;
+	
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
index 00d9e97..5d64232 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
@@ -19,6 +19,7 @@ import java.util.List;
 
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClasspathAttribute;
 import org.eclipse.jdt.core.IClasspathContainer;
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.IJavaProject;
@@ -51,7 +52,10 @@ public class ModulePathContainer implements IClasspathContainer{
 				if (refRoot == null)
 					continue;
 				IPath path = refRoot.getPath();
-				entries.add(JavaCore.newProjectEntry(path, ref.isTransitive()));
+				IClasspathAttribute moduleAttribute = new ClasspathAttribute(IClasspathAttribute.AUTOMATIC_MODULE, "true"); //$NON-NLS-1$
+				entries.add(JavaCore.newProjectEntry(path, ClasspathEntry.NO_ACCESS_RULES,
+						false,
+						new IClasspathAttribute[] {moduleAttribute}, ref.isTransitive()));
 			}
 		} catch (JavaModelException e) {
 			// ignore
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
deleted file mode 100644
index bdff71e..0000000
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2017 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core.builder;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.ModuleReferenceImpl;
-
-public class BasicModule implements IModule {
-	static class PackageExport implements IModule.IPackageExport {
-		char[] pack;
-		char[][] exportedTo;
-		@Override
-		public char[] name() {
-			return this.pack;
-		}
-
-		@Override
-		public char[][] targets() {
-			return this.exportedTo;
-		}
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append(this.pack);
-			if (this.exportedTo != null) {
-				for (char[] cs : this.exportedTo) {
-					buffer.append(cs);
-				}
-			}
-			buffer.append(';');
-			return buffer.toString();
-		}
-	}
-	static class Service implements IModule.IService {
-		char[] provides;
-		char[][] with;
-		@Override
-		public char[] name() {
-			return this.provides;
-		}
-
-		@Override
-		public char[][] with() {
-			return this.with;
-		}
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append("provides"); //$NON-NLS-1$
-			buffer.append(this.provides);
-			buffer.append(" with "); //$NON-NLS-1$
-			for (int i = 0; i < this.with.length; i++) {
-				buffer.append(this.with[i]);
-				if (i < this.with.length - 1)
-					buffer.append(", "); //$NON-NLS-1$
-			}
-			buffer.append(';');
-			return buffer.toString();
-		}
-	}
-
-	Boolean isOpen = null;
-	char[] name;
-	IModule.IModuleReference[] requires;
-	IModule.IPackageExport[] exports;
-	char[][] uses;
-	Service[] provides;
-	IModule.IPackageExport[] opens;
-	ClasspathLocation root;
-	boolean isAutomodule;
-	public BasicModule(char[] name, ClasspathLocation root, boolean isAutomodule) {
-		this.name = name;
-		this.root = root;
-		this.exports = IModule.NO_EXPORTS;
-		this.requires = IModule.NO_MODULE_REFS;
-		this.isAutomodule = isAutomodule;
-	}
-	@Override
-	public char[] name() {
-		return this.name;
-	}
-	@Override
-	public IModule.IModuleReference[] requires() {
-		return this.requires;
-	}
-	@Override
-	public IModule.IPackageExport[] exports() {
-		return this.exports;
-	}
-	@Override
-	public char[][] uses() {
-		return this.uses;
-	}
-	@Override
-	public IService[] provides() {
-		return this.provides;
-	}
-	@Override
-	public IPackageExport[] opens() {
-		return this.opens;
-	}
-	@Override
-	public boolean isAutomatic() {
-		return this.root.isAutomaticModule();
-	}
-	public void addReads(char[] modName) {
-		Predicate<char[]> shouldAdd = m -> {
-			return Stream.of(this.requires).map(ref -> ref.name()).noneMatch(n -> CharOperation.equals(modName, n));
-		};
-		if (shouldAdd.test(modName)) {
-			int len = this.requires.length;
-			this.requires = Arrays.copyOf(this.requires, len + 1);
-			ModuleReferenceImpl info = new ModuleReferenceImpl();
-			info.name = modName;
-			this.requires[len] = info;
-		}		
-	}
-	public void addExports(IModule.IPackageExport[] toAdd) {
-		Predicate<char[]> shouldAdd = m -> {
-			return Stream.of(this.exports).map(ref -> ((PackageExport) ref).pack).noneMatch(n -> CharOperation.equals(m, n));
-		};
-		Collection<IPackageExport> merged = Stream.concat(Stream.of(this.exports), Stream.of(toAdd)
-				.filter(e -> shouldAdd.test(((PackageExport )e).name()))
-				.map(e -> {
-					PackageExport exp = new PackageExport();
-					exp.pack = ((PackageExport )e).name();
-					exp.exportedTo = ((PackageExport )e).targets();
-					return exp;
-				}))
-			.collect(
-				ArrayList::new,
-				ArrayList::add,
-				ArrayList::addAll);
-		this.exports = merged.toArray(new PackageExport[merged.size()]);
-	}
-	public boolean equals(Object o) {
-		if (this == o)
-			return true;
-		if (!(o instanceof IModule))
-			return false;
-		IModule mod = (IModule) o;
-		if (!CharOperation.equals(this.name, mod.name()))
-			return false;
-		return Arrays.equals(this.requires, mod.requires());
-	}
-	@Override
-	public int hashCode() {
-		int result = 17;
-		int c = this.name.hashCode();
-		result = 31 * result + c;
-		c =  Arrays.hashCode(this.requires);
-		result = 31 * result + c;
-		return result;
-	}
-	public String toString() {
-		StringBuffer buffer = new StringBuffer(getClass().getName());
-		toStringContent(buffer);
-		return buffer.toString();
-	}
-	protected void toStringContent(StringBuffer buffer) {
-		buffer.append("\nmodule "); //$NON-NLS-1$
-		buffer.append(this.name).append(' ');
-		buffer.append('{').append('\n');
-		if (this.requires != null) {
-			for(int i = 0; i < this.requires.length; i++) {
-				buffer.append("\trequires "); //$NON-NLS-1$
-				if (this.requires[i].isTransitive()) {
-					buffer.append(" public "); //$NON-NLS-1$
-				}
-				buffer.append(this.requires[i].name());
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.exports != null) {
-			buffer.append('\n');
-			for(int i = 0; i < this.exports.length; i++) {
-				buffer.append("\texports "); //$NON-NLS-1$
-				buffer.append(this.exports[i].toString());
-			}
-		}
-		if (this.uses != null) {
-			buffer.append('\n');
-			for (char[] cs : this.uses) {
-				buffer.append(cs);
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.provides != null) {
-			buffer.append('\n');
-			for(Service ser : this.provides) {
-				buffer.append(ser.toString());
-			}
-		}
-		buffer.append('\n').append('}').toString();
-	}
-	@Override
-	public boolean isOpen() {
-		if (this.isOpen == null) {
-			IModule module = this.root != null ? this.root.getModule() : null;
-			this.isOpen = module != null ? module.isOpen() : Boolean.FALSE;
-		}
-		return this.isOpen;
-	}
-}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index 340d4f0..7cc6242 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -30,7 +30,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -47,7 +46,7 @@ ZipFile annotationZipFile;
 String externalAnnotationPath;
 INameEnvironment env;
 
-ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
+ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isOnModulePath) {
 	this.binaryFolder = binaryFolder;
 	this.isOutputFolder = isOutputFolder || binaryFolder.getProjectRelativePath().isEmpty(); // if binaryFolder == project, then treat it as an outputFolder
 	this.directoryCache = new SimpleLookupTable(5);
@@ -55,14 +54,7 @@ ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSe
 	this.env = env;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toOSString();
-	if (isAutomodule) {
-		setAutomaticModule();
-	}
-}
-
-void setAutomaticModule() {
-	this.isAutoModule = true;
-	acceptModule(new AutoModule(this.binaryFolder.getName().toCharArray()));
+	this.isOnModulePath = isOnModulePath;
 }
 
 public void cleanup() {
@@ -76,7 +68,7 @@ public void cleanup() {
 	this.directoryCache = null;
 }
 
-ClasspathDirectory initializeModule() {
+IModule initializeModule() {
 	IResource[] members = null;
 	try {
 		members = this.binaryFolder.members();
@@ -88,8 +80,8 @@ ClasspathDirectory initializeModule() {
 				if (m.getType() == IResource.FILE && org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(name)) {
 					if (name.equalsIgnoreCase(IModule.MODULE_INFO_CLASS)) {
 						try {
-							this.acceptModule( Util.newClassFileReader(m));
-							this.isAutoModule = false;
+							ClassFileReader cfr = Util.newClassFileReader(m);
+							return cfr.getModuleDeclaration();
 						} catch (ClassFormatException | IOException e) {
 							// TODO BETA_JAVA9 Auto-generated catch block
 							e.printStackTrace();
@@ -101,7 +93,7 @@ ClasspathDirectory initializeModule() {
 	} catch (CoreException e1) {
 		e1.printStackTrace();
 	}
-	return this;
+	return null;
 }
 String[] directoryList(String qualifiedPackageName) {
 	String[] dirList = (String[]) this.directoryCache.get(qualifiedPackageName);
@@ -133,11 +125,6 @@ String[] directoryList(String qualifiedPackageName) {
 	this.directoryCache.put(qualifiedPackageName, this.missingPackageHolder);
 	return null;
 }
-void acceptModule(ClassFileReader classfile) {
-	if (classfile != null) {
-		acceptModule(classfile.getModuleDeclaration());
-	}
-}
 boolean doesFileExist(String fileName, String qualifiedPackageName, String qualifiedFullName) {
 	String[] dirList = directoryList(qualifiedPackageName);
 	if (dirList == null) return false; // most common case
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 5e0f2aa..cdab5d4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -33,10 +33,8 @@ import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
@@ -44,7 +42,7 @@ import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.Util;
 
 @SuppressWarnings("rawtypes")
-public class ClasspathJar extends ClasspathLocation implements IModulePathEntry {
+public class ClasspathJar extends ClasspathLocation {
 
 static class PackageCacheEntry {
 	long lastModified;
@@ -83,21 +81,12 @@ protected SimpleSet findPackageSet() {
 	long timestamp = this.lastModified();
 	long fileSize = new File(zipFileName).length();
 	if (cacheEntry != null && cacheEntry.lastModified == timestamp && cacheEntry.fileSize == fileSize) {
-		this.module = (IModule) ModuleCache.get(zipFileName);
 		return cacheEntry.packageSet;
 	}
 	final SimpleSet packageSet = new SimpleSet(41);
 	packageSet.add(""); //$NON-NLS-1$
-	String modInfo = readJarContent(packageSet);
+	readJarContent(packageSet);
 	PackageCache.put(zipFileName, new PackageCacheEntry(timestamp, fileSize, packageSet));
-	if (modInfo != null) {
-		try {
-			this.acceptModule(ClassFileReader.read(this.zipFile, modInfo));
-		} catch (ClassFormatException | IOException e) {
-			// TODO BETA_JAVA9 Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
 	return packageSet;
 }
 protected String readJarContent(final SimpleSet packageSet) {
@@ -116,15 +105,28 @@ protected String readJarContent(final SimpleSet packageSet) {
 	}
 	return modInfo;
 }
-void acceptModule(ClassFileReader classfile) {
-	if (classfile != null) {
-		IModule mod = classfile.getModuleDeclaration();
-		ModuleCache.put(this.zipFilename, mod);
-		acceptModule(mod);
+IModule initializeModule() {
+	IModule mod = null;
+	ZipFile file = null;
+	try {
+		file = new ZipFile(this.zipFilename);
+		ClassFileReader classfile = ClassFileReader.read(file, IModule.MODULE_INFO_CLASS);
+		if (classfile != null) {
+			mod = classfile.getModuleDeclaration();
+		}
+	} catch (ClassFormatException | IOException e) {
+		// do nothing
+	} finally {
+		try {
+			if (file != null)
+				file.close();
+		} catch (IOException e) {
+			// do nothing
+		}
 	}
+	return mod;
 }
 
-
 String zipFilename; // keep for equals
 IFile resource;
 ZipFile zipFile;
@@ -135,7 +137,7 @@ private SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
 String externalAnnotationPath;
 
-ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
+ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isOnModulePath) {
 	this.resource = resource;
 	try {
 		java.net.URI location = resource.getLocationURI();
@@ -153,11 +155,10 @@ ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotati
 	this.accessRuleSet = accessRuleSet;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
-	if (isAutomodule)
-		setAutomaticModule();
+	this.isOnModulePath = isOnModulePath;
 }
 
-ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
+ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isOnModulePath) {
 	this.zipFilename = zipFilename;
 	this.lastModified = lastModified;
 	this.zipFile = null;
@@ -166,37 +167,21 @@ ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet,
 	this.env = env;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
-	if (isAutomodule)
-		setAutomaticModule();
+	this.isOnModulePath = isOnModulePath;
 }
 
-public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
-	this(zipFile.getName(), accessRuleSet, externalAnnotationPath, env, isAutomodule);
+public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isOnModulePath) {
+	this(zipFile.getName(), accessRuleSet, externalAnnotationPath, env, isOnModulePath);
 	this.zipFile = zipFile;
 	this.closeZipFileAtEnd = true;
 }
 
-public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
-	this(fileName, 0, accessRuleSet, externalAnnotationPath, env, isAutomodule);
+public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isOnModulePath) {
+	this(fileName, 0, accessRuleSet, externalAnnotationPath, env, isOnModulePath);
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
-	if (isAutomodule)
-		setAutomaticModule();
 }
 
-void setAutomaticModule() {
-	this.isAutoModule = true;
-	acceptModule(new AutoModule(getFileName(this.zipFilename).toCharArray()));
-}
-private static String getFileName(String name) {
-	int index = name.lastIndexOf('.');
-	if (index != -1)
-		name = name.substring(0, index);
-	index = name.lastIndexOf(File.separatorChar);
-	if (index == -1)
-		return name;
-	return name.substring(index + 1);
-}
 public void cleanup() {
 	if (this.closeZipFileAtEnd) {
 		if (this.zipFile != null) {
@@ -227,7 +212,7 @@ public boolean equals(Object o) {
 			return false;
 	return this.zipFilename.equals(jar.zipFilename) 
 			&& lastModified() == jar.lastModified()
-			&& this.isAutoModule == jar.isAutoModule;
+			&& this.isOnModulePath == jar.isOnModulePath;
 }
 
 public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName, boolean asBinaryOnly) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index 4fadc24..d267404 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -28,7 +28,7 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public abstract class ClasspathLocation {
 
-	protected boolean isAutoModule;
+	protected boolean isOnModulePath;
 	protected IModule module;
 	abstract public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName);
 	abstract public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName, boolean asBinaryOnly);
@@ -44,6 +44,9 @@ public abstract class ClasspathLocation {
 	public void setModule (IModule mod) {
 		this.module = mod;
 	}
+	public IModule getModule() {
+		return this.module;
+	}
 	static ClasspathLocation forSourceFolder(IContainer sourceFolder, IContainer outputFolder,
 			char[][] inclusionPatterns, char[][] exclusionPatterns, boolean ignoreOptionalProblems,
 			INameEnvironment env) {
@@ -64,7 +67,7 @@ static ClasspathLocation forLibrary(String libraryPathname,
 			new ClasspathJrt(libraryPathname, annotationsPath, env) :
 				Util.archiveFormat(libraryPathname) == Util.JMOD_FILE ?
 					new ClasspathJMod(libraryPathname, lastModified, accessRuleSet, annotationsPath, env) :
-			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env, false);
+			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env, autoModule);
 
 }
 
@@ -93,15 +96,6 @@ public void reset() {
 
 public abstract String debugPathString();
 
-void acceptModule(IModule mod) {
-	if (mod != null) {
-		this.module = mod;
-	}
-}
-public IModule getModule() {
-	return this.module;
-}
-
 public char[][] singletonModuleNameIf(boolean condition) {
 	if (!condition)
 		return null;
@@ -109,13 +103,4 @@ public char[][] singletonModuleNameIf(boolean condition) {
 		return new char[][] { this.module.name() };
 	return new char[][] { ModuleBinding.UNNAMED };
 }
-
-/**
- * Specifies whether this entry represents an automatic module.
- * 
- * @return true if this is an automatic module, false otherwise
- */
-public boolean isAutomaticModule() {
-	return this.isAutoModule;
-}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
index b3c9218..041aea0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
@@ -15,10 +15,13 @@
 package org.eclipse.jdt.internal.core.builder;
 
 
+import java.io.File;
+
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
+import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 
 /**
  * Represents a project on the module path.
@@ -28,13 +31,20 @@ public class ModulePathEntry implements IModulePathEntry {
 	private IPath path;
 	/*private*/ ClasspathLocation[] locations;
 	IModule module;
+	boolean isAutomaticModule;
 
 	ModulePathEntry(IPath path, IModule module, ClasspathLocation[] locations) {
 		this.path = path;
 		this.locations = locations;
 		this.module = module;
+		this.isAutomaticModule = module.isAutomatic();
 		initializeModule();
 	}
+	public ModulePathEntry(IPath path, ClasspathLocation location) {
+		this.path = path;
+		initModule(location);
+		this.locations = new ClasspathLocation[] {location};
+	}
 	public IPath getPath() {
 		return this.path;
 	}
@@ -48,6 +58,44 @@ public class ModulePathEntry implements IModulePathEntry {
 		return this.module;
 	}
 
+	public boolean isAutomaticModule() {
+		return this.isAutomaticModule;
+	}
+	public static char[] getAutomaticModuleName(ClasspathLocation location) {
+		String name = null;
+		if (location instanceof ClasspathJar) {
+			name = ((ClasspathJar) location).zipFilename;
+			int index = name.lastIndexOf('.');
+			if (index != -1)
+				name = name.substring(0, index);
+			index = name.lastIndexOf(File.separatorChar);
+			if (index == -1)
+				return name.toCharArray();
+			return name.substring(index + 1).toCharArray();
+			
+		}
+		if (location instanceof ClasspathDirectory) {
+			return ((ClasspathDirectory) location).binaryFolder.getName().toCharArray();
+		}
+		return null;
+	}
+	private void initModule(ClasspathLocation location) {
+		IModule mod = null;
+		if (location instanceof ClasspathJar) {
+			mod = ((ClasspathJar) location).initializeModule();
+		} else if (location instanceof ClasspathDirectory){
+			mod = ((ClasspathDirectory) location).initializeModule();
+		}
+		if (mod != null) {
+			this.module = mod;
+			this.isAutomaticModule = false;
+		} else {
+			this.module = new AutoModule(getAutomaticModuleName(location));
+			this.isAutomaticModule = true;
+		}
+		location.setModule(this.module);
+	}
+
 	// TODO: This is only needed because SourceFile.module() uses the module set on the location
 	// Once we have a mechanism to map a folder to a module path entry, this should no longer be
 	// needed
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index 66965b8..fcb7465 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -28,6 +28,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
@@ -122,6 +123,7 @@ private void computeClasspathLocations(
 		Object target = JavaModel.getTarget(path, true);
 		IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, javaProject.getProject(), true);
 		if (target == null) continue nextEntry;
+		boolean isOnModulePath = entry.isAutomaticModule();
 
 		switch(entry.getEntryKind()) {
 			case IClasspathEntry.CPE_SOURCE :
@@ -168,7 +170,7 @@ private void computeClasspathLocations(
 							: (IContainer) root.getFolder(prereqOutputPath);
 						if (binaryFolder.exists() && !seen.contains(binaryFolder)) {
 							seen.add(binaryFolder);
-							ClasspathLocation bLocation = ClasspathLocation.forBinaryFolder(binaryFolder, true, entry.getAccessRuleSet(), externalAnnotationPath, this, entry.isAutomaticModule());
+							ClasspathLocation bLocation = ClasspathLocation.forBinaryFolder(binaryFolder, true, entry.getAccessRuleSet(), externalAnnotationPath, this, isOnModulePath);
 							bLocations.add(bLocation);
 							projectLocations.add(bLocation);
 							if (binaryLocationsPerProject != null) { // normal builder mode
@@ -185,15 +187,21 @@ private void computeClasspathLocations(
 						}
 					}
 				}
-				if (moduleEntries != null && (mod = prereqJavaProject.getModuleDescription()) != null && projectLocations.size() > 0) {
+				if (moduleEntries != null && isOnModulePath && projectLocations.size() > 0) {
+					IModule info = null;
 					try {
-						SourceModule sourceModule = (SourceModule)mod;
-						ModuleDescriptionInfo info = (ModuleDescriptionInfo) sourceModule.getElementInfo();
-						ModulePathEntry projectEntry = new ModulePathEntry(prereqJavaProject.getPath(), info, projectLocations.toArray(new ClasspathLocation[projectLocations.size()]));
-						moduleEntries.put(sourceModule.getElementName(), projectEntry);
+						if ((mod = prereqJavaProject.getModuleDescription()) != null) {
+							SourceModule sourceModule = (SourceModule) mod;
+							info = (ModuleDescriptionInfo) sourceModule.getElementInfo();
+						}
 					} catch (JavaModelException jme) {
 						// do nothing, probably a non module project
 					}
+					if (info == null)
+						info = new AutoModule(prereqJavaProject.getElementName().toCharArray());
+					ModulePathEntry projectEntry = new ModulePathEntry(prereqJavaProject.getPath(), info,
+							projectLocations.toArray(new ClasspathLocation[projectLocations.size()]));
+					moduleEntries.put(String.valueOf(info.name()), projectEntry);
 				}
 				continue nextEntry;
 
@@ -207,14 +215,14 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
+						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath, this, isOnModulePath);
 					} else if (resource instanceof IContainer) {
 						AccessRuleSet accessRuleSet =
 							(JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, true))
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forBinaryFolder((IContainer) target, false, accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());	 // is library folder not output folder
+						bLocation = ClasspathLocation.forBinaryFolder((IContainer) target, false, accessRuleSet, externalAnnotationPath, this, isOnModulePath);	 // is library folder not output folder
 					}
 					bLocations.add(bLocation);
 					// TODO: Ideally we need to do something like mapToModulePathEntry using the path and if it is indeed
@@ -225,8 +233,8 @@ private void computeClasspathLocations(
 							for (String moduleName : binaryModulePathEntry.getModuleNames()) {
 								moduleEntries.put(moduleName, binaryModulePathEntry);							
 							}
-						} else if (bLocation instanceof IModulePathEntry) {
-							IModulePathEntry binaryModulePathEntry = (IModulePathEntry) bLocation;
+						} else if (isOnModulePath) {
+							IModulePathEntry binaryModulePathEntry = new ModulePathEntry(path, bLocation);
 							IModule module = binaryModulePathEntry.getModule();
 							if (module != null)
 								moduleEntries.put(String.valueOf(module.name()), binaryModulePathEntry);
@@ -250,18 +258,16 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toOSString(), accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
+					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toOSString(), accessRuleSet, externalAnnotationPath, this, isOnModulePath);
 					bLocations.add(bLocation);
-					// TODO: Ideally we need to do something like mapToModulePathEntry using the path and if it is indeed
-					// a module path entry, then add the corresponding entry here, but that would need the target platform
 					if (moduleEntries != null) {
 						if (bLocation instanceof IMultiModuleEntry) {
 							IMultiModuleEntry binaryModulePathEntry = (IMultiModuleEntry) bLocation;
 							for (String moduleName : binaryModulePathEntry.getModuleNames()) {
 								moduleEntries.put(moduleName, binaryModulePathEntry);							
 							}
-						} else if (bLocation instanceof IModulePathEntry) {
-							IModulePathEntry binaryModulePathEntry = (IModulePathEntry) bLocation;
+						} else if (isOnModulePath) {
+							IModulePathEntry binaryModulePathEntry = new ModulePathEntry(path, bLocation);
 							IModule module = binaryModulePathEntry.getModule();
 							if (module != null)
 								moduleEntries.put(String.valueOf(module.name()), binaryModulePathEntry);
@@ -531,7 +537,7 @@ public IModule getModule(char[] name) {
 public IModule[] getAllAutomaticModules() {
 	if (this.modulePathEntries == null)
 		return IModule.NO_MODULES;
-	Set<IModule> set = this.modulePathEntries.values().stream().map(e -> e.getModule()).filter(m -> m.isAutomatic())
+	Set<IModule> set = this.modulePathEntries.values().stream().filter(m -> m.isAutomaticModule()).map(e -> e.getModule())
 			.collect(Collectors.toSet());
 	return set.toArray(new IModule[set.size()]);
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 4bc15a6..b2ba21f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -467,7 +467,7 @@ void write(DataOutputStream out) throws IOException {
 			out.writeBoolean(cd.isOutputFolder);
 			writeRestriction(cd.accessRuleSet, out);
 			out.writeUTF(cd.externalAnnotationPath != null ? cd.externalAnnotationPath : ""); //$NON-NLS-1$
-			out.writeBoolean(cd.isAutomaticModule());
+			out.writeBoolean(cd.isOnModulePath);
 		} else if (c instanceof ClasspathJar) {
 			ClasspathJar jar = (ClasspathJar) c;
 			if (jar.resource == null) {
@@ -480,7 +480,7 @@ void write(DataOutputStream out) throws IOException {
 			}
 			writeRestriction(jar.accessRuleSet, out);
 			out.writeUTF(jar.externalAnnotationPath != null ? jar.externalAnnotationPath : ""); //$NON-NLS-1$
-			out.writeBoolean(jar.isAutomaticModule());
+			out.writeBoolean(jar.isOnModulePath);
 		} else {
 			ClasspathJrt jrt = (ClasspathJrt) c;
 			out.writeByte(EXTERNAL_JAR);
commit 5af56213f16d92a1b250a06f621d76ce986be5ea
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Fri Jul 21 15:00:23 2017 +0530

    bug 518282 - fix for failing test
    
    Change-Id: Idb3a68d98e0713a187a367700717ce50733835c8

4	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index f214245..4f57fca 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -4074,7 +4074,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			IJavaProject p3 = setupModuleProject("test_automodules", src, new IClasspathEntry[] {dep, dep2});
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
-			assertMarkers("Unexpected markers", "World cannot be resolved to a type", markers);
+			sortMarkers(markers);
+			assertMarkers("Unexpected markers", 
+					"The import org cannot be resolved\n" +
+					"World cannot be resolved to a type", markers);
 		} finally {
 			this.deleteProject("test");
 			this.deleteProject("test_automodules");
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index 5224403..e50a3c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -358,7 +358,7 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 	 * search in all accessible modules.
 	 */
 	public char[] nameForLookup() {
-		if (this.moduleName == UNNAMED || this.isAuto)
+		if (this.moduleName == UNNAMED)
 			return ANY;
 		else
 			return this.moduleName;
commit 423aba2e1437d1be1177df8d51b87ef38772e823
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Tue Jul 25 17:12:52 2017 +0530

    Fixed Bug 518282: [9] Classes from automatic module seen in Content
    assist but using it gives Compilation error
    
    
    Change-Id: I39a032127e087bf6bbcfb4bcf1fdb3400f5cf051

4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
4	4	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
22	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
5	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 46c1249..3140465 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -3961,7 +3961,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 		}
 	}
 	// An automatic module grants implied readability to all other automatic modules
-	public void _testBug518282d() throws CoreException, IOException {
+	public void testBug518282d() throws CoreException, IOException {
 		if (!isJRE9) return;
 		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
 		String libPath = "externalLib/test.jar";
@@ -3975,8 +3975,8 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			};
 			IJavaProject p1 = setupModuleProject("org.astro", src);
 			src = new String[] { 
-				"src/com/greetings/Test.java",
-				"package com.greetings;\n" +
+				"src/org/greetings/Test.java",
+				"package org.greetings;\n" +
 				"import  org.astro.World;\n" +
 				"public class Test implements World {\n" +
 				"	public String name() {\n" +
@@ -3996,7 +3996,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"}",
 				"src/test/Main.java",
 				"package test;\n" +
-				"import com.greetings.Test;\n" +
+				"import org.greetings.Test;\n" +
 				"public class Main {\n" +
 				"	public static void main(String[] args) {\n" +
 				"		org.astro.World world = new Test();\n" +
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index 26c0d17..b409881 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -571,14 +571,14 @@ public IModule getModule(char[] name) {
 }
 
 @Override
-public IModule[] getAllAutomaticModules() {
-	Set<IModule> set = new HashSet<>();
+public char[][] getAllAutomaticModules() {
+	Set<char[]> set = new HashSet<>();
 	for (int i = 0, l = this.classpaths.length; i < l; i++) {
 		if (this.classpaths[i].isAutomaticModule()) {
-			set.add(this.classpaths[i].getModule());
+			set.add(this.classpaths[i].getModule().name());
 		}
 	}
-	return set.toArray(new IModule[set.size()]);
+	return set.toArray(new char[set.size()][]);
 }
 
 void addModuleUpdate(String moduleName, Consumer<IUpdatableModule> update, UpdateKind kind) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
index cbddb7c..4fc7cd7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
@@ -117,7 +117,7 @@ public interface IModuleAwareNameEnvironment extends INameEnvironment {
 	
 	/** Get the module with the given name, which must denote a named module. */
 	IModule getModule(char[] moduleName);
-	IModule[] getAllAutomaticModules();
+	char[][] getAllAutomaticModules();
 
 	/**
 	 * Ask the name environment to perform any updates (add-exports or add-reads) to the given module.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
index 6e948b8..61707ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import java.util.HashMap;
+import java.util.stream.Stream;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -22,6 +23,7 @@ import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModule.IModuleReference;
 import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
 import org.eclipse.jdt.internal.compiler.env.IModule.IService;
+import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 
 public class BinaryModuleBinding extends ModuleBinding {
 	
@@ -44,9 +46,15 @@ public class BinaryModuleBinding extends ModuleBinding {
 	
 	void cachePartsFrom(IModule module) {
 		this.isAuto = module.isAutomatic();
+
 		if (module.isOpen())
 			this.modifiers |= ClassFileConstants.ACC_OPEN;
 
+		if (this.isAuto) {
+			this.requires = Binding.NO_MODULES;
+			this.requiresTransitive = Binding.NO_MODULES;
+			this.exportedPackages = Binding.NO_PACKAGES;
+		} else {
 		IModuleReference[] requiresReferences = module.requires();
 		this.requires = new ModuleBinding[requiresReferences.length];
 		this.requiresTransitive = new ModuleBinding[requiresReferences.length];
@@ -65,7 +73,7 @@ public class BinaryModuleBinding extends ModuleBinding {
 			System.arraycopy(this.requires, 0, this.requires = new ModuleBinding[count], 0, count);
 		if (transitiveCount < this.requiresTransitive.length)
 			System.arraycopy(this.requiresTransitive, 0, this.requiresTransitive = new ModuleBinding[transitiveCount], 0, transitiveCount);
-
+		}
 		this.unresolvedExports = module.exports();
 		this.unresolvedOpens = module.opens();
 		this.unresolvedUses = module.uses();
@@ -83,7 +91,7 @@ public class BinaryModuleBinding extends ModuleBinding {
 	public PackageBinding[] getOpens() {
 		if (this.openedPackages == null && this.unresolvedOpens != null)
 			resolvePackages();
-		return super.getExports();
+		return super.getOpens();
 	}
 
 	private void resolvePackages() {
@@ -141,7 +149,18 @@ public class BinaryModuleBinding extends ModuleBinding {
 			resolveServices();
 		return super.getImplementations(binding);
 	}
-
+	public ModuleBinding[] getRequiresTransitive() {
+		if (this.isAuto) {
+			if (this.requiresTransitive == NO_MODULES) {
+				char[][] autoModules = ((IModuleAwareNameEnvironment)this.environment.nameEnvironment).getAllAutomaticModules();
+				return this.requiresTransitive = Stream.of(autoModules)
+					.filter(name -> !CharOperation.equals(name, this.moduleName))
+					.map(name -> this.environment.getModule(name)).filter(m -> m != null)
+					.toArray(ModuleBinding[]::new);
+			}
+		}
+		return super.getRequiresTransitive();
+	}
 	private void resolveServices() {
 		this.services = new TypeBinding[this.unresolvedProvides.length];
 		this.implementations = new HashMap<>();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index 027978c..4ebe57c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -921,8 +921,8 @@ public class SearchableEnvironment
 	}
 
 	@Override
-	public IModule[] getAllAutomaticModules() {
-		return new IModule[0];
+	public char[][] getAllAutomaticModules() {
+		return CharOperation.NO_CHAR_CHAR;
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index eeaf55b..d493feb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -608,12 +608,12 @@ public IModule getModule(char[] name) {
 }
 
 @Override
-public IModule[] getAllAutomaticModules() {
+public char[][] getAllAutomaticModules() {
 	if (this.modulePathEntries == null)
-		return IModule.NO_MODULES;
-	Set<IModule> set = this.modulePathEntries.values().stream().filter(m -> m.isAutomaticModule()).map(e -> e.getModule())
+		return CharOperation.NO_CHAR_CHAR;
+	Set<char[]> set = this.modulePathEntries.values().stream().filter(m -> m.isAutomaticModule()).map(e -> e.getModule().name())
 			.collect(Collectors.toSet());
-	return set.toArray(new IModule[set.size()]);
+	return set.toArray(new char[set.size()][]);
 }
 @Override
 public void applyModuleUpdates(IUpdatableModule compilerModule, IUpdatableModule.UpdateKind kind) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 1e2fc65..6b00e37 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -374,11 +374,11 @@ public IModule getModule(char[] moduleName) {
 }
 
 @Override
-public IModule[] getAllAutomaticModules() {
+public char[][] getAllAutomaticModules() {
 	if (this.moduleLocations == null || this.moduleLocations.size() == 0)
-		return IModule.NO_MODULES;
-	Set<IModule> set = this.moduleLocations.values().stream().map(e -> e.getModule()).filter(m -> m.isAutomatic())
-			.collect(Collectors.toSet());
-	return set.toArray(new IModule[set.size()]);
+		return CharOperation.NO_CHAR_CHAR;
+	Set<char[]> set = this.moduleLocations.values().stream().map(e -> e.getModule()).filter(m -> m != null && m.isAutomatic())
+			.map(m -> m.name()).collect(Collectors.toSet());
+	return set.toArray(new char[set.size()][]);
 }
 }
commit bf50826b7b628cad1b3a902d45c69bc3ffce6c3a
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Aug 11 23:46:37 2017 +0200

    Follow-up for Bug 518282: [9] Classes from automatic module seen in
    Content
    assist but using it gives Compilation error
    
    Change-Id: I08711e0a04d3e0c170261d78a899668085e967f8

35	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
8	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
index e6fac25..fdd9bf5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
@@ -27,34 +27,59 @@ import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 
 public class BinaryModuleBinding extends ModuleBinding {
 	
+	private static class AutomaticModuleBinding extends ModuleBinding {
+
+		public AutomaticModuleBinding(IModule module, LookupEnvironment existingEnvironment) {
+			super(module.name(), existingEnvironment);
+			existingEnvironment.root.knownModules.put(this.moduleName, this);
+			this.isAuto = true;
+			this.requires = Binding.NO_MODULES;
+			this.requiresTransitive = Binding.NO_MODULES;
+			this.exportedPackages = Binding.NO_PACKAGES;
+		}
+		public ModuleBinding[] getRequiresTransitive() {
+			if (this.requiresTransitive == NO_MODULES) {
+				char[][] autoModules = ((IModuleAwareNameEnvironment)this.environment.nameEnvironment).getAllAutomaticModules();
+				this.requiresTransitive = Stream.of(autoModules)
+					.filter(name -> !CharOperation.equals(name, this.moduleName))
+					.map(name -> this.environment.getModule(name)).filter(m -> m != null)
+					.toArray(ModuleBinding[]::new);
+			}
+			return this.requiresTransitive;
+		}
+		@Override
+		public char[] nameForLookup() {
+			return ANY_NAMED;
+		}
+	}
+	
 	private IPackageExport[] unresolvedExports;
 	private IPackageExport[] unresolvedOpens;
 	private char[][] unresolvedUses;
 	private IService[] unresolvedProvides;
 	
 	/**
-	 * Construct a named module from binary.
+	 * Construct a named module from binary, could be an auto module.
 	 * <p>
 	 * <strong>Side effects:</strong> adds the new module to root.knownModules and resolves its directives.
 	 * </p>
 	 */
-	public BinaryModuleBinding(IModule module, LookupEnvironment existingEnvironment) {
+	public static ModuleBinding create(IModule module, LookupEnvironment existingEnvironment) {
+		if (module.isAutomatic())
+			return new AutomaticModuleBinding(module, existingEnvironment);
+		return new BinaryModuleBinding(module, existingEnvironment);
+	}
+
+	private BinaryModuleBinding(IModule module, LookupEnvironment existingEnvironment) {
 		super(module.name(), existingEnvironment);
 		existingEnvironment.root.knownModules.put(this.moduleName, this);
 		cachePartsFrom(module);
 	}
 	
 	void cachePartsFrom(IModule module) {
-		this.isAuto = module.isAutomatic();
-
 		if (module.isOpen())
 			this.modifiers |= ClassFileConstants.ACC_OPEN;
 
-		if (this.isAuto) {
-			this.requires = Binding.NO_MODULES;
-			this.requiresTransitive = Binding.NO_MODULES;
-			this.exportedPackages = Binding.NO_PACKAGES;
-		} else {
 		IModuleReference[] requiresReferences = module.requires();
 		this.requires = new ModuleBinding[requiresReferences.length];
 		this.requiresTransitive = new ModuleBinding[requiresReferences.length];
@@ -73,7 +98,7 @@ public class BinaryModuleBinding extends ModuleBinding {
 			System.arraycopy(this.requires, 0, this.requires = new ModuleBinding[count], 0, count);
 		if (transitiveCount < this.requiresTransitive.length)
 			System.arraycopy(this.requiresTransitive, 0, this.requiresTransitive = new ModuleBinding[transitiveCount], 0, transitiveCount);
-		}
+
 		this.unresolvedExports = module.exports();
 		this.unresolvedOpens = module.opens();
 		this.unresolvedUses = module.uses();
@@ -150,18 +175,6 @@ public class BinaryModuleBinding extends ModuleBinding {
 			resolveServices();
 		return super.getImplementations(binding);
 	}
-	public ModuleBinding[] getRequiresTransitive() {
-		if (this.isAuto) {
-			if (this.requiresTransitive == NO_MODULES) {
-				char[][] autoModules = ((IModuleAwareNameEnvironment)this.environment.nameEnvironment).getAllAutomaticModules();
-				return this.requiresTransitive = Stream.of(autoModules)
-					.filter(name -> !CharOperation.equals(name, this.moduleName))
-					.map(name -> this.environment.getModule(name)).filter(m -> m != null)
-					.toArray(ModuleBinding[]::new);
-			}
-		}
-		return super.getRequiresTransitive();
-	}
 	private void resolveServices() {
 		this.services = new TypeBinding[this.unresolvedProvides.length];
 		this.implementations = new HashMap<>();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 6aa1b04..a3847e9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -207,7 +207,7 @@ public ModuleBinding getModule(char[] name) {
 		if (this.useModuleSystem) {
 			IModule mod = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModule(name);
 			if (mod != null) {
-				moduleBinding = new BinaryModuleBinding(mod, this);
+				moduleBinding = BinaryModuleBinding.create(mod, this);
 			}
 		} else 
 			return this.UnNamedModule;
@@ -422,7 +422,7 @@ private ModuleBinding getModuleFromAnswer(NameEnvironmentAnswer answer) {
 			if (moduleBinding == null && this.nameEnvironment instanceof IModuleAwareNameEnvironment) {
 				assert answer.isBinaryType();
 				IModule iModule = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModule(moduleName);
-				moduleBinding = new BinaryModuleBinding(iModule, this);
+				moduleBinding = BinaryModuleBinding.create(iModule, this);
 			}
 		}
 		return moduleBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index faa27e6..dc67f49 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -83,6 +83,10 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 			return true;
 		}
 		@Override
+		public char[] nameForLookup() {
+			return ANY;
+		}
+		@Override
 		public char[] readableName() {
 			return UNNAMED_READABLE_NAME;
 		}
@@ -105,7 +109,7 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 	public LookupEnvironment environment;
 	public int tagBits;
 	ModuleBinding[] requiredModules = null;
-	boolean isAuto;
+	boolean isAuto = false;
 	private boolean[] isComplete = new boolean[UpdateKind.values().length];
 	private Set<ModuleBinding> transitiveRequires;
 
@@ -133,7 +137,6 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 		this.uses = Binding.NO_TYPES;
 		this.services = Binding.NO_TYPES;
 		this.declaredPackages = new HashtableOfPackage(5);
-		this.isAuto = false;
 	}
 
 	/* For sub class BinaryModuleBinding */
@@ -365,16 +368,11 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 
 	/**
 	 * Answer the name of this module as it should be used for package or type lookup.
-	 * Unnamed and automatic modules answer {@link #ANY}, to signal that lookup should
-	 * search in all accessible modules.
+	 * Unnamed and automatic modules answer {@link #ANY} or {@link #ANY_NAMED} resp.,
+	 * to signal that lookup should search in all accessible (named) modules.
 	 */
 	public char[] nameForLookup() {
-		if (this.moduleName == UNNAMED)
-			return ANY;
-		else if (this.isAuto)
-			return ANY_NAMED;
-		else
-			return this.moduleName;
+		return this.moduleName;
 	}
 
 	/**
