commit 2caa59d033a9b6c8ec71aab586472ad7fe749893
Author: Stephan Herrmann <stephan@cs.tu-berlin.de>
Date:   Tue Nov 20 18:07:11 2012 +0100

    Bug 392862 - [1.8][compiler][null] Evaluate null annotations on array
    types

9	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
392	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
22	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
8	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
18	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
82	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
41	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
60	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
9	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
23	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
15	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
92	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
9	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index a398fb9..6840b97 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -22,6 +22,7 @@
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
  *								bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -367,6 +368,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ArgumentTypeNotFound", DEPRECATED);
 		expectedProblemAttributes.put("ArgumentTypeNotVisible", DEPRECATED);
 		expectedProblemAttributes.put("ArrayConstantsOnlyInArrayInitializers", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("ArrayReferencePotentialNullReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ArrayReferenceRequired", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("AssignmentHasNoEffect", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("AssignmentToMultiCatchParameter", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -418,6 +420,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("DefaultMethodNotBelow18", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("DefaultMethodOverridesObjectMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("DereferencingNullableExpression", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("DiamondNotBelow17", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -776,6 +779,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationUnchecked", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullSourceString", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("NumericValueOutOfRange", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ObjectCannotBeGeneric", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -1096,6 +1101,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ArgumentTypeNotFound", SKIP);
 		expectedProblemAttributes.put("ArgumentTypeNotVisible", SKIP);
 		expectedProblemAttributes.put("ArrayConstantsOnlyInArrayInitializers", SKIP);
+		expectedProblemAttributes.put("ArrayReferencePotentialNullReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("ArrayReferenceRequired", SKIP);
 		expectedProblemAttributes.put("AssignmentHasNoEffect", new ProblemAttributes(JavaCore.COMPILER_PB_NO_EFFECT_ASSIGNMENT));
 		expectedProblemAttributes.put("AssignmentToMultiCatchParameter", SKIP);
@@ -1147,6 +1153,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(JavaCore.COMPILER_PB_DEAD_CODE));
 		expectedProblemAttributes.put("DefaultMethodNotBelow18", SKIP);
 		expectedProblemAttributes.put("DefaultMethodOverridesObjectMethod", SKIP);
+		expectedProblemAttributes.put("DereferencingNullableExpression", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("DiamondNotBelow17", SKIP);
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", SKIP);
@@ -1502,6 +1509,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleField", SKIP);
 		expectedProblemAttributes.put("NotVisibleMethod", SKIP);
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationUnchecked", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 4d40987..019a92b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -50,7 +50,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testMissingAnnotationTypes_01" };
+//			TESTS_NAMES = new String[] { "testArrayType_05" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -376,7 +376,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. ERROR in B.java (at line 4)\n" + 
 			"	ai.foo(null); // problems: ai can be null, arg must not be null\n" + 
 			"	^^\n" + 
-			"Potential null pointer access: The variable ai may be null at this location\n" + 
+			"Potential null pointer access: this expression has a '@Nullable' type\n" + 
 			"----------\n" + 
 			"2. ERROR in B.java (at line 4)\n" + 
 			"	ai.foo(null); // problems: ai can be null, arg must not be null\n" + 
@@ -409,4 +409,394 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"Missing2 cannot be resolved to a type\n" + 
 			"----------\n");
 	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// annotation on leaf type in 1-dim array
+	public void testArrayType_01() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"Wrapper.java",
+				  "public class Wrapper<T> {\n" +
+				  "	T content;" +
+				  "	public T content() { return content; }\n" +
+				  "}\n",
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+// Using Wrapper is a workaround until bug 391331 is fixed (to force the interesting annotation to be consumed as a type annotation):
+				  "    void bar(Wrapper<@NonNull String[]> realStrings, Wrapper<@Nullable String[]> maybeStrings) {\n" +
+				  "        System.out.println(realStrings.content()[0].toUpperCase()); // no problem\n" +
+				  "        realStrings.content()[0] = null; // problem: cannot assign null as @NonNull element\n" +
+				  "        System.out.println(maybeStrings.content()[0].toUpperCase()); // problem: element can be null\n" +
+				  "        maybeStrings.content()[0] = null; // no problem\n" +
+				  "    }\n" +
+				  "}\n"},
+		    "----------\n" + 
+			"1. ERROR in A.java (at line 5)\n" + 
+			"	realStrings.content()[0] = null; // problem: cannot assign null as @NonNull element\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+			"----------\n" + 
+			"2. ERROR in A.java (at line 6)\n" + 
+			"	System.out.println(maybeStrings.content()[0].toUpperCase()); // problem: element can be null\n" + 
+			"	                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Potential null pointer access: array element may be null\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// annotation on leaf type in 2-dim array
+	public void testArrayType_02() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"Wrapper.java",
+				  "public class Wrapper<T> {\n" +
+				  "	T content;" +
+				  "	public T content() { return content; }\n" +
+				  "}\n",
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+// Using Wrapper is a workaround until bug 391331 is fixed (to force the interesting annotation to be consumed as a type annotation):
+				  "    void bar(Wrapper<@NonNull String[][]> realStrings, Wrapper<@Nullable String[][]> maybeStrings) {\n" +
+				  "        System.out.println(realStrings.content()[0][0].toUpperCase()); // no problem\n" +
+				  "        realStrings.content()[0][0] = null; // problem: cannot assign null as @NonNull element\n" +
+				  "        System.out.println(maybeStrings.content()[0][0].toUpperCase()); // problem: element can be null\n" +
+				  "        maybeStrings.content()[0][0] = null; // no problem\n" +
+				  "    }\n" +
+				  "}\n"},
+		    "----------\n" + 
+			"1. ERROR in A.java (at line 5)\n" + 
+			"	realStrings.content()[0][0] = null; // problem: cannot assign null as @NonNull element\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+			"----------\n" + 
+			"2. ERROR in A.java (at line 6)\n" + 
+			"	System.out.println(maybeStrings.content()[0][0].toUpperCase()); // problem: element can be null\n" + 
+			"	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Potential null pointer access: array element may be null\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// annotation on array type (1-dim array)
+	public void testArrayType_03() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+				  "    void array(String @NonNull[] realStringArray, String @Nullable[] maybeStringArray) {\n" +
+				  "        @NonNull Object array;\n" +
+				  "        array = realStringArray;  // no problem\n" +
+				  "        realStringArray = null; 	 // problem: cannot assign null as @NonNull array\n" +
+				  "        array = maybeStringArray; // problem: array can be null\n" +
+				  "        maybeStringArray = null;  // no problem\n" +
+				  "    }\n" +
+				  "    void leaf(String @NonNull[] realStringArray, String @Nullable[] maybeStringArray) {\n" +
+				  "        @NonNull String string;\n" +
+				  "        string = realStringArray[0];  // problem: unchecked conversion\n" +
+				  "        realStringArray[0] = null; 	 // no problem\n" +
+				  "        string = maybeStringArray[0]; // problems: indexing nullable array & unchecked conversion\n" +
+				  "        maybeStringArray[0] = null; 	 // problem: indexing nullable array\n" +
+				  "    }\n" +
+				  "}\n"},
+		    "----------\n" + 
+    		"1. ERROR in A.java (at line 7)\n" + 
+    		"	array = maybeStringArray; // problem: array can be null\n" + 
+    		"	        ^^^^^^^^^^^^^^^^\n" + 
+    		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" + 
+    		"----------\n" + 
+    		"2. WARNING in A.java (at line 12)\n" + 
+    		"	string = realStringArray[0];  // problem: unchecked conversion\n" + 
+    		"	         ^^^^^^^^^^^^^^^^^^\n" + 
+    		"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" + 
+    		"----------\n" + 
+    		"3. ERROR in A.java (at line 14)\n" + 
+    		"	string = maybeStringArray[0]; // problems: indexing nullable array & unchecked conversion\n" + 
+    		"	         ^^^^^^^^^^^^^^^^\n" + 
+    		"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+    		"----------\n" + 
+    		"4. WARNING in A.java (at line 14)\n" + 
+    		"	string = maybeStringArray[0]; // problems: indexing nullable array & unchecked conversion\n" + 
+    		"	         ^^^^^^^^^^^^^^^^^^^\n" + 
+    		"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" + 
+    		"----------\n" + 
+    		"5. ERROR in A.java (at line 15)\n" + 
+    		"	maybeStringArray[0] = null; 	 // problem: indexing nullable array\n" + 
+    		"	^^^^^^^^^^^^^^^^\n" + 
+    		"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// annotation on intermediate type in 2-dim array
+	public void testArrayType_04() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+				  "    void outer(String [] @NonNull[] realArrays, String [] @Nullable[] maybeArrays) {\n" +
+				  "        @NonNull Object array;\n" +
+				  "        array = realArrays; 		// problem: unchecked conversion\n" +
+				  "        realArrays = null; 		// no problem, outer array is unspecified\n" +
+				  "        array = maybeArrays; 	// problem: unchecked conversion\n" +
+				  "        maybeArrays = null; 		// no problem\n" +
+				  "    }\n" +
+				  "    void inner(String [] @NonNull[] realArrays, String [] @Nullable[] maybeArrays) {\n" +
+				  "        @NonNull Object array;\n" +
+				  "        array = realArrays[0]; 	// no problem\n" +
+				  "        realArrays[0] = null; 	// problem: cannot assign null to @NonNull array\n" +
+				  "        array = maybeArrays[0]; 	// problem: element can be null\n" +
+				  "        maybeArrays[0] = null; 	// no problem\n" +
+				  "    }\n" +
+				  "    void leaf(String [] @NonNull[] realArrays, String [] @Nullable[] maybeArrays) {\n" +
+				  "        @NonNull Object array;\n" +
+				  "        array = realArrays[0][0]; // problem: unchecked conversion\n" +
+				  "        realArrays[0][0] = null;  // no problem, element type is unspecified\n" +
+				  "        array = maybeArrays[0][0]; // problems: indexing nullable array & unchecked conversion\n" +
+				  "        maybeArrays[0][0] = null; // problem: indexing nullable array\n" +
+				  "    }\n" +
+				  "}\n"},
+		    "----------\n" + 
+    		"1. WARNING in A.java (at line 5)\n" + 
+    		"	array = realArrays; 		// problem: unchecked conversion\n" + 
+    		"	        ^^^^^^^^^^\n" + 
+    		"Null type safety: The expression of type String[][] needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+		    "----------\n" + 
+			"2. WARNING in A.java (at line 7)\n" + 
+    		"	array = maybeArrays; 	// problem: unchecked conversion\n" + 
+    		"	        ^^^^^^^^^^^\n" + 
+    		"Null type safety: The expression of type String[][] needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+			"----------\n" + 
+			"3. ERROR in A.java (at line 13)\n" + 
+			"	realArrays[0] = null; 	// problem: cannot assign null to @NonNull array\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Null type mismatch: required \'String @NonNull[]\' but the provided value is null\n" + 
+			"----------\n" + 
+			"4. ERROR in A.java (at line 14)\n" +
+			"	array = maybeArrays[0]; 	// problem: element can be null\n" +
+			"	        ^^^^^^^^^^^^^^\n" + 
+			"Null type mismatch: required '@NonNull Object' but the provided value is inferred as @Nullable\n" + 
+			"----------\n" + 
+			"5. WARNING in A.java (at line 19)\n" +
+			"	array = realArrays[0][0]; // problem: unchecked conversion\n" +
+			"	        ^^^^^^^^^^^^^^^^\n" +
+    		"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+			"----------\n" + 
+			"6. ERROR in A.java (at line 21)\n" +
+			"	array = maybeArrays[0][0]; // problems: indexing nullable array & unchecked conversion\n" +
+			"	        ^^^^^^^^^^^^^^\n" +
+    		"Potential null pointer access: array element may be null\n" + 
+			"----------\n" + 
+			"7. WARNING in A.java (at line 21)\n" +
+			"	array = maybeArrays[0][0]; // problems: indexing nullable array & unchecked conversion\n" +
+			"	        ^^^^^^^^^^^^^^^^^\n" +
+			"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull Object\'\n" +
+			"----------\n" + 
+			"8. ERROR in A.java (at line 22)\n" + 
+			"	maybeArrays[0][0] = null; // problem: indexing nullable array\n" + 
+			"	^^^^^^^^^^^^^^\n" + 
+			"Potential null pointer access: array element may be null\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// mismatches against outer array type, test display of type annotation in error messages
+	public void testArrayType_05() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+				  "    void outer(String @NonNull[] @NonNull[] realArrays, String @NonNull[] @Nullable[] maybeArrays, String @Nullable[][] unknownArrays) {\n" +
+				  "        realArrays[0] = maybeArrays[0];		// problem: inner array can be null\n" +
+				  "        realArrays[0] = unknownArrays[0];	// problems: inner array is unspecified, outer can be null\n" +
+				  "    }\n" +
+				  "    void oneDim(String @Nullable[] maybeStrings, String[] unknownStrings) {\n" +
+				  "        String @NonNull[] s = maybeStrings;\n" +
+				  "        s = unknownStrings;\n" +
+				  "        consume(maybeStrings);\n" +
+				  "        consume(unknownStrings);\n" +
+				  "    }\n" +
+				  "    void consume(String @NonNull[] s) {};\n" +
+				  "}\n"},
+			"----------\n" + 
+			"1. ERROR in A.java (at line 4)\n" + 
+			"	realArrays[0] = maybeArrays[0];		// problem: inner array can be null\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Null type mismatch: required \'String @NonNull[]\' but the provided value is inferred as @Nullable\n" + 
+			"----------\n" + 
+			"2. WARNING in A.java (at line 5)\n" + 
+			"	realArrays[0] = unknownArrays[0];	// problems: inner array is unspecified, outer can be null\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Null type safety: The expression of type String[] needs unchecked conversion to conform to \'String @NonNull[]\'\n" + 
+			"----------\n" + 
+			"3. ERROR in A.java (at line 5)\n" + 
+			"	realArrays[0] = unknownArrays[0];	// problems: inner array is unspecified, outer can be null\n" + 
+			"	                ^^^^^^^^^^^^^\n" + 
+			"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
+			"----------\n" + 
+			"4. ERROR in A.java (at line 8)\n" + 
+			"	String @NonNull[] s = maybeStrings;\n" + 
+			"	                      ^^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[]\' but this expression has type \'String @Nullable[]\'\n" + 
+			"----------\n" + 
+			"5. WARNING in A.java (at line 9)\n" + 
+			"	s = unknownStrings;\n" + 
+			"	    ^^^^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): the expression of type \'String[]\' needs unchecked conversion to conform to \'String @NonNull[]\'\n" + 
+			"----------\n" + 
+			"6. ERROR in A.java (at line 10)\n" + 
+			"	consume(maybeStrings);\n" + 
+			"	        ^^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[]\' but this expression has type \'String @Nullable[]\'\n" + 
+			"----------\n" + 
+			"7. WARNING in A.java (at line 11)\n" + 
+			"	consume(unknownStrings);\n" + 
+			"	        ^^^^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): the expression of type \'String[]\' needs unchecked conversion to conform to \'String @NonNull[]\'\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
+	// bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+	// more compiler messages
+	public void testArrayType_10() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"A.java",
+				  "import org.foo.*;\n" +
+				  "public class A {\n" +
+				  "    void outer(String @NonNull[] @NonNull[] realArrays, String @NonNull[] @Nullable[] maybeArrays, String @Nullable[][] unknownArrays, String @NonNull[][] mixedArrays) {\n" +
+				  "        realArrays = maybeArrays;			// problem on inner dimension!\n" +
+				  "        realArrays = unknownArrays; 			// problems on both dimensions\n" +
+				  "        maybeArrays = realArrays;			// problem on inner dimension\n" +
+				  "        unknownArrays = maybeArrays;			// problsm on outer dimension\n" +
+				  "        realArrays = mixedArrays;			// problem on inner\n" +
+				  "        maybeArrays = mixedArrays;			// problem on inner\n" +
+				  "        consume(maybeArrays, mixedArrays, maybeArrays);\n" +
+				  "    }\n" +
+				  "    void consume(String @NonNull[] @NonNull[] realStrings, String @NonNull[] @Nullable[] maybeArrays, String @Nullable[][] unknownArrays) {\n" +
+				  "    }\n" +
+				  "}\n"},
+			"----------\n" + 
+			"1. ERROR in A.java (at line 4)\n" + 
+			"	realArrays = maybeArrays;			// problem on inner dimension!\n" + 
+			"	             ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[] @NonNull[]\' but this expression has type \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n" + 
+			"2. ERROR in A.java (at line 5)\n" + 
+			"	realArrays = unknownArrays; 			// problems on both dimensions\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[] @NonNull[]\' but this expression has type \'String @Nullable[] []\'\n" + 
+			"----------\n" + 
+			"3. ERROR in A.java (at line 6)\n" + 
+			"	maybeArrays = realArrays;			// problem on inner dimension\n" + 
+			"	              ^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[] @Nullable[]\' but this expression has type \'String @NonNull[] @NonNull[]\'\n" + 
+			"----------\n" + 
+			"4. ERROR in A.java (at line 7)\n" + 
+			"	unknownArrays = maybeArrays;			// problsm on outer dimension\n" + 
+			"	                ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @Nullable[] []\' but this expression has type \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n" + 
+			"5. WARNING in A.java (at line 8)\n" + 
+			"	realArrays = mixedArrays;			// problem on inner\n" + 
+			"	             ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): the expression of type \'String @NonNull[] []\' needs unchecked conversion to conform to \'String @NonNull[] @NonNull[]\'\n" + 
+			"----------\n" + 
+			"6. WARNING in A.java (at line 9)\n" + 
+			"	maybeArrays = mixedArrays;			// problem on inner\n" + 
+			"	              ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): the expression of type \'String @NonNull[] []\' needs unchecked conversion to conform to \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n" + 
+			"7. ERROR in A.java (at line 10)\n" + 
+			"	consume(maybeArrays, mixedArrays, maybeArrays);\n" + 
+			"	        ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @NonNull[] @NonNull[]\' but this expression has type \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n" + 
+			"8. WARNING in A.java (at line 10)\n" + 
+			"	consume(maybeArrays, mixedArrays, maybeArrays);\n" + 
+			"	                     ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): the expression of type \'String @NonNull[] []\' needs unchecked conversion to conform to \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n" + 
+			"9. ERROR in A.java (at line 10)\n" + 
+			"	consume(maybeArrays, mixedArrays, maybeArrays);\n" + 
+			"	                                  ^^^^^^^^^^^\n" + 
+			"Null type mismatch (type annotations): required \'String @Nullable[] []\' but this expression has type \'String @NonNull[] @Nullable[]\'\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
index e2798de..c77fcd0 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
@@ -11,6 +11,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.core.tests;
 
@@ -31,6 +33,7 @@ import org.eclipse.jdt.core.tests.compiler.regression.DefaultMethodsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.GrammarCoverageTests308;
 import org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.NegativeTypeAnnotationTest;
+import org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest;
 import org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test;
 import org.eclipse.jdt.core.tests.dom.ASTConverterAST8Test;
 import org.eclipse.jdt.core.tests.dom.ASTConverterBugsTestJLS8;
@@ -52,7 +55,8 @@ public class RunAllJava8Tests extends TestCase {
 			ReferenceExpressionSyntaxTest.class,
 			DefaultMethodsTest.class,
 			ComplianceDiagnoseTest.class,
-			GrammarCoverageTests308.class
+			GrammarCoverageTests308.class,
+			NullTypeAnnotationTest.class
 		};
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index d9f0206..ce3b464 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -157,6 +157,10 @@
  *									InheritedDefaultMethodConflictsWithOtherInherited
  *									ConflictingNullAnnotations
  *									ConflictingInheritedNullAnnotations
+ *									ArrayReferencePotentialNullReference
+ *									DereferencingNullableExpression
+ *									NullityMismatchingTypeAnnotation
+ *									NullityMismatchingTypeAnnotationUnchecked
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -1550,7 +1554,15 @@ void setSourceStart(int sourceStart);
 	/** @since 3.9 */
 	int ConflictingInheritedNullAnnotations = MethodRelated + 940;
 	
-	
+	/** @since 3.9 */
+	int ArrayReferencePotentialNullReference = Internal + 951;
+	/** @since 3.9 */
+	int DereferencingNullableExpression = Internal + 952;
+	/** @since 3.9 */
+	int NullityMismatchingTypeAnnotation = Internal + 953;
+	/** @since 3.9 */
+	int NullityMismatchingTypeAnnotationUnchecked = Internal + 954;
+
 	// Java 8 work
 	/** @since 3.9 */
 	int IllegalModifiersForElidedType = Internal + 1001;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index 55d4cac..24e87d4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -5,10 +5,15 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -19,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
@@ -40,12 +46,19 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 	if (assignment.expression == null) {
 		return analyseCode(currentScope, flowContext, flowInfo);
 	}
-	return assignment
+	flowInfo = assignment
 		.expression
 		.analyseCode(
 			currentScope,
 			flowContext,
 			analyseCode(currentScope, flowContext, flowInfo).unconditionalInits());
+	if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
+		int nullStatus = assignment.expression.nullStatus(flowInfo);
+		if (nullStatus != FlowInfo.NON_NULL) {
+			currentScope.problemReporter().nullityMismatch(this, assignment.expression.resolvedType, this.resolvedType, nullStatus, currentScope.environment().getNonNullAnnotationName());
+		}
+	}
+	return flowInfo;
 }
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -57,6 +70,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if ((this.resolvedType.tagBits & TagBits.AnnotationNullable) != 0) {
+		scope.problemReporter().arrayReferencePotentialNullReference(this);
+	} else {
+		super.checkNPE(scope, flowContext, flowInfo);
+	}
+}
+
 public void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired) {
 	int pc = codeStream.position;
 	this.receiver.generateCode(currentScope, codeStream, true);
@@ -167,10 +188,6 @@ public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream
 	codeStream.arrayAtPut(this.resolvedType.id, false);
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public StringBuffer printExpression(int indent, StringBuffer output) {
 	this.receiver.printExpression(0, output).append('[');
 	return this.position.printExpression(0, output).append(']');
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 41f3b9f..b2695d9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -5,11 +5,16 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
  *								bug 292478 - Report potentially null across variable assignment
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -527,6 +532,16 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
  * @param flowInfo the upstream flow info; caveat: may get modified
  */
 public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (this.resolvedType != null) {
+		if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
+			return; // no danger
+		} else if ((this.resolvedType.tagBits & TagBits.AnnotationNullable) != 0) {
+			scope.problemReporter().dereferencingNullableExpression(this, scope.environment());
+			return; // danger is definite.
+			// stopping analysis at this point requires that the above error is not suppressable
+			// unless suppressing all null warnings (otherwise we'd miss a stronger warning below).
+		}
+	}
 	LocalVariableBinding local = localVariableBinding();
 	if (local != null &&
 			(local.type.tagBits & TagBits.IsBaseType) == 0) {
@@ -869,7 +884,7 @@ public int nullStatus(FlowInfo flowInfo) {
 
 	if (/* (this.bits & IsNonNull) != 0 || */
 		this.constant != null && this.constant != Constant.NotAConstant)
-	return FlowInfo.NON_NULL; // constant expression cannot be null
+		return FlowInfo.NON_NULL; // constant expression cannot be null
 
 	LocalVariableBinding local = localVariableBinding();
 	if (local != null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 0803095..ba0cdd2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Nick Teryaev - fix for bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=40752)
@@ -19,6 +23,7 @@
  *								bug 379784 - [compiler] "Method can be static" is not getting reported
  *								bug 379834 - Wrong "method can be static" in presence of qualified super and different staticness of nested super class.
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -165,9 +170,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	super.checkNPE(scope, flowContext, flowInfo);
-	if ((nullStatus(flowInfo) & FlowInfo.POTENTIALLY_NULL) != 0)
+	if ((nullStatus(flowInfo) & FlowInfo.POTENTIALLY_NULL) != 0) // note that flowInfo is not used inside nullStatus(..)
 		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+	else
+		super.checkNPE(scope, flowContext, flowInfo);
 }
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index 1196cdc..071429d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -5,9 +5,15 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -22,6 +28,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
@@ -92,6 +99,16 @@ public abstract void generateCompoundAssignment(BlockScope currentScope, CodeStr
 
 public abstract void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired);
 
+public int nullStatus(FlowInfo flowInfo) {
+	if (this.resolvedType != null) {
+		if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0)
+			return FlowInfo.NON_NULL;
+		else if ((this.resolvedType.tagBits & TagBits.AnnotationNullable) != 0)
+			return FlowInfo.POTENTIALLY_NULL;
+	}
+	return FlowInfo.UNKNOWN;
+}
+
 /* report if a private field is only read from a 'special operator',
  * i.e., in a postIncrement expression or a compound assignment,
  * where the information is never flowing out off the field. */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index c4b035b..1a14bbb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -15,11 +19,14 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370930 - NonNull annotation not considered for enhanced for loops
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
@@ -67,35 +74,57 @@ public abstract FlowInfo analyseCode(BlockScope currentScope, FlowContext flowCo
 protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)
 {
 	// compare actual null-status against parameter annotations of the called method:
-	if (arguments != null && methodBinding.parameterNonNullness != null) {
-
-		// check if varargs need special treatment:
+	if (arguments != null) {
+		CompilerOptions compilerOptions = currentScope.compilerOptions();
+		boolean considerTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8
+				&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;
+		boolean hasJDK15NullAnnotations = methodBinding.parameterNonNullness != null;
 		int numParamsToCheck = methodBinding.parameters.length;
-		boolean passThrough = false;
-		if (methodBinding.isVarargs()) {
-			int varArgPos = numParamsToCheck-1;
-			// this if-block essentially copied from generateArguments(..):
-			if (numParamsToCheck == arguments.length) {
-				TypeBinding varArgsType = methodBinding.parameters[varArgPos];
-				TypeBinding lastType = arguments[varArgPos].resolvedType;
-				if (lastType == TypeBinding.NULL
-						|| (varArgsType.dimensions() == lastType.dimensions()
-						&& lastType.isCompatibleWith(varArgsType)))
-					passThrough = true; // pass directly as-is
+		if (considerTypeAnnotations || hasJDK15NullAnnotations) {
+			// check if varargs need special treatment:
+			boolean passThrough = false;
+			if (methodBinding.isVarargs()) {
+				int varArgPos = numParamsToCheck-1;
+				// this if-block essentially copied from generateArguments(..):
+				if (numParamsToCheck == arguments.length) {
+					TypeBinding varArgsType = methodBinding.parameters[varArgPos];
+					TypeBinding lastType = arguments[varArgPos].resolvedType;
+					if (lastType == TypeBinding.NULL
+							|| (varArgsType.dimensions() == lastType.dimensions()
+							&& lastType.isCompatibleWith(varArgsType)))
+						passThrough = true; // pass directly as-is
+				}
+				if (!passThrough)
+					numParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check
 			}
-			if (!passThrough)
-				numParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check
 		}
-
-		for (int i = 0; i < numParamsToCheck; i++) {
-			if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
+		if (considerTypeAnnotations) {
+			for (int i=0; i<numParamsToCheck; i++) {
 				TypeBinding expectedType = methodBinding.parameters[i];
 				Expression argument = arguments[i];
-				int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
-				if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
-					flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
+				// prefer check based on type annotations:
+				int severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType);
+				if (severity > 0) {
+					// immediate reporting:
+					currentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity==1, currentScope.environment());
+					// next check flow-based null status against null JDK15-style annotations:
+				} else if (hasJDK15NullAnnotations && methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
+					int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+					if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
+						flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
+				}
 			}
-		}
+		} else if (hasJDK15NullAnnotations) {
+			for (int i = 0; i < numParamsToCheck; i++) {
+				if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
+					TypeBinding expectedType = methodBinding.parameters[i];
+					Expression argument = arguments[i];
+					int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+					if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
+						flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
+				}
+			}
+		} 
 	}
 }
 
@@ -104,10 +133,13 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 												   LocalVariableBinding local, int nullStatus, Expression expression, TypeBinding providedType)
 {
 	if (local != null) {
+		int severity = 0;
 		if ((local.tagBits & TagBits.AnnotationNonNull) != 0
 				&& nullStatus != FlowInfo.NON_NULL) {
 			flowContext.recordNullityMismatch(currentScope, expression, providedType, local.type, nullStatus);
 			return FlowInfo.NON_NULL;
+		} else if ((severity = findNullTypeAnnotationMismatch(local.type, providedType)) > 0) {
+			currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, local.type, severity==1, currentScope.environment());
 		} else if ((local.tagBits & TagBits.AnnotationNullable) != 0
 				&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
 			return FlowInfo.POTENTIALLY_NULL;			// -> use more specific info from the annotation
@@ -115,7 +147,33 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 	}
 	return nullStatus;
 }
-
+protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType) {
+	int severity = 0;
+	if (requiredType instanceof ArrayBinding) {
+		long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
+		if (requiredDimsTagBits != null) {
+			int dims = requiredType.dimensions();
+			if (requiredType.dimensions() == providedType.dimensions()) {
+				long[] providedDimsTagBits = ((ArrayBinding)providedType).nullTagBitsPerDimension;
+				if (providedDimsTagBits == null) {
+					severity = 1; // required is annotated, provided not, need unchecked conversion
+				} else {
+					for (int i=0; i<dims; i++) {
+						long requiredBits = requiredDimsTagBits[i] & TagBits.AnnotationNullMASK;
+						long providedBits = providedDimsTagBits[i] & TagBits.AnnotationNullMASK;
+						if (requiredBits != 0 && requiredBits != providedBits) {
+							if (providedBits == 0)
+								severity = 1; // need unchecked conversion regarding type detail
+							else
+								return 2; // mismatching annotations
+						}
+					}
+				}
+			}
+		}
+	}
+	return severity;
+}
 /**
  * INTERNAL USE ONLY.
  * This is used to redirect inter-statements jumps.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 0a3d320..21660c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -426,13 +427,15 @@ protected TypeBinding internalResolveType(Scope scope) {
 			&& scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {
 		scope.problemReporter().rawTypeReference(this, type);
 	}
-	resolveAnnotations(scope);
-
 	if (hasError) {
-		// do not store the computed type, keep the problem type instead
+		resolveAnnotations(scope);		
 		return type;
+	} else {
+		// store the computed type only if no error, otherwise keep the problem type instead
+		this.resolvedType = type;
+		resolveAnnotations(scope);
+		return this.resolvedType; // pick up value that may have been changed in resolveAnnotations(..)
 	}
-	return this.resolvedType = type;
 }
 public boolean isTypeReference() {
 	return true;
@@ -514,11 +517,27 @@ protected void resolveAnnotations(Scope scope) {
 	if (this.annotations != null || annotationsOnDimensions != null) {
 		BlockScope resolutionScope = Scope.typeAnnotationsResolutionScope(scope);
 		if (resolutionScope != null) {
+			long[] tagBitsPerDimension = null;
+			int dimensions = this.dimensions();
+			boolean shouldAnalyzeArrayNullAnnotations = scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled && this instanceof ArrayTypeReference;
 			if (this.annotations != null) {
 				int annotationsLevels = this.annotations.length;
 				for (int i = 0; i < annotationsLevels; i++) {
-					if (this.annotations[i] != null) {
-						resolveAnnotations(resolutionScope, this.annotations[i], new Annotation.TypeUseBinding(isWildcard() ? Binding.TYPE_PARAMETER : Binding.TYPE_USE));
+					Annotation[] currentAnnotations = this.annotations[i];
+					if (currentAnnotations != null) {
+						resolveAnnotations(resolutionScope, currentAnnotations, new Annotation.TypeUseBinding(isWildcard() ? Binding.TYPE_PARAMETER : Binding.TYPE_USE));
+						if (shouldAnalyzeArrayNullAnnotations) {
+							int len = currentAnnotations.length;
+							for (int j=0; j<len; j++) {
+								Binding recipient = currentAnnotations[j].recipient;
+								if (recipient instanceof Annotation.TypeUseBinding) {
+									if (tagBitsPerDimension == null)
+										tagBitsPerDimension = new long[dimensions+1]; // each dimension plus leaf component type at last position
+									// @NonNull Foo [][][] means the leaf component type is @NonNull:
+									tagBitsPerDimension[dimensions] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;
+								}
+							}
+						}
 					}
 				}
 			}
@@ -528,9 +547,25 @@ protected void resolveAnnotations(Scope scope) {
 					Annotation [] dimensionAnnotations = annotationsOnDimensions[i];
 					if (dimensionAnnotations  != null) {
 						resolveAnnotations(resolutionScope, dimensionAnnotations, new Annotation.TypeUseBinding(Binding.TYPE_USE));
+						if (shouldAnalyzeArrayNullAnnotations) {
+							int len = dimensionAnnotations.length;
+							for (int j=0; j<len; j++) {
+								Binding recipient = dimensionAnnotations[j].recipient;
+								if (recipient instanceof Annotation.TypeUseBinding) {
+									if (tagBitsPerDimension == null)
+										tagBitsPerDimension = new long[dimensions+1];
+									tagBitsPerDimension[i] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;
+								}
+							}
+						}
 					}
 				}
 			}
+			if (tagBitsPerDimension != null && this.resolvedType.isValidBinding()) {
+				// TODO(stephan): wouldn't it be more efficient to store the array bindings inside the type binding rather than the environment?
+				// cf. LocalTypeBinding.createArrayType()
+				this.resolvedType = scope.environment().createArrayType(this.resolvedType.leafComponentType(), dimensions, tagBitsPerDimension);
+			}
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
index 6bbbc94..0f381ac 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
@@ -1,12 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -27,7 +33,15 @@ public final class ArrayBinding extends TypeBinding {
 	char[] constantPoolName;
 	char[] genericTypeSignature;
 
+	// One bitset for each dimension plus one more for the leaf component type at position 'dimensions',
+	// possible bits are TagBits.AnnotationNonNull and TagBits.AnnotationNullable
+	// (only ever set when CompilerOptions.isAnnotationBasedNullAnalysisEnabled == true):
+	public long[] nullTagBitsPerDimension;
+
 public ArrayBinding(TypeBinding type, int dimensions, LookupEnvironment environment) {
+	this(type, dimensions, environment, null);
+}
+public ArrayBinding(TypeBinding type, int dimensions, LookupEnvironment environment, long[] nullTagBitsPerDimension) {
 	this.tagBits |= TagBits.IsArrayType;
 	this.leafComponentType = type;
 	this.dimensions = dimensions;
@@ -36,6 +50,11 @@ public ArrayBinding(TypeBinding type, int dimensions, LookupEnvironment environm
 		((UnresolvedReferenceBinding) type).addWrapper(this, environment);
 	else
 		this.tagBits |= type.tagBits & (TagBits.HasTypeVariable | TagBits.HasDirectWildcard | TagBits.HasMissingType | TagBits.ContainsNestedTypeReferences);
+	
+	if (nullTagBitsPerDimension != null) {
+		this.tagBits |= nullTagBitsPerDimension[0]; // outer-most dimension
+		this.nullTagBitsPerDimension = nullTagBitsPerDimension;
+	}
 }
 
 public TypeBinding closestMatch() {
@@ -128,8 +147,17 @@ public int dimensions() {
 */
 
 public TypeBinding elementsType() {
-	if (this.dimensions == 1) return this.leafComponentType;
-	return this.environment.createArrayType(this.leafComponentType, this.dimensions - 1);
+	long[] nullTagBitsSub = null;
+	if (this.nullTagBitsPerDimension != null) {
+		int len = this.nullTagBitsPerDimension.length-1;
+		System.arraycopy(this.nullTagBitsPerDimension, 1, nullTagBitsSub = new long[len], 0, len);
+	}
+	if (this.dimensions == 1) {
+		if (nullTagBitsSub != null && nullTagBitsSub[0] != 0L && this.leafComponentType instanceof ReferenceBinding)
+			return this.environment.createParameterizedType((ReferenceBinding) this.leafComponentType, null, nullTagBitsSub[0], null);
+		return this.leafComponentType;
+	}
+	return this.environment.createArrayType(this.leafComponentType, this.dimensions - 1, nullTagBitsSub);
 }
 /**
  * @see org.eclipse.jdt.internal.compiler.lookup.TypeBinding#erasure()
@@ -216,6 +244,35 @@ public TypeBinding leafComponentType(){
 	return this.leafComponentType;
 }
 
+public char[] nullAnnotatedReadableName(LookupEnvironment env, boolean shortNames) /* java.lang.Object @o.e.j.a.NonNull[] */ {
+	if (this.nullTagBitsPerDimension == null)
+		return shortNames ? shortReadableName() : readableName();
+	char[][] brackets = new char[this.dimensions][];
+	for (int i = 0; i < this.dimensions; i++) {
+		if ((this.nullTagBitsPerDimension[i] & TagBits.AnnotationNullMASK) != 0) {
+			char[][] fqAnnotationName;
+			if ((this.nullTagBitsPerDimension[i] & TagBits.AnnotationNonNull) != 0)
+				fqAnnotationName = env.getNonNullAnnotationName();
+			else
+				fqAnnotationName = env.getNullableAnnotationName();
+			char[] annotationName = shortNames 
+										? fqAnnotationName[fqAnnotationName.length-1] 
+										: CharOperation.concatWith(fqAnnotationName, '.');
+			brackets[i] = new char[annotationName.length+3];
+			brackets[i][0] = '@';
+			System.arraycopy(annotationName, 0, brackets[i], 1, annotationName.length);
+			brackets[i][annotationName.length+1] = '[';
+			brackets[i][annotationName.length+2] = ']';
+		} else {
+			brackets[i] = new char[]{'[', ']'}; 
+		}
+	}
+	char[] leafTypeName = shortNames ? this.leafComponentType.shortReadableName() : this.leafComponentType.readableName();
+	return CharOperation.concat(leafTypeName, 
+								 CharOperation.concatWith(brackets, ' '),
+								 ' ');
+}
+
 /* API
 * Answer the problem id associated with the receiver.
 * NoError if the receiver is a valid binding.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 7605128..869598c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -16,10 +16,12 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -640,6 +642,9 @@ public AnnotationBinding createAnnotation(ReferenceBinding annotationType, Eleme
  *  Used to guarantee array type identity.
  */
 public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimensionCount) {
+	return createArrayType(leafComponentType, dimensionCount, null);
+}
+public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimensionCount, long[] nullTagBitsPerDimension) {
 	if (leafComponentType instanceof LocalTypeBinding) // cache local type arrays with the local type itself
 		return ((LocalTypeBinding) leafComponentType).createArrayType(dimensionCount, this);
 
@@ -664,8 +669,9 @@ public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimension
 	while (++index < length) {
 		ArrayBinding currentBinding = arrayBindings[index];
 		if (currentBinding == null) // no matching array, but space left
-			return arrayBindings[index] = new ArrayBinding(leafComponentType, dimensionCount, this);
-		if (currentBinding.leafComponentType == leafComponentType)
+			return arrayBindings[index] = new ArrayBinding(leafComponentType, dimensionCount, this, nullTagBitsPerDimension);
+		if (currentBinding.leafComponentType == leafComponentType
+				&& (nullTagBitsPerDimension == null || Arrays.equals(currentBinding.nullTagBitsPerDimension, nullTagBitsPerDimension)))
 			return currentBinding;
 	}
 
@@ -675,7 +681,7 @@ public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimension
 		(arrayBindings = new ArrayBinding[length * 2]), 0,
 		length);
 	this.uniqueArrayBindings[dimIndex] = arrayBindings;
-	return arrayBindings[length] = new ArrayBinding(leafComponentType, dimensionCount, this);
+	return arrayBindings[length] = new ArrayBinding(leafComponentType, dimensionCount, this, nullTagBitsPerDimension);
 }
 public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) {
 	return createBinaryTypeFrom(binaryType, packageBinding, true, accessRestriction);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index c1a6073..73e01bd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -4,6 +4,10 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -14,6 +18,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1350,6 +1355,24 @@ public MethodBinding[] methods() {
 	return Binding.NO_METHODS;
 }
 
+public char[] nullAnnotatedReadableName(LookupEnvironment env, boolean shortNames) /* java.lang.Object @o.e.j.a.NonNull[] */ {
+	char[] typeName = shortNames ? shortReadableName() : readableName();
+	if ((this.tagBits & TagBits.AnnotationNullMASK) == 0)
+		return typeName;
+	char[][] fqAnnotationName;
+	if ((this.tagBits & TagBits.AnnotationNonNull) != 0)
+		fqAnnotationName = env.getNonNullAnnotationName();
+	else
+		fqAnnotationName = env.getNullableAnnotationName();
+	char[] annotationName = shortNames
+								? fqAnnotationName[fqAnnotationName.length-1]
+								: CharOperation.concatWith(fqAnnotationName, '.');				
+	char[] prefix = new char[annotationName.length+1];
+	prefix[0] = '@';
+	System.arraycopy(annotationName, 0, prefix, 1, annotationName.length);
+	return CharOperation.concat(prefix, typeName, ' ');
+}
+
 public final ReferenceBinding outermostEnclosingType() {
 	ReferenceBinding current = this;
 	while (true) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 7871211..10d3e48 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -4,10 +4,16 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *      Stephen Herrmann <stephan@cs.tu-berlin.de> -  Contribution for bug 317046
+ *      Stephen Herrmann <stephan@cs.tu-berlin.de> -  Contributions for
+ *								bug 317046 - Exception during debugging when hover mouse over a field
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1155,6 +1161,14 @@ public boolean needsUncheckedConversion(TypeBinding targetType) {
 	return false;
 }
 
+/** Answer a readable name (for error reporting) that includes nullness type annotations. */
+public char[] nullAnnotatedReadableName(LookupEnvironment env, boolean shortNames) /* e.g.: java.lang.Object @o.e.j.a.NonNull[] */ {
+	if (shortNames)
+		return shortReadableName();
+	else
+		return readableName();
+}
+
 /**
  * Returns the orignal generic type instantiated by the receiver type, or itself if not.
  * This is similar to erasure process, except it doesn't erase type variable, wildcard, intersection types etc...
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 27755f8..3c2de42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -25,6 +25,7 @@
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
  *								bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -109,6 +110,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
@@ -307,6 +309,8 @@ public static int getIrritant(int problemID) {
 
 		case IProblem.PotentialNullLocalVariableReference:
 		case IProblem.PotentialNullMessageSendReference:
+		case IProblem.ArrayReferencePotentialNullReference:
+		case IProblem.DereferencingNullableExpression:
 			return CompilerOptions.PotentialNullReference;
 
 		case IProblem.RedundantLocalVariableNullAssignment:
@@ -330,11 +334,13 @@ public static int getIrritant(int problemID) {
 		case IProblem.CannotImplementIncompatibleNullness:
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
+		case IProblem.NullityMismatchingTypeAnnotation:
 			return CompilerOptions.NullSpecViolation;
 
 		case IProblem.RequiredNonNullButProvidedPotentialNull:
 			return CompilerOptions.NullAnnotationInferenceConflict;
 		case IProblem.RequiredNonNullButProvidedUnknown:
+		case IProblem.NullityMismatchingTypeAnnotationUnchecked:
 			return CompilerOptions.NullUncheckedConversion;
 		case IProblem.RedundantNullAnnotation:
 		case IProblem.RedundantNullDefaultAnnotation:
@@ -8409,12 +8415,10 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType, char[][] annotationName) {
 	int problemId = IProblem.RequiredNonNullButProvidedNull;
 	String[] arguments = new String[] {
-			String.valueOf(CharOperation.concatWith(annotationName, '.')),
-			String.valueOf(requiredType.readableName())
+			annotatedTypeName(requiredType, annotationName)
 	};
 	String[] argumentsShort = new String[] {
-			String.valueOf(annotationName[annotationName.length-1]),
-			String.valueOf(requiredType.shortReadableName())
+			shortAnnotatedTypeName(requiredType, annotationName)
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
 }
@@ -8422,13 +8426,11 @@ public void nullityMismatchSpecdNullable(Expression expression, TypeBinding requ
 	int problemId = IProblem.RequiredNonNullButProvidedSpecdNullable;
 	char[][] nullableName = this.options.nullableAnnotationName;
 	String[] arguments = new String[] {
-			String.valueOf(CharOperation.concatWith(annotationName, '.')),
-			String.valueOf(requiredType.readableName()),
+			annotatedTypeName(requiredType, annotationName),
 			String.valueOf(CharOperation.concatWith(nullableName, '.'))
 	};
 	String[] argumentsShort = new String[] {
-			String.valueOf(annotationName[annotationName.length-1]),
-			String.valueOf(requiredType.shortReadableName()),
+			shortAnnotatedTypeName(requiredType, annotationName),
 			String.valueOf(nullableName[nullableName.length-1])
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
@@ -8437,13 +8439,11 @@ public void nullityMismatchPotentiallyNull(Expression expression, TypeBinding re
 	int problemId = IProblem.RequiredNonNullButProvidedPotentialNull;
 	char[][] nullableName = this.options.nullableAnnotationName;
 	String[] arguments = new String[] {
-			String.valueOf(CharOperation.concatWith(annotationName, '.')),
-			String.valueOf(requiredType.readableName()),
+			annotatedTypeName(requiredType, annotationName),
 			String.valueOf(CharOperation.concatWith(nullableName, '.'))
 	};
 	String[] argumentsShort = new String[] {
-			String.valueOf(annotationName[annotationName.length-1]),
-			String.valueOf(requiredType.shortReadableName()),
+			shortAnnotatedTypeName(requiredType, annotationName),
 			String.valueOf(nullableName[nullableName.length-1])
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
@@ -8452,13 +8452,11 @@ public void nullityMismatchIsUnknown(Expression expression, TypeBinding provided
 	int problemId = IProblem.RequiredNonNullButProvidedUnknown;
 	String[] arguments = new String[] {
 			String.valueOf(providedType.readableName()),
-			String.valueOf(CharOperation.concatWith(annotationName, '.')),
-			String.valueOf(requiredType.readableName())
+			annotatedTypeName(requiredType, annotationName)
 	};
 	String[] argumentsShort = new String[] {
 			String.valueOf(providedType.shortReadableName()),
-			String.valueOf(annotationName[annotationName.length-1]),
-			String.valueOf(requiredType.shortReadableName())
+			shortAnnotatedTypeName(requiredType, annotationName)
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
 }
@@ -8671,6 +8669,50 @@ public void illegalAnnotationForBaseType(TypeReference type, Annotation[] annota
 			type.sourceEnd);
 }
 
+private String annotatedTypeName(TypeBinding type, char[][] annotationName) {
+	int dims = 0;
+	if (type instanceof ArrayBinding && ((ArrayBinding)type).nullTagBitsPerDimension != null) {
+		dims = type.dimensions();
+		type = type.leafComponentType();
+	}
+	char[] typeName = type.readableName();
+	char[] annotationDisplayName = CharOperation.concatWith(annotationName, '.');
+	return internalAnnotatedTypeName(annotationDisplayName, typeName, dims);
+}
+private String shortAnnotatedTypeName(TypeBinding type, char[][] annotationName) {
+	int dims = 0;
+	if (type instanceof ArrayBinding && ((ArrayBinding)type).nullTagBitsPerDimension != null) {
+		// if type has annotations on dimensions show the annotation on the outer most dimension:
+		dims = type.dimensions();
+		type = type.leafComponentType();
+	}
+	char[] typeName = type.shortReadableName();
+	char[] annotationDisplayName = annotationName[annotationName.length-1];
+	return internalAnnotatedTypeName(annotationDisplayName, typeName, dims);
+}
+
+String internalAnnotatedTypeName(char[] annotationName, char[] typeName, int dims) {
+	char[] fullName;
+	if (dims > 0) {
+		int plainLen = annotationName.length+typeName.length+2; // adding '@' and ' ' ...
+		fullName = new char[plainLen+(2*dims)]; // ... and []* 
+		System.arraycopy(typeName, 0, fullName, 0, typeName.length);
+		fullName[typeName.length] = ' ';
+		fullName[typeName.length+1] = '@';
+		System.arraycopy(annotationName, 0, fullName, typeName.length+2, annotationName.length);
+		for (int i=0; i<dims; i++) {
+			fullName[plainLen+i] = '[';
+			fullName[plainLen+i+1] = ']';
+		}
+	} else {
+		fullName = new char[annotationName.length+typeName.length+2]; // adding '@' and ' ' 
+		fullName[0] = '@';
+		System.arraycopy(annotationName, 0, fullName, 1, annotationName.length);
+		fullName[annotationName.length+1] = ' ';
+		System.arraycopy(typeName, 0, fullName, annotationName.length+2, typeName.length);
+	}
+	return String.valueOf(fullName);
+}
 private Annotation findAnnotation(Annotation[] annotations, int typeId) {
 	if (annotations != null) {
 		// should have a @NonNull/@Nullable annotation, search for it:
@@ -8723,4 +8765,38 @@ public void illegalModifiersForElidedType(Argument argument) {
 			argument.declarationSourceStart,
 			argument.declarationSourceEnd);
 }
+
+public void arrayReferencePotentialNullReference(ArrayReference arrayReference) {
+	// TODO(stephan): merge with other expressions
+	this.handle(IProblem.ArrayReferencePotentialNullReference, NoArgument, NoArgument, arrayReference.sourceStart, arrayReference.sourceEnd);
+	
+}
+public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding providedType, TypeBinding requiredType, 
+		boolean uncheckedConversion, LookupEnvironment env) 
+{
+	String[] arguments = new String[] {
+		String.valueOf(requiredType.nullAnnotatedReadableName(env, false)),
+		String.valueOf(providedType.nullAnnotatedReadableName(env, false))
+	};
+	String[] shortArguments = new String[] {
+		String.valueOf(requiredType.nullAnnotatedReadableName(env, true)),
+		String.valueOf(providedType.nullAnnotatedReadableName(env, true))
+	};
+	this.handle(
+			uncheckedConversion ? IProblem.NullityMismatchingTypeAnnotationUnchecked : IProblem.NullityMismatchingTypeAnnotation,
+			arguments, shortArguments, expression.sourceStart, expression.sourceEnd);
+}
+public void dereferencingNullableExpression(Expression expression, LookupEnvironment env) {
+	if (expression instanceof MessageSend) {
+		MessageSend send = (MessageSend) expression;
+		messageSendPotentialNullReference(send.binding, send);
+		return;
+	}
+	char[][] nullableName = env.getNullableAnnotationName();
+	char[] nullableShort = nullableName[nullableName.length-1];
+	String[] arguments = { String.valueOf(nullableShort) };
+	// TODO(stephan): more sophisticated handling for various kinds of expressions
+	this.handle(IProblem.DereferencingNullableExpression, arguments, arguments, expression.sourceStart, expression.sourceEnd);
+	
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 36beb24..235f47e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -24,6 +24,7 @@
 #							bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
 #							bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
 #							bug 388281 - [compiler][null] inheritance of null annotations as an option
+#							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -693,9 +694,9 @@
 890 = Cannot switch on an enum value for source level below 1.5. Only convertible int values are permitted
 
 ### NULL ANNOTATIONS
-910 = Null type mismatch: required ''@{0} {1}'' but the provided value is null
-911 = Null type mismatch: required ''@{0} {1}'' but the provided value is inferred as @{2}
-912 = Null type safety: The expression of type {0} needs unchecked conversion to conform to ''@{1} {2}''
+910 = Null type mismatch: required ''{0}'' but the provided value is null
+911 = Null type mismatch: required ''{0}'' but the provided value is inferred as @{1}
+912 = Null type safety: The expression of type {0} needs unchecked conversion to conform to ''{1}''
 913 = A default nullness annotation has not been specified for the package {0}
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
@@ -715,10 +716,14 @@
 930 = A default nullness annotation has not been specified for the type {0}
 931 = Redundant null check: The variable {0} is specified as @{1}
 932 = Null comparison always yields false: The variable {0} is specified as @{1}
-933 = Null type mismatch: required ''@{0} {1}'' but the provided value is specified as @{2}
+933 = Null type mismatch: required ''{0}'' but the provided value is specified as @{1}
 939 = The default ''@{0}'' conflicts with the inherited ''@{1}'' annotation in the overridden method from {2} 
 940 = Conflict between inherited null annotations ''@{0}'' declared in {1} versus ''@{2}'' declared in {3} 
 
+951 = Potential null pointer access: array element may be null
+952 = Potential null pointer access: this expression has a ''@{0}'' type
+953 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}''
+954 = Null type mismatch (type annotations): the expression of type ''{1}'' needs unchecked conversion to conform to ''{0}''
 
 // Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
