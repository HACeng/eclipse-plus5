commit d1fa996b413072e0e9f017186862083f5b05d0dc
Author: Till Brychcy <register.eclipse@brychcy.de>
Date:   Thu Jan 28 19:57:19 2016 +0100

    Bug 466556 - [null][1.8] Incorrect null analysis for "unconstrained"
    type parameters
    
    Change-Id: I0aeb30d07cc194230598bb5b6f23b8e28654f6a6
    Signed-off-by: Till Brychcy <register.eclipse@brychcy.de>

5	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
11	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
560	46	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
13	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
19	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
94	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
17	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
index 205c8ca..3a0a49a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2010, 2014 GK Software AG and others.
+ * Copyright (c) 2010, 2016 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,7 @@ import java.util.Map;
 import org.eclipse.core.runtime.FileLocator;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.osgi.framework.Bundle;
 
 @SuppressWarnings({ "unchecked", "rawtypes" })
@@ -97,6 +98,9 @@ public abstract class AbstractNullAnnotationTest extends AbstractComparableTest
 
 			// enable null annotations:
 			defaultOptions.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+
+			defaultOptions.put(CompilerOptions.OPTION_PessimisticNullAnalysisForFreeTypeVariables, JavaCore.ERROR);
+			
 			// leave other new options at these defaults:
 //			defaultOptions.put(CompilerOptions.OPTION_ReportNullContractViolation, JavaCore.ERROR);
 //			defaultOptions.put(CompilerOptions.OPTION_ReportPotentialNullContractViolation, JavaCore.ERROR);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index a23e288..a57d363 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -2037,6 +2037,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingMethodWithoutSuperInvocation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.parameterAssignment\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables\" value=\"warning\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullReference\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 94ab38e..6c58193 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2015 IBM Corporation and others.
+ * Copyright (c) 2006, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -937,6 +937,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ReferenceExpressionReturnNullRedef", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceExpressionReturnNullRedefUnchecked", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceToForwardField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedFreeTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedSpecdNullable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1005,6 +1006,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("TypeMissingDeprecatedAnnotation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("TypeParameterHidingType", new ProblemAttributes(CategorizedProblem.CAT_NAME_SHADOWING_CONFLICT));
 		expectedProblemAttributes.put("UnboxingConversion", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
+		expectedProblemAttributes.put("UncheckedAccessOfValueOfFreeTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnclosedCloseable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnclosedCloseableAtExit", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UndefinedAnnotationMember", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1028,6 +1030,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("UninitializedFreeTypeVariableField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UninitializedFreeTypeVariableFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UninitializedLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1680,7 +1684,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocation", SKIP);
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocationAtType", SKIP);
-		expectedProblemAttributes.put("NullityMismatchAgainstFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("NullityMismatchAgainstFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationSuperHint", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
@@ -1690,7 +1694,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
-		expectedProblemAttributes.put("NullNotCompatibleToFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("NullNotCompatibleToFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES));
 		expectedProblemAttributes.put("NullSourceString", SKIP);
 		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NumericValueOutOfRange", SKIP);
@@ -1770,6 +1774,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RepeatableAnnotationTypeTargetMismatch", SKIP);
 		expectedProblemAttributes.put("RepeatableAnnotationWithRepeatingContainerAnnotation", SKIP);
 		expectedProblemAttributes.put("RepeatedAnnotationWithContainerAnnotation", SKIP);
+		expectedProblemAttributes.put("RequiredNonNullButProvidedFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
@@ -1832,6 +1837,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("TypeMissingDeprecatedAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_DEPRECATED_ANNOTATION));
 		expectedProblemAttributes.put("TypeParameterHidingType", new ProblemAttributes(JavaCore.COMPILER_PB_TYPE_PARAMETER_HIDING));
 		expectedProblemAttributes.put("UnboxingConversion", new ProblemAttributes(JavaCore.COMPILER_PB_AUTOBOXING));
+		expectedProblemAttributes.put("UncheckedAccessOfValueOfFreeTypeVariable", new ProblemAttributes(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES));
 		expectedProblemAttributes.put("UnclosedCloseable", new ProblemAttributes(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("UnclosedCloseableAtExit", new ProblemAttributes(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("UndefinedAnnotationMember", SKIP);
@@ -1855,6 +1861,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(JavaCore.COMPILER_PB_UNHANDLED_WARNING_TOKEN));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", SKIP);
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", SKIP);
+		expectedProblemAttributes.put("UninitializedFreeTypeVariableField", SKIP);
+		expectedProblemAttributes.put("UninitializedFreeTypeVariableFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariable", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index e6883fe..01176fb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -198,7 +198,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. ERROR in X.java (at line 5)\n" + 
 			"	System.out.print(l.get(0).toString()); // problem: l may be null\n" + 
 			"	                 ^\n" + 
-			"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+			"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 6)\n" + 
 			"	l.add(null); // problem: cannot insert \'null\' into this list\n" + 
@@ -208,7 +208,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"3. ERROR in X.java (at line 9)\n" + 
 			"	System.out.print(l.get(0).toString()); // problem: l may be null\n" + 
 			"	                 ^\n" + 
-			"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+			"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"4. ERROR in X.java (at line 10)\n" + 
 			"	l.add(0, null); // problem: cannot insert \'null\' into this list\n" + 
@@ -218,7 +218,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"5. ERROR in X.java (at line 13)\n" + 
 			"	System.out.print(l2.get(0).toString()); // problem: l2 may be null\n" + 
 			"	                 ^^\n" + 
-			"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+			"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"6. ERROR in X.java (at line 14)\n" + 
 			"	l2.add(0, null); // problem: cannot insert \'null\' into this list\n" + 
@@ -240,18 +240,21 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				  "        public X foo(Y l) {\n" +
 				  "            return anX;\n" +
 				  "        }\n" +
+				  "        public I(X x) {\n" +
+				  "            anX = x;\n" +
+				  "        }\n" +
 				  "    }\n" +
 				  "    void bar(A<@Nullable Object>.I<@NonNull Object> i) {\n" + // legal instantiation
 				  "        @NonNull Object o = i.foo(null); // problems: argument and assignment violate null contracts\n" +
 				  "    }\n" +
 				  "}\n"},
 			"----------\n" + 
-			"1. ERROR in A.java (at line 10)\n" + 
+			"1. ERROR in A.java (at line 13)\n" + 
 			"	@NonNull Object o = i.foo(null); // problems: argument and assignment violate null contracts\n" + 
 			"	                    ^^^^^^^^^^^\n" + 
 			"Null type mismatch (type annotations): required '@NonNull Object' but this expression has type '@Nullable Object'\n" + 
 			"----------\n" + 
-			"2. ERROR in A.java (at line 10)\n" + 
+			"2. ERROR in A.java (at line 13)\n" + 
 			"	@NonNull Object o = i.foo(null); // problems: argument and assignment violate null contracts\n" + 
 			"	                          ^^^^\n" + 
 			"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
@@ -353,7 +356,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. ERROR in B.java (at line 4)\n" + 
 			"	ai.foo(null); // problems: ai can be null, arg must not be null\n" + 
 			"	^^\n" + 
-			"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+			"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"2. ERROR in B.java (at line 4)\n" + 
 			"	ai.foo(null); // problems: ai can be null, arg must not be null\n" + 
@@ -417,6 +420,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"Wrapper.java",
 				  "public class Wrapper<T> {\n" +
 				  "	T content;" +
+				  "	public Wrapper(T t) { content = t; }\n" +
 				  "	public T content() { return content; }\n" +
 				  "}\n",
 				"A.java",
@@ -451,6 +455,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"Wrapper.java",
 				  "public class Wrapper<T> {\n" +
 				  "	T content;" +
+				  "	public Wrapper(T t) { content = t; }\n" +
 				  "	public T content() { return content; }\n" +
 				  "}\n",
 				"A.java",
@@ -522,7 +527,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
     		"4. ERROR in A.java (at line 15)\n" + 
     		"	string = maybeStringArray[0]; // problems: indexing nullable array & unchecked conversion\n" + 
     		"	         ^^^^^^^^^^^^^^^^\n" + 
-    		"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+    		"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
     		"----------\n" + 
     		"5. WARNING in A.java (at line 15)\n" + 
     		"	string = maybeStringArray[0]; // problems: indexing nullable array & unchecked conversion\n" + 
@@ -532,7 +537,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
     		"6. ERROR in A.java (at line 17)\n" + 
     		"	maybeStringArray[0] = null; 	 // problem: indexing nullable array\n" + 
     		"	^^^^^^^^^^^^^^^^\n" + 
-    		"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+    		"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 			"----------\n");
 	}
 
@@ -1048,7 +1053,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"1. ERROR in Y1.java (at line 4)\n" + 
 				"	System.out.println(p.X1.f1.length);\n" + 
 				"	                        ^^\n" + 
-				"Potential null pointer access: this expression has a '@Nullable' type\n" + 
+				"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
 				"----------\n" + 
 				"2. ERROR in Y1.java (at line 5)\n" + 
 				"	System.out.println(X1.f2[0].length);\n" + 
@@ -3736,15 +3741,15 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			},
 			getCompilerOptions(),
 			"----------\n" + 
-			"1. WARNING in X.java (at line 4)\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
 			"	consume(t); // error, t can be null\n" + 
 			"	        ^\n" + 
-			"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull T\'\n" + 
+			"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 			"----------\n" + 
-			"2. WARNING in X.java (at line 5)\n" + 
+			"2. ERROR in X.java (at line 5)\n" + 
 			"	consumeObject(t); // error, t can be null\n" + 
 			"	              ^\n" + 
-			"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+			"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 8)\n" + 
 			"	consume(t); // error, both sides explicit, mismatch\n" + 
@@ -3794,15 +3799,15 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			},
 			getCompilerOptions(),
 			"----------\n" + 
-			"1. WARNING in X.java (at line 4)\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
 			"	consume(t); // error, t can be null\n" + 
 			"	        ^\n" + 
-			"Null type safety (type annotations): The expression of type \'T extends Number\' needs unchecked conversion to conform to \'@NonNull T extends Number\'\n" + 
+			"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 			"----------\n" + 
-			"2. WARNING in X.java (at line 5)\n" + 
+			"2. ERROR in X.java (at line 5)\n" + 
 			"	consumeObject(t); // error, t can be null\n" + 
 			"	              ^\n" + 
-			"Null type safety (type annotations): The expression of type \'T extends Number\' needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+			"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 8)\n" + 
 			"	consume(t); // error, both sides explicit, mismatch\n" + 
@@ -4734,12 +4739,12 @@ public void testDefault01b() {
 		"1. ERROR in X.java (at line 6)\n" + 
 		"	in.add(null); // NOK, cannot assume nullable\n" + 
 		"	       ^^^^\n" + 
-		"Null type mismatch (type annotations): \'null\' is not compatible to the free type variable '? extends Number'\n" + 
+		"Null type mismatch (type annotations): \'null\' is not compatible to the free type variable \'? extends Number\'\n" + 
 		"----------\n" + 
-		"2. WARNING in X.java (at line 7)\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
 		"	needNN(in.get(0)); // NOK, cannot assume nonnull\n" + 
 		"	       ^^^^^^^^^\n" + 
-		"Null type safety (type annotations): The expression of type \'capture#of ? extends Number\' needs unchecked conversion to conform to \'@NonNull Number\'\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'capture#2-of ? extends java.lang.Number\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n" + 
 		"3. ERROR in X.java (at line 8)\n" + 
 		"	return new ArrayList<@Nullable T>(); // NOK, cannot assume nullable for T in List<T>\n" + 
@@ -6491,10 +6496,10 @@ public void testBug440759a() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. WARNING in X.java (at line 5)\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
 		"	@NonNull T localT = t; // err#1\n" + 
 		"	                    ^\n" + 
-		"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull T\'\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 6)\n" + 
 		"	return null; // err must mention free type variable, not @NonNull\n" + 
@@ -6521,10 +6526,10 @@ public void testBug440759b() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. WARNING in X.java (at line 8)\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
 		"	@NonNull T localT = t; // err#1\n" + 
 		"	                    ^\n" + 
-		"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull T\'\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 9)\n" + 
 		"	return null; // err must mention free type variable, not @NonNull\n" + 
@@ -6732,7 +6737,7 @@ public void testBug434579() {
 		},
 		options,
 		"");
-	runConformTestWithLibs(
+	runNegativeTestWithLibs(
 		new String[] {
 			"UnequalBinaryNode.java",
 			"public class UnequalBinaryNode<L extends ExtendedNode, R extends ExtendedNode>\n" +
@@ -6748,7 +6753,17 @@ public void testBug434579() {
 			"}\n"
 		},
 		options,
-		"");
+		"----------\n" + 
+		"1. ERROR in UnequalBinaryNode.java (at line 8)\n" + 
+		"	left.setParent(this);\n" + 
+		"	^^^^\n" + 
+		"Potential null pointer access: this expression has type \'L\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in UnequalBinaryNode.java (at line 9)\n" + 
+		"	right.setParent(this); // error on this line without fix\n" + 
+		"	^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'R\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=434582,
 //[1.8][compiler][null] @Nullable annotation in type parameter causes NullPointerException in JDT core
@@ -7709,6 +7724,7 @@ public void testBug437072() {
 public void testBug448709() {
 	Map compilerOptions = getCompilerOptions();
 	compilerOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION, JavaCore.WARNING); // ensure program is runnable
+	compilerOptions.put(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES, JavaCore.WARNING); // ensure program is runnable
 	runConformTestWithLibs(
 		new String[] {
 			"Test.java",
@@ -7764,7 +7780,7 @@ public void testBug448709() {
 		"1. WARNING in Test.java (at line 21)\n" + 
 		"	final U result = mapper.apply(source);\n" + 
 		"	                              ^^^^^^\n" + 
-		"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull capture#of ? super T\'\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n" + 
 		"2. WARNING in Test.java (at line 39)\n" + 
 		"	map(optNullableString, testMethodRef);\n" + 
@@ -8297,6 +8313,8 @@ public void testBug446217() {
 		getCompilerOptions(), "");
 }
 public void testBug456584() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES, JavaCore.WARNING);
 	runConformTestWithLibs(
 		new String[] {
 			"Test.java",
@@ -8313,12 +8331,12 @@ public void testBug456584() {
 			"\n" + 
 			"}\n"
 		},
-		getCompilerOptions(),
+		compilerOptions,
 		"----------\n" + 
 		"1. WARNING in Test.java (at line 9)\n" + 
 		"	return Objects.requireNonNull(function.apply(input));\n" + 
 		"	                              ^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"Null type safety (type annotations): The expression of type \'capture#of ? extends R\' needs unchecked conversion to conform to \'@NonNull capture#of ? extends R\'\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'capture#2-of ? extends R\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n");
 }
 public void testBug447661() {
@@ -8921,7 +8939,12 @@ public void testBug481322a() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. ERROR in X.java (at line 12)\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	return list.get(0);\n" + 
+		"	       ^^^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 12)\n" + 
 		"	public class X extends Super<@NonNull String, List<@Nullable String>> {\n" + 
 		"	                                              ^^^^\n" + 
 		"Null constraint mismatch: The type \'List<@Nullable String>\' is not a valid substitute for the type parameter \'T extends List<S>\'\n" + 
@@ -9122,12 +9145,17 @@ public void testBug482228() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. ERROR in X.java (at line 14)\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	return list.get(0);\n" + 
+		"	       ^^^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 14)\n" + 
 		"	<T extends List<@Nullable String>> @NonNull String pick(T list) {\n" + 
 		"	 ^\n" + 
 		"Cannot redefine null constraints of type variable \'T extends List<@NonNull String>\' declared in \'Super<String>.pick(T)\'\n" + 
 		"----------\n" + 
-		"2. ERROR in X.java (at line 15)\n" + 
+		"3. ERROR in X.java (at line 15)\n" + 
 		"	return super.pick(list);\n" + 
 		"	       ^^^^^^^^^^^^^^^^\n" + 
 		"Null constraint mismatch: The type \'T extends List<@Nullable String>\' is not a valid substitute for the type parameter \'T extends List<@NonNull String>\'\n" + 
@@ -9631,17 +9659,22 @@ public void testBug466562() {
 		"	                    ^\n" + 
 		"Null type mismatch (type annotations): required \'@NonNull Object\' but this expression has type \'T1 extends @Nullable Number\'\n" + 
 		"----------\n" + 
-		"3. ERROR in x\\C.java (at line 13)\n" + 
+		"3. ERROR in x\\C.java (at line 10)\n" + 
+		"	return t.toString(); // legal???\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: this expression has type \'T1\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"4. ERROR in x\\C.java (at line 13)\n" + 
 		"	consume(null);  // illegal - OK\n" + 
 		"	        ^^^^\n" + 
 		"Null type mismatch: required \'T1 extends @Nullable Number\' but the provided value is null\n" + 
 		"----------\n" + 
-		"4. ERROR in x\\C.java (at line 14)\n" + 
+		"5. ERROR in x\\C.java (at line 14)\n" + 
 		"	@NonNull Object t = provide();  // error, should warn?\n" + 
 		"	                    ^^^^^^^^^\n" + 
 		"Null type mismatch (type annotations): required \'@NonNull Object\' but this expression has type \'T1 extends @Nullable Number\'\n" + 
 		"----------\n" + 
-		"5. ERROR in x\\C.java (at line 18)\n" + 
+		"6. ERROR in x\\C.java (at line 18)\n" + 
 		"	return null; // error, should warn?\n" + 
 		"	       ^^^^\n" + 
 		"Null type mismatch: required \'T1 extends @Nullable Number\' but the provided value is null\n" + 
@@ -10001,20 +10034,20 @@ public void testBug484741Invoke2() {
 		}, 
 		getCompilerOptions(), 
 		"----------\n" + 
-		"1. WARNING in test\\TestInterdepInvokeNN.java (at line 48)\n" + 
+		"1. ERROR in test\\TestInterdepInvokeNN.java (at line 48)\n" + 
 		"	return f2(e); // error 1 expected\n" + 
 		"	          ^\n" + 
-		"Null type safety (type annotations): The expression of type \'E21 extends T21\' needs unchecked conversion to conform to \'@NonNull E21 extends T21\'\n" + 
+		"Null type safety: required '@NonNull' but this expression has type 'E21', a free type variable that may represent a '@Nullable' type\n" + 
 		"----------\n" + 
-		"2. WARNING in test\\TestInterdepInvokeNN.java (at line 66)\n" + 
+		"2. ERROR in test\\TestInterdepInvokeNN.java (at line 66)\n" + 
 		"	return f3(e); // error 2 expected\n" + 
 		"	          ^\n" + 
-		"Null type safety (type annotations): The expression of type \'E31 extends T31\' needs unchecked conversion to conform to \'@NonNull E31 extends T31\'\n" + 
+		"Null type safety: required '@NonNull' but this expression has type 'E31', a free type variable that may represent a '@Nullable' type\n" + 
 		"----------\n" + 
-		"3. WARNING in test\\TestInterdepInvokeNN.java (at line 84)\n" + 
+		"3. ERROR in test\\TestInterdepInvokeNN.java (at line 84)\n" + 
 		"	return f4(e); // error 3 expected\n" + 
 		"	          ^\n" + 
-		"Null type safety (type annotations): The expression of type \'E41 extends T41\' needs unchecked conversion to conform to \'@NonNull E41 extends T41\'\n" + 
+		"Null type safety: required '@NonNull' but this expression has type 'E41', a free type variable that may represent a '@Nullable' type\n" + 
 		"----------\n"
 	);
 }
@@ -10455,15 +10488,15 @@ public void testBug485302() {
 		"	       ^^^^^^^^^^^^^^\n" + 
 		"Null type mismatch (type annotations): required \'@NonNull Number\' but this expression has type \'@Nullable capture#of ? extends Number\'\n" + 
 		"----------\n" + 
-		"2. WARNING in WildCardNullable.java (at line 25)\n" + 
+		"2. ERROR in WildCardNullable.java (at line 25)\n" + 
 		"	a.acceptNonNullT(t); // warning 2 expected\n" + 
 		"	                 ^\n" + 
-		"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull capture#of ? super T\'\n" + 
+		"Null type safety: required '@NonNull' but this expression has type 'T', a free type variable that may represent a '@Nullable' type\n" + 
 		"----------\n" + 
-		"3. WARNING in WildCardNullable.java (at line 26)\n" + 
+		"3. ERROR in WildCardNullable.java (at line 26)\n" + 
 		"	a.acceptNonNullObject(t); // warning 3 expected\n" + 
 		"	                      ^\n" + 
-		"Null type safety (type annotations): The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+		"Null type safety: required '@NonNull' but this expression has type 'T', a free type variable that may represent a '@Nullable' type\n" + 
 		"----------\n"
 	);
 }
@@ -10699,5 +10732,486 @@ public void testBug485374() {
 			"----------\n"
 		);
 }
-
+
+public void testBug466556a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/C.java",
+			"package test;\n" +
+			"class C<T extends Number> {\n" +
+			"    int consume(T t) {\n" +
+			"        return t.intValue(); // NOT OK since T could be nullable\n" +
+			"    }\n" +
+			"    T provide() {\n" +
+			"        return null;         // NOT OK since T could require nonnull\n" +
+			"    }\n" +
+			"}\n",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\C.java (at line 4)\n" + 
+		"	return t.intValue(); // NOT OK since T could be nullable\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\C.java (at line 7)\n" + 
+		"	return null;         // NOT OK since T could require nonnull\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch (type annotations): \'null\' is not compatible to the free type variable \'T\'\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556nonfree() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/C.java",
+			"package test;\n" +
+			"class C<T extends @org.eclipse.jdt.annotation.NonNull Number> {\n" +
+			"    int consume(T t) {\n" +
+			"        return t.intValue(); // OK since T has upper bound with @NonNull\n" +
+			"    }\n" +
+			"    T provide() {\n" +
+			"        return null;         // NOT OK since T could require nonnull\n" +
+			"    }\n" +
+			"}\n",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\C.java (at line 7)\n" + 
+		"	return null;         // NOT OK since T could require nonnull\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'T extends @NonNull Number\' but the provided value is null\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556b() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/C.java",
+			"package test;\n" +
+			"\n" +
+			"import java.util.function.Supplier;\n" +
+			"\n" +
+			"class C<T> {\n" +
+			"	int consume(T t) {\n" +
+			"		return t.hashCode();\n" +
+			"	}\n" +
+			"	void consume2(Supplier<T> s) {\n" +
+			"		s.get().hashCode();\n" +
+			"	}\n" +
+			"}\n",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\C.java (at line 7)\n" + 
+		"	return t.hashCode();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\C.java (at line 10)\n" + 
+		"	s.get().hashCode();\n" + 
+		"	^^^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556c() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/C.java",
+			"package test;\n" +
+			"\n" +
+			"import java.util.function.Supplier;\n" +
+			"\n" +
+			"class C<T extends Number> {\n" +
+			"	int consume(T t) {\n" +
+			"		Number n = t;\n" +
+			"		return n.intValue();\n" +
+			"	}\n" +
+			"\n" +
+			"	int consume2(Supplier<T> s) {\n" +
+			"		Number n = s.get();\n" +
+			"		return n.intValue();\n" +
+			"	}\n" +
+			"}\n",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\C.java (at line 8)\n" + 
+		"	return n.intValue();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The variable n may be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\C.java (at line 13)\n" + 
+		"	return n.intValue();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The variable n may be null at this location\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556field() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/D.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"\n" +
+			"class E<T> {\n" +
+			"	T t;\n" +
+			"}\n" +
+			"\n" +
+			"class D<T> {\n" +
+			"	enum X {\n" +
+			"		x\n" +
+			"	};\n" +
+			"\n" +
+			"	T t1;\n" +
+			"	T t2;\n" +
+			"	T t3;\n" +
+			"	@Nullable\n" +
+			"	T t4;\n" +
+			"	@NonNull\n" +
+			"	T t5;\n" +
+			"	@NonNull\n" +
+			"	T t6;\n" +
+			"	@NonNull\n" +
+			"	T t7;\n" +
+			"\n" +
+			"	D(@NonNull T t) {\n" +
+			"		t2 = t;\n" +
+			"		switch (X.x) {\n" +
+			"		case x:\n" +
+			"			t1 = t;\n" +
+			"			t5 = t;\n" +
+			"		}\n" +
+			"		t6 = t;\n" +
+			"	}\n" +
+			"\n" +
+			"	void f() {\n" +
+			"		t1.hashCode();\n" +
+			"		t2.hashCode();\n" +
+			"		t3.hashCode();\n" +
+			"		t4.hashCode();\n" +
+			"		t5.hashCode();\n" +
+			"		t6.hashCode();\n" +
+			"		t7.hashCode();\n" +
+			"		T t = t1;\n" +
+			"		t.hashCode();\n" +
+			"	}\n" +
+			"	void g() {\n" +
+			"		if(t1 != null)\n" +
+			"			t1.hashCode();\n // problem report expected because syntactic null analysis for fields is off\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\D.java (at line 7)\n" + 
+		"	T t;\n" + 
+		"	  ^\n" + 
+		"The field t may not have been initialized, whereas its type \'T\' is a free type variable that may represent a \'@NonNull\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\D.java (at line 27)\n" + 
+		"	D(@NonNull T t) {\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The field t1 may not have been initialized, whereas its type \'T\' is a free type variable that may represent a \'@NonNull\' type. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\D.java (at line 27)\n" + 
+		"	D(@NonNull T t) {\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The field t3 may not have been initialized, whereas its type \'T\' is a free type variable that may represent a \'@NonNull\' type. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\D.java (at line 27)\n" + 
+		"	D(@NonNull T t) {\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The @NonNull field t5 may not have been initialized. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\D.java (at line 27)\n" + 
+		"	D(@NonNull T t) {\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The @NonNull field t7 may not have been initialized. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\D.java (at line 38)\n" + 
+		"	t1.hashCode();\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\D.java (at line 39)\n" + 
+		"	t2.hashCode();\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\D.java (at line 40)\n" + 
+		"	t3.hashCode();\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"9. ERROR in test\\D.java (at line 41)\n" + 
+		"	t4.hashCode();\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"10. ERROR in test\\D.java (at line 46)\n" + 
+		"	t.hashCode();\n" + 
+		"	^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" +
+		"11. ERROR in test\\D.java (at line 50)\n" + 
+		"	t1.hashCode();\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556withRaw() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/TestWithRaw.java",
+			"package test;\n" +
+			"\n" +
+			"public class TestWithRaw {\n" +
+			"	@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n" +
+			"	public static void uncheckedEnumValueOf(final Class<?> valueClass, final String value) {\n" +
+			"		Class valueClass2 = valueClass;\n" +
+			"		Enum.valueOf(valueClass2, value).name();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
+public void testBug466556withPGMB() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/TestWithParameterizedGenericMethodBinding.java",
+			"package test;\n" +
+			"\n" +
+			"public class TestWithParameterizedGenericMethodBinding {\n" +
+			"	static <T, E extends T> T f1(E e) {\n" +
+			"		return e;\n" +
+			"	}\n" +
+			"\n" +
+			"	static <T11, E11 extends T11> void g11(E11 e) {\n" +
+			"		f1(e).hashCode();\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\TestWithParameterizedGenericMethodBinding.java (at line 9)\n" + 
+		"	f1(e).hashCode();\n" + 
+		"	^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'E11\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556captures() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/TestCapture.java",
+			"package test;\n" +
+			"\n" +
+			"class I {\n" +
+			"	int i;\n" +
+			"\n" +
+			"	String s() {\n" +
+			"		return \"\";\n" +
+			"	}\n" +
+			"}\n" +
+			"\n" +
+			"class KE<E extends I> {\n" +
+			"	public final E e;\n" +
+			"\n" +
+			"	public E getE() {\n" +
+			"		return e;\n" +
+			"	}\n" +
+			"\n" +
+			"	public KE(E element) {\n" +
+			"		this.e = element;\n" +
+			"	}\n" +
+			"}\n" +
+			"\n" +
+			"class TestFreeTypeVariable<E2 extends I> {\n" +
+			"	public void test(KE<E2> ke) {\n" +
+			"		int i1 = ke.e.i; // error 1\n" +
+			"		ke.e.s().substring(i1); // error 2\n" +
+			"		int i2 = ke.getE().i; // error 3\n" +
+			"		ke.getE().s().substring(i2); // error 4\n" +
+			"	}\n" +
+			"}\n" +
+			"\n" +
+			"public class TestCapture {\n" +
+			"	public void test(KE<? extends I> ke) {\n" +
+			"		int i1 = ke.e.i; // error 5\n" +
+			"		ke.e.s().substring(i1); // error 6\n" +
+			"		int i2 = ke.getE().i; // error 7\n" +
+			"		ke.getE().s().substring(i2); // error 8\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\TestCapture.java (at line 25)\n" + 
+		"	int i1 = ke.e.i; // error 1\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: this expression has type \'E2\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\TestCapture.java (at line 26)\n" + 
+		"	ke.e.s().substring(i1); // error 2\n" + 
+		"	   ^\n" + 
+		"Potential null pointer access: this expression has type \'E2\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\TestCapture.java (at line 27)\n" + 
+		"	int i2 = ke.getE().i; // error 3\n" + 
+		"	         ^^^^^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'E2\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\TestCapture.java (at line 28)\n" + 
+		"	ke.getE().s().substring(i2); // error 4\n" + 
+		"	^^^^^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'E2\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\TestCapture.java (at line 34)\n" + 
+		"	int i1 = ke.e.i; // error 5\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: this expression has type \'capture#1-of ? extends test.I\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\TestCapture.java (at line 35)\n" + 
+		"	ke.e.s().substring(i1); // error 6\n" + 
+		"	   ^\n" + 
+		"Potential null pointer access: this expression has type \'capture#2-of ? extends test.I\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\TestCapture.java (at line 36)\n" + 
+		"	int i2 = ke.getE().i; // error 7\n" + 
+		"	         ^^^^^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'capture#3-of ? extends test.I\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\TestCapture.java (at line 37)\n" + 
+		"	ke.getE().s().substring(i2); // error 8\n" + 
+		"	^^^^^^^^^\n" + 
+		"Potential null pointer access: this expression has type \'capture#4-of ? extends test.I\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
+public void testBug466556Loops() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/TestLoop.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"\n" +
+			"public class TestLoop<T> {\n" +
+			"	boolean b;\n" +
+			"\n" +
+			"	public static void nn(@NonNull Object value) {\n" +
+			"		assert value != null;\n" +
+			"	}\n" +
+			"\n" +
+			"	public void testDoWhile(T t1) {\n" +
+			"		nn(t1); // 1: unchecked warning\n" +
+			"		do {\n" +
+			"			nn(t1); // 2: unchecked warning\n" +
+			"			t1.hashCode(); // 3: Potential null pointer access...free type variable\n" +
+			"		} while (b);\n" +
+			"	}\n" +
+			"\n" +
+			"	public void testWhileWithBreak(T t1) {\n" +
+			"		while (true) {\n" +
+			"			nn(t1); // 4: unchecked warning\n" +
+			"			t1.hashCode(); // 5: Potential null pointer access...free type variable\n" +
+			"			if (b)\n" +
+			"				break;\n" +
+			"		}\n" +
+			"	}\n" +
+			"\n" +
+			"	public void testWhile(T t1) {\n" +
+			"		while (TestLoop.class.hashCode() == 4711) {\n" +
+			"			nn(t1); // 6: unchecked warning\n" +
+			"			t1.hashCode(); // 7: Potential null pointer access...free type variable\n" +
+			"		}\n" +
+			"	}\n" +
+			"\n" +
+			"	public void testFor(T t1) {\n" +
+			"		for (int i = 0; i < 1; i++) {\n" +
+			"			nn(t1); // 8: unchecked warning\n" +
+			"			t1.hashCode(); // 9: Potential null pointer access...free type variable\n" +
+			"		}\n" +
+			"	}\n" +
+			"\n" +
+			"	public void testForEach(T t1) {\n" +
+			"		for (int i = 0; i < 1; i++) {\n" +
+			"			nn(t1); // 10: unchecked warning\n" +
+			"			t1.hashCode(); // 11: Potential null pointer access: The variable t1 may be null at this location\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\TestLoop.java (at line 13)\n" + 
+		"	nn(t1); // 1: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\TestLoop.java (at line 15)\n" + 
+		"	nn(t1); // 2: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\TestLoop.java (at line 16)\n" + 
+		"	t1.hashCode(); // 3: Potential null pointer access...free type variable\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\TestLoop.java (at line 22)\n" + 
+		"	nn(t1); // 4: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"5. ERROR in test\\TestLoop.java (at line 23)\n" + 
+		"	t1.hashCode(); // 5: Potential null pointer access...free type variable\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"6. ERROR in test\\TestLoop.java (at line 31)\n" + 
+		"	nn(t1); // 6: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"7. ERROR in test\\TestLoop.java (at line 32)\n" + 
+		"	t1.hashCode(); // 7: Potential null pointer access...free type variable\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"8. ERROR in test\\TestLoop.java (at line 38)\n" + 
+		"	nn(t1); // 8: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"9. ERROR in test\\TestLoop.java (at line 39)\n" + 
+		"	t1.hashCode(); // 9: Potential null pointer access...free type variable\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"10. ERROR in test\\TestLoop.java (at line 45)\n" + 
+		"	nn(t1); // 10: unchecked warning\n" + 
+		"	   ^^\n" + 
+		"Null type safety: required \'@NonNull\' but this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n" + 
+		"11. ERROR in test\\TestLoop.java (at line 46)\n" + 
+		"	t1.hashCode(); // 11: Potential null pointer access: The variable t1 may be null at this location\n" + 
+		"	^^\n" + 
+		"Potential null pointer access: this expression has type \'T\', a free type variable that may represent a \'@Nullable\' type\n" + 
+		"----------\n"
+	);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 40b86d6..e02eb61 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1816,6 +1816,14 @@ void setSourceStart(int sourceStart);
 	int IllegalReturnNullityRedefinitionFreeTypeVariable = MethodRelated + 974;
 	/** @since 3.12 */
 	int IllegalRedefinitionOfTypeVariable = 975;
+	/** @since 3.12 */
+	int UncheckedAccessOfValueOfFreeTypeVariable = 976;
+	/** @since 3.12 */
+	int UninitializedFreeTypeVariableField = 977;
+	/** @since 3.12 */
+	int UninitializedFreeTypeVariableFieldHintMissingDefault = 978;
+	/** @since 3.12 */
+	int RequiredNonNullButProvidedFreeTypeVariable = TypeRelated + 979;
 
 
 	// Java 8 work
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 84a02b9..7761f87 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -211,6 +211,9 @@ public abstract class AbstractMethodDeclaration
 						flowInfo.markAsDefinitelyNonNull(methodArguments[i].binding);
 					else if (tagBits == TagBits.AnnotationNullable)
 						flowInfo.markPotentiallyNullBit(methodArguments[i].binding);
+					else if (methodBinding.parameters[i].isFreeTypeVariable()) {
+						flowInfo.markNullStatus(methodArguments[i].binding, FlowInfo.FREE_TYPEVARIABLE);
+					}
 				} else {					
 					if (methodBinding.parameterNonNullness != null) {
 						// leverage null-info from parameter annotations:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 6dc2774..3ec2c09 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -204,7 +204,7 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 								((this.bits & ASTNode.IsDefaultConstructor) != 0)
 									? (ASTNode) this.scope.referenceType().declarationOf(field.original())
 									: this);
-					} else if (field.isNonNull()) {
+					} else if (field.isNonNull() || field.type.isFreeTypeVariable()) {
 						FieldDeclaration fieldDecl = this.scope.referenceType().declarationOf(field.original());
 						if (!isValueProvidedUsingAnnotation(fieldDecl))
 							this.scope.problemReporter().uninitializedNonNullField(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index f63db6d..2254285 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -120,7 +120,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			// assigning a final field outside an initializer or constructor or wrong reference
 			currentScope.problemReporter().cannotAssignToFinalField(this.binding, this);
 		}
-	} else if (this.binding.isNonNull()) {
+	} else if (this.binding.isNonNull() || this.binding.type.isTypeVariable()) {
 		// in a context where it can be assigned?
 		if (   !isCompound
 			&& this.receiver.isThis()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index ce2f82f..966e309 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -375,8 +375,14 @@ private FlowInfo analyseNullAssertion(BlockScope currentScope, Expression argume
 
 public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, int ttlForFieldCheck) {
 	// message send as a receiver
-	if ((nullStatus(flowInfo, flowContext) & FlowInfo.POTENTIALLY_NULL) != 0) // note that flowInfo is not used inside nullStatus(..)
-		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+	int nullStatus = nullStatus(flowInfo, flowContext); // note that flowInfo is not used inside nullStatus(..)
+	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0) {
+		if(this.binding.returnType.isTypeVariable() && nullStatus == FlowInfo.FREE_TYPEVARIABLE && scope.environment().globalOptions.pessimisticNullAnalysisForFreeTypeVariablesEnabled) {
+			scope.problemReporter().methodReturnTypeFreeTypeVariableReference(this.binding, this);			
+		} else {
+			scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+		}
+	}
 	return true; // done all possible checking
 }
 /**
@@ -540,7 +546,10 @@ public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		// try to retrieve null status of this message send from an annotation of the called method:
 		long tagBits = this.binding.tagBits;
 		if ((tagBits & TagBits.AnnotationNullMASK) == 0L) // alternatively look for type annotation (will only be present in 1.8+):
-			tagBits = this.binding.returnType.tagBits;
+			tagBits = this.binding.returnType.tagBits & TagBits.AnnotationNullMASK;
+		if(tagBits == 0L && this.binding.returnType.isFreeTypeVariable()) {
+			return FlowInfo.FREE_TYPEVARIABLE;
+		}
 		return FlowInfo.tagBitsToNullStatus(tagBits);
 	}
 	return FlowInfo.UNKNOWN;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index bbd4cda..35e3234 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -62,6 +62,10 @@ protected boolean checkNullableFieldDereference(Scope scope, FieldBinding field,
 		if ((field.type.tagBits & TagBits.AnnotationNullable) != 0) {
 			scope.problemReporter().dereferencingNullableExpression(sourcePosition, scope.environment());
 			return true;
+		} 
+		if (field.type.isFreeTypeVariable()) {
+			scope.problemReporter().fieldFreeTypeVariableReference(field, sourcePosition);
+			return true;
 		}
 		if ((field.tagBits & TagBits.AnnotationNullable) != 0) {
 			scope.problemReporter().nullableFieldDereference(field, sourcePosition);
@@ -149,6 +153,8 @@ public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 			return FlowInfo.NON_NULL;
 		} else if (fieldBinding.isNullable()) {
 			return FlowInfo.POTENTIALLY_NULL;
+		} else if (fieldBinding.type.isFreeTypeVariable()) {
+			return FlowInfo.FREE_TYPEVARIABLE;
 		}
 	}
 	if (this.resolvedType != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index 3c06e3e..e0dfde8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -124,7 +124,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				} else {
 					currentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);
 				}
-			} else if (!isCompound && fieldBinding.isNonNull()
+			} else if (!isCompound && (fieldBinding.isNonNull() || fieldBinding.type.isTypeVariable())
 						&& TypeBinding.equalsEquals(fieldBinding.declaringClass, currentScope.enclosingReceiverType())) { // inherited fields are not tracked here
 				// record assignment for detecting uninitialized non-null fields:
 				flowInfo.markAsDefinitelyAssigned(fieldBinding);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 6b1a868..e75997d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -947,6 +947,10 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 				return;
 			}
 			if (flowInfo.isPotentiallyNull(local)) {
+				if(local.type.isFreeTypeVariable()) {
+					scope.problemReporter().localVariableFreeTypeVariableReference(local, location);
+					return;
+				}
 				scope.problemReporter().localVariablePotentialNullReference(local, location);
 				return;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
index 30cf54e..ad63440 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -52,6 +52,8 @@ public abstract class FlowInfo {
 	public final static int POTENTIALLY_NON_NULL = 32;
 
 	public final static int UNROOTED = 64; // marks a flowInfo that may be appended to another flowInfo (accepting incoming nulls/nonnulls, see UFI.iNBit/iNNBit).
+	
+	public static final int FREE_TYPEVARIABLE = FlowInfo.POTENTIALLY_NULL | FlowInfo.POTENTIALLY_NON_NULL;
 
 	public static final UnconditionalFlowInfo DEAD_END; // Represents a dead branch status of initialization
 	static {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index bae9872..7093c8c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -184,6 +184,8 @@ public class CompilerOptions {
 	public static final String OPTION_SyntacticNullAnalysisForFields = "org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
+	public static final String OPTION_PessimisticNullAnalysisForFreeTypeVariables = "org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables";  //$NON-NLS-1$
+	
 	/**
 	 * Possible values for configurable options
 	 */
@@ -304,6 +306,7 @@ public class CompilerOptions {
 	public static final int UnusedTypeParameter = IrritantSet.GROUP2 | ASTNode.Bit17;
 	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
+	public static final int PessimisticNullAnalysisForFreeTypeVariables = IrritantSet.GROUP2 | ASTNode.Bit20;
 
 	// Severity level for handlers
 	/** 
@@ -477,11 +480,15 @@ public class CompilerOptions {
 	/** Should immediate null-check for fields be considered during null analysis (syntactical match)? */
 	public boolean enableSyntacticNullAnalysisForFields;
 
+	/** Is the error level for pessimistic null analysis for free type variables different from "ignore"? */
+	public boolean pessimisticNullAnalysisForFreeTypeVariablesEnabled;
+
 	public boolean complainOnUninternedIdentityComparison;
 	public boolean emulateJavacBug8031744 = true;
 
 	/** Not directly configurable, derived from other options by LookupEnvironment.usesNullTypeAnnotations() */
 	public Boolean useNullTypeAnnotations = null;
+	
 
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
@@ -698,6 +705,8 @@ public class CompilerOptions {
 				return OPTION_ReportRedundantNullAnnotation;
 			case NonnullParameterAnnotationDropped:
 				return OPTION_ReportNonnullParameterAnnotationDropped;
+			case PessimisticNullAnalysisForFreeTypeVariables:
+				return OPTION_PessimisticNullAnalysisForFreeTypeVariables;
 		}
 		return null;
 	}
@@ -961,6 +970,7 @@ public class CompilerOptions {
 			case RedundantNullAnnotation :
 			case MissingNonNullByDefaultAnnotation:
 			case NonnullParameterAnnotationDropped:
+			case PessimisticNullAnalysisForFreeTypeVariables:
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1202,6 +1212,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_PessimisticNullAnalysisForFreeTypeVariables, getSeverityString(PessimisticNullAnalysisForFreeTypeVariables));
 		return optionsMap;
 	}
 
@@ -1736,6 +1747,12 @@ public class CompilerOptions {
 				this.inheritNullAnnotations = ENABLED.equals(optionValue);
 			}
 			if ((optionValue = optionsMap.get(OPTION_ReportNonnullParameterAnnotationDropped)) != null) updateSeverity(NonnullParameterAnnotationDropped, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_PessimisticNullAnalysisForFreeTypeVariables)) != null) updateSeverity(PessimisticNullAnalysisForFreeTypeVariables, optionValue);
+			if (getSeverity(PessimisticNullAnalysisForFreeTypeVariables) == ProblemSeverities.Ignore) {
+				this.pessimisticNullAnalysisForFreeTypeVariablesEnabled = false;
+			} else {
+				this.pessimisticNullAnalysisForFreeTypeVariablesEnabled = true;
+			}
 		}
 
 		// Javadoc options
@@ -2003,6 +2020,7 @@ public class CompilerOptions {
 		buf.append("\n\t- resource may not be closed: ").append(getSeverityString(PotentiallyUnclosedCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- resource should be handled by try-with-resources: ").append(getSeverityString(ExplicitlyClosedAutoCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
+		buf.append("\n\t- pessimistic null analysis for free type variables: ").append(getSeverityString(PessimisticNullAnalysisForFreeTypeVariables)); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index b3f67c9..e9993c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -115,7 +115,8 @@ public class IrritantSet {
 				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation
-				|CompilerOptions.NonnullParameterAnnotationDropped);
+				|CompilerOptions.NonnullParameterAnnotationDropped
+				|CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
@@ -134,7 +135,8 @@ public class IrritantSet {
 			.set(CompilerOptions.NullUncheckedConversion)
 			.set(CompilerOptions.RedundantNullAnnotation)
 			.set(CompilerOptions.NonnullParameterAnnotationDropped)
-			.set(CompilerOptions.MissingNonNullByDefaultAnnotation);
+			.set(CompilerOptions.MissingNonNullByDefaultAnnotation)
+			.set(CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables);
 
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index a2612d0..fdb6fb3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1680,4 +1680,8 @@ public boolean isFunctionalType() {
 public long updateTagBits() {
 	return this.tagBits & TagBits.HasNullTypeAnnotation; // subclasses to override
 }
+
+public boolean isFreeTypeVariable() {
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 6f77adb..00f85b2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -43,10 +43,10 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
-import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants.BoundCheckStatus;
@@ -1050,4 +1050,11 @@ public class TypeVariableBinding extends ReferenceBinding {
 		}
 		return super.updateTagBits();
 	}
+
+	@Override
+	public boolean isFreeTypeVariable() {
+		return this.environment.usesNullTypeAnnotations() 
+				&& this.environment.globalOptions.pessimisticNullAnalysisForFreeTypeVariablesEnabled 
+				&& (this.tagBits & TagBits.AnnotationNullMASK) == 0;	
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 29437ef..607e180 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -406,8 +406,6 @@ public static int getIrritant(int problemID) {
 		case IProblem.CannotImplementIncompatibleNullness:
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
-		case IProblem.NullNotCompatibleToFreeTypeVariable:
-		case IProblem.NullityMismatchAgainstFreeTypeVariable:
 		case IProblem.NullityMismatchingTypeAnnotation:
 		case IProblem.NullityMismatchingTypeAnnotationSuperHint:
 		case IProblem.NullityMismatchTypeArgument:
@@ -421,6 +419,14 @@ public static int getIrritant(int problemID) {
 		case IProblem.ContradictoryNullAnnotationsInferredFunctionType:
 			return CompilerOptions.NullSpecViolation;
 
+		case IProblem.NullNotCompatibleToFreeTypeVariable:
+		case IProblem.NullityMismatchAgainstFreeTypeVariable:
+		case IProblem.UncheckedAccessOfValueOfFreeTypeVariable:
+		case IProblem.RequiredNonNullButProvidedFreeTypeVariable:
+		case IProblem.UninitializedFreeTypeVariableField:
+		case IProblem.UninitializedFreeTypeVariableFieldHintMissingDefault:
+			return CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables;
+
 		case IProblem.ParameterLackingNonNullAnnotation:
 			return CompilerOptions.NonnullParameterAnnotationDropped;
 
@@ -652,6 +658,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.UnusedObjectAllocation :
 			case CompilerOptions.UnclosedCloseable :
 			case CompilerOptions.PotentiallyUnclosedCloseable :
+			case CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables :
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -5864,7 +5871,54 @@ public void localVariableNullReference(LocalVariableBinding local, ASTNode locat
 		nodeSourceEnd(local, location));
 }
 
+public void fieldFreeTypeVariableReference(FieldBinding variable, long position) {
+	char[][] nullableName = this.options.nullableAnnotationName;
+	String[] arguments = new String[] {new String(variable.type.readableName()), 
+			new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.UncheckedAccessOfValueOfFreeTypeVariable,
+		arguments,
+		arguments,
+		(int)(position >>> 32),
+		(int)position);
+}
+
+
+public void localVariableFreeTypeVariableReference(LocalVariableBinding local, ASTNode location) {
+	int severity = computeSeverity(IProblem.UncheckedAccessOfValueOfFreeTypeVariable);
+	if (severity == ProblemSeverities.Ignore) return;
+	char[][] nullableName = this.options.nullableAnnotationName;
+	String[] arguments = new String[] {new String(local.type.readableName()), 
+			new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.UncheckedAccessOfValueOfFreeTypeVariable,
+		arguments,
+		arguments,
+		severity,
+		nodeSourceStart(local, location),
+		nodeSourceEnd(local, location));
+}
+
+public void methodReturnTypeFreeTypeVariableReference(MethodBinding method, ASTNode location) {
+	int severity = computeSeverity(IProblem.UncheckedAccessOfValueOfFreeTypeVariable);
+	if (severity == ProblemSeverities.Ignore) return;
+	char[][] nullableName = this.options.nullableAnnotationName;
+	String[] arguments = new String[] {new String(method.returnType.readableName()), 
+			new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.UncheckedAccessOfValueOfFreeTypeVariable,
+		arguments,
+		arguments,
+		location.sourceStart,
+		location.sourceEnd);
+}
+
+
 public void localVariablePotentialNullReference(LocalVariableBinding local, ASTNode location) {
+	if(local.type.isFreeTypeVariable()) {
+		localVariableFreeTypeVariableReference(local, location);
+		return;
+	}
 	if (location instanceof Expression && (((Expression)location).implicitConversion & TypeIds.UNBOXING) != 0) {
 		potentialNullUnboxing(location, local.type);
 		return;
@@ -8125,6 +8179,20 @@ public void uninitializedBlankFinalField(FieldBinding field, ASTNode location) {
 }
 public void uninitializedNonNullField(FieldBinding field, ASTNode location) {
 	char[][] nonNullAnnotationName = this.options.nonNullAnnotationName;
+	if(!field.isNonNull()) {
+		String[] arguments = new String[] {
+				new String(field.readableName()), 
+				new String(field.type.readableName()), 
+				new String(nonNullAnnotationName[nonNullAnnotationName.length-1])
+		};
+		this.handle(
+				methodHasMissingSwitchDefault() ? IProblem.UninitializedFreeTypeVariableFieldHintMissingDefault : IProblem.UninitializedFreeTypeVariableField,
+				arguments,
+				arguments,
+				nodeSourceStart(field, location),
+				nodeSourceEnd(field, location));	
+		return;
+	}
 	String[] arguments = new String[] {
 			new String(nonNullAnnotationName[nonNullAnnotationName.length-1]),
 			new String(field.readableName())
@@ -9216,6 +9284,10 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 		if (var == null && expression instanceof Reference) {
 			var = ((Reference)expression).lastFieldBinding();
 		}
+		if(var != null && var.type.isFreeTypeVariable()) {			
+			nullityMismatchVariableIsFreeTypeVariable(var, expression);
+			return;
+		}
 		if (var != null && var.isNullable()) {
 			nullityMismatchSpecdNullable(expression, requiredType, annotationName);
 			return;
@@ -9297,6 +9369,21 @@ public void nullityMismatchIsUnknown(Expression expression, TypeBinding provided
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
 }
+private void nullityMismatchIsFreeTypeVariable(TypeBinding providedType, int sourceStart, int sourceEnd) {
+	char[][] nullableName = this.options.nullableAnnotationName;
+	char[][] nonNullName = this.options.nonNullAnnotationName;
+	String[] arguments = new String[] { 
+			new String(nonNullName[nonNullName.length-1]), 
+			new String(providedType.readableName()), 
+			new String(nullableName[nullableName.length-1])};
+	this.handle(IProblem.RequiredNonNullButProvidedFreeTypeVariable, arguments, arguments, sourceStart, sourceEnd);
+}
+public void nullityMismatchVariableIsFreeTypeVariable(VariableBinding variable, ASTNode location) {
+	int severity = computeSeverity(IProblem.RequiredNonNullButProvidedFreeTypeVariable);
+	if (severity == ProblemSeverities.Ignore) return;
+	nullityMismatchIsFreeTypeVariable(variable.type, nodeSourceStart(variable, location),
+			nodeSourceEnd(variable, location));
+}
 public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
 	int sourceStart = argument.type.sourceStart;
 	if (argument.annotations != null) {
@@ -9823,6 +9910,11 @@ public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding
 			&& (requiredType.tagBits & TagBits.AnnotationNonNull) != 0 
 			&& (providedType.tagBits & TagBits.AnnotationNullable) == 0)
 	{
+		if(this.options.pessimisticNullAnalysisForFreeTypeVariablesEnabled && providedType.isTypeVariable() && !providedType.hasNullTypeAnnotations()) {
+			nullityMismatchIsFreeTypeVariable(providedType, expression.sourceStart, expression.sourceEnd);
+			return;
+		}
+
 		nullityMismatchPotentiallyNull(expression, requiredType, this.options.nonNullAnnotationName);
 		return;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 34e1866..37672d6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2015 IBM Corporation and others.
+# Copyright (c) 2000, 2016 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -832,6 +832,11 @@
 973 = Contradictory null annotations: function type was inferred as ''{2} ({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
 974 = The return type is incompatible with the free type variable ''{1}'' returned from {0} (mismatching null constraints)
 975 = Cannot redefine null constraints of type variable ''{0}'' declared in ''{1}''
+976 = Potential null pointer access: this expression has type ''{0}'', a free type variable that may represent a ''@{1}'' type
+977 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type
+978 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
+979 = Null type safety: required ''@{0}'' but this expression has type ''{1}'', a free type variable that may represent a ''@{2}'' type
+
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 95e3c83..9627875 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1774,6 +1774,22 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_NULL_UNCHECKED_CONVERSION = PLUGIN_ID + ".compiler.problem.nullUncheckedConversion"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Report problems detected by pessimistic null analysis for free type variables.
+	 * <p>When not set to "ignore", type variables without explicit null annotation are assumed to be nullable,
+	 * where values are read, and nonnull, where values are assigned or provided as return value.</p>
+	 * <p>Problems reported for values whose type is such free type variable are reported with the level given in this option.</p>
+	 * <p>If such a value is assigned to a variable with a compatible ordinary type, its nullness information is set 
+	 * accordingly and any follow-up problem is reported according to the corresponding compiler option</p>
+	 * @since 3.12
+	 * @category CompilerOptionID
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "info", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 */
+	public static final String COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES = PLUGIN_ID + ".compiler.problem.pessimisticNullAnalysisForFreeTypeVariables"; //$NON-NLS-1$
+	/**
 	 * Compiler option ID: Reporting Redundant Null Annotations.
 	 * <p>When enabled, the compiler will issue an error or a warning when a non-null annotation
 	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
commit 80ffb9f552f489b2bf6197004bfa593cb4ed2451
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Mar 3 15:55:32 2016 +0100

    Bug 466556 - [null][1.8] Incorrect null analysis for "unconstrained"
    type parameters
    
    Change-Id: I47ca6a962f668d90a623d07911b033a0847fb7bd

6	6	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 9627875..be641c3 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1774,12 +1774,12 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_NULL_UNCHECKED_CONVERSION = PLUGIN_ID + ".compiler.problem.nullUncheckedConversion"; //$NON-NLS-1$
 	/**
-	 * Compiler option ID: Report problems detected by pessimistic null analysis for free type variables.
-	 * <p>When not set to "ignore", type variables without explicit null annotation are assumed to be nullable,
-	 * where values are read, and nonnull, where values are assigned or provided as return value.</p>
-	 * <p>Problems reported for values whose type is such free type variable are reported with the level given in this option.</p>
-	 * <p>If such a value is assigned to a variable with a compatible ordinary type, its nullness information is set 
-	 * accordingly and any follow-up problem is reported according to the corresponding compiler option</p>
+	 * Compiler option ID: Reporting problems detected by pessimistic null analysis for free type variables.
+	 * <p>Unless set to <code>"ignore"</code>, type variables not affected by any explicit null annotation are pessimistically analyzed
+	 * in two directions: When reading a value of this type, it is assumed to be nullable. When this type appears as the required type
+	 * (i.e., at the left hand side of an assignment or variable initialization, or as the method return type against which a return statement
+	 * is being checked) the type is considered to require the nonnull property.</p>
+	 * <p>Problems reported due to this pessimistic analysis are reported with the level given in this option.</p>
 	 * @since 3.12
 	 * @category CompilerOptionID
 	 * <dl>
