commit 09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Sat Dec 21 00:16:49 2013 +0100

    Bug 418979: Improved Javadoc to include bug 404489 comment 4

17	24	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
index b3b549f..43d305c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
@@ -28,35 +28,28 @@ import java.util.List;
  * <p>
  * Not all node arrangements will represent legal Java constructs. In particular,
  * it is nonsense if the type is an array type or primitive type. The normal use
- * is when the type is a simple or parameterized type.
+ * is when the type is a ParameterizedType, an annotated QualifiedType, or a
+ * PackageQualifiedType.
  * </p>
  * <p>
- * A type like "A.B" can be represented either of two ways:
- * <ol>
- * <li>
- * <code>QualifiedType(SimpleType(SimpleName("A")),SimpleName("B"))</code>
- * </li>
- * <li>
- * <code>SimpleType(QualifiedName(SimpleName("A"),SimpleName("B")))</code>
- * </li>
- * </ol>
- * The first form is preferred when "A" is known to be a type. However, a
- * parser cannot always determine this. Clients should be prepared to handle
- * either rather than make assumptions. (Note also that the first form
- * became possible as of JLS3; only the second form existed in JLS2 API;
- * the ASTParser currently prefers the second form).
+ * A "."-separated type like "A.B" can be represented in three ways:
+ * <pre>
+ * 1.    SimpleType       | 2.   QualifiedType     | 3. PackageQualifiedType
+ *     QualifiedName      | SimpleType  SimpleName |   SimpleName  SimpleName
+ * SimpleName  SimpleName | SimpleName     "B"     |       "A"        "B"
+ *     "A"        "B"     |     "A"                |
+ * </pre>
+ * <p>
+ * The ASTParser creates the SimpleType form (wrapping a name) if possible. The
+ * SimpleType form doesn't support any embedded Annotations nor ParameterizedTypes.
+ * The QualifiedType form is only available since JLS3 and the
+ * PackageQualifiedType form only since JLS8.
  * </p>
  * <p>
- * Since JLS8, it's also possible to annotate qualified type names.
- * A type like "a.@X B" cannot be represented in either of
- * the old ways, because "a" is not a type, but a package.
- * Such types are represented as:
+ * The QualifiedType form cannot be used if the qualifier resolves to a package
+ * name, e.g. for "pack.@A C". In that case, the PackageQualifiedType form is used.
+ * If bindings are not resolved, then only the QualifiedType form is used.
  * </p>
- * <ol start="3">
- * <li>
- * <code>PackageQualifiedType(SimpleName("a"),MarkerAnnotation("X"),SimpleName("B"))</code>
- * </li>
- * </ol>
  * 
  * @see SimpleType
  * @see PackageQualifiedType
commit 25dbd9e17c7b6920dccf1b458296dbbe00f382de
Author: M N Palat <manpalat@in.ibm.com>
Date:   Mon Jan 6 16:05:48 2014 +0530

    Fix for Bug 418979 [1.8][dom ast] Bad source ranges for annotated
    QualifiedType as type of ParameterizedType

127	82	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
1	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
23	23	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeAnnotationsTest.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
4	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
61	66	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
25	25	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
16	18	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
6	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
294	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
0	294	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PackageQualifiedType.java
24	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
7	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index a35c59d..3833e61 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -204,10 +204,10 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertNotNull(assignment);
 		CastExpression castExpression = (CastExpression) assignment.getRightHandSide();
 		assertNotNull(castExpression);
-		PackageQualifiedType packageQualifiedType = (PackageQualifiedType) castExpression.getType();
-		assertNotNull(packageQualifiedType);
-		assertEquals("java.lang.@Marker String", packageQualifiedType.toString());
-		List annotations = packageQualifiedType.annotations();
+		NameQualifiedType nameQualifiedType = (NameQualifiedType) castExpression.getType();
+		assertNotNull(nameQualifiedType);
+		assertEquals("java.lang.@Marker String", nameQualifiedType.toString());
+		List annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		assertEquals("@Marker", annotations.get(0).toString());
 
@@ -224,22 +224,22 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		// annotations.
 		variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
 		type = variableDeclarationStatement.getType();
-		assertTrue(type.isQualifiedType());
-		QualifiedType qualifiedType = (QualifiedType) type;
-		assertNotNull(qualifiedType);
-		assertEquals("Outer.@Marker2 Inner", qualifiedType.toString());
-		annotations = qualifiedType.annotations();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		assertNotNull(nameQualifiedType);
+		assertEquals("Outer.@Marker2 Inner", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		assertEquals("@Marker2", annotations.get(0).toString());
 
 		// case 4 - Multiple levels with annotations at the last only.
 		variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
 		type = variableDeclarationStatement.getType();
-		assertTrue(type.isQualifiedType());
-		qualifiedType = (QualifiedType) type;
-		assertNotNull(qualifiedType);
-		assertEquals("Outer.Inner.@Marker1 Deeper", qualifiedType.toString());
-		annotations = qualifiedType.annotations();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		assertNotNull(nameQualifiedType);
+		assertEquals("Outer.Inner.@Marker1 Deeper", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		assertEquals("@Marker1", annotations.get(0).toString());
 
@@ -247,7 +247,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
 		type = variableDeclarationStatement.getType();
 		assertTrue(type.isQualifiedType());
-		qualifiedType = (QualifiedType) type;
+		QualifiedType qualifiedType = (QualifiedType) type;
 		assertNotNull(qualifiedType);
 		assertEquals("Outer.@Marker1 Inner.@Marker2 Deeper", qualifiedType.toString());
 		annotations = qualifiedType.annotations();
@@ -256,10 +256,10 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		SimpleName simpleName = qualifiedType.getName();
 		assertEquals("Deeper", simpleName.toString());
 		Type qualifierType = qualifiedType.getQualifier();
-		assertTrue(qualifierType.isQualifiedType());
-		qualifiedType = (QualifiedType) qualifierType;
-		assertEquals("Outer.@Marker1 Inner", qualifiedType.toString());
-		annotations = qualifiedType.annotations();
+		assertTrue(qualifierType.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) qualifierType;
+		assertEquals("Outer.@Marker1 Inner", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		assertEquals("@Marker1", annotations.get(0).toString());
 	}
@@ -395,10 +395,10 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		typeArguments = parametrizedType.typeArguments();
 		assertEquals(1, typeArguments.size());
 		type = (Type) typeArguments.get(0);
-		assertTrue(type.isQualifiedType());
-		QualifiedType qualifiedType = (QualifiedType) type;
-		assertEquals("Outer.@Marker1 Inner", qualifiedType.toString());
-		List annotations = qualifiedType.annotations();
+		assertTrue(type.isNameQualifiedType());
+		NameQualifiedType nameQualifiedType = (NameQualifiedType) type;
+		assertEquals("Outer.@Marker1 Inner", nameQualifiedType.toString());
+		List annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		Annotation annotation = (Annotation) annotations.get(0);
 		assertEquals("@Marker1", annotation.toString());
@@ -412,7 +412,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		type = (Type) typeArguments.get(0);
 		assertTrue(type.isQualifiedType());
 		assertEquals("@Marker1 Outer.Inner", type.toString());
-		qualifiedType = (QualifiedType) type;
+		QualifiedType qualifiedType = (QualifiedType) type;
 		assertEquals("Inner", qualifiedType.getName().toString());
 		annotations = qualifiedType.annotations();
 		assertTrue(annotations.size() == 0);
@@ -457,7 +457,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 	 * 
 	 * @throws JavaModelException
 	 */
-	public void _test0006() throws JavaModelException {
+	public void test0006() throws JavaModelException {
 		this.workingCopy = getWorkingCopy("/Converter18/src/test0006/X.java",
 				true);
 		String contents = "package test0006;"
@@ -545,11 +545,9 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertEquals("Deeper", name.toString());
 		List annotations = qualifiedType.annotations();
 		assertTrue(annotations.size() == 0);
-		Type qualifierType = qualifiedType.getQualifier();
-		assertTrue(qualifierType.isSimpleType());
-		simpleType = (SimpleType) qualifierType;
-		assertEquals("Outer.@Marker1 Inner", simpleType.toString());
-		annotations = simpleType.annotations();
+		NameQualifiedType nameQualifiedType = (NameQualifiedType) qualifiedType.getQualifier();
+		assertEquals("Outer.@Marker1 Inner", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		Annotation annotation = (Annotation) annotations.get(0);
 		assertEquals("@Marker1", annotation.toString());
@@ -577,11 +575,11 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		assertEquals("@Marker2", annotation.toString());
-		qualifierType = qualifiedType.getQualifier();
-		assertTrue(qualifierType.isSimpleType());
-		simpleType = (SimpleType) qualifierType;
-		assertEquals("Outer.@Marker1 Inner", simpleType.toString());
-		annotations = simpleType.annotations();
+		Type qualifierType = qualifiedType.getQualifier();
+		assertTrue(qualifierType.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) qualifierType;
+		assertEquals("Outer.@Marker1 Inner", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		assertEquals("@Marker1", annotation.toString());
@@ -742,10 +740,10 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		type = (Type) typeArguments.get(0);
 		assertEquals("Integer", type.toString());
 		type = parametrizedType.getType();
-		assertTrue(type.isSimpleType());
-		simpleType = (SimpleType) type;
-		assertEquals("Outer1.@Marker1 Inner", simpleType.toString());
-		annotations = simpleType.annotations();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		assertEquals("Outer1.@Marker1 Inner", nameQualifiedType.toString());
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		assertEquals("@Marker1", annotation.toString());
@@ -1807,7 +1805,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		methodBinding = typeMethodReference.resolveMethodBinding();
 		assertNotNull(methodBinding);
 		type = typeMethodReference.getType();
-		assertTrue(type.isQualifiedType());
+		assertTrue(type.isNameQualifiedType());
 		checkSourceRange(type, "Y.@Marker Z", contents);
 		typeArguments = typeMethodReference.typeArguments();
 		assertTrue(typeArguments.size() == 0);
@@ -1828,7 +1826,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		methodBinding = typeMethodReference.resolveMethodBinding();
 		assertNotNull(methodBinding);
 		type = typeMethodReference.getType();
-		assertTrue(type.isQualifiedType());
+		assertTrue(type.isNameQualifiedType());
 		checkSourceRange(type, "Y.@Marker Z", contents);
 		typeArguments = typeMethodReference.typeArguments();
 		assertTrue(typeArguments.size() == 1);
@@ -2329,15 +2327,15 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertEquals("Not a method declaration", ASTNode.METHOD_DECLARATION, node.getNodeType());		
 		MethodDeclaration methodDecl = (MethodDeclaration) node;
 		Type type = methodDecl.getReturnType2();
-		assertTrue(type.isPackageQualifiedType());
-		PackageQualifiedType packageQualifiedType = (PackageQualifiedType) type;
-		checkSourceRange(packageQualifiedType, "test404489.bug.@NonNull IOException", source);
-		ITypeBinding typeBinding = packageQualifiedType.resolveBinding();
+		assertTrue(type.isNameQualifiedType());
+		NameQualifiedType nameQualifiedType = (NameQualifiedType) type;
+		checkSourceRange(nameQualifiedType, "test404489.bug.@NonNull IOException", source);
+		ITypeBinding typeBinding = nameQualifiedType.resolveBinding();
 		assertNotNull("null binding", typeBinding);
 		assertEquals("not a valid binding", "test404489.bug.IOException", typeBinding.getQualifiedName());
 		
-		// qualifier of the package qualified type
-		Name name = packageQualifiedType.getQualifier();
+		// qualifier of the name qualified type
+		Name name = nameQualifiedType.getQualifier();
 		assertTrue(name.isQualifiedName());
 		QualifiedName qualifiedName = (QualifiedName) name;
 		checkSourceRange(qualifiedName, "test404489.bug", source);
@@ -2363,8 +2361,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue("not a package binding", binding.getKind() == IBinding.PACKAGE);
 		assertEquals("wrong package binding", "package test404489.bug", binding.toString());
 		
-		// annotations of package qualified type
-		List annotations = packageQualifiedType.annotations();
+		// annotations of name qualified type
+		List annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		Annotation annotation = (Annotation) annotations.get(0);
 		typeBinding = annotation.resolveTypeBinding();
@@ -2379,8 +2377,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		checkSourceRange(simpleName, "NonNull", source);
 		assertNotNull(typeBinding);
 		
-		// name of the package qualified type
-		simpleName = packageQualifiedType.getName();
+		// name of the name qualified type
+		simpleName = nameQualifiedType.getName();
 		checkSourceRange(simpleName, "IOException", source);
 		typeBinding = simpleName.resolveTypeBinding();
 		assertNotNull(typeBinding);
@@ -2388,15 +2386,15 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		// parameter
 		SingleVariableDeclaration param = (SingleVariableDeclaration) methodDecl.parameters().get(0);
 		type = param.getType();
-		assertTrue(type.isPackageQualifiedType());
-		packageQualifiedType = (PackageQualifiedType) type;
-		checkSourceRange(packageQualifiedType, "test404489.bug.@NonNull FileNotFoundException", source);
-		typeBinding = packageQualifiedType.resolveBinding();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		checkSourceRange(nameQualifiedType, "test404489.bug.@NonNull FileNotFoundException", source);
+		typeBinding = nameQualifiedType.resolveBinding();
 		assertNotNull("null binding", typeBinding);
 		assertEquals("not a valid binding", "test404489.bug.FileNotFoundException", typeBinding.getQualifiedName());
 		
-		// qualifier of the package qualified type
-		name = packageQualifiedType.getQualifier();
+		// qualifier of the name qualified type
+		name = nameQualifiedType.getQualifier();
 		assertTrue(name.isQualifiedName());
 		qualifiedName = (QualifiedName) name;
 		checkSourceRange(qualifiedName, "test404489.bug", source);
@@ -2422,8 +2420,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue("not a package binding", binding.getKind() == IBinding.PACKAGE);
 		assertEquals("wrong package binding", "package test404489.bug", binding.toString());
 		
-		// annotations of package qualified type
-		annotations = packageQualifiedType.annotations();
+		// annotations of name qualified type
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		typeBinding = annotation.resolveTypeBinding();
@@ -2438,23 +2436,23 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		checkSourceRange(simpleName, "NonNull", source);
 		assertNotNull(typeBinding);
 		
-		// name of the package qualified type
-		simpleName = packageQualifiedType.getName();
+		// name of the name qualified type
+		simpleName = nameQualifiedType.getName();
 		checkSourceRange(simpleName, "FileNotFoundException", source);
 		typeBinding = simpleName.resolveTypeBinding();
 		assertNotNull(typeBinding);
 		
 		// throws
 		type = (Type) methodDecl.thrownExceptionTypes().get(0);
-		assertTrue(type.isPackageQualifiedType());
-		packageQualifiedType = (PackageQualifiedType) type;
-		checkSourceRange(packageQualifiedType, "test404489.bug.@NonNull EOFException", source);
-		typeBinding = packageQualifiedType.resolveBinding();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		checkSourceRange(nameQualifiedType, "test404489.bug.@NonNull EOFException", source);
+		typeBinding = nameQualifiedType.resolveBinding();
 		assertNotNull("null binding", typeBinding);
 		assertEquals("not a valid binding", "test404489.bug.EOFException", typeBinding.getQualifiedName());
 		
-		// qualifier of the package qualified type
-		name = packageQualifiedType.getQualifier();
+		// qualifier of the name qualified type
+		name = nameQualifiedType.getQualifier();
 		assertTrue(name.isQualifiedName());
 		qualifiedName = (QualifiedName) name;
 		checkSourceRange(qualifiedName, "test404489.bug", source);
@@ -2480,8 +2478,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue("not a package binding", binding.getKind() == IBinding.PACKAGE);
 		assertEquals("wrong package binding", "package test404489.bug", binding.toString());
 		
-		// annotations of package qualified type
-		annotations = packageQualifiedType.annotations();
+		// annotations of name qualified type
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		typeBinding = annotation.resolveTypeBinding();
@@ -2496,8 +2494,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		checkSourceRange(simpleName, "NonNull", source);
 		assertNotNull(typeBinding);
 		
-		// name of the package qualified type
-		simpleName = packageQualifiedType.getName();
+		// name of the name qualified type
+		simpleName = nameQualifiedType.getName();
 		checkSourceRange(simpleName, "EOFException", source);
 		typeBinding = simpleName.resolveTypeBinding();
 		assertNotNull(typeBinding);
@@ -2508,16 +2506,16 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		type = field.getType();
 		assertTrue(type.isQualifiedType());
 		QualifiedType qualifiedType = (QualifiedType) type;
-		packageQualifiedType = (PackageQualifiedType)qualifiedType.getQualifier();
-		checkSourceRange(packageQualifiedType, "test404489.bug.@NonNull X", source);
-		typeBinding = packageQualifiedType.resolveBinding();
+		nameQualifiedType = (NameQualifiedType)qualifiedType.getQualifier();
+		checkSourceRange(nameQualifiedType, "test404489.bug.@NonNull X", source);
+		typeBinding = nameQualifiedType.resolveBinding();
 		assertNotNull("null binding", typeBinding);
 		assertEquals("not a valid binding", "test404489.bug.X", typeBinding.getQualifiedName());
-		name = packageQualifiedType.getName();
-		assertSame("bindings different for package qualified type and assocated name", typeBinding, name.resolveTypeBinding());
+		name = nameQualifiedType.getName();
+		assertSame("bindings different for name qualified type and assocated name", typeBinding, name.resolveTypeBinding());
 		
-		// qualifier of the package qualified type
-		name = packageQualifiedType.getQualifier();
+		// qualifier of the name qualified type
+		name = nameQualifiedType.getQualifier();
 		assertTrue(name.isQualifiedName());
 		qualifiedName = (QualifiedName) name;
 		checkSourceRange(qualifiedName, "test404489.bug", source);
@@ -2543,8 +2541,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue("not a package binding", binding.getKind() == IBinding.PACKAGE);
 		assertEquals("wrong package binding", "package test404489.bug", binding.toString());
 		
-		// annotations of package qualified type
-		annotations = packageQualifiedType.annotations();
+		// annotations of name qualified type
+		annotations = nameQualifiedType.annotations();
 		assertTrue(annotations.size() == 1);
 		annotation = (Annotation) annotations.get(0);
 		typeBinding = annotation.resolveTypeBinding();
@@ -2559,8 +2557,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		checkSourceRange(simpleName, "NonNull", source);
 		assertNotNull(typeBinding);
 		
-		// name of the package qualified type
-		simpleName = packageQualifiedType.getName();
+		// name of the name qualified type
+		simpleName = nameQualifiedType.getName();
 		checkSourceRange(simpleName, "X", source);
 		typeBinding = simpleName.resolveTypeBinding();
 		assertNotNull(typeBinding);
@@ -3576,4 +3574,51 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		IMethodBinding resolveMethodBinding = lambda.resolveMethodBinding();
 		assertTrue("Should be null", resolveMethodBinding == null); // no NPE, just a null method binding.
 	}
+	/*
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=418979
+	 */
+	public void test418979() throws JavaModelException {
+		String contents =
+				"import java.lang.annotation.*;\n" +
+				"public class X {\n" +
+				"    void foo(Y.@A Z<?> events) {}\n" +
+				"    void foo(Y.@A ZZ events) {}\n" +
+				" }\n" +
+				"class Y {\n" +
+				"	class Z<T> {}\n" +
+				"   class ZZ{}\n" +
+				"}\n" +
+				"@Target (ElementType.TYPE_USE)\n" +
+				"@interface A{}";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		node = getASTNode(compilationUnit, 0);
+		assertEquals("Not a type declaration", ASTNode.TYPE_DECLARATION, node.getNodeType());
+		MethodDeclaration[] methods = ((TypeDeclaration) node).getMethods();
+		assertEquals("Incorrect no of methods", 2, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		assertEquals("Incorrect no of parameters", 1, params.size());
+		SingleVariableDeclaration variable = (SingleVariableDeclaration) params.get(0);
+		Type type = variable.getType();
+		assertTrue(type.isParameterizedType());
+		ParameterizedType parameterizedType = (ParameterizedType) type;
+		checkSourceRange(parameterizedType, "Y.@A Z<?>", contents);
+		type = parameterizedType.getType();
+		assertTrue(type.isNameQualifiedType());
+		NameQualifiedType nameQualifiedType = (NameQualifiedType) type;
+		checkSourceRange(nameQualifiedType, "Y.@A Z", contents);
+
+		method = methods[1];
+		params = method.parameters();
+		assertEquals("Incorrect no of parameters", 1, params.size());
+		variable = (SingleVariableDeclaration) params.get(0);
+		type = variable.getType();
+		assertTrue(type.isNameQualifiedType());
+		nameQualifiedType = (NameQualifiedType) type;
+		checkSourceRange(nameQualifiedType, "Y.@A ZZ", contents);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
index c86504d..996d5b0 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
@@ -453,7 +453,7 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		public boolean match(PackageDeclaration node, Object other) {
 			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
 		}
-		public boolean match(PackageQualifiedType node, Object other) {
+		public boolean match(NameQualifiedType node, Object other) {
 			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
 		}
 		public boolean match(ParameterizedType node, Object other) {
@@ -723,11 +723,11 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 	}
 
 	/** @deprecated using deprecated code */
-	public void testPackageQualifiedType() {
+	public void testNameQualifiedType() {
 		if (this.ast.apiLevel() < AST.JLS8) {
 			return;
 		}
-		Type x1 = this.ast.newPackageQualifiedType(this.ast.newQualifiedName(this.N2, this.N3), this.N1);
+		Type x1 = this.ast.newNameQualifiedType(this.ast.newQualifiedName(this.N2, this.N3), this.N1);
 		basicMatch(x1);
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 989df2a..bd7e275 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -8830,7 +8830,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			ASTNode.DIMENSION,
 			ASTNode.LAMBDA_EXPRESSION,
 			ASTNode.INTERSECTION_TYPE,
-			ASTNode.PACKAGE_QUALIFIED_TYPE,
+			ASTNode.NAME_QUALIFIED_TYPE,
 			ASTNode.CREATION_REFERENCE,
 			ASTNode.EXPRESSION_METHOD_REFERENCE,
 			ASTNode.SUPER_METHOD_REFERENCE,
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
index 59d8b23..8950968 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
@@ -383,11 +383,11 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 			ASTVisitorTest.this.b.append(node.getPrimitiveTypeCode().toString());
 			ASTVisitorTest.this.b.append("tP)"); //$NON-NLS-1$
 		}
-		public boolean visit(PackageQualifiedType node) {
+		public boolean visit(NameQualifiedType node) {
 			ASTVisitorTest.this.b.append("(tPQ"); //$NON-NLS-1$
 			return isVisitingChildren();
 		}
-		public void endVisit(PackageQualifiedType node) {
+		public void endVisit(NameQualifiedType node) {
 			ASTVisitorTest.this.b.append("tPQ)"); //$NON-NLS-1$
 		}
 		public boolean visit(ParameterizedType node) {
@@ -1162,12 +1162,12 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 	}
 
 	/** @deprecated using deprecated code */
-	public void testPackageQualifiedType() {
+	public void testNameQualifiedType() {
 		if (this.ast.apiLevel() < AST.JLS8) {
 			return;
 		}
 		QualifiedName q = this.ast.newQualifiedName(this.N2, this.N3);
-		PackageQualifiedType x1 = this.ast.newPackageQualifiedType(q, this.N1);
+		NameQualifiedType x1 = this.ast.newNameQualifiedType(q, this.N1);
 		TestVisitor v1 = new TestVisitor();
 		this.b.setLength(0);
 		x1.accept(v1);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
index 11756d4..f954428 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -786,7 +786,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 		binding = binding.getComponentType();
 		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
 	}
-	public void _test020() throws Exception {
+	public void test020() throws Exception {
 		String contents = 
 				"public class X  {\n" +
 				"    public static void main(String [] args) {\n" +
@@ -1014,7 +1014,6 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 		Type type = lambda.getType();
 
 		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		verifyAnnotationOnType(((QualifiedType)type).getQualifier(), new String[]{});
 	}
 	public void test027() throws Exception {
 		String contents = 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeAnnotationsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeAnnotationsTest.java
index cea9d59..80fbf14 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeAnnotationsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeAnnotationsTest.java
@@ -849,12 +849,12 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 	}
 
 	/**
-	 * ASTRewriterTests for PackageQualifiedType
+	 * ASTRewriterTests for NameQualifiedType
 	 * @throws Exception
 	 * 
 	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=406469
 	 */
-	public void testPackageQualifiedTypeAnnotations() throws Exception {
+	public void testNameQualifiedTypeAnnotations() throws Exception {
 		IPackageFragment pack1= this.sourceFolder.createPackageFragment("test406469.bug", false, null);
 		String contents = "package test406469.bug;\n" +
 				"import java.lang.annotation.*;\n" +
@@ -899,24 +899,24 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 		TypeDeclaration typeDeclaration= findTypeDeclaration(astRoot, "X");
 		MethodDeclaration methodDeclaration= findMethodDeclaration(typeDeclaration, "foo");
 		{   //replace an annotation.
-			PackageQualifiedType packageQualifiedType = (PackageQualifiedType) methodDeclaration.getReturnType2();
+			NameQualifiedType nameQualifiedType = (NameQualifiedType) methodDeclaration.getReturnType2();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Marker"));
-			rewrite.replace((ASTNode) packageQualifiedType.annotations().get(0), markerAnnotation, null);
+			rewrite.replace((ASTNode) nameQualifiedType.annotations().get(0), markerAnnotation, null);
 
 			// remove an annotation
 			SingleVariableDeclaration param = (SingleVariableDeclaration) methodDeclaration.parameters().get(0);
-			packageQualifiedType = (PackageQualifiedType) param.getType();
-			rewrite.remove((ASTNode) packageQualifiedType.annotations().get(0), null);
+			nameQualifiedType = (NameQualifiedType) param.getType();
+			rewrite.remove((ASTNode) nameQualifiedType.annotations().get(0), null);
 			
 			// insert an annotation after an existing annotation
-			packageQualifiedType = (PackageQualifiedType) methodDeclaration.thrownExceptionTypes().get(0);
+			nameQualifiedType = (NameQualifiedType) methodDeclaration.thrownExceptionTypes().get(0);
 			markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Marker"));
-			rewrite.getListRewrite(packageQualifiedType, PackageQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
+			rewrite.getListRewrite(nameQualifiedType, NameQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
 			
-			/* insert an annotation in a type not converted as a PackageQualifiedType. This would involve
-			 *  creation of a PackageQualifiedType from fields of the existing type.
+			/* insert an annotation in a type not converted as a NameQualifiedType. This would involve
+			 *  creation of a NameQualifiedType from fields of the existing type.
 			 */
 			TryStatement tryStatement = (TryStatement) methodDeclaration.getBody().statements().get(0);
 			VariableDeclarationStatement variableDeclarationStatement = (VariableDeclarationStatement) tryStatement.getBody().statements().get(0);
@@ -927,11 +927,11 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 			SimpleName simpleName = ast.newSimpleName(qualifiedName.getName().getIdentifier());
 			qualifiedName = (QualifiedName) qualifiedName.getQualifier();
 			qualifiedName = ast.newQualifiedName(ast.newName(qualifiedName.getQualifier().toString()), ast.newSimpleName(qualifiedName.getName().toString()));
-			packageQualifiedType = ast.newPackageQualifiedType(qualifiedName, simpleName);
+			nameQualifiedType = ast.newNameQualifiedType(qualifiedName, simpleName);
 			markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Marker"));
-			rewrite.getListRewrite(packageQualifiedType, PackageQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
-			rewrite.replace(classInstanceCreation.getType(), packageQualifiedType, null);
+			rewrite.getListRewrite(nameQualifiedType, NameQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
+			rewrite.replace(classInstanceCreation.getType(), nameQualifiedType, null);
 		}
 		String preview= evaluateRewrite(cu, rewrite);
 		String contentsmodified = "package test406469.bug;\n" +
@@ -1014,22 +1014,22 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 
 		{   //replace an annotation.
 			VariableDeclarationStatement variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
-			QualifiedType qualifiedType = (QualifiedType) variableDeclarationStatement.getType();
+			NameQualifiedType nameQualifiedType = (NameQualifiedType) variableDeclarationStatement.getType();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("NewMarker"));
-			rewrite.replace((ASTNode) qualifiedType.annotations().get(0), markerAnnotation, null);
+			rewrite.replace((ASTNode) nameQualifiedType.annotations().get(0), markerAnnotation, null);
 			
 			// remove an annotation
 			variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
-			qualifiedType = (QualifiedType) variableDeclarationStatement.getType();
-			rewrite.remove((ASTNode) qualifiedType.annotations().get(0), null);
+			nameQualifiedType = (NameQualifiedType) variableDeclarationStatement.getType();
+			rewrite.remove((ASTNode) nameQualifiedType.annotations().get(0), null);
 			
 			// insert an annotation after an existing annotation
 			variableDeclarationStatement = (VariableDeclarationStatement) statements.get(sCount++);
-			qualifiedType = (QualifiedType) variableDeclarationStatement.getType();
+			nameQualifiedType = (NameQualifiedType) variableDeclarationStatement.getType();
 			markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("NewMarker"));
-			rewrite.getListRewrite(qualifiedType, QualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
+			rewrite.getListRewrite(nameQualifiedType, NameQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
 			
 			/* insert an annotation in a type not converted as QualifiedType. This would involve
 			 *  creation of a QualifiedType from fields of the existing type.
@@ -1040,12 +1040,12 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 			SimpleName simpleName = ast.newSimpleName(qualifiedName.getName().getIdentifier());
 			qualifiedName = (QualifiedName) qualifiedName.getQualifier();
 			qualifiedName = ast.newQualifiedName(ast.newName(qualifiedName.getQualifier().toString()), ast.newSimpleName(qualifiedName.getName().toString()));
-			qualifiedType = ast.newQualifiedType(ast.newSimpleType(qualifiedName), simpleName);
+			nameQualifiedType = ast.newNameQualifiedType(qualifiedName, simpleName);
 			
 			markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("NewMarker"));
-			rewrite.getListRewrite(qualifiedType, QualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
-			rewrite.replace(variableDeclarationStatement.getType(), qualifiedType, null);
+			rewrite.getListRewrite(nameQualifiedType, NameQualifiedType.ANNOTATIONS_PROPERTY).insertLast(markerAnnotation, null);
+			rewrite.replace(variableDeclarationStatement.getType(), nameQualifiedType, null);
 		}
 		String preview= evaluateRewrite(cu, rewrite);
 		String contentsmodified = "package test0002;\n" +
@@ -1056,7 +1056,7 @@ public class ASTRewritingTypeAnnotationsTest extends ASTRewritingTest {
 				 "		Outer.@NewMarker Inner first = outer.new Inner();\n" +
 				 "		Outer.Inner second = outer.new Inner() ;\n" +
 				 "		Outer.Inner.@Marker1 @NewMarker Deeper deeper = second.new Deeper();\n" +
-				 "		Outer. Inner.@NewMarker Deeper deeper2 =  second.new Deeper();\n" +
+				 "		Outer.Inner.@NewMarker Deeper deeper2 =  second.new Deeper();\n" +
 				 "	}\n" + "}\n" + "class Outer {\n" +
 				 "	public class Inner {\n" + 
 				 "		public class Deeper {\n" +
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index f0ad99a..d9c4c23 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -992,7 +992,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 				case Binding.LOCAL:
 					LocalVariableBinding local = (LocalVariableBinding) recipient;
 					TypeReference typeRef = local.declaration.type;
-					if (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on package qualified types.
+					if (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on name qualified types.
 						local.declaration.bits |= HasTypeAnnotations;
 						typeRef.bits |= HasTypeAnnotations;
 						local.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, typeRef, local.type);
@@ -1002,7 +1002,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 					FieldBinding field = (FieldBinding) recipient;
 					SourceTypeBinding sourceType = (SourceTypeBinding) field.declaringClass;
 					FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);
-					if (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.
+					if (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on name qualified types.
 						fieldDeclaration.bits |= HasTypeAnnotations;
 						fieldDeclaration.type.bits |= HasTypeAnnotations;
 						field.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, fieldDeclaration.type, field.type);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index f3c3083..a8cee50 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -2038,10 +2038,10 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented package qualified type node with
+	 * Creates and returns a new unparented name qualified type node with
 	 * the given qualifier and name.
 	 *
-	 * @param qualifier the package qualifier type node
+	 * @param qualifier the name qualifier name node
 	 * @param name the simple name being qualified
 	 * @return a new unparented qualified type node
 	 * @exception IllegalArgumentException if:
@@ -2053,8 +2053,8 @@ public final class AST {
 	 * a JLS2, JLS3 and JLS4 AST
 	 * @since 3.9 BETA_JAVA8
 	 */
-	public PackageQualifiedType newPackageQualifiedType(Name qualifier, SimpleName name) {
-		PackageQualifiedType result = new PackageQualifiedType(this);
+	public NameQualifiedType newNameQualifiedType(Name qualifier, SimpleName name) {
+		NameQualifiedType result = new NameQualifiedType(this);
 		result.setQualifier(qualifier);
 		result.setName(name);
 		return result;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 6b67728..5eefd89 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -17,7 +17,6 @@
 
 package org.eclipse.jdt.core.dom;
 
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -61,8 +60,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
-import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
-import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
@@ -3650,40 +3647,23 @@ class ASTConverter {
 					}
 					break;
 					default :
+						boolean isTypeArgumentBased = false;
 						for (int i = 0; i < lenth; ++i) {
 							if (typeArguments != null && typeArguments[i] != null) {
 								firstTypeIndex = i;
+								isTypeArgumentBased = true;
 								break;
 							}
 							if (typeAnnotations != null && typeAnnotations[i] != null) {
 								firstTypeIndex = i;
+								isTypeArgumentBased = false;
 								break;
 							}
 						}						
+						int start = (int) (positions[0] >>> 32);
+						int end = (int) positions[0];
 						
-						Name name = null;						
-						if (firstTypeIndex == 0) {
-							final SimpleName simpleName = new SimpleName(this.ast);
-							simpleName.setIdentifier(new String(tokens[0]));
-							recordPendingNameScopeResolution(simpleName);
-							int start = (int) (positions[0] >>> 32);
-							int end = (int) positions[0];
-							simpleName.setSourceRange(start, end - start + 1);
-							simpleName.index = 1;
-							name = simpleName;
-							if (this.resolveBindings) {
-								recordNodes(simpleName, typeReference);
-							}
-						} else {
-							name = this.setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex, typeReference);
-						}
-						
-						SimpleType simpleType = new SimpleType(this.ast);
-						simpleType.setName(name);
-						setSourceRangeAnnotationsAndRecordNodes(typeReference, simpleType, positions, typeAnnotations, firstTypeIndex, 0, firstTypeIndex);
-						int start = simpleType.getStartPosition();
-						int end = (int)positions[firstTypeIndex];
-						Type currentType = simpleType;						
+						Type currentType = createBaseType(typeReference, positions, typeAnnotations, tokens, lenth, firstTypeIndex, isTypeArgumentBased);
 						int indexOfEnclosingType = 1;
 						if (typeArguments != null && (arguments = typeArguments[firstTypeIndex]) != null) {
 							int arglen = arguments.length;
@@ -3700,6 +3680,8 @@ class ASTConverter {
 							}
 							end = type2 != null ? type2.getStartPosition() + type2.getLength() - 1 : end;
 							end = retrieveClosingAngleBracketPosition(end + 1);
+							int baseStart = currentType.getStartPosition();
+							start = start <= baseStart ? start : baseStart;
 							parameterizedType.setSourceRange(start, end - start + 1);
 							currentType = parameterizedType;
 						}
@@ -3772,46 +3754,10 @@ class ASTConverter {
 						}
 					}
 				}  
-				Name name = null;
-				Type currentType = null;
-				if (firstTypeIndex == lenth) {//Just a QualifiedName
-					name = setQualifiedNameNameAndSourceRanges(tokens, positions, lenth - 1, typeReference);
-					currentType = createSimpleType(name, typeReference, positions, 0, lenth - 1);
-				} else {
-					if (firstTypeIndex <= 1) {
-						name = createSimpleName(typeReference, positions, tokens, 0 );
-						firstTypeIndex = 1;
-					} else {
-						name = setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex - 1, typeReference);
-					}						
-
-					org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding = typeReference.resolvedType;
-					boolean createPackageQualifiedType = false;
-					if (typeBinding instanceof ReferenceBinding) {
-						ReferenceBinding referenceBinding = (ReferenceBinding)typeBinding;			
-						PackageBinding packageBinding = referenceBinding.getPackage();
-						if (packageBinding != null && Arrays.equals(name.toString().toCharArray(), packageBinding.readableName())) {
-							createPackageQualifiedType = true;
-						}
-					}
-					
-					if (createPackageQualifiedType && this.ast.apiLevel >= AST.JLS8) {
-						PackageQualifiedType packageQualifiedType = new PackageQualifiedType(this.ast);
-						packageQualifiedType.setQualifier(name);
-						packageQualifiedType.setName(createSimpleName(typeReference, positions, tokens, firstTypeIndex));
-						setSourceRangeAnnotationsAndRecordNodes(typeReference, packageQualifiedType, positions, typeAnnotations, firstTypeIndex, 0, firstTypeIndex);
-						currentType = packageQualifiedType;																	
-					} else {
-						SimpleType simpleType = this.ast.newSimpleType(name);	
-						setSourceRangeAnnotationsAndRecordNodes(typeReference, simpleType, positions, typeAnnotations, 0, 0, name.index > 0 ? name.index - 1 : 0);
-						currentType = createQualifiedType(typeReference, positions,  typeAnnotations, tokens, firstTypeIndex, simpleType);
-						if (createPackageQualifiedType) 
-							currentType.setFlags(currentType.getFlags() | ASTNode.MALFORMED);
-					}
-					for (int i = firstTypeIndex + 1; i < lenth; ++i) {
-						currentType = createQualifiedType(typeReference, positions,  typeAnnotations, tokens, i, currentType);
-					}					
-				}
+				Type currentType = createBaseType(typeReference, positions, typeAnnotations, tokens, lenth, firstTypeIndex, false);
+				for (int i = firstTypeIndex + 1; i < lenth; ++i) {
+					currentType = createQualifiedType(typeReference, positions,  typeAnnotations, tokens, i, currentType);
+				}					
 				type = currentType;
 			} else if (typeReference instanceof UnionTypeReference){
 				TypeReference[] typeReferences = ((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference) typeReference).typeReferences;
@@ -3907,6 +3853,55 @@ class ASTConverter {
 		return type;
 	}
 
+	private Type createBaseType(TypeReference typeReference, long[] positions,
+			org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations, char[][] tokens, int lenth,
+			int firstTypeIndex, boolean isTypeArgumentBased) {
+		Type currentType;
+		Name name = null;
+		if (firstTypeIndex == 0) {
+			name = createSimpleName(typeReference, positions, tokens, 0 );
+			currentType = createSimpleType(name, typeReference, positions, 0, 0);
+			setSourceRangeAnnotationsAndRecordNodes(typeReference, (SimpleType) currentType, positions, typeAnnotations, 0, 0, name.index > 0 ? name.index - 1 : 0);
+		} else if (firstTypeIndex == lenth) {//Just a QualifiedName
+			name = setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex - 1, typeReference);
+			currentType = createSimpleType(name, typeReference, positions, 0, firstTypeIndex - 1);
+		} else if (isTypeArgumentBased && (typeAnnotations == null || typeAnnotations[firstTypeIndex] == null)) {
+			name = setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex, typeReference);
+			currentType = createSimpleType(name, typeReference, positions, 0, firstTypeIndex);
+		} else {
+			if (firstTypeIndex == 1) {
+				name = createSimpleName(typeReference, positions, tokens, 0 );
+			} else {
+				name = setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex - 1, typeReference);
+			}						
+
+/*			org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding = typeReference.resolvedType;
+			boolean createPackageQualifiedType = false;
+			if (typeBinding instanceof ReferenceBinding) {
+				ReferenceBinding referenceBinding = (ReferenceBinding)typeBinding;			
+				PackageBinding packageBinding = referenceBinding.getPackage();
+				if (packageBinding != null && Arrays.equals(name.toString().toCharArray(), packageBinding.readableName())) {
+					createPackageQualifiedType = true;
+				}
+			}
+*/			boolean createNameQualifiedType = typeAnnotations != null && typeAnnotations[firstTypeIndex] != null;
+			if (createNameQualifiedType && this.ast.apiLevel >= AST.JLS8) {
+				NameQualifiedType nameQualifiedType = new NameQualifiedType(this.ast);
+				nameQualifiedType.setQualifier(name);
+				nameQualifiedType.setName(createSimpleName(typeReference, positions, tokens, firstTypeIndex));
+				setSourceRangeAnnotationsAndRecordNodes(typeReference, nameQualifiedType, positions, typeAnnotations, firstTypeIndex, 0, firstTypeIndex);
+				currentType = nameQualifiedType;																	
+			} else {
+				SimpleType simpleType = this.ast.newSimpleType(name);	
+				setSourceRangeAnnotationsAndRecordNodes(typeReference, simpleType, positions, typeAnnotations, 0, 0, name.index > 0 ? name.index - 1 : 0);
+				currentType = createQualifiedType(typeReference, positions,  typeAnnotations, tokens, firstTypeIndex, simpleType);
+				if (createNameQualifiedType) 
+					currentType.setFlags(currentType.getFlags() | ASTNode.MALFORMED);
+			}
+		}
+		return currentType;
+	}
+
 	private QualifiedType createQualifiedType(TypeReference typeReference, long[] positions,
 			org.eclipse.jdt.internal.compiler.ast.Annotation[][] typeAnnotations, char[][] tokens, int index,
 			Type qualifier) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 7f19254..a281528 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -1556,6 +1556,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public boolean match(NameQualifiedType node, Object other) {
+		if (!(other instanceof NameQualifiedType)) {
+			return false;
+		}
+		NameQualifiedType o = (NameQualifiedType) other;
+		return safeSubtreeMatch(node.getQualifier(), o.getQualifier())
+				&& safeSubtreeListMatch(node.annotations(), o.annotations())
+				&& safeSubtreeMatch(node.getName(), o.getName());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 * @since 3.1
 	 */
 	public boolean match(NormalAnnotation node, Object other) {
@@ -1653,31 +1678,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.9 BETA_JAVA8
-	 */
-	public boolean match(PackageQualifiedType node, Object other) {
-		if (!(other instanceof PackageQualifiedType)) {
-			return false;
-		}
-		PackageQualifiedType o = (PackageQualifiedType) other;
-		return safeSubtreeMatch(node.getQualifier(), o.getQualifier())
-				&& safeSubtreeListMatch(node.annotations(), o.annotations())
-				&& safeSubtreeMatch(node.getName(), o.getName());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 * @since 3.1
 	 */
 	public boolean match(ParameterizedType node, Object other) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 644042e..2c770bb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -861,11 +861,11 @@ public abstract class ASTNode {
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>QualifiedType</code>.
-	 * @see QualifiedType
+	 * <code>NameQualifiedType</code>.
+	 * @see NameQualifiedType
 	 * @since 3.9 BETA_JAV8
 	 */
-	public static final int PACKAGE_QUALIFIED_TYPE = 88;
+	public static final int NAME_QUALIFIED_TYPE = 88;
 
 	/**
 	 * Node type constant indicating a node of type
@@ -1021,8 +1021,8 @@ public abstract class ASTNode {
 				return NumberLiteral.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
-			case PACKAGE_QUALIFIED_TYPE :
-				return PackageQualifiedType.class;
+			case NAME_QUALIFIED_TYPE :
+				return NameQualifiedType.class;
 			case PARAMETERIZED_TYPE :
 				return ParameterizedType.class;
 			case PARENTHESIZED_EXPRESSION :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index a23f1d0..b4326dc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -1045,7 +1045,6 @@ public abstract class ASTVisitor {
 		return true;
 	}
 
-
 	/**
 	 * Visits the given type-specific AST node.
 	 * <p>
@@ -1057,9 +1056,9 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.1
+	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean visit(NormalAnnotation node) {
+	public boolean visit(NameQualifiedType node) {
 		return true;
 	}
 
@@ -1074,8 +1073,9 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.1
 	 */
-	public boolean visit(NullLiteral node) {
+	public boolean visit(ParameterizedType node) {
 		return true;
 	}
 
@@ -1090,8 +1090,9 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.1
 	 */
-	public boolean visit(NumberLiteral node) {
+	public boolean visit(NormalAnnotation node) {
 		return true;
 	}
 
@@ -1107,11 +1108,10 @@ public abstract class ASTVisitor {
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
 	 */
-	public boolean visit(PackageDeclaration node) {
+	public boolean visit(NullLiteral node) {
 		return true;
 	}
 
-
 	/**
 	 * Visits the given type-specific AST node.
 	 * <p>
@@ -1123,9 +1123,8 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean visit(PackageQualifiedType node) {
+	public boolean visit(NumberLiteral node) {
 		return true;
 	}
 
@@ -1140,9 +1139,8 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.1
 	 */
-	public boolean visit(ParameterizedType node) {
+	public boolean visit(PackageDeclaration node) {
 		return true;
 	}
 
@@ -2354,9 +2352,9 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.1
+	 * @since 3.9 BETA_JAVA8
 	 */
-	public void endVisit(NormalAnnotation node) {
+	public void endVisit(NameQualifiedType node) {
 		// default implementation: do nothing
 	}
 
@@ -2367,8 +2365,9 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.1
 	 */
-	public void endVisit(NullLiteral node) {
+	public void endVisit(NormalAnnotation node) {
 		// default implementation: do nothing
 	}
 
@@ -2380,7 +2379,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(NumberLiteral node) {
+	public void endVisit(NullLiteral node) {
 		// default implementation: do nothing
 	}
 
@@ -2392,7 +2391,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(PackageDeclaration node) {
+	public void endVisit(NumberLiteral node) {
 		// default implementation: do nothing
 	}
 
@@ -2403,9 +2402,8 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.9 BETA_JAVA8
 	 */
-	public void endVisit(PackageQualifiedType node) {
+	public void endVisit(PackageDeclaration node) {
 		// default implementation: do nothing
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index 1594d42..a0aafa2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -195,7 +199,7 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(PackageDeclaration node) {
 		endVisitNode(node);
 	}
-	public void endVisit(PackageQualifiedType node) {
+	public void endVisit(NameQualifiedType node) {
 		endVisitNode(node);
 	}
 	public void endVisit(ParameterizedType node) {
@@ -482,7 +486,7 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(PackageDeclaration node) {
 		return visitNode(node);
 	}
-	public boolean visit(PackageQualifiedType node) {
+	public boolean visit(NameQualifiedType node) {
 		return visitNode(node);
 	}
 	public boolean visit(ParameterizedType node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 062758c..c0f823f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -1637,8 +1637,8 @@ class DefaultBindingResolver extends BindingResolver {
 					return resolveTypeBindingForName(((SimpleType)type).getName());
 				} else if (type instanceof QualifiedType) {
 					return resolveTypeBindingForName(((QualifiedType)type).getName());
-				} else if (type instanceof PackageQualifiedType){
-					return resolveTypeBindingForName(((PackageQualifiedType)type).getName());
+				} else if (type instanceof NameQualifiedType){
+					return resolveTypeBindingForName(((NameQualifiedType)type).getName());
 				}
 				TypeReference typeReference = (TypeReference) node;
 				binding = typeReference.resolvedType;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
new file mode 100644
index 0000000..bb871ef
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
@@ -0,0 +1,294 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Node for a name qualified type (added in JLS8 API).
+ * 
+ * <pre>
+ * NameQualifiedType:
+ *    Name <b>.</b> { Annotation } SimpleName
+ * </pre>
+ * 
+ * <p>
+ * Note that if no annotation is present, then a name-qualified type can
+ * also be represented by a SimpleType or a QualifiedType, see the discussion
+ * in {@link QualifiedType}.
+ * </p>
+ *
+ * @see SimpleType
+ * @see QualifiedType
+ * 
+ * @since 3.9 BETA_JAVA8
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+public class NameQualifiedType extends AnnotatableType {
+
+	/**
+	 * The "qualifier" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor QUALIFIER_PROPERTY =
+		new ChildPropertyDescriptor(NameQualifiedType.class, "qualifier", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			internalAnnotationsPropertyFactory(NameQualifiedType.class);
+	
+	/**
+	 * The "name" structural property of this node type (child type: {@link SimpleName}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(NameQualifiedType.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS;
+
+	static {
+		List propertyList = new ArrayList(4);
+		createPropertyList(NameQualifiedType.class, propertyList);
+		addProperty(QUALIFIER_PROPERTY, propertyList);
+		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS;
+	}
+
+	/**
+	 * The qualifier node; lazily initialized; defaults to 
+	 * an unspecified, but legal, simple name.
+	 */
+	private Name qualifier = null;
+
+	/**
+	 * The name being qualified; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private SimpleName name = null;
+
+	/**
+	 * Creates a new unparented node for a name qualified type owned by the
+	 * given AST. By default, an unspecified, but legal, qualifier and name.
+	 * <p>
+	 * N.B. This constructor is package-private.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	NameQualifiedType(AST ast) {
+		super(ast);
+	    unsupportedIn2_3_4();
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 */
+	ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == ANNOTATIONS_PROPERTY) {
+			return annotations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+	
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == QUALIFIER_PROPERTY) {
+			if (get) {
+				return getQualifier();
+			} else {
+				setQualifier((Name) child);
+				return null;
+			}
+		}
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((SimpleName) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	final int getNodeType0() {
+		return NAME_QUALIFIED_TYPE;
+	}
+
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	ASTNode clone0(AST target) {
+		NameQualifiedType result = new NameQualifiedType(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setQualifier((Name) ((ASTNode) getQualifier()).clone(target));
+		result.annotations().addAll(ASTNode.copySubtrees(target, annotations()));
+		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
+		return result;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			// visit children in normal left to right reading order
+			acceptChild(visitor, getQualifier());
+			acceptChildren(visitor, this.annotations);
+			acceptChild(visitor, getName());
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * Returns the qualifier of this name qualified type.
+	 *
+	 * @return the qualifier of this name qualified type
+	 */
+	public Name getQualifier() {
+		if (this.qualifier == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.qualifier == null) {
+					preLazyInit();
+					this.qualifier = new SimpleName(this.ast);
+					postLazyInit(this.qualifier, QUALIFIER_PROPERTY);
+				}
+			}
+		}
+		return this.qualifier;
+	}
+
+	/**
+	 * Sets the qualifier of this name qualified type to the given name.
+	 *
+	 * @param name the new qualifier of this name qualified type
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setQualifier(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.qualifier;
+		preReplaceChild(oldChild, name, QUALIFIER_PROPERTY);
+		this.qualifier = name;
+		postReplaceChild(oldChild, name, QUALIFIER_PROPERTY);
+	}
+
+	/**
+	 * Returns the name part of this name qualified type.
+	 *
+	 * @return the name being qualified
+	 */
+	public SimpleName getName() {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name = new SimpleName(this.ast);
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the name part of this name qualified type to the given simple name.
+	 *
+	 * @param name the identifier of this qualified name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(SimpleName name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int memSize() {
+		// treat Code as free
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int treeSize() {
+		return
+			memSize()
+			+ (this.qualifier == null ? 0 : getQualifier().treeSize())
+			+ (this.annotations == null ? 0 : this.annotations.listSize())
+			+ (this.name == null ? 0 : getName().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PackageQualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PackageQualifiedType.java
deleted file mode 100644
index b3154b4..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PackageQualifiedType.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2003, 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Node for a package qualified type (added in JLS8 API).
- * 
- * <pre>
- * PackageQualifiedType:
- *    Name <b>.</b> { Annotation } SimpleName
- * </pre>
- * 
- * <p>
- * Note that if no annotation is present, then a package-qualified type can
- * also be represented by a SimpleType or a QualifiedType, see the discussion
- * in {@link QualifiedType}.
- * </p>
- *
- * @see SimpleType
- * @see QualifiedType
- * 
- * @since 3.9 BETA_JAVA8
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-public class PackageQualifiedType extends AnnotatableType {
-
-	/**
-	 * The "qualifier" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor QUALIFIER_PROPERTY =
-		new ChildPropertyDescriptor(PackageQualifiedType.class, "qualifier", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-			internalAnnotationsPropertyFactory(PackageQualifiedType.class);
-	
-	/**
-	 * The "name" structural property of this node type (child type: {@link SimpleName}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(PackageQualifiedType.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-	
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS;
-
-	static {
-		List propertyList = new ArrayList(4);
-		createPropertyList(PackageQualifiedType.class, propertyList);
-		addProperty(QUALIFIER_PROPERTY, propertyList);
-		addProperty(ANNOTATIONS_PROPERTY, propertyList);
-		addProperty(NAME_PROPERTY, propertyList);
-		PROPERTY_DESCRIPTORS = reapPropertyList(propertyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS;
-	}
-
-	/**
-	 * The qualifier node; lazily initialized; defaults to 
-	 * an unspecified, but legal, simple name.
-	 */
-	private Name qualifier = null;
-
-	/**
-	 * The name being qualified; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private SimpleName name = null;
-
-	/**
-	 * Creates a new unparented node for a package qualified type owned by the
-	 * given AST. By default, an unspecified, but legal, qualifier and name.
-	 * <p>
-	 * N.B. This constructor is package-private.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	PackageQualifiedType(AST ast) {
-		super(ast);
-	    unsupportedIn2_3_4();
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on AnnotatableType.
-	 */
-	ChildListPropertyDescriptor internalAnnotationsProperty() {
-		return ANNOTATIONS_PROPERTY;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == ANNOTATIONS_PROPERTY) {
-			return annotations();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-	
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == QUALIFIER_PROPERTY) {
-			if (get) {
-				return getQualifier();
-			} else {
-				setQualifier((Name) child);
-				return null;
-			}
-		}
-		if (property == NAME_PROPERTY) {
-			if (get) {
-				return getName();
-			} else {
-				setName((SimpleName) child);
-				return null;
-			}
-		}
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	final int getNodeType0() {
-		return PACKAGE_QUALIFIED_TYPE;
-	}
-
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	ASTNode clone0(AST target) {
-		PackageQualifiedType result = new PackageQualifiedType(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setQualifier((Name) ((ASTNode) getQualifier()).clone(target));
-		result.annotations().addAll(ASTNode.copySubtrees(target, annotations()));
-		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
-		return result;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			// visit children in normal left to right reading order
-			acceptChild(visitor, getQualifier());
-			acceptChildren(visitor, this.annotations);
-			acceptChild(visitor, getName());
-		}
-		visitor.endVisit(this);
-	}
-
-	/**
-	 * Returns the qualifier of this package qualified type.
-	 *
-	 * @return the qualifier of this package qualified type
-	 */
-	public Name getQualifier() {
-		if (this.qualifier == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.qualifier == null) {
-					preLazyInit();
-					this.qualifier = new SimpleName(this.ast);
-					postLazyInit(this.qualifier, QUALIFIER_PROPERTY);
-				}
-			}
-		}
-		return this.qualifier;
-	}
-
-	/**
-	 * Sets the qualifier of this package qualified type to the given name.
-	 *
-	 * @param name the new qualifier of this package qualified type
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setQualifier(Name name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.qualifier;
-		preReplaceChild(oldChild, name, QUALIFIER_PROPERTY);
-		this.qualifier = name;
-		postReplaceChild(oldChild, name, QUALIFIER_PROPERTY);
-	}
-
-	/**
-	 * Returns the name part of this package qualified type.
-	 *
-	 * @return the name being qualified
-	 */
-	public SimpleName getName() {
-		if (this.name == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.name == null) {
-					preLazyInit();
-					this.name = new SimpleName(this.ast);
-					postLazyInit(this.name, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.name;
-	}
-
-	/**
-	 * Sets the name part of this package qualified type to the given simple name.
-	 *
-	 * @param name the identifier of this qualified name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setName(SimpleName name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.name;
-		preReplaceChild(oldChild, name, NAME_PROPERTY);
-		this.name = name;
-		postReplaceChild(oldChild, name, NAME_PROPERTY);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	int memSize() {
-		// treat Code as free
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	int treeSize() {
-		return
-			memSize()
-			+ (this.qualifier == null ? 0 : getQualifier().treeSize())
-			+ (this.annotations == null ? 0 : this.annotations.listSize())
-			+ (this.name == null ? 0 : getName().treeSize());
-	}
-
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
index 43d305c..04b5a0c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
@@ -29,30 +29,43 @@ import java.util.List;
  * Not all node arrangements will represent legal Java constructs. In particular,
  * it is nonsense if the type is an array type or primitive type. The normal use
  * is when the type is a ParameterizedType, an annotated QualifiedType, or a
- * PackageQualifiedType.
+ * NameQualifiedType.
  * </p>
  * <p>
  * A "."-separated type like "A.B" can be represented in three ways:
  * <pre>
- * 1.    SimpleType       | 2.   QualifiedType     | 3. PackageQualifiedType
- *     QualifiedName      | SimpleType  SimpleName |   SimpleName  SimpleName
- * SimpleName  SimpleName | SimpleName     "B"     |       "A"        "B"
- *     "A"        "B"     |     "A"                |
+ * 1.    SimpleType       | 2.   NameQualifiedType | 3. QualifiedType
+ *     QualifiedName      | SimpleName  SimpleName |   SimpleType  SimpleName
+ * SimpleName  SimpleName |     "A"        "B"     |   SimpleName     "B"
+ *     "A"        "B"     |                        |       "A"
  * </pre>
  * <p>
  * The ASTParser creates the SimpleType form (wrapping a name) if possible. The
  * SimpleType form doesn't support any embedded Annotations nor ParameterizedTypes.
- * The QualifiedType form is only available since JLS3 and the
- * PackageQualifiedType form only since JLS8.
+ * The NameQualifiedType form is only available since JLS8 and the
+ * QualifiedType form only since JLS3. The NameQualifiedType form allows
+ * Annotations on the last SimpleName. The QualifiedType form cannot be used if
+ * the qualifier represents a package name.
  * </p>
  * <p>
- * The QualifiedType form cannot be used if the qualifier resolves to a package
- * name, e.g. for "pack.@A C". In that case, the PackageQualifiedType form is used.
- * If bindings are not resolved, then only the QualifiedType form is used.
+ * The part before the last "." is called the <em>qualifier</em> of a type. If
+ * the name after the last "." has annotations or if the qualifier is not a
+ * (possibly qualified) name, then the ASTParser creates either a
+ * NameQualifiedType or a QualifiedType:
  * </p>
+ * <ul>
+ * <li>
+ * If the qualifier is a (possibly qualified) name, then a NameQualifiedType is
+ * created.
+ * </li>
+ * <li>
+ * Otherwise, a QualifiedType is created and its qualifier is built using the
+ * same rules.
+ * </li>
+ * </ul>
  * 
  * @see SimpleType
- * @see PackageQualifiedType
+ * @see NameQualifiedType
  * 
  * @since 3.1
  * @noinstantiate This class is not intended to be instantiated by clients.
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
index ff9e87a..9068a19 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
@@ -682,9 +682,9 @@ class RecoveredTypeBinding implements ITypeBinding {
 			case ASTNode.QUALIFIED_TYPE :
 				QualifiedType qualifiedType = (QualifiedType) type;
 				return qualifiedType.getName().getIdentifier();
-			case ASTNode.PACKAGE_QUALIFIED_TYPE :
-				PackageQualifiedType packageQualifiedType = (PackageQualifiedType) type;
-				return packageQualifiedType.getName().getIdentifier();
+			case ASTNode.NAME_QUALIFIED_TYPE :
+				NameQualifiedType nameQualifiedType = (NameQualifiedType) type;
+				return nameQualifiedType.getName().getIdentifier();
 			case ASTNode.SIMPLE_TYPE :
 				SimpleType simpleType = (SimpleType) type;
 				Name name = simpleType.getName();
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
index 91818f4..08ab66c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
@@ -31,10 +31,10 @@ import java.util.List;
  *
  * In JLS8 and later, the SimpleType may have optional annotations.
  * If annotations are present, then the name must be a {@link SimpleName}.
- * Annotated qualified names are represented as {@link QualifiedType} or {@link PackageQualifiedType}.
+ * Annotated qualified names are represented as {@link QualifiedType} or {@link NameQualifiedType}.
  * 
  * @see QualifiedType
- * @see PackageQualifiedType
+ * @see NameQualifiedType
  * 
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
index 8d2685b..4095474 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
@@ -32,7 +32,7 @@ package org.eclipse.jdt.core.dom;
  *       PrimitiveType
  *       SimpleType
  *       QualifiedType
- *       PackageQualifiedType
+ *       NameQualifiedType
  *       WildcardType
  *    ArrayType
  *    ParameterizedType
@@ -55,7 +55,7 @@ package org.eclipse.jdt.core.dom;
  *    { Annotation } TypeName
  * {@link QualifiedType}:
  *    Type <b>.</b> {Annotation} SimpleName
- * {@link PackageQualifiedType}:
+ * {@link NameQualifiedType}:
  *    Name <b>.</b> { Annotation } SimpleName
  * {@link WildcardType}:
  *    { Annotation } <b>?</b> [ ( <b>extends</b> | <b>super</b>) Type ]
@@ -118,15 +118,15 @@ public abstract class Type extends ASTNode {
 	}
 
 	/**
-	 * Returns whether this type is a package qualified type
-	 * ({@link PackageQualifiedType}).
+	 * Returns whether this type is a name qualified type
+	 * ({@link NameQualifiedType}).
 	 *
-	 * @return <code>true</code> if this is a package qualified type, and
+	 * @return <code>true</code> if this is a name qualified type, and
 	 *    <code>false</code> otherwise
 	 * @since 3.9 BETA_JAVA8
 	 */
-	public final boolean isPackageQualifiedType() {
-		return (this instanceof PackageQualifiedType);
+	public final boolean isNameQualifiedType() {
+		return (this instanceof NameQualifiedType);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index c314666..c521ad6 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -1259,10 +1259,10 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(PackageQualifiedType)
+	 * @see ASTVisitor#visit(NameQualifiedType)
 	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean visit(PackageQualifiedType node) {
+	public boolean visit(NameQualifiedType node) {
 		node.getQualifier().accept(this);
 		this.buffer.append('.');
 		visitTypeAnnotations(node);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 749c2f2..47da4ed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -4139,20 +4139,20 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 		return false;
 	}
 	/* (non-Javadoc)
-	 * @see org.eclipse.jdt.core.dom.ASTVisitor#visit(org.eclipse.jdt.core.dom.PackageQualifiedType)
+	 * @see org.eclipse.jdt.core.dom.ASTVisitor#visit(org.eclipse.jdt.core.dom.NameQualifiedType)
 	 */
-	public boolean visit(PackageQualifiedType node) {
+	public boolean visit(NameQualifiedType node) {
 		if (!hasChildrenChanges(node)) {
 			return doVisitUnchangedChildren(node);
 		}
-		int pos = rewriteRequiredNode(node, PackageQualifiedType.QUALIFIER_PROPERTY);
+		int pos = rewriteRequiredNode(node, NameQualifiedType.QUALIFIER_PROPERTY);
 		try {
 			pos = getScanner().getTokenEndOffset(TerminalTokens.TokenNameDOT, pos);
-			rewriteTypeAnnotations(node, PackageQualifiedType.ANNOTATIONS_PROPERTY, pos);
+			rewriteTypeAnnotations(node, NameQualifiedType.ANNOTATIONS_PROPERTY, pos);
 		} catch (CoreException e) {
 			handleException(e);
 		}
-		rewriteRequiredNode(node, PackageQualifiedType.NAME_PROPERTY);
+		rewriteRequiredNode(node, NameQualifiedType.NAME_PROPERTY);
 		return false;
 	}
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 09fda33..4673595 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -1443,16 +1443,16 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(PackageQualifiedType)
+	 * @see ASTVisitor#visit(NameQualifiedType)
 	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean visit(PackageQualifiedType node) {
-		getChildNode(node, PackageQualifiedType.QUALIFIER_PROPERTY).accept(this);
+	public boolean visit(NameQualifiedType node) {
+		getChildNode(node, NameQualifiedType.QUALIFIER_PROPERTY).accept(this);
 		this.result.append('.');
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			visitList(node, PackageQualifiedType.ANNOTATIONS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));
+			visitList(node, NameQualifiedType.ANNOTATIONS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));
 		}
-		getChildNode(node, PackageQualifiedType.NAME_PROPERTY).accept(this);
+		getChildNode(node, NameQualifiedType.NAME_PROPERTY).accept(this);
 		return false;
 	}
 
commit 23f99b8ee2d416cf9b0622bf3ddf2ea4961ce8f4
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Jan 6 14:33:07 2014 +0100

    Bug 418979 [1.8][dom ast] Bad source ranges for annotated
    QualifiedType as type of ParameterizedType
    
    fixed order of NameQualifiedType-related methods

23	23	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
8	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
12	12	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index a8cee50..7fb1352 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1974,6 +1974,29 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented name qualified type node with
+	 * the given qualifier and name.
+	 *
+	 * @param qualifier the name qualifier name node
+	 * @param name the simple name being qualified
+	 * @return a new unparented qualified type node
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS2, JLS3 and JLS4 AST
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public NameQualifiedType newNameQualifiedType(Name qualifier, SimpleName name) {
+		NameQualifiedType result = new NameQualifiedType(this);
+		result.setQualifier(qualifier);
+		result.setName(name);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented normal annotation node with
 	 * an unspecified type name and an empty list of member value
 	 * pairs.
@@ -2038,29 +2061,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented name qualified type node with
-	 * the given qualifier and name.
-	 *
-	 * @param qualifier the name qualifier name node
-	 * @param name the simple name being qualified
-	 * @return a new unparented qualified type node
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 * @exception UnsupportedOperationException if this operation is used in
-	 * a JLS2, JLS3 and JLS4 AST
-	 * @since 3.9 BETA_JAVA8
-	 */
-	public NameQualifiedType newNameQualifiedType(Name qualifier, SimpleName name) {
-		NameQualifiedType result = new NameQualifiedType(this);
-		result.setQualifier(qualifier);
-		result.setName(name);
-		return result;
-	}
-
-	/**
 	 * Creates and returns a new unparented parameterized type node with the
 	 * given type and an empty list of type arguments.
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 2c770bb..a77cea3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1013,6 +1013,8 @@ public abstract class ASTNode {
 				return MethodRefParameter.class;
 			case MODIFIER :
 				return Modifier.class;
+			case NAME_QUALIFIED_TYPE :
+				return NameQualifiedType.class;
 			case NORMAL_ANNOTATION :
 				return NormalAnnotation.class;
 			case NULL_LITERAL :
@@ -1021,8 +1023,6 @@ public abstract class ASTNode {
 				return NumberLiteral.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
-			case NAME_QUALIFIED_TYPE :
-				return NameQualifiedType.class;
 			case PARAMETERIZED_TYPE :
 				return ParameterizedType.class;
 			case PARENTHESIZED_EXPRESSION :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index b4326dc..44f072a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -1075,7 +1075,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.1
 	 */
-	public boolean visit(ParameterizedType node) {
+	public boolean visit(NormalAnnotation node) {
 		return true;
 	}
 
@@ -1090,9 +1090,8 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.1
 	 */
-	public boolean visit(NormalAnnotation node) {
+	public boolean visit(NullLiteral node) {
 		return true;
 	}
 
@@ -1108,7 +1107,7 @@ public abstract class ASTVisitor {
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
 	 */
-	public boolean visit(NullLiteral node) {
+	public boolean visit(NumberLiteral node) {
 		return true;
 	}
 
@@ -1124,7 +1123,7 @@ public abstract class ASTVisitor {
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
 	 */
-	public boolean visit(NumberLiteral node) {
+	public boolean visit(PackageDeclaration node) {
 		return true;
 	}
 
@@ -1139,8 +1138,9 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.1
 	 */
-	public boolean visit(PackageDeclaration node) {
+	public boolean visit(ParameterizedType node) {
 		return true;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index a0aafa2..7709799 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -187,6 +187,10 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(Modifier node) {
 		endVisitNode(node);
 	}
+	public void endVisit(NameQualifiedType node) {
+		endVisitNode(node);
+	}
+
 	public void endVisit(NormalAnnotation node) {
 		endVisitNode(node);
 	}
@@ -199,9 +203,6 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(PackageDeclaration node) {
 		endVisitNode(node);
 	}
-	public void endVisit(NameQualifiedType node) {
-		endVisitNode(node);
-	}
 	public void endVisit(ParameterizedType node) {
 		endVisitNode(node);
 	}
@@ -474,6 +475,10 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(MethodRefParameter node) {
 		return visitNode(node);
 	}
+	public boolean visit(NameQualifiedType node) {
+		return visitNode(node);
+	}
+
 	public boolean visit(NormalAnnotation node) {
 		return visitNode(node);
 	}
@@ -486,9 +491,6 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(PackageDeclaration node) {
 		return visitNode(node);
 	}
-	public boolean visit(NameQualifiedType node) {
-		return visitNode(node);
-	}
 	public boolean visit(ParameterizedType node) {
 		return visitNode(node);
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index c521ad6..0deb2a7 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -1203,6 +1203,18 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(NameQualifiedType)
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public boolean visit(NameQualifiedType node) {
+		node.getQualifier().accept(this);
+		this.buffer.append('.');
+		visitTypeAnnotations(node);
+		node.getName().accept(this);
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(NormalAnnotation)
 	 * @since 3.1
 	 */
@@ -1259,18 +1271,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(NameQualifiedType)
-	 * @since 3.9 BETA_JAVA8
-	 */
-	public boolean visit(NameQualifiedType node) {
-		node.getQualifier().accept(this);
-		this.buffer.append('.');
-		visitTypeAnnotations(node);
-		node.getName().accept(this);
-		return false;
-	}
-
-	/*
 	 * @see ASTVisitor#visit(ParameterizedType)
 	 * @since 3.1
 	 */
commit ad704373cea78f3c29e047ad44aaf6e254d7c32f
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Jan 6 16:53:07 2014 +0100

    Bug 418979: [1.8][dom ast] Bad source ranges for annotated QualifiedType as type of ParameterizedType
    
    cleanup

2	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 5eefd89..9266b90 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -3873,18 +3873,9 @@ class ASTConverter {
 				name = createSimpleName(typeReference, positions, tokens, 0 );
 			} else {
 				name = setQualifiedNameNameAndSourceRanges(tokens, positions, firstTypeIndex - 1, typeReference);
-			}						
-
-/*			org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding = typeReference.resolvedType;
-			boolean createPackageQualifiedType = false;
-			if (typeBinding instanceof ReferenceBinding) {
-				ReferenceBinding referenceBinding = (ReferenceBinding)typeBinding;			
-				PackageBinding packageBinding = referenceBinding.getPackage();
-				if (packageBinding != null && Arrays.equals(name.toString().toCharArray(), packageBinding.readableName())) {
-					createPackageQualifiedType = true;
-				}
 			}
-*/			boolean createNameQualifiedType = typeAnnotations != null && typeAnnotations[firstTypeIndex] != null;
+
+			boolean createNameQualifiedType = typeAnnotations != null && typeAnnotations[firstTypeIndex] != null;
 			if (createNameQualifiedType && this.ast.apiLevel >= AST.JLS8) {
 				NameQualifiedType nameQualifiedType = new NameQualifiedType(this.ast);
 				nameQualifiedType.setQualifier(name);
commit 1a9cac53d4ac29d3f80117ac2f0972315a7c6461
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Jan 6 16:53:36 2014 +0100

    Bug 418979: [1.8][dom ast] Bad source ranges for annotated QualifiedType as type of ParameterizedType
    
    fix for qualified diamond

2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 9266b90..127f354 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -3661,7 +3661,7 @@ class ASTConverter {
 							}
 						}						
 						int start = (int) (positions[0] >>> 32);
-						int end = (int) positions[0];
+						int end = (int) positions[firstTypeIndex];
 						
 						Type currentType = createBaseType(typeReference, positions, typeAnnotations, tokens, lenth, firstTypeIndex, isTypeArgumentBased);
 						int indexOfEnclosingType = 1;
commit 0034505de2732b8d694205cdc539038707e38e58
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Tue Jan 7 12:20:50 2014 +0100

    Bug 418979 [1.8][dom ast] Bad source ranges for annotated QualifiedType as type of ParameterizedType
    
    - Javadoc tweaks for NameQualifiedType
    - tests: resolved TODOs and removed unused class

22	18	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
12	9	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
7	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index 500cb0d..2af1c7e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -2068,9 +2068,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 						"public class X<T extends Exception> {\n" +
 						"	class Y<K, V> {\n" +
 						"		class Z {\n" +
-//TODO: bad AST node structure, see https://bugs.eclipse.org/419974#c2 :
-//						"			public Z(@A X<T>.@B Y<K, V> Y.this){ }\n" +
-//						"			public void foo(@B Y<K, V>.@C Z this){ }\n" +
+						"			public Z(@A X<T>.@B Y<K, V> Y.this, boolean a){ }\n" +
+						"			public void foo(@B Y<K, V>.@C Z this, boolean a){ }\n" +
 						"			public Z(X<T>.@B Y<K, V> Y.this){ }\n" +
 						"			public void foo(Y<K, V>.@C Z this){ }\n" +
 						"		}\n" +
@@ -2090,22 +2089,29 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		TypeDeclaration type = (TypeDeclaration)node;
 		node = (ASTNode) type.bodyDeclarations().get(0);
 		type = (TypeDeclaration) node;
-		node = (ASTNode) type.bodyDeclarations().get(0);
-		assertEquals("Not a method Declaration", ASTNode.METHOD_DECLARATION, node.getNodeType());
-		MethodDeclaration method = (MethodDeclaration) node;
+		
+		MethodDeclaration method = (MethodDeclaration) type.bodyDeclarations().get(0);
 		Type receiver = method.getReceiverType();
-//TODO: bad AST node structure, see https://bugs.eclipse.org/419974#c2 :
-//		assertEquals("Incorrect receiver", "@A X<T>.@B Y<K,V>", ((QualifiedType) receiver).toString());
-//		assertEquals("Incorrect method signature", "public Z(@A X<T>.@B Y<K,V> Y.this){\n}\n", method.toString());
-		assertEquals("Incorrect receiver", "X<T>.@B Y<K,V>", ((ParameterizedType) receiver).toString());
-		assertEquals("Incorrect method signature", "public Z(X<T>.@B Y<K,V> Y.this){\n}\n", method.toString());
+		assertEquals("Not a ParameterizedType", ASTNode.PARAMETERIZED_TYPE, receiver.getNodeType());
+		checkSourceRange(receiver, "@A X<T>.@B Y<K, V>", contents);
+		assertEquals("Incorrect method signature", "public Z(@A X<T>.@B Y<K,V> Y.this,boolean a){\n}\n", method.toString());
 		
 		method = (MethodDeclaration) type.bodyDeclarations().get(1);
 		receiver = method.getReceiverType();
-//TODO: bad AST node structure, see https://bugs.eclipse.org/419974#c2 :
-//		assertEquals("Incorrect receiver", "@B Y<K,V>.@C Z", ((QualifiedType) receiver).toString());
-//		assertEquals("Incorrect method signature", "public void foo(@B Y<K,V>.@C Z this){\n}\n", method.toString());
-		assertEquals("Incorrect receiver", "Y<K,V>.@C Z", ((QualifiedType) receiver).toString());
+		assertEquals("Not a QualifiedType", ASTNode.QUALIFIED_TYPE, receiver.getNodeType());
+		checkSourceRange(receiver, "@B Y<K, V>.@C Z", contents);
+		assertEquals("Incorrect method signature", "public void foo(@B Y<K,V>.@C Z this,boolean a){\n}\n", method.toString());
+		
+		method = (MethodDeclaration) type.bodyDeclarations().get(2);
+		receiver = method.getReceiverType();
+		assertEquals("Not a ParameterizedType", ASTNode.PARAMETERIZED_TYPE, receiver.getNodeType());
+		checkSourceRange(receiver, "X<T>.@B Y<K, V>", contents);
+		assertEquals("Incorrect method signature", "public Z(X<T>.@B Y<K,V> Y.this){\n}\n", method.toString());
+		
+		method = (MethodDeclaration) type.bodyDeclarations().get(3);
+		receiver = method.getReceiverType();
+		assertEquals("Not a QualifiedType", ASTNode.QUALIFIED_TYPE, receiver.getNodeType());
+		checkSourceRange(receiver, "Y<K, V>.@C Z", contents);
 		assertEquals("Incorrect method signature", "public void foo(Y<K,V>.@C Z this){\n}\n", method.toString());
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403410
@@ -3623,6 +3629,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 	}
 	/*
 	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=418979
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=424977
 	 */
 	public void _testBug418979_002() throws JavaModelException {
 		String contents =
@@ -3665,9 +3672,6 @@ public class ASTConverter18Test extends ConverterTestSetup {
 				"        new java.util.@A HashMap<>();\n" +
 				"    }\n" +
 				" }\n" +
-				"class Outer<T> {\n" +
-				"	class Inner<S> {}\n" +
-				"}\n" +
 				"@Target (ElementType.TYPE_USE)\n" +
 				"@interface A{}";
 		this.workingCopy = getWorkingCopy("/Converter18/src/test/X.java", true/*resolve*/);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
index bb871ef..5fdc93d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameQualifiedType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
+ * Copyright (c) 2013, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,7 +19,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Node for a name qualified type (added in JLS8 API).
+ * Node for a name-qualified type (added in JLS8 API).
  * 
  * <pre>
  * NameQualifiedType:
@@ -27,6 +27,9 @@ import java.util.List;
  * </pre>
  * 
  * <p>
+ * The qualifier can resolve to a type or to a package.
+ * </p>
+ * <p>
  * Note that if no annotation is present, then a name-qualified type can
  * also be represented by a SimpleType or a QualifiedType, see the discussion
  * in {@link QualifiedType}.
@@ -100,7 +103,7 @@ public class NameQualifiedType extends AnnotatableType {
 	private SimpleName name = null;
 
 	/**
-	 * Creates a new unparented node for a name qualified type owned by the
+	 * Creates a new unparented node for a name-qualified type owned by the
 	 * given AST. By default, an unspecified, but legal, qualifier and name.
 	 * <p>
 	 * N.B. This constructor is package-private.
@@ -195,9 +198,9 @@ public class NameQualifiedType extends AnnotatableType {
 	}
 
 	/**
-	 * Returns the qualifier of this name qualified type.
+	 * Returns the qualifier of this name-qualified type.
 	 *
-	 * @return the qualifier of this name qualified type
+	 * @return the qualifier of this name-qualified type
 	 */
 	public Name getQualifier() {
 		if (this.qualifier == null) {
@@ -214,9 +217,9 @@ public class NameQualifiedType extends AnnotatableType {
 	}
 
 	/**
-	 * Sets the qualifier of this name qualified type to the given name.
+	 * Sets the qualifier of this name-qualified type to the given name.
 	 *
-	 * @param name the new qualifier of this name qualified type
+	 * @param name the new qualifier of this name-qualified type
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
@@ -234,7 +237,7 @@ public class NameQualifiedType extends AnnotatableType {
 	}
 
 	/**
-	 * Returns the name part of this name qualified type.
+	 * Returns the name part of this name-qualified type.
 	 *
 	 * @return the name being qualified
 	 */
@@ -253,7 +256,7 @@ public class NameQualifiedType extends AnnotatableType {
 	}
 
 	/**
-	 * Sets the name part of this name qualified type to the given simple name.
+	 * Sets the name part of this name-qualified type to the given simple name.
 	 *
 	 * @param name the identifier of this qualified name
 	 * @exception IllegalArgumentException if:
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
index 04b5a0c..884a71b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2003, 2013 IBM Corporation and others.
+ * Copyright (c) 2003, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,17 +34,17 @@ import java.util.List;
  * <p>
  * A "."-separated type like "A.B" can be represented in three ways:
  * <pre>
- * 1.    SimpleType       | 2.   NameQualifiedType | 3. QualifiedType
- *     QualifiedName      | SimpleName  SimpleName |   SimpleType  SimpleName
- * SimpleName  SimpleName |     "A"        "B"     |   SimpleName     "B"
- *     "A"        "B"     |                        |       "A"
+ * 1.    SimpleType       | 2. NameQualifiedType   | 3.  QualifiedType
+ *     QualifiedName      | SimpleName  SimpleName | SimpleType  SimpleName
+ * SimpleName  SimpleName |     "A"         "B"    | SimpleName      "B"
+ *     "A"         "B"    |                        |     "A"
  * </pre>
  * <p>
  * The ASTParser creates the SimpleType form (wrapping a name) if possible. The
  * SimpleType form doesn't support any embedded Annotations nor ParameterizedTypes.
  * The NameQualifiedType form is only available since JLS8 and the
- * QualifiedType form only since JLS3. The NameQualifiedType form allows
- * Annotations on the last SimpleName. The QualifiedType form cannot be used if
+ * QualifiedType form only since JLS3. The NameQualifiedType and QualifiedType forms
+ * allow Annotations on the last SimpleName. The QualifiedType form cannot be used if
  * the qualifier represents a package name.
  * </p>
  * <p>
