commit a55be3089b1474701c6009071b6792ce21fce5bc
Author: Andrew Clement <aclement@gopivotal.com>
Date:   Mon Jan 13 08:05:11 2014 +0530

    Fixed Bug 405104 - [1.8][compiler][codegen] Implement support for
    serializeable lambdas

296	178	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JSR335ClassFileTest.java
1213	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SerializableLambdaTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
146	27	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
50	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
283	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
26	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java
21	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
15	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
15	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
21	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JSR335ClassFileTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JSR335ClassFileTest.java
index 804a6a8..8cae987 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JSR335ClassFileTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JSR335ClassFileTest.java
@@ -104,14 +104,14 @@ public void test001() throws Exception {
 		"    constant #21 utf8: \"LX;\"\n" + 
 		"    constant #22 utf8: \"SourceFile\"\n" + 
 		"    constant #23 utf8: \"X.java\"\n" + 
-		"    constant #24 method_ref: #25.#27 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-		"    constant #25 class: #26 java/lang/invoke/LambdaMetafactory\n" + 
-		"    constant #26 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-		"    constant #27 name_and_type: #28.#29 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-		"    constant #28 utf8: \"metafactory\"\n" + 
-		"    constant #29 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-		"    constant #30 method handle: invokestatic (6) #24 \n" + 
-		"    constant #31 utf8: \"BootstrapMethods\"\n" + 
+		"    constant #24 utf8: \"BootstrapMethods\"\n" + 
+		"    constant #25 method_ref: #26.#28 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+		"    constant #26 class: #27 java/lang/invoke/LambdaMetafactory\n" + 
+		"    constant #27 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+		"    constant #28 name_and_type: #29.#30 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+		"    constant #29 utf8: \"metafactory\"\n" + 
+		"    constant #30 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+		"    constant #31 method handle: invokestatic (6) #25 \n" + 
 		"    constant #32 method type: #8 ()V\n" + 
 		"    constant #33 method_ref: #34.#36 java/lang/Thread.yield ()V\n" + 
 		"    constant #34 class: #35 java/lang/Thread\n" + 
@@ -150,7 +150,7 @@ public void test001() throws Exception {
 		"    [inner class info: #41 java/lang/invoke/MethodHandles$Lookup, outer class info: #43 java/lang/invoke/MethodHandles\n" + 
 		"     inner name: #45 Lookup, accessflags: 25 public static final]\n" + 
 		"Bootstrap methods:\n" + 
-		"  0 : # 30 arguments: {#32,#38,#39}\n" + 
+		"  0 : # 31 arguments: {#32,#38,#39}\n" + 
 		"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -206,14 +206,14 @@ public void test002() throws Exception {
 			"    constant #21 utf8: \"LX;\"\n" + 
 			"    constant #22 utf8: \"SourceFile\"\n" + 
 			"    constant #23 utf8: \"X.java\"\n" + 
-			"    constant #24 method_ref: #25.#27 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #25 class: #26 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #26 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #27 name_and_type: #28.#29 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #28 utf8: \"metafactory\"\n" + 
-			"    constant #29 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #30 method handle: invokestatic (6) #24 \n" + 
-			"    constant #31 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #24 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #25 method_ref: #26.#28 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #26 class: #27 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #27 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #28 name_and_type: #29.#30 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #29 utf8: \"metafactory\"\n" + 
+			"    constant #30 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #31 method handle: invokestatic (6) #25 \n" + 
 			"    constant #32 utf8: \"(Ljava/lang/Object;)V\"\n" + 
 			"    constant #33 method type: #32 (Ljava/lang/Object;)V\n" + 
 			"    constant #34 method_ref: #35.#37 Main.printIt (Ljava/lang/Object;)V\n" + 
@@ -253,7 +253,7 @@ public void test002() throws Exception {
 			"    [inner class info: #42 java/lang/invoke/MethodHandles$Lookup, outer class info: #44 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #46 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 30 arguments: {#33,#39,#40}\n" + 
+			"  0 : # 31 arguments: {#33,#39,#40}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -310,14 +310,14 @@ public void test003() throws Exception {
 			"    constant #21 utf8: \"LX;\"\n" + 
 			"    constant #22 utf8: \"SourceFile\"\n" + 
 			"    constant #23 utf8: \"X.java\"\n" + 
-			"    constant #24 method_ref: #25.#27 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #25 class: #26 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #26 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #27 name_and_type: #28.#29 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #28 utf8: \"metafactory\"\n" + 
-			"    constant #29 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #30 method handle: invokestatic (6) #24 \n" + 
-			"    constant #31 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #24 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #25 method_ref: #26.#28 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #26 class: #27 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #27 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #28 name_and_type: #29.#30 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #29 utf8: \"metafactory\"\n" + 
+			"    constant #30 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #31 method handle: invokestatic (6) #25 \n" + 
 			"    constant #32 utf8: \"(Ljava/lang/Object;)Ljava/lang/String;\"\n" + 
 			"    constant #33 method type: #32 (Ljava/lang/Object;)Ljava/lang/String;\n" + 
 			"    constant #34 method_ref: #3.#35 java/lang/Object.toString ()Ljava/lang/String;\n" + 
@@ -356,7 +356,7 @@ public void test003() throws Exception {
 			"    [inner class info: #41 java/lang/invoke/MethodHandles$Lookup, outer class info: #43 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #45 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 30 arguments: {#33,#38,#39}\n" + 
+			"  0 : # 31 arguments: {#33,#38,#39}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -416,14 +416,14 @@ public void test004() throws Exception {
 			"    constant #27 utf8: \"LX;\"\n" + 
 			"    constant #28 utf8: \"SourceFile\"\n" + 
 			"    constant #29 utf8: \"X.java\"\n" + 
-			"    constant #30 method_ref: #31.#33 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #31 class: #32 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #32 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #33 name_and_type: #34.#35 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #34 utf8: \"metafactory\"\n" + 
-			"    constant #35 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #36 method handle: invokestatic (6) #30 \n" + 
-			"    constant #37 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #30 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #31 method_ref: #32.#34 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #32 class: #33 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #33 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #34 name_and_type: #35.#36 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #35 utf8: \"metafactory\"\n" + 
+			"    constant #36 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #37 method handle: invokestatic (6) #31 \n" + 
 			"    constant #38 utf8: \"()Ljava/lang/String;\"\n" + 
 			"    constant #39 method type: #38 ()Ljava/lang/String;\n" + 
 			"    constant #40 method_ref: #41.#43 java/lang/String.toString ()Ljava/lang/String;\n" + 
@@ -472,7 +472,7 @@ public void test004() throws Exception {
 			"    [inner class info: #48 java/lang/invoke/MethodHandles$Lookup, outer class info: #50 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #52 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 36 arguments: {#39,#45,#46}\n" + 
+			"  0 : # 37 arguments: {#39,#45,#46}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -528,14 +528,14 @@ public void test005() throws Exception {
 			"    constant #22 utf8: \"LX;\"\n" + 
 			"    constant #23 utf8: \"SourceFile\"\n" + 
 			"    constant #24 utf8: \"X.java\"\n" + 
-			"    constant #25 method_ref: #26.#28 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #26 class: #27 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #27 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #28 name_and_type: #29.#30 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #29 utf8: \"metafactory\"\n" + 
-			"    constant #30 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #31 method handle: invokestatic (6) #25 \n" + 
-			"    constant #32 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #25 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #26 method_ref: #27.#29 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #27 class: #28 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #28 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #29 name_and_type: #30.#31 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #30 utf8: \"metafactory\"\n" + 
+			"    constant #31 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #32 method handle: invokestatic (6) #26 \n" + 
 			"    constant #33 utf8: \"()LMain;\"\n" + 
 			"    constant #34 method type: #33 ()LMain;\n" + 
 			"    constant #35 method_ref: #36.#20 Main.<init> ()V\n" + 
@@ -577,7 +577,7 @@ public void test005() throws Exception {
 			"    [inner class info: #41 java/lang/invoke/MethodHandles$Lookup, outer class info: #43 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #45 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 31 arguments: {#34,#38,#39}\n" + 
+			"  0 : # 32 arguments: {#34,#38,#39}\n" + 
 			"}", "X.class", ClassFileBytesDisassembler.SYSTEM);
 }
 public void test006() throws Exception {
@@ -639,14 +639,14 @@ public void test006() throws Exception {
 			"    constant #24 utf8: \"LX;\"\n" + 
 			"    constant #25 utf8: \"SourceFile\"\n" + 
 			"    constant #26 utf8: \"X.java\"\n" + 
-			"    constant #27 method_ref: #28.#30 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #28 class: #29 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #29 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #30 name_and_type: #31.#32 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #31 utf8: \"metafactory\"\n" + 
-			"    constant #32 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #33 method handle: invokestatic (6) #27 \n" + 
-			"    constant #34 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #27 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #28 method_ref: #29.#31 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #29 class: #30 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #30 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #31 name_and_type: #32.#33 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #32 utf8: \"metafactory\"\n" + 
+			"    constant #33 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #34 method handle: invokestatic (6) #28 \n" + 
 			"    constant #35 utf8: \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"\n" + 
 			"    constant #36 method type: #35 (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n" + 
 			"    constant #37 method_ref: #38.#40 Main.<init> (Ljava/lang/String;Ljava/lang/String;)V\n" + 
@@ -692,7 +692,7 @@ public void test006() throws Exception {
 			"    [inner class info: #46 java/lang/invoke/MethodHandles$Lookup, outer class info: #48 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #50 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 33 arguments: {#36,#42,#44}\n" + 
+			"  0 : # 34 arguments: {#36,#42,#44}\n" + 
 			"}";
 	verifyClassFile(expected, "X.class", ClassFileBytesDisassembler.SYSTEM);
 }
@@ -757,14 +757,14 @@ public void test007() throws Exception {
 			"    constant #36 utf8: \"(Ljava/lang/String;)V\"\n" + 
 			"    constant #37 utf8: \"SourceFile\"\n" + 
 			"    constant #38 utf8: \"X.java\"\n" + 
-			"    constant #39 method_ref: #40.#42 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #40 class: #41 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #41 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #42 name_and_type: #43.#44 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #43 utf8: \"metafactory\"\n" + 
-			"    constant #44 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #45 method handle: invokestatic (6) #39 \n" + 
-			"    constant #46 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #39 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #40 method_ref: #41.#43 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #41 class: #42 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #42 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #43 name_and_type: #44.#45 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #44 utf8: \"metafactory\"\n" + 
+			"    constant #45 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #46 method handle: invokestatic (6) #40 \n" + 
 			"    constant #47 method type: #8 ()V\n" + 
 			"    constant #48 method_ref: #1.#49 X.lambda$0 ()V\n" + 
 			"    constant #49 name_and_type: #22.#8 lambda$0 ()V\n" + 
@@ -811,7 +811,7 @@ public void test007() throws Exception {
 			"    [inner class info: #53 java/lang/invoke/MethodHandles$Lookup, outer class info: #55 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #57 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 45 arguments: {#47,#50,#51}\n" + 
+			"  0 : # 46 arguments: {#47,#50,#51}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -875,14 +875,14 @@ public void test007a() throws Exception {
 			"    constant #36 utf8: \"(Ljava/lang/String;)V\"\n" + 
 			"    constant #37 utf8: \"SourceFile\"\n" + 
 			"    constant #38 utf8: \"X.java\"\n" + 
-			"    constant #39 method_ref: #40.#42 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #40 class: #41 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #41 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #42 name_and_type: #43.#44 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #43 utf8: \"metafactory\"\n" + 
-			"    constant #44 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #45 method handle: invokestatic (6) #39 \n" + 
-			"    constant #46 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #39 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #40 method_ref: #41.#43 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #41 class: #42 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #42 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #43 name_and_type: #44.#45 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #44 utf8: \"metafactory\"\n" + 
+			"    constant #45 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #46 method handle: invokestatic (6) #40 \n" + 
 			"    constant #47 method type: #8 ()V\n" + 
 			"    constant #48 method_ref: #1.#49 X.lambda$0 ()V\n" + 
 			"    constant #49 name_and_type: #22.#8 lambda$0 ()V\n" + 
@@ -928,7 +928,7 @@ public void test007a() throws Exception {
 			"    [inner class info: #53 java/lang/invoke/MethodHandles$Lookup, outer class info: #55 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #57 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 45 arguments: {#47,#50,#51}\n" + 
+			"  0 : # 46 arguments: {#47,#50,#51}\n" + 
 			"}";
 	
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -983,14 +983,14 @@ public void test008() throws Exception {
 			"    constant #27 utf8: \"SUCCESS\"\n" + 
 			"    constant #28 utf8: \"SourceFile\"\n" + 
 			"    constant #29 utf8: \"X.java\"\n" + 
-			"    constant #30 method_ref: #31.#33 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #31 class: #32 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #32 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #33 name_and_type: #34.#35 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #34 utf8: \"metafactory\"\n" + 
-			"    constant #35 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #36 method handle: invokestatic (6) #30 \n" + 
-			"    constant #37 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #30 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #31 method_ref: #32.#34 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #32 class: #33 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #33 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #34 name_and_type: #35.#36 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #35 utf8: \"metafactory\"\n" + 
+			"    constant #36 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #37 method handle: invokestatic (6) #31 \n" + 
 			"    constant #38 utf8: \"()Ljava/lang/Object;\"\n" + 
 			"    constant #39 method type: #38 ()Ljava/lang/Object;\n" + 
 			"    constant #40 method_ref: #1.#41 X.lambda$0 ()Ljava/lang/String;\n" + 
@@ -1036,7 +1036,7 @@ public void test008() throws Exception {
 			"    [inner class info: #45 java/lang/invoke/MethodHandles$Lookup, outer class info: #47 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #49 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 36 arguments: {#39,#42,#43}\n" + 
+			"  0 : # 37 arguments: {#39,#42,#43}\n" + 
 			"}"
 ;
 
@@ -1117,14 +1117,14 @@ public void test009() throws Exception {
 			"    constant #47 utf8: \"s2\"\n" + 
 			"    constant #48 utf8: \"SourceFile\"\n" + 
 			"    constant #49 utf8: \"X.java\"\n" + 
-			"    constant #50 method_ref: #51.#53 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #51 class: #52 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #52 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #53 name_and_type: #54.#55 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #54 utf8: \"metafactory\"\n" + 
-			"    constant #55 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #56 method handle: invokestatic (6) #50 \n" + 
-			"    constant #57 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #50 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #51 method_ref: #52.#54 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #52 class: #53 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #53 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #54 name_and_type: #55.#56 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #55 utf8: \"metafactory\"\n" + 
+			"    constant #56 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #57 method handle: invokestatic (6) #51 \n" + 
 			"    constant #58 utf8: \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"\n" + 
 			"    constant #59 method type: #58 (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n" + 
 			"    constant #60 method_ref: #1.#61 X.lambda$0 (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\n" + 
@@ -1180,7 +1180,7 @@ public void test009() throws Exception {
 			"    [inner class info: #65 java/lang/invoke/MethodHandles$Lookup, outer class info: #67 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #69 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 56 arguments: {#59,#62,#63}\n" + 
+			"  0 : # 57 arguments: {#59,#62,#63}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -1268,14 +1268,14 @@ public void test010() throws Exception {
 			"    constant #51 utf8: \"s2\"\n" + 
 			"    constant #52 utf8: \"SourceFile\"\n" + 
 			"    constant #53 utf8: \"X.java\"\n" + 
-			"    constant #54 method_ref: #55.#57 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #55 class: #56 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #56 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #57 name_and_type: #58.#59 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #58 utf8: \"metafactory\"\n" + 
-			"    constant #59 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #60 method handle: invokestatic (6) #54 \n" + 
-			"    constant #61 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #54 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #55 method_ref: #56.#58 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #56 class: #57 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #57 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #58 name_and_type: #59.#60 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #59 utf8: \"metafactory\"\n" + 
+			"    constant #60 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #61 method handle: invokestatic (6) #55 \n" + 
 			"    constant #62 utf8: \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"\n" + 
 			"    constant #63 method type: #62 (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n" + 
 			"    constant #64 method_ref: #1.#65 X.lambda$0 (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\n" + 
@@ -1342,7 +1342,7 @@ public void test010() throws Exception {
 			"    [inner class info: #70 java/lang/invoke/MethodHandles$Lookup, outer class info: #72 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #74 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 60 arguments: {#63,#66,#68}\n" + 
+			"  0 : # 61 arguments: {#63,#66,#68}\n" + 
 			"}"
 ;
 
@@ -1431,14 +1431,14 @@ public void test011() throws Exception {
 			"    constant #51 utf8: \"s2\"\n" + 
 			"    constant #52 utf8: \"SourceFile\"\n" + 
 			"    constant #53 utf8: \"X.java\"\n" + 
-			"    constant #54 method_ref: #55.#57 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #55 class: #56 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #56 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #57 name_and_type: #58.#59 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #58 utf8: \"metafactory\"\n" + 
-			"    constant #59 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #60 method handle: invokestatic (6) #54 \n" + 
-			"    constant #61 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #54 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #55 method_ref: #56.#58 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #56 class: #57 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #57 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #58 name_and_type: #59.#60 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #59 utf8: \"metafactory\"\n" + 
+			"    constant #60 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #61 method handle: invokestatic (6) #55 \n" + 
 			"    constant #62 utf8: \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\"\n" + 
 			"    constant #63 method type: #62 (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n" + 
 			"    constant #64 method_ref: #1.#65 X.lambda$0 (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\n" + 
@@ -1505,7 +1505,7 @@ public void test011() throws Exception {
 			"    [inner class info: #70 java/lang/invoke/MethodHandles$Lookup, outer class info: #72 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #74 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 60 arguments: {#63,#66,#68}\n" + 
+			"  0 : # 61 arguments: {#63,#66,#68}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -1576,14 +1576,14 @@ public void test012() throws Exception {
 			"    constant #33 utf8: \"p\"\n" + 
 			"    constant #34 utf8: \"SourceFile\"\n" + 
 			"    constant #35 utf8: \"X.java\"\n" + 
-			"    constant #36 method_ref: #37.#39 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #37 class: #38 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #38 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #39 name_and_type: #40.#41 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #40 utf8: \"metafactory\"\n" + 
-			"    constant #41 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #42 method handle: invokestatic (6) #36 \n" + 
-			"    constant #43 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #36 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #37 method_ref: #38.#40 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #38 class: #39 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #39 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #40 name_and_type: #41.#42 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #41 utf8: \"metafactory\"\n" + 
+			"    constant #42 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #43 method handle: invokestatic (6) #37 \n" + 
 			"    constant #44 utf8: \"(Ljava/lang/Object;Ljava/lang/Object;)V\"\n" + 
 			"    constant #45 method type: #44 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
 			"    constant #46 method_ref: #1.#47 X.lambda$0 ([Ljava/lang/String;IILjava/lang/Object;Ljava/lang/Object;)V\n" + 
@@ -1663,7 +1663,7 @@ public void test012() throws Exception {
 			"    [inner class info: #51 java/lang/invoke/MethodHandles$Lookup, outer class info: #53 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #55 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 42 arguments: {#45,#48,#49}\n" + 
+			"  0 : # 43 arguments: {#45,#48,#49}\n" + 
 			"}"
 ;
 
@@ -1730,14 +1730,14 @@ public void test013() throws Exception {
 			"    constant #30 utf8: \"p\"\n" + 
 			"    constant #31 utf8: \"SourceFile\"\n" + 
 			"    constant #32 utf8: \"X.java\"\n" + 
-			"    constant #33 method_ref: #34.#36 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #34 class: #35 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #35 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #36 name_and_type: #37.#38 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #37 utf8: \"metafactory\"\n" + 
-			"    constant #38 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #39 method handle: invokestatic (6) #33 \n" + 
-			"    constant #40 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #33 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #34 method_ref: #35.#37 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #35 class: #36 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #36 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #37 name_and_type: #38.#39 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #38 utf8: \"metafactory\"\n" + 
+			"    constant #39 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #40 method handle: invokestatic (6) #34 \n" + 
 			"    constant #41 method type: #25 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
 			"    constant #42 method_ref: #1.#43 X.lambda$0 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
 			"    constant #43 name_and_type: #24.#25 lambda$0 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
@@ -1795,7 +1795,7 @@ public void test013() throws Exception {
 			"    [inner class info: #47 java/lang/invoke/MethodHandles$Lookup, outer class info: #49 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #51 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 39 arguments: {#41,#44,#45}\n" + 
+			"  0 : # 40 arguments: {#41,#44,#45}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -1874,14 +1874,14 @@ public void test014() throws Exception {
 			"    constant #40 utf8: \"([Ljava/lang/String;IILjava/lang/Object;Ljava/lang/Object;)V\"\n" + 
 			"    constant #41 utf8: \"SourceFile\"\n" + 
 			"    constant #42 utf8: \"X.java\"\n" + 
-			"    constant #43 method_ref: #44.#46 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #44 class: #45 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #45 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #46 name_and_type: #47.#48 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #47 utf8: \"metafactory\"\n" + 
-			"    constant #48 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #49 method handle: invokestatic (6) #43 \n" + 
-			"    constant #50 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #43 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #44 method_ref: #45.#47 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #45 class: #46 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #46 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #47 name_and_type: #48.#49 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #48 utf8: \"metafactory\"\n" + 
+			"    constant #49 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #50 method handle: invokestatic (6) #44 \n" + 
 			"    constant #51 method type: #33 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
 			"    constant #52 method_ref: #1.#53 X.lambda$0 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
 			"    constant #53 name_and_type: #32.#33 lambda$0 (Ljava/lang/Object;Ljava/lang/Object;)V\n" + 
@@ -1990,8 +1990,8 @@ public void test014() throws Exception {
 			"    [inner class info: #62 java/lang/invoke/MethodHandles$Lookup, outer class info: #64 java/lang/invoke/MethodHandles\n" + 
 			"     inner name: #66 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 49 arguments: {#51,#54,#55},\n" + 
-			"  1 : # 49 arguments: {#56,#59,#60}\n" + 
+			"  0 : # 50 arguments: {#51,#54,#55},\n" + 
+			"  1 : # 50 arguments: {#56,#59,#60}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -2040,27 +2040,80 @@ public void test015() throws Exception {
 			"    constant #22 utf8: \"i\"\n" + 
 			"    constant #23 utf8: \"LI;\"\n" + 
 			"    constant #24 utf8: \"lambda$0\"\n" + 
-			"    constant #25 utf8: \"SourceFile\"\n" + 
-			"    constant #26 utf8: \"X.java\"\n" + 
-			"    constant #27 method_ref: #28.#30 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #28 class: #29 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #29 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #30 name_and_type: #31.#32 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #31 utf8: \"metafactory\"\n" + 
-			"    constant #32 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #33 method handle: invokestatic (6) #27 \n" + 
-			"    constant #34 utf8: \"BootstrapMethods\"\n" + 
-			"    constant #35 method type: #6 ()V\n" + 
-			"    constant #36 method_ref: #1.#37 X.lambda$0 ()V\n" + 
-			"    constant #37 name_and_type: #24.#6 lambda$0 ()V\n" + 
-			"    constant #38 method handle: invokestatic (6) #36 \n" + 
-			"    constant #39 method type: #6 ()V\n" + 
-			"    constant #40 utf8: \"InnerClasses\"\n" + 
-			"    constant #41 class: #42 java/lang/invoke/MethodHandles$Lookup\n" + 
-			"    constant #42 utf8: \"java/lang/invoke/MethodHandles$Lookup\"\n" + 
-			"    constant #43 class: #44 java/lang/invoke/MethodHandles\n" + 
-			"    constant #44 utf8: \"java/lang/invoke/MethodHandles\"\n" + 
-			"    constant #45 utf8: \"Lookup\"\n" + 
+			"    constant #25 utf8: \"$deserializeLambda$\"\n" + 
+			"    constant #26 utf8: \"(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;\"\n" + 
+			"    constant #27 method_ref: #28.#30 java/lang/invoke/SerializedLambda.getImplMethodName ()Ljava/lang/String;\n" + 
+			"    constant #28 class: #29 java/lang/invoke/SerializedLambda\n" + 
+			"    constant #29 utf8: \"java/lang/invoke/SerializedLambda\"\n" + 
+			"    constant #30 name_and_type: #31.#32 getImplMethodName ()Ljava/lang/String;\n" + 
+			"    constant #31 utf8: \"getImplMethodName\"\n" + 
+			"    constant #32 utf8: \"()Ljava/lang/String;\"\n" + 
+			"    constant #33 method_ref: #34.#36 java/lang/String.hashCode ()I\n" + 
+			"    constant #34 class: #35 java/lang/String\n" + 
+			"    constant #35 utf8: \"java/lang/String\"\n" + 
+			"    constant #36 name_and_type: #37.#38 hashCode ()I\n" + 
+			"    constant #37 utf8: \"hashCode\"\n" + 
+			"    constant #38 utf8: \"()I\"\n" + 
+			"    constant #39 string: #24 \"lambda$0\"\n" + 
+			"    constant #40 method_ref: #34.#41 java/lang/String.equals (Ljava/lang/Object;)Z\n" + 
+			"    constant #41 name_and_type: #42.#43 equals (Ljava/lang/Object;)Z\n" + 
+			"    constant #42 utf8: \"equals\"\n" + 
+			"    constant #43 utf8: \"(Ljava/lang/Object;)Z\"\n" + 
+			"    constant #44 method_ref: #28.#45 java/lang/invoke/SerializedLambda.getImplMethodKind ()I\n" + 
+			"    constant #45 name_and_type: #46.#38 getImplMethodKind ()I\n" + 
+			"    constant #46 utf8: \"getImplMethodKind\"\n" + 
+			"    constant #47 method_ref: #28.#48 java/lang/invoke/SerializedLambda.getFunctionalInterfaceClass ()Ljava/lang/String;\n" + 
+			"    constant #48 name_and_type: #49.#32 getFunctionalInterfaceClass ()Ljava/lang/String;\n" + 
+			"    constant #49 utf8: \"getFunctionalInterfaceClass\"\n" + 
+			"    constant #50 string: #51 \"I\"\n" + 
+			"    constant #51 utf8: \"I\"\n" + 
+			"    constant #52 method_ref: #3.#41 java/lang/Object.equals (Ljava/lang/Object;)Z\n" + 
+			"    constant #53 method_ref: #28.#54 java/lang/invoke/SerializedLambda.getFunctionalInterfaceMethodName ()Ljava/lang/String;\n" + 
+			"    constant #54 name_and_type: #55.#32 getFunctionalInterfaceMethodName ()Ljava/lang/String;\n" + 
+			"    constant #55 utf8: \"getFunctionalInterfaceMethodName\"\n" + 
+			"    constant #56 string: #17 \"foo\"\n" + 
+			"    constant #57 method_ref: #28.#58 java/lang/invoke/SerializedLambda.getFunctionalInterfaceMethodSignature ()Ljava/lang/String;\n" + 
+			"    constant #58 name_and_type: #59.#32 getFunctionalInterfaceMethodSignature ()Ljava/lang/String;\n" + 
+			"    constant #59 utf8: \"getFunctionalInterfaceMethodSignature\"\n" + 
+			"    constant #60 string: #6 \"()V\"\n" + 
+			"    constant #61 method_ref: #28.#62 java/lang/invoke/SerializedLambda.getImplClass ()Ljava/lang/String;\n" + 
+			"    constant #62 name_and_type: #63.#32 getImplClass ()Ljava/lang/String;\n" + 
+			"    constant #63 utf8: \"getImplClass\"\n" + 
+			"    constant #64 string: #2 \"X\"\n" + 
+			"    constant #65 method_ref: #28.#66 java/lang/invoke/SerializedLambda.getImplMethodSignature ()Ljava/lang/String;\n" + 
+			"    constant #66 name_and_type: #67.#32 getImplMethodSignature ()Ljava/lang/String;\n" + 
+			"    constant #67 utf8: \"getImplMethodSignature\"\n" + 
+			"    constant #68 invoke dynamic: #0 #16 foo ()LI;\n" + 
+			"    constant #69 class: #70 java/lang/IllegalArgumentException\n" + 
+			"    constant #70 utf8: \"java/lang/IllegalArgumentException\"\n" + 
+			"    constant #71 string: #72 \"Invalid lambda deserialization\"\n" + 
+			"    constant #72 utf8: \"Invalid lambda deserialization\"\n" + 
+			"    constant #73 method_ref: #69.#74 java/lang/IllegalArgumentException.<init> (Ljava/lang/String;)V\n" + 
+			"    constant #74 name_and_type: #5.#75 <init> (Ljava/lang/String;)V\n" + 
+			"    constant #75 utf8: \"(Ljava/lang/String;)V\"\n" + 
+			"    constant #76 utf8: \"StackMapTable\"\n" + 
+			"    constant #77 utf8: \"SourceFile\"\n" + 
+			"    constant #78 utf8: \"X.java\"\n" + 
+			"    constant #79 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #80 method_ref: #81.#83 java/lang/invoke/LambdaMetafactory.altMetafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #81 class: #82 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #82 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #83 name_and_type: #84.#85 altMetafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #84 utf8: \"altMetafactory\"\n" + 
+			"    constant #85 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #86 method handle: invokestatic (6) #80 \n" + 
+			"    constant #87 method type: #6 ()V\n" + 
+			"    constant #88 method_ref: #1.#89 X.lambda$0 ()V\n" + 
+			"    constant #89 name_and_type: #24.#6 lambda$0 ()V\n" + 
+			"    constant #90 method handle: invokestatic (6) #88 \n" + 
+			"    constant #91 method type: #6 ()V\n" + 
+			"    constant #92 integer: 1\n" + 
+			"    constant #93 utf8: \"InnerClasses\"\n" + 
+			"    constant #94 class: #95 java/lang/invoke/MethodHandles$Lookup\n" + 
+			"    constant #95 utf8: \"java/lang/invoke/MethodHandles$Lookup\"\n" + 
+			"    constant #96 class: #97 java/lang/invoke/MethodHandles\n" + 
+			"    constant #97 utf8: \"java/lang/invoke/MethodHandles\"\n" + 
+			"    constant #98 utf8: \"Lookup\"\n" + 
 			"  \n" + 
 			"  // Method descriptor #6 ()V\n" + 
 			"  // Stack: 1, Locals: 1\n" + 
@@ -2092,12 +2145,77 @@ public void test015() throws Exception {
 			"    0  return\n" + 
 			"      Line numbers:\n" + 
 			"        [pc: 0, line: 6]\n" + 
+			"  \n" + 
+			"  // Method descriptor #26 (Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;\n" + 
+			"  // Stack: 3, Locals: 3\n" + 
+			"  private static synthetic java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda arg0);\n" + 
+			"      0  aload_0 [arg0]\n" + 
+			"      1  invokevirtual java.lang.invoke.SerializedLambda.getImplMethodName() : java.lang.String [27]\n" + 
+			"      4  astore_1\n" + 
+			"      5  iconst_m1\n" + 
+			"      6  istore_2\n" + 
+			"      7  aload_1\n" + 
+			"      8  invokevirtual java.lang.String.hashCode() : int [33]\n" + 
+			"     11  lookupswitch default: 39\n" + 
+			"          case -1647345005: 28\n" + 
+			"     28  aload_1\n" + 
+			"     29  ldc <String \"lambda$0\"> [39]\n" + 
+			"     31  invokevirtual java.lang.String.equals(java.lang.Object) : boolean [40]\n" + 
+			"     34  ifeq 39\n" + 
+			"     37  iconst_0\n" + 
+			"     38  istore_2\n" + 
+			"     39  iload_2\n" + 
+			"     40  lookupswitch default: 135\n" + 
+			"          case 0: 60\n" + 
+			"     60  aload_0 [arg0]\n" + 
+			"     61  invokevirtual java.lang.invoke.SerializedLambda.getImplMethodKind() : int [44]\n" + 
+			"     64  bipush 6\n" + 
+			"     66  if_icmpne 135\n" + 
+			"     69  aload_0 [arg0]\n" + 
+			"     70  invokevirtual java.lang.invoke.SerializedLambda.getFunctionalInterfaceClass() : java.lang.String [47]\n" + 
+			"     73  ldc <String \"I\"> [50]\n" + 
+			"     75  invokevirtual java.lang.Object.equals(java.lang.Object) : boolean [52]\n" + 
+			"     78  ifeq 135\n" + 
+			"     81  aload_0 [arg0]\n" + 
+			"     82  invokevirtual java.lang.invoke.SerializedLambda.getFunctionalInterfaceMethodName() : java.lang.String [53]\n" + 
+			"     85  ldc <String \"foo\"> [56]\n" + 
+			"     87  invokevirtual java.lang.Object.equals(java.lang.Object) : boolean [52]\n" + 
+			"     90  ifeq 135\n" + 
+			"     93  aload_0 [arg0]\n" + 
+			"     94  invokevirtual java.lang.invoke.SerializedLambda.getFunctionalInterfaceMethodSignature() : java.lang.String [57]\n" + 
+			"     97  ldc <String \"()V\"> [60]\n" + 
+			"     99  invokevirtual java.lang.Object.equals(java.lang.Object) : boolean [52]\n" + 
+			"    102  ifeq 135\n" + 
+			"    105  aload_0 [arg0]\n" + 
+			"    106  invokevirtual java.lang.invoke.SerializedLambda.getImplClass() : java.lang.String [61]\n" + 
+			"    109  ldc <String \"X\"> [64]\n" + 
+			"    111  invokevirtual java.lang.Object.equals(java.lang.Object) : boolean [52]\n" + 
+			"    114  ifeq 135\n" + 
+			"    117  aload_0 [arg0]\n" + 
+			"    118  invokevirtual java.lang.invoke.SerializedLambda.getImplMethodSignature() : java.lang.String [65]\n" + 
+			"    121  ldc <String \"()V\"> [60]\n" + 
+			"    123  invokevirtual java.lang.Object.equals(java.lang.Object) : boolean [52]\n" + 
+			"    126  ifeq 135\n" + 
+			"    129  invokedynamic 0 foo() : I [68]\n" + 
+			"    134  areturn\n" + 
+			"    135  new java.lang.IllegalArgumentException [69]\n" + 
+			"    138  dup\n" + 
+			"    139  ldc <String \"Invalid lambda deserialization\"> [71]\n" + 
+			"    141  invokespecial java.lang.IllegalArgumentException(java.lang.String) [73]\n" + 
+			"    144  athrow\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 1]\n" + 
+			"      Stack map table: number of frames 4\n" + 
+			"        [pc: 28, append: {java.lang.String, int}]\n" + 
+			"        [pc: 39, same]\n" + 
+			"        [pc: 60, same]\n" + 
+			"        [pc: 135, chop 2 local(s)]\n" + 
 			"\n" + 
 			"  Inner classes:\n" + 
-			"    [inner class info: #41 java/lang/invoke/MethodHandles$Lookup, outer class info: #43 java/lang/invoke/MethodHandles\n" + 
-			"     inner name: #45 Lookup, accessflags: 25 public static final]\n" + 
+			"    [inner class info: #94 java/lang/invoke/MethodHandles$Lookup, outer class info: #96 java/lang/invoke/MethodHandles\n" + 
+			"     inner name: #98 Lookup, accessflags: 25 public static final]\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 33 arguments: {#35,#38,#39}\n" + 
+			"  0 : # 86 arguments: {#87,#90,#91,#92}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X.class", ClassFileBytesDisassembler.SYSTEM);
@@ -2191,14 +2309,14 @@ public void test016() throws Exception {
 			"    constant #54 utf8: \"X\"\n" + 
 			"    constant #55 name_and_type: #56.#14 foo ()V\n" + 
 			"    constant #56 utf8: \"foo\"\n" + 
-			"    constant #57 method_ref: #58.#60 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #58 class: #59 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #59 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #60 name_and_type: #61.#62 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #61 utf8: \"metafactory\"\n" + 
-			"    constant #62 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #63 method handle: invokestatic (6) #57 \n" + 
-			"    constant #64 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #57 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #58 method_ref: #59.#61 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #59 class: #60 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #60 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #61 name_and_type: #62.#63 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #62 utf8: \"metafactory\"\n" + 
+			"    constant #63 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #64 method handle: invokestatic (6) #58 \n" + 
 			"    constant #65 method type: #14 ()V\n" + 
 			"    constant #66 method_ref: #1.#67 X$1Y.lambda$0 ()V\n" + 
 			"    constant #67 name_and_type: #31.#14 lambda$0 ()V\n" + 
@@ -2269,7 +2387,7 @@ public void test016() throws Exception {
 			"     inner name: #76 Lookup, accessflags: 25 public static final]\n" + 
 			"  Enclosing Method: #53  #55 X.foo()V\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 63 arguments: {#65,#68,#69}\n" + 
+			"  0 : # 64 arguments: {#65,#68,#69}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X$1Y.class", ClassFileBytesDisassembler.SYSTEM);
@@ -2363,14 +2481,14 @@ public void test017() throws Exception {
 			"    constant #54 utf8: \"X\"\n" + 
 			"    constant #55 name_and_type: #56.#14 foo ()V\n" + 
 			"    constant #56 utf8: \"foo\"\n" + 
-			"    constant #57 method_ref: #58.#60 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #58 class: #59 java/lang/invoke/LambdaMetafactory\n" + 
-			"    constant #59 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
-			"    constant #60 name_and_type: #61.#62 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
-			"    constant #61 utf8: \"metafactory\"\n" + 
-			"    constant #62 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
-			"    constant #63 method handle: invokestatic (6) #57 \n" + 
-			"    constant #64 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #57 utf8: \"BootstrapMethods\"\n" + 
+			"    constant #58 method_ref: #59.#61 java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #59 class: #60 java/lang/invoke/LambdaMetafactory\n" + 
+			"    constant #60 utf8: \"java/lang/invoke/LambdaMetafactory\"\n" + 
+			"    constant #61 name_and_type: #62.#63 metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n" + 
+			"    constant #62 utf8: \"metafactory\"\n" + 
+			"    constant #63 utf8: \"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\"\n" + 
+			"    constant #64 method handle: invokestatic (6) #58 \n" + 
 			"    constant #65 method type: #14 ()V\n" + 
 			"    constant #66 method_ref: #1.#67 X$1Y.lambda$0 ()V\n" + 
 			"    constant #67 name_and_type: #31.#14 lambda$0 ()V\n" + 
@@ -2441,7 +2559,7 @@ public void test017() throws Exception {
 			"     inner name: #76 Lookup, accessflags: 25 public static final]\n" + 
 			"  Enclosing Method: #53  #55 X.foo()V\n" + 
 			"Bootstrap methods:\n" + 
-			"  0 : # 63 arguments: {#65,#68,#69}\n" + 
+			"  0 : # 64 arguments: {#65,#68,#69}\n" + 
 			"}";
 
 	verifyClassFile(expectedOutput, "X$1Y.class", ClassFileBytesDisassembler.SYSTEM);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SerializableLambdaTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SerializableLambdaTest.java
new file mode 100644
index 0000000..d65bd02
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SerializableLambdaTest.java
@@ -0,0 +1,1213 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.io.File;
+import java.lang.reflect.Modifier;
+import java.util.Map;
+
+import org.eclipse.jdt.core.ToolFactory;
+import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
+import org.eclipse.jdt.core.util.IBootstrapMethodsEntry;
+import org.eclipse.jdt.core.util.IClassFileAttribute;
+import org.eclipse.jdt.core.util.IClassFileReader;
+import org.eclipse.jdt.core.util.IConstantPool;
+import org.eclipse.jdt.core.util.IConstantPoolConstant;
+import org.eclipse.jdt.core.util.IConstantPoolEntry;
+import org.eclipse.jdt.core.util.IConstantPoolEntry2;
+import org.eclipse.jdt.core.util.IMethodInfo;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.core.util.BootstrapMethodsAttribute;
+
+import junit.framework.Test;
+
+public class SerializableLambdaTest extends AbstractRegressionTest {
+
+	static {
+//		TESTS_NUMBERS = new int [] { 40 };
+//		TESTS_NAMES = new String[] { "testTypeVariable" };
+	}
+	
+	public static Class testClass() {
+		return SerializableLambdaTest.class;
+	}
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+	}
+	public SerializableLambdaTest(String testName){
+		super(testName);
+	}
+
+	// Enables the tests to run individually
+	protected Map getCompilerOptions() {
+		Map defaultOptions = super.getCompilerOptions();
+		defaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);
+		defaultOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);
+		defaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);
+		return defaultOptions;
+	}
+	
+	public static final String RUNNER_CLASS = 
+		"public class Y {\n"+
+		"  public static void main(String[]args) {\n"+
+		"    com.foo.X.main(args);\n"+
+		"  }\n"+
+		"}";
+	
+	private static final String HELPER_CLASS =
+		"package util;\n"+
+		"import java.io.*;\n"+
+		"public class Helper {\n"+
+		"public static void print(Object o ) {System.err.println(o);}\n"+
+	    "static byte[][] data;\n"+
+	    "\n"+
+	    "public static void write(Object o) { write(0,o); }\n"+
+	    "public static void write(int i, Object o) {\n"+
+	    "    if (data==null) data=new byte[10][];\n"+
+	    "    try {\n"+
+	    "        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n"+
+	    "        ObjectOutputStream oos = new ObjectOutputStream(baos);\n"+
+	    "        oos.writeObject(o);\n"+
+	    "        oos.flush();\n"+
+	    "        oos.close();\n"+
+	    "        data[i] = baos.toByteArray();\n"+
+	    "    } catch (Exception e) {\n"+
+	    "    }\n"+
+	    "}\n"+
+	    "\n"+
+	    "public static Object read() { return read(0); }\n"+
+	    "public static Object read(int i) {\n"+
+	    "    try {\n"+
+	    "        ByteArrayInputStream bais = new ByteArrayInputStream(data[i]);\n"+
+	    "        ObjectInputStream ois = new ObjectInputStream(bais);\n"+
+	    "        Object o = ois.readObject();\n"+
+	    "        ois.close();\n"+
+	    "        return o;\n"+
+	    "    } catch (Exception e) {\n"+
+	    "    }\n"+
+	    "    return null;\n"+
+	    "}\n"+
+		"}\n";	
+
+	/**
+	 * Verifies that after deserializing it is usable, also that the bootstrap methods attribute indicates use of altMetafactory
+	 */
+	public void test001_simple() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = () -> 3;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m());\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"3",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	/**
+	 * Sanity test, non serializable should have bootstrap methods attribute reference to metafactory.
+	 */
+	public void test002_simpleNonSerializable() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo { int m(); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = () -> 3;\n"+
+					"        System.out.println(f1.m());\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"3");
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+
+	/**
+	 * Basic test that deserializeLambda can cope with two lambda expressions.
+	 */
+	public void test003_twoSerializedLambdas() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null, f2 = null;\n"+
+					"        f1 = () -> 33;\n"+
+					"        f2 = () -> 99;\n"+
+					"        util.Helper.write(0,f1);\n"+
+					"        util.Helper.write(1,f2);\n"+
+					"        f2 = (Foo)util.Helper.read(1);\n"+
+					"        f1 = (Foo)util.Helper.read(0);\n"+
+					"        System.out.println(f1.m());\n"+
+					"        System.out.println(f2.m());\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"33\n99",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n"+
+				"1: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$1:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test004_lambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",
+					"public class Y {\n"+
+					"  public static void main(String[]args) {\n"+
+					"    com.foo.X.main(args);\n"+
+					"  }\n"+
+					"}",
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(int i); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null, f2 = null;\n"+
+					"        f1 = (i) -> i*2;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(4));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"8",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (I)I\n"+
+				"    invokestatic com/foo/X.lambda$0:(I)I\n"+
+				"    (I)I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test005_capturingVariableLambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",
+					"public class Y {\n"+
+					"  public static void main(String[]args) {\n"+
+					"    com.foo.X.main(args);\n"+
+					"  }\n"+
+					"}",
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(int i); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        int multiplier = 3;\n"+
+					"        f1 = (i) -> i * multiplier;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(4));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"12",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (I)I\n"+
+				"    invokestatic com/foo/X.lambda$0:(II)I\n"+
+				"    (I)I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+
+	// differing types, not just int
+	public void test006_capturingVariableLambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",
+					"public class Y {\n"+
+					"  public static void main(String[]args) {\n"+
+					"    com.foo.X.main(args);\n"+
+					"  }\n"+
+					"}",
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(String n); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        int multiplier = 3;\n"+
+					"        f1 = (n) -> Integer.valueOf(n) * multiplier;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(\"33\"));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"99",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (Ljava/lang/String;)I\n"+
+				"    invokestatic com/foo/X.lambda$0:(ILjava/lang/String;)I\n"+
+				"    (Ljava/lang/String;)I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// Fails the same way as javac right now... with NPE (b120)
+	public void xtest007_capturingFieldLambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",
+					"public class Y {\n"+
+					"  public static void main(String[]args) {\n"+
+					"    com.foo.X.main(args);\n"+
+					"  }\n"+
+					"}",
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    int multiplier = 3;\n"+
+					"    interface Foo extends Serializable { int m(int i); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"      new X().run();\n"+
+					"    }\n"+
+					"    public void run() {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (i) -> i * this.multiplier;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(4));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"12",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (I)I\n"+
+				"    invokestatic com/foo/X.lambda$0:(II)I\n"+
+				"    (I)I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test008_capturingTwoVariableLambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",
+					"public class Y {\n"+
+					"  public static void main(String[]args) {\n"+
+					"    com.foo.X.main(args);\n"+
+					"  }\n"+
+					"}",
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { float m(int i, float f); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"      new X().run();\n"+
+					"    }\n"+
+					"    public void run() {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (i,f) -> ((float)i) * f;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(3,4.0f));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"12.0",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (IF)F\n"+
+				"    invokestatic com/foo/X.lambda$0:(IF)F\n"+
+				"    (IF)F\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test009_capturingTwoSlotVariablesLambdaWithParameterInPackage() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",RUNNER_CLASS,
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { double m(int i, long l); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"      new X().run();\n"+
+					"    }\n"+
+					"    public void run() {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (i,l) -> (double)(i*l);\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(3,40L));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"120.0",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (IJ)D\n"+
+				"    invokestatic com/foo/X.lambda$0:(IJ)D\n"+
+				"    (IJ)D\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test010_VarargsLambdaExpression() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",RUNNER_CLASS,
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { String m(String... ss); }\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"      new X().run();\n"+
+					"    }\n"+
+					"    public void run() {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (strings) -> strings[0]+strings[1];\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m(\"abc\",\"def\"));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"abcdef",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    invokestatic com/foo/X.lambda$0:([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    ([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// Fails same way as javac right now... with an NPE (b120)
+	public void xtest011_CapturingInstance() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"Y.java",RUNNER_CLASS,
+					"X.java",
+					"package com.foo;\n"+
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { String m(); }\n"+
+					"\n"+
+					"    String fieldValue = \"hello\";\n"+
+					"    public static void main(String[] args) {\n"+
+					"      new X().run();\n"+
+					"    }\n"+
+					"    public void run() {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = () -> this.fieldValue;\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m());\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"abcdef",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    invokestatic com/foo/X.lambda$0:([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    ([Ljava/lang/String;)Ljava/lang/String;\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "com"+File.separator+"foo"+File.separator+"X.class");
+		checkExpected(expectedOutput,data);
+	}
+
+	public void test012_intersectionCast() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(); }\n"+
+					"    interface Marker {}\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (Foo & Marker) () -> 3;\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m());\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"isMarker?true\n3\nisMarker?true",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    3\n"+ // BitFlags: 0x01 = FLAG_SERIALIZABLE 0x02 = FLAG_MARKER
+				"    1\n"+ // Marker interface count
+				"    X$Marker\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+
+	public void test013_intersectionCast() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"interface Goo {}\n"+
+					"public class X {\n"+
+					"    interface Foo extends Serializable { int m(); }\n"+
+					"    interface Marker {}\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (Foo & Goo & Serializable & Marker) () -> 3;\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        System.out.println(\"isGoo?\"+(f1 instanceof Goo));\n"+
+					"        System.out.println(\"isSerializable?\"+(f1 instanceof Serializable));\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m());\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        System.out.println(\"isGoo?\"+(f1 instanceof Goo));\n"+
+					"        System.out.println(\"isSerializable?\"+(f1 instanceof Serializable));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"isMarker?true\nisGoo?true\nisSerializable?true\n3\nisMarker?true\nisGoo?true\nisSerializable?true",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    3\n"+ // BitFlags: 0x01 = FLAG_SERIALIZABLE 0x02 = FLAG_MARKER
+				"    2\n"+ // Marker interface count
+				"    Goo\n"+
+				"    X$Marker\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test014_intersectionCastAndNotSerializable() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"interface Goo {}\n"+
+					"public class X {\n"+
+					"    interface Foo { int m(); }\n"+
+					"    interface Marker {}\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (Foo & Goo & Marker) () -> 3;\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        System.out.println(\"isGoo?\"+(f1 instanceof Goo));\n"+
+					"        System.out.println(\"isSerializable?\"+(f1 instanceof Serializable));\n"+
+					"        System.out.println(f1.m());\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"isMarker?true\nisGoo?true\nisSerializable?false\n3",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    2\n"+ // BitFlags: 0x02 = FLAG_MARKER
+				"    2\n"+ // Marker interface count
+				"    Goo\n"+
+				"    X$Marker\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test015_serializableViaIntersectionCast() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.*;\n"+
+					"interface Goo {}\n"+
+					"public class X {\n"+
+					"    interface Foo { int m(); }\n"+
+					"    interface Marker {}\n"+
+					"\n"+
+					"    public static void main(String[] args) {\n"+
+					"        Foo f1 = null;\n"+
+					"        f1 = (Foo & Goo & Serializable & Marker) () -> 3;\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        System.out.println(\"isGoo?\"+(f1 instanceof Goo));\n"+
+					"        System.out.println(\"isSerializable?\"+(f1 instanceof Serializable));\n"+
+					"        util.Helper.write(f1);\n"+
+					"        f1 = (Foo)util.Helper.read();\n"+
+					"        System.out.println(f1.m());\n"+
+					"        System.out.println(\"isMarker?\"+(f1 instanceof Marker));\n"+
+					"        System.out.println(\"isGoo?\"+(f1 instanceof Goo));\n"+
+					"        System.out.println(\"isSerializable?\"+(f1 instanceof Serializable));\n"+
+					"    }\n"+
+					"}\n",
+					"Helper.java",HELPER_CLASS,
+					},
+					"isMarker?true\nisGoo?true\nisSerializable?true\n3\nisMarker?true\nisGoo?true\nisSerializable?true",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    3\n"+ // BitFlags: 0x01 = FLAG_SERIALIZABLE 0x02 = FLAG_MARKER
+				"    2\n"+ // Marker interface count
+				"    Goo\n"+
+				"    X$Marker\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// SAM type not first in intersection cast
+	public void test016_bug424211() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		AutoCloseable one = ((Serializable & AutoCloseable) (() -> {}));\n"+
+					"		one.close();\n"+
+					"	}\n"+
+					"}"
+					},
+					"",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()V\n"+
+				"    invokestatic X.lambda$0:()V\n"+
+				"    ()V\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// Now SAM type first
+	public void test017_bug424211() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		AutoCloseable one = ((AutoCloseable & Serializable) (() -> {}));\n"+
+					"		one.close();\n"+
+					"	}\n"+
+					"}"
+					},
+					"",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()V\n"+
+				"    invokestatic X.lambda$0:()V\n"+
+				"    ()V\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// Not Serializable but a regular marker interface
+	public void test018_bug424211() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Marker {}\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		AutoCloseable one = ((Marker & AutoCloseable) (() -> {}));\n"+
+					"		one.close();\n"+
+					"	}\n"+
+					"}"
+					},
+					"",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()V\n"+
+				"    invokestatic X.lambda$0:()V\n"+
+				"    ()V\n"+
+				"    2\n"+
+				"    1\n"+
+				"    Marker\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	// Now SAM type not first and serialization occurring
+	public void test019_bug424211() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface SAM {int m();}\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		SAM one = ((Serializable & SAM) (() -> 3));\n"+
+					"        System.out.println(one.m());\n"+
+					"        util.Helper.write(one);\n"+
+					"        one = (SAM)util.Helper.read();\n"+
+					"        System.out.println(one.m());\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"3\n3",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test020_lambdaNames() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo {int m();}\n"+
+					"interface FooN extends Serializable {int m();}\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		AutoCloseable one = () -> {};\n"+
+					"       new X().m();\n"+
+					"       one.close();\n"+
+					"	}\n"+
+					"   public void m() { Foo f = () -> 3; System.out.println(f.m());}\n"+
+					"   public void n() { FooN f = () -> 3; System.out.println(f.m());}\n"+
+					"}"
+					},
+					"3",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+			"  private static synthetic void lambda$0() throws java.lang.Exception;\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+		expectedOutput =
+			"  private static synthetic int lambda$1();\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test021_lambdaNamesVariants() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo {int m();}\n"+
+					"interface FooSer extends Serializable {int m();}\n"+
+					"interface FooI {int m(int i);}\n"+
+					"interface FooSerI extends Serializable {int m(int i);}\n"+
+					"public class X {\n"+
+					"\n"+
+					"   Foo instanceField = () -> 1;\n"+
+					"   FooSer instanceFieldSer = () -> 2;\n"+
+					"   static Foo staticField = () -> 3;\n"+
+					"   static FooSer staticFieldSer = () -> 4;\n"+
+					"   FooI instanceFieldI = (i) -> 5;\n"+
+					"   FooSerI instanceFieldSerI = (i) -> 6;\n"+
+					"\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"     int x = 4;\n"+
+					"     Foo a = () -> 1;\n"+
+					"     FooSer b = () -> 2;\n"+
+					"     FooI c = (i) -> 3;\n"+
+					"     FooSerI d = (i) -> 4;\n"+
+					"     Foo e = () -> x;\n"+
+					"     FooSer f = () -> x+1;\n"+
+					"     FooI g = (i) -> x+2;\n"+
+					"     FooSerI h = (i) -> x+3;\n"+
+					"	}\n"+
+					"}"
+					},
+					"",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"static lambda$0()I\n"+
+				"static lambda$1()I\n"+
+				"static lambda$2()I\n"+
+				"static lambda$3()I\n"+
+				"static lambda$4(I)I\n"+
+				"static lambda$5(I)I\n"+
+				"static lambda$6()I\n"+
+				"static lambda$7()I\n"+
+				"static lambda$8(I)I\n"+
+				"static lambda$9(I)I\n"+
+				"static lambda$10(I)I\n"+
+				"static lambda$11(I)I\n"+
+				"static lambda$12(II)I\n"+
+				"static lambda$13(II)I\n";
+		String actualOutput = printLambdaMethods(OUTPUT_DIR + File.separator + "X.class");
+		if (!actualOutput.equals(expectedOutput)) {
+			printIt(actualOutput);
+			assertEquals(expectedOutput,actualOutput);
+		}
+	}
+	
+	public void test022_nestedLambdas() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo extends Serializable {int m();}\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"		Foo f = () -> { return ((Foo)()->33).m();};\n"+
+					"       System.out.println(f.m());\n"+
+					"       util.Helper.write(f);\n"+
+					"       f = (Foo)util.Helper.read();\n"+
+					"       System.out.println(f.m());\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"33\n33",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n"+
+				"1: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$1:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test023_lambdasInOtherPlaces_Field() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo extends Serializable {int m();}\n"+
+					"public class X {\n"+
+					"   Foo f = () -> 99;\n" +
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"     new X().run();\n"+
+					"   }\n"+
+					"   public void run() {\n"+
+					"       System.out.println(f.m());\n"+
+					"       util.Helper.write(f);\n"+
+					"       f = (Foo)util.Helper.read();\n"+
+					"       System.out.println(f.m());\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"99\n99",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test024_lambdasInOtherPlaces_MethodParameter() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo extends Serializable {int m();}\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"       new X().run(()->33);\n"+
+					"   }\n"+
+					"   public void run(Foo f) {\n"+
+					"       System.out.println(f.m());\n"+
+					"       util.Helper.write(f);\n"+
+					"       f = (Foo)util.Helper.read();\n"+
+					"       System.out.println(f.m());\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"33\n33",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	public void test025_lambdasWithGenericInferencing() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"import java.util.function.*;\n"+
+					"public class X {\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"       new X().run();\n"+
+					"   }\n"+
+					"   public void run() {\n"+
+					"       IntFunction<Integer> times3 = (IntFunction<Integer> & Serializable) (triple) -> 3 * triple;\n"+
+					"       System.out.println(times3.apply(4));\n"+
+					"       util.Helper.write(times3);\n"+
+					"       times3 = (IntFunction<Integer>)util.Helper.read();\n"+
+					"       System.out.println(times3.apply(4));\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"12\n12",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    (I)Ljava/lang/Object;\n"+
+				"    invokestatic X.lambda$0:(I)Ljava/lang/Integer;\n"+
+				"    (I)Ljava/lang/Integer;\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	public void test026_lambdasInOtherPlaces_Clinit() throws Exception {
+		this.runConformTest(
+				new String[]{
+					"X.java",
+					"import java.io.Serializable;\n"+
+					"interface Foo extends Serializable {int m();}\n"+
+					"public class X {\n"+
+					"   static {\n"+
+					"     Foo f = () -> 99;\n" +
+					"   }\n"+
+					"	public static void main(String argv[]) throws Exception {\n"+
+					"     new X().run();\n"+
+					"   }\n"+
+					"   public void run() {\n"+
+					"       Foo f = ()->99;\n"+
+					"       System.out.println(f.m());\n"+
+					"       util.Helper.write(f);\n"+
+					"       f = (Foo)util.Helper.read();\n"+
+					"       System.out.println(f.m());\n"+
+					"	}\n"+
+					"}",
+					"Helper.java",HELPER_CLASS,
+					},
+					"99\n99",
+					null,
+					true,
+					new String [] { "-Ddummy" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+		String expectedOutput =
+				"0: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$0:()I\n"+
+				"    ()I\n"+
+				"    1\n"+
+				"1: invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;\n"+
+				"  Method arguments:\n"+
+				"    ()I\n"+
+				"    invokestatic X.lambda$1:()I\n"+
+				"    ()I\n"+
+				"    1\n";
+		String data = printBootstrapMethodsAttribute(OUTPUT_DIR + File.separator + "X.class");
+		checkExpected(expectedOutput,data);
+	}
+	
+	
+	// ---
+	
+	private void checkExpected(String expected, String actual) {
+		if (!expected.equals(actual)) {
+			printIt(actual);
+		}
+		assertEquals(expected,actual);
+	}
+	
+	/**
+	 * Print a piece of text with the necessary extra quotes and newlines so that it can be cut/pasted into
+	 * the test source file.
+	 */
+	private void printIt(String text) {
+		String quotedText = text;
+		if (!quotedText.startsWith("\"")) {
+			quotedText = "\""+quotedText.replaceAll("\n", "\\\\n\"+\n\"");
+			quotedText = quotedText.substring(0,quotedText.length()-3);
+		}
+		System.out.println(quotedText);
+	}
+	
+	/**
+	 * Print the bootstrap methods attribute in a very similar fashion to javap for checking.
+	 * Unlike javap the constant pool indexes are not included, to make the test a little less
+	 * fragile.
+	 */
+	private String printBootstrapMethodsAttribute(String filepath) {
+		IClassFileReader cfr = ToolFactory.createDefaultClassFileReader(filepath, IClassFileReader.CLASSFILE_ATTRIBUTES);
+		BootstrapMethodsAttribute bootstrapMethodsAttribute = null;
+		IClassFileAttribute[] attrs = cfr.getAttributes();
+		for (int i=0,max=attrs.length;i<max;i++) {
+			if (new String(attrs[i].getAttributeName()).equals("BootstrapMethods")) {
+				bootstrapMethodsAttribute = (BootstrapMethodsAttribute)attrs[i];
+			}
+		}
+		if (bootstrapMethodsAttribute==null) {
+			return "";
+		}
+		IConstantPool cp = cfr.getConstantPool();
+		StringBuffer sb = new StringBuffer();
+		int bmaLength = bootstrapMethodsAttribute.getBootstrapMethodsLength();
+		for (int i=0;i<bmaLength;i++) {
+			IBootstrapMethodsEntry entry = bootstrapMethodsAttribute.getBootstrapMethods()[i];
+			int mr = entry.getBootstrapMethodReference();
+			IConstantPoolEntry2 icpe = (IConstantPoolEntry2)cfr.getConstantPool().decodeEntry(mr);
+			
+			sb.append(i).append(": ").append(formatReferenceKind(icpe.getReferenceKind()));
+			sb.append(" ").append(format(cp,icpe.getReferenceIndex()));	
+			sb.append("\n");
+			int[] args = entry.getBootstrapArguments();
+			sb.append("  Method arguments:\n");
+			for (int a=0;a<args.length;a++) {
+				sb.append("    ").append(format(cp,args[a])).append("\n");
+			}
+		}
+		return sb.toString();
+	}
+	
+	private String printLambdaMethods(String filepath) {
+		IClassFileReader cfr = ToolFactory.createDefaultClassFileReader(filepath, IClassFileReader.METHOD_INFOS);
+		IMethodInfo[] methodInfos = cfr.getMethodInfos();
+		StringBuffer buf = new StringBuffer();
+		for (int i = 0, max = methodInfos.length; i < max; i++) {
+			IMethodInfo methodInfo = methodInfos[i];
+			if (!new String(methodInfo.getName()).startsWith("lambda")) 
+				continue;
+			int accessFlags = methodInfo.getAccessFlags();
+			if (Modifier.isStatic(accessFlags)) {
+				buf.append("static ");
+			}
+			buf.append(methodInfo.getName());
+			buf.append(methodInfo.getDescriptor());
+			buf.append("\n");
+		}
+		return buf.toString();
+	}
+	
+	String formatReferenceKind(int kind) {
+		switch (kind) {
+			case IConstantPoolConstant.METHOD_TYPE_REF_InvokeStatic:
+				return "invokestatic";
+			default:
+				throw new IllegalStateException("nyi for "+kind);
+		}
+	}
+	
+	String format(IConstantPool cp, int entryNumber) {
+		IConstantPoolEntry entry = cp.decodeEntry(entryNumber);
+		if (entry == null) {
+			return "null";
+		}
+		switch (entry.getKind()) {
+			case IConstantPoolConstant.CONSTANT_Integer:
+				return Integer.toString(entry.getIntegerValue());
+			case IConstantPoolConstant.CONSTANT_Utf8:
+				return new String(entry.getUtf8Value());
+			case IConstantPoolConstant.CONSTANT_Methodref:
+				return new String(entry.getClassName())+"."+new String(entry.getMethodName())+":"+new String(entry.getMethodDescriptor());
+			case IConstantPoolConstant.CONSTANT_MethodHandle:
+				IConstantPoolEntry2 entry2 = (IConstantPoolEntry2)entry;
+				return formatReferenceKind(entry2.getReferenceKind())+" "+format(cp,entry2.getReferenceIndex());
+			case IConstantPoolConstant.CONSTANT_MethodType:
+				return format(cp,((IConstantPoolEntry2)entry).getDescriptorIndex());
+			case IConstantPoolConstant.CONSTANT_Class:
+				return new String(entry.getClassInfoName());
+			default:
+					throw new IllegalStateException("nyi for "+entry.getKind());
+		}
+	}
+	
+}
+
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index e954fb9..ccce167 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -135,6 +135,7 @@ public static Test suite() {
 	since_1_8.add(NullTypeAnnotationTest.class);
 	since_1_8.add(NegativeLambdaExpressionsTest.class);
 	since_1_8.add(LambdaExpressionsTest.class);
+	since_1_8.add(SerializableLambdaTest.class);
 	since_1_8.add(OverloadResolutionTest8.class);
 	since_1_8.add(JSR335ClassFileTest.class);
 	since_1_8.add(ExpressionContextTests.class);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
index 0ee3505..8bc71e7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
+ * Copyright (c) 2013, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                       Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.core.tests;
 
@@ -47,6 +49,7 @@ import org.eclipse.jdt.core.tests.compiler.regression.NegativeTypeAnnotationTest
 import org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest;
 import org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8;
 import org.eclipse.jdt.core.tests.compiler.regression.RepeatableAnnotationTest;
+import org.eclipse.jdt.core.tests.compiler.regression.SerializableLambdaTest;
 import org.eclipse.jdt.core.tests.compiler.regression.TypeAnnotationTest;
 import org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test;
 import org.eclipse.jdt.core.tests.dom.ASTConverter18Test;
@@ -73,6 +76,7 @@ public class RunOnlyJava8Tests extends TestCase {
 			LambdaExpressionSyntaxTest.class,
 			NegativeLambdaExpressionsTest.class,
 			LambdaExpressionsTest.class,
+			SerializableLambdaTest.class,
 			OverloadResolutionTest8.class,
 			JSR335ClassFileTest.class,
 			NegativeTypeAnnotationTest.class,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index da6add0..b90eebb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,13 +16,14 @@
  *							Bug 406982 - [1.8][compiler] Generation of MethodParameters Attribute in classfile
  *							Bug 416885 - [1.8][compiler]IncompatibleClassChange error (edit)
  *							Bug 412149 - [1.8][compiler] Emit repeated annotations into the designated container
- *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
  *                          Bug 409246 - [1.8][compiler] Type annotations on catch parameters not handled properly
  *                          Bug 415541 - [1.8][compiler] Type annotations in the body of static initializer get dropped
  *                          Bug 415399 - [1.8][compiler] Type annotations on constructor results dropped by the code generator
  *                          Bug 415470 - [1.8][compiler] Type annotations on class declaration go vanishing
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
 
@@ -932,6 +933,10 @@ public class ClassFile implements TypeConstants, TypeIds {
 						case SyntheticMethodBinding.FactoryMethod:
 							addSyntheticFactoryMethod(syntheticMethod);
 							break;	
+						case SyntheticMethodBinding.DeserializeLambda:
+							// TODO [andy] do we need to do this after the loop to ensure it is done last?
+							addSyntheticDeserializeLambda(syntheticMethod,this.referenceBinding.syntheticMethods()); 
+							break;
 					}
 				}
 				emittedSyntheticsCount = currentSyntheticsCount;
@@ -2847,52 +2852,131 @@ public class ClassFile implements TypeConstants, TypeIds {
 		if (methodHandlesLookup == null) return 0; // skip bootstrap section, class path problem already reported, just avoid NPE.
 		recordInnerClasses(methodHandlesLookup); // Should be done, it's what javac does also
 		ReferenceBinding javaLangInvokeLambdaMetafactory = this.referenceBinding.scope.getJavaLangInvokeLambdaMetafactory(); 
-		int indexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
-				ConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);
+		
+		// Depending on the complexity of the expression it may be necessary to use the altMetafactory() rather than the metafactory()
+		int indexForMetaFactory = 0;
+		int indexForAltMetaFactory = 0;
 
 		int numberOfBootstraps = functionalExpressionList.size();
 		int localContentsOffset = this.contentsOffset;
 		// Generate the boot strap attribute - since we are only making lambdas and
 		// functional expressions, we know the size ahead of time - this less general
 		// than the full invokedynamic scope, but fine for Java 8
+		
 		int exSize = 10 * numberOfBootstraps + 8;
 		if (exSize + localContentsOffset >= this.contents.length) {
 			resizeContents(exSize);
 		}
-		this.contentsOffset += exSize;
 		
 		int attributeNameIndex =
 			this.constantPool.literalIndex(AttributeNamesConstants.BootstrapMethodsName);
 		this.contents[localContentsOffset++] = (byte) (attributeNameIndex >> 8);
 		this.contents[localContentsOffset++] = (byte) attributeNameIndex;
-		int value = (numberOfBootstraps * 10) + 2;
-		this.contents[localContentsOffset++] = (byte) (value >> 24);
-		this.contents[localContentsOffset++] = (byte) (value >> 16);
-		this.contents[localContentsOffset++] = (byte) (value >> 8);
-		this.contents[localContentsOffset++] = (byte) value;
+		// leave space for attribute_length and remember where to insert it
+		int attributeLengthPosition = localContentsOffset;
+		localContentsOffset += 4;
 		this.contents[localContentsOffset++] = (byte) (numberOfBootstraps >> 8);
 		this.contents[localContentsOffset++] = (byte) numberOfBootstraps;
 		for (int i = 0; i < numberOfBootstraps; i++) {
 			FunctionalExpression functional = (FunctionalExpression) functionalExpressionList.get(i);
-			this.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);
-			this.contents[localContentsOffset++] = (byte) indexForMetaFactory;
 			
-			this.contents[localContentsOffset++] = 0;
-			this.contents[localContentsOffset++] = (byte) 3;
-			
-			int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
-			this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
-			this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;
-
-			int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
-			this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
-			this.contents[localContentsOffset++] = (byte) methodHandleIndex;
-
-			char [] instantiatedSignature = functional.descriptor.signature();
-			int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
-			this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
-			this.contents[localContentsOffset++] = (byte) methodTypeIndex;
+			TypeBinding[] markerInterfaces = null;
+			if (functional instanceof LambdaExpression && 
+				   (((markerInterfaces=((LambdaExpression)functional).getMarkerInterfaces()) != null) ||
+				   	((LambdaExpression)functional).isSerializable)) {
+				
+				LambdaExpression lambdaEx = (LambdaExpression)functional;
+				// may need even more space
+				int extraSpace = 2; // at least 2 more than when the normal metafactory is used, for the bitflags entry
+				if (markerInterfaces != null) {
+					// 2 for the marker interface list size then 2 per marker interface index
+					extraSpace += (2 + 2 * markerInterfaces.length);
+				}
+				if (extraSpace + localContentsOffset >= this.contents.length) {
+					resizeContents(extraSpace);
+				} 
+				
+				if (indexForAltMetaFactory == 0) {
+					indexForAltMetaFactory = 
+						this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
+						ConstantPool.ALTMETAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_ALTMETAFACTORY_SIGNATURE, false);
+				}
+				this.contents[localContentsOffset++] = (byte) (indexForAltMetaFactory >> 8);
+				this.contents[localContentsOffset++] = (byte) indexForAltMetaFactory;
+				
+				// u2 num_bootstrap_arguments
+				this.contents[localContentsOffset++] = 0;
+				this.contents[localContentsOffset++] = (byte) (4+(markerInterfaces==null?0:1+markerInterfaces.length));
+				
+				int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
+				this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;
+	
+				int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
+				this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) methodHandleIndex;
+	
+				char [] instantiatedSignature = functional.descriptor.signature();
+				int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
+				this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) methodTypeIndex;
+
+				// Does this block have to deal with FLAG_BRIDGE? When is it needed?
+				int bitflags = 0;
+				if (lambdaEx.isSerializable) {
+					bitflags |= ClassFileConstants.FLAG_SERIALIZABLE;
+				}
+				if (markerInterfaces!=null) {
+					bitflags |= ClassFileConstants.FLAG_MARKERS;
+				}
+				int indexForBitflags = this.constantPool.literalIndex(bitflags);
+				
+				this.contents[localContentsOffset++] = (byte)(indexForBitflags>>8);
+				this.contents[localContentsOffset++] = (byte)(indexForBitflags);
+				
+				if (markerInterfaces != null) {
+					int markerInterfaceCountIndex =  this.constantPool.literalIndex(markerInterfaces.length);
+					this.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex>>8);
+					this.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex);
+					for (int m = 0, maxm = markerInterfaces.length; m < maxm; m++) {
+						int classTypeIndex = this.constantPool.literalIndexForType(markerInterfaces[m]);
+						this.contents[localContentsOffset++] = (byte)(classTypeIndex>>8);
+						this.contents[localContentsOffset++] = (byte)(classTypeIndex);
+					}					
+				}
+			} else {
+				if (indexForMetaFactory == 0) {
+					indexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
+							ConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);
+				}
+				this.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);
+				this.contents[localContentsOffset++] = (byte) indexForMetaFactory;
+				
+				// u2 num_bootstrap_arguments
+				this.contents[localContentsOffset++] = 0;
+				this.contents[localContentsOffset++] = (byte) 3;
+				
+				int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
+				this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;
+	
+				int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
+				this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) methodHandleIndex;
+	
+				char [] instantiatedSignature = functional.descriptor.signature();
+				int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
+				this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
+				this.contents[localContentsOffset++] = (byte) methodTypeIndex;				
+			}
 		}
+
+		int attributeLength = localContentsOffset - attributeLengthPosition - 4;
+		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 24);
+		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 16);
+		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 8);
+		this.contents[attributeLengthPosition++] = (byte) attributeLength;
+		this.contentsOffset = localContentsOffset;
 		return 1;
 	}
 	private int generateLineNumberAttribute() {
@@ -3293,6 +3377,33 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.contents[this.contentsOffset++] = (byte) (descriptorIndex >> 8);
 		this.contents[this.contentsOffset++] = (byte) descriptorIndex;
 	}
+	
+	public void addSyntheticDeserializeLambda(SyntheticMethodBinding methodBinding, SyntheticMethodBinding[] syntheticMethodBindings ) {
+		generateMethodInfoHeader(methodBinding);
+		int methodAttributeOffset = this.contentsOffset;
+		// this will add exception attribute, synthetic attribute, deprecated attribute,...
+		int attributeNumber = generateMethodInfoAttributes(methodBinding);
+		// Code attribute
+		int codeAttributeOffset = this.contentsOffset;
+		attributeNumber++; // add code attribute
+		generateCodeAttributeHeader();
+		this.codeStream.init(this);
+		this.codeStream.generateSyntheticBodyForDeserializeLambda(methodBinding, syntheticMethodBindings);
+		completeCodeAttributeForSyntheticMethod(
+			methodBinding,
+			codeAttributeOffset,
+			((SourceTypeBinding) methodBinding.declaringClass)
+				.scope
+				.referenceCompilationUnit()
+				.compilationResult
+				.getLineSeparatorPositions());
+		// update the number of attributes
+		if ((this.produceAttributes & ClassFileConstants.ATTR_METHOD_PARAMETERS) != 0) {
+			attributeNumber += generateMethodParameters(methodBinding);
+		}
+		this.contents[methodAttributeOffset++] = (byte) (attributeNumber >> 8);
+		this.contents[methodAttributeOffset] = (byte) attributeNumber;
+	}	
 
 	/**
 	 * INTERNAL USE-ONLY
@@ -4917,6 +5028,12 @@ public class ClassFile implements TypeConstants, TypeIds {
 				if ((arguments = methodBinding.parameters) != null) {
 					for (int i = 0, max = arguments.length; i < max; i++) {
 						final TypeBinding typeBinding = arguments[i];
+						// For the branching complexities in the generated $deserializeLambda$ we need the local variable
+						LocalVariableBinding localVariableBinding = new LocalVariableBinding((" synthetic"+i).toCharArray(), typeBinding, 0, true); //$NON-NLS-1$
+						localVariableBinding.resolvedPosition = i;
+						this.codeStream.record(localVariableBinding);
+						localVariableBinding.recordInitializationStartPC(0);
+						localVariableBinding.recordInitializationEndPC(codeLength);
 						frame.putLocal(resolvedPosition,
 								new VerificationTypeInfo(typeBinding));
 						switch (typeBinding.id) {
@@ -4999,6 +5116,8 @@ public class ClassFile implements TypeConstants, TypeIds {
 			this.bootstrapMethods = new ArrayList();
 		}
 		this.bootstrapMethods.add(expression);
+		// Record which bootstrap method was assigned to the expression
+		expression.bootstrapMethodNumber = this.bootstrapMethods.size() - 1;
 		return this.bootstrapMethods.size() - 1;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 21b473d..2f39b41 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -19,6 +19,8 @@
  *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *							Bug 425142 - [1.8][compiler] NPE in ConstraintTypeFormula.reduceSubType
  *							Bug 425153 - [1.8] Having wildcard allows incompatible types in a lambda expression
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -51,6 +53,7 @@ public abstract class FunctionalExpression extends Expression {
 	protected CompilationResult compilationResult;
 	public BlockScope enclosingScope;
 	protected boolean ellipsisArgument;
+	public int bootstrapMethodNumber = -1;
 	protected static IErrorHandlingPolicy silentErrorHandlingPolicy = DefaultErrorHandlingPolicies.ignoreAllProblems();
 
 	public FunctionalExpression(CompilationResult compilationResult) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 02ba631..e098a9a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -24,9 +24,14 @@
  *							Bug 425142 - [1.8][compiler] NPE in ConstraintTypeFormula.reduceSubType
  *							Bug 425153 - [1.8] Having wildcard allows incompatible types in a lambda expression
  *							Bug 424205 - [1.8] Cannot infer type for diamond type with lambda on method invocation
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.LinkedHashSet;
+import java.util.Set;
+
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
@@ -49,6 +54,7 @@ import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
@@ -86,9 +92,10 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	boolean valueCompatible = false;
 	private boolean shapeAnalysisComplete = false;
 	boolean returnsValue;
+	public boolean isSerializable;
 	boolean returnsVoid;
 	private LambdaExpression original = this;
-	private SyntheticArgumentBinding[] outerLocalVariables = NO_SYNTHETIC_ARGUMENTS;
+	public SyntheticArgumentBinding[] outerLocalVariables = NO_SYNTHETIC_ARGUMENTS;
 	private int outerLocalVariablesSlotSize = 0;
 	public boolean shouldCaptureInstance = false;
 	private boolean assistNode = false;
@@ -162,7 +169,11 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			codeStream.generateOuterAccess(path, this, capturedOuterLocal, currentScope);
 		}
 		signature.append(')');
-		signature.append(this.expectedType.signature());
+		if (this.expectedType instanceof IntersectionCastTypeBinding) {
+			signature.append(((IntersectionCastTypeBinding)this.expectedType).getSAMType(currentScope).signature());
+		} else {
+			signature.append(this.expectedType.signature());
+		}
 		int invokeDynamicNumber = codeStream.classFile.recordBootstrapMethod(this);
 		codeStream.invokeDynamic(invokeDynamicNumber, (this.shouldCaptureInstance ? 1 : 0) + this.outerLocalVariablesSlotSize, 1, this.descriptor.selector, signature.toString().toCharArray());
 		if (!valueRequired)
@@ -371,6 +382,18 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		} else {
 			this.body.resolve(this.scope);
 		}
+		if (this.expectedType instanceof IntersectionCastTypeBinding) {
+			ReferenceBinding[] intersectingTypes =  ((IntersectionCastTypeBinding)this.expectedType).intersectingTypes;
+			for (int t = 0, max = intersectingTypes.length; t < max; t++) {
+				if (intersectingTypes[t].findSuperTypeOriginatingFrom(TypeIds.T_JavaIoSerializable, false /*Serializable is not a class*/) != null) {
+					this.isSerializable = true;
+					break;
+				}
+			}
+		} else if (this.expectedType != null && 
+				   this.expectedType.findSuperTypeOriginatingFrom(TypeIds.T_JavaIoSerializable, false /*Serializable is not a class*/) != null) {
+			this.isSerializable = true;
+		}
 		return this.resolvedType;
 	}
 
@@ -1100,4 +1123,29 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	public int diagnosticsSourceEnd() {
 		return this.body instanceof Block ? this.arrowPosition : this.sourceEnd;
 	}
+
+	public TypeBinding[] getMarkerInterfaces() {
+		if (this.expectedType instanceof IntersectionCastTypeBinding) {
+			Set markerBindings = new LinkedHashSet();
+			TypeBinding[] intersectionTypes = ((IntersectionCastTypeBinding)this.expectedType).intersectingTypes;
+			for (int i = 0,max = intersectionTypes.length; i < max; i++) {
+				TypeBinding typeBinding = intersectionTypes[i];
+				MethodBinding methodBinding = typeBinding.getSingleAbstractMethod(this.scope, false);
+				// Why doesn't getSingleAbstractMethod do as the javadoc says, and return null
+				// when it is not a SAM type
+				if (!(methodBinding instanceof ProblemMethodBinding && ((ProblemMethodBinding)methodBinding).problemId()==ProblemReasons.NoSuchSingleAbstractMethod)) {
+					continue;
+				}
+				if (typeBinding.id == TypeIds.T_JavaIoSerializable) {
+					// Serializable is captured as a bitflag
+					continue;
+				}
+				markerBindings.add(typeBinding);
+			}
+			if (markerBindings.size() > 0) {
+				return (TypeBinding[])markerBindings.toArray(new TypeBinding[markerBindings.size()]);
+			}
+		}
+		return null;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
index b9fa395..f623ad1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,8 @@
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335             
  *							Bug 406982 - [1.8][compiler] Generation of MethodParameters Attribute in classfile
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -155,4 +157,9 @@ public interface ClassFileConstants {
 	int ATTR_STACK_MAP = 0x10; // Stack map attribute: cldc
 	int ATTR_TYPE_ANNOTATION = 0x20; // type annotation attribute (jsr 308)
 	int ATTR_METHOD_PARAMETERS = 0x40; // method parameters attribute (jep 118)
+
+	// See java.lang.invoke.LambdaMetafactory constants - option bitflags when calling altMetaFactory()
+	int FLAG_SERIALIZABLE = 0x01;
+	int FLAG_MARKERS = 0x02;
+	int FLAG_BRIDGES = 0x04;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 2f8f8b7..5634925 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,14 +17,22 @@
  *								bug 421543 - [1.8][compiler] Compiler fails to recognize default method being turned into abstract by subtytpe
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335        
- *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409247 - [1.8][compiler] Verify error with code allocating multidimensional array
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -2507,6 +2515,268 @@ public void generateSyntheticBodyForEnumValueOf(SyntheticMethodBinding methodBin
 	areturn();
 }
 
+// TODO what about blowing the method limit? Ignore for now?
+/**
+ * This is intended to match what javac generates. First there is a switch statement on the hashcode of the lambda method name - based on that
+ * an id is computed (0..N). An unrecognized hash gets the id -1. Then a second switch is on the id and each case here checks all the properties
+ * of the serialized lambda. If they all checkout OK an invokedynamic call to a bootstrap method targeting the altMetafactory. If any of the tests
+ * fail an IllegalArgumentException is thrown. This exception is not typically seen by the 'user', instead they seem to see a NPE when
+ * the lambda does not deserialize properly.
+ */
+public void generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding methodBinding,SyntheticMethodBinding[] syntheticMethodBindings) {
+	initializeMaxLocals(methodBinding);
+	
+	// Compute the list of the serializable lambdas from the full set of synthetic method bindings
+	// Also compute a map of hashcodes to a list of serializable lambdas whose names share a hashcode 
+	List syntheticsForSerializableLambdas = new ArrayList();	
+	Map hashcodesToLambdas = new LinkedHashMap();
+	for (int i=0,max=syntheticMethodBindings.length;i<max;i++) {
+		SyntheticMethodBinding syntheticMethodBinding = syntheticMethodBindings[i];
+		if (syntheticMethodBinding.lambda!=null && syntheticMethodBinding.lambda.isSerializable) {
+			syntheticsForSerializableLambdas.add(syntheticMethodBinding);
+			// TODO can I use > Java 1.4 features here?
+			Integer hashcode = new Integer(new String(syntheticMethodBinding.selector).hashCode());
+			List lambdasForThisHashcode = (List)hashcodesToLambdas.get(hashcode);
+			if (hashcodesToLambdas.get(hashcode)==null) {
+				lambdasForThisHashcode = new ArrayList();
+				hashcodesToLambdas.put(hashcode,lambdasForThisHashcode);
+			}
+			lambdasForThisHashcode.add(syntheticMethodBinding);
+		}
+	}
+	int lambdaCount = syntheticsForSerializableLambdas.size();
+	ClassScope scope = ((SourceTypeBinding)methodBinding.declaringClass).scope;
+	
+	
+	// Generate the first switch, on method name hashcode
+	aload_0();
+	invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, ConstantPool.GetImplMethodName, ConstantPool.GetImplMethodNameSignature);
+	astore_1();
+	LocalVariableBinding lvb1 = new LocalVariableBinding("hashcode".toCharArray(),scope.getJavaLangString(),0,false); //$NON-NLS-1$
+	lvb1.resolvedPosition = 1;
+	addVariable(lvb1);
+	iconst_m1();
+	istore_2();
+	LocalVariableBinding lvb2 = new LocalVariableBinding("id".toCharArray(),TypeBinding.INT,0,false); //$NON-NLS-1$
+	lvb2.resolvedPosition = 2;
+	addVariable(lvb2);
+	aload_1();
+	invokeStringHashCode();
+	
+	BranchLabel label = new BranchLabel(this);
+	CaseLabel defaultLabel = new CaseLabel(this);
+	int numberOfHashcodes = hashcodesToLambdas.size();
+	CaseLabel[] switchLabels = new CaseLabel[numberOfHashcodes];
+	int[] keys = new int[numberOfHashcodes];
+	int[] sortedIndexes = new int[numberOfHashcodes];
+	Set hashcodes = hashcodesToLambdas.keySet();
+	Iterator hashcodeIterator = hashcodes.iterator();
+	int index=0;
+	while (hashcodeIterator.hasNext()) {
+		Integer hashcode = (Integer)hashcodeIterator.next();
+		switchLabels[index] = new CaseLabel(this);
+		keys[index] = hashcode.intValue();
+		sortedIndexes[index] = index;
+		index++;
+	}
+	int[] localKeysCopy;
+	System.arraycopy(keys,0,(localKeysCopy = new int[numberOfHashcodes]),0,numberOfHashcodes);
+	sort(localKeysCopy, 0, numberOfHashcodes-1, sortedIndexes);
+	// TODO need to use a tableswitch at some size threshold?
+	lookupswitch(defaultLabel, keys, sortedIndexes, switchLabels);
+	// TODO cope with multiple names that share the same hashcode	
+	hashcodeIterator = hashcodes.iterator();
+	index = 0;
+	while (hashcodeIterator.hasNext()) {
+		Integer hashcode = (Integer)hashcodeIterator.next();
+		List lambdas = (List)hashcodesToLambdas.get(hashcode);
+		switchLabels[index].place();
+		BranchLabel nextOne = new BranchLabel(this);
+		// Loop through all lambdas that share the same hashcode
+		for (int j=0,max=lambdas.size();j<max;j++) {
+			SyntheticMethodBinding syntheticMethodBinding = (SyntheticMethodBinding)lambdas.get(j);
+			aload_1();
+			ldc(new String(syntheticMethodBinding.selector));
+			invokeStringEquals();
+			ifeq(nextOne);
+			loadInt(index++);
+			istore_2();
+			goto_(label);
+			nextOne.place();
+			nextOne = new BranchLabel(this);
+		}
+		goto_(label);
+	}
+	defaultLabel.place();
+	label.place();
+	
+	// Second block is switching on the lambda id, -1 is the error (unrecognized) case
+	switchLabels = new CaseLabel[lambdaCount];
+	keys = new int[lambdaCount];
+	sortedIndexes = new int[lambdaCount];
+	BranchLabel errorLabel = new BranchLabel(this);
+	defaultLabel = new CaseLabel(this);
+	iload_2();
+	for (int j=0;j<lambdaCount;j++) {
+		switchLabels[j] = new CaseLabel(this);
+		keys[j] = j;
+		sortedIndexes[j] = j;
+	}
+	System.arraycopy(keys,0,(localKeysCopy = new int[lambdaCount]),0,lambdaCount);
+	// TODO no need to sort here? They should all be in order
+	sort(localKeysCopy, 0, lambdaCount-1, sortedIndexes);
+	// TODO need to use a tableswitch at some size threshold?
+	lookupswitch(defaultLabel, keys, sortedIndexes, switchLabels);
+	for (int i=0;i<lambdaCount;i++) {
+		SyntheticMethodBinding syntheticMethodBinding = (SyntheticMethodBinding)syntheticsForSerializableLambdas.get(i);
+		switchLabels[i].place();
+		
+		// Compare ImplMethodKind
+		aload_0();
+		LambdaExpression lambdaEx = syntheticMethodBinding.lambda;
+		MethodBinding mb = lambdaEx.binding;
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetImplMethodKind, ConstantPool.GetImplMethodKindSignature);
+		byte methodKind = 0;
+		if (mb.isStatic()) {
+			methodKind = ClassFileConstants.MethodHandleRefKindInvokeStatic;
+		} else if (mb.isPrivate()) {
+			methodKind = ClassFileConstants.MethodHandleRefKindInvokeSpecial;
+		} else {
+			methodKind = ClassFileConstants.MethodHandleRefKindInvokeVirtual;
+		}
+		bipush(methodKind);// TODO see table below
+		if_icmpne(errorLabel);
+
+		// Compare FunctionalInterfaceClass
+		aload_0();
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetFunctionalInterfaceClass, ConstantPool.GetFunctionalInterfaceClassSignature);
+		ldc(new String(CharOperation.concatWith(lambdaEx.descriptor.declaringClass.compoundName,'/'))); // e.g. "com/foo/X$Foo"
+		invokeObjectEquals();
+		ifeq(errorLabel);
+		
+		// Compare FunctionalInterfaceMethodName
+		aload_0();
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetFunctionalInterfaceMethodName, ConstantPool.GetFunctionalInterfaceMethodNameSignature);
+		ldc(new String(lambdaEx.descriptor.selector)); // e.g. "m"
+		invokeObjectEquals();
+		ifeq(errorLabel);
+
+		// Compare FunctionalInterfaceMethodSignature
+		aload_0();
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetFunctionalInterfaceMethodSignature, ConstantPool.GetFunctionalInterfaceMethodSignatureSignature);
+		ldc(new String(lambdaEx.descriptor.original().signature())); // e.g "()I"
+		invokeObjectEquals();
+		ifeq(errorLabel);
+
+		// Compare ImplClass
+		aload_0();
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetImplClass, ConstantPool.GetImplClassSignature);
+		ldc(new String(CharOperation.concatWith(mb.declaringClass.compoundName,'/'))); // e.g. "com/foo/X"
+		invokeObjectEquals();
+		ifeq(errorLabel);
+
+		// Compare ImplMethodSignature
+		aload_0();
+		invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+				ConstantPool.GetImplMethodSignature, ConstantPool.GetImplMethodSignatureSignature);
+		ldc(new String(mb.signature())); // e.g. "(I)I"
+		invokeObjectEquals();
+		ifeq(errorLabel);
+
+		// Captured arguments
+		StringBuffer sig = new StringBuffer("("); //$NON-NLS-1$
+		index = 0;
+		if (lambdaEx.shouldCaptureInstance) {
+			aload_0();
+			loadInt(index++);
+			invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+					ConstantPool.GetCapturedArg, ConstantPool.GetCapturedArgSignature);
+			checkcast(mb.declaringClass);
+			sig.append(mb.declaringClass.signature());
+		}
+		
+		SyntheticArgumentBinding[] outerLocalVariables = lambdaEx.outerLocalVariables;
+		for (int p=0,max=outerLocalVariables.length;p<max;p++) {
+			aload_0();
+			loadInt(p);
+			invoke(Opcodes.OPC_invokevirtual, 1, 1, ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName, 
+					ConstantPool.GetCapturedArg, ConstantPool.GetCapturedArgSignature);
+			TypeBinding varType = outerLocalVariables[p].type;
+			if (varType.isBaseType()) {
+				checkcast(scope.boxing(varType));
+				generateUnboxingConversion(varType.id);
+				if (varType.id == TypeIds.T_JavaLangLong || varType.id == TypeIds.T_JavaLangDouble) {
+					index++;
+				}
+			} else {
+				checkcast(varType);
+			}
+			index++;
+			sig.append(varType.signature());
+		}
+		sig.append(")"); //$NON-NLS-1$
+		if (lambdaEx.resolvedType instanceof IntersectionCastTypeBinding) {
+			sig.append(((IntersectionCastTypeBinding)lambdaEx.resolvedType).getSAMType(scope).signature());
+		} else {
+			sig.append(lambdaEx.resolvedType.signature());
+		}
+		// Example: invokeDynamic(0, 0, 1, "m".toCharArray(), "()Lcom/foo/X$Foo;".toCharArray());
+		invokeDynamic(lambdaEx.bootstrapMethodNumber, index, 1, lambdaEx.descriptor.selector, sig.toString().toCharArray());
+		areturn();
+	}
+	
+	removeVariable(lvb1);
+	removeVariable(lvb2);
+	defaultLabel.place();
+	errorLabel.place();
+	// Code: throw new IllegalArgumentException("Invalid lambda deserialization")
+	new_(scope.getJavaLangIllegalArgumentException());
+	dup();
+	ldc("Invalid lambda deserialization"); //$NON-NLS-1$ // TODO into a constant?		
+	// invokespecial: java.lang.IllegalArgumentException.<init>(Ljava/lang/String;)V
+	invoke(
+			Opcodes.OPC_invokespecial,
+			2, // receiverAndArgsSize
+			0, // return type size
+			ConstantPool.JavaLangIllegalArgumentExceptionConstantPoolName,
+			ConstantPool.Init,
+			ConstantPool.IllegalArgumentExceptionConstructorSignature);
+	athrow();
+}
+
+/**
+ * Based on the supplied value add the most efficient load instruction to the code stream for that value.
+ * Note: Does not handle  negative values.
+ */
+public void loadInt(int value) {
+	if (value<6) {
+		if (value==0) {
+			iconst_0();
+		} else if (value==1) {
+			iconst_1();
+		} else if (value==2) {
+			iconst_2();
+		} else if (value==3) {
+			iconst_3();
+		} else if (value==4) {
+			iconst_4();
+		} else if (value==5) {
+			iconst_5();
+		}
+	} else if (value < 128) {
+		// TODO [andy] testcases that hit this
+		bipush((byte)value);
+	} else {
+		// TODO [andy] testcases that hit this, yikes
+		ldc(value);
+	}
+}
+
 //static X[] values() {
 // X[] values;
 // int length;
@@ -2930,6 +3200,7 @@ public void generateUnboxingConversion(int unboxedTypeID) {
 	}
 }
 
+
 /*
  * Wide conditional branch compare, improved by swapping comparison opcode
  *   ifeq WideTarget
@@ -4658,6 +4929,16 @@ public void invokeStringEquals() {
 			ConstantPool.Equals,
 			ConstantPool.EqualsSignature);
 }
+public void invokeObjectEquals() {
+	// invokevirtual: java.lang.Object.equals()
+	invoke(
+			Opcodes.OPC_invokevirtual,
+			2, // receiverAndArgsSize
+			1, // return type size
+			ConstantPool.JavaLangObjectConstantPoolName,
+			ConstantPool.Equals,
+			ConstantPool.EqualsSignature);
+}
 public void invokeStringHashCode() {
 	// invokevirtual: java.lang.String.hashCode()
 	invoke(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java
index 06144ad..0c46413 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,8 @@
  *							Bug 406982 - [1.8][compiler] Generation of MethodParameters Attribute in classfile
  *							Bug 416885 - [1.8][compiler]IncompatibleClassChange error (edit)
  *							Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
@@ -147,6 +149,7 @@ public class ConstantPool implements ClassFileConstants, TypeIds {
 	public static final char[] INVOKE_METHOD_METHOD_SIGNATURE = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;".toCharArray(); //$NON-NLS-1$
 	public static final char[][] JAVA_LANG_REFLECT_ACCESSIBLEOBJECT = new char[][] {TypeConstants.JAVA, TypeConstants.LANG, TypeConstants.REFLECT, "AccessibleObject".toCharArray()}; //$NON-NLS-1$
 	public static final char[][] JAVA_LANG_REFLECT_ARRAY = new char[][] {TypeConstants.JAVA, TypeConstants.LANG, TypeConstants.REFLECT, "Array".toCharArray()}; //$NON-NLS-1$
+	public static final char[] IllegalArgumentExceptionConstructorSignature = "(Ljava/lang/String;)V".toCharArray(); //$NON-NLS-1$
 	// predefined type constant names
 	public static final char[] JavaIoPrintStreamSignature = "Ljava/io/PrintStream;".toCharArray(); //$NON-NLS-1$
 	public static final char[] JavaLangAssertionErrorConstantPoolName = "java/lang/AssertionError".toCharArray(); //$NON-NLS-1$
@@ -180,6 +183,7 @@ public class ConstantPool implements ClassFileConstants, TypeIds {
 	public static final char[] JavaLangObjectSignature = "Ljava/lang/Object;".toCharArray(); //$NON-NLS-1$
 	public static final char[] JavaLangSystemConstantPoolName = "java/lang/System".toCharArray(); //$NON-NLS-1$
 	public static final char[] JavaLangThrowableConstantPoolName = "java/lang/Throwable".toCharArray(); //$NON-NLS-1$
+	public static final char[] JavaLangIllegalArgumentExceptionConstantPoolName = "java/lang/IllegalArgumentException".toCharArray(); //$NON-NLS-1$
 	public static final char[] JavaLangVoidConstantPoolName = "java/lang/Void".toCharArray(); //$NON-NLS-1$
 	public static final char[] JavaUtilIteratorConstantPoolName = "java/util/Iterator".toCharArray(); //$NON-NLS-1$
 	public static final char[] LongConstrSignature = "(J)V".toCharArray(); //$NON-NLS-1$
@@ -264,6 +268,27 @@ public class ConstantPool implements ClassFileConstants, TypeIds {
 	// Java 8 lambda support
 	public static final char[] METAFACTORY = "metafactory".toCharArray(); //$NON-NLS-1$
 	public static final char[] JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE = "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;".toCharArray(); //$NON-NLS-1$
+	public static final char[] ALTMETAFACTORY = "altMetafactory".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_ALTMETAFACTORY_SIGNATURE = 
+			"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JavaLangInvokeSerializedLambda = "Ljava/lang/invoke/SerializedLambda;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JavaLangInvokeSerializedLambdaConstantPoolName = "java/lang/invoke/SerializedLambda".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodName = "getImplMethodName".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodNameSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodKind = "getImplMethodKind".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodKindSignature = "()I".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceClass = "getFunctionalInterfaceClass".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceClassSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceMethodName = "getFunctionalInterfaceMethodName".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceMethodNameSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceMethodSignature = "getFunctionalInterfaceMethodSignature".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetFunctionalInterfaceMethodSignatureSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplClass = "getImplClass".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplClassSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodSignature = "getImplMethodSignature".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetImplMethodSignatureSignature = "()Ljava/lang/String;".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetCapturedArg = "getCapturedArg".toCharArray(); //$NON-NLS-1$
+	public static final char[] GetCapturedArgSignature = "(I)Ljava/lang/Object;".toCharArray(); //$NON-NLS-1$
 	// Java 8 repeatable annotation support
 	public static final char[] JAVA_LANG_ANNOTATION_REPEATABLE = "Ljava/lang/annotation/Repeatable;".toCharArray(); //$NON-NLS-1$
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
index 1db5593..5a9ff10 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.lookup;
@@ -179,4 +181,22 @@ public class IntersectionCastTypeBinding extends ReferenceBinding {
 	public String toString() {
 	    return debugName();
 	}
+
+	public TypeBinding getSAMType(Scope scope) {
+		TypeBinding samType = null;
+		for (int i = 0, max = this.intersectingTypes.length; i < max; i++) {
+			TypeBinding typeBinding = this.intersectingTypes[i];
+			MethodBinding methodBinding = typeBinding.getSingleAbstractMethod(scope, false);
+			// Why doesn't getSingleAbstractMethod do as the javadoc says, and return null
+			// when it is not a SAM type
+			if (methodBinding instanceof ProblemMethodBinding && ((ProblemMethodBinding) methodBinding).problemId()==ProblemReasons.NoSuchSingleAbstractMethod) {
+				continue;
+			}
+			if (samType != null) {
+				return null; // There is more than one (!), so we don't know which
+			}
+			samType = typeBinding;
+		}
+		return samType;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index c74bb45..6a4b6a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -29,6 +29,8 @@
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *  							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          	Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -2690,6 +2692,12 @@ public abstract class Scope {
 		unitScope.recordQualifiedReference(TypeConstants.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY);
 		return unitScope.environment.getResolvedType(TypeConstants.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY, this);
 	}
+	
+	public final ReferenceBinding getJavaLangInvokeSerializedLambda() {
+		CompilationUnitScope unitScope = compilationUnitScope();
+		unitScope.recordQualifiedReference(TypeConstants.JAVA_LANG_INVOKE_SERIALIZEDLAMBDA);
+		return unitScope.environment.getResolvedType(TypeConstants.JAVA_LANG_INVOKE_SERIALIZEDLAMBDA, this);
+	}
 
 	public final ReferenceBinding getJavaLangInvokeMethodHandlesLookup() {
 		CompilationUnitScope unitScope = compilationUnitScope();
@@ -2720,6 +2728,13 @@ public abstract class Scope {
 		unitScope.recordQualifiedReference(TypeConstants.JAVA_LANG_THROWABLE);
 		return unitScope.environment.getResolvedType(TypeConstants.JAVA_LANG_THROWABLE, this);
 	}
+	
+	public final ReferenceBinding getJavaLangIllegalArgumentException() {
+		CompilationUnitScope unitScope = compilationUnitScope();
+		unitScope.recordQualifiedReference(TypeConstants.JAVA_LANG_ILLEGALARGUMENTEXCEPTION);
+		return unitScope.environment.getResolvedType(TypeConstants.JAVA_LANG_ILLEGALARGUMENTEXCEPTION, this);
+	}
+	
 	public final ReferenceBinding getJavaUtilIterator() {
 		CompilationUnitScope unitScope = compilationUnitScope();
 		unitScope.recordQualifiedReference(TypeConstants.JAVA_UTIL_ITERATOR);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 215884f..fc8211b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,8 +34,10 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
- *     Till Brychcy - Contributions for
+ *      Till Brychcy - Contributions for
  *     							bug 415269 - NonNullByDefault is not always inherited to nested classes
+ *      Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          	Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -601,6 +603,17 @@ public SyntheticMethodBinding addSyntheticMethod(LambdaExpression lambda) {
 	} else {
 		lambdaMethod = lambdaMethods[0];
 	}
+	
+	// Create a $deserializeLambda$ method if necessary, one is shared amongst all lambdas
+	if (lambda.isSerializable) {
+		SyntheticMethodBinding[] deserializeLambdaMethods = (SyntheticMethodBinding[]) this.synthetics[SourceTypeBinding.METHOD_EMUL].get(TypeConstants.DESERIALIZE_LAMBDA);
+		if (deserializeLambdaMethods == null) {
+			SyntheticMethodBinding deserializeLambdaMethod = new SyntheticMethodBinding(this);
+			this.synthetics[SourceTypeBinding.METHOD_EMUL].put(TypeConstants.DESERIALIZE_LAMBDA,deserializeLambdaMethods = new SyntheticMethodBinding[1]);
+			deserializeLambdaMethods[0] = deserializeLambdaMethod;
+		}
+	}
+	
 	return lambdaMethod;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java
index b293ad4..d11805b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,8 @@
  *		IBM Corporation - initial API and implementation
  *		Stephan Herrmann - Contribution for
  *								bug 400710 - [1.8][compiler] synthetic access to default method generates wrong code
+ *      Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          	Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -52,6 +54,7 @@ public class SyntheticMethodBinding extends MethodBinding {
 	public final static int ArrayConstructor = 14; // X[]::new
 	public static final int ArrayClone = 15; // X[]::clone
     public static final int FactoryMethod = 16; // for indy call to private constructor.
+    public static final int DeserializeLambda = 17; // For supporting lambda deserialization.
     
 	public int sourceStart = 0; // start position of the matching declaration
 	public int index; // used for sorting access methods in the class file
@@ -284,6 +287,23 @@ public class SyntheticMethodBinding extends MethodBinding {
 	}
 	
 	/**
+	 * Construct $deserializeLambda$ method
+	 */
+	public SyntheticMethodBinding(SourceTypeBinding declaringClass) {
+		this.declaringClass = declaringClass;
+		this.selector = TypeConstants.DESERIALIZE_LAMBDA;
+		this.modifiers = ClassFileConstants.AccPrivate | ClassFileConstants.AccStatic | ClassFileConstants.AccSynthetic;
+		this.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
+		this.thrownExceptions = Binding.NO_EXCEPTIONS;
+		this.returnType = declaringClass.scope.getJavaLangObject();
+	    this.parameters = new TypeBinding[]{declaringClass.scope.getJavaLangInvokeSerializedLambda()};
+	    this.purpose = SyntheticMethodBinding.DeserializeLambda;
+		SyntheticMethodBinding[] knownAccessMethods = declaringClass.syntheticMethods();
+		int methodId = knownAccessMethods == null ? 0 : knownAccessMethods.length;
+		this.index = methodId;
+	}
+	
+	/**
 	 * Construct enum special methods: values or valueOf methods
 	 */
 	public SyntheticMethodBinding(SourceTypeBinding declaringEnum, int startIndex, int endIndex) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index fada286..3b1f386 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,6 +21,8 @@
  *    Jesper S Moller - Contributions for
  *								Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+ *    Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                              Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -92,6 +94,7 @@ public interface TypeConstants {
     char[] UPPER_ANNOTATION_TYPE = "ANNOTATION_TYPE".toCharArray(); //$NON-NLS-1$
     char[] UPPER_PACKAGE = "PACKAGE".toCharArray(); //$NON-NLS-1$
     char[] ANONYMOUS_METHOD = "lambda$".toCharArray(); //$NON-NLS-1$
+    char[] DESERIALIZE_LAMBDA = "$deserializeLambda$".toCharArray(); //$NON-NLS-1$
     
 	// jsr308
 	char[] TYPE_USE_TARGET  = "TYPE_USE".toCharArray(); //$NON-NLS-1$
@@ -193,6 +196,7 @@ public interface TypeConstants {
 			"MethodHandle$PolymorphicSignature".toCharArray() //$NON-NLS-1$
 	};
 	char[][] JAVA_LANG_INVOKE_LAMBDAMETAFACTORY = {JAVA, LANG, INVOKE, "LambdaMetafactory".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_INVOKE_SERIALIZEDLAMBDA = {JAVA, LANG, INVOKE, "SerializedLambda".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_INVOKE_METHODHANDLES = {JAVA, LANG, INVOKE, "MethodHandles".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_AUTOCLOSEABLE =  {JAVA, LANG, "AutoCloseable".toCharArray()}; //$NON-NLS-1$
 	char[] CLOSE = "close".toCharArray(); //$NON-NLS-1$
