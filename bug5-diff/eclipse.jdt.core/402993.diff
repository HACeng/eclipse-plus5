commit 5f97e12f962e721b3d706fc12b2c5617a3adbc7d
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Apr 12 00:11:33 2013 +0200

    Bug 402993 - [null] Follow up of bug 401088: Missing warning about
    redundant null check

115	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
15	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
44	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 5346099..7dba22b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -30,6 +30,7 @@
  *							bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -58,9 +59,9 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "test0037_conditional_expression" };
-//		TESTS_NAMES = new String[] { "test0515_try_finally" };
-//		TESTS_NAMES = new String[] { "testBug319201c" };
+//		TESTS_NAMES = new String[] { "test0555_try_catch" };
+//		TESTS_NAMES = new String[] { "testBug401088" };
+//		TESTS_NAMES = new String[] { "testBug402993" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -16518,4 +16519,115 @@ public void test401092a() {
 			"}\n"
 		});
 }
+// Bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+public void testBug402993() {
+	runNegativeTest(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" + 
+			"\n" + 
+			"	private static void occasionallyThrowException() throws Exception {\n" + 
+			"		if ((System.currentTimeMillis() & 1L) != 0L)\n" + 
+			"			throw new Exception();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void open() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void close() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static void main(String s[]) {\n" + 
+			"		Exception exc = null;\n" +
+			"		try {\n" + 
+			"			open();\n" + 
+			"			// do more things\n" + 
+			"		}\n" + 
+			"		catch (Exception e) {\n" + 
+			"			if (exc == null) // no warning here ??\n" + 
+			"				;\n" + 
+			"		}\n" + 
+			"		finally {\n" + 
+			"			try {\n" + 
+			"				close();\n" + 
+			"			}\n" + 
+			"			catch (Exception e) {\n" + 
+			"				if (exc == null) // No warning here ??\n" + 
+			"					exc = e;\n" + 
+			"			}\n" + 
+			"		}\n" + 
+			"	}\n" + 
+			"}\n"
+		}, 
+		"----------\n" + 
+		"1. ERROR in Test.java (at line 23)\n" + 
+		"	if (exc == null) // no warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 31)\n" + 
+		"	if (exc == null) // No warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n");
+}
+// Bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+// variant with finally block in inner try
+public void testBug402993a() {
+	runNegativeTest(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" + 
+			"\n" + 
+			"	private static void occasionallyThrowException() throws Exception {\n" + 
+			"		if ((System.currentTimeMillis() & 1L) != 0L)\n" + 
+			"			throw new Exception();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void open() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void close() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static void main(String s[]) {\n" + 
+			"		Exception exc = null;\n" + 
+			"		try {\n" + 
+			"			open();\n" + 
+			"			// do more things\n" + 
+			"		}\n" + 
+			"		catch (Exception e) {\n" + 
+			"			if (exc == null) // no warning here ??\n" + 
+			"				;\n" + 
+			"		}\n" + 
+			"		finally {\n" + 
+			"			try {\n" + 
+			"				close();\n" + 
+			"			}\n" + 
+			"			catch (Exception e) {\n" + 
+			"				if (exc == null) // No warning here ??\n" + 
+			"					exc = e;\n" + 
+			"			} finally {\n" +
+			"				System.out.print(1);\n" +
+			"			}\n" +
+			"		}\n" + 
+			"	}\n" + 
+			"}\n"
+		}, 
+		"----------\n" + 
+		"1. ERROR in Test.java (at line 23)\n" + 
+		"	if (exc == null) // no warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 31)\n" + 
+		"	if (exc == null) // No warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 516e4ef..434d4c0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 331649 - [compiler][null] consider null annotations for fields
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -104,8 +105,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	}
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
-		if (flowContext.initsOnFinally != null)
-			flowContext.markFinallyNullStatus(local, nullStatus);
+		flowContext.markFinallyNullStatus(local, nullStatus);
 	}
 	return flowInfo;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index 491e0eb..e7af82f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -42,8 +43,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			flowInfo = stat.analyseCode(this.scope, flowContext, flowInfo);
 		}
 		// record the effect of stat on the finally block of an enclosing try-finally, if any:
-		if (flowContext.initsOnFinally != null)
-			flowContext.mergeFinallyNullInfo(flowInfo);
+		flowContext.mergeFinallyNullInfo(flowInfo);
 		if (enableSyntacticNullAnalysisForFields) {
 			flowContext.expireNullCheckedFieldInfo();
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
index 3ab010e..f6aaeb1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -54,8 +55,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		if (local != null) {
 			// compound assignment results in a definitely non null value for String
 			flowInfo.markAsDefinitelyNonNull(local);
-			if (flowContext.initsOnFinally != null)
-				flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
+			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
 	}
 	return flowInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 37f3bd3..527c2ca 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -551,9 +552,7 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 		}
 		flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-		if (flowContext.initsOnFinally != null) {
-			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
-		}
+		flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		return true;
 	}
 	return false; // not checked
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
index 7e1f697..655375b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2012 GK Software AG and others.
+ * Copyright (c) 2011, 2013 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -626,8 +626,7 @@ public class FakedTrackingVariable extends LocalDeclaration {
 		do {
 			flowInfo.markAsDefinitelyNonNull(current.binding);
 			current.globalClosingState |= CLOSE_SEEN;
-			if (flowContext.initsOnFinally != null)
-				flowContext.markFinallyNullStatus(this.binding, FlowInfo.NON_NULL);
+			flowContext.markFinallyNullStatus(this.binding, FlowInfo.NON_NULL);
 			current = current.innerTracker;
 		} while (current != null);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 13a8c1d..94c7838 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -15,6 +15,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -240,9 +241,7 @@ private void checkInternalNPE(BlockScope scope, FlowContext flowContext, FlowInf
 			}
 			flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-			if (flowContext.initsOnFinally != null) {
-				flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
-			}
+			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
 	}
 	if (this.otherBindings != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 5d937f8..14a3ca5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -17,6 +17,7 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *								bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -116,9 +117,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.subRoutineStartLabel == null) {
 		// no finally block -- this is a simplified copy of the else part
 		if (flowContext instanceof FinallyFlowContext) {
-			// if this TryStatement sits inside another TryStatement,
-			// report into the initsOnFinally of the outer try-block.
-			flowContext.initsOnFinally = ((FinallyFlowContext)flowContext).tryContext.initsOnFinally;
+			// if this TryStatement sits inside another TryStatement, establish the wiring so that
+			// FlowContext.markFinallyNullStatus can report into initsOnFinally of the outer try context:
+			FinallyFlowContext finallyContext = (FinallyFlowContext) flowContext;
+			finallyContext.outerTryContext = finallyContext.tryContext;
 		}
 		// process the try block in a context handling the local exceptions.
 		ExceptionHandlingFlowContext handlingContext =
@@ -130,6 +132,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				null,
 				this.scope,
 				flowInfo);
+		handlingContext.conditionalLevel = 0; // start collection initsOnFinally
 		// only try blocks initialize that member - may consider creating a
 		// separate class if needed
 
@@ -234,11 +237,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				if (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579
 					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
+				flowContext.conditionalLevel++;
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
 						currentScope,
 						flowContext,
 						catchInfo);
+				flowContext.conditionalLevel--;
 				this.catchExitInitStateIndexes[i] = currentScope.methodScope().recordInitializationStates(catchInfo);
 				this.catchExits[i] =
 					(catchInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0;
@@ -249,9 +254,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			currentScope.methodScope().recordInitializationStates(tryInfo);
 
 		// chain up null info registry
-		if (flowContext.initsOnFinally != null) {
-			flowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);
-		}
+		flowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);
 
 		return tryInfo;
 	} else {
@@ -261,9 +264,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// analyse finally block first
 		insideSubContext = new InsideSubRoutineFlowContext(flowContext, this);
 		if (flowContext instanceof FinallyFlowContext) {
-			// if this TryStatement sits inside another TryStatement,
-			// let the nested context report into the initsOnFinally of the outer try-block.
-			insideSubContext.initsOnFinally = ((FinallyFlowContext)flowContext).tryContext.initsOnFinally;
+			// if this TryStatement sits inside another TryStatement, establish the wiring so that
+			// FlowContext.markFinallyNullStatus can report into initsOnFinally of the outer try context:
+			insideSubContext.outerTryContext = ((FinallyFlowContext)flowContext).tryContext;
 		}
 
 		// process the try block in a context handling the local exceptions.
@@ -277,6 +280,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				null,
 				this.scope,
 				flowInfo);
+		insideSubContext.initsOnFinally = handlingContext.initsOnFinally; 
 
 		subInfo =
 			this.finallyBlock
@@ -285,6 +289,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					finallyContext = new FinallyFlowContext(flowContext, this.finallyBlock, handlingContext),
 					flowInfo.nullInfoLessUnconditionalCopy())
 				.unconditionalInits();
+		handlingContext.conditionalLevel = 0; // start collection initsOnFinally only after analysing the finally block
 		if (subInfo == FlowInfo.DEAD_END) {
 			this.bits |= ASTNode.IsSubRoutineEscaping;
 			this.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);
@@ -402,6 +407,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				if (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579
 					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
+				insideSubContext.conditionalLevel = 1;
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
 						currentScope,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
index 4beaa90..b5d6c7e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -78,7 +79,6 @@ public ExceptionHandlingFlowContext(
 	this(parent, tryStatement, handledExceptions, exceptionToCatchBlockMap, 
 			tryStatement.catchArguments, initializationParent, scope, flowInfo.unconditionalInits());
 	this.initsOnFinally = flowInfo.unconditionalCopy();
-	this.conditionalLevel = 0;	
 }
 ExceptionHandlingFlowContext(
 		FlowContext parent,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 2efcbd9..8d8333f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -32,7 +32,7 @@ import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
  * Reflects the context of code analysis, keeping track of enclosing
  *	try statements, exception handlers, etc...
  */
-public class FinallyFlowContext extends FlowContext {
+public class FinallyFlowContext extends TryFlowContext {
 
 	Reference[] finalAssignments;
 	VariableBinding[] finalVariables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 664d240..d89cb29 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,7 @@
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -643,11 +644,11 @@ public char[] labelName() {
 
 /**
  * Record a given null status of a given local variable as it will be seen in the finally block.
- * Precondition: caller has checked that initsOnFinally != null.
  * @param local the local variable being observed
  * @param nullStatus the null status of local at the current point in the flow
  */
 public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
+	if (this.initsOnFinally == null) return;
 	if (this.conditionalLevel == -1) return;
 	if (this.conditionalLevel == 0) {
 		// node is unconditionally reached, take nullStatus as is:
@@ -667,6 +668,7 @@ public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
  * @param flowInfo info after executing a statement of the try-block.
  */
 public void mergeFinallyNullInfo(FlowInfo flowInfo) {
+	if (this.initsOnFinally == null) return;
 	if (this.conditionalLevel == -1) return;
 	if (this.conditionalLevel == 0) {
 		// node is unconditionally reached, take null info as is:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
index 4daa2c7..451a6c7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
@@ -17,7 +17,7 @@ import org.eclipse.jdt.internal.compiler.ast.SubRoutineStatement;
  * Reflects the context of code analysis, keeping track of enclosing
  *	try statements, exception handlers, etc...
  */
-public class InsideSubRoutineFlowContext extends FlowContext {
+public class InsideSubRoutineFlowContext extends TryFlowContext {
 
 	public UnconditionalFlowInfo initsOnReturn;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
new file mode 100644
index 0000000..1623e51
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.flow;
+
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+
+/**
+ * Shared implementation for try-statement-related flow contexts.
+ */
+public abstract class TryFlowContext extends FlowContext {
+
+	/**
+	 * For a try statement nested inside a finally block this reference
+	 * points to the flow context of the outer try block, for access to its initsOnFinally.
+	 */
+	public FlowContext outerTryContext;
+
+	public TryFlowContext(FlowContext parent, ASTNode associatedNode) {
+		super(parent, associatedNode);
+	}
+	
+	public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
+		if (this.outerTryContext != null) {
+			this.outerTryContext.markFinallyNullStatus(local, nullStatus);
+		}
+		super.markFinallyNullStatus(local, nullStatus);
+	}
+
+	public void mergeFinallyNullInfo(FlowInfo flowInfo) {
+		if (this.outerTryContext != null) {
+			this.outerTryContext.mergeFinallyNullInfo(flowInfo);
+		}
+		super.mergeFinallyNullInfo(flowInfo);
+	}
+}
commit fa66834f9f4ec8541916655f7830d28cd8630692
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu May 16 12:47:42 2013 +0530

    Bug 402993 - [null] Follow up of bug 401088: Missing warning about
    redundant null check

115	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
15	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
44	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 5346099..7dba22b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -30,6 +30,7 @@
  *							bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -58,9 +59,9 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "test0037_conditional_expression" };
-//		TESTS_NAMES = new String[] { "test0515_try_finally" };
-//		TESTS_NAMES = new String[] { "testBug319201c" };
+//		TESTS_NAMES = new String[] { "test0555_try_catch" };
+//		TESTS_NAMES = new String[] { "testBug401088" };
+//		TESTS_NAMES = new String[] { "testBug402993" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -16518,4 +16519,115 @@ public void test401092a() {
 			"}\n"
 		});
 }
+// Bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+public void testBug402993() {
+	runNegativeTest(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" + 
+			"\n" + 
+			"	private static void occasionallyThrowException() throws Exception {\n" + 
+			"		if ((System.currentTimeMillis() & 1L) != 0L)\n" + 
+			"			throw new Exception();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void open() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void close() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static void main(String s[]) {\n" + 
+			"		Exception exc = null;\n" +
+			"		try {\n" + 
+			"			open();\n" + 
+			"			// do more things\n" + 
+			"		}\n" + 
+			"		catch (Exception e) {\n" + 
+			"			if (exc == null) // no warning here ??\n" + 
+			"				;\n" + 
+			"		}\n" + 
+			"		finally {\n" + 
+			"			try {\n" + 
+			"				close();\n" + 
+			"			}\n" + 
+			"			catch (Exception e) {\n" + 
+			"				if (exc == null) // No warning here ??\n" + 
+			"					exc = e;\n" + 
+			"			}\n" + 
+			"		}\n" + 
+			"	}\n" + 
+			"}\n"
+		}, 
+		"----------\n" + 
+		"1. ERROR in Test.java (at line 23)\n" + 
+		"	if (exc == null) // no warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 31)\n" + 
+		"	if (exc == null) // No warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n");
+}
+// Bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
+// variant with finally block in inner try
+public void testBug402993a() {
+	runNegativeTest(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" + 
+			"\n" + 
+			"	private static void occasionallyThrowException() throws Exception {\n" + 
+			"		if ((System.currentTimeMillis() & 1L) != 0L)\n" + 
+			"			throw new Exception();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void open() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	private static void close() throws Exception {\n" + 
+			"		occasionallyThrowException();\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static void main(String s[]) {\n" + 
+			"		Exception exc = null;\n" + 
+			"		try {\n" + 
+			"			open();\n" + 
+			"			// do more things\n" + 
+			"		}\n" + 
+			"		catch (Exception e) {\n" + 
+			"			if (exc == null) // no warning here ??\n" + 
+			"				;\n" + 
+			"		}\n" + 
+			"		finally {\n" + 
+			"			try {\n" + 
+			"				close();\n" + 
+			"			}\n" + 
+			"			catch (Exception e) {\n" + 
+			"				if (exc == null) // No warning here ??\n" + 
+			"					exc = e;\n" + 
+			"			} finally {\n" +
+			"				System.out.print(1);\n" +
+			"			}\n" +
+			"		}\n" + 
+			"	}\n" + 
+			"}\n"
+		}, 
+		"----------\n" + 
+		"1. ERROR in Test.java (at line 23)\n" + 
+		"	if (exc == null) // no warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 31)\n" + 
+		"	if (exc == null) // No warning here ??\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable exc can only be null at this location\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 30c4ee3..f2199f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -27,6 +27,7 @@
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 331649 - [compiler][null] consider null annotations for fields
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -109,8 +110,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	}
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
-		if (flowContext.initsOnFinally != null)
-			flowContext.markFinallyNullStatus(local, nullStatus);
+		flowContext.markFinallyNullStatus(local, nullStatus);
 	}
 	return flowInfo;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index 491e0eb..e7af82f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -42,8 +43,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			flowInfo = stat.analyseCode(this.scope, flowContext, flowInfo);
 		}
 		// record the effect of stat on the finally block of an enclosing try-finally, if any:
-		if (flowContext.initsOnFinally != null)
-			flowContext.mergeFinallyNullInfo(flowInfo);
+		flowContext.mergeFinallyNullInfo(flowInfo);
 		if (enableSyntacticNullAnalysisForFields) {
 			flowContext.expireNullCheckedFieldInfo();
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
index 135735c..418b3aa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *     Jesper S Moller - Contributions for
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *******************************************************************************/
@@ -60,8 +61,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		if (local != null) {
 			// compound assignment results in a definitely non null value for String
 			flowInfo.markAsDefinitelyNonNull(local);
-			if (flowContext.initsOnFinally != null)
-				flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
+			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
 	}
 	return flowInfo;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 3fe5c71..ac8ea62 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -18,6 +18,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -581,9 +582,7 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 		}
 		flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-		if (flowContext.initsOnFinally != null) {
-			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
-		}
+		flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		return true;
 	}
 	return false; // not checked
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
index 7e1f697..655375b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2012 GK Software AG and others.
+ * Copyright (c) 2011, 2013 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -626,8 +626,7 @@ public class FakedTrackingVariable extends LocalDeclaration {
 		do {
 			flowInfo.markAsDefinitelyNonNull(current.binding);
 			current.globalClosingState |= CLOSE_SEEN;
-			if (flowContext.initsOnFinally != null)
-				flowContext.markFinallyNullStatus(this.binding, FlowInfo.NON_NULL);
+			flowContext.markFinallyNullStatus(this.binding, FlowInfo.NON_NULL);
 			current = current.innerTracker;
 		} while (current != null);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index b421e36..d9b4283 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -21,6 +21,7 @@
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -246,9 +247,7 @@ private void checkInternalNPE(BlockScope scope, FlowContext flowContext, FlowInf
 			}
 			flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-			if (flowContext.initsOnFinally != null) {
-				flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
-			}
+			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
 	}
 	if (this.otherBindings != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 197bd95..dad1b31 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -21,6 +21,7 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *								bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -120,9 +121,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.subRoutineStartLabel == null) {
 		// no finally block -- this is a simplified copy of the else part
 		if (flowContext instanceof FinallyFlowContext) {
-			// if this TryStatement sits inside another TryStatement,
-			// report into the initsOnFinally of the outer try-block.
-			flowContext.initsOnFinally = ((FinallyFlowContext)flowContext).tryContext.initsOnFinally;
+			// if this TryStatement sits inside another TryStatement, establish the wiring so that
+			// FlowContext.markFinallyNullStatus can report into initsOnFinally of the outer try context:
+			FinallyFlowContext finallyContext = (FinallyFlowContext) flowContext;
+			finallyContext.outerTryContext = finallyContext.tryContext;
 		}
 		// process the try block in a context handling the local exceptions.
 		ExceptionHandlingFlowContext handlingContext =
@@ -134,6 +136,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				null,
 				this.scope,
 				flowInfo);
+		handlingContext.conditionalLevel = 0; // start collection initsOnFinally
 		// only try blocks initialize that member - may consider creating a
 		// separate class if needed
 
@@ -239,11 +242,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				if (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579
 					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
+				flowContext.conditionalLevel++;
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
 						currentScope,
 						flowContext,
 						catchInfo);
+				flowContext.conditionalLevel--;
 				this.catchExitInitStateIndexes[i] = currentScope.methodScope().recordInitializationStates(catchInfo);
 				this.catchExits[i] =
 					(catchInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0;
@@ -254,9 +259,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			currentScope.methodScope().recordInitializationStates(tryInfo);
 
 		// chain up null info registry
-		if (flowContext.initsOnFinally != null) {
-			flowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);
-		}
+		flowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);
 
 		return tryInfo;
 	} else {
@@ -266,9 +269,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// analyse finally block first
 		insideSubContext = new InsideSubRoutineFlowContext(flowContext, this);
 		if (flowContext instanceof FinallyFlowContext) {
-			// if this TryStatement sits inside another TryStatement,
-			// let the nested context report into the initsOnFinally of the outer try-block.
-			insideSubContext.initsOnFinally = ((FinallyFlowContext)flowContext).tryContext.initsOnFinally;
+			// if this TryStatement sits inside another TryStatement, establish the wiring so that
+			// FlowContext.markFinallyNullStatus can report into initsOnFinally of the outer try context:
+			insideSubContext.outerTryContext = ((FinallyFlowContext)flowContext).tryContext;
 		}
 
 		// process the try block in a context handling the local exceptions.
@@ -282,6 +285,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				null,
 				this.scope,
 				flowInfo);
+		insideSubContext.initsOnFinally = handlingContext.initsOnFinally; 
 
 		subInfo =
 			this.finallyBlock
@@ -290,6 +294,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					finallyContext = new FinallyFlowContext(flowContext, this.finallyBlock, handlingContext),
 					flowInfo.nullInfoLessUnconditionalCopy())
 				.unconditionalInits();
+		handlingContext.conditionalLevel = 0; // start collection initsOnFinally only after analysing the finally block
 		if (subInfo == FlowInfo.DEAD_END) {
 			this.bits |= ASTNode.IsSubRoutineEscaping;
 			this.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);
@@ -408,6 +413,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				if (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579
 					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
+				insideSubContext.conditionalLevel = 1;
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
 						currentScope,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
index 4beaa90..b5d6c7e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionHandlingFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -78,7 +79,6 @@ public ExceptionHandlingFlowContext(
 	this(parent, tryStatement, handledExceptions, exceptionToCatchBlockMap, 
 			tryStatement.catchArguments, initializationParent, scope, flowInfo.unconditionalInits());
 	this.initsOnFinally = flowInfo.unconditionalCopy();
-	this.conditionalLevel = 0;	
 }
 ExceptionHandlingFlowContext(
 		FlowContext parent,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 2efcbd9..8d8333f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -32,7 +32,7 @@ import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
  * Reflects the context of code analysis, keeping track of enclosing
  *	try statements, exception handlers, etc...
  */
-public class FinallyFlowContext extends FlowContext {
+public class FinallyFlowContext extends TryFlowContext {
 
 	Reference[] finalAssignments;
 	VariableBinding[] finalVariables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 56e25ae..d1e571c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -18,6 +18,7 @@
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -648,11 +649,11 @@ public char[] labelName() {
 
 /**
  * Record a given null status of a given local variable as it will be seen in the finally block.
- * Precondition: caller has checked that initsOnFinally != null.
  * @param local the local variable being observed
  * @param nullStatus the null status of local at the current point in the flow
  */
 public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
+	if (this.initsOnFinally == null) return;
 	if (this.conditionalLevel == -1) return;
 	if (this.conditionalLevel == 0) {
 		// node is unconditionally reached, take nullStatus as is:
@@ -672,6 +673,7 @@ public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
  * @param flowInfo info after executing a statement of the try-block.
  */
 public void mergeFinallyNullInfo(FlowInfo flowInfo) {
+	if (this.initsOnFinally == null) return;
 	if (this.conditionalLevel == -1) return;
 	if (this.conditionalLevel == 0) {
 		// node is unconditionally reached, take null info as is:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
index 4daa2c7..451a6c7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/InsideSubRoutineFlowContext.java
@@ -17,7 +17,7 @@ import org.eclipse.jdt.internal.compiler.ast.SubRoutineStatement;
  * Reflects the context of code analysis, keeping track of enclosing
  *	try statements, exception handlers, etc...
  */
-public class InsideSubRoutineFlowContext extends FlowContext {
+public class InsideSubRoutineFlowContext extends TryFlowContext {
 
 	public UnconditionalFlowInfo initsOnReturn;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
new file mode 100644
index 0000000..1623e51
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/TryFlowContext.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.flow;
+
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+
+/**
+ * Shared implementation for try-statement-related flow contexts.
+ */
+public abstract class TryFlowContext extends FlowContext {
+
+	/**
+	 * For a try statement nested inside a finally block this reference
+	 * points to the flow context of the outer try block, for access to its initsOnFinally.
+	 */
+	public FlowContext outerTryContext;
+
+	public TryFlowContext(FlowContext parent, ASTNode associatedNode) {
+		super(parent, associatedNode);
+	}
+	
+	public void markFinallyNullStatus(LocalVariableBinding local, int nullStatus) {
+		if (this.outerTryContext != null) {
+			this.outerTryContext.markFinallyNullStatus(local, nullStatus);
+		}
+		super.markFinallyNullStatus(local, nullStatus);
+	}
+
+	public void mergeFinallyNullInfo(FlowInfo flowInfo) {
+		if (this.outerTryContext != null) {
+			this.outerTryContext.mergeFinallyNullInfo(flowInfo);
+		}
+		super.mergeFinallyNullInfo(flowInfo);
+	}
+}
