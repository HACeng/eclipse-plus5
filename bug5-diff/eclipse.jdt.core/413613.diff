commit f8cf1cf93993a2a964d587ccb545506c0c4fdc0b
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Oct 8 12:57:30 2013 +0530

    Fixed Bug 413613 - [1.8] APT should support SE8 annotations

1	1	org.eclipse.jdt.compiler.apt.tests/.classpath
-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
1	0	org.eclipse.jdt.compiler.apt.tests/processors/META-INF/services/javax.annotation.processing.Processor
22	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type$1.java
26	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type.java
639	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
35	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
39	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
28	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Y.java
23	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
7	1	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/AllTests.java
201	0	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
36	19	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
22	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
18	34	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
16	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
11	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
20	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
21	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
16	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
77	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
23	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
12	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
29	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
8	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/.classpath b/org.eclipse.jdt.compiler.apt.tests/.classpath
index 619082c..88dad53 100644
--- a/org.eclipse.jdt.compiler.apt.tests/.classpath
+++ b/org.eclipse.jdt.compiler.apt.tests/.classpath
@@ -3,6 +3,6 @@
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" output="binprocessors" path="processors"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index ed9bbcf..3dbab6d 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/META-INF/services/javax.annotation.processing.Processor b/org.eclipse.jdt.compiler.apt.tests/processors/META-INF/services/javax.annotation.processing.Processor
index 327a865..f7d0320 100644
--- a/org.eclipse.jdt.compiler.apt.tests/processors/META-INF/services/javax.annotation.processing.Processor
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/META-INF/services/javax.annotation.processing.Processor
@@ -1,6 +1,7 @@
 org.eclipse.jdt.compiler.apt.tests.processors.genclass.GenClassProc
 org.eclipse.jdt.compiler.apt.tests.processors.checkargs.CheckArgsProc
 org.eclipse.jdt.compiler.apt.tests.processors.elements.ElementProc
+org.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor
 org.eclipse.jdt.compiler.apt.tests.processors.filer.FilerProc
 org.eclipse.jdt.compiler.apt.tests.processors.messager.MessagerProc
 org.eclipse.jdt.compiler.apt.tests.processors.generics.GenericsProc
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type$1.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type$1.java
new file mode 100644
index 0000000..44a743b
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type$1.java
@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE_USE)
+public @interface Type$1 {
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type.java
new file mode 100644
index 0000000..8e40381
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Type.java
@@ -0,0 +1,26 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE_USE)
+public @interface Type {
+	String value() default "";
+	@Target(ElementType.TYPE_USE)
+	@interface One {
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
new file mode 100644
index 0000000..0efd902
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
@@ -0,0 +1,639 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.compiler.apt.tests.processors.elements;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.lang.model.AnnotatedConstruct;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type$1;
+import org.eclipse.jdt.compiler.apt.tests.processors.base.BaseProcessor;
+
+/**
+ * A processor that explores the java 8 specific elements and validates the lambda and 
+ * type annotated elements. To enable this processor, add 
+ * -Aorg.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor to the command line.
+ * @since 3.9 BETA_JAVA8
+ */
+@SupportedAnnotationTypes({"org.eclipse.jdt.compiler.apt.tests.annotations.Type", "org.eclipse.jdt.compiler.apt.tests.annotations.Type$1"})
+@SupportedSourceVersion(SourceVersion.RELEASE_8)
+public class Java8ElementProcessor extends BaseProcessor {
+	
+		private static final String[] ELEMENT_NAMES = new String[] {
+			"targets.model8.X", "T", "U", "K", "V"};
+	
+	RoundEnvironment roundEnv = null;
+	// Always return false from this processor, because it supports "*".
+	// The return value does not signify success or failure!
+	@Override
+	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+		if (roundEnv.processingOver()) {
+			return false;
+		}
+		
+		this.roundEnv = roundEnv;
+
+		Map<String, String> options = processingEnv.getOptions();
+		if (!options.containsKey(this.getClass().getName())) {
+			// Disable this processor unless we are intentionally performing the test.
+			return false;
+		} else {
+			try {
+				if (!invokeTestMethods(options)) {
+					testAll();
+				}
+				super.reportSuccess();
+			} catch (AssertionFailedError e) {
+				super.reportError(getExceptionStackTrace(e));
+			} catch (Throwable e) {
+				e.printStackTrace();
+			}
+		}
+		return false;
+	}
+	public boolean invokeTestMethods(Map<String, String> options) throws Throwable {
+		Method testMethod = null;
+		Set<String> keys = options.keySet();
+		boolean testsFound = false;
+		for (String option : keys) {
+			if (option.startsWith("test")) {
+				try {
+					testMethod = this.getClass().getDeclaredMethod(option, new Class[0]);
+					if (testMethod != null) {
+						testsFound = true;
+						testMethod.invoke(this,  new Object[0]);
+					}
+				} catch (InvocationTargetException e) {
+					throw e.getCause();
+				} catch (Exception e) {
+					super.reportError(getExceptionStackTrace(e));
+				}
+			}
+		}
+		return testsFound;
+	}
+	public void testAll() throws AssertionFailedError {
+		testSE8Specifics();
+		testLambdaSpecifics();
+		testTypeAnnotations();
+		testTypeAnnotations1();
+		testTypeAnnotations2();
+		testTypeAnnotations3();
+		testTypeAnnotations4();
+		testTypeAnnotations5();
+		testTypeAnnotations6();
+		testTypeAnnotations7();
+		testTypeAnnotations8();
+		testTypeAnnotations9();
+		testTypeAnnotations10();
+		testTypeAnnotations11();
+	}
+	
+	public void testLambdaSpecifics() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.LambdaTest");
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Type element for LambdaTest should not be null", annotatedType);
+		assertFalse("Java8ElementProcessor#examineLambdaSpecifics: Type LambdaTest is not a functional interface", _elementUtils.isFunctionalInterface(annotatedType));
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (ExecutableElement member : ElementFilter.methodsIn(members)) {
+			if ("foo".equals(member.getSimpleName().toString())) {
+				method = member;
+				break;
+			}
+		}
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Element for method foo should not be null", method);
+		assertFalse("Java8ElementProcessor#examineLambdaSpecifics: Method foo is not a default method", method.isDefault());
+
+		annotatedType = _elementUtils.getTypeElement("targets.model8.DefaultInterface");
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Type element for DefaultInterface should not be null", annotatedType);
+		assertFalse("Java8ElementProcessor#examineLambdaSpecifics: Type DefaultInterface is not a functional interface", _elementUtils.isFunctionalInterface(annotatedType));
+
+		method = null;
+		members = _elementUtils.getAllMembers(annotatedType);
+		for (ExecutableElement member : ElementFilter.methodsIn(members)) {
+			if ("defaultMethod".equals(member.getSimpleName().toString())) {
+				method = member;
+				break;
+			}
+		}
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Element for method defaultMethod() should not be null", method);
+		assertTrue("Java8ElementProcessor#examineLambdaSpecifics: Method defaultMethod() should be a default method", method.isDefault());
+
+		method = null;
+		for (ExecutableElement member : ElementFilter.methodsIn(members)) {
+			if ("staticMethod".equals(member.getSimpleName().toString())) {
+				method = member;
+				break;
+			}
+		}
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Element for method staticMethod() should not be null", method);
+		assertFalse("Java8ElementProcessor#examineLambdaSpecifics: Method staticMethod() shoule not be a default method", method.isDefault());
+
+		annotatedType = _elementUtils.getTypeElement("targets.model8.FunctionalInterface");
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Type element for FunctionalInterface should not be null", annotatedType);
+		assertTrue("Java8ElementProcessor#examineLambdaSpecifics: Type FunctionalInterface should be a functional interface", _elementUtils.isFunctionalInterface(annotatedType));
+
+		method = null;
+		members = _elementUtils.getAllMembers(annotatedType);
+		for (ExecutableElement member : ElementFilter.methodsIn(members)) {
+			if ("abstractMethod".equals(member.getSimpleName().toString())) {
+				method = member;
+				break;
+			}
+		}
+		assertNotNull("Java8ElementProcessor#examineLambdaSpecifics: Element for method abstractMethod() should not be null", method);
+		assertFalse("Java8ElementProcessor#examineLambdaSpecifics: Method abstractMethod() should not be a default method", method.isDefault());
+	}
+
+	public void testSE8Specifics() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		examineSE8AnnotationMethods("Java8ElementProcessor#examineSE8Specifics: ", annotatedType, "c");
+
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		VariableElement field = null, field1 = null;
+		ExecutableElement method2 = null;
+		for (Element member : members) {
+			if ("foo".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			} else if ("_field".equals(member.getSimpleName().toString())) {
+				field = (VariableElement) member;
+			} else if ("noAnnotationHere".equals(member.getSimpleName().toString())) {
+				method2 = (ExecutableElement) member;
+			} else if ("_field1".equals(member.getSimpleName().toString())) {
+				field1 = (VariableElement) member;
+			}
+		}
+		assertNotNull("Method should not be null", method);
+		TypeMirror typeMirror = method.getReturnType();
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for method foo should not be null", typeMirror);
+		examineSE8AnnotationMethods("Java8ElementProcessor#examineSE8Specifics: ", typeMirror, "m");
+		List<? extends AnnotationMirror> list = typeMirror.getAnnotationMirrors();
+		assertEquals("Java8ElementProcessor#examineSE8Specifics: Incorrect no of annotation mirrors", 1, list.size());
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for field _field should not be null", field);
+		typeMirror = field.asType(); 
+		examineSE8AnnotationMethods("Java8ElementProcessor#examineSE8Specifics: ", typeMirror, "f");
+		
+		typeMirror = field1.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		
+		typeMirror = method2.getReturnType();
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for method noAnnotationHere should not be null", typeMirror);
+		Type annot = typeMirror.getAnnotation(Type.class);
+		assertNull("Annotation should not be present", annot);
+		Annotation[] annots = typeMirror.getAnnotationsByType(Type.class);
+		assertEquals("Annotation is not empty list", 0, annots.length);
+	}
+	
+	public void testTypeAnnotations() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		TypeMirror superType = annotatedType.getSuperclass();
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: super type not be null", superType);
+		verifyTypeAnnotations(superType, new String[]{"@Type(value=s)"});
+
+		List<? extends TypeMirror> interfaces  = annotatedType.getInterfaces();
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: super interfaces list should not be null", interfaces);
+		assertEquals("Java8ElementProcessor#examineSE8Specifics: incorrect no of super interfaces", 2, interfaces.size());
+		superType = interfaces.get(0);
+		verifyTypeAnnotations(superType, new String[]{"@Type(value=i1)"});
+		superType = interfaces.get(1);
+		verifyTypeAnnotations(superType, new String[]{"@Type(value=i2)"});
+	}
+	
+	public void testTypeAnnotations1() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (Element member : members) {
+			if ("bar".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			}
+		}
+		List<? extends VariableElement> params = method.getParameters();
+		assertEquals("Incorrect no of params for method bar()", 2, params.size());
+		VariableElement param = (VariableElement) params.get(0);
+		TypeMirror typeMirror = param.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+		param = (VariableElement) params.get(1);
+		typeMirror = param.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+	}
+	
+	public void testTypeAnnotations2() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.Y");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		VariableElement field2 = null;
+		VariableElement field3 = null;
+		for (Element member : members) {
+			if ("_field2".equals(member.getSimpleName().toString())) {
+				field2 = (VariableElement) member;
+			} else if ("_field3".equals(member.getSimpleName().toString())) {
+				field3 = (VariableElement) member;
+			}
+		}
+		
+		//@Type("f") String @Type("f1") [] @Type("f2") [] _field2 @Type("f3") [], _field3 @Type("f4") [][] = null;
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for field _field2 should not be null", field2);
+		TypeMirror typeMirror = field2.asType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f3)"});
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
+
+		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for field _field3 should not be null", field3);
+		typeMirror = field3.asType();
+		// The second field binding doesn't seem to have the annotations. To be investigated
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f4)"});
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{});
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
+	}
+	
+	public void testTypeAnnotations3() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.Y");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (Element member : members) {
+			if ("foo".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			}
+		}
+		// @Type("m") String @Type("m1") [] foo() @Type("m2") [] @Type("m3") [] {}
+		assertNotNull("Method should not be null", method);
+		TypeMirror typeMirror = method.getReturnType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m2)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m3)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m1)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m)"});
+	}
+
+	public void testTypeAnnotations4() {
+		// void bar( @Type("p1") String [] a @Type("p2") [], @Type("p3") int @Type("p4") [] b [] @Type("p5") []) {}
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.Y");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (Element member : members) {
+			if ("bar".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			}
+		}
+		assertNotNull("Method should not be null", method);
+		List<? extends VariableElement> params = method.getParameters();
+		assertEquals("Incorrect no of params for method bar()", 2, params.size());
+		VariableElement param = (VariableElement) params.get(0);
+		TypeMirror typeMirror = param.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		
+		verifyTypeAnnotations(typeMirror, new String[]{});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+
+		param = (VariableElement) params.get(1);
+		typeMirror = param.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p5)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p4)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
+		
+	}
+	
+	public void testTypeAnnotations5() {
+		// void foo2() throws (@Type("e1") NullPointerException, (@Type("e2") ArrayIndexOutOfBoundsException {}
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.Y");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (Element member : members) {
+			if ("foo2".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			}
+		}
+		List<?extends TypeMirror> exceptions = method.getThrownTypes();
+		assertEquals("Incorrect no of thrown exceptions", 2, exceptions.size());
+		TypeMirror typeMirror = exceptions.get(0);
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=e1)"});
+		typeMirror = exceptions.get(1);
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=e2)"});
+	}
+
+	public void testTypeAnnotations6() {
+		// void bar2 (@Type("p1") String @Type("p2") [] @Type("p3") ... args) {}
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.Y");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement method = null;
+		for (Element member : members) {
+			if ("bar2".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			}
+		}
+		List<? extends VariableElement> params = method.getParameters();
+		assertEquals("Incorrect no of parameters", 1, params.size());
+		TypeMirror typeMirror = params.get(0).asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
+		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
+		typeMirror = ((ArrayType) typeMirror).getComponentType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+
+	}
+
+	public void testTypeAnnotations7() {
+		// public class Z <@Type("tp1") K, @Type("tp2") V> {
+		TypeElement typeZ = _elementUtils.getTypeElement("targets.model8.Z");
+		TypeMirror typeMirror = typeZ.asType();
+		List<? extends TypeParameterElement> typeParams = typeZ.getTypeParameters();
+		assertEquals("Incorrect no of type params", 2, typeParams.size());
+		TypeParameterElement typeParam = typeParams.get(0);
+		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=tp1)"});
+		typeMirror = typeParam.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=tp1)"});
+		typeParam = typeParams.get(1);
+		typeMirror = typeParam.asType();
+		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=tp2)"});
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=tp2)"});
+	}
+	
+	public void testTypeAnnotations8() {
+		TypeElement typeZ = _elementUtils.getTypeElement("targets.model8.Z");
+		List<? extends Element> members = _elementUtils.getAllMembers(typeZ);
+		ExecutableElement method = null;
+		VariableElement field = null;
+		for (Element member : members) {
+			if ("foo".equals(member.getSimpleName().toString())) {
+				method = (ExecutableElement) member;
+			} else if ("z1".equals(member.getSimpleName().toString())) {
+				field = (VariableElement) member;
+			}
+		}
+		
+		// public <@Type("mp1") T, @Type("mp2") U> void foo() {}	
+		List<? extends TypeParameterElement> typeParams = method.getTypeParameters();
+		assertEquals("Incorrect no of type params", 2, typeParams.size());
+		TypeParameterElement typeParam = typeParams.get(0);
+		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp1)"});
+		typeParam = typeParams.get(1);
+		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp2)"});
+		//Z<@Type("ta1") String, @Type("ta2") Object> z1 = null;
+		// APIs don't expose the type arguments on a TypeMirror
+		TypeMirror typeMirror = field.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{});
+	}
+
+	public void testTypeAnnotations9() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		
+		VariableElement field2 = null;
+		for (VariableElement member : ElementFilter.fieldsIn(members)) {
+			if ("_field2".equals(member.getSimpleName().toString())) {
+				field2 = (VariableElement) member;
+				break;
+			}
+		}
+		TypeMirror typeMirror = field2.asType();
+		Type$1 annot1 = typeMirror.getAnnotation(Type$1.class);
+		assertNotNull("Annotation should not be null", annot1);
+		Type.One annot2 = typeMirror.getAnnotation(Type.One.class);
+		assertNotNull("Annotation should not be null", annot2);
+	}
+	
+	public void testTypeAnnotations10() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		VariableElement field3 = null;
+		for (Element member : members) {
+			if ("_field3".equals(member.getSimpleName().toString())) {
+				field3 = (VariableElement) member;
+			}
+		}
+		verifyTypeAnnotations(annotatedType, new String[]{"@Type(value=c)"});
+		verifyTypeAnnotations(annotatedType.asType(), new String[]{});
+		verifyTypeAnnotations(field3, new String[]{});
+		verifyTypeAnnotations(field3.asType(), new String[]{});
+	}
+
+	public void testTypeAnnotations11() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		VariableElement xy = null;
+		for (Element member : members) {
+			if ("xy".equals(member.getSimpleName().toString())) {
+				xy = (VariableElement) member;
+			}
+		}
+		verifyTypeAnnotations(xy, new String[]{});
+		verifyTypeAnnotations(xy.asType(), new String[]{"@Type(value=xy)"});
+		
+		Set<String> expectedElementNames = new HashSet<String>(ELEMENT_NAMES.length);
+		for (String name : ELEMENT_NAMES) {
+			expectedElementNames.add(name);
+		}
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Type.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		
+		for (Element e : actualElments) {
+			if (e instanceof TypeElement) {
+				String name = ((TypeElement) e).getQualifiedName().toString();
+				if (!expectedElementNames.remove(name)) {
+					reportError("Missing root element " + name);
+				}
+			} else if (e instanceof TypeParameterElement) {
+				String name = ((TypeParameterElement) e).getSimpleName().toString();
+				if (!expectedElementNames.remove(name)) {
+					reportError("Missing root element " + name);
+				}
+			}
+		}
+		assertTrue("Found unexpected extra elements", expectedElementNames.isEmpty());
+	}
+
+	public void testTypeAnnotations12() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement bar2 = null;
+		for (Element member : members) {
+			if ("bar2".equals(member.getSimpleName().toString())) {
+				bar2 = (ExecutableElement) member;
+			}
+		}
+		TypeMirror typeMirror = bar2.getReceiverType();
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		ExecutableType type = (ExecutableType) bar2.asType();
+		verifyTypeAnnotations(type.getReceiverType(), new String[]{"@Type(value=receiver)"});
+	}
+	private String getExceptionStackTrace(Throwable t) {
+		StringBuffer buf = new StringBuffer(t.getMessage());
+		StackTraceElement[] traces = t.getStackTrace();
+		for (int i = 0; i < traces.length; i++) {
+			StackTraceElement trace = traces[i];
+			buf.append("\n\tat " + trace);
+			if (i == 12)
+				break; // Don't dump all stacks
+		}
+		return buf.toString();
+	}
+
+	
+	private void verifyTypeAnnotations(AnnotatedConstruct construct, String[] annots) {
+		List<? extends AnnotationMirror> annotations = construct.getAnnotationMirrors();
+		assertEquals("Incorrect no of annotations", annots.length, annotations.size());
+		for(int i = 0, length = annots.length; i < length; i++) {
+			AnnotationMirror mirror = annotations.get(i);
+			assertEquals("Invalid annotation value", annots[i], getAnnotationString(mirror));
+		}
+	}
+	private String getAnnotationString(AnnotationMirror annot) {
+		DeclaredType annotType = annot.getAnnotationType();
+		TypeElement type = (TypeElement) annotType.asElement();
+		StringBuffer buf = new StringBuffer("@" + type.getSimpleName());
+		Map<? extends ExecutableElement, ? extends AnnotationValue> values = annot.getElementValues();
+		Set<? extends ExecutableElement> keys = values.keySet();
+		buf.append('(');
+		for (ExecutableElement executableElement : keys) { // @Marker3()
+			buf.append(executableElement.getSimpleName());
+			buf.append('=');
+			AnnotationValue value = values.get(executableElement);
+			buf.append(value.getValue());
+		}
+		buf.append(')');
+		return buf.toString();
+	}
+	private <A extends Annotation> void examineSE8AnnotationMethods(String msg, AnnotatedConstruct construct,  String value) {
+		Type annot = construct.getAnnotation(Type.class);
+		assertNotNull(msg + "Annotation for element " + construct.toString() + " should not be null", annot);
+		assertSame(msg + "Invalid annotation type" , Type.class, annot.annotationType());
+		assertEquals(msg + "Invalid annotation value", value, annot.value());
+		
+		Annotation[] annots = construct.getAnnotationsByType(Type.class);
+		assertEquals(msg + "Incorrect no of annotations", 1, annots.length);
+		annot = (Type) annots[0];
+		assertSame(msg + "Invalid annotation type" , Type.class, annots[0].annotationType());
+		assertEquals(msg + "Invalid annotation value", value, annot.value());
+	}
+	
+	public void reportError(String msg) {
+		throw new AssertionFailedError(msg);
+	}
+	
+	public void assertTrue(String msg, boolean value) {
+		if (!value) reportError(msg);
+	}
+	public void assertFalse(String msg, boolean value) {
+		if (value) reportError(msg);
+	}
+	public void assertSame(String msg, Object obj1, Object obj2) {
+		if (obj1 != obj2) {
+			reportError(msg + ", should be " + obj1.toString() + " but " + obj2.toString());
+		}
+	}
+	public void assertNotNull(String msg, Object obj) {
+		if (obj == null) {
+			reportError(msg);
+		}
+	}
+	public void assertNull(String msg, Object obj) {
+		if (obj != null) {
+			reportError(msg);
+		}
+	}
+    public void assertEquals(String message, Object expected, Object actual) {
+        if (equalsRegardingNull(expected, actual)) {
+            return;
+        } else {
+        	reportError(message + ", expected " + expected.toString() + " but was " + actual.toString());
+        }
+    }
+
+    static boolean equalsRegardingNull(Object expected, Object actual) {
+        if (expected == null) {
+            return actual == null;
+        }
+        return expected.equals(actual);
+    }
+    
+	public void assertEquals(String msg, int expected, int actual) {
+		if (expected != actual) {
+			StringBuffer buf = new StringBuffer();
+			buf.append(msg);
+			buf.append(", expected " + expected + " but was " + actual);
+			reportError(buf.toString());
+		}
+	}
+	public void assertEquals(Object expected, Object actual) {
+		if (expected != actual) {
+			
+		}
+	}
+	private class AssertionFailedError extends Error {
+		private static final long serialVersionUID = 1L;
+
+		public AssertionFailedError(String msg) {
+			super(msg);
+		}
+	}
+	
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
new file mode 100644
index 0000000..6589eb1
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package targets.model8;
+
+public class LambdaTest {
+	public String foo() {
+		return null;
+	}
+}     
+
+interface DefaultInterface {
+	public default String defaultMethod () {
+		return null;
+	}
+	public static String staticMethod () {
+		return null;
+	}
+}     
+
+interface FunctionalInterface {
+	public abstract String abstractMethod ();
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
new file mode 100644
index 0000000..b8e690e
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package targets.model8;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type$1;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type.One;
+
+@Type("c")
+public class X extends @Type("s") Object implements @Type("i1") I, @Type("i2") J {
+	@Type("f") String _field = null;
+	@Type("f1") X _field1 = null;
+	@Type$1 @One String _field2 = null;
+	X _field3 = null;
+	X. @Type("xy") XY xy;
+	public void noAnnotationHere() {
+	}
+	@Deprecated @Type("m") String foo() {
+		return null;
+	}
+	void bar(@Type("p1") String p1, @Type("p2") String p2) {}
+	public void bar2(@Type("receiver") X this) {}
+	class XY {}
+}
+
+interface I {}
+interface J {}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Y.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Y.java
new file mode 100644
index 0000000..9c7f2b9
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Y.java
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package targets.model8;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+
+public class Y {
+	@Type("f") String @Type("f1") [] @Type("f2") [] _field2 @Type("f3") [], _field3 @Type("f4") [][] = null;
+	
+	@Deprecated @Type("m") String @Type("m1") [] foo() @Type("m2") [] @Type("m3") [] {
+		return null;
+	}
+	void bar (@Type("p1") String [] a @Type("p2") [], @Type("p3") int @Type("p4") [] b [] @Type("p5") []) {}
+	void foo2() throws @Type("e1") NullPointerException, @Type("e2") ArrayIndexOutOfBoundsException {}
+	void bar2 (@Type("p1") String @Type("p2") [] @Type("p3") ... args) {}
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
new file mode 100644
index 0000000..2461aad
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package targets.model8;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+
+public class Z <@Type("tp1") K, @Type("tp2") V> {
+	Z<@Type("ta1") String, @Type("ta2") Object> z1 = null;
+	public <@Type("mp1") T, @Type("mp2") U> void foo() {}
+}
+
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/AllTests.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/AllTests.java
index b3dcfc7..8c26096 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/AllTests.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/AllTests.java
@@ -1,12 +1,17 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2006, 2013 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *    wharley@bea.com - initial API and implementation
+ *    IBM Corporation - Java 8 support
  *    
  *******************************************************************************/
 package org.eclipse.jdt.compiler.apt.tests;
@@ -29,6 +34,7 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(FilerTests.class);
 		suite.addTestSuite(ModelUtilTests.class);
 		suite.addTestSuite(NegativeTests.class);
+		suite.addTestSuite(Java8ElementsTests.class);
 		return suite;
 	}
 }
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
new file mode 100644
index 0000000..a17178d
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
@@ -0,0 +1,201 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.compiler.apt.tests;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.lang.model.SourceVersion;
+import javax.tools.JavaCompiler;
+import javax.tools.ToolProvider;
+
+import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler;
+
+import junit.framework.TestCase;
+
+public class Java8ElementsTests extends TestCase {
+	
+	private static final String TYPE_ANNOTATION_PROC = "org.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor";
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		BatchTestUtils.init();
+	}
+
+	public void testSE8Specifics() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testSE8Specifics");
+	}
+	public void testSE8SpecificsWithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testSE8Specifics");
+	}
+	public void testLambdaSpecifics() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testLambdaSpecifics");
+	}
+	public void testLambdaSpecificsWithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testLambdaSpecifics");
+	}
+	public void testTypeAnnotations() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations");
+	}
+	public void testTypeAnnotationsWithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations");
+	}
+	public void testTypeAnnotations1() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations1");
+	}
+	public void testTypeAnnotations1WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations1");
+	}
+	public void testTypeAnnotations2() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations2");
+	}
+	public void testTypeAnnotations2WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations2");
+	}
+	public void testTypeAnnotations3() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations3");
+	}
+	public void testTypeAnnotations3WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations3");
+	}
+	public void testTypeAnnotations4() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations4");
+	}
+	public void testTypeAnnotations4WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations4");
+	}
+	public void testTypeAnnotations5() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations5");
+	}
+	public void testTypeAnnotations5WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations5");
+	}
+	public void testTypeAnnotations6() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations6");
+	}
+	public void testTypeAnnotations6WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations6");
+	}
+	public void testTypeAnnotations7() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations7");
+	}
+	public void testTypeAnnotations7WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations7");
+	}
+	public void testTypeAnnotations8() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations8");
+	}
+	public void testTypeAnnotations8WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations8");
+	}
+	public void testTypeAnnotations9() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations9");
+	}
+	public void testTypeAnnotations9WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations9");
+	}
+	public void testTypeAnnotations10() throws Exception {
+		System.out.println("Eclipse compiler:");
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
+	}
+	public void testTypeAnnotations10WithJavac() throws Exception {
+		System.out.println("Javac compiler:");
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
+	}
+	public void testTypeAnnotations11() throws Exception {
+		System.out.println("Eclipse compiler:");
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
+	}
+	public void testTypeAnnotations11WithJavac() throws Exception {
+		System.out.println("Javac compiler:");
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
+	}
+	public void testTypeAnnotations12() throws Exception {
+		System.out.println("Eclipse compiler:");
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
+	}
+	public void testTypeAnnotations12WithJavac() throws Exception {
+		System.out.println("Javac compiler:");
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
+	}
+
+	private void internalTest(JavaCompiler compiler, String processor, String testMethod) throws IOException {
+		if (!canRunJava8()) {
+			return;
+		}
+		System.clearProperty(processor);
+		File targetFolder = TestUtils.concatPath(BatchTestUtils.getSrcFolderName(), "targets", "model8");
+		BatchTestUtils.copyResources("targets/model8", targetFolder);
+
+		List<String> options = new ArrayList<String>();
+		options.add("-A" + processor);
+		options.add("-A" + testMethod);
+		// Javac 1.8 doesn't (yet?) support the -1.8 option
+		if (compiler instanceof EclipseCompiler) {
+			options.add("-1.8");
+		}
+		BatchTestUtils.compileTree(compiler, options, targetFolder);
+
+		// If it succeeded, the processor will have set this property to "succeeded";
+		// if not, it will set it to an error value.
+		assertEquals("succeeded", System.getProperty(processor));
+	}
+	public boolean canRunJava8() {
+		try {
+			SourceVersion.valueOf("RELEASE_8");
+		} catch(IllegalArgumentException iae) {
+			return false;
+		}
+		return true;
+	}
+	@Override
+	protected void tearDown() throws Exception {
+		super.tearDown();
+	}
+}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
index 45168f7..74428d8 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
@@ -24,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.AptSourceLocalVariableBinding;
@@ -35,6 +36,7 @@ import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 
 /**
  * This class is used to visit the JDT compiler internal AST to discover annotations, 
@@ -92,14 +94,7 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 					annotations,
 					constructorBinding);
 		}
-		Argument[] arguments = constructorDeclaration.arguments;
-		if (arguments != null) {
-			int argumentLength = arguments.length;
-			for (int i = 0; i < argumentLength; i++) {
-				arguments[i].traverse(this, constructorDeclaration.scope);
-			}
-		}
-		return false;
+		return true;
 	}
 
 	@Override
@@ -117,6 +112,32 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 	}
 
 	@Override
+	public boolean visit(TypeParameter typeParameter, ClassScope scope) {
+		Annotation[] annotations = typeParameter.annotations;
+		if (annotations != null) {
+			TypeVariableBinding binding = typeParameter.binding;
+			if (binding == null) {
+				return false;
+			}
+			this.resolveAnnotations(scope.referenceContext.initializerScope, annotations, binding);
+		}
+		return false;
+	}
+	
+	@Override
+	public boolean visit(TypeParameter typeParameter, BlockScope scope) {
+		Annotation[] annotations = typeParameter.annotations;
+		if (annotations != null) {
+			TypeVariableBinding binding = typeParameter.binding;
+			if (binding == null) {
+				return false;
+			}
+			this.resolveAnnotations(scope, annotations, binding);
+		}
+		return false;
+	}
+
+	@Override
 	public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
 		Annotation[] annotations = methodDeclaration.annotations;
 		if (annotations != null) {
@@ -130,15 +151,7 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 					annotations,
 					methodBinding);
 		}
-
-		Argument[] arguments = methodDeclaration.arguments;
-		if (arguments != null) {
-			int argumentLength = arguments.length;
-			for (int i = 0; i < argumentLength; i++) {
-				arguments[i].traverse(this, methodDeclaration.scope);
-			}
-		}
-		return false;
+		return true;
 	}
 
 	@Override
@@ -177,10 +190,14 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 			BlockScope scope,
 			Annotation[] annotations,
 			Binding currentBinding) {
-		ASTNode.resolveAnnotations(scope, annotations, currentBinding);
-		
+		boolean resolved = false;
 		for (Annotation annotation : annotations) {
 			AnnotationBinding binding = annotation.getCompilerAnnotation();
+			if (binding == null && !resolved) {
+				ASTNode.resolveAnnotations(scope, annotations, currentBinding, true);
+				binding = annotation.getCompilerAnnotation();
+				resolved = true;
+			}
 			if (binding != null) { // binding should be resolved, but in case it's not, ignore it
 				TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType()); 
 				Element element = _factory.newElement(currentBinding);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
index 0a4cf69..a0b17e0 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
@@ -1,13 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
  *    IBM Corporation - fix for 342598
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -18,7 +23,9 @@ import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
+import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
 
 /**
  * Implementation of ArrayType, which represents an array of some type.
@@ -44,7 +51,20 @@ public class ArrayTypeImpl extends TypeMirrorImpl implements ArrayType {
 	public <R, P> R accept(TypeVisitor<R, P> v, P p) {
 		return v.visitArray(this, p);
 	}
-	
+
+	protected AnnotationBinding[] getAnnotationBindings() {
+		AnnotationBinding[] oldies = ((ArrayBinding)_binding).getTypeAnnotations();
+		AnnotationBinding[] newbies = Binding.NO_ANNOTATIONS;
+		// Strip out the annotations on sub arrays
+		for (int i = 0, length = oldies == null ? 0 : oldies.length; i < length; i++) {
+			if (oldies[i] == null) {
+				System.arraycopy(oldies, 0, newbies = new AnnotationBinding[i], 0, i);
+				return newbies;
+			}
+		}
+		return newbies;
+	}
+
 	/* (non-Javadoc)
 	 * @see javax.lang.model.type.TypeMirror#getKind()
 	 */
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
index 998e3d6..44146a4 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
@@ -1,17 +1,20 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 IBM Corporation and others.
+ * Copyright (c) 2005, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.apt.model;
 
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Proxy;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -24,11 +27,9 @@ import javax.lang.model.element.PackageElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 
 /**
  * Element represents any defined Java language element - a package, 
@@ -50,37 +51,9 @@ public abstract class ElementImpl
 		return _env.getFactory().newTypeMirror(_binding);
 	}
 
-	@SuppressWarnings("unchecked") // for cast of newProxyInstance() to A
 	@Override
 	public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
-		AnnotationBinding[] annoInstances = getAnnotationBindings();
-		if( annoInstances == null || annoInstances.length == 0 || annotationClass == null ) 
-			return null;
-
-		String annoTypeName = annotationClass.getName();
-		if( annoTypeName == null ) return null;
-		annoTypeName = annoTypeName.replace('$', '.');
-		for( AnnotationBinding annoInstance : annoInstances) {
-			if (annoInstance == null)
-				continue;
-			ReferenceBinding binding = annoInstance.getAnnotationType();
-			if ( binding != null && binding.isAnnotationType() ) {
-				char[] qName;
-				if (binding.isMemberType()) {
-					qName = CharOperation.concatWith(binding.enclosingType().compoundName, binding.sourceName, '.');
-					CharOperation.replace(qName, '$', '.');
-				} else {
-					qName = CharOperation.concatWith(binding.compoundName, '.');
-				}
-				if( annoTypeName.equals(new String(qName)) ){
-					AnnotationMirrorImpl annoMirror =
-						(AnnotationMirrorImpl)_env.getFactory().newAnnotationMirror(annoInstance);
-					return (A)Proxy.newProxyInstance(annotationClass.getClassLoader(),
-							new Class[]{ annotationClass }, annoMirror );
-				}
-			}
-		}
-		return null; 
+		return _env.getFactory().getAnnotation(getAnnotationBindings(), annotationClass);
 	}
 	
 	/**
@@ -93,6 +66,10 @@ public abstract class ElementImpl
 		return _env.getFactory().getAnnotationMirrors(getAnnotationBindings());
 	}
 
+	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+		return _env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);	
+	}
+
 	@Override
 	public Set<Modifier> getModifiers() {
 		// Most subclasses implement this; this default is appropriate for 
@@ -131,7 +108,14 @@ public abstract class ElementImpl
 
 	@Override
 	public String toString() {
-		return _binding.toString();
+		StringBuffer buf = new StringBuffer();
+		List<? extends AnnotationMirror> annots = getAnnotationMirrors();
+		for (AnnotationMirror annotationMirror : annots) {
+			buf.append(annotationMirror.toString());
+			buf.append(' ');
+		}
+		buf.append(_binding.toString());
+		return buf.toString();
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
index 8e7664a..32bfc2f 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
@@ -1,14 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2012 BEA Systems, Inc. and others
+ * Copyright (c) 2006, 2013 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *    wharley@bea.com - initial API and implementation
  *    IBM Corporation - Fix for bug 341494
  *    IBM Corporation - Fix for bug 328575
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -702,4 +707,14 @@ public class ElementsImpl implements Elements {
 		}
 	}
 
+	public boolean isFunctionalInterface(TypeElement type) {
+		if (type != null && type.getKind() == ElementKind.INTERFACE) {
+			ReferenceBinding binding = (ReferenceBinding)((TypeElementImpl) type)._binding;
+			if (binding instanceof SourceTypeBinding) {
+				return binding.isFunctionalInterface(((SourceTypeBinding) binding).scope);
+			}
+		}
+		return false;
+	}
+
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
index 3eccbf9..b6be38e 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 IBM Corporation and others.
+ * Copyright (c) 2007, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -109,6 +113,12 @@ public class ErrorTypeElement extends TypeElementImpl {
 	public List<? extends AnnotationMirror> getAnnotationMirrors() {
 		return Collections.emptyList();
 	}
+	
+	@SuppressWarnings("unchecked")
+	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+		return (A[]) Factory.EMPTY_ANNOTATIONS;
+	}
+
 
 	/* (non-Javadoc)
 	 * @see javax.lang.model.element.Element#getEnclosedElements()
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
index 6b826b7..f7d7367 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
@@ -1,19 +1,25 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 IBM Corporation and others.
+ * Copyright (c) 2007, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.apt.model;
 
+import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.TypeKind;
@@ -85,6 +91,19 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 		return v.visitError(this, p);
 	}
 
+	public List<? extends AnnotationMirror> getAnnotationMirrors() {
+		return Factory.EMPTY_ANNOTATION_MIRRORS;
+	}
+
+	public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+		return null;
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+		return (A[]) Factory.EMPTY_ANNOTATIONS;
+	}
+
 	/* (non-Javadoc)
 	 * @see javax.lang.model.type.TypeMirror#getKind()
 	 */
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
index 33b8241..4dc8b16 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 IBM Corporation and others.
+ * Copyright (c) 2005, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -334,4 +338,20 @@ public class ExecutableElementImpl extends ElementImpl implements
 		return false;
 	}
 
+	public TypeMirror getReceiverType() {
+		MethodBinding binding = (MethodBinding)_binding;
+		if (binding.receiver != null) {
+			return _env.getFactory().newTypeMirror(binding.receiver);
+		}
+		if (binding.declaringClass != null) {
+			return _env.getFactory().newTypeMirror(binding.declaringClass);
+		}
+		return NoTypeImpl.NO_TYPE_NONE;
+	}
+
+	public boolean isDefault() {
+		MethodBinding binding = (MethodBinding)_binding;
+		return binding.isDefaultMethod();
+	}
+
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
index 3681abe..edc58da 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 IBM Corporation and others.
+ * Copyright (c) 2006, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -122,4 +126,15 @@ public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType
 	public TypeKind getKind() {
 		return TypeKind.EXECUTABLE;
 	}
+
+	public TypeMirror getReceiverType() {
+		MethodBinding binding = (MethodBinding)_binding;
+		if (binding.receiver != null) {
+			return _env.getFactory().newTypeMirror(binding.receiver);
+		}
+		if (binding.declaringClass != null) {
+			return _env.getFactory().newTypeMirror(binding.declaringClass);
+		}
+		return NoTypeImpl.NO_TYPE_NONE;
+	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 71c7ab9..06ea4ba 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -1,18 +1,25 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2012 BEA Systems, Inc. and others 
+ * Copyright (c) 2007, 2013 BEA Systems, Inc. and others 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
  *    IBM Corporation - fix for 342598
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
+import java.lang.reflect.Proxy;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumSet;
@@ -31,6 +38,7 @@ import javax.lang.model.type.NullType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
@@ -64,6 +72,8 @@ public class Factory {
 	public static final Short DUMMY_SHORT = 0;
 
 	private final BaseProcessingEnvImpl _env;
+	public static Annotation[] EMPTY_ANNOTATIONS = new Annotation[0];
+	public static List<? extends AnnotationMirror> EMPTY_ANNOTATION_MIRRORS = Collections.emptyList();
 	
 	/**
 	 * This object should only be constructed by the BaseProcessingEnvImpl.
@@ -88,6 +98,58 @@ public class Factory {
 		return Collections.unmodifiableList(list);
 	}
 	
+	@SuppressWarnings("unchecked") // for the cast to A
+	public <A extends Annotation> A[] getAnnotationsByType(AnnotationBinding[] annoInstances, Class<A> annotationClass) {
+		A[] result = getAnnotations(annoInstances, annotationClass, false);
+		return result == null ? (A[]) EMPTY_ANNOTATIONS : result;
+	}
+	
+	
+	public <A extends Annotation> A getAnnotation(AnnotationBinding[] annoInstances, Class<A> annotationClass) {
+		A[] result = getAnnotations(annoInstances, annotationClass, true);
+		return result == null ? null : result[0];
+	}
+
+	@SuppressWarnings("unchecked") // for cast of newProxyInstance() to A
+	private <A extends Annotation> A[] getAnnotations(AnnotationBinding[] annoInstances, Class<A> annotationClass, boolean justTheFirst) {
+		if(annoInstances == null || annoInstances.length == 0 || annotationClass == null ) 
+			return null;
+
+		String annoTypeName = annotationClass.getName();
+		if(annoTypeName == null ) return null;
+
+		List<A> list = new ArrayList<A>(annoInstances.length);
+		for(AnnotationBinding annoInstance : annoInstances) {
+			if (annoInstance == null)
+				continue;
+			
+			AnnotationMirrorImpl annoMirror = createAnnotationMirror(annoTypeName, annoInstance);
+			if (annoMirror != null) {
+				list.add((A)Proxy.newProxyInstance(annotationClass.getClassLoader(), new Class[]{ annotationClass }, annoMirror));
+				if (justTheFirst) break;
+			}
+		}
+		return list.size() > 0 ? (A[]) list.toArray(new Annotation[list.size()]) :  null;
+	}
+
+	private AnnotationMirrorImpl createAnnotationMirror(String annoTypeName, AnnotationBinding annoInstance) {
+		ReferenceBinding binding = annoInstance.getAnnotationType();
+		if (binding != null && binding.isAnnotationType() ) {
+			char[] qName;
+			if (binding.isMemberType()) {
+				annoTypeName = annoTypeName.replace('$', '.');
+				qName = CharOperation.concatWith(binding.enclosingType().compoundName, binding.sourceName, '.');
+				CharOperation.replace(qName, '$', '.');
+			} else {
+				qName = CharOperation.concatWith(binding.compoundName, '.');
+			}
+			if(annoTypeName.equals(new String(qName)) ){
+				return (AnnotationMirrorImpl)_env.getFactory().newAnnotationMirror(annoInstance);
+			}
+		}
+		return null;
+	}
+
 	private static void appendModifier(Set<Modifier> result, int modifiers, int modifierConstant, Modifier modifier) {
 		if ((modifiers & modifierConstant) != 0) {
 			result.add(modifier);
@@ -342,6 +404,14 @@ public class Factory {
 			throw new IllegalStateException();
 		}
 	}
+	
+	public PrimitiveTypeImpl getPrimitiveType(BaseTypeBinding binding) {
+		AnnotationBinding[] annotations = binding.getTypeAnnotations();
+		if (annotations == null || annotations.length == 0) {
+			return getPrimitiveType(PrimitiveTypeImpl.getKind(binding));
+		}
+		return new PrimitiveTypeImpl(_env, binding);
+	}
 
 	/**
 	 * Given a binding of uncertain type, try to create the right sort of TypeMirror for it.
@@ -379,12 +449,12 @@ public class Factory {
 		case Binding.BASE_TYPE:
 			BaseTypeBinding btb = (BaseTypeBinding)binding;
 			switch (btb.id) {
-			case TypeIds.T_void:
-				return getNoType(TypeKind.VOID);
-			case TypeIds.T_null:
-				return getNullType();
-			default:
-				return getPrimitiveType(PrimitiveTypeImpl.getKind((BaseTypeBinding)binding));
+				case TypeIds.T_void:
+					return getNoType(TypeKind.VOID);
+				case TypeIds.T_null:
+					return getNullType();
+				default:
+					return getPrimitiveType(btb);
 			}
 
 		case Binding.WILDCARD_TYPE:
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
index 499ff16..39b1f24 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
@@ -1,16 +1,25 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 BEA Systems, Inc.
+ * Copyright (c) 2007, 2013 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
 
+import java.lang.annotation.Annotation;
+import java.util.List;
+
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.type.NoType;
 import javax.lang.model.type.NullType;
 import javax.lang.model.type.TypeKind;
@@ -66,4 +75,17 @@ public class NoTypeImpl implements NoType, NullType
 		}
 	}
 
+	public List<? extends AnnotationMirror> getAnnotationMirrors() {
+		return Factory.EMPTY_ANNOTATION_MIRRORS;
+	}
+
+	public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+		return null;
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+		return (A[]) Factory.EMPTY_ANNOTATIONS;
+	}
+
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
index 77fe2d7..44b0536 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
@@ -1,13 +1,17 @@
 /*******************************************************************************
- * Copyright (c) 2007 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -16,6 +20,7 @@ import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeVisitor;
 
+import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
@@ -44,6 +49,11 @@ public class PrimitiveTypeImpl extends TypeMirrorImpl implements PrimitiveType {
 		super(null, binding);
 	}
 	
+	PrimitiveTypeImpl(BaseProcessingEnvImpl env, BaseTypeBinding binding) {
+		// From Java 8, base type bindings can hold annotations and hence need the environment.
+		super(env, binding);
+	}
+	
 	@Override
 	public <R, P> R accept(TypeVisitor<R, P> v, P p)
 	{
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
index 22b7a44..a08a295 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
@@ -1,23 +1,33 @@
 /*******************************************************************************
- * Copyright (c) 2007 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
 
+import java.lang.annotation.Annotation;
+import java.util.List;
+
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
+import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 /**
  * Implementation of a TypeMirror.  TypeMirror represents a type, including
@@ -26,7 +36,7 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
  */
 public class TypeMirrorImpl implements TypeMirror {
 
-	// Caution: _env will be NULL for PrimitiveTypeImpl.
+	// Caution: _env will be NULL for unannotated primitive types (PrimitiveTypeImpl).
 	protected final BaseProcessingEnvImpl _env;
 	protected final Binding _binding;
 	
@@ -106,5 +116,21 @@ public class TypeMirrorImpl implements TypeMirror {
 		return _binding == other._binding;
 	}
 
+	protected AnnotationBinding[] getAnnotationBindings() {
+		return ((TypeBinding)_binding).getTypeAnnotations();
+	}
+
+	public List<? extends AnnotationMirror> getAnnotationMirrors() {
+		return _env.getFactory().getAnnotationMirrors(getAnnotationBindings());
+	}
+
+	public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+		return _env.getFactory().getAnnotation(getAnnotationBindings(), annotationType);
+	}
+
+	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+		return _env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);
+	}
+
 	
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
index 7da7c3a..60caffd 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
@@ -1,14 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 BEA Systems, Inc.
+ * Copyright (c) 2007, 2013 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
  *    IBM Corporation - fix for 342470
  *    IBM Corporation - fix for 342598
+ *    IBM Corporation - Java 8 support
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -128,13 +133,13 @@ public class TypeParameterElementImpl extends ElementImpl implements TypeParamet
 
 	/*
 	 * (non-Javadoc)
-	 * Java does not currently support annotations on type parameters.
+	 * Java supports annotations on type parameters from JLS8
 	 * @see javax.lang.model.element.Element#getAnnotationMirrors()
 	 */
 	@Override
 	protected AnnotationBinding[] getAnnotationBindings()
 	{
-		return null;
+		return ((TypeVariableBinding)_binding).getTypeAnnotations();
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 5c47287..f93194e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -783,6 +783,11 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 							}
 						}
 						break;
+					default:
+						if (annotations != null) {
+							annotations[i] = annotation.getCompilerAnnotation();
+						}
+						break;
 				}
 				return annotations;
 			} else {
commit 2e4e63b9ed8aad7925bed1f9109d7e2d1a341f45
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Wed Oct 9 21:31:37 2013 +0530

    Incorporation of review comments for Bug 413613 - [1.8] APT should
    support SE8 annotations

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
128	5	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
1	1	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
8	1	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
0	1	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
20	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z1.java
21	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z2.java
41	7	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
44	10	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
1	8	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
5	10	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
1	8	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
14	0	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
6	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
8	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
0	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
6	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index f775e33..51952d6 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
index 0efd902..8fad083 100644
--- a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
@@ -56,8 +56,9 @@ import org.eclipse.jdt.compiler.apt.tests.processors.base.BaseProcessor;
 @SupportedSourceVersion(SourceVersion.RELEASE_8)
 public class Java8ElementProcessor extends BaseProcessor {
 	
-		private static final String[] ELEMENT_NAMES = new String[] {
-			"targets.model8.X", "T", "U", "K", "V"};
+		private static final String[] ELEMENT_NAMES = new String[] {"targets.model8.X", "T", "U", "K", "V", "KK", "VV", "KKK", "VVV"};
+		private static final String[] TYPE_PARAM_ELEMENTS_Z1 = new String[] {"KK", "VV"};
+		private static final String[] TYPE_PARAM_ELEMENTS_Z2 = new String[] {"KKK", "VVV"};
 	
 	RoundEnvironment roundEnv = null;
 	// Always return false from this processor, because it supports "*".
@@ -88,6 +89,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 		}
 		return false;
 	}
+
 	public boolean invokeTestMethods(Map<String, String> options) throws Throwable {
 		Method testMethod = null;
 		Set<String> keys = options.keySet();
@@ -109,6 +111,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 		}
 		return testsFound;
 	}
+
 	public void testAll() throws AssertionFailedError {
 		testSE8Specifics();
 		testLambdaSpecifics();
@@ -124,6 +127,11 @@ public class Java8ElementProcessor extends BaseProcessor {
 		testTypeAnnotations9();
 		testTypeAnnotations10();
 		testTypeAnnotations11();
+		testTypeAnnotations12();
+		testTypeAnnotations13();
+		testTypeAnnotations14();
+		testTypeAnnotations15();
+		testTypeAnnotations16();
 	}
 	
 	public void testLambdaSpecifics() {
@@ -188,7 +196,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 
 		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
 		ExecutableElement method = null;
-		VariableElement field = null, field1 = null;
+		VariableElement field = null, field1 = null, field11 = null;
 		ExecutableElement method2 = null;
 		for (Element member : members) {
 			if ("foo".equals(member.getSimpleName().toString())) {
@@ -199,7 +207,10 @@ public class Java8ElementProcessor extends BaseProcessor {
 				method2 = (ExecutableElement) member;
 			} else if ("_field1".equals(member.getSimpleName().toString())) {
 				field1 = (VariableElement) member;
+			} else if ("_field11".equals(member.getSimpleName().toString())) {
+				field11 = (VariableElement) member;
 			}
+			
 		}
 		assertNotNull("Method should not be null", method);
 		TypeMirror typeMirror = method.getReturnType();
@@ -211,8 +222,12 @@ public class Java8ElementProcessor extends BaseProcessor {
 		typeMirror = field.asType(); 
 		examineSE8AnnotationMethods("Java8ElementProcessor#examineSE8Specifics: ", typeMirror, "f");
 		
+		TypeMirror similar = typeMirror;
 		typeMirror = field1.asType();
+		assertFalse("Should be of same type", _typeUtils.isSameType(typeMirror, similar));
 		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		similar = field11.asType();
+		assertTrue("Should be of same type", _typeUtils.isSameType(typeMirror, similar));
 		
 		typeMirror = method2.getReturnType();
 		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for method noAnnotationHere should not be null", typeMirror);
@@ -435,8 +450,10 @@ public class Java8ElementProcessor extends BaseProcessor {
 		assertEquals("Incorrect no of type params", 2, typeParams.size());
 		TypeParameterElement typeParam = typeParams.get(0);
 		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp1)"});
+		verifyTypeAnnotations(typeParam.asType(), new String[]{"@Type(value=mp1)"});
 		typeParam = typeParams.get(1);
 		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp2)"});
+		verifyTypeAnnotations(typeParam.asType(), new String[]{"@Type(value=mp2)"});
 		//Z<@Type("ta1") String, @Type("ta2") Object> z1 = null;
 		// APIs don't expose the type arguments on a TypeMirror
 		TypeMirror typeMirror = field.asType();
@@ -525,6 +542,107 @@ public class Java8ElementProcessor extends BaseProcessor {
 		ExecutableType type = (ExecutableType) bar2.asType();
 		verifyTypeAnnotations(type.getReceiverType(), new String[]{"@Type(value=receiver)"});
 	}
+	
+	public void testTypeAnnotations13() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		
+		VariableElement field = null;
+		for (VariableElement member : ElementFilter.fieldsIn(members)) {
+			if ("_i".equals(member.getSimpleName().toString())) {
+				field = (VariableElement) member;
+				break;
+			}
+		}
+		TypeMirror typeMirror = field.asType();
+		verifyTypeAnnotations(typeMirror, new String[]{});
+	}
+
+	public void testTypeAnnotations14() {
+		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
+		List<? extends Element> members = _elementUtils.getAllMembers(annotatedType);
+		ExecutableElement main = null;
+		ExecutableElement constr = null;
+		TypeElement XY = null;
+		for (Element member : members) {
+			if ("main".equals(member.getSimpleName().toString())) {
+				main = (ExecutableElement) member;
+			} else if ("<init>".equals(member.getSimpleName().toString())) {
+				constr = (ExecutableElement) member;
+			} else if ("XY".equals(member.getSimpleName().toString())) {
+				XY = (TypeElement) member;
+			}
+		}
+		TypeMirror typeMirror = main.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		assertSame("Should be no type", TypeKind.NONE, typeMirror.getKind());
+		ExecutableType type = (ExecutableType) main.asType();
+		typeMirror = type.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		assertSame("Should be no type", TypeKind.NONE, typeMirror.getKind());				
+		typeMirror = constr.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		assertSame("Should be no type", TypeKind.NONE, typeMirror.getKind());
+		type = (ExecutableType) constr.asType();
+		typeMirror = type.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		assertSame("Should be no type", TypeKind.NONE, typeMirror.getKind());
+		
+		members = _elementUtils.getAllMembers(XY);
+		for (Element member : members) {
+			if ("<init>".equals(member.getSimpleName().toString())) {
+				constr = (ExecutableElement) member;
+			}
+		}
+		typeMirror = constr.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		assertNotSame("Should not be no type", TypeKind.NONE, typeMirror.getKind());
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		type = (ExecutableType) constr.asType();
+		typeMirror = type.getReceiverType();
+		assertNotNull("TypeMirror should not be null", typeMirror);
+		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		assertNotSame("Should not be no type", TypeKind.NONE, typeMirror.getKind());
+	}
+
+	public void testTypeAnnotations15() {
+		Set<String> expectedElementNames = new HashSet<String>(TYPE_PARAM_ELEMENTS_Z1.length);
+		for (String name : TYPE_PARAM_ELEMENTS_Z1) {
+			expectedElementNames.add(name);
+		}
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Type.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		
+		for (Element e : actualElments) {
+			if (e instanceof TypeParameterElement) {
+				String name = ((TypeParameterElement) e).getSimpleName().toString();
+				if (!expectedElementNames.remove(name)) {
+					reportError("Missing root element " + name);
+				}
+			}
+		}
+		assertTrue("Found unexpected extra elements", expectedElementNames.isEmpty());
+	}
+
+	public void testTypeAnnotations16() {
+		Set<String> expectedElementNames = new HashSet<String>(TYPE_PARAM_ELEMENTS_Z2.length);
+		for (String name : TYPE_PARAM_ELEMENTS_Z2) {
+			expectedElementNames.add(name);
+		}
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Type.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		
+		for (Element e : actualElments) {
+			if (e instanceof TypeParameterElement) {
+				String name = ((TypeParameterElement) e).getSimpleName().toString();
+				if (!expectedElementNames.remove(name)) {
+					reportError("Missing root element " + name);
+				}
+			}
+		}
+		assertTrue("Found unexpected extra elements", expectedElementNames.isEmpty());
+	}
+
 	private String getExceptionStackTrace(Throwable t) {
 		StringBuffer buf = new StringBuffer(t.getMessage());
 		StackTraceElement[] traces = t.getStackTrace();
@@ -537,7 +655,6 @@ public class Java8ElementProcessor extends BaseProcessor {
 		return buf.toString();
 	}
 
-	
 	private void verifyTypeAnnotations(AnnotatedConstruct construct, String[] annots) {
 		List<? extends AnnotationMirror> annotations = construct.getAnnotationMirrors();
 		assertEquals("Incorrect no of annotations", annots.length, annotations.size());
@@ -546,6 +663,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 			assertEquals("Invalid annotation value", annots[i], getAnnotationString(mirror));
 		}
 	}
+
 	private String getAnnotationString(AnnotationMirror annot) {
 		DeclaredType annotType = annot.getAnnotationType();
 		TypeElement type = (TypeElement) annotType.asElement();
@@ -562,6 +680,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 		buf.append(')');
 		return buf.toString();
 	}
+
 	private <A extends Annotation> void examineSE8AnnotationMethods(String msg, AnnotatedConstruct construct,  String value) {
 		Type annot = construct.getAnnotation(Type.class);
 		assertNotNull(msg + "Annotation for element " + construct.toString() + " should not be null", annot);
@@ -590,6 +709,11 @@ public class Java8ElementProcessor extends BaseProcessor {
 			reportError(msg + ", should be " + obj1.toString() + " but " + obj2.toString());
 		}
 	}
+	public void assertNotSame(String msg, Object obj1, Object obj2) {
+		if (obj1 == obj2) {
+			reportError(msg + ", " + obj1.toString() + " should not be same as " + obj2.toString());
+		}
+	}
 	public void assertNotNull(String msg, Object obj) {
 		if (obj == null) {
 			reportError(msg);
@@ -635,5 +759,4 @@ public class Java8ElementProcessor extends BaseProcessor {
 			super(msg);
 		}
 	}
-	
 }
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
index 6589eb1..14665d8 100644
--- a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/LambdaTest.java
@@ -32,4 +32,4 @@ interface DefaultInterface {
 
 interface FunctionalInterface {
 	public abstract String abstractMethod ();
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
index b8e690e..1f36cc4 100644
--- a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/X.java
@@ -22,9 +22,11 @@ import org.eclipse.jdt.compiler.apt.tests.annotations.Type.One;
 public class X extends @Type("s") Object implements @Type("i1") I, @Type("i2") J {
 	@Type("f") String _field = null;
 	@Type("f1") X _field1 = null;
+	@Type("f1") X _field11 = null;
 	@Type$1 @One String _field2 = null;
 	X _field3 = null;
 	X. @Type("xy") XY xy;
+	int _i = 10;
 	public void noAnnotationHere() {
 	}
 	@Deprecated @Type("m") String foo() {
@@ -32,7 +34,12 @@ public class X extends @Type("s") Object implements @Type("i1") I, @Type("i2") J
 	}
 	void bar(@Type("p1") String p1, @Type("p2") String p2) {}
 	public void bar2(@Type("receiver") X this) {}
-	class XY {}
+	// Static methods and top level constructors do not have receivers
+	public static void main(String[] args) {}
+	public X(){}
+	class XY {
+		XY(@Type("receiver") X X.this) {}
+	}
 }
 
 interface I {}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
index 2461aad..7a20e55 100644
--- a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z.java
@@ -20,4 +20,3 @@ public class Z <@Type("tp1") K, @Type("tp2") V> {
 	Z<@Type("ta1") String, @Type("ta2") Object> z1 = null;
 	public <@Type("mp1") T, @Type("mp2") U> void foo() {}
 }
-
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z1.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z1.java
new file mode 100644
index 0000000..913d9c6
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z1.java
@@ -0,0 +1,20 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package targets.model8;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+
+public class Z1 <@Type("tp1") KK, @Type("tp2") VV> {
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z2.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z2.java
new file mode 100644
index 0000000..5ceb7bc
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/Z2.java
@@ -0,0 +1,21 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package targets.model8;
+
+import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
+
+public class Z2 {
+	public <@Type("mp1") KKK, @Type("mp2") VVV> void foo() {}
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
index 66e0abc..bba13d5 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
@@ -135,43 +135,77 @@ public class Java8ElementsTests extends TestCase {
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations9");
 	}
 	public void testTypeAnnotations10() throws Exception {
-		System.out.println("Eclipse compiler:");
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
 	}
 	public void testTypeAnnotations10WithJavac() throws Exception {
-		System.out.println("Javac compiler:");
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
 	}
 	public void testTypeAnnotations11() throws Exception {
-		System.out.println("Eclipse compiler:");
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
 	}
 	public void testTypeAnnotations11WithJavac() throws Exception {
-		System.out.println("Javac compiler:");
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
 	}
 	public void testTypeAnnotations12() throws Exception {
-		System.out.println("Eclipse compiler:");
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
 	}
 	public void testTypeAnnotations12WithJavac() throws Exception {
-		System.out.println("Javac compiler:");
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
 	}
+	public void testTypeAnnotations13() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations13");
+	}
+	public void testTypeAnnotations13WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations13");
+	}
+	public void testTypeAnnotations14() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations14");
+	}
+	public void _testTypeAnnotations14WithJavac() throws Exception { // Disabled for now. Javac returns null as receiver type where it should be type 'None'
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations14");
+	}
+	public void testTypeAnnotations15() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
+	}
+	public void testTypeAnnotations15WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
+	}
+	public void testTypeAnnotations16() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
+	}
+	public void testTypeAnnotations16WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
+	}
 
 	private void internalTest(JavaCompiler compiler, String processor, String testMethod) throws IOException {
+		internalTest(compiler, processor, testMethod, null);
+	}
+	private void internalTest(JavaCompiler compiler, String processor, String testMethod, String testClass) throws IOException {
 		if (!canRunJava8()) {
 			return;
 		}
 		System.clearProperty(processor);
 		File targetFolder = TestUtils.concatPath(BatchTestUtils.getSrcFolderName(), "targets", "model8");
-		BatchTestUtils.copyResources("targets/model8", targetFolder);
+		if (testClass == null || testClass.equals("")) {
+			BatchTestUtils.copyResources("targets/model8", targetFolder);
+		} else {
+			BatchTestUtils.copyResource("targets/model8/" + testClass, targetFolder);
+		}
+		
 
 		List<String> options = new ArrayList<String>();
 		options.add("-A" + processor);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
index 74428d8..8bb119f 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
@@ -94,7 +94,23 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 					annotations,
 					constructorBinding);
 		}
-		return true;
+		
+		TypeParameter[] typeParameters = constructorDeclaration.typeParameters;
+		if (typeParameters != null) {
+			int typeParametersLength = typeParameters.length;
+			for (int i = 0; i < typeParametersLength; i++) {
+				typeParameters[i].traverse(this, constructorDeclaration.scope);
+			}
+		}
+		
+		Argument[] arguments = constructorDeclaration.arguments;
+		if (arguments != null) {
+			int argumentLength = arguments.length;
+			for (int i = 0; i < argumentLength; i++) {
+				arguments[i].traverse(this, constructorDeclaration.scope);
+			}
+		}
+		return false;
 	}
 
 	@Override
@@ -132,6 +148,9 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 			if (binding == null) {
 				return false;
 			}
+			// when we get here, it is guaranteed that class type parameters are connected, but method type parameters may not be.			
+			MethodBinding methodBinding = (MethodBinding) binding.declaringElement;
+			((SourceTypeBinding) methodBinding.declaringClass).resolveTypesFor(methodBinding);
 			this.resolveAnnotations(scope, annotations, binding);
 		}
 		return false;
@@ -151,7 +170,23 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 					annotations,
 					methodBinding);
 		}
-		return true;
+		
+		TypeParameter[] typeParameters = methodDeclaration.typeParameters;
+		if (typeParameters != null) {
+			int typeParametersLength = typeParameters.length;
+			for (int i = 0; i < typeParametersLength; i++) {
+				typeParameters[i].traverse(this, methodDeclaration.scope);
+			}
+		}
+		
+		Argument[] arguments = methodDeclaration.arguments;
+		if (arguments != null) {
+			int argumentLength = arguments.length;
+			for (int i = 0; i < argumentLength; i++) {
+				arguments[i].traverse(this, methodDeclaration.scope);
+			}
+		}
+		return false;
 	}
 
 	@Override
@@ -190,17 +225,16 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 			BlockScope scope,
 			Annotation[] annotations,
 			Binding currentBinding) {
-		boolean resolved = false;
+		ASTNode.resolveAnnotations(scope, annotations, currentBinding, true);
+		Element element = null;
+		
 		for (Annotation annotation : annotations) {
 			AnnotationBinding binding = annotation.getCompilerAnnotation();
-			if (binding == null && !resolved) {
-				ASTNode.resolveAnnotations(scope, annotations, currentBinding, true);
-				binding = annotation.getCompilerAnnotation();
-				resolved = true;
-			}
 			if (binding != null) { // binding should be resolved, but in case it's not, ignore it
-				TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType()); 
-				Element element = _factory.newElement(currentBinding);
+				TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType());
+				if (element == null) {
+					element = _factory.newElement(currentBinding);
+				}
 				_annoToElement.put(anno, element);
 			}
 		}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
index 44146a4..d09f2fe 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
@@ -108,14 +108,7 @@ public abstract class ElementImpl
 
 	@Override
 	public String toString() {
-		StringBuffer buf = new StringBuffer();
-		List<? extends AnnotationMirror> annots = getAnnotationMirrors();
-		for (AnnotationMirror annotationMirror : annots) {
-			buf.append(annotationMirror.toString());
-			buf.append(' ');
-		}
-		buf.append(_binding.toString());
-		return buf.toString();
+		return _binding.toString();
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
index 4dc8b16..49e30bf 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
@@ -339,19 +339,14 @@ public class ExecutableElementImpl extends ElementImpl implements
 	}
 
 	public TypeMirror getReceiverType() {
-		MethodBinding binding = (MethodBinding)_binding;
-		if (binding.receiver != null) {
-			return _env.getFactory().newTypeMirror(binding.receiver);
-		}
-		if (binding.declaringClass != null) {
-			return _env.getFactory().newTypeMirror(binding.declaringClass);
-		}
-		return NoTypeImpl.NO_TYPE_NONE;
+		return _env.getFactory().getReceiverType((MethodBinding) _binding);
 	}
 
 	public boolean isDefault() {
-		MethodBinding binding = (MethodBinding)_binding;
-		return binding.isDefaultMethod();
+		if (_binding != null) {
+			return ((MethodBinding)_binding).isDefaultMethod();
+		}
+		return false;
 	}
 
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
index edc58da..0aae47a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
@@ -128,13 +128,6 @@ public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType
 	}
 
 	public TypeMirror getReceiverType() {
-		MethodBinding binding = (MethodBinding)_binding;
-		if (binding.receiver != null) {
-			return _env.getFactory().newTypeMirror(binding.receiver);
-		}
-		if (binding.declaringClass != null) {
-			return _env.getFactory().newTypeMirror(binding.declaringClass);
-		}
-		return NoTypeImpl.NO_TYPE_NONE;
+		return _env.getFactory().getReceiverType((MethodBinding) _binding);
 	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 06ea4ba..63d74f9 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -222,6 +222,20 @@ public class Factory {
     		return null;
     }
     
+	public TypeMirror getReceiverType(MethodBinding binding) {
+		if (binding != null) {
+			if (binding.receiver != null) {
+				return _env.getFactory().newTypeMirror(binding.receiver);
+			}
+			if (binding.declaringClass != null) {
+				if (!binding.isStatic() && (!binding.isConstructor() || binding.declaringClass.isMemberType())) {
+					return _env.getFactory().newTypeMirror(binding.declaringClass);	
+				}
+			}
+		}
+		return NoTypeImpl.NO_TYPE_NONE;
+	}
+    
 	public static Set<Modifier> getModifiers(int modifiers, ElementKind kind) {
 		return getModifiers(modifiers, kind, false);
 	}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
index a08a295..c715726 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
@@ -121,15 +121,18 @@ public class TypeMirrorImpl implements TypeMirror {
 	}
 
 	public List<? extends AnnotationMirror> getAnnotationMirrors() {
-		return _env.getFactory().getAnnotationMirrors(getAnnotationBindings());
+		return _env == null ? Factory.EMPTY_ANNOTATION_MIRRORS : 
+								_env.getFactory().getAnnotationMirrors(getAnnotationBindings());
 	}
 
 	public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
-		return _env.getFactory().getAnnotation(getAnnotationBindings(), annotationType);
+		return _env == null ? null : _env.getFactory().getAnnotation(getAnnotationBindings(), annotationType);
 	}
 
+	@SuppressWarnings("unchecked")
 	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
-		return _env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);
+		return _env == null ? (A[]) Factory.EMPTY_ANNOTATIONS : 
+								_env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);
 	}
 
 	
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
index 187fc0b..bce31a6 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
@@ -395,7 +395,14 @@ public class TypesImpl implements Types {
         }
         Binding b1 = ((TypeMirrorImpl)t1).binding();
         Binding b2 = ((TypeMirrorImpl)t2).binding();
-        return b1 == b2;
+
+        if (b1 == b2) {
+            return true;
+        }
+        if (!(b1 instanceof TypeBinding) || !(b2 instanceof TypeBinding)) {
+            return false;
+        }
+        return ((TypeBinding) b1).unannotated() == ((TypeBinding) b2).unannotated(); 
     }
 
     /* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 3046cba..ca92b16 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -787,11 +787,6 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 							}
 						}
 						break;
-					default:
-						if (annotations != null) {
-							annotations[i] = annotation.getCompilerAnnotation();
-						}
-						break;
 				}
 				return annotations;
 			} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
index 79e978b..4203a0a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
@@ -120,9 +120,12 @@ public class TypeParameter extends AbstractVariableDeclaration {
 		BlockScope resolutionScope = Scope.typeAnnotationsResolutionScope(scope);
 		if (resolutionScope != null) {
 			AnnotationBinding [] annotationBindings = resolveAnnotations(resolutionScope, this.annotations, this.binding, false);
-			this.binding.setTypeAnnotations(annotationBindings, scope.environment().globalOptions.isAnnotationBasedNullAnalysisEnabled);
-			if (this.binding != null && this.binding.isValidBinding())
-				this.binding.evaluateNullAnnotations(scope, this);
+			if (annotationBindings != null && annotationBindings.length > 0) {
+				this.binding.setTypeAnnotations(annotationBindings, scope.environment().globalOptions.isAnnotationBasedNullAnalysisEnabled);
+				scope.referenceCompilationUnit().compilationResult.hasAnnotations = true;
+				if (this.binding != null && this.binding.isValidBinding())
+					this.binding.evaluateNullAnnotations(scope, this);
+			}
 		}	
 	}
 	/* (non-Javadoc)
