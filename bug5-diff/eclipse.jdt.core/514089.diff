commit b6f1674bff043155a08a6b29de138f974df73b2c
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Mar 22 16:48:56 2017 -0700

    Bug 514089 - Build a tool to help debug index corruption
    
    Change-Id: If219721a6a3df77ba1075fccf2cbb80f77128435

4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/FieldOneToOneTest.java
9	2	org.eclipse.jdt.core/.options
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
8	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
21	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
87	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
36	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
22	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
328	100	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
32	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
441	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
59	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/RelatedAddress.java
25	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/BaseField.java
4	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/Field.java
14	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
14	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
15	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
14	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
14	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
14	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
55	39	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
9	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
33	20	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToOne.java
15	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldPointer.java
17	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
28	15	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
15	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
35	21	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
22	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
32	15	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/StructDef.java
3	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
3	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodAnnotationData.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
7	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/FieldOneToOneTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/FieldOneToOneTest.java
index fff8342..6f7631f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/FieldOneToOneTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/FieldOneToOneTest.java
@@ -33,8 +33,8 @@ public class FieldOneToOneTest extends BaseTestCase {
 		static {
 			type = StructDef.create(TestStruct.class, NdNode.type);
 
-			ANOTHER_STRUCT = FieldOneToOne.create(type, TestStruct2.class, TestStruct2.ANOTHER_STRUCT);
-			OWNED = FieldOneToOne.create(type, TestStruct2.class, TestStruct2.OWNER);
+			ANOTHER_STRUCT = FieldOneToOne.create(type, TestStruct2.type, TestStruct2.ANOTHER_STRUCT);
+			OWNED = FieldOneToOne.create(type, TestStruct2.type, TestStruct2.OWNER);
 			type.done();
 		}
 
@@ -79,8 +79,8 @@ public class FieldOneToOneTest extends BaseTestCase {
 		static {
 			type = StructDef.create(TestStruct2.class, NdNode.type);
 
-			OWNER = FieldOneToOne.createOwner(type, TestStruct.class, TestStruct.OWNED);
-			ANOTHER_STRUCT = FieldOneToOne.create(type, TestStruct.class, TestStruct.ANOTHER_STRUCT);
+			OWNER = FieldOneToOne.createOwner(type, TestStruct.type, TestStruct.OWNED);
+			ANOTHER_STRUCT = FieldOneToOne.create(type, TestStruct.type, TestStruct.ANOTHER_STRUCT);
 
 			type.done();
 		}
diff --git a/org.eclipse.jdt.core/.options b/org.eclipse.jdt.core/.options
index e5bdf26..a90286e 100644
--- a/org.eclipse.jdt.core/.options
+++ b/org.eclipse.jdt.core/.options
@@ -62,8 +62,12 @@ org.eclipse.jdt.core/debug/javamodel/insertions=false
 # Records information about the invalid archive cache
 org.eclipse.jdt.core/debug/javamodel/invalid_archives=false
 
-# Runs self-diagnostics on the large chunk free space tree
-org.eclipse.jdt.core/debug/index/largechunks=false
+# Runs self-diagnostics on the free space lists. This is expensive and will slow down indexing.
+org.eclipse.jdt.core/debug/index/freespacetest=false
+
+# Controls the amount of memory used by the traceback log, in megabytes (suggested size = 1024).
+# If nonzero, the index will print out detailed traceback information when corruption is detected. 
+org.eclipse.jdt.core/debug/index/logsizemegs=0
 
 # Logs every time a page is allocated, flushed, or inserted/removed from the page cache (very verbose)
 org.eclipse.jdt.core/debug/index/pagecache=false
@@ -77,6 +81,9 @@ org.eclipse.jdt.core/debug/index/insertions=false
 # Prints diagnostic information about index database locks
 org.eclipse.jdt.core/debug/index/locks=false
 
+# Prints a message whenever the indexer is scheduled. Useful for tracking race conditions in the unit tests.
+org.eclipse.jdt.core/debug/index/scheduling=false
+
 # Prints statistics about database memory usage
 org.eclipse.jdt.core/debug/index/space=false
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index eb2009c..5aaa78f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -366,14 +366,16 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	private static final String SEARCH_DEBUG = JavaCore.PLUGIN_ID + "/debug/search" ; //$NON-NLS-1$
 	private static final String SOURCE_MAPPER_DEBUG_VERBOSE = JavaCore.PLUGIN_ID + "/debug/sourcemapper" ; //$NON-NLS-1$
 	private static final String FORMATTER_DEBUG = JavaCore.PLUGIN_ID + "/debug/formatter" ; //$NON-NLS-1$
-	private static final String INDEX_DEBUG_LARGE_CHUNKS = JavaCore.PLUGIN_ID + "/debug/index/largechunks" ; //$NON-NLS-1$
+	private static final String INDEX_DEBUG_LARGE_CHUNKS = JavaCore.PLUGIN_ID + "/debug/index/freespacetest" ; //$NON-NLS-1$
 	private static final String INDEX_DEBUG_PAGE_CACHE = JavaCore.PLUGIN_ID + "/debug/index/pagecache" ; //$NON-NLS-1$
 	private static final String INDEX_INDEXER_DEBUG = JavaCore.PLUGIN_ID + "/debug/index/indexer" ; //$NON-NLS-1$
 	private static final String INDEX_INDEXER_INSERTIONS = JavaCore.PLUGIN_ID + "/debug/index/insertions" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_SCHEDULING = JavaCore.PLUGIN_ID + "/debug/index/scheduling" ; //$NON-NLS-1$
 	private static final String INDEX_INDEXER_SELFTEST = JavaCore.PLUGIN_ID + "/debug/index/selftest" ; //$NON-NLS-1$
 	private static final String INDEX_LOCKS_DEBUG = JavaCore.PLUGIN_ID + "/debug/index/locks" ; //$NON-NLS-1$
 	private static final String INDEX_INDEXER_SPACE = JavaCore.PLUGIN_ID + "/debug/index/space" ; //$NON-NLS-1$
 	private static final String INDEX_INDEXER_TIMING = JavaCore.PLUGIN_ID + "/debug/index/timing" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_LOG_SIZE_MEGS = JavaCore.PLUGIN_ID + "/debug/index/logsizemegs"; //$NON-NLS-1$
 
 	public static final String COMPLETION_PERF = JavaCore.PLUGIN_ID + "/perf/completion" ; //$NON-NLS-1$
 	public static final String SELECTION_PERF = JavaCore.PLUGIN_ID + "/perf/selection" ; //$NON-NLS-1$
@@ -1837,13 +1839,15 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 				JavaModelManager.ZIP_ACCESS_VERBOSE = debug && options.getBooleanOption(ZIP_ACCESS_DEBUG, false);
 				SourceMapper.VERBOSE = debug && options.getBooleanOption(SOURCE_MAPPER_DEBUG_VERBOSE, false);
 				DefaultCodeFormatter.DEBUG = debug && options.getBooleanOption(FORMATTER_DEBUG, false);
-				Database.DEBUG_LARGE_CHUNKS = debug && options.getBooleanOption(INDEX_DEBUG_LARGE_CHUNKS, false);
+				Database.DEBUG_FREE_SPACE = debug && options.getBooleanOption(INDEX_DEBUG_LARGE_CHUNKS, false);
 				Database.DEBUG_PAGE_CACHE = debug && options.getBooleanOption(INDEX_DEBUG_PAGE_CACHE, false);
 				Indexer.DEBUG = debug && options.getBooleanOption(INDEX_INDEXER_DEBUG, false);
 				Indexer.DEBUG_INSERTIONS = debug  && options.getBooleanOption(INDEX_INDEXER_INSERTIONS, false);
 				Indexer.DEBUG_ALLOCATIONS = debug && options.getBooleanOption(INDEX_INDEXER_SPACE, false);
 				Indexer.DEBUG_TIMING = debug && options.getBooleanOption(INDEX_INDEXER_TIMING, false);
+				Indexer.DEBUG_SCHEDULING = debug && options.getBooleanOption(INDEX_INDEXER_SCHEDULING, false);
 				Indexer.DEBUG_SELFTEST = debug && options.getBooleanOption(INDEX_INDEXER_SELFTEST, false);
+				Indexer.DEBUG_LOG_SIZE_MB = debug ? options.getIntegerOption(INDEX_INDEXER_LOG_SIZE_MEGS, 0) : 0;
 				Nd.sDEBUG_LOCKS = debug && options.getBooleanOption(INDEX_LOCKS_DEBUG, false);
 		
 				// configure performance options
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index cd45e92..7044df6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -706,4 +706,12 @@ public final class Nd {
 	public boolean isValidAddress(long address) {
 		return address > 0 && address < (long) getDB().getChunkCount() * Database.CHUNK_SIZE;
 	}
+
+	/**
+	 * Creates a {@link ProblemBuilder} object that collects information about database corruption after it is 
+	 * detected.
+	 */
+	public ProblemBuilder describeProblem() {
+		return this.db.describeProblem();
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index 2fc229c..6511604 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -53,19 +53,36 @@ public abstract class NdNode implements IDestructable {
 			return null;
 		}
 
-		return nd.getNode(address, NODE_TYPE.get(nd, address));
+		try {
+			return nd.getNode(address, NODE_TYPE.get(nd, address));
+		} catch (IndexException e) {
+			// Add metadata to the exception describing where we obtained the node type from
+			nd.describeProblem().addProblemAddress(NODE_TYPE, address).attachTo(e);
+			throw e;
+		}
 	}
 
 	@SuppressWarnings("unchecked")
-	public static <T extends NdNode> T load(Nd nd, long address, Class<T> clazz) {
+	public static <T extends NdNode> T load(Nd nd, long address, StructDef<T> targetType) {
 		if (address == 0) {
 			return null;
 		}
 
-		NdNode result = nd.getNode(address, NODE_TYPE.get(nd, address));
+		NdNode result;
+		try {
+			// Polymorphic types (that subclass NdNode) store a header with their type ID
+			result = nd.getNode(address, NODE_TYPE.get(nd, address));
+		} catch (IndexException e) {
+			// Add metadata to the exception describing where we obtained the node type from
+			nd.describeProblem().addProblemAddress(NODE_TYPE, address).attachTo(e);
+			throw e;
+		}
 
+		Class<T> clazz = targetType.getStructClass();
 		if (!clazz.isAssignableFrom(result.getClass())) {
-			throw new IndexException("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
+			nd.describeProblem()
+				.addProblemAddress(NODE_TYPE, address)
+				.throwException("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
 					clazz + " but found " + result.getClass()); //$NON-NLS-1$
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
new file mode 100644
index 0000000..dc9434b
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ * Copyright (c) 2017 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.MemoryAccessLog;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
+import org.eclipse.jdt.internal.core.nd.db.RelatedAddress;
+import org.eclipse.jdt.internal.core.nd.field.IField;
+
+/**
+ * Given a set of memory ranges, this class constructs detailed error messages.
+ */
+public final class ProblemBuilder {
+	private final Database db;
+	private final List<RelatedAddress> relatedAddresses = new ArrayList<>();
+
+	/**
+	 * Constructs a new {@link ProblemBuilder}
+	 */
+	public ProblemBuilder(Database db) {
+		this.db = db;
+	}
+
+	/**
+	 * Adds an address range to this problem description, given the first address that may be corrupt,
+	 * the size of the possibly-corrupt address range, and a custom description for the memory at this
+	 * address range.
+	 */
+	public ProblemBuilder addProblemAddress(String description, long dataBlockAddress, int rangeSize) {
+		MemoryAccessLog lastWrite = this.db.getLog().getReportFor(dataBlockAddress, rangeSize);
+		this.relatedAddresses.add(new RelatedAddress(description, dataBlockAddress, rangeSize, lastWrite));
+		return this;
+	}
+
+	/**
+	 * Adds an address range to this problem description, given a field that may be corrupt, the base
+	 * address for its struct, and a custom description for the field.
+	 * 
+	 * @return this
+	 */
+	public ProblemBuilder addProblemAddress(String description, IField field, long address) {
+		long offset = field.getOffset();
+		int size = field.getRecordSize();
+		return addProblemAddress(description, address + offset, size);
+	}
+
+	/**
+	 * Adds an address range to this problem description, given the field that may be corrupt
+	 * and the base address for its struct.
+	 * 
+	 * @return this
+	 */
+	public ProblemBuilder addProblemAddress(IField field, long address) {
+		return addProblemAddress(field.getFieldName(), field, address);
+	}
+
+	/**
+	 * Throws an {@link IndexException} containing the given message and all the addresses collected
+	 * by this object. 
+	 */
+	public void throwException(String description) {
+		IndexException toThrow = new IndexException(description);
+		attachTo(toThrow);
+		throw toThrow;
+	}
+
+	/**
+	 * Attaches the addresses collected by the receiver to the given exception.
+	 */
+	public void attachTo(IndexException exception) {
+		for (RelatedAddress next : this.relatedAddresses) {
+			exception.addRelatedAddress(next);
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
index 93b4e6f..03a3404 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
@@ -204,10 +204,17 @@ public final class RawGrowableArray {
 		int insertionIndex = size(nd, address);
 		int newSize = insertionIndex + 1;
 
-		ensureCapacity(nd, address, newSize);
-		long recordAddress = getAddressOfRecord(nd, address, insertionIndex);
-		db.putRecPtr(recordAddress, value);
-		setSize(nd, address, newSize);
+		try {
+			ensureCapacity(nd, address, newSize);
+			long recordAddress = getAddressOfRecord(nd, address, insertionIndex);
+			db.putRecPtr(recordAddress, value);
+			setSize(nd, address, newSize);
+		} catch (IndexException e) {
+			ProblemBuilder descriptor = nd.describeProblem();
+			addSizeTo(nd, address, descriptor);
+			descriptor.attachTo(e);
+			throw e;
+		}
 		return insertionIndex;
 	}
 
@@ -378,7 +385,12 @@ public final class RawGrowableArray {
 
 			// We use reads of 1 past the end of the array to handle insertions.
 			if (index > size) {
-				throw new IndexException(
+				ProblemBuilder builder = nd.describeProblem();
+
+				addSizeTo(nd, address, builder);
+
+				builder.addProblemAddress(GROWABLE_BLOCK_ADDRESS, address);
+				builder.throwException(
 						"Record index " + index + " out of range. Array contains " + size + " elements"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			}
 
@@ -390,8 +402,15 @@ public final class RawGrowableArray {
 				int blockRelativeIndex = growableBlockRelativeIndex % GrowableBlockHeader.MAX_GROWABLE_SIZE;
 				int block = growableBlockRelativeIndex / GrowableBlockHeader.MAX_GROWABLE_SIZE;
 
-				growableBlockAddress = db.getRecPtr(growableBlockAddress + MetaBlockHeader.META_BLOCK_HEADER_BYTES
-						+ block * Database.PTR_SIZE);
+				long dataBlockAddress = growableBlockAddress + MetaBlockHeader.META_BLOCK_HEADER_BYTES
+						+ block * Database.PTR_SIZE;
+				growableBlockAddress = db.getRecPtr(dataBlockAddress);
+				if (growableBlockAddress == 0) {
+					nd.describeProblem()
+						.addProblemAddress("backpointer number " + block, dataBlockAddress, Database.PTR_SIZE) //$NON-NLS-1$
+						.addProblemAddress(GROWABLE_BLOCK_ADDRESS, address)
+						.throwException("Null data block found in metablock"); //$NON-NLS-1$
+				}
 				growableBlockRelativeIndex = blockRelativeIndex;
 			}
 
@@ -403,6 +422,13 @@ public final class RawGrowableArray {
 		}
 	}
 
+	private void addSizeTo(Nd nd, long address, ProblemBuilder builder) {
+		long growableBlockAddress = GROWABLE_BLOCK_ADDRESS.get(nd, address);
+		if (growableBlockAddress != 0) {
+			builder.addProblemAddress(GrowableBlockHeader.ARRAY_SIZE, growableBlockAddress);
+		}
+	}
+
 	/**
 	 * Removes an entry from the array, given an element index. If the given index is not the last element
 	 * in the list, the last element will have its index swapped with the removed element. If another element
@@ -415,7 +441,9 @@ public final class RawGrowableArray {
 
 		Database db = nd.getDB();
 		if (index > lastElementIndex || index < 0) {
-			throw new IndexException("Attempt to remove nonexistent element " + index //$NON-NLS-1$
+			ProblemBuilder descriptor = nd.describeProblem().addProblemAddress(GROWABLE_BLOCK_ADDRESS, address);
+			addSizeTo(nd, address, descriptor);
+			descriptor.throwException("Attempt to remove nonexistent element " + index //$NON-NLS-1$
 					+ " from an array of size " + (lastElementIndex + 1)); //$NON-NLS-1$
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
index 2c9ec0b..6ed8006 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/BTree.java
@@ -347,7 +347,7 @@ public class BTree {
 		}
 
 		public void makeWritable() {
-			this.chunk = chunk.getWritableChunk();
+			this.chunk = this.chunk.getWritableChunk();
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
index 92fcd7a..820ff74 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Chunk.java
@@ -102,13 +102,14 @@ final class Chunk {
 		return wasCanceled;
 	}
 
-	private static int recPtrToIndex(final long offset) {
+	static int recPtrToIndex(final long offset) {
 		return (int) (offset & Database.OFFSET_IN_CHUNK_MASK);
 	}
 
 	public void putByte(final long offset, final byte value) {
 		makeDirty();
 		this.fBuffer[recPtrToIndex(offset)]= value;
+		recordWrite(offset, 1);
 	}
 
 	public byte getByte(final long offset) {
@@ -133,12 +134,14 @@ final class Chunk {
 	public void putBytes(final long offset, final byte[] bytes) {
 		makeDirty();
 		System.arraycopy(bytes, 0, this.fBuffer, recPtrToIndex(offset), bytes.length);
+		recordWrite(offset, bytes.length);
 	}
 
 	public void putInt(final long offset, final int value) {
 		makeDirty();
 		int idx= recPtrToIndex(offset);
 		putInt(value, this.fBuffer, idx);
+		recordWrite(offset, 4);
 	}
 
 	static final void putInt(final int value, final byte[] buffer, int idx) {
@@ -194,6 +197,7 @@ final class Chunk {
 		makeDirty();
 		int idx = recPtrToIndex(offset);
 		Database.putRecPtr(value, this.fBuffer, idx);
+		recordWrite(offset, 4);
 	}
 
 	/**
@@ -204,6 +208,7 @@ final class Chunk {
 		makeDirty();
 		int idx = recPtrToIndex(offset);
 		putInt(compressFreeRecPtr(value), this.fBuffer, idx);
+		recordWrite(offset, 4);
 	}
 
 	public long getRecPtr(final long offset) {
@@ -223,6 +228,7 @@ final class Chunk {
 		this.fBuffer[idx]= (byte) (value >> 16);
 		this.fBuffer[++idx]= (byte) (value >> 8);
 		this.fBuffer[++idx]= (byte) (value);
+		recordWrite(offset, 3);
 	}
 
 	public int get3ByteUnsignedInt(final long offset) {
@@ -237,6 +243,11 @@ final class Chunk {
 		int idx= recPtrToIndex(offset);
 		this.fBuffer[idx]= (byte) (value >> 8);
 		this.fBuffer[++idx]= (byte) (value);
+		recordWrite(offset, 2);
+	}
+
+	private void recordWrite(long offset, int size) {
+		this.fDatabase.getLog().recordWrite(offset, size);
 	}
 
 	public short getShort(final long offset) {
@@ -276,6 +287,7 @@ final class Chunk {
 		this.fBuffer[++idx]= (byte) (value >> 16);
 		this.fBuffer[++idx]= (byte) (value >> 8);
 		this.fBuffer[++idx]= (byte) (value);
+		recordWrite(offset, 8);
 	}
 
 	public void putChar(final long offset, final char value) {
@@ -283,6 +295,7 @@ final class Chunk {
 		int idx= recPtrToIndex(offset);
 		this.fBuffer[idx]= (byte) (value >> 8);
 		this.fBuffer[++idx]= (byte) (value);
+		recordWrite(offset, 2);
 	}
 
 	public void putChars(final long offset, char[] chars, int start, int len) {
@@ -294,6 +307,7 @@ final class Chunk {
 			this.fBuffer[++idx]= (byte) (value >> 8);
 			this.fBuffer[++idx]= (byte) (value);
 		}
+		recordWrite(offset, len * 2);
 	}
 
 	public void putCharsAsBytes(final long offset, char[] chars, int start, int len) {
@@ -304,6 +318,7 @@ final class Chunk {
 			char value= chars[i];
 			this.fBuffer[++idx]= (byte) (value);
 		}
+		recordWrite(offset, len);
 	}
 
 	public void putDouble(final long offset, double value) {
@@ -336,9 +351,14 @@ final class Chunk {
 		makeDirty();
 		int idx = recPtrToIndex(offset);
 		final int end = idx + length;
+		if (end > this.fBuffer.length) {
+			throw new IndexException("Attempting to clear beyond end of chunk. Chunk = " + this.fSequenceNumber //$NON-NLS-1$
+					+ ", offset = " + offset + ", length = " + length); //$NON-NLS-1$//$NON-NLS-2$
+		}
 		for (; idx < end; idx++) {
 			this.fBuffer[idx] = 0;
 		}
+		recordWrite(offset, length);
 	}
 
 	void put(final long offset, final byte[] data, final int len) {
@@ -349,6 +369,7 @@ final class Chunk {
 		makeDirty();
 		int idx = recPtrToIndex(offset);
 		System.arraycopy(data, dataPos, this.fBuffer, idx, len);
+		recordWrite(offset, len);
 	}
 
 	public void get(final long offset, byte[] data) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 421ec82..25c34cf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -31,11 +31,21 @@ import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.OperationCanceledException;
 import org.eclipse.core.runtime.Status;
+import org.eclipse.jdt.internal.core.nd.ProblemBuilder;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.osgi.util.NLS;
 
 /**
  * Database encapsulates access to a flat binary format file with a memory-manager-like API for
  * obtaining and releasing areas of storage (memory).
+ * <p>
+ * Some terminology is used throughout this class: A block is a variable-size piece of
+ * contiguous memory returned by malloc. A chunk is a fixed-size piece of contiguous memory
+ * that is the atomic unit for paging, caching, reads, and writes. A free block is contiguous
+ * variable-length piece of memory that is created by free and is potentially usable by malloc.
+ * Most chunks contain multiple blocks and free blocks, but it is possible for a single block
+ * to use multiple chunks. Such blocks are referred to as "large blocks". A free block is always
+ * smaller than a chunk.
  */
 /*
  * The file encapsulated is divided into Chunks of size CHUNK_SIZE, and a table of contents
@@ -157,7 +167,7 @@ public class Database {
 	/**
 	 * True iff large chunk self-diagnostics should be enabled.
 	 */
-	public static boolean DEBUG_LARGE_CHUNKS;
+	public static boolean DEBUG_FREE_SPACE;
 
 	public static boolean DEBUG_PAGE_CACHE;
 
@@ -196,8 +206,14 @@ public class Database {
 	private long totalFlushTime;
 	private long totalWriteTimeMs;
 	private long pageWritesBytes;
+	private long nextValidation;
+	private long validateCounter;
 	public static final double MIN_BYTES_PER_MILLISECOND = 20480.0;
 
+	private final ModificationLog log = new ModificationLog(0);
+	private final Tag mallocTag;
+	private final Tag freeTag;
+
 	/**
 	 * Construct a new Database object, creating a backing file if necessary.
 	 * @param location the local file path for the database
@@ -207,6 +223,8 @@ public class Database {
 	 * @throws IndexException
 	 */
 	public Database(File location, ChunkCache cache, int version, boolean openReadOnly) throws IndexException {
+		this.mallocTag = ModificationLog.createTag("Calling Database.malloc"); //$NON-NLS-1$
+		this.freeTag = ModificationLog.createTag("Calling Database.free"); //$NON-NLS-1$
 		try {
 			this.fLocation = location;
 			this.fReadOnly= openReadOnly;
@@ -265,6 +283,10 @@ public class Database {
 		} while (true);
 	}
 
+	public ModificationLog getLog() {
+		return this.log;
+	}
+
 	/**
 	 * Attempts to write to the given position in the file. Will retry if interrupted by Thread.interrupt() until,
 	 * the write succeeds. It will return true if any call to Thread.interrupt() was detected.
@@ -347,6 +369,7 @@ public class Database {
 		boolean wasCanceled = false;
 		removeChunksFromCache();
 
+		this.log.clear();
 		this.fVersion= version;
 		// Clear the first chunk.
 		this.fHeaderChunk.clear(0, CHUNK_SIZE);
@@ -502,65 +525,84 @@ public class Database {
 		assert this.fExclusiveLock;
 		assert datasize >= 0;
 		assert datasize <= MAX_MALLOC_SIZE;
-
+		
 		long result;
 		int usedSize;
-		if (datasize >= MAX_SINGLE_BLOCK_MALLOC_SIZE) {
-			int newChunkNum = createLargeBlock(datasize);
-			usedSize = Math.abs(getBlockHeaderForChunkNum(newChunkNum)) * CHUNK_SIZE;
-			result = (long) newChunkNum * CHUNK_SIZE + LargeBlock.HEADER_SIZE;
-			// Note that we identify large blocks by setting their block size to 0.
-			clearRange(result, usedSize - LargeBlock.HEADER_SIZE - LargeBlock.FOOTER_SIZE);
-			result = result + BLOCK_HEADER_SIZE;
-		} else {
-			long freeBlock = 0;
-			int needDeltas = divideRoundingUp(datasize + BLOCK_HEADER_SIZE, BLOCK_SIZE_DELTA);
-			if (needDeltas < MIN_BLOCK_DELTAS) {
-				needDeltas = MIN_BLOCK_DELTAS;
-			}
-
-			// Which block size.
-			int useDeltas;
-			for (useDeltas = needDeltas; useDeltas <= MAX_BLOCK_DELTAS; useDeltas++) {
-				freeBlock = getFirstBlock(useDeltas * BLOCK_SIZE_DELTA);
-				if (freeBlock != 0)
-					break;
-			}
-
-			// Get the block.
-			Chunk chunk;
-			if (freeBlock == 0) {
-				// Allocate a new chunk.
-				freeBlock = (long) (createLargeBlock(datasize)) * (long) CHUNK_SIZE + LargeBlock.HEADER_SIZE;
-				useDeltas = MAX_BLOCK_DELTAS;
-				chunk = getChunk(freeBlock);
+		this.log.start(this.mallocTag);
+		try {
+			if (datasize >= MAX_SINGLE_BLOCK_MALLOC_SIZE) {
+				int newChunkNum = createLargeBlock(datasize);
+				usedSize = Math.abs(getBlockHeaderForChunkNum(newChunkNum)) * CHUNK_SIZE;
+				result = (long) newChunkNum * CHUNK_SIZE + LargeBlock.HEADER_SIZE;
+				// Note that we identify large blocks by setting their block size to 0.
+				clearRange(result, usedSize - LargeBlock.HEADER_SIZE - LargeBlock.FOOTER_SIZE);
+				result = result + BLOCK_HEADER_SIZE;
 			} else {
-				chunk = getChunk(freeBlock);
-				chunk.makeDirty();
-				removeBlock(chunk, useDeltas * BLOCK_SIZE_DELTA, freeBlock);
-			}
-
-			final int unusedDeltas = useDeltas - needDeltas;
-			if (unusedDeltas >= MIN_BLOCK_DELTAS) {
-				// Add in the unused part of our block.
-				addBlock(chunk, unusedDeltas * BLOCK_SIZE_DELTA, freeBlock + needDeltas * BLOCK_SIZE_DELTA);
-				useDeltas = needDeltas;
+				long freeBlock = 0;
+				int needDeltas = divideRoundingUp(datasize + BLOCK_HEADER_SIZE, BLOCK_SIZE_DELTA);
+				if (needDeltas < MIN_BLOCK_DELTAS) {
+					needDeltas = MIN_BLOCK_DELTAS;
+				}
+	
+				// Which block size.
+				int useDeltas;
+				for (useDeltas = needDeltas; useDeltas <= MAX_BLOCK_DELTAS; useDeltas++) {
+					freeBlock = getFirstBlock(useDeltas * BLOCK_SIZE_DELTA);
+					if (freeBlock != 0)
+						break;
+				}
+	
+				// Get the block.
+				Chunk chunk;
+				if (freeBlock == 0) {
+					// Allocate a new chunk.
+					freeBlock = (long) (createLargeBlock(datasize)) * (long) CHUNK_SIZE + LargeBlock.HEADER_SIZE;
+					useDeltas = MAX_BLOCK_DELTAS;
+					chunk = getChunk(freeBlock);
+				} else {
+					chunk = getChunk(freeBlock);
+					chunk.makeDirty();
+					int blockReportedSize = chunk.getShort(freeBlock);
+					if (blockReportedSize != useDeltas * BLOCK_SIZE_DELTA) {
+						describeProblem()
+							.addProblemAddress("block size", freeBlock, SHORT_SIZE) //$NON-NLS-1$
+							.throwException(
+								"Heap corruption detected in free space list. Block " + freeBlock //$NON-NLS-1$
+								+ " reports a size of " + blockReportedSize + " but was in the list for blocks of size "  //$NON-NLS-1$//$NON-NLS-2$
+								+ useDeltas * BLOCK_SIZE_DELTA);
+					}
+					removeBlock(chunk, useDeltas * BLOCK_SIZE_DELTA, freeBlock);
+				}
+	
+				final int unusedDeltas = useDeltas - needDeltas;
+				if (unusedDeltas >= MIN_BLOCK_DELTAS) {
+					// Add in the unused part of our block.
+					addBlock(chunk, unusedDeltas * BLOCK_SIZE_DELTA, freeBlock + needDeltas * BLOCK_SIZE_DELTA);
+					useDeltas = needDeltas;
+				}
+	
+				// Make our size negative to show in use.
+				usedSize = useDeltas * BLOCK_SIZE_DELTA;
+				chunk.putShort(freeBlock, (short) -usedSize);
+	
+				// Clear out the block, lots of people are expecting this.
+				chunk.clear(freeBlock + BLOCK_HEADER_SIZE, usedSize - BLOCK_HEADER_SIZE);
+				result = freeBlock + BLOCK_HEADER_SIZE;
 			}
-
-			// Make our size negative to show in use.
-			usedSize = useDeltas * BLOCK_SIZE_DELTA;
-			chunk.putShort(freeBlock, (short) -usedSize);
-
-			// Clear out the block, lots of people are expecting this.
-			chunk.clear(freeBlock + BLOCK_HEADER_SIZE, usedSize - BLOCK_HEADER_SIZE);
-			result = freeBlock + BLOCK_HEADER_SIZE;
+		} finally {
+			this.log.end(this.mallocTag);
 		}
 
+		this.log.recordMalloc(result, usedSize - BLOCK_HEADER_SIZE);
 		this.malloced += usedSize;
 		this.memoryUsage.recordMalloc(poolId, usedSize);
 
-		if (DEBUG_LARGE_CHUNKS) {
-			validateFreeSpaceTries();
+		if (DEBUG_FREE_SPACE) {
+			boolean performedValidation = periodicValidateFreeSpace();
+
+			if (performedValidation) {
+				verifyNotInFreeSpaceList(result);
+			}
 		}
 
 		return result;
@@ -631,6 +673,22 @@ public class Database {
 		} else {
 			numChunks = getBlockHeaderForChunkNum(freeBlockChunkNum);
 
+			if (numChunks < neededChunks) {
+				describeProblem()
+					.addProblemAddress("chunk header", freeBlockChunkNum * CHUNK_SIZE, INT_SIZE) //$NON-NLS-1$
+					.throwException("A block in the free space trie was too small or wasn't actually free. Reported size = " //$NON-NLS-1$
+							+ numChunks + " chunks, requested size = " + neededChunks + " chunks");  //$NON-NLS-1$//$NON-NLS-2$
+			}
+
+			int footer = getBlockFooterForChunkBefore(freeBlockChunkNum + numChunks);
+			if (footer != numChunks) {
+				describeProblem()
+					.addProblemAddress("chunk header", freeBlockChunkNum * CHUNK_SIZE, INT_SIZE) //$NON-NLS-1$
+					.addProblemAddress("chunk footer", (freeBlockChunkNum + numChunks) * CHUNK_SIZE - INT_SIZE, INT_SIZE) //$NON-NLS-1$
+					.throwException("The header and footer didn't match for a block in the free space trie. Expected " //$NON-NLS-1$
+							+ numChunks + " but found " + footer); //$NON-NLS-1$
+			}
+
 			unlinkFreeBlock(freeBlockChunkNum);
 		}
 
@@ -774,7 +832,7 @@ public class Database {
 		for (int testPosition = firstDifference; testPosition < LargeBlock.ENTRIES_IN_CHILD_TABLE; testPosition++) {
 			if (((currentSize & bitMask) != 0) == lookingForSmallerChild) {
 				int nextChildChunkNum = getInt(
-						(long) trieNodeChunkNum * CHUNK_SIZE + LargeBlock.CHILD_TABLE_OFFSET + (testPosition * PTR_SIZE));
+						(long) trieNodeChunkNum * CHUNK_SIZE + LargeBlock.CHILD_TABLE_OFFSET + (testPosition * INT_SIZE));
 				int childResultChunkNum = getSmallestChildNoSmallerThan(nextChildChunkNum, numChunks);
 				if (childResultChunkNum != 0) {
 					return childResultChunkNum;
@@ -807,6 +865,111 @@ public class Database {
 		insertChild(getInt(FREE_BLOCK_OFFSET), freeBlockChunkNum);
 	}
 
+	private void validateFreeSpace() {
+		validateFreeSpaceLists();
+		validateFreeSpaceTries();
+	}
+
+	/**
+	 * Performs a self-test on the free space lists used by malloc to check for corruption
+	 */
+	private void validateFreeSpaceLists() {
+		int useDeltas;
+		for (useDeltas = MIN_BLOCK_DELTAS; useDeltas <= MAX_BLOCK_DELTAS; useDeltas++) {
+			validateFreeBlocksFor(useDeltas);
+		}
+	}
+
+	private void verifyNotInFreeSpaceList(long result) {
+		int useDeltas;
+		for (useDeltas = MIN_BLOCK_DELTAS; useDeltas <= MAX_BLOCK_DELTAS; useDeltas++) {
+			int correctSize = useDeltas * BLOCK_SIZE_DELTA;
+			long block = getFirstBlock(correctSize);
+			long addressOfPrevBlockPointer = getAddressOfFirstBlockPointer(correctSize);
+			while (block != 0) {
+				if (block == result) {
+					describeProblem()
+						.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
+						.throwException("Block " + result  //$NON-NLS-1$
+							+ " was found in the free space list, even though it wasn't free"); //$NON-NLS-1$
+				}
+				addressOfPrevBlockPointer = block + BLOCK_NEXT_OFFSET;
+				long followingBlock = getFreeRecPtr(addressOfPrevBlockPointer);
+				block = followingBlock;
+			}
+		}
+
+		int currentChunkNum = getInt(FREE_BLOCK_OFFSET);
+
+		if (currentChunkNum == 0) {
+			return;
+		}
+		int targetChunkNum = (int) (result / CHUNK_SIZE);
+
+		if (currentChunkNum == targetChunkNum) {
+			describeProblem().throwException("Block " + result  //$NON-NLS-1$
+					+ " was not supposed to be in the free space list, but was linked as the root of the list"); //$NON-NLS-1$
+		}
+
+		verifyNotInLargeBlockFreeSpaceTrie(targetChunkNum, currentChunkNum, 0);
+	}
+
+	private void verifyNotInLargeBlockFreeSpaceTrie(int targetChunkNum, int chunkNum, int parent) {
+		long chunkStart = chunkNum * CHUNK_SIZE;
+
+		for (int testPosition = 0; testPosition < LargeBlock.ENTRIES_IN_CHILD_TABLE; testPosition++) {
+			long chunkAddress = chunkStart + LargeBlock.CHILD_TABLE_OFFSET + (testPosition * INT_SIZE);
+			int nextChildChunkNum = getInt(chunkAddress);
+
+			if (nextChildChunkNum == 0) {
+				continue;
+			}
+
+			if (nextChildChunkNum == targetChunkNum) {
+				describeProblem()
+					.addProblemAddress("trie child address", chunkAddress, INT_SIZE)
+					.throwException("Chunk number " + nextChildChunkNum  //$NON-NLS-1$
+						+ " was found in the free space trie even though it was in use"); //$NON-NLS-1$
+			}
+
+			verifyNotInLargeBlockFreeSpaceTrie(targetChunkNum, nextChildChunkNum, chunkNum);
+		}
+	}
+
+	private void validateFreeBlocksFor(int numberOfDeltas) {
+		int correctSize = numberOfDeltas * BLOCK_SIZE_DELTA;
+		long lastBlock = 0;
+		long block = getFirstBlock(correctSize);
+		long addressOfPrevBlockPointer = getAddressOfFirstBlockPointer(correctSize);
+		while (block != 0) {
+			long measuredLastBlock = getFreeRecPtr(block + BLOCK_PREV_OFFSET);
+			int blockReportedSize = getShort(block);
+			long followingBlock = getFreeRecPtr(block + BLOCK_NEXT_OFFSET);
+			if (measuredLastBlock != lastBlock) {
+				describeProblem()
+					.addProblemAddress("last block", block + BLOCK_PREV_OFFSET, PTR_SIZE) //$NON-NLS-1$
+					.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
+					.throwException("The free space block (" + block //$NON-NLS-1$
+						+ ") of size " + correctSize + " had an incorrect prev pointer to "  //$NON-NLS-1$//$NON-NLS-2$
+						+ measuredLastBlock + ", but it should have been pointing to " //$NON-NLS-1$
+						+ lastBlock);
+			}
+			if (blockReportedSize != correctSize) {
+				describeProblem()
+					.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
+					.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
+					.throwException("A block (" + block + ") of size " + measuredLastBlock //$NON-NLS-1$ //$NON-NLS-2$
+						+ " was in the free space list for blocks of size " + correctSize); //$NON-NLS-1$
+			}
+			addressOfPrevBlockPointer = block + BLOCK_NEXT_OFFSET;
+			lastBlock = block;
+			block = followingBlock;
+		}
+	}
+
+	/**
+	 * Performs a self-test on the free space trie list (used by the large block allocator) to check for corruption
+	 */
 	private void validateFreeSpaceTries() {
 		int currentChunkNum = getInt(FREE_BLOCK_OFFSET);
 
@@ -820,22 +983,24 @@ public class Database {
 
 	private void validateFreeSpaceNode(Set<Integer> visited, int chunkNum, int parent) {
 		if (visited.contains(chunkNum)) {
-			throw new IndexException("Chunk " + chunkNum + "(parent = " + parent //$NON-NLS-1$//$NON-NLS-2$
+			describeProblem().throwException("Chunk " + chunkNum + "(parent = " + parent //$NON-NLS-1$//$NON-NLS-2$
 					+ " appeared twice in the free space tree"); //$NON-NLS-1$
 		}
-		
+
 		long chunkStart = chunkNum * CHUNK_SIZE;
 		int parentChunk = getInt(chunkStart + LargeBlock.PARENT_OFFSET);
 		if (parentChunk != parent) {
-			throw new IndexException("Chunk " + chunkNum + " has the wrong parent. Expected " + parent  //$NON-NLS-1$//$NON-NLS-2$
+			describeProblem()
+				.addProblemAddress("parent pointer", chunkStart + LargeBlock.PARENT_OFFSET, Database.INT_SIZE) //$NON-NLS-1$
+				.throwException("Chunk " + chunkNum + " has the wrong parent. Expected " + parent  //$NON-NLS-1$//$NON-NLS-2$
 					+ " but found  " + parentChunk); //$NON-NLS-1$
 		}
-		
+
 		visited.add(chunkNum);
 		int numChunks = getBlockHeaderForChunkNum(chunkNum);
 		for (int testPosition = 0; testPosition < LargeBlock.ENTRIES_IN_CHILD_TABLE; testPosition++) {
-			int nextChildChunkNum = getInt(
-					chunkStart + LargeBlock.CHILD_TABLE_OFFSET + (testPosition * PTR_SIZE));
+			long nextChildChunkNumAddress = chunkStart + LargeBlock.CHILD_TABLE_OFFSET + (testPosition * INT_SIZE);
+			int nextChildChunkNum = getInt(nextChildChunkNumAddress);
 
 			if (nextChildChunkNum == 0) {
 				continue;
@@ -845,14 +1010,25 @@ public class Database {
 			int sizeDifference = nextSize ^ numChunks;
 			int firstDifference = LargeBlock.SIZE_OF_SIZE_FIELD * 8 - Integer.numberOfLeadingZeros(
 					Integer.highestOneBit(sizeDifference)) - 1;
-			
+
 			if (firstDifference != testPosition) {
-				throw new IndexException("Chunk " + nextChildChunkNum + " contained an incorrect size of "  //$NON-NLS-1$//$NON-NLS-2$
+				ProblemBuilder descriptor = describeProblem();
+				attachBlockHeaderForChunkNum(descriptor, chunkNum);
+				attachBlockHeaderForChunkNum(descriptor, nextChildChunkNum);
+				descriptor.throwException("Chunk " + nextChildChunkNum + " contained an incorrect size of "  //$NON-NLS-1$//$NON-NLS-2$
 						+ nextSize + ". It was at position " + testPosition + " in parent " + chunkNum //$NON-NLS-1$ //$NON-NLS-2$
 						+ " which had size " + numChunks); //$NON-NLS-1$
 			}
 
-			validateFreeSpaceNode(visited, nextChildChunkNum, chunkNum);
+			try {
+				validateFreeSpaceNode(visited, nextChildChunkNum, chunkNum);
+			} catch (IndexException e) {
+				describeProblem()
+					.addProblemAddress("child pointer from parent " + chunkNum, nextChildChunkNumAddress,  //$NON-NLS-1$
+							Database.INT_SIZE)
+					.attachTo(e);
+				throw e;
+			}
 		}
 	}
 	
@@ -956,6 +1132,14 @@ public class Database {
 		return getInt((long) firstChunkNum * CHUNK_SIZE);
 	}
 
+	private void attachBlockHeaderForChunkNum(ProblemBuilder builder, int firstChunkNum) {
+		if (firstChunkNum >= this.fChunksUsed) {
+			return;
+		}
+		builder.addProblemAddress("block header for chunk " + firstChunkNum, ((long) firstChunkNum * CHUNK_SIZE),
+				Database.INT_SIZE);
+	}
+
 	/**
 	 * Returns the size of the block (in number of chunks), given the (non-inclusive) address that the block ends at.
 	 * The return value is positive if the block is free and negative if the block is allocated.
@@ -1013,21 +1197,26 @@ public class Database {
 		}
 	}
 
+	private long getAddressOfFirstBlockPointer(int blockSize) {
+		return MALLOC_TABLE_OFFSET + (blockSize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS) * INT_SIZE;
+	}
+
 	/**
-	 * @param blocksize (must be a multiple of BLOCK_SIZE_DELTA)
+	 * @param blockSize (must be a multiple of BLOCK_SIZE_DELTA)
 	 */
-	private long getFirstBlock(int blocksize) throws IndexException {
+	private long getFirstBlock(int blockSize) throws IndexException {
 		assert this.fLocked;
-		return this.fHeaderChunk.getFreeRecPtr(MALLOC_TABLE_OFFSET + (blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS) * INT_SIZE);
+		return this.fHeaderChunk.getFreeRecPtr(getAddressOfFirstBlockPointer(blockSize));
 	}
 
-	private void setFirstBlock(int blocksize, long block) throws IndexException {
+	private void setFirstBlock(int blockSize, long block) throws IndexException {
 		assert this.fExclusiveLock;
-		this.fHeaderChunk.putFreeRecPtr(MALLOC_TABLE_OFFSET + (blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS) * INT_SIZE, block);
+		this.fHeaderChunk.putFreeRecPtr(getAddressOfFirstBlockPointer(blockSize), block);
 	}
 
 	private void removeBlock(Chunk chunk, int blocksize, long block) throws IndexException {
 		assert this.fExclusiveLock;
+
 		long prevblock = chunk.getFreeRecPtr(block + BLOCK_PREV_OFFSET);
 		long nextblock = chunk.getFreeRecPtr(block + BLOCK_NEXT_OFFSET);
 		if (prevblock != 0) {
@@ -1063,45 +1252,79 @@ public class Database {
 	 *            the same ID that was previously passed into malloc when allocating this memory address
 	 */
 	public void free(long address, short poolId) throws IndexException {
-		assert this.fExclusiveLock;
-		if (address == 0) {
-			return;
-		}
-		long blockSize;
-		long block = address - BLOCK_HEADER_SIZE;
-		Chunk chunk = getChunk(block);
-		blockSize = -chunk.getShort(block);
-		// We use a block size of 0 to indicate a large block that fills a range of chunks
-		if (blockSize == 0) {
-			int offsetIntoChunk = (int) (address % CHUNK_SIZE);
-			assert offsetIntoChunk == LargeBlock.HEADER_SIZE + BLOCK_HEADER_SIZE;
-			// Deallocating a large block
-			// This was a large block. It uses a sequence of full chunks.
-			int chunkNum = (int) (address / CHUNK_SIZE);
-			int numChunks = -getBlockHeaderForChunkNum(chunkNum);
-			if (numChunks < 0) {
-				// Already freed.
-				throw new IndexException(new Status(IStatus.ERROR, Package.PLUGIN_ID, 0,
-						"Already freed large block " + address, new Exception())); //$NON-NLS-1$
+		getLog().start(this.freeTag);
+		try {
+			assert this.fExclusiveLock;
+			if (address == 0) {
+				return;
 			}
-			blockSize = (long) numChunks * CHUNK_SIZE;
-			freeLargeChunk(chunkNum, numChunks);
-			if (DEBUG_LARGE_CHUNKS) {
-				validateFreeSpaceTries();
+			long blockSize;
+			long block = address - BLOCK_HEADER_SIZE;
+			Chunk chunk = getChunk(block);
+			blockSize = -chunk.getShort(block);
+			// We use a block size of 0 to indicate a large block that fills a range of chunks
+			if (blockSize == 0) {
+				int offsetIntoChunk = (int) (address % CHUNK_SIZE);
+				assert offsetIntoChunk == LargeBlock.HEADER_SIZE + BLOCK_HEADER_SIZE;
+				// Deallocating a large block
+				// This was a large block. It uses a sequence of full chunks.
+				int chunkNum = (int) (address / CHUNK_SIZE);
+				int numChunks = -getBlockHeaderForChunkNum(chunkNum);
+				if (numChunks < 0) {
+					ProblemBuilder builder = describeProblem();
+					if (chunkNum < this.fChunksUsed) {
+						builder.addProblemAddress("block header", (long) chunkNum * CHUNK_SIZE, INT_SIZE); //$NON-NLS-1$
+					}
+					builder.throwException("Already freed large block " + address); //$NON-NLS-1$
+				}
+				blockSize = (long) numChunks * CHUNK_SIZE;
+				this.log.recordFree(address, (int)(blockSize - BLOCK_HEADER_SIZE));
+				freeLargeChunk(chunkNum, numChunks);
+			} else {
+				// Deallocating a normal block
+				// TODO Look for opportunities to merge small blocks
+				if (blockSize < 0) {
+					describeProblem()
+						.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
+						.throwException("Already freed record " + address); //$NON-NLS-1$
+				}
+				this.log.recordFree(address, (int)(blockSize - BLOCK_HEADER_SIZE));
+				int offset = Chunk.recPtrToIndex(address);
+				if (offset + blockSize > CHUNK_SIZE) {
+					describeProblem()
+						.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
+						.throwException("Attempting to free chunk of impossible size. The block at address " //$NON-NLS-1$
+								+ address + " in chunk " + chunk.fSequenceNumber + " offset " + offset //$NON-NLS-1$//$NON-NLS-2$
+								+ " can't be as large as " //$NON-NLS-1$
+								+ blockSize + " bytes since that would make it extend beyond the end of the chunk"); //$NON-NLS-1$
+				}
+				addBlock(chunk, (int) blockSize, block);
 			}
-		} else {
-			// Deallocating a normal block
-			// TODO Look for opportunities to merge small blocks
-			if (blockSize < 0) {
-				// Already freed.
-				throw new IndexException(new Status(IStatus.ERROR, Package.PLUGIN_ID, 0,
-						"Already freed record " + address, new Exception())); //$NON-NLS-1$
+	
+			if (DEBUG_FREE_SPACE) {
+				periodicValidateFreeSpace();
 			}
-			addBlock(chunk, (int) blockSize, block);
+	
+			this.freed += blockSize;
+			this.memoryUsage.recordFree(poolId, blockSize);
+		} finally {
+			getLog().end(this.freeTag);
 		}
+	}
 
-		this.freed += blockSize;
-		this.memoryUsage.recordFree(poolId, blockSize);
+	/**
+	 * Periodically performs validation of the free space in the database. Validation is very expensive, so the
+	 * validation period uses exponential falloff so validations happen less and less frequently over
+	 * time. Returns true iff validation happened on this iteration.
+	 */
+	private boolean periodicValidateFreeSpace() {
+		this.validateCounter++;
+		if (this.validateCounter > this.nextValidation) {
+			validateFreeSpace();
+			this.nextValidation = this.validateCounter * 2;
+			return true;
+		}
+		return false;
 	}
 
 	private void freeLargeChunk(int chunkNum, int numChunks) {
@@ -1320,6 +1543,7 @@ public class Database {
 		flush();
 		removeChunksFromCache();
 
+		this.log.clear();
 		// Chunks have been removed from the cache, so we are fine.
 		this.fHeaderChunk.clear(0, CHUNK_SIZE);
 		this.memoryUsage.refresh();
@@ -1629,4 +1853,8 @@ public class Database {
 			return new ChunkStats(this.fChunks.length, count, dirtyChunks, nonDirtyChunksNotInCache);
 		}
 	}
+
+	public ProblemBuilder describeProblem() {
+		return new ProblemBuilder(this);
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
index f6ecf9a..aa195b8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/IndexException.java
@@ -10,6 +10,9 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.db;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 
@@ -19,9 +22,9 @@ import org.eclipse.core.runtime.Status;
 public class IndexException extends RuntimeException {
 
 	private IStatus status;
+	private List<RelatedAddress> relatedAddresses = new ArrayList<>();
 
 	public IndexException(IStatus status) {
-		super(status.getMessage());
 		this.status = status;
 	}
 
@@ -43,4 +46,32 @@ public class IndexException extends RuntimeException {
 
 	private static final long serialVersionUID = -6561893929558916225L;
 
+	public void addRelatedAddress(RelatedAddress related) {
+		// Don't include dupes
+		for (RelatedAddress next : this.relatedAddresses) {
+			if (next.isSameAddressAs(related)) {
+				return;
+			}
+		}
+		this.relatedAddresses.add(related);
+	}
+
+	@Override
+	public String getMessage() {
+		StringBuilder result = new StringBuilder();
+		result.append(this.status.getMessage());
+
+		if (!this.relatedAddresses.isEmpty()) {
+			boolean isFirst = true;
+			result.append("\nRelated addresses:\n"); //$NON-NLS-1$
+			for (RelatedAddress next : this.relatedAddresses) {
+				if (!isFirst) {
+					result.append("\n"); //$NON-NLS-1$
+				}
+				isFirst = false;
+				result.append(next.toString());
+			}
+		}
+		return result.toString();
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
new file mode 100644
index 0000000..a6d76f9
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
@@ -0,0 +1,441 @@
+/*******************************************************************************
+ * Copyright (c) 2017 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.db;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Records a record of every modification to the database, in a circular buffer of fixed size. Whenever anything writes
+ * to the database, the log records the address and size of the write, along with a call stack describing what was going
+ * on at the time of the write. The actual bytes written to the database are not recorded. In addition to writes, it
+ * also records every invocation of malloc and free.
+ * <p>
+ * Given a memory address range, we can trace the log backwards to find everything that ever happened to that address
+ * range since the start of the log.
+ * </p>
+ * "call stacks" don't use java call stacks. They use explicit tags that are pushed and popped at the start and
+ * end of operations related to modifying the database.
+ */
+public class ModificationLog {
+	/**
+	 * Used to attach messages to events in the log. Tags should be allocated in static initializers at application
+	 * startup by calling {@link ModificationLog#createTag(String)}. Once allocated, the tag can be pushed and popped on to
+	 * the stack in the log to mark the beginning and end of operations.
+	 */
+	public static class Tag {
+		public final String name;
+		public final int opNum;
+
+		Tag(String name, int opNum) {
+			this.name = name;
+			this.opNum = opNum;
+		}
+
+		@Override
+		public String toString() {
+			return this.opNum + ":" + this.name; //$NON-NLS-1$
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + this.opNum;
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			Tag other = (Tag) obj;
+			if (this.opNum != other.opNum)
+				return false;
+			return true;
+		}
+	}
+
+	/**
+	 * Represents a single entry in a {@link MemoryAccessLog}. That is, a single read, write, malloc, or free event that
+	 * affected the memory range of interest.
+	 */
+	public static class MemoryOperation {
+		private final List<Tag> stack;
+		private final long time;
+		private final long startAddress;
+		private final int addressSize;
+		private final byte operationType;
+
+		public MemoryOperation(byte operationType, long time, long startAddress, int size, List<Tag> stack) {
+			super();
+			this.operationType = operationType;
+			this.time = time;
+			this.startAddress = startAddress;
+			this.addressSize = size;
+			this.stack = stack;
+		}
+
+		public List<Tag> getStack() {
+			return this.stack;
+		}
+
+		public long getTime() {
+			return this.time;
+		}
+
+		public long getStartAddress() {
+			return this.startAddress;
+		}
+
+		public int getSize() {
+			return this.addressSize;
+		}
+
+		public byte getOperationType() {
+			return this.operationType;
+		}
+
+		public void printTo(StringBuilder builder, int indent) {
+			indent(builder, indent);
+			switch (getOperationType()) {
+				case FREE_OPERATION: builder.append("freed"); break; //$NON-NLS-1$
+				case MALLOC_OPERATION: builder.append("malloc'd"); break; //$NON-NLS-1$
+				case WRITE_OPERATION: builder.append("wrote"); break; //$NON-NLS-1$
+			}
+			builder.append(" [address "); //$NON-NLS-1$
+			builder.append(this.startAddress);
+			builder.append(", size "); //$NON-NLS-1$
+			builder.append(this.addressSize);
+			builder.append("] at time "); //$NON-NLS-1$
+			builder.append(this.time);
+			builder.append("\n");  //$NON-NLS-1$
+			List<Tag> theStack = new ArrayList<>();
+			theStack.addAll(getStack());
+			Collections.reverse(theStack);
+			for (Tag next : theStack) {
+				indent(builder, indent + 1);
+				builder.append(next.name + "\n");  //$NON-NLS-1$
+			}
+		}
+	}
+
+	/**
+	 * Contains a log of events related to a specific range of database addresses, in reverse chronological order.
+	 */
+	public static class MemoryAccessLog {
+		private final List<MemoryOperation> operations;
+
+		public MemoryAccessLog(List<MemoryOperation> operations) {
+			super();
+			this.operations = operations;
+		}
+
+		/**
+		 * Returns a list of operations, in reverse order of time.
+		 */
+		public List<MemoryOperation> getOperations() {
+			return this.operations;
+		}
+
+		/**
+		 * Returns true iff this log contains a double malloc or a double free
+		 */
+		public boolean hasInconsistentMemoryAllocation() {
+			boolean known = false;
+			boolean allocated = false;
+			for (MemoryOperation next : this.operations) {
+				boolean newAllocatedState;
+				if (next.getOperationType() == MALLOC_OPERATION) {
+					newAllocatedState = false;
+				} else if (next.getOperationType() == FREE_OPERATION) {
+					newAllocatedState = true;
+				} else {
+					continue;
+				}
+
+				if (!known) {
+					known = true;
+				} else if (allocated == newAllocatedState) {
+					return true;
+				}
+				allocated = newAllocatedState;
+			}
+			return false;
+		}
+
+		/**
+		 * Search for anomalies in the log and produce a reduced report
+		 * 
+		 * @return a log containing the most interesting results
+		 */
+		public MemoryAccessLog reduce(int maxWrites) {
+			boolean includeAllMallocs = hasInconsistentMemoryAllocation();
+			int numWrites = 0;
+
+			List<MemoryOperation> result = new ArrayList<>();
+			for (MemoryOperation next : this.operations) {
+				boolean keepGoing = true;
+				switch (next.getOperationType()) {
+					case MALLOC_OPERATION: {
+						result.add(next);
+						keepGoing = includeAllMallocs;
+						break;
+					}
+					case FREE_OPERATION: {
+						result.add(next);
+						break;
+					}
+					case WRITE_OPERATION: {
+						if (numWrites < maxWrites) {
+							result.add(next);
+						}
+						numWrites++;
+					}
+				}
+				if (!keepGoing) {
+					break;
+				}
+			}
+
+			return new MemoryAccessLog(result);
+		}
+	}
+
+	private static Map<Integer, Tag> activeTags = new HashMap<>();
+	private final ArrayDeque<Tag> operationStack = new ArrayDeque<>();
+	private long[] buffer0;
+	private int[] buffer1;
+	private byte[] operation;
+	private int insertionPosition;
+	private int currentEntries;
+	private long timer;
+
+	public static final byte PUSH_OPERATION = 0;
+	public static final byte POP_OPERATION = 1;
+	public static final byte WRITE_OPERATION = 2;
+	public static final byte MALLOC_OPERATION = 3;
+	public static final byte FREE_OPERATION = 4;
+
+	public ModificationLog(int size) {
+		allocateBuffers(size);
+	}
+
+	public void clear() {
+		this.currentEntries = 0;
+	}
+
+	private void allocateBuffers(int sizeInMegs) {
+		int entries = getBufferEntriesFor(sizeInMegs);
+		if (entries != 0) {
+			this.buffer0 = new long[entries];
+			this.buffer1 = new int[entries];
+			this.operation = new byte[entries];
+		} else {
+			this.buffer0 = null;
+			this.buffer1 = null;
+			this.operation = null;
+		}
+	}
+
+	private static int getBufferEntriesFor(int sizeInMegs) {
+		int sizeOfABufferEntry = 8 + 4 + 1; // size, in bytes, of one long, one int, and one byte 
+		return sizeInMegs * 1024 * 1024 / sizeOfABufferEntry;
+	}
+
+	public int getBufferEntries() {
+		return this.buffer0 == null ? 0 : this.buffer0.length;
+	}
+
+	public void setBufferSize(int megs) {
+		int oldBufferLength = getBufferEntries();
+		int newBufferLength = getBufferEntriesFor(megs);
+
+		if (oldBufferLength == newBufferLength) {
+			return;
+		}
+
+		long[] oldBuffer0 = this.buffer0;
+		int[] oldBuffer1 = this.buffer1;
+		byte[] oldOperation = this.operation;
+
+		allocateBuffers(megs);
+
+		if (this.buffer0 == null) {
+			this.currentEntries = 0;
+			this.insertionPosition = 0;
+			this.operationStack.clear();
+			return;
+		}
+		int newBufferSize = Math.min(this.buffer0.length, this.currentEntries);
+		if (oldBufferLength > 0) {
+			int readStart = (this.insertionPosition + oldBufferLength - newBufferSize) % oldBufferLength;
+			if (readStart >= this.insertionPosition) {
+				int entriesFromEnd = oldBufferLength - readStart;
+				System.arraycopy(oldBuffer0, readStart, this.buffer0, 0, entriesFromEnd);
+				System.arraycopy(oldBuffer1, readStart, this.buffer1, 0, entriesFromEnd);
+				System.arraycopy(oldOperation, readStart, this.operation, 0, entriesFromEnd);
+
+				System.arraycopy(oldBuffer0, 0, this.buffer0, entriesFromEnd, this.insertionPosition);
+				System.arraycopy(oldBuffer1, 0, this.buffer1, entriesFromEnd, this.insertionPosition);
+				System.arraycopy(oldOperation, 0, this.operation, entriesFromEnd, this.insertionPosition);
+			} else {
+				int entriesToCopy = this.insertionPosition - readStart;
+				System.arraycopy(oldBuffer0, readStart, this.buffer0, 0, entriesToCopy);
+				System.arraycopy(oldBuffer1, readStart, this.buffer1, 0, entriesToCopy);
+				System.arraycopy(oldOperation, readStart, this.operation, 0, entriesToCopy);
+			}
+		}
+
+		this.currentEntries = newBufferSize;
+		this.insertionPosition = newBufferSize % this.buffer0.length;
+	}
+
+	public static void indent(StringBuilder builder, int indent) {
+		for (int count = 0; count < indent; count++) {
+			builder.append("    "); //$NON-NLS-1$
+		}
+	}
+
+	private boolean enabled() {
+		return this.buffer0 != null;
+	}
+
+	public void start(Tag tag) {
+		if (!enabled()) {
+			return;
+		}
+
+		this.operationStack.add(tag);
+		addToQueue(PUSH_OPERATION, 0, tag.opNum);
+	}
+
+	public void end(Tag tag) {
+		if (!enabled()) {
+			return;
+		}
+		if (!this.operationStack.getLast().equals(tag)) {
+			throw new IllegalStateException();
+		}
+		this.operationStack.removeLast();
+		addToQueue(POP_OPERATION, 0, tag.opNum);
+	}
+
+	public void recordWrite(long address, int size) {
+		if (!enabled()) {
+			return;
+		}
+		this.timer++;
+		addToQueue(WRITE_OPERATION, address, size);
+	}
+
+	public void recordMalloc(long address, int size) {
+		if (!enabled()) {
+			return;
+		}
+		this.timer++;
+		addToQueue(MALLOC_OPERATION, address, size);
+	}
+
+	public void recordFree(long address, int size) {
+		if (!enabled()) {
+			return;
+		}
+		this.timer++;
+		addToQueue(FREE_OPERATION, address, size);
+	}
+
+	private void addToQueue(byte opConstant, long arg0, int arg1) {
+		this.buffer0[this.insertionPosition] = arg0;
+		this.buffer1[this.insertionPosition] = arg1;
+		this.operation[this.insertionPosition] = opConstant;
+		this.insertionPosition = (this.insertionPosition + 1) % this.buffer0.length;
+
+		if (this.currentEntries < this.buffer0.length) {
+			this.currentEntries++;
+		}
+	}
+
+	public long getWriteCount() {
+		return this.timer;
+	}
+
+	/**
+	 * Returns information about the last write to the given address range
+	 */
+	public MemoryAccessLog getReportFor(long address, int size) {
+		List<Tag> tags = new ArrayList<>();
+		tags.addAll(this.operationStack);
+		int pointerToStart = (this.insertionPosition + this.buffer0.length - this.currentEntries) % this.buffer0.length;
+		int currentPosition = (this.insertionPosition + this.buffer0.length - 1) % this.buffer0.length;
+		long currentWrite = this.timer;
+
+		List<MemoryOperation> operations = new ArrayList<>();
+		do {
+			long nextAddress = this.buffer0[currentPosition];
+			int nextArgument = this.buffer1[currentPosition];
+			byte nextOp = this.operation[currentPosition];
+
+			switch (nextOp) {
+				case POP_OPERATION: {
+					tags.add(getTagForId(nextArgument));
+					break;
+				}
+				case PUSH_OPERATION: {
+					tags.remove(tags.size() - 1);
+					break;
+				}
+				default: {
+					boolean isMatch = false;
+					if (address < nextAddress) {
+						long diff = nextAddress - address;
+						if (diff < size) {
+							isMatch = true;
+						}
+					} else {
+						long diff = address - nextAddress;
+						if (diff < nextArgument) {
+							isMatch = true;
+						}
+					}
+
+					if (isMatch) {
+						List<Tag> stack = new ArrayList<>();
+						stack.addAll(tags);
+						MemoryOperation nextOperation = new MemoryOperation(nextOp, currentWrite, nextAddress,
+								nextArgument, stack);
+						operations.add(nextOperation);
+					}
+
+					currentWrite--;
+				}
+			}
+			currentPosition = (currentPosition + this.buffer0.length - 1) % this.buffer0.length;
+		} while (currentPosition != pointerToStart);
+		return new MemoryAccessLog(operations);
+	}
+
+	public static Tag createTag(String tagName) {
+		Tag result = new Tag(tagName, activeTags.size());
+		activeTags.put(activeTags.size(), result);
+		return result;
+	}
+
+	private Tag getTagForId(int nextArgument) {
+		return activeTags.get(nextArgument);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/RelatedAddress.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/RelatedAddress.java
new file mode 100644
index 0000000..c665b91
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/RelatedAddress.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2017 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.db;
+
+import java.util.List;
+
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.MemoryAccessLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.MemoryOperation;
+
+/**
+ * Holds information about a memory range that was related to the cause of data corruption.
+ */
+public class RelatedAddress {
+	private final String description;
+	private final long address;
+	private final int size;
+	private final MemoryAccessLog modificationReport;
+
+	public RelatedAddress(String description, long address, int size, MemoryAccessLog lastModification) {
+		this.description = description;
+		this.address = address;
+		this.size = size;
+		this.modificationReport = lastModification;
+	}
+
+	boolean isSameAddressAs(RelatedAddress other) {
+		return other.address == this.address && other.size == this.size;
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder builder = new StringBuilder();
+		builder.append(this.description);
+		builder.append(" [address "); //$NON-NLS-1$
+		builder.append(this.address);
+		builder.append(", size "); //$NON-NLS-1$
+		builder.append(this.size);
+		builder.append("]: "); //$NON-NLS-1$
+		MemoryAccessLog reducedReport = this.modificationReport.reduce(5);
+		List<MemoryOperation> operations = reducedReport.getOperations();
+		if (operations.isEmpty()) {
+			builder.append("No modification report"); //$NON-NLS-1$
+		} else {
+			builder.append("\n"); //$NON-NLS-1$
+			for (MemoryOperation nextOperation : operations) {
+				nextOperation.printTo(builder, 1);
+			}
+		}
+		return builder.toString();
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/BaseField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/BaseField.java
new file mode 100644
index 0000000..28f4478
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/BaseField.java
@@ -0,0 +1,25 @@
+package org.eclipse.jdt.internal.core.nd.field;
+
+abstract class BaseField implements IField {
+	protected int offset;
+	private String fieldName;
+
+	protected final void setFieldName(String fieldName) {
+		this.fieldName = fieldName;
+	}
+
+	@Override
+	public final void setOffset(int offset) {
+		this.offset = offset;
+	}
+
+	@Override
+	public final int getOffset() {
+		return this.offset;
+	}
+
+	@Override
+	public final String getFieldName() {
+		return this.fieldName;
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/Field.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/Field.java
index bab45d4..efd6e8e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/Field.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/Field.java
@@ -28,11 +28,12 @@ import org.eclipse.jdt.internal.core.nd.Nd;
  * 
  * @param <T>
  */
-public final class Field<T> implements IField, IDestructableField {
-	private int offset;
+public final class Field<T> extends BaseField implements IDestructableField {
 	public final ITypeFactory<T> factory;
 
-	public Field(ITypeFactory<T> objectFactory) {
+	public Field(ITypeFactory<T> objectFactory, String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
 		this.factory = objectFactory;
 	}
 
@@ -50,11 +51,6 @@ public final class Field<T> implements IField, IDestructableField {
 	}
 
 	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
-	}
-
-	@Override
 	public int getRecordSize() {
 		return this.factory.getRecordSize();
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
index c7a9ef5..4bb0b88 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldByte.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Declares a Nd field of type byte. Can be used in place of {@link Field}&lt{@link Byte}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldByte implements IField {
-	private int offset;
+public class FieldByte extends BaseField {
+	private final Tag tag;
 
-	public FieldByte() {
+	public FieldByte(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public byte get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldByte implements IField {
 	}
 
 	public void put(Nd nd, long address, byte newValue) {
-		nd.getDB().putByte(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset; 
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			db.putByte(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
index e4b0e17..95f50d4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldChar.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Declares a Nd field of type char. Can be used in place of  {@link Field}&lt{@link Character}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldChar implements IField {
-	private int offset;
+public class FieldChar extends BaseField {
+	private final Tag tag;
 
-	public FieldChar() {
+	public FieldChar(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public char get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldChar implements IField {
 	}
 
 	public void put(Nd nd, long address, char newValue) {
-		nd.getDB().putChar(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset; 
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			nd.getDB().putChar(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
index f0932e2..535085f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldDouble.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
 import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 
 /**
- * Declares a Nd field of type double. Can be used in place of  {@link Field}&lt{@link Double}&gt in order to
+ * Declares a Nd field of type double. Can be used in place of {@link Field}&lt{@link Double}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldDouble implements IField {
-	private int offset;
+public class FieldDouble extends BaseField {
+	private final Tag tag;
 
-	public FieldDouble() {
+	public FieldDouble(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName);   //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing "); //$NON-NLS-1$
 	}
 
 	public double get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldDouble implements IField {
 	}
 
 	public void put(Nd nd, long address, double newValue) {
-		nd.getDB().putDouble(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			nd.getDB().putDouble(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
index 4ddd093..5c8b084 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldFloat.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Declares a Nd field of type float. Can be used in place of  {@link Field}&lt{@link Float}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldFloat implements IField {
-	private int offset;
+public class FieldFloat extends BaseField {
+	private final Tag tag;
 
-	public FieldFloat() {
+	public FieldFloat(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public float get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldFloat implements IField {
 	}
 
 	public void put(Nd nd, long address, float newValue) {
-		nd.getDB().putFloat(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			nd.getDB().putFloat(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
index 06e9b8a..a524a9f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldInt.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
 import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 
 /**
  * Declares a Nd field of type int. Can be used in place of  {@link Field}&lt{@link Integer}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldInt implements IField {
-	private int offset;
+public class FieldInt extends BaseField {
+	private final Tag tag;
 
-	public FieldInt() {
+	public FieldInt(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public int get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldInt implements IField {
 	}
 
 	public void put(Nd nd, long address, int newValue) {
-		nd.getDB().putInt(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset; 
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			nd.getDB().putInt(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
index 6a66ac2..93ad1ba 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldLong.java
@@ -11,16 +11,20 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Declares a Nd field of type long. Can be used in place of  {@link Field}&lt{@link Long}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldLong implements IField {
-	private int offset;
+public class FieldLong extends BaseField {
+	private final Tag tag;
 
-	public FieldLong() {
+	public FieldLong(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() + " in struct " + structName); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
+		this.tag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public long get(Nd nd, long address) {
@@ -29,12 +33,13 @@ public class FieldLong implements IField {
 	}
 
 	public void put(Nd nd, long address, long newValue) {
-		nd.getDB().putLong(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.tag);
+		try {
+			nd.getDB().putLong(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.tag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
index ed64495..41216cf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldManyToOne.java
@@ -13,6 +13,9 @@ package org.eclipse.jdt.internal.core.nd.field;
 import org.eclipse.jdt.internal.core.nd.ITypeFactory;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 
 /**
  * Holds the n side of a n..1 relationship. Declares a Nd field which is a pointer of a NdNode of the specified
@@ -20,13 +23,12 @@ import org.eclipse.jdt.internal.core.nd.NdNode;
  * {@link FieldManyToOne} points to an object, the inverse pointer is automatically inserted into the matching back
  * pointer list.
  */
-public class FieldManyToOne<T extends NdNode> implements IDestructableField, IField, IRefCountedField {
+public class FieldManyToOne<T extends NdNode> extends BaseField implements IDestructableField, IRefCountedField {
 	public final static FieldPointer TARGET;
 	public final static FieldInt BACKPOINTER_INDEX;
 
-	private int offset;
-	Class<T> targetType;
-	final Class<? extends NdNode> localType;
+	StructDef<T> targetType;
+	final StructDef<? extends NdNode> localType;
 	FieldOneToMany<?> backPointer;
 	@SuppressWarnings("rawtypes")
 	private final static StructDef<FieldManyToOne> type;
@@ -34,6 +36,8 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	 * True iff the other end of this pointer should delete this object when its end of the pointer is cleared.
 	 */
 	public final boolean pointsToOwner;
+	private final Tag putTag;
+	private final Tag destructTag;
 
 	static {
 		type = StructDef.createAbstract(FieldManyToOne.class);
@@ -43,7 +47,7 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	}
 
 	@SuppressWarnings({ "unchecked", "rawtypes" })
-	private FieldManyToOne(Class<? extends NdNode> localType, FieldOneToMany<?> backPointer, boolean pointsToOwner) {
+	private FieldManyToOne(StructDef<? extends NdNode> localType, FieldOneToMany<?> backPointer, boolean pointsToOwner) {
 		this.localType = localType;
 		this.pointsToOwner = pointsToOwner;
 
@@ -53,16 +57,20 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 						"Attempted to construct a FieldNodePointer referring to a backpointer list that is already in use" //$NON-NLS-1$
 								+ " by another field"); //$NON-NLS-1$
 			}
-			backPointer.targetType = (Class) localType;
-			this.targetType = (Class) backPointer.localType;
+			backPointer.targetType = (StructDef) localType;
+			this.targetType = (StructDef) backPointer.localType;
 			backPointer.forwardPointer = this;
 		}
 		this.backPointer = backPointer;
+		setFieldName("field " + localType.getNumFields() + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + localType.getStructName()); //$NON-NLS-1$
+		this.putTag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
+		this.destructTag = ModificationLog.createTag("Destructing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public static <T extends NdNode, B extends NdNode> FieldManyToOne<T> create(StructDef<B> builder,
 			FieldOneToMany<B> forwardPointer) {
-		FieldManyToOne<T> result = new FieldManyToOne<T>(builder.getStructClass(), forwardPointer, false);
+		FieldManyToOne<T> result = new FieldManyToOne<T>(builder, forwardPointer, false);
 		builder.add(result);
 		builder.addDestructableField(result);
 		return result;
@@ -79,7 +87,7 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	public static <T extends NdNode, B extends NdNode> FieldManyToOne<T> createOwner(StructDef<B> builder,
 			FieldOneToMany<B> forwardPointer) {
 
-		FieldManyToOne<T> result = new FieldManyToOne<T>(builder.getStructClass(), forwardPointer, true);
+		FieldManyToOne<T> result = new FieldManyToOne<T>(builder, forwardPointer, true);
 		builder.add(result);
 		builder.addDestructableField(result);
 		builder.addOwnerField(result);
@@ -100,34 +108,41 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	 */
 	public void put(Nd nd, long address, T value) {
 		if (value != null) {
-			put(nd, address, value.address);
+			put(nd, address, value.getAddress());
 		} else {
 			put(nd, address, 0);
 		}
 	}
 
 	public void put(Nd nd, long address, long newTargetAddress) {
-		long fieldStart = address + this.offset;
-		if (this.backPointer == null) {
-			throw new IllegalStateException("FieldNodePointer must be associated with a FieldBackPointer"); //$NON-NLS-1$
-		}
-		
-		long oldTargetAddress = TARGET.get(nd, fieldStart);
-		if (oldTargetAddress == newTargetAddress) {
-			return;
-		}
-
-		detachFromOldTarget(nd, address, oldTargetAddress);
-
-		TARGET.put(nd, fieldStart, newTargetAddress);
-		if (newTargetAddress != 0) {
-			// Note that newValue is the address of the backpointer list and record (the address of the struct
-			// containing the forward pointer) is the value being inserted into the list.
-			BACKPOINTER_INDEX.put(nd, fieldStart, this.backPointer.add(nd, newTargetAddress, address));
-		} else {
-			if (this.pointsToOwner) {
-				nd.scheduleDeletion(address);
+		Database db = nd.getDB();
+		db.getLog().start(this.putTag);
+		try {
+			long fieldStart = address + this.offset;
+			if (this.backPointer == null) {
+				throw new IllegalStateException(
+						getClass().getSimpleName() + " must be associated with a " + FieldOneToMany.class.getSimpleName()); //$NON-NLS-1$
+			}
+	
+			long oldTargetAddress = TARGET.get(nd, fieldStart);
+			if (oldTargetAddress == newTargetAddress) {
+				return;
 			}
+	
+			detachFromOldTarget(nd, address, oldTargetAddress);
+	
+			TARGET.put(nd, fieldStart, newTargetAddress);
+			if (newTargetAddress != 0) {
+				// Note that newValue is the address of the backpointer list and record (the address of the struct
+				// containing the forward pointer) is the value being inserted into the list.
+				BACKPOINTER_INDEX.put(nd, fieldStart, this.backPointer.add(nd, newTargetAddress, address));
+			} else {
+				if (this.pointsToOwner) {
+					nd.scheduleDeletion(address);
+				}
+			}
+		} finally {
+			db.getLog().end(this.putTag);
 		}
 	}
 
@@ -161,10 +176,16 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 
 	@Override
 	public void destruct(Nd nd, long address) {
-		long fieldStart = address + this.offset;
-		long oldTargetAddress = TARGET.get(nd, fieldStart);
-		detachFromOldTarget(nd, address, oldTargetAddress);
-		TARGET.put(nd, fieldStart, 0);
+		Database db = nd.getDB();
+		db.getLog().start(this.destructTag);
+		try {
+			long fieldStart = address + this.offset;
+			long oldTargetAddress = TARGET.get(nd, fieldStart);
+			detachFromOldTarget(nd, address, oldTargetAddress);
+			TARGET.put(nd, fieldStart, 0);
+		} finally {
+			db.getLog().end(this.destructTag);
+		}
 	}
 
 	void clearedByBackPointer(Nd nd, long address) {
@@ -174,11 +195,6 @@ public class FieldManyToOne<T extends NdNode> implements IDestructableField, IFi
 	}
 
 	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
-	}
-
-	@Override
 	public int getRecordSize() {
 		return type.size();
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
index ce1ebca..c054234 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
@@ -21,10 +21,9 @@ import org.eclipse.jdt.internal.core.nd.RawGrowableArray;
  * Holds the 1 side of a 1..n relationship between two objects. FieldNodePointer and FieldBackPointer fields always go
  * together in pairs.
  */
-public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRefCountedField, IField {
-	private int offset;
-	public Class<T> targetType;
-	public final Class<? extends NdNode> localType;
+public class FieldOneToMany<T extends NdNode> extends BaseField implements IDestructableField, IRefCountedField, IField {
+	public StructDef<T> targetType;
+	public final StructDef<? extends NdNode> localType;
 	private final RawGrowableArray backPointerArray;
 	FieldManyToOne<?> forwardPointer;
 
@@ -33,7 +32,7 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
-	private FieldOneToMany(Class<? extends NdNode> localType, FieldManyToOne<? extends NdNode> forwardPointer,
+	private FieldOneToMany(StructDef<? extends NdNode> localType, FieldManyToOne<? extends NdNode> forwardPointer,
 			int inlineElements) {
 		this.localType = localType;
 
@@ -43,11 +42,13 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 					"Attempted to construct a FieldBackPointer referring to a forward pointer that is already in use" //$NON-NLS-1$
 						+ " by another field"); //$NON-NLS-1$
 			}
-			forwardPointer.targetType = (Class)localType;
-			this.targetType = (Class)forwardPointer.localType;
+			forwardPointer.targetType = (StructDef)localType;
+			this.targetType = (StructDef)forwardPointer.localType;
 			forwardPointer.backPointer = this;
 		}
 		this.forwardPointer = forwardPointer;
+		setFieldName("field " + localType.getNumFields() + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + localType.getStructName()); //$NON-NLS-1$
 		this.backPointerArray = new RawGrowableArray(inlineElements);
 	}
 
@@ -65,8 +66,7 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 	 */
 	public static <T extends NdNode, B extends NdNode> FieldOneToMany<T> create(StructDef<B> builder, 
 			FieldManyToOne<B> forwardPointer, int inlineElementCount) {
-		FieldOneToMany<T> result = new FieldOneToMany<T>(builder.getStructClass(), forwardPointer,
-				inlineElementCount);
+		FieldOneToMany<T> result = new FieldOneToMany<T>(builder, forwardPointer, inlineElementCount);
 		builder.add(result);
 		builder.addDestructableField(result);
 		builder.addRefCountedField(result);
@@ -184,9 +184,4 @@ public class FieldOneToMany<T extends NdNode> implements IDestructableField, IRe
 		}
 		return !isEmpty(nd, address);
 	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
-	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToOne.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToOne.java
index 00cb293..ca7fa19 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToOne.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToOne.java
@@ -12,22 +12,25 @@ package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Represents a 1-to-0..1 relationship in a Nd database.
  */
-public class FieldOneToOne<T extends NdNode> implements IField, IDestructableField, IRefCountedField {
-	private int offset;
-	public final Class<T> nodeType; 
+public class FieldOneToOne<T extends NdNode> extends BaseField implements IDestructableField, IRefCountedField {
+	public final StructDef<T> nodeType; 
 	FieldOneToOne<?> backPointer;
 	private boolean pointsToOwner;
+	private final Tag putTag;
+	private final Tag destructTag;
 
 	/**
 	 * @param nodeType
 	 * @param backPointer
 	 */
-	private FieldOneToOne(Class<T> nodeType, FieldOneToOne<?> backPointer, boolean pointsToOwner) {
+	private FieldOneToOne(StructDef<T> nodeType, FieldOneToOne<?> backPointer, boolean pointsToOwner) {
 		this.nodeType = nodeType;
 
 		if (backPointer != null) {
@@ -40,10 +43,14 @@ public class FieldOneToOne<T extends NdNode> implements IField, IDestructableFie
 		}
 		this.backPointer = backPointer;
 		this.pointsToOwner = pointsToOwner;
+		setFieldName("field " + nodeType.getNumFields() + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + nodeType.getStructName()); //$NON-NLS-1$
+		this.putTag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
+		this.destructTag = ModificationLog.createTag("Destructing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public static <T extends NdNode, B extends NdNode> FieldOneToOne<T> create(StructDef<B> builder,
-			Class<T> nodeType, FieldOneToOne<B> forwardPointer) {
+			StructDef<T> nodeType, FieldOneToOne<B> forwardPointer) {
 
 		FieldOneToOne<T> result = new FieldOneToOne<T>(nodeType, forwardPointer, false);
 		builder.add(result);
@@ -52,7 +59,7 @@ public class FieldOneToOne<T extends NdNode> implements IField, IDestructableFie
 	}
 
 	public static <T extends NdNode, B extends NdNode> FieldOneToOne<T> createOwner(StructDef<B> builder,
-			Class<T> nodeType, FieldOneToOne<B> forwardPointer) {
+			StructDef<T> nodeType, FieldOneToOne<B> forwardPointer) {
 
 		FieldOneToOne<T> result = new FieldOneToOne<T>(nodeType, forwardPointer, true);
 		builder.add(result);
@@ -68,21 +75,32 @@ public class FieldOneToOne<T extends NdNode> implements IField, IDestructableFie
 
 	public void put(Nd nd, long address, T target) {
 		Database db = nd.getDB();
-		cleanup(nd, address);
-		if (target == null) {
-			db.putRecPtr(address + this.offset, 0);
-			if (this.pointsToOwner) {
-				nd.scheduleDeletion(address);
+		db.getLog().start(this.putTag);
+		try {
+			cleanup(nd, address);
+			if (target == null) {
+				db.putRecPtr(address + this.offset, 0);
+				if (this.pointsToOwner) {
+					nd.scheduleDeletion(address);
+				}
+			} else {
+				db.putRecPtr(address + this.offset, target.address);
+				db.putRecPtr(target.address + this.backPointer.offset, address);
 			}
-		} else {
-			db.putRecPtr(address + this.offset, target.address);
-			db.putRecPtr(target.address + this.backPointer.offset, address);
+		} finally {
+			db.getLog().end(this.putTag);
 		}
 	}
 
 	@Override
 	public void destruct(Nd nd, long address) {
-		cleanup(nd, address);
+		Database db = nd.getDB();
+		db.getLog().start(this.destructTag);
+		try {
+			cleanup(nd, address);
+		} finally {
+			db.getLog().end(this.destructTag);
+		}
 	}
 
 	private void cleanup(Nd nd, long address) {
@@ -98,11 +116,6 @@ public class FieldOneToOne<T extends NdNode> implements IField, IDestructableFie
 	}
 
 	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
-	}
-
-	@Override
 	public int getRecordSize() {
 		return Database.PTR_SIZE;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldPointer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldPointer.java
index fef3176..e67e251 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldPointer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldPointer.java
@@ -11,12 +11,17 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
-public class FieldPointer implements IField {
-	private int offset;
+public class FieldPointer extends BaseField {
+	private final Tag putTag;
 
-	public FieldPointer() {
+	public FieldPointer(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
+		this.putTag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public long get(Nd nd, long address) {
@@ -25,12 +30,13 @@ public class FieldPointer implements IField {
 	}
 
 	public void put(Nd nd, long address, long newValue) {
-		nd.getDB().putRecPtr(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.putTag);
+		try {
+			nd.getDB().putRecPtr(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.putTag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
index c7f6a3a..247da7d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchIndex.java
@@ -17,6 +17,9 @@ import org.eclipse.jdt.internal.core.nd.ITypeFactory;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.db.BTree;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.IBTreeComparator;
 import org.eclipse.jdt.internal.core.nd.db.IBTreeVisitor;
 import org.eclipse.jdt.internal.core.nd.db.IString;
@@ -25,10 +28,10 @@ import org.eclipse.jdt.internal.core.nd.db.IndexException;
 /**
  * Declares a field representing a case-insensitive search tree over elements which are a subtype of NdNode.
  */
-public class FieldSearchIndex<T extends NdNode> implements IField, IDestructableField {
-	private int offset;
+public class FieldSearchIndex<T extends NdNode> extends BaseField implements IDestructableField {
 	private final ITypeFactory<BTree> btreeFactory;
 	FieldSearchKey<?> searchKey;
+	private final Tag destructTag;
 	private static IResultRank anything = new IResultRank() {
 		@Override
 		public long getRank(Nd nd, long address) {
@@ -163,7 +166,7 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 		protected abstract boolean acceptResult(long address);
 	}
 
-	private FieldSearchIndex(FieldSearchKey<?> searchKey) {
+	private FieldSearchIndex(FieldSearchKey<?> searchKey, String structName, int fieldNumber) {
 		this.btreeFactory = BTree.getFactory(new IBTreeComparator() {
 			@Override
 			public int compare(Nd nd, long record1, long record2) {
@@ -188,12 +191,15 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 			searchKey.searchIndex = this;
 		}
 		this.searchKey = searchKey;
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
+		this.destructTag = ModificationLog.createTag("Destructing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public static <T extends NdNode, B> FieldSearchIndex<T> create(StructDef<B> builder,
 			final FieldSearchKey<B> searchKey) {
 
-		FieldSearchIndex<T> result = new FieldSearchIndex<T>(searchKey);
+		FieldSearchIndex<T> result = new FieldSearchIndex<T>(searchKey, builder.getStructName(), builder.getNumFields());
 
 		builder.add(result);
 		builder.addDestructableField(result);
@@ -207,12 +213,13 @@ public class FieldSearchIndex<T extends NdNode> implements IField, IDestructable
 
 	@Override
 	public void destruct(Nd nd, long address) {
-		this.btreeFactory.destruct(nd, address);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.destructTag);
+		try {
+			this.btreeFactory.destruct(nd, address);
+		} finally {
+			db.getLog().end(this.destructTag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
index 1b585cb..519afd5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
@@ -13,6 +13,8 @@ package org.eclipse.jdt.internal.core.nd.field;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.db.BTree;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.db.EmptyString;
 import org.eclipse.jdt.internal.core.nd.db.IString;
@@ -20,11 +22,12 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
 /**
  * Represents a search key into a global search index.
  */
-public class FieldSearchKey<T> implements IField, IDestructableField {
-	private int offset;
+public class FieldSearchKey<T> extends BaseField implements IDestructableField {
 	FieldSearchIndex<?> searchIndex;
+	private final Tag destructTag;
+	private final Tag putTag;
 
-	private FieldSearchKey(FieldSearchIndex<?> searchIndex) {
+	private FieldSearchKey(FieldSearchIndex<?> searchIndex, String structName, int fieldNumber) {
 		if (searchIndex != null) {
 			if (searchIndex.searchKey != null && searchIndex.searchKey != this) {
 				throw new IllegalArgumentException(
@@ -34,6 +37,10 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 			searchIndex.searchKey = this;
 		}
 		this.searchIndex = searchIndex;
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
+		this.putTag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
+		this.destructTag = ModificationLog.createTag("Destructing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	/**
@@ -41,7 +48,7 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 	 */
 	public static <T, B extends NdNode> FieldSearchKey<T> create(StructDef<B> builder,
 			FieldSearchIndex<B> searchIndex) {
-		FieldSearchKey<T> result = new FieldSearchKey<T>(searchIndex);
+		FieldSearchKey<T> result = new FieldSearchKey<T>(searchIndex, builder.getStructName(), builder.getNumFields());
 
 		builder.add(result);
 		builder.addDestructableField(result);
@@ -57,12 +64,17 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 	 * Sets the value of the key and inserts it into the index if it is not already present
 	 */
 	public void put(Nd nd, long address, char[] newString) {
-		cleanup(nd, address);
-
 		Database db = nd.getDB();
-		BTree btree = this.searchIndex.get(nd, Database.DATA_AREA_OFFSET);
-		db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
-		btree.insert(address);
+		db.getLog().start(this.putTag);
+		try {
+			cleanup(nd, address);
+
+			BTree btree = this.searchIndex.get(nd, Database.DATA_AREA_OFFSET);
+			db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
+			btree.insert(address);
+		} finally {
+			db.getLog().end(this.putTag);
+		}
 	}
 
 	public IString get(Nd nd, long address) {
@@ -77,7 +89,13 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 
 	@Override
 	public void destruct(Nd nd, long address) {
-		cleanup(nd, address);
+		Database db = nd.getDB();
+		db.getLog().start(this.destructTag);
+		try {
+			cleanup(nd, address);
+		} finally {
+			db.getLog().end(this.destructTag);
+		}
 	}
 
 	private void cleanup(Nd nd, long address) {
@@ -112,11 +130,6 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 	}
 
 	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
-	}
-
-	@Override
 	public int getRecordSize() {
 		return FieldString.RECORD_SIZE;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
index fe2a56b..ea3af54 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldShort.java
@@ -11,16 +11,21 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 
 /**
  * Declares a Nd field of type short. Can be used in place of  {@link Field}&lt{@link Short}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldShort implements IField {
-	private int offset;
+public class FieldShort extends BaseField {
+	private final Tag putTag;
 
-	public FieldShort() {
+	public FieldShort(String structName, int fieldNumber) {
+		setFieldName("field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
+		this.putTag = ModificationLog.createTag("Writing " + getFieldName()); //$NON-NLS-1$
 	}
 
 	public short get(Nd nd, long address) {
@@ -29,12 +34,13 @@ public class FieldShort implements IField {
 	}
 
 	public void put(Nd nd, long address, short newValue) {
-		nd.getDB().putShort(address + this.offset, newValue);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.putTag);
+		try {
+			nd.getDB().putShort(address + this.offset, newValue);
+		} finally {
+			db.getLog().end(this.putTag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
index ddd4493..f509e28 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldString.java
@@ -11,6 +11,8 @@
 package org.eclipse.jdt.internal.core.nd.field;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.jdt.internal.core.nd.db.Database;
 import org.eclipse.jdt.internal.core.nd.db.EmptyString;
 import org.eclipse.jdt.internal.core.nd.db.IString;
@@ -19,12 +21,18 @@ import org.eclipse.jdt.internal.core.nd.db.IString;
  * Declares a Nd field of type string. Can be used in place of  {@link Field}&lt{@link String}&gt in order to
  * avoid extra GC overhead.
  */
-public class FieldString implements IDestructableField, IField {
+public class FieldString extends BaseField implements IDestructableField {
 	public static final int RECORD_SIZE = Database.STRING_SIZE;
 	private static final char[] EMPTY_CHAR_ARRAY = new char[0];
-	private int offset;
+	private final Tag putTag;
+	private final Tag destructTag;
 
-	public FieldString() {
+	public FieldString(String structName, int fieldNumber) {
+		this.putTag = ModificationLog.createTag("Writing field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+				+ " in struct " + structName); //$NON-NLS-1$
+		this.destructTag = ModificationLog
+				.createTag("Destructing field " + fieldNumber + ", a " + getClass().getSimpleName() //$NON-NLS-1$//$NON-NLS-2$
+						+ " in struct " + structName); //$NON-NLS-1$
 	}
 
 	public IString get(Nd nd, long address) {
@@ -38,18 +46,23 @@ public class FieldString implements IDestructableField, IField {
 	}
 
 	public void put(Nd nd, long address, char[] newString) {
-		if (newString == null) {
-			newString = EMPTY_CHAR_ARRAY;
-		}
-		final Database db= nd.getDB();
-		IString name= get(nd, address);
-		if (name.compare(newString, true) != 0) {
-			name.delete();
-			if (newString != null && newString.length > 0) {
-				db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
-			} else {
-				db.putRecPtr(address + this.offset, 0);
+		Database db = nd.getDB();
+		db.getLog().start(this.putTag);
+		try {
+			if (newString == null) {
+				newString = EMPTY_CHAR_ARRAY;
 			}
+			IString name= get(nd, address);
+			if (name.compare(newString, true) != 0) {
+				name.delete();
+				if (newString != null && newString.length > 0) {
+					db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
+				} else {
+					db.putRecPtr(address + this.offset, 0);
+				}
+			}
+		} finally {
+			db.getLog().end(this.putTag);
 		}
 	}
 
@@ -58,13 +71,14 @@ public class FieldString implements IDestructableField, IField {
 	}
 
 	public void destruct(Nd nd, long address) {
-		get(nd, address).delete();
-		nd.getDB().putRecPtr(address + this.offset, 0);
-	}
-
-	@Override
-	public void setOffset(int offset) {
-		this.offset = offset;
+		Database db = nd.getDB();
+		db.getLog().start(this.destructTag);
+		try {
+			get(nd, address).delete();
+			nd.getDB().putRecPtr(address + this.offset, 0);
+		} finally {
+			db.getLog().end(this.destructTag);
+		}
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
index 979a0eb..dc5882c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
@@ -10,7 +10,29 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.field;
 
+/**
+ * Represents a single field of a struct in the {@link Nd} database. Holds metadata for that field
+ * and permits laziy initialization of the field offset.
+ */
 public interface IField {
+	/**
+	 * Sets the field offset (bytes from the start of the struct). This is invoked some time after field construction,
+	 * after the sizes of all preceeding fields are known.
+	 */
 	void setOffset(int offset);
+	/**
+	 * Returns the size of the field, in bytes.
+	 */
 	int getRecordSize();
+
+	/**
+	 * Returns the name of the field. This is mainly used for error messages, debug output, and diagnostic tools.
+	 * Meant to be programmer-readable but not user-readable.
+	 */
+	String getFieldName();
+
+	/**
+	 * Returns the field offset, in bytes from the start of the struct.
+	 */
+	int getOffset();
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/StructDef.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/StructDef.java
index 261e853..b5fddf3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/StructDef.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/StructDef.java
@@ -20,6 +20,9 @@ import java.util.List;
 import org.eclipse.jdt.internal.core.nd.IDestructable;
 import org.eclipse.jdt.internal.core.nd.ITypeFactory;
 import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 
 /**
  * Defines a data structure that will appear in the database.
@@ -56,6 +59,7 @@ public final class StructDef<T> {
 	private ITypeFactory<T> factory;
 	protected boolean hasUserDestructor;
 	private DeletionSemantics deletionSemantics;
+	final Tag destructTag;
 
 	public static enum DeletionSemantics {
 		EXPLICIT, OWNED, REFCOUNTED
@@ -70,6 +74,7 @@ public final class StructDef<T> {
 	}
 
 	private StructDef(Class<T> clazz, StructDef<? super T> superClass, boolean isAbstract) {
+		this.destructTag = ModificationLog.createTag("Destructing struct " + clazz.getSimpleName()); //$NON-NLS-1$
 		this.clazz = clazz;
 		this.superClass = superClass;
 		if (this.superClass != null) {
@@ -128,11 +133,17 @@ public final class StructDef<T> {
 
 			public void destruct(Nd nd, long address) {
 				checkNotMutable();
-				if (StructDef.this.hasUserDestructor) {
-					IDestructable destructable = (IDestructable)create(nd, address);
-					destructable.destruct();
+				Database db = nd.getDB();
+				db.getLog().start(StructDef.this.destructTag);
+				try {
+					if (StructDef.this.hasUserDestructor) {
+						IDestructable destructable = (IDestructable)create(nd, address);
+						destructable.destruct();
+					}
+					destructFields(nd, address);
+				} finally {
+					db.getLog().end(StructDef.this.destructTag);
 				}
-				destructFields(nd, address);
 			}
 
 			public void destructFields(Nd dom, long address) {
@@ -317,62 +328,66 @@ public final class StructDef<T> {
 	}
 
 	public FieldPointer addPointer() {
-		FieldPointer result = new FieldPointer();
+		FieldPointer result = new FieldPointer(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldShort addShort() {
-		FieldShort result = new FieldShort();
+		FieldShort result = new FieldShort(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldInt addInt() {
-		FieldInt result = new FieldInt();
+		FieldInt result = new FieldInt(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldLong addLong() {
-		FieldLong result = new FieldLong();
+		FieldLong result = new FieldLong(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldString addString() {
-		FieldString result = new FieldString();
+		FieldString result = new FieldString(getStructName(), this.fields.size());
 		add(result);
 		addDestructableField(result);
 		return result;
 	}
 
 	public FieldDouble addDouble() {
-		FieldDouble result = new FieldDouble();
+		FieldDouble result = new FieldDouble(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldFloat addFloat() {
-		FieldFloat result = new FieldFloat();
+		FieldFloat result = new FieldFloat(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
+	public String getStructName() {
+		return this.clazz.getSimpleName();
+	}
+
 	public FieldByte addByte() {
-		FieldByte result = new FieldByte();
+		FieldByte result = new FieldByte(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public FieldChar addChar() {
-		FieldChar result = new FieldChar();
+		FieldChar result = new FieldChar(getStructName(), this.fields.size());
 		add(result);
 		return result;
 	}
 
 	public <F> Field<F> add(ITypeFactory<F> factory1) {
-		Field<F> result = new Field<>(factory1);
+		Field<F> result = new Field<>(factory1, getStructName(), this.fields.size());
 		add(result);
 		if (result.factory.hasDestructor()) {
 			this.destructableFields.add(result);
@@ -394,5 +409,7 @@ public final class StructDef<T> {
 		}
 	}
 
-	
+	public int getNumFields() {
+		return this.fields.size();
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index d52ce33..38cacb1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -33,7 +33,6 @@ import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.Openable;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.nd.Nd;
-import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.NdAnnotation;
@@ -507,7 +506,7 @@ public final class ClassFileToIndexConverter {
 		skipChar(wrapper, '>');
 	}
 
-	private char[] readNextFieldDescriptor(SignatureWrapper genericSignature) {
+	private char[] readNextFieldDescriptor(SignatureWrapper genericSignature) throws CoreException {
 		int endPosition = findEndOfFieldDescriptor(genericSignature);
 
 		char[] result = CharArrayUtils.subarray(genericSignature.signature, genericSignature.start, endPosition);
@@ -515,7 +514,7 @@ public final class ClassFileToIndexConverter {
 		return result;
 	}
 
-	private int findEndOfFieldDescriptor(SignatureWrapper genericSignature) {
+	private int findEndOfFieldDescriptor(SignatureWrapper genericSignature) throws CoreException {
 		char[] signature = genericSignature.signature;
 
 		if (signature == null || signature.length == 0) {
@@ -544,7 +543,7 @@ public final class ClassFileToIndexConverter {
 				case 'Z':
 					return current + 1;
 				default:
-					throw new IndexException(Package.createStatus("Field descriptor starts with unknown character: " //$NON-NLS-1$
+					throw new CoreException(Package.createStatus("Field descriptor starts with unknown character: " //$NON-NLS-1$
 							+ genericSignature.toString()));
 			}
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 5e58ca8..877713c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -90,8 +90,10 @@ public final class Indexer {
 	public static boolean DEBUG;
 	public static boolean DEBUG_ALLOCATIONS;
 	public static boolean DEBUG_TIMING;
+	public static boolean DEBUG_SCHEDULING;
 	public static boolean DEBUG_INSERTIONS;
 	public static boolean DEBUG_SELFTEST;
+	public static int DEBUG_LOG_SIZE_MB;
 
 	// This is an arbitrary constant that is larger than the maximum number of ticks
 	// reported by SubMonitor and small enough that it won't overflow a long when multiplied by a large
@@ -216,6 +218,7 @@ public final class Indexer {
 		SubMonitor subMonitor = SubMonitor.convert(monitor, 100);
 		Database db = this.nd.getDB();
 		db.resetCacheCounters();
+		db.getLog().setBufferSize(DEBUG_LOG_SIZE_MB);
 
 		synchronized (this.automaticIndexingMutex) {
 			this.indexerDirtiedWhileDisabled = false;
@@ -924,7 +927,7 @@ public final class Indexer {
 	}
 
 	public void rescanAll() {
-		if (DEBUG) {
+		if (DEBUG_SCHEDULING) {
 			Package.logInfo("Scheduling rescanAll now"); //$NON-NLS-1$
 		}
 		synchronized (this.automaticIndexingMutex) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
index 2328a49..d3ee914 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
@@ -22,7 +22,7 @@ public class NdAnnotationInConstant extends NdAnnotation {
 
 	static {
 		type = StructDef.create(NdAnnotationInConstant.class, NdAnnotation.type);
-		OWNER = FieldOneToOne.createOwner(type, NdConstantAnnotation.class, NdConstantAnnotation.VALUE);
+		OWNER = FieldOneToOne.createOwner(type, NdConstantAnnotation.type, NdConstantAnnotation.VALUE);
 		type.done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
index f62ceb3..303a0bc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationValuePair.java
@@ -30,7 +30,7 @@ public class NdAnnotationValuePair extends NdNode {
 		type = StructDef.create(NdAnnotationValuePair.class, NdNode.type);
 		APPLIES_TO = FieldManyToOne.createOwner(type, NdAnnotation.ELEMENT_VALUE_PAIRS);
 		NAME = type.addString();
-		VALUE = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_ANNOTATION_VALUE);
+		VALUE = FieldOneToOne.create(type, NdConstant.type, NdConstant.PARENT_ANNOTATION_VALUE);
 		type.done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index b348f4e..bcde1c5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -16,7 +16,6 @@ import java.util.List;
 
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
-import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
@@ -107,7 +106,9 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			long size = TYPE_ARGUMENTS.size(getNd(), this.address);
 
 			if (size != 1) {
-				throw new IndexException("Array types should have exactly one argument"); //$NON-NLS-1$
+				getNd().describeProblem()
+					.addProblemAddress(TYPE_ARGUMENTS, this.address)
+					.throwException("Array types should have exactly one argument"); //$NON-NLS-1$
 			}
 
 			return TYPE_ARGUMENTS.get(getNd(), this.address, 0).getType();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
index 96e6045..ff4ee5e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstant.java
@@ -33,10 +33,10 @@ public abstract class NdConstant extends NdNode {
 	static {
 		type = StructDef.createAbstract(NdConstant.class, NdNode.type);
 		PARENT_ARRAY = FieldManyToOne.createOwner(type, NdConstantArray.ELEMENTS);
-		PARENT_ANNOTATION_VALUE = FieldOneToOne.createOwner(type, NdAnnotationValuePair.class,
+		PARENT_ANNOTATION_VALUE = FieldOneToOne.createOwner(type, NdAnnotationValuePair.type,
 				NdAnnotationValuePair.VALUE);
-		PARENT_VARIABLE = FieldOneToOne.createOwner(type, NdVariable.class, NdVariable.CONSTANT);
-		PARENT_METHOD = FieldOneToOne.createOwner(type, NdMethod.class, NdMethod.DEFAULT_VALUE);
+		PARENT_VARIABLE = FieldOneToOne.createOwner(type, NdVariable.type, NdVariable.CONSTANT);
+		PARENT_METHOD = FieldOneToOne.createOwner(type, NdMethod.type, NdMethod.DEFAULT_VALUE);
 		type.done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
index a69e52c..a231458 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
@@ -23,7 +23,7 @@ public final class NdConstantAnnotation extends NdConstant {
 
 	static {
 		type = StructDef.create(NdConstantAnnotation.class, NdConstant.type);
-		VALUE = FieldOneToOne.create(type, NdAnnotationInConstant.class, NdAnnotationInConstant.OWNER);
+		VALUE = FieldOneToOne.create(type, NdAnnotationInConstant.type, NdAnnotationInConstant.OWNER);
 		type.done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index e3a5730..d7d49b8 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -43,10 +43,10 @@ public class NdMethod extends NdBinding {
 		PARENT = FieldManyToOne.createOwner(type, NdType.METHODS);
 		PARAMETERS = FieldOneToMany.create(type, NdMethodParameter.PARENT);
 		DECLARED_VARIABLES = FieldOneToMany.create(type, NdVariable.DECLARING_METHOD);
-		DEFAULT_VALUE = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_METHOD);
+		DEFAULT_VALUE = FieldOneToOne.create(type, NdConstant.type, NdConstant.PARENT_METHOD);
 		EXCEPTIONS = FieldOneToMany.create(type, NdMethodException.PARENT);
 		RETURN_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_RETURN_TYPE);
-		ANNOTATION_DATA = FieldOneToOne.create(type, NdMethodAnnotationData.class, NdMethodAnnotationData.METHOD);
+		ANNOTATION_DATA = FieldOneToOne.create(type, NdMethodAnnotationData.type, NdMethodAnnotationData.METHOD);
 		type.done();
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodAnnotationData.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodAnnotationData.java
index 913eaad..d7d62a3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodAnnotationData.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodAnnotationData.java
@@ -34,7 +34,7 @@ public class NdMethodAnnotationData extends NdNode {
 
 	static {
 		type = StructDef.create(NdMethodAnnotationData.class, NdNode.type);
-		METHOD = FieldOneToOne.createOwner(type, NdMethod.class, NdMethod.ANNOTATION_DATA);
+		METHOD = FieldOneToOne.createOwner(type, NdMethod.type, NdMethod.ANNOTATION_DATA);
 		TAG_BITS = type.addLong();
 		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInMethod.OWNER);
 		TYPE_ANNOTATIONS = FieldOneToMany.create(type, NdTypeAnnotationInMethod.OWNER);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
index d9e33db..da0c0f6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTreeNode.java
@@ -73,9 +73,9 @@ public abstract class NdTreeNode extends NdNode {
 				if (ancestorType.isInstance(result)) {
 					return (T) result;
 				} else {
-					throw new IndexException("The node at address " + current +  //$NON-NLS-1$
-							" should have been an instance of " + ancestorType.getName() +  //$NON-NLS-1$
-							" but was an instance of " + result.getClass().getName()); //$NON-NLS-1$
+					nd.describeProblem().addProblemAddress(NODE_TYPE, current).throwException("The node at address " //$NON-NLS-1$
+							+ current + " should have been an instance of " + ancestorType.getName() //$NON-NLS-1$
+							+  " but was an instance of " + result.getClass().getName()); //$NON-NLS-1$
 				}
 			}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index fabc0e8..0ab3bee 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -47,7 +47,7 @@ public class NdVariable extends NdBinding {
 		DECLARING_METHOD = FieldManyToOne.create(type, NdMethod.DECLARED_VARIABLES);
 		PARENT = FieldManyToOne.createOwner(type, NdBinding.VARIABLES);
 		NAME = type.addString();
-		CONSTANT = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_VARIABLE);
+		CONSTANT = FieldOneToOne.create(type, NdConstant.type, NdConstant.PARENT_VARIABLE);
 		TAG_BITS = type.addLong();
 		VARIABLE_FLAGS = type.addByte();
 		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInVariable.OWNER);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
index 9ad5a60..4f9b6a2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
@@ -78,7 +78,9 @@ public abstract class TagTreeReader {
 		readAddress += Database.BYTE_SIZE;
 		TagHandler<?> reader = this.readers[nextByte];
 		if (reader == null) {
-			throw new IndexException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
+			nd.describeProblem()
+				.addProblemAddress("tag", address, 1) //$NON-NLS-1$
+				.throwException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		return reader.read(nd, readAddress, this, bytesRead);
@@ -98,7 +100,7 @@ public abstract class TagTreeReader {
 		TagHandler handler = this.readers[key];
 
 		if (handler == null) {
-			throw new IndexException("Invalid key " + key + " returned from getKeyFor(...)"); //$NON-NLS-1$//$NON-NLS-2$
+			nd.describeProblem().throwException("Invalid key " + key + " returned from getKeyFor(...)"); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		handler.write(nd, address, this, toWrite, bytesWritten);
@@ -112,7 +114,9 @@ public abstract class TagTreeReader {
 
 		TagHandler<?> handler = this.readers[nextByte];
 		if (handler == null) {
-			throw new IndexException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
+			nd.describeProblem()
+				.addProblemAddress("tag", address, 1) //$NON-NLS-1$
+				.throwException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		handler.destruct(nd, readAddress, this);
commit b58ce647c26a7c228db349f8052bcb58f7a4077d
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Mar 27 14:05:06 2017 -0700

    Bug 514089 - Build a tool to help debug index corruption
    
    Fix warnings.
    
    Change-Id: Ic59a1260005f2e42052b9131d6757843bce5a414

2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
3	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 25c34cf..8d7a4dd 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -927,7 +927,7 @@ public class Database {
 
 			if (nextChildChunkNum == targetChunkNum) {
 				describeProblem()
-					.addProblemAddress("trie child address", chunkAddress, INT_SIZE)
+					.addProblemAddress("trie child address", chunkAddress, INT_SIZE) //$NON-NLS-1$
 					.throwException("Chunk number " + nextChildChunkNum  //$NON-NLS-1$
 						+ " was found in the free space trie even though it was in use"); //$NON-NLS-1$
 			}
@@ -1136,7 +1136,7 @@ public class Database {
 		if (firstChunkNum >= this.fChunksUsed) {
 			return;
 		}
-		builder.addProblemAddress("block header for chunk " + firstChunkNum, ((long) firstChunkNum * CHUNK_SIZE),
+		builder.addProblemAddress("block header for chunk " + firstChunkNum, ((long) firstChunkNum * CHUNK_SIZE), //$NON-NLS-1$
 				Database.INT_SIZE);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
index c054234..19c085d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldOneToMany.java
@@ -21,7 +21,7 @@ import org.eclipse.jdt.internal.core.nd.RawGrowableArray;
  * Holds the 1 side of a 1..n relationship between two objects. FieldNodePointer and FieldBackPointer fields always go
  * together in pairs.
  */
-public class FieldOneToMany<T extends NdNode> extends BaseField implements IDestructableField, IRefCountedField, IField {
+public class FieldOneToMany<T extends NdNode> extends BaseField implements IDestructableField, IRefCountedField {
 	public StructDef<T> targetType;
 	public final StructDef<? extends NdNode> localType;
 	private final RawGrowableArray backPointerArray;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
index dc5882c..6796a46 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/IField.java
@@ -10,8 +10,10 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.field;
 
+import org.eclipse.jdt.internal.core.nd.db.Database;
+
 /**
- * Represents a single field of a struct in the {@link Nd} database. Holds metadata for that field
+ * Represents a single field of a struct in the {@link Database}. Holds metadata for that field
  * and permits laziy initialization of the field offset.
  */
 public interface IField {
commit 7d2b09ebfd4cb99d1f345eedcae879729e8aff7e
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Mar 27 17:41:41 2017 -0700

    Bug 514089 - Build a tool to help debug index corruption
    
    Fix NPE when corruption is detected and the buffer size is 0.
    
    Change-Id: I4163e9f294c96582b201bdf09593602ab1807d6e

42	40	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
index a6d76f9..1229343 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/ModificationLog.java
@@ -380,52 +380,54 @@ public class ModificationLog {
 	public MemoryAccessLog getReportFor(long address, int size) {
 		List<Tag> tags = new ArrayList<>();
 		tags.addAll(this.operationStack);
-		int pointerToStart = (this.insertionPosition + this.buffer0.length - this.currentEntries) % this.buffer0.length;
-		int currentPosition = (this.insertionPosition + this.buffer0.length - 1) % this.buffer0.length;
-		long currentWrite = this.timer;
 
 		List<MemoryOperation> operations = new ArrayList<>();
-		do {
-			long nextAddress = this.buffer0[currentPosition];
-			int nextArgument = this.buffer1[currentPosition];
-			byte nextOp = this.operation[currentPosition];
-
-			switch (nextOp) {
-				case POP_OPERATION: {
-					tags.add(getTagForId(nextArgument));
-					break;
-				}
-				case PUSH_OPERATION: {
-					tags.remove(tags.size() - 1);
-					break;
-				}
-				default: {
-					boolean isMatch = false;
-					if (address < nextAddress) {
-						long diff = nextAddress - address;
-						if (diff < size) {
-							isMatch = true;
+		if (this.buffer0 != null) {
+			int pointerToStart = (this.insertionPosition + this.buffer0.length - this.currentEntries) % this.buffer0.length;
+			int currentPosition = (this.insertionPosition + this.buffer0.length - 1) % this.buffer0.length;
+			long currentWrite = this.timer;
+			do {
+				long nextAddress = this.buffer0[currentPosition];
+				int nextArgument = this.buffer1[currentPosition];
+				byte nextOp = this.operation[currentPosition];
+	
+				switch (nextOp) {
+					case POP_OPERATION: {
+						tags.add(getTagForId(nextArgument));
+						break;
+					}
+					case PUSH_OPERATION: {
+						tags.remove(tags.size() - 1);
+						break;
+					}
+					default: {
+						boolean isMatch = false;
+						if (address < nextAddress) {
+							long diff = nextAddress - address;
+							if (diff < size) {
+								isMatch = true;
+							}
+						} else {
+							long diff = address - nextAddress;
+							if (diff < nextArgument) {
+								isMatch = true;
+							}
 						}
-					} else {
-						long diff = address - nextAddress;
-						if (diff < nextArgument) {
-							isMatch = true;
+	
+						if (isMatch) {
+							List<Tag> stack = new ArrayList<>();
+							stack.addAll(tags);
+							MemoryOperation nextOperation = new MemoryOperation(nextOp, currentWrite, nextAddress,
+									nextArgument, stack);
+							operations.add(nextOperation);
 						}
+	
+						currentWrite--;
 					}
-
-					if (isMatch) {
-						List<Tag> stack = new ArrayList<>();
-						stack.addAll(tags);
-						MemoryOperation nextOperation = new MemoryOperation(nextOp, currentWrite, nextAddress,
-								nextArgument, stack);
-						operations.add(nextOperation);
-					}
-
-					currentWrite--;
 				}
-			}
-			currentPosition = (currentPosition + this.buffer0.length - 1) % this.buffer0.length;
-		} while (currentPosition != pointerToStart);
+				currentPosition = (currentPosition + this.buffer0.length - 1) % this.buffer0.length;
+			} while (currentPosition != pointerToStart);
+		}
 		return new MemoryAccessLog(operations);
 	}
 
commit fae393304298c10366ba6a71a6df9dcd1b32ce66
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Tue Mar 28 12:53:56 2017 -0700

    Bug 514089 - Build a tool to help debug index corruption
    
    Add late suggestions from code review.
    
    Change-Id: Ie1e4240448c4cae1aaa7b0ac40c7d152004c61c0

87	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexExceptionBuilder.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
0	87	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
8	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
30	30	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
5	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexExceptionBuilder.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexExceptionBuilder.java
new file mode 100644
index 0000000..42d9b5a
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/IndexExceptionBuilder.java
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ * Copyright (c) 2017 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.internal.core.nd.db.ModificationLog.MemoryAccessLog;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.db.IndexException;
+import org.eclipse.jdt.internal.core.nd.db.RelatedAddress;
+import org.eclipse.jdt.internal.core.nd.field.IField;
+
+/**
+ * Given a set of memory ranges, this class constructs detailed error messages.
+ */
+public final class IndexExceptionBuilder {
+	private final Database db;
+	private final List<RelatedAddress> relatedAddresses = new ArrayList<>();
+
+	/**
+	 * Constructs a new {@link IndexExceptionBuilder}
+	 */
+	public IndexExceptionBuilder(Database db) {
+		this.db = db;
+	}
+
+	/**
+	 * Adds an address range to this problem description, given the first address that may be corrupt,
+	 * the size of the possibly-corrupt address range, and a custom description for the memory at this
+	 * address range.
+	 */
+	public IndexExceptionBuilder addProblemAddress(String description, long dataBlockAddress, int rangeSize) {
+		MemoryAccessLog lastWrite = this.db.getLog().getReportFor(dataBlockAddress, rangeSize);
+		this.relatedAddresses.add(new RelatedAddress(description, dataBlockAddress, rangeSize, lastWrite));
+		return this;
+	}
+
+	/**
+	 * Adds an address range to this problem description, given a field that may be corrupt, the base
+	 * address for its struct, and a custom description for the field.
+	 * 
+	 * @return this
+	 */
+	public IndexExceptionBuilder addProblemAddress(String description, IField field, long address) {
+		long offset = field.getOffset();
+		int size = field.getRecordSize();
+		return addProblemAddress(description, address + offset, size);
+	}
+
+	/**
+	 * Adds an address range to this problem description, given the field that may be corrupt
+	 * and the base address for its struct.
+	 * 
+	 * @return this
+	 */
+	public IndexExceptionBuilder addProblemAddress(IField field, long address) {
+		return addProblemAddress(field.getFieldName(), field, address);
+	}
+
+	/**
+	 * Returns a newly constructed {@link IndexException} containing the given message and all the addresses collected
+	 * by this object.
+	 */
+	public IndexException build(String description) {
+		IndexException toThrow = new IndexException(description);
+		attachTo(toThrow);
+		return toThrow;
+	}
+
+	/**
+	 * Attaches the addresses collected by the receiver to the given exception.
+	 */
+	public void attachTo(IndexException exception) {
+		for (RelatedAddress next : this.relatedAddresses) {
+			exception.addRelatedAddress(next);
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index 7044df6..9b20c45 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -708,10 +708,10 @@ public final class Nd {
 	}
 
 	/**
-	 * Creates a {@link ProblemBuilder} object that collects information about database corruption after it is 
+	 * Creates a {@link IndexExceptionBuilder} object that collects information about database corruption after it is 
 	 * detected.
 	 */
-	public ProblemBuilder describeProblem() {
+	public IndexExceptionBuilder describeProblem() {
 		return this.db.describeProblem();
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
index 6511604..d550751 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/NdNode.java
@@ -80,9 +80,9 @@ public abstract class NdNode implements IDestructable {
 
 		Class<T> clazz = targetType.getStructClass();
 		if (!clazz.isAssignableFrom(result.getClass())) {
-			nd.describeProblem()
+			throw nd.describeProblem()
 				.addProblemAddress(NODE_TYPE, address)
-				.throwException("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
+				.build("Found wrong data type at address " + address + ". Expected a subclass of " +  //$NON-NLS-1$//$NON-NLS-2$
 					clazz + " but found " + result.getClass()); //$NON-NLS-1$
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
deleted file mode 100644
index dc9434b..0000000
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/ProblemBuilder.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2017 Google, Inc and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Stefan Xenos (Google) - Initial implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core.nd;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.jdt.internal.core.nd.db.ModificationLog.MemoryAccessLog;
-import org.eclipse.jdt.internal.core.nd.db.Database;
-import org.eclipse.jdt.internal.core.nd.db.IndexException;
-import org.eclipse.jdt.internal.core.nd.db.RelatedAddress;
-import org.eclipse.jdt.internal.core.nd.field.IField;
-
-/**
- * Given a set of memory ranges, this class constructs detailed error messages.
- */
-public final class ProblemBuilder {
-	private final Database db;
-	private final List<RelatedAddress> relatedAddresses = new ArrayList<>();
-
-	/**
-	 * Constructs a new {@link ProblemBuilder}
-	 */
-	public ProblemBuilder(Database db) {
-		this.db = db;
-	}
-
-	/**
-	 * Adds an address range to this problem description, given the first address that may be corrupt,
-	 * the size of the possibly-corrupt address range, and a custom description for the memory at this
-	 * address range.
-	 */
-	public ProblemBuilder addProblemAddress(String description, long dataBlockAddress, int rangeSize) {
-		MemoryAccessLog lastWrite = this.db.getLog().getReportFor(dataBlockAddress, rangeSize);
-		this.relatedAddresses.add(new RelatedAddress(description, dataBlockAddress, rangeSize, lastWrite));
-		return this;
-	}
-
-	/**
-	 * Adds an address range to this problem description, given a field that may be corrupt, the base
-	 * address for its struct, and a custom description for the field.
-	 * 
-	 * @return this
-	 */
-	public ProblemBuilder addProblemAddress(String description, IField field, long address) {
-		long offset = field.getOffset();
-		int size = field.getRecordSize();
-		return addProblemAddress(description, address + offset, size);
-	}
-
-	/**
-	 * Adds an address range to this problem description, given the field that may be corrupt
-	 * and the base address for its struct.
-	 * 
-	 * @return this
-	 */
-	public ProblemBuilder addProblemAddress(IField field, long address) {
-		return addProblemAddress(field.getFieldName(), field, address);
-	}
-
-	/**
-	 * Throws an {@link IndexException} containing the given message and all the addresses collected
-	 * by this object. 
-	 */
-	public void throwException(String description) {
-		IndexException toThrow = new IndexException(description);
-		attachTo(toThrow);
-		throw toThrow;
-	}
-
-	/**
-	 * Attaches the addresses collected by the receiver to the given exception.
-	 */
-	public void attachTo(IndexException exception) {
-		for (RelatedAddress next : this.relatedAddresses) {
-			exception.addRelatedAddress(next);
-		}
-	}
-}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
index 03a3404..ac3ede1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
@@ -210,7 +210,7 @@ public final class RawGrowableArray {
 			db.putRecPtr(recordAddress, value);
 			setSize(nd, address, newSize);
 		} catch (IndexException e) {
-			ProblemBuilder descriptor = nd.describeProblem();
+			IndexExceptionBuilder descriptor = nd.describeProblem();
 			addSizeTo(nd, address, descriptor);
 			descriptor.attachTo(e);
 			throw e;
@@ -385,12 +385,12 @@ public final class RawGrowableArray {
 
 			// We use reads of 1 past the end of the array to handle insertions.
 			if (index > size) {
-				ProblemBuilder builder = nd.describeProblem();
+				IndexExceptionBuilder builder = nd.describeProblem();
 
 				addSizeTo(nd, address, builder);
 
 				builder.addProblemAddress(GROWABLE_BLOCK_ADDRESS, address);
-				builder.throwException(
+				throw builder.build(
 						"Record index " + index + " out of range. Array contains " + size + " elements"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			}
 
@@ -406,10 +406,10 @@ public final class RawGrowableArray {
 						+ block * Database.PTR_SIZE;
 				growableBlockAddress = db.getRecPtr(dataBlockAddress);
 				if (growableBlockAddress == 0) {
-					nd.describeProblem()
+					throw nd.describeProblem()
 						.addProblemAddress("backpointer number " + block, dataBlockAddress, Database.PTR_SIZE) //$NON-NLS-1$
 						.addProblemAddress(GROWABLE_BLOCK_ADDRESS, address)
-						.throwException("Null data block found in metablock"); //$NON-NLS-1$
+						.build("Null data block found in metablock"); //$NON-NLS-1$
 				}
 				growableBlockRelativeIndex = blockRelativeIndex;
 			}
@@ -422,7 +422,7 @@ public final class RawGrowableArray {
 		}
 	}
 
-	private void addSizeTo(Nd nd, long address, ProblemBuilder builder) {
+	private void addSizeTo(Nd nd, long address, IndexExceptionBuilder builder) {
 		long growableBlockAddress = GROWABLE_BLOCK_ADDRESS.get(nd, address);
 		if (growableBlockAddress != 0) {
 			builder.addProblemAddress(GrowableBlockHeader.ARRAY_SIZE, growableBlockAddress);
@@ -441,9 +441,9 @@ public final class RawGrowableArray {
 
 		Database db = nd.getDB();
 		if (index > lastElementIndex || index < 0) {
-			ProblemBuilder descriptor = nd.describeProblem().addProblemAddress(GROWABLE_BLOCK_ADDRESS, address);
+			IndexExceptionBuilder descriptor = nd.describeProblem().addProblemAddress(GROWABLE_BLOCK_ADDRESS, address);
 			addSizeTo(nd, address, descriptor);
-			descriptor.throwException("Attempt to remove nonexistent element " + index //$NON-NLS-1$
+			throw descriptor.build("Attempt to remove nonexistent element " + index //$NON-NLS-1$
 					+ " from an array of size " + (lastElementIndex + 1)); //$NON-NLS-1$
 		}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 8d7a4dd..aa7f758 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -31,7 +31,7 @@ import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.OperationCanceledException;
 import org.eclipse.core.runtime.Status;
-import org.eclipse.jdt.internal.core.nd.ProblemBuilder;
+import org.eclipse.jdt.internal.core.nd.IndexExceptionBuilder;
 import org.eclipse.jdt.internal.core.nd.db.ModificationLog.Tag;
 import org.eclipse.osgi.util.NLS;
 
@@ -564,9 +564,9 @@ public class Database {
 					chunk.makeDirty();
 					int blockReportedSize = chunk.getShort(freeBlock);
 					if (blockReportedSize != useDeltas * BLOCK_SIZE_DELTA) {
-						describeProblem()
+						throw describeProblem()
 							.addProblemAddress("block size", freeBlock, SHORT_SIZE) //$NON-NLS-1$
-							.throwException(
+							.build(
 								"Heap corruption detected in free space list. Block " + freeBlock //$NON-NLS-1$
 								+ " reports a size of " + blockReportedSize + " but was in the list for blocks of size "  //$NON-NLS-1$//$NON-NLS-2$
 								+ useDeltas * BLOCK_SIZE_DELTA);
@@ -674,18 +674,18 @@ public class Database {
 			numChunks = getBlockHeaderForChunkNum(freeBlockChunkNum);
 
 			if (numChunks < neededChunks) {
-				describeProblem()
+				throw describeProblem()
 					.addProblemAddress("chunk header", freeBlockChunkNum * CHUNK_SIZE, INT_SIZE) //$NON-NLS-1$
-					.throwException("A block in the free space trie was too small or wasn't actually free. Reported size = " //$NON-NLS-1$
+					.build("A block in the free space trie was too small or wasn't actually free. Reported size = " //$NON-NLS-1$
 							+ numChunks + " chunks, requested size = " + neededChunks + " chunks");  //$NON-NLS-1$//$NON-NLS-2$
 			}
 
 			int footer = getBlockFooterForChunkBefore(freeBlockChunkNum + numChunks);
 			if (footer != numChunks) {
-				describeProblem()
+				throw describeProblem()
 					.addProblemAddress("chunk header", freeBlockChunkNum * CHUNK_SIZE, INT_SIZE) //$NON-NLS-1$
 					.addProblemAddress("chunk footer", (freeBlockChunkNum + numChunks) * CHUNK_SIZE - INT_SIZE, INT_SIZE) //$NON-NLS-1$
-					.throwException("The header and footer didn't match for a block in the free space trie. Expected " //$NON-NLS-1$
+					.build("The header and footer didn't match for a block in the free space trie. Expected " //$NON-NLS-1$
 							+ numChunks + " but found " + footer); //$NON-NLS-1$
 			}
 
@@ -888,9 +888,9 @@ public class Database {
 			long addressOfPrevBlockPointer = getAddressOfFirstBlockPointer(correctSize);
 			while (block != 0) {
 				if (block == result) {
-					describeProblem()
+					throw describeProblem()
 						.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
-						.throwException("Block " + result  //$NON-NLS-1$
+						.build("Block " + result  //$NON-NLS-1$
 							+ " was found in the free space list, even though it wasn't free"); //$NON-NLS-1$
 				}
 				addressOfPrevBlockPointer = block + BLOCK_NEXT_OFFSET;
@@ -907,7 +907,7 @@ public class Database {
 		int targetChunkNum = (int) (result / CHUNK_SIZE);
 
 		if (currentChunkNum == targetChunkNum) {
-			describeProblem().throwException("Block " + result  //$NON-NLS-1$
+			throw describeProblem().build("Block " + result  //$NON-NLS-1$
 					+ " was not supposed to be in the free space list, but was linked as the root of the list"); //$NON-NLS-1$
 		}
 
@@ -926,9 +926,9 @@ public class Database {
 			}
 
 			if (nextChildChunkNum == targetChunkNum) {
-				describeProblem()
+				throw describeProblem()
 					.addProblemAddress("trie child address", chunkAddress, INT_SIZE) //$NON-NLS-1$
-					.throwException("Chunk number " + nextChildChunkNum  //$NON-NLS-1$
+					.build("Chunk number " + nextChildChunkNum  //$NON-NLS-1$
 						+ " was found in the free space trie even though it was in use"); //$NON-NLS-1$
 			}
 
@@ -946,19 +946,19 @@ public class Database {
 			int blockReportedSize = getShort(block);
 			long followingBlock = getFreeRecPtr(block + BLOCK_NEXT_OFFSET);
 			if (measuredLastBlock != lastBlock) {
-				describeProblem()
+				throw describeProblem()
 					.addProblemAddress("last block", block + BLOCK_PREV_OFFSET, PTR_SIZE) //$NON-NLS-1$
 					.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
-					.throwException("The free space block (" + block //$NON-NLS-1$
+					.build("The free space block (" + block //$NON-NLS-1$
 						+ ") of size " + correctSize + " had an incorrect prev pointer to "  //$NON-NLS-1$//$NON-NLS-2$
 						+ measuredLastBlock + ", but it should have been pointing to " //$NON-NLS-1$
 						+ lastBlock);
 			}
 			if (blockReportedSize != correctSize) {
-				describeProblem()
+				throw describeProblem()
 					.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
 					.addProblemAddress("incoming pointer", addressOfPrevBlockPointer, PTR_SIZE) //$NON-NLS-1$
-					.throwException("A block (" + block + ") of size " + measuredLastBlock //$NON-NLS-1$ //$NON-NLS-2$
+					.build("A block (" + block + ") of size " + measuredLastBlock //$NON-NLS-1$ //$NON-NLS-2$
 						+ " was in the free space list for blocks of size " + correctSize); //$NON-NLS-1$
 			}
 			addressOfPrevBlockPointer = block + BLOCK_NEXT_OFFSET;
@@ -983,16 +983,16 @@ public class Database {
 
 	private void validateFreeSpaceNode(Set<Integer> visited, int chunkNum, int parent) {
 		if (visited.contains(chunkNum)) {
-			describeProblem().throwException("Chunk " + chunkNum + "(parent = " + parent //$NON-NLS-1$//$NON-NLS-2$
+			throw describeProblem().build("Chunk " + chunkNum + "(parent = " + parent //$NON-NLS-1$//$NON-NLS-2$
 					+ " appeared twice in the free space tree"); //$NON-NLS-1$
 		}
 
 		long chunkStart = chunkNum * CHUNK_SIZE;
 		int parentChunk = getInt(chunkStart + LargeBlock.PARENT_OFFSET);
 		if (parentChunk != parent) {
-			describeProblem()
+			throw describeProblem()
 				.addProblemAddress("parent pointer", chunkStart + LargeBlock.PARENT_OFFSET, Database.INT_SIZE) //$NON-NLS-1$
-				.throwException("Chunk " + chunkNum + " has the wrong parent. Expected " + parent  //$NON-NLS-1$//$NON-NLS-2$
+				.build("Chunk " + chunkNum + " has the wrong parent. Expected " + parent  //$NON-NLS-1$//$NON-NLS-2$
 					+ " but found  " + parentChunk); //$NON-NLS-1$
 		}
 
@@ -1012,10 +1012,10 @@ public class Database {
 					Integer.highestOneBit(sizeDifference)) - 1;
 
 			if (firstDifference != testPosition) {
-				ProblemBuilder descriptor = describeProblem();
+				IndexExceptionBuilder descriptor = describeProblem();
 				attachBlockHeaderForChunkNum(descriptor, chunkNum);
 				attachBlockHeaderForChunkNum(descriptor, nextChildChunkNum);
-				descriptor.throwException("Chunk " + nextChildChunkNum + " contained an incorrect size of "  //$NON-NLS-1$//$NON-NLS-2$
+				throw descriptor.build("Chunk " + nextChildChunkNum + " contained an incorrect size of "  //$NON-NLS-1$//$NON-NLS-2$
 						+ nextSize + ". It was at position " + testPosition + " in parent " + chunkNum //$NON-NLS-1$ //$NON-NLS-2$
 						+ " which had size " + numChunks); //$NON-NLS-1$
 			}
@@ -1132,7 +1132,7 @@ public class Database {
 		return getInt((long) firstChunkNum * CHUNK_SIZE);
 	}
 
-	private void attachBlockHeaderForChunkNum(ProblemBuilder builder, int firstChunkNum) {
+	private void attachBlockHeaderForChunkNum(IndexExceptionBuilder builder, int firstChunkNum) {
 		if (firstChunkNum >= this.fChunksUsed) {
 			return;
 		}
@@ -1271,11 +1271,11 @@ public class Database {
 				int chunkNum = (int) (address / CHUNK_SIZE);
 				int numChunks = -getBlockHeaderForChunkNum(chunkNum);
 				if (numChunks < 0) {
-					ProblemBuilder builder = describeProblem();
+					IndexExceptionBuilder builder = describeProblem();
 					if (chunkNum < this.fChunksUsed) {
 						builder.addProblemAddress("block header", (long) chunkNum * CHUNK_SIZE, INT_SIZE); //$NON-NLS-1$
 					}
-					builder.throwException("Already freed large block " + address); //$NON-NLS-1$
+					throw builder.build("Already freed large block " + address); //$NON-NLS-1$
 				}
 				blockSize = (long) numChunks * CHUNK_SIZE;
 				this.log.recordFree(address, (int)(blockSize - BLOCK_HEADER_SIZE));
@@ -1284,16 +1284,16 @@ public class Database {
 				// Deallocating a normal block
 				// TODO Look for opportunities to merge small blocks
 				if (blockSize < 0) {
-					describeProblem()
+					throw describeProblem()
 						.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
-						.throwException("Already freed record " + address); //$NON-NLS-1$
+						.build("Already freed record " + address); //$NON-NLS-1$
 				}
 				this.log.recordFree(address, (int)(blockSize - BLOCK_HEADER_SIZE));
 				int offset = Chunk.recPtrToIndex(address);
 				if (offset + blockSize > CHUNK_SIZE) {
-					describeProblem()
+					throw describeProblem()
 						.addProblemAddress("block size", block, SHORT_SIZE) //$NON-NLS-1$
-						.throwException("Attempting to free chunk of impossible size. The block at address " //$NON-NLS-1$
+						.build("Attempting to free chunk of impossible size. The block at address " //$NON-NLS-1$
 								+ address + " in chunk " + chunk.fSequenceNumber + " offset " + offset //$NON-NLS-1$//$NON-NLS-2$
 								+ " can't be as large as " //$NON-NLS-1$
 								+ blockSize + " bytes since that would make it extend beyond the end of the chunk"); //$NON-NLS-1$
@@ -1854,7 +1854,7 @@ public class Database {
 		}
 	}
 
-	public ProblemBuilder describeProblem() {
-		return new ProblemBuilder(this);
+	public IndexExceptionBuilder describeProblem() {
+		return new IndexExceptionBuilder(this);
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index bcde1c5..c5d6733 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -106,9 +106,9 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 			long size = TYPE_ARGUMENTS.size(getNd(), this.address);
 
 			if (size != 1) {
-				getNd().describeProblem()
+				throw getNd().describeProblem()
 					.addProblemAddress(TYPE_ARGUMENTS, this.address)
-					.throwException("Array types should have exactly one argument"); //$NON-NLS-1$
+					.build("Array types should have exactly one argument"); //$NON-NLS-1$
 			}
 
 			return TYPE_ARGUMENTS.get(getNd(), this.address, 0).getType();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
index 4f9b6a2..d81e73a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/TagTreeReader.java
@@ -78,9 +78,9 @@ public abstract class TagTreeReader {
 		readAddress += Database.BYTE_SIZE;
 		TagHandler<?> reader = this.readers[nextByte];
 		if (reader == null) {
-			nd.describeProblem()
+			throw nd.describeProblem()
 				.addProblemAddress("tag", address, 1) //$NON-NLS-1$
-				.throwException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
+				.build("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		return reader.read(nd, readAddress, this, bytesRead);
@@ -100,7 +100,7 @@ public abstract class TagTreeReader {
 		TagHandler handler = this.readers[key];
 
 		if (handler == null) {
-			nd.describeProblem().throwException("Invalid key " + key + " returned from getKeyFor(...)"); //$NON-NLS-1$//$NON-NLS-2$
+			throw nd.describeProblem().build("Invalid key " + key + " returned from getKeyFor(...)"); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		handler.write(nd, address, this, toWrite, bytesWritten);
@@ -114,9 +114,9 @@ public abstract class TagTreeReader {
 
 		TagHandler<?> handler = this.readers[nextByte];
 		if (handler == null) {
-			nd.describeProblem()
+			throw nd.describeProblem()
 				.addProblemAddress("tag", address, 1) //$NON-NLS-1$
-				.throwException("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
+				.build("Found unknown tag with value " + nextByte + " at address " + address); //$NON-NLS-1$//$NON-NLS-2$
 		}
 
 		handler.destruct(nd, readAddress, this);
