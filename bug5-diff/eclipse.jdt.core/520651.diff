commit 27c39f2d52997455d4e4e1030d3682e1263712f5
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Aug 15 10:44:08 2017 +0200

    Bug 520651: [9] module-info.class has a type as its child
    
    - preparatory clean-up
    
    Change-Id: I5e634f55d8817c5483d10c8380a1cce1ba4d2803

3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
20	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryModule.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
0	201	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
2	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 7a1ce5e..2560cc9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -32,6 +32,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
@@ -55,7 +56,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private AnnotationInfo[] annotations;
 	private TypeAnnotationInfo[] typeAnnotations;
 	private FieldInfo[] fields;
-	private IModule moduleDeclaration;
+	private IBinaryModule moduleDeclaration;
 	public char[] moduleName;
 	private int fieldsCount;
 
@@ -618,7 +619,7 @@ public char[] getModule() {
  * 
  * @return the module declaration this represents
  */
-public IModule getModuleDeclaration() {
+public IBinaryModule getModuleDeclaration() {
 	return this.moduleDeclaration;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
index 72019ba..6371324 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
@@ -21,9 +21,10 @@ import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 
-public class ModuleInfo extends ClassFileStruct implements IModule {
+public class ModuleInfo extends ClassFileStruct implements IBinaryModule {
 	protected int flags;
 	protected int requiresCount;
 	protected int exportsCount;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryModule.java
new file mode 100644
index 0000000..5c3215f
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryModule.java
@@ -0,0 +1,20 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.env;
+
+/** Marker interface for usage of {@link org.eclipse.jdt.internal.compiler.classfmt.ModuleInfo} outside the compiler proper. */
+public interface IBinaryModule extends IModule {
+	// empty
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
index 6f94b57..bd58fa5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
@@ -24,9 +24,9 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
@@ -257,7 +257,7 @@ private void generateInnerClassHandles(IType type, IBinaryType typeInfo, ArrayLi
 }
 private void generateModuleInfos(ClassFile classFile, IBinaryType info, HashMap newElements, ArrayList childrenHandles) {
 	// TODO: The following needs fix once we can get ModuleDeclaration from IndexBinaryType
-	IModule modDecl = (info instanceof ClassFileReader) ? ((ClassFileReader) info).getModuleDeclaration() : null;
+	IBinaryModule modDecl = (info instanceof ClassFileReader) ? ((ClassFileReader) info).getModuleDeclaration() : null;
 	if (modDecl != null) {
 		char[] modName = modDecl.name();
 		BinaryModule handle = new BinaryModule(classFile, new String(modName));
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
deleted file mode 100644
index 59f1e21..0000000
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core;
-
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.ExportsStatement;
-import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
-import org.eclipse.jdt.internal.compiler.ast.RequiresStatement;
-import org.eclipse.jdt.internal.compiler.ast.ProvidesStatement;
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.ast.UsesStatement;
-import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.ModuleReferenceImpl;
-import org.eclipse.jdt.internal.compiler.env.PackageExportImpl;
-
-public class ModuleInfo extends SourceTypeElementInfo implements IModule {
-
-	protected static final IModuleReference[] NO_REQUIRES = new IModuleReference[0];
-	protected static final IPackageExport[] NO_EXPORTS = new IPackageExport[0];
-	protected static final IService[] NO_SERVICES = new IService[0];
-	protected static final char[][] NO_USES = new char[0][0];
-
-	static class Service implements IModule.IService {
-		char[] provides;
-		char[][] with;
-		@Override
-		public char[] name() {
-			return this.provides;
-		}
-
-		@Override
-		public char[][] with() {
-			return this.with;
-		}
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append("provides "); //$NON-NLS-1$
-			buffer.append(this.provides);
-			buffer.append(" with "); //$NON-NLS-1$
-			buffer.append(this.with);
-			buffer.append(';');
-			return buffer.toString();
-		}
-	}
-	char[] name;
-	boolean isOpen = false;
-	ModuleReferenceImpl[] requires;
-	PackageExportImpl[] exports;
-	char[][] uses;
-	Service[] provides;
-	PackageExportImpl[] opens;
-
-	@Override
-	public boolean isOpen() {
-		return this.isOpen;
-	}
-	@Override
-	public char[] name() {
-		return this.name;
-	}
-	public static ModuleInfo createModule(ModuleDeclaration module) {
-		ModuleInfo mod = new ModuleInfo();
-		mod.name = module.moduleName;
-		mod.isOpen = module.isOpen();
-		if (module.requiresCount > 0) {
-			RequiresStatement[] refs = module.requires;
-			mod.requires = new ModuleReferenceImpl[refs.length];
-			for (int i = 0; i < refs.length; i++) {
-				mod.requires[i] = new ModuleReferenceImpl();
-				mod.requires[i].name = CharOperation.concatWith(refs[i].module.tokens, '.');
-				mod.requires[i].modifiers = refs[i].modifiers;
-			}
-		} else {
-			mod.requires = new ModuleReferenceImpl[0];
-		}
-		if (module.exportsCount > 0) {
-			ExportsStatement[] refs = module.exports;
-			mod.exports = new PackageExportImpl[refs.length];
-			for (int i = 0; i < refs.length; i++) {
-				PackageExportImpl exp = createPackageExport(refs, i);
-				mod.exports[i] = exp;
-			}
-		} else {
-			mod.exports = new PackageExportImpl[0];
-		}
-		if (module.usesCount > 0) {
-			UsesStatement[] uses = module.uses;
-			mod.uses = new char[uses.length][];
-			for(int i = 0; i < uses.length; i++) {
-				mod.uses[i] = CharOperation.concatWith(uses[i].serviceInterface.getTypeName(), '.');
-			}
-		}
-		if (module.servicesCount > 0) {
-			ProvidesStatement[] services = module.services;
-			mod.provides = new Service[module.servicesCount];
-			for (int i = 0; i < module.servicesCount; i++) {
-				mod.provides[i] = createService(services[i].serviceInterface, services[i].implementations);
-			}
-		}
-		return mod;
-	}
-
-	private static PackageExportImpl createPackageExport(ExportsStatement[] refs, int i) {
-		ExportsStatement ref = refs[i];
-		PackageExportImpl exp = new PackageExportImpl();
-		exp.pack = ref.pkgName;
-		ModuleReference[] imp = ref.targets;
-		if (imp != null) {
-			exp.exportedTo = new char[imp.length][];
-			for(int j = 0; j < imp.length; j++) {
-				exp.exportedTo[j] = imp[j].moduleName;
-			}
-		}
-		return exp;
-	}
-	private static Service createService(TypeReference service, TypeReference[] with) {
-		Service ser = new Service();
-		ser.provides = CharOperation.concatWith(service.getTypeName(), '.');
-		ser.with = new char[with.length][];
-		for (int i = 0; i < with.length; i++) {
-			ser.with[i] = CharOperation.concatWith(with[i].getTypeName(), '.');
-		}
-		return ser;
-	}
-
-	@Override
-	public IModule.IModuleReference[] requires() {
-		return this.requires;
-	}
-	@Override
-	public IPackageExport[] exports() {
-		return this.exports;
-	}
-	@Override
-	public char[][] uses() {
-		return this.uses;
-	}
-	@Override
-	public IService[] provides() {
-		return this.provides;
-	}
-	public IPackageExport[] opens() {
-		return this.opens;
-	}
-	public String toString() {
-		StringBuffer buffer = new StringBuffer(getClass().getName());
-		toStringContent(buffer);
-		return buffer.toString();
-	}
-	protected void toStringContent(StringBuffer buffer) {
-		buffer.append("\nmodule "); //$NON-NLS-1$
-		buffer.append(this.name).append(' ');
-		buffer.append('{').append('\n');
-		if (this.requires != null && this.requires.length > 0) {
-			buffer.append('\n');
-			for(int i = 0; i < this.requires.length; i++) {
-				buffer.append("\trequires "); //$NON-NLS-1$
-				if (this.requires[i].isTransitive()) {
-					buffer.append("public "); //$NON-NLS-1$
-				}
-				buffer.append(this.requires[i].name);
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.exports != null && this.exports.length > 0) {
-			buffer.append('\n');
-			for(int i = 0; i < this.exports.length; i++) {
-				buffer.append("\texports "); //$NON-NLS-1$
-				buffer.append(this.exports[i].toString()).append('\n');
-			}
-		}
-		if (this.uses != null) {
-			buffer.append('\n');
-			for (char[] cs : this.uses) {
-				buffer.append(cs);
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.provides != null) {
-			buffer.append('\n');
-			for(Service ser : this.provides) {
-				buffer.append('\t').append(ser.toString()).append('\n');
-			}
-		}
-		buffer.append('\n').append('}').toString();
-	}
-
-}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
index 4278164..6ef7323 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
@@ -18,11 +18,11 @@ import org.eclipse.core.resources.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.batch.BasicModule;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
-import org.eclipse.jdt.internal.core.ModuleInfo;
 import org.eclipse.jdt.internal.core.util.Util;
 
 public class ClasspathMultiDirectory extends ClasspathDirectory {
@@ -81,10 +81,7 @@ public void acceptModuleInfo(ICompilationUnit cu, Parser parser) {
 	CompilationUnitDeclaration unit = parser.parse(cu, compilationResult);
 	// Request could also come in when module-info has changed or removed.
 	if (unit.isModuleInfo() && unit.moduleDeclaration != null) {
-		IModule decl = ModuleInfo.createModule(unit.moduleDeclaration);
-		if (decl != null) {
-			this.module = decl;
-		}
+		this.module = new BasicModule(unit.moduleDeclaration, null);
 	}
 }
 public void setModule(IModule mod) {
commit 25071e6ed2edcb8faae73209cbe4aeaceb937d78
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Aug 15 11:36:42 2017 +0200

    Bug 520651: [9] module-info.class has a type as its child
    
    Change-Id: Iae35b45ffbba8f2a5e25d33207a098ef4e707c47

7	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
9	5	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
7	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
36	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
21	13	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
14	3	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClassFile.java
33	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModularClassFile.java
35	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOrdinaryClassFile.java
73	2	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragment.java
9	2	org.eclipse.jdt.core/model/org/eclipse/jdt/core/ITypeRoot.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
466	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/AbstractClassFile.java
5	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BasicCompilationUnit.java
1	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
2	422	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
15	22	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
15	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java
4	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
11	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
7	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
262	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleDescriptionInfo.java
8	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java
70	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
7	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
8	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
5	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
2	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
20	19	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
4	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
29	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
7	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
index 5341618..3166f34 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 BEA Systems, Inc.
+ * Copyright (c) 2005, 2017 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
  *******************************************************************************/
@@ -20,8 +24,8 @@ import java.util.List;
 import org.eclipse.jdt.apt.core.internal.env.BaseProcessorEnv;
 import org.eclipse.jdt.apt.core.internal.util.PackageUtil;
 import org.eclipse.jdt.apt.core.internal.util.SourcePositionImpl;
-import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaModelException;
@@ -223,7 +227,7 @@ public class PackageDeclarationImpl extends DeclarationImpl implements PackageDe
 		try {
 			// Get all top-level classes -- ignore local, member, and anonymous classes
 			for (IPackageFragment fragment : fragments) {
-				for (IClassFile classFile : fragment.getClassFiles()) {
+				for (IOrdinaryClassFile classFile : fragment.getOrdinaryClassFiles()) {
 					IType type = classFile.getType();
 					if (! (type.isLocal() || type.isMember() || type.isAnonymous()) ) {
 						types.add(type);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
index ae53ed7..05d649a 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2016 BEA Systems Inc. and others
+ * Copyright (c) 2005, 2017 BEA Systems Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
  *******************************************************************************/
@@ -39,11 +43,11 @@ import org.eclipse.jdt.apt.core.internal.util.TypesUtil;
 import org.eclipse.jdt.apt.core.internal.util.Visitors.AnnotatedNodeVisitor;
 import org.eclipse.jdt.apt.core.util.AptConfig;
 import org.eclipse.jdt.core.BindingKey;
-import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMember;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IType;
@@ -556,9 +560,9 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
 			// If we find package-info, don't use it, but set 
 			// it aside in case it's all we can find.
 			ICompilationUnit compUnit = null;
-			IClassFile classFile = null;
+			IOrdinaryClassFile classFile = null;
 			ICompilationUnit pkgInfoUnit = null;
-			IClassFile pkgInfoClassFile = null;
+			IOrdinaryClassFile pkgInfoClassFile = null;
 			OUTER:
 				for (IPackageFragment frag : pkgFrags) {
 					if (frag.getKind() == IPackageFragmentRoot.K_SOURCE) {
@@ -573,7 +577,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
 						}
 					}
 					else { // K_BINARY
-						for (IClassFile file : frag.getClassFiles()) {
+						for (IOrdinaryClassFile file : frag.getOrdinaryClassFiles()) {
 							String cfName = file.getElementName();
 							if ("package-info.class".equals(cfName)) { //$NON-NLS-1$
 								pkgInfoClassFile = file;
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
index e6535c2..873fa95 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425,
@@ -973,7 +977,7 @@ public void testClasspathCreateLibraryEntry() throws CoreException {
 		assertEquals(
 			"Unexpected numbers of .class files",
 			0,
-			pkg.getClassFiles().length);
+			pkg.getAllClassFiles().length);
 
 		setClasspath(
 			proj,
@@ -991,7 +995,7 @@ public void testClasspathCreateLibraryEntry() throws CoreException {
 		assertEquals(
 			"Unexpected numbers of .class files",
 			1,
-			pkg.getClassFiles().length);
+			pkg.getAllClassFiles().length);
 
 		//ensure that the new kind has been persisted in the classpath file
 		proj.close();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
index 08a67a5..aa5a267 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
@@ -24,7 +24,9 @@ import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
 import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
@@ -846,7 +848,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			assertTrue("Invalid selection result", (elements[0] instanceof BinaryModule));
 			IModuleDescription mod = (IModuleDescription) elements[0];
 			String id = mod.getHandleIdentifier();
-			assertTrue("incorrect id", id.matches("=Java9Elements/.*"+Pattern.quote("\\/jmods\\/java.base.jmod<(module-info.class`java.base")));
+			assertTrue("incorrect id", id.matches("=Java9Elements/.*"+Pattern.quote("\\/jmods\\/java.base.jmod<'`java.base")));
 			IJavaElement element = JavaCore.create(id);
 			assertEquals("incorrect element type", IJavaElement.JAVA_MODULE, element.getElementType());
 			assertEquals("incorrect module name", "java.base", element.getElementName());
@@ -855,4 +857,37 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			deleteProject("Java9Elements");
 		}
 	}
+	public void test_binary_module_bug520651() throws Exception {
+		try {
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+			project.open(null);
+			ITypeRoot classFile = null;
+			IModuleDescription moduleDescription = null;
+			for (IPackageFragmentRoot root : project.getAllPackageFragmentRoots()) {
+				moduleDescription = root.getModuleDescription();
+				if (moduleDescription != null && moduleDescription.getElementName().equals("java.base")) {
+					try {
+						classFile = root.getPackageFragment("").getOrdinaryClassFile("module-info.class");
+						fail("getOrdinaryClassFile() should not answer module-info.class");
+					} catch (IllegalArgumentException iae) {
+						// expected
+					}
+					classFile = root.getPackageFragment("").getModularClassFile();
+					break;
+				}
+			}
+			assertNotNull("classfile should not be null", classFile);
+			assertEquals("same module", moduleDescription, classFile.getModule());
+			IJavaElement[] children = classFile.getChildren();
+			assertEquals("number of children", 1, children.length);
+			IJavaElement child = children[0];
+			assertTrue("type of child", child instanceof BinaryModule);
+			assertEquals("module name", "java.base", child.getElementName());
+			BinaryModule mod = (BinaryModule) child;
+			assertEquals("# mod children", 0, mod.getChildren().length);
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 93c9c59..202ecb6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -472,6 +472,7 @@ public interface TypeConstants {
 	// synthetic package-info name
 	public static final char[] PACKAGE_INFO_NAME = "package-info".toCharArray(); //$NON-NLS-1$
 	public static final char[] MODULE_INFO_NAME = "module-info".toCharArray(); //$NON-NLS-1$
+	public static final String MODULE_INFO_NAME_STRING = "module-info"; //$NON-NLS-1$
 	public static final char[] MODULE_INFO_FILE_NAME = "module-info.java".toCharArray(); //$NON-NLS-1$
 	public static final char[] MODULE_INFO_CLASS_NAME = "module-info.class".toCharArray(); //$NON-NLS-1$
 	public static final String MODULE_INFO_FILE_NAME_STRING = "module-info.java"; //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index 5943470..91ae5d3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2016 IBM Corporation and others.
+ * Copyright (c) 2004, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1138,19 +1138,27 @@ public class ASTParser {
 							}
 							PackageFragment packageFragment = (PackageFragment) this.typeRoot.getParent();
 							BinaryType type = (BinaryType) this.typeRoot.findPrimaryType();
-							IBinaryType binaryType = (IBinaryType) type.getElementInfo();
-							// file name is used to recreate the Java element, so it has to be the toplevel .class file name
-							char[] fileName = binaryType.getFileName();
-							int firstDollar = CharOperation.indexOf('$', fileName);
-							if (firstDollar != -1) {
-								char[] suffix = SuffixConstants.SUFFIX_class;
-								int suffixLength = suffix.length;
-								char[] newFileName = new char[firstDollar + suffixLength];
-								System.arraycopy(fileName, 0, newFileName, 0, firstDollar);
-								System.arraycopy(suffix, 0, newFileName, firstDollar, suffixLength);
-								fileName = newFileName;
+							String fileNameString = null;
+							if (type != null) {
+								IBinaryType binaryType = (IBinaryType) type.getElementInfo();
+								// file name is used to recreate the Java element, so it has to be the toplevel .class file name
+								char[] fileName = binaryType.getFileName();
+
+								int firstDollar = CharOperation.indexOf('$', fileName);
+								if (firstDollar != -1) {
+									char[] suffix = SuffixConstants.SUFFIX_class;
+									int suffixLength = suffix.length;
+									char[] newFileName = new char[firstDollar + suffixLength];
+									System.arraycopy(fileName, 0, newFileName, 0, firstDollar);
+									System.arraycopy(suffix, 0, newFileName, firstDollar, suffixLength);
+									fileName = newFileName;
+								}
+								fileNameString = new String(fileName);
+							} else {
+								// assumed to be "module-info.class" (which has no type):
+								fileNameString = this.typeRoot.getElementName();
 							}
-							sourceUnit = new BasicCompilationUnit(sourceString.toCharArray(), Util.toCharArrays(packageFragment.names), new String(fileName), this.project);
+							sourceUnit = new BasicCompilationUnit(sourceString.toCharArray(), Util.toCharArrays(packageFragment.names), fileNameString, this.project);
 						} catch(JavaModelException e) {
 							// an error occured accessing the java element
 							StringWriter stringWriter = new StringWriter();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClassFile.java
index 9c51ec3..a5b8c43 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClassFile.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -13,8 +17,12 @@ package org.eclipse.jdt.core;
 import org.eclipse.core.runtime.IProgressMonitor;
 
 /**
- * Represents an entire binary type (single <code>.class</code> file).
- * A class file has a single child of type <code>IType</code>.
+ * Represents a single <code>.class</code> file, holding the binary form
+ * of either a type or a module:
+ * <ul>
+ * <li>A class file of type {@link IOrdinaryClassFile} has a single child of type <code>IType</code>,</li>
+ * <li>a class file of type {@link IModularClassFile} has a single child of type <code>IModuleDescription</code>.</li>
+ * </ul>
  * Class file elements need to be opened before they can be navigated.
  * If a class file cannot be parsed, its structure remains unknown. Use
  * <code>IJavaElement.isStructureKnown</code> to determine whether this is the
@@ -94,7 +102,10 @@ byte[] getBytes() throws JavaModelException;
  * This is a handle-only method. The type may or may not exist.
  *
  * @return the type contained in this class file
+ * @throws UnsupportedOperationException when invoked on an instance representing a modular class file.
+ * @deprecated should only be used as {@link IOrdinaryClassFile#getType()}.
  */
+@Deprecated
 IType getType();
 /**
  * Returns a working copy on the source associated with this class file using the given
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModularClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModularClassFile.java
new file mode 100644
index 0000000..1f89b53
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModularClassFile.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core;
+
+/**
+ * Represents the class file of a module description ("module-info.class").
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noimplement This interface is not intended to be implemented by clients.
+ */
+public interface IModularClassFile extends IClassFile {
+	/**
+	 * Returns the module description contained in this type root.
+	 * An error-free {@link IModularClassFile} should always have a module.
+	 *
+	 * @throws JavaModelException 
+	 * @return the module description contained in the type root.
+	 */
+	@Override
+	IModuleDescription getModule() throws JavaModelException;
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOrdinaryClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOrdinaryClassFile.java
new file mode 100644
index 0000000..e86ece3
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IOrdinaryClassFile.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core;
+
+/**
+ * Ordinary form of a {@link IClassFile} which holds exactly one <code>IType</code>.
+ * 
+ * @since 3.13 BETA_JAVA9
+ * @noimplement This interface is not intended to be implemented by clients.
+ */
+public interface IOrdinaryClassFile extends IClassFile {
+	/**
+	 * Returns the type contained in this class file.
+	 * This is a handle-only method. The type may or may not exist.
+	 *
+	 * <p>This method supersedes the corresponding super method.
+	 * This method will never throw {@link UnsupportedOperationException}.</p>
+	 *
+	 * @return the type contained in this class file
+	 */
+	@Override
+	IType getType();
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragment.java
index cea9e2b..95ba751 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragment.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -75,23 +79,90 @@ public interface IPackageFragment extends IParent, IJavaElement, IOpenable, ISou
 	 * in this package (for example, <code>"Object.class"</code>).
 	 * The ".class" suffix is required.
 	 * This is a handle-only method.  The class file may or may not be present.
+	 * <p>
+	 * This method can handle ordinary class files or modular class files
+	 * denoted by the name <code>"module-info.class"</code>.
+	 * </p>
 	 * @param name the given name
 	 * @return the class file with the specified name in this package
 	 */
 	IClassFile getClassFile(String name);
 	/**
+	 * Returns the class file with the specified name
+	 * in this package (for example, <code>"Object.class"</code>).
+	 * The ".class" suffix is required.
+	 * This is a handle-only method.  The class file may or may not be present.
+	 * <p>
+	 * This method is not applicable to the files <code>"module-info.class"</code>
+	 * as introduced in Java 9. For those please use {@link #getModularClassFile()}.
+	 * </p>
+	 * @param name the given name
+	 * @return the class file with the specified name in this package
+	 * @since 3.13 BETA_JAVA9
+	 */
+	IOrdinaryClassFile getOrdinaryClassFile(String name);
+
+	/**
+	 * Returns the class file for <code>"module-info.class"</code> in this package.
+	 * This is a handle-only method.  The class file may or may not be present.
+	 * If the class file is present, then it is guaranteed to contain an {@link IModuleDescription}.
+	 * 
+	 * @since 3.13 BETA_JAVA
+	 * @return the class file representing "module-info.class" in this package.
+	 */
+	IModularClassFile getModularClassFile();
+
+	/**
 	 * Returns all of the class files in this package fragment.
 	 *
 	 * <p>Note: it is possible that a package fragment contains only
 	 * compilation units (in other words, its kind is <code>K_SOURCE</code>), in
-	 * which case this method returns an empty collection.
+	 * which case this method returns an empty collection.</p>
+	 * 
+	 * <p>Note: the returned list may contain ordinary class files as well as
+	 * a modular class file (for "module-info.class").</p>
 	 *
 	 * @exception JavaModelException if this element does not exist or if an
 	 *		exception occurs while accessing its corresponding resource.
 	 * @return all of the class files in this package fragment
+	 * @since 3.13 BETA_JAVA9
+	 */
+	IClassFile[] getAllClassFiles() throws JavaModelException;
+	
+	/**
+	 * Returns all of the ordinary class files in this package fragment.
+	 * 
+	 * <p>Note: this list never includes a modular class file 
+	 * (see {@link #getModularClassFile()}).</p>
+	 *
+	 * <p>Note: it is possible that a package fragment contains only
+	 * compilation units (in other words, its kind is <code>K_SOURCE</code>), in
+	 * which case this method returns an empty collection.</p>
+	 *
+	 * @exception JavaModelException if this element does not exist or if an
+	 *		exception occurs while accessing its corresponding resource.
+	 * @return all of the ordinary class files in this package fragment
+	 * @deprecated Clients are advised to specifically use either {@link #getOrdinaryClassFiles()}
+	 * 		or {@link #getAllClassFiles()} to express their intent.
 	 */
+	@Deprecated
 	IClassFile[] getClassFiles() throws JavaModelException;
 	/**
+	 * Returns all of the ordinary class files in this package fragment,
+	 * i.e., not including the modular class file "module-info.class".
+	 *
+	 * <p>Note: it is possible that a package fragment contains only
+	 * compilation units (in other words, its kind is <code>K_SOURCE</code>), in
+	 * which case this method returns an empty collection.</p>
+	 * 
+	 * @exception JavaModelException if this element does not exist or if an
+	 *		exception occurs while accessing its corresponding resource.
+	 * @return all of the ordinary class files in this package fragment
+	 * @since 3.13 BETA_JAVA9
+	 */
+	IOrdinaryClassFile[] getOrdinaryClassFiles() throws JavaModelException;
+
+	/**
 	 * Returns the compilation unit with the specified name
 	 * in this package (for example, <code>"Object.java"</code>).
 	 * The name has to be a valid compilation unit name.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ITypeRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ITypeRoot.java
index b591043..6447257 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ITypeRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ITypeRoot.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -36,12 +40,15 @@ IType findPrimaryType();
 /**
  * Returns the module description contained in this type root or null if there is no module
  * in this type root.
+ * <p>Only subtype {@link IModularClassFile} promises to return non-null.</p>
  *
  * @throws JavaModelException 
  * @since 3.13 BETA_JAVA9
  * @return the module description contained in the type root or null.
  */
-IModuleDescription getModule() throws JavaModelException;
+default IModuleDescription getModule() throws JavaModelException {
+	return null;
+}
 /**
  * Returns the smallest element within this Java type root that
  * includes the given source position (that is, a method, field, etc.), or
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 4a470ca..20d424f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -4526,8 +4526,8 @@ public final class JavaCore extends Plugin {
 			if (element.equals(markerElement)) return true; // external elements may still be equal with different handleIDs.
 
 			// cycle through enclosing types in case marker is associated with a classfile (15568)
-			if (markerElement instanceof IClassFile){
-				IType enclosingType = ((IClassFile)markerElement).getType().getDeclaringType();
+			if (markerElement instanceof IOrdinaryClassFile){
+				IType enclosingType = ((IOrdinaryClassFile)markerElement).getType().getDeclaringType();
 				if (enclosingType != null){
 					markerElement = enclosingType.getClassFile(); // retry with immediate enclosing classfile
 					continue;
@@ -4569,8 +4569,8 @@ public final class JavaCore extends Plugin {
 			if (element.equals(markerElement)) return true; // external elements may still be equal with different handleIDs.
 
 			// cycle through enclosing types in case marker is associated with a classfile (15568)
-			if (markerElement instanceof IClassFile){
-				IType enclosingType = ((IClassFile)markerElement).getType().getDeclaringType();
+			if (markerElement instanceof IOrdinaryClassFile){
+				IType enclosingType = ((IOrdinaryClassFile)markerElement).getType().getDeclaringType();
 				if (enclosingType != null){
 					markerElement = enclosingType.getClassFile(); // retry with immediate enclosing classfile
 					continue;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/AbstractClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/AbstractClassFile.java
new file mode 100644
index 0000000..4089fa6
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/AbstractClassFile.java
@@ -0,0 +1,466 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 458577 - IClassFile.getWorkingCopy() may lead to NPE in BecomeWorkingCopyOperation
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
+ *								Bug 462768 - [null] NPE when using linked folder for external annotations
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.util.Util;
+
+/**
+ * Common parts of ClassFile (containing a BinaryType) and ModularClassFile (containing a BinaryModule).
+ * Prior to Java 9, most of this content was directly in ClassFile.
+ */
+public abstract class AbstractClassFile extends Openable implements IClassFile, SuffixConstants {
+
+	protected String name;
+
+	protected AbstractClassFile(PackageFragment parent, String nameWithoutExtension) {
+		super(parent);
+		this.name = nameWithoutExtension;
+	}
+
+	/*
+	 * @see IClassFile#becomeWorkingCopy(IProblemRequestor, WorkingCopyOwner, IProgressMonitor)
+	 */
+	public ICompilationUnit becomeWorkingCopy(IProblemRequestor problemRequestor, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException {
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		CompilationUnit workingCopy = new ClassFileWorkingCopy(this, owner == null ? DefaultWorkingCopyOwner.PRIMARY : owner);
+		JavaModelManager.PerWorkingCopyInfo perWorkingCopyInfo = manager.getPerWorkingCopyInfo(workingCopy, false/*don't create*/, true /*record usage*/, null/*no problem requestor needed*/);
+		if (perWorkingCopyInfo == null) {
+			// close cu and its children
+			close();
+	
+			BecomeWorkingCopyOperation operation = new BecomeWorkingCopyOperation(workingCopy, problemRequestor);
+			operation.runOperation(monitor);
+	
+			return workingCopy;
+		}
+		return perWorkingCopyInfo.workingCopy;
+	}
+
+	/**
+	 * @see ICodeAssist#codeComplete(int, ICompletionRequestor)
+	 * @deprecated
+	 */
+	@Deprecated
+	public void codeComplete(int offset, ICompletionRequestor requestor) throws JavaModelException {
+		codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY);
+	}
+	/**
+	 * @see ICodeAssist#codeComplete(int, ICompletionRequestor, WorkingCopyOwner)
+	 * @deprecated
+	 */
+	@Deprecated
+	public void codeComplete(int offset, ICompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
+		if (requestor == null) {
+			throw new IllegalArgumentException("Completion requestor cannot be null"); //$NON-NLS-1$
+		}
+		codeComplete(offset, new org.eclipse.jdt.internal.codeassist.CompletionRequestorWrapper(requestor), owner);
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor)
+	 */
+	public void codeComplete(int offset, CompletionRequestor requestor) throws JavaModelException {
+		codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY);
+	}
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.core.runtime.IProgressMonitor)
+	 */
+	public void codeComplete(int offset, CompletionRequestor requestor, IProgressMonitor monitor) throws JavaModelException {
+		codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY, monitor);
+	}
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.jdt.core.WorkingCopyOwner)
+	 */
+	public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
+		codeComplete(offset, requestor, owner, null);
+	}
+	public abstract void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException;
+	
+	/**
+	 * @see ICodeAssist#codeSelect(int, int)
+	 */
+	public IJavaElement[] codeSelect(int offset, int length) throws JavaModelException {
+		return codeSelect(offset, length, DefaultWorkingCopyOwner.PRIMARY);
+	}
+	public abstract IJavaElement[] codeSelect(int offset, int length, WorkingCopyOwner owner) throws JavaModelException;
+	
+	/**
+	 * Returns a new element info for this element.
+	 */
+	@Override
+	protected Object createElementInfo() {
+		return new ClassFileInfo();
+	}
+	@Override
+	public boolean equals(Object o) {
+		if (!(o instanceof AbstractClassFile)) return false;
+		AbstractClassFile other = (AbstractClassFile) o;
+		return this.name.equals(other.name) && this.parent.equals(other.parent);
+	}
+	
+	/**
+	 * Finds the deepest <code>IJavaElement</code> in the hierarchy of
+	 * <code>elt</elt>'s children (including <code>elt</code> itself)
+	 * which has a source range that encloses <code>position</code>
+	 * according to <code>mapper</code>.
+	 */
+	protected IJavaElement findElement(IJavaElement elt, int position, SourceMapper mapper) {
+		SourceRange range = mapper.getSourceRange(elt);
+		if (range == null || position < range.getOffset() || range.getOffset() + range.getLength() - 1 < position) {
+			return null;
+		}
+		if (elt instanceof IParent) {
+			try {
+				IJavaElement[] children = ((IParent) elt).getChildren();
+				for (int i = 0; i < children.length; i++) {
+					IJavaElement match = findElement(children[i], position, mapper);
+					if (match != null) {
+						return match;
+					}
+				}
+			} catch (JavaModelException npe) {
+				// elt doesn't exist: return the element
+			}
+		}
+		return elt;
+	}
+	
+	public byte[] getBytes() throws JavaModelException {
+		JavaElement pkg = (JavaElement) getParent();
+		if (pkg instanceof JarPackageFragment) {
+			JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
+			try {
+				String entryName = Util.concatWith(((PackageFragment) pkg).names, getElementName(), '/');
+				entryName = root.getClassFilePath(entryName);
+				return getClassFileContent(root, entryName);
+				// BETA_JAVA9 - The below exception is not thrown in new scheme of things. Could cause issues?
+	//			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));
+			} catch (IOException ioe) {
+				throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
+			} catch (CoreException e) {
+				if (e instanceof JavaModelException) {
+					throw (JavaModelException)e;
+				} else {
+					throw new JavaModelException(e);
+				}
+			}
+		} else {
+			IFile file = (IFile) resource();
+			return Util.getResourceContentsAsByteArray(file);
+		}
+	}
+	protected byte[] getClassFileContent(JarPackageFragmentRoot root, String className) throws CoreException, IOException {
+		byte[] contents = null;
+		String rootPath = root.getPath().toOSString();
+		if (org.eclipse.jdt.internal.compiler.util.Util.isJrt(rootPath)) {
+				try {
+					contents = org.eclipse.jdt.internal.compiler.util.JRTUtil.getClassfileContent(
+							new File(rootPath),
+							className,
+							root.getElementName());
+				} catch (ClassFormatException e) {
+					e.printStackTrace();
+				}
+		} else {
+			ZipFile zip = root.getJar();
+			try {
+				ZipEntry ze = zip.getEntry(className);
+				if (ze != null) {
+					contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
+				}
+			} finally {
+				JavaModelManager.getJavaModelManager().closeZipFile(zip);
+			}
+		}
+		return contents;
+	}
+	
+	@Override
+	public IBuffer getBuffer() throws JavaModelException {
+		IStatus status = validateClassFile();
+		if (status.isOK()) {
+			return super.getBuffer();
+		} else {
+			switch (status.getCode()) {
+			case IJavaModelStatusConstants.ELEMENT_NOT_ON_CLASSPATH: // don't throw a JavaModelException to be able to open .class file outside the classpath (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=138507 )
+			case IJavaModelStatusConstants.INVALID_ELEMENT_TYPES: // don't throw a JavaModelException to be able to open .class file in proj==src case without source (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=221904 )
+				return null;
+			default:
+				throw new JavaModelException(status);
+			}
+		}
+	}
+	/**
+	 * @see IMember#getTypeRoot()
+	 */
+	public ITypeRoot getTypeRoot() {
+		return this;
+	}
+	
+	/**
+	 * A class file has a corresponding resource unless it is contained
+	 * in a jar.
+	 *
+	 * @see IJavaElement
+	 */
+	@Override
+	public IResource getCorrespondingResource() throws JavaModelException {
+		IPackageFragmentRoot root= (IPackageFragmentRoot)getParent().getParent();
+		if (root.isArchive()) {
+			return null;
+		} else {
+			return getUnderlyingResource();
+		}
+	}
+	public IJavaElement getElementAtConsideringSibling(int position) throws JavaModelException {
+		IPackageFragment fragment = (IPackageFragment)getParent();
+		PackageFragmentRoot root = (PackageFragmentRoot) fragment.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+		SourceMapper mapper = root.getSourceMapper();
+		if (mapper == null) {
+			return null;
+		} else {
+			int index = this.name.indexOf('$');
+			int prefixLength = index < 0 ? this.name.length() : index;
+	
+			IType type = null;
+			int start = -1;
+			int end = Integer.MAX_VALUE;
+			IJavaElement[] children = fragment.getChildren();
+			for (int i = 0; i < children.length; i++) {
+				if (children[i] instanceof IOrdinaryClassFile) {
+					IOrdinaryClassFile classFile = (IOrdinaryClassFile) children[i];
+					String childName = classFile.getElementName();
+		
+					int childIndex = childName.indexOf('$');
+					int childPrefixLength = childIndex < 0 ? childName.indexOf('.') : childIndex;
+					if (prefixLength == childPrefixLength && this.name.regionMatches(0, childName, 0, prefixLength)) {
+		
+						// ensure this class file's buffer is open so that source ranges are computed
+						classFile.getBuffer();
+		
+						SourceRange range = mapper.getSourceRange(classFile.getType());
+						if (range == SourceMapper.UNKNOWN_RANGE) continue;
+						int newStart = range.getOffset();
+						int newEnd = newStart + range.getLength() - 1;
+						if(newStart > start && newEnd < end
+								&& newStart <= position && newEnd >= position) {
+							type = classFile.getType();
+							start = newStart;
+							end = newEnd;
+						}
+					}
+				}
+			}
+			if(type != null) {
+				return findElement(type, position, mapper);
+			}
+			return null;
+		}
+	}
+	@Override
+	public String getElementName() {
+		return this.name + SuffixConstants.SUFFIX_STRING_class;
+	}
+	/**
+	 * @see IJavaElement
+	 */
+	public int getElementType() {
+		return CLASS_FILE;
+	}
+
+	/*
+	 * @see IJavaElement
+	 */
+	public IPath getPath() {
+		PackageFragmentRoot root = getPackageFragmentRoot();
+		if (root.isArchive()) {
+			return root.getPath();
+		} else {
+			return getParent().getPath().append(getElementName());
+		}
+	}
+	
+	/*
+	 * @see IJavaElement
+	 */
+	@Override
+	public IResource resource(PackageFragmentRoot root) {
+		return ((IContainer) ((Openable) this.parent).resource(root)).getFile(new Path(getElementName()));
+	}
+	/**
+	 * @see ISourceReference
+	 */
+	public String getSource() throws JavaModelException {
+		IBuffer buffer = getBuffer();
+		if (buffer == null) {
+			return null;
+		}
+		return buffer.getContents();
+	}
+	/**
+	 * @see ISourceReference
+	 */
+	public ISourceRange getSourceRange() throws JavaModelException {
+		IBuffer buffer = getBuffer();
+		if (buffer != null) {
+			String contents = buffer.getContents();
+			if (contents == null) return null;
+			return new SourceRange(0, contents.length());
+		} else {
+			return null;
+		}
+	}
+	/**
+	 * @see IClassFile
+	 * @deprecated
+	 */
+	@Deprecated
+	public IJavaElement getWorkingCopy(IProgressMonitor monitor, org.eclipse.jdt.core.IBufferFactory factory) throws JavaModelException {
+		return getWorkingCopy(BufferFactoryWrapper.create(factory), monitor);
+	}
+	/**
+	 * @see Openable
+	 */
+	@Override
+	protected boolean hasBuffer() {
+		return true;
+	}
+	@Override
+	public int hashCode() {
+		return Util.combineHashCodes(this.name.hashCode(), this.parent.hashCode());
+	}
+	/**
+	 * Returns true - class files are always read only.
+	 */
+	@Override
+	public boolean isReadOnly() {
+		return true;
+	}
+	private IStatus validateClassFile() {
+		IPackageFragmentRoot root = getPackageFragmentRoot();
+		try {
+			if (root.getKind() != IPackageFragmentRoot.K_BINARY)
+				return new JavaModelStatus(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES, root);
+		} catch (JavaModelException e) {
+			return e.getJavaModelStatus();
+		}
+		IJavaProject project = getJavaProject();
+		return JavaConventions.validateClassFileName(getElementName(), project.getOption(JavaCore.COMPILER_SOURCE, true), project.getOption(JavaCore.COMPILER_COMPLIANCE, true));
+	}
+	
+
+	/**
+	 * @see ICodeAssist#codeComplete(int, ICodeCompletionRequestor)
+	 * @deprecated - should use codeComplete(int, ICompletionRequestor) instead
+	 */
+	@Deprecated
+	public void codeComplete(int offset, final org.eclipse.jdt.core.ICodeCompletionRequestor requestor) throws JavaModelException {
+
+		if (requestor == null){
+			codeComplete(offset, (ICompletionRequestor)null);
+			return;
+		}
+		codeComplete(
+			offset,
+			new ICompletionRequestor(){
+				public void acceptAnonymousType(char[] superTypePackageName,char[] superTypeName, char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance) {
+					// ignore
+				}
+				public void acceptClass(char[] packageName, char[] className, char[] completionName, int modifiers, int completionStart, int completionEnd, int relevance) {
+					requestor.acceptClass(packageName, className, completionName, modifiers, completionStart, completionEnd);
+				}
+				public void acceptError(IProblem error) {
+					// was disabled in 1.0
+				}
+				public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] fieldName, char[] typePackageName, char[] typeName, char[] completionName, int modifiers, int completionStart, int completionEnd, int relevance) {
+					requestor.acceptField(declaringTypePackageName, declaringTypeName, fieldName, typePackageName, typeName, completionName, modifiers, completionStart, completionEnd);
+				}
+				public void acceptInterface(char[] packageName,char[] interfaceName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance) {
+					requestor.acceptInterface(packageName, interfaceName, completionName, modifiers, completionStart, completionEnd);
+				}
+				public void acceptKeyword(char[] keywordName,int completionStart,int completionEnd, int relevance){
+					requestor.acceptKeyword(keywordName, completionStart, completionEnd);
+				}
+				public void acceptLabel(char[] labelName,int completionStart,int completionEnd, int relevance){
+					requestor.acceptLabel(labelName, completionStart, completionEnd);
+				}
+				public void acceptLocalVariable(char[] localVarName,char[] typePackageName,char[] typeName,int modifiers,int completionStart,int completionEnd, int relevance){
+					// ignore
+				}
+				public void acceptMethod(char[] declaringTypePackageName,char[] declaringTypeName,char[] selector,char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] returnTypePackageName,char[] returnTypeName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance){
+					// skip parameter names
+					requestor.acceptMethod(declaringTypePackageName, declaringTypeName, selector, parameterPackageNames, parameterTypeNames, returnTypePackageName, returnTypeName, completionName, modifiers, completionStart, completionEnd);
+				}
+				public void acceptMethodDeclaration(char[] declaringTypePackageName,char[] declaringTypeName,char[] selector,char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] returnTypePackageName,char[] returnTypeName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance){
+					// ignore
+				}
+				public void acceptModifier(char[] modifierName,int completionStart,int completionEnd, int relevance){
+					requestor.acceptModifier(modifierName, completionStart, completionEnd);
+				}
+				public void acceptPackage(char[] packageName,char[] completionName,int completionStart,int completionEnd, int relevance){
+					requestor.acceptPackage(packageName, completionName, completionStart, completionEnd);
+				}
+				public void acceptType(char[] packageName,char[] typeName,char[] completionName,int completionStart,int completionEnd, int relevance){
+					requestor.acceptType(packageName, typeName, completionName, completionStart, completionEnd);
+				}
+				public void acceptVariableName(char[] typePackageName,char[] typeName,char[] varName,char[] completionName,int completionStart,int completionEnd, int relevance){
+					// ignore
+				}
+			});
+	}
+	
+	@Override
+	protected IStatus validateExistence(IResource underlyingResource) {
+		// check whether the class file can be opened
+		IStatus status = validateClassFile();
+		if (!status.isOK())
+			return status;
+		if (underlyingResource != null) {
+			if (!underlyingResource.isAccessible())
+				return newDoesNotExistStatus();
+			PackageFragmentRoot root;
+			if ((underlyingResource instanceof IFolder) && (root = getPackageFragmentRoot()).isArchive()) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=204652
+				return root.newDoesNotExistStatus();
+			}
+		}
+		return JavaModelStatus.VERIFIED_OK;
+	}
+	
+	public ISourceRange getNameRange() {
+		return null;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BasicCompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BasicCompilationUnit.java
index 3d8fe22..d2ed32f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BasicCompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BasicCompilationUnit.java
@@ -22,6 +22,7 @@ import org.eclipse.core.resources.IProject;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IModularClassFile;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
@@ -78,7 +79,10 @@ private void initAttributes(IJavaElement javaElement) {
 
 				switch (javaElement.getElementType()) {
 					case IJavaElement.CLASS_FILE:
-						module = ((ClassFile) javaElement).getPackageFragmentRoot().getModuleDescription();
+						if (javaElement instanceof IModularClassFile)
+							module = ((IModularClassFile) javaElement).getModule();
+						else
+							module = ((ClassFile) javaElement).getPackageFragmentRoot().getModuleDescription();
 						break;
 					case IJavaElement.COMPILATION_UNIT:
 						IFile file = (IFile) javaElement.getResource();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
index 422db16..d9582b8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
@@ -25,9 +25,7 @@ public class BinaryModule extends AbstractModule {
 	 * @see IParent#getChildren()
 	 */
 	public IJavaElement[] getChildren() throws JavaModelException {
-		ClassFile cf = (ClassFile) this.parent;
-		ClassFileInfo cfi = (ClassFileInfo) cf.getElementInfo();
-		return cfi.binaryChildren;
+		return NO_ELEMENTS;
 	}
 	@Override
 	public int getFlags() throws JavaModelException {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
index c315276..0f65b40 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -249,7 +253,7 @@ public IType getDeclaringType() {
 				return null;
 			}
 
-			return getPackageFragment().getClassFile(new String(enclosingTypeName) + SUFFIX_STRING_class).getType();
+			return getPackageFragment().getOrdinaryClassFile(new String(enclosingTypeName) + SUFFIX_STRING_class).getType();
 		} catch (JavaModelException npe) {
 			return null;
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index d54efb2..a21e069 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -18,16 +18,11 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
-import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IFolder;
 import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.IResource;
 import org.eclipse.core.resources.IWorkspaceRoot;
@@ -38,7 +33,6 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.*;
-import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
@@ -59,9 +53,8 @@ import org.eclipse.jdt.internal.core.util.Util;
  */
 
 @SuppressWarnings({"rawtypes"})
-public class ClassFile extends Openable implements IClassFile, SuffixConstants {
+public class ClassFile extends AbstractClassFile implements IOrdinaryClassFile {
 
-	protected String name;
 	protected BinaryType binaryType = null;
 
 	private IPath externalAnnotationBase;
@@ -70,27 +63,7 @@ public class ClassFile extends Openable implements IClassFile, SuffixConstants {
  * Creates a handle to a class file.
  */
 protected ClassFile(PackageFragment parent, String nameWithoutExtension) {
-	super(parent);
-	this.name = nameWithoutExtension;
-}
-
-/*
- * @see IClassFile#becomeWorkingCopy(IProblemRequestor, WorkingCopyOwner, IProgressMonitor)
- */
-public ICompilationUnit becomeWorkingCopy(IProblemRequestor problemRequestor, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException {
-	JavaModelManager manager = JavaModelManager.getJavaModelManager();
-	CompilationUnit workingCopy = new ClassFileWorkingCopy(this, owner == null ? DefaultWorkingCopyOwner.PRIMARY : owner);
-	JavaModelManager.PerWorkingCopyInfo perWorkingCopyInfo = manager.getPerWorkingCopyInfo(workingCopy, false/*don't create*/, true /*record usage*/, null/*no problem requestor needed*/);
-	if (perWorkingCopyInfo == null) {
-		// close cu and its children
-		close();
-
-		BecomeWorkingCopyOperation operation = new BecomeWorkingCopyOperation(workingCopy, problemRequestor);
-		operation.runOperation(monitor);
-
-		return workingCopy;
-	}
-	return perWorkingCopyInfo.workingCopy;
+	super(parent, nameWithoutExtension);
 }
 
 /**
@@ -117,50 +90,8 @@ protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm,
 	newElements.put(type, typeInfo);
 	// Read children
 	((ClassFileInfo) info).readBinaryChildren(this, (HashMap) newElements, typeInfo);
-	BinaryModule mod = (BinaryModule) ((ClassFileInfo) info).getModule();
-	if (mod != null) {
-		((PackageFragmentRootInfo) getPackageFragmentRoot().getElementInfo()).setModule(mod);
-	}
 	return true;
 }
-/**
- * @see ICodeAssist#codeComplete(int, ICompletionRequestor)
- * @deprecated
- */
-@Deprecated
-public void codeComplete(int offset, ICompletionRequestor requestor) throws JavaModelException {
-	codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY);
-}
-/**
- * @see ICodeAssist#codeComplete(int, ICompletionRequestor, WorkingCopyOwner)
- * @deprecated
- */
-@Deprecated
-public void codeComplete(int offset, ICompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
-	if (requestor == null) {
-		throw new IllegalArgumentException("Completion requestor cannot be null"); //$NON-NLS-1$
-	}
-	codeComplete(offset, new org.eclipse.jdt.internal.codeassist.CompletionRequestorWrapper(requestor), owner);
-}
-
-/* (non-Javadoc)
- * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor)
- */
-public void codeComplete(int offset, CompletionRequestor requestor) throws JavaModelException {
-	codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY);
-}
-/* (non-Javadoc)
- * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.core.runtime.IProgressMonitor)
- */
-public void codeComplete(int offset, CompletionRequestor requestor, IProgressMonitor monitor) throws JavaModelException {
-	codeComplete(offset, requestor, DefaultWorkingCopyOwner.PRIMARY, monitor);
-}
-/* (non-Javadoc)
- * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.jdt.core.WorkingCopyOwner)
- */
-public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
-	codeComplete(offset, requestor, owner, null);
-}
 /* (non-Javadoc)
  * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.jdt.core.WorkingCopyOwner, org.eclipse.core.runtime.IProgressMonitor)
  */
@@ -179,12 +110,6 @@ public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyO
 }
 
 /**
- * @see ICodeAssist#codeSelect(int, int)
- */
-public IJavaElement[] codeSelect(int offset, int length) throws JavaModelException {
-	return codeSelect(offset, length, DefaultWorkingCopyOwner.PRIMARY);
-}
-/**
  * @see ICodeAssist#codeSelect(int, int, WorkingCopyOwner)
  */
 public IJavaElement[] codeSelect(int offset, int length, WorkingCopyOwner owner) throws JavaModelException {
@@ -199,19 +124,6 @@ public IJavaElement[] codeSelect(int offset, int length, WorkingCopyOwner owner)
 		return new IJavaElement[] {};
 	}
 }
-/**
- * Returns a new element info for this element.
- */
-@Override
-protected Object createElementInfo() {
-	return new ClassFileInfo();
-}
-@Override
-public boolean equals(Object o) {
-	if (!(o instanceof ClassFile)) return false;
-	ClassFile other = (ClassFile) o;
-	return this.name.equals(other.name) && this.parent.equals(other.parent);
-}
 public boolean existsUsingJarTypeCache() {
 	if (getPackageFragmentRoot().isArchive()) {
 		JavaModelManager manager = JavaModelManager.getJavaModelManager();
@@ -249,32 +161,6 @@ public boolean existsUsingJarTypeCache() {
 }
 
 /**
- * Finds the deepest <code>IJavaElement</code> in the hierarchy of
- * <code>elt</elt>'s children (including <code>elt</code> itself)
- * which has a source range that encloses <code>position</code>
- * according to <code>mapper</code>.
- */
-protected IJavaElement findElement(IJavaElement elt, int position, SourceMapper mapper) {
-	SourceRange range = mapper.getSourceRange(elt);
-	if (range == null || position < range.getOffset() || range.getOffset() + range.getLength() - 1 < position) {
-		return null;
-	}
-	if (elt instanceof IParent) {
-		try {
-			IJavaElement[] children = ((IParent) elt).getChildren();
-			for (int i = 0; i < children.length; i++) {
-				IJavaElement match = findElement(children[i], position, mapper);
-				if (match != null) {
-					return match;
-				}
-			}
-		} catch (JavaModelException npe) {
-			// elt doesn't exist: return the element
-		}
-	}
-	return elt;
-}
-/**
  * @see ITypeRoot#findPrimaryType()
  */
 public IType findPrimaryType() {
@@ -324,56 +210,6 @@ public IBinaryType getBinaryTypeInfo() throws JavaModelException {
 	}
 }
 
-public byte[] getBytes() throws JavaModelException {
-	JavaElement pkg = (JavaElement) getParent();
-	if (pkg instanceof JarPackageFragment) {
-		JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
-		try {
-			String entryName = Util.concatWith(((PackageFragment) pkg).names, getElementName(), '/');
-			entryName = root.getClassFilePath(entryName);
-			return getClassFileContent(root, entryName);
-			// BETA_JAVA9 - The below exception is not thrown in new scheme of things. Could cause issues?
-//			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));
-		} catch (IOException ioe) {
-			throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
-		} catch (CoreException e) {
-			if (e instanceof JavaModelException) {
-				throw (JavaModelException)e;
-			} else {
-				throw new JavaModelException(e);
-			}
-		}
-	} else {
-		IFile file = (IFile) resource();
-		return Util.getResourceContentsAsByteArray(file);
-	}
-}
-private byte[] getClassFileContent(JarPackageFragmentRoot root, String className) throws CoreException, IOException {
-	byte[] contents = null;
-	String rootPath = root.getPath().toOSString();
-	if (org.eclipse.jdt.internal.compiler.util.Util.isJrt(rootPath)) {
-			try {
-				contents = org.eclipse.jdt.internal.compiler.util.JRTUtil.getClassfileContent(
-						new File(rootPath),
-						className,
-						root.getElementName());
-			} catch (ClassFormatException e) {
-				e.printStackTrace();
-			}
-	} else {
-		ZipFile zip = root.getJar();
-		try {
-			ZipEntry ze = zip.getEntry(className);
-			if (ze != null) {
-				contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
-			}
-		} finally {
-			JavaModelManager.getJavaModelManager().closeZipFile(zip);
-		}
-	}
-	return contents;
-}
-
 public String getName() {
 	return this.name;
 }
@@ -504,21 +340,6 @@ public void close() throws JavaModelException {
 	}
 	super.close();
 }
-@Override
-public IBuffer getBuffer() throws JavaModelException {
-	IStatus status = validateClassFile();
-	if (status.isOK()) {
-		return super.getBuffer();
-	} else {
-		switch (status.getCode()) {
-		case IJavaModelStatusConstants.ELEMENT_NOT_ON_CLASSPATH: // don't throw a JavaModelException to be able to open .class file outside the classpath (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=138507 )
-		case IJavaModelStatusConstants.INVALID_ELEMENT_TYPES: // don't throw a JavaModelException to be able to open .class file in proj==src case without source (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=221904 )
-			return null;
-		default:
-			throw new JavaModelException(status);
-		}
-	}
-}
 /**
  * @see IMember
  */
@@ -527,27 +348,6 @@ public IClassFile getClassFile() {
 	return this;
 }
 /**
- * @see IMember#getTypeRoot()
- */
-public ITypeRoot getTypeRoot() {
-	return this;
-}
-/**
- * A class file has a corresponding resource unless it is contained
- * in a jar.
- *
- * @see IJavaElement
- */
-@Override
-public IResource getCorrespondingResource() throws JavaModelException {
-	IPackageFragmentRoot root= (IPackageFragmentRoot)getParent().getParent();
-	if (root.isArchive()) {
-		return null;
-	} else {
-		return getUnderlyingResource();
-	}
-}
-/**
  * @see IClassFile
  */
 public IJavaElement getElementAt(int position) throws JavaModelException {
@@ -567,59 +367,7 @@ public IJavaElement getElementAt(int position) throws JavaModelException {
 		return findElement(type, position, mapper);
 	}
 }
-public IJavaElement getElementAtConsideringSibling(int position) throws JavaModelException {
-	IPackageFragment fragment = (IPackageFragment)getParent();
-	PackageFragmentRoot root = (PackageFragmentRoot) fragment.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
-	SourceMapper mapper = root.getSourceMapper();
-	if (mapper == null) {
-		return null;
-	} else {
-		int index = this.name.indexOf('$');
-		int prefixLength = index < 0 ? this.name.length() : index;
-
-		IType type = null;
-		int start = -1;
-		int end = Integer.MAX_VALUE;
-		IJavaElement[] children = fragment.getChildren();
-		for (int i = 0; i < children.length; i++) {
-			String childName = children[i].getElementName();
-
-			int childIndex = childName.indexOf('$');
-			int childPrefixLength = childIndex < 0 ? childName.indexOf('.') : childIndex;
-			if (prefixLength == childPrefixLength && this.name.regionMatches(0, childName, 0, prefixLength)) {
-				IClassFile classFile = (IClassFile) children[i];
 
-				// ensure this class file's buffer is open so that source ranges are computed
-				classFile.getBuffer();
-
-				SourceRange range = mapper.getSourceRange(classFile.getType());
-				if (range == SourceMapper.UNKNOWN_RANGE) continue;
-				int newStart = range.getOffset();
-				int newEnd = newStart + range.getLength() - 1;
-				if(newStart > start && newEnd < end
-						&& newStart <= position && newEnd >= position) {
-					type = classFile.getType();
-					start = newStart;
-					end = newEnd;
-				}
-			}
-		}
-		if(type != null) {
-			return findElement(type, position, mapper);
-		}
-		return null;
-	}
-}
-@Override
-public String getElementName() {
-	return this.name + SuffixConstants.SUFFIX_STRING_class;
-}
-/**
- * @see IJavaElement
- */
-public int getElementType() {
-	return CLASS_FILE;
-}
 /*
  * @see JavaElement
  */
@@ -631,11 +379,6 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			String typeName = memento.nextToken();
 			JavaElement type = new BinaryType(this, typeName);
 			return type.getHandleFromMemento(memento, owner);
-		case JEM_MODULE:
-			if (!memento.hasMoreTokens()) return this;
-			String modName = memento.nextToken();
-			JavaElement mod = new BinaryModule(this, modName);
-			return mod.getHandleFromMemento(memento, owner);
 	}
 	return null;
 }
@@ -647,47 +390,6 @@ protected char getHandleMementoDelimiter() {
 	return JavaElement.JEM_CLASSFILE;
 }
 /*
- * @see IJavaElement
- */
-public IPath getPath() {
-	PackageFragmentRoot root = getPackageFragmentRoot();
-	if (root.isArchive()) {
-		return root.getPath();
-	} else {
-		return getParent().getPath().append(getElementName());
-	}
-}
-/*
- * @see IJavaElement
- */
-@Override
-public IResource resource(PackageFragmentRoot root) {
-	return ((IContainer) ((Openable) this.parent).resource(root)).getFile(new Path(getElementName()));
-}
-/**
- * @see ISourceReference
- */
-public String getSource() throws JavaModelException {
-	IBuffer buffer = getBuffer();
-	if (buffer == null) {
-		return null;
-	}
-	return buffer.getContents();
-}
-/**
- * @see ISourceReference
- */
-public ISourceRange getSourceRange() throws JavaModelException {
-	IBuffer buffer = getBuffer();
-	if (buffer != null) {
-		String contents = buffer.getContents();
-		if (contents == null) return null;
-		return new SourceRange(0, contents.length());
-	} else {
-		return null;
-	}
-}
-/*
  * Returns the name of the toplevel type of this class file.
  */
 public String getTopLevelTypeName() {
@@ -731,25 +433,6 @@ public ICompilationUnit getWorkingCopy(WorkingCopyOwner owner, IProgressMonitor
 }
 /**
  * @see IClassFile
- * @deprecated
- */
-@Deprecated
-public IJavaElement getWorkingCopy(IProgressMonitor monitor, org.eclipse.jdt.core.IBufferFactory factory) throws JavaModelException {
-	return getWorkingCopy(BufferFactoryWrapper.create(factory), monitor);
-}
-/**
- * @see Openable
- */
-@Override
-protected boolean hasBuffer() {
-	return true;
-}
-@Override
-public int hashCode() {
-	return Util.combineHashCodes(this.name.hashCode(), this.parent.hashCode());
-}
-/**
- * @see IClassFile
  */
 public boolean isClass() throws JavaModelException {
 	return getType().isClass();
@@ -761,24 +444,6 @@ public boolean isInterface() throws JavaModelException {
 	return getType().isInterface();
 }
 /**
- * Returns true - class files are always read only.
- */
-@Override
-public boolean isReadOnly() {
-	return true;
-}
-private IStatus validateClassFile() {
-	IPackageFragmentRoot root = getPackageFragmentRoot();
-	try {
-		if (root.getKind() != IPackageFragmentRoot.K_BINARY)
-			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES, root);
-	} catch (JavaModelException e) {
-		return e.getJavaModelStatus();
-	}
-	IJavaProject project = getJavaProject();
-	return JavaConventions.validateClassFileName(getElementName(), project.getOption(JavaCore.COMPILER_SOURCE, true), project.getOption(JavaCore.COMPILER_COMPLIANCE, true));
-}
-/**
  * Opens and returns buffer on the source code associated with this class file.
  * Maps the source code to the children elements of this class file.
  * If no source code is associated with this class file,
@@ -922,89 +587,4 @@ public static char[] translatedName(char[] name) {
 	}
 	return className;
 }
-
-/**
- * @see ICodeAssist#codeComplete(int, ICodeCompletionRequestor)
- * @deprecated - should use codeComplete(int, ICompletionRequestor) instead
- */
-@Deprecated
-public void codeComplete(int offset, final org.eclipse.jdt.core.ICodeCompletionRequestor requestor) throws JavaModelException {
-
-	if (requestor == null){
-		codeComplete(offset, (ICompletionRequestor)null);
-		return;
-	}
-	codeComplete(
-		offset,
-		new ICompletionRequestor(){
-			public void acceptAnonymousType(char[] superTypePackageName,char[] superTypeName, char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance) {
-				// ignore
-			}
-			public void acceptClass(char[] packageName, char[] className, char[] completionName, int modifiers, int completionStart, int completionEnd, int relevance) {
-				requestor.acceptClass(packageName, className, completionName, modifiers, completionStart, completionEnd);
-			}
-			public void acceptError(IProblem error) {
-				// was disabled in 1.0
-			}
-			public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] fieldName, char[] typePackageName, char[] typeName, char[] completionName, int modifiers, int completionStart, int completionEnd, int relevance) {
-				requestor.acceptField(declaringTypePackageName, declaringTypeName, fieldName, typePackageName, typeName, completionName, modifiers, completionStart, completionEnd);
-			}
-			public void acceptInterface(char[] packageName,char[] interfaceName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance) {
-				requestor.acceptInterface(packageName, interfaceName, completionName, modifiers, completionStart, completionEnd);
-			}
-			public void acceptKeyword(char[] keywordName,int completionStart,int completionEnd, int relevance){
-				requestor.acceptKeyword(keywordName, completionStart, completionEnd);
-			}
-			public void acceptLabel(char[] labelName,int completionStart,int completionEnd, int relevance){
-				requestor.acceptLabel(labelName, completionStart, completionEnd);
-			}
-			public void acceptLocalVariable(char[] localVarName,char[] typePackageName,char[] typeName,int modifiers,int completionStart,int completionEnd, int relevance){
-				// ignore
-			}
-			public void acceptMethod(char[] declaringTypePackageName,char[] declaringTypeName,char[] selector,char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] returnTypePackageName,char[] returnTypeName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance){
-				// skip parameter names
-				requestor.acceptMethod(declaringTypePackageName, declaringTypeName, selector, parameterPackageNames, parameterTypeNames, returnTypePackageName, returnTypeName, completionName, modifiers, completionStart, completionEnd);
-			}
-			public void acceptMethodDeclaration(char[] declaringTypePackageName,char[] declaringTypeName,char[] selector,char[][] parameterPackageNames,char[][] parameterTypeNames,char[][] parameterNames,char[] returnTypePackageName,char[] returnTypeName,char[] completionName,int modifiers,int completionStart,int completionEnd, int relevance){
-				// ignore
-			}
-			public void acceptModifier(char[] modifierName,int completionStart,int completionEnd, int relevance){
-				requestor.acceptModifier(modifierName, completionStart, completionEnd);
-			}
-			public void acceptPackage(char[] packageName,char[] completionName,int completionStart,int completionEnd, int relevance){
-				requestor.acceptPackage(packageName, completionName, completionStart, completionEnd);
-			}
-			public void acceptType(char[] packageName,char[] typeName,char[] completionName,int completionStart,int completionEnd, int relevance){
-				requestor.acceptType(packageName, typeName, completionName, completionStart, completionEnd);
-			}
-			public void acceptVariableName(char[] typePackageName,char[] typeName,char[] varName,char[] completionName,int completionStart,int completionEnd, int relevance){
-				// ignore
-			}
-		});
-}
-
-@Override
-protected IStatus validateExistence(IResource underlyingResource) {
-	// check whether the class file can be opened
-	IStatus status = validateClassFile();
-	if (!status.isOK())
-		return status;
-	if (underlyingResource != null) {
-		if (!underlyingResource.isAccessible())
-			return newDoesNotExistStatus();
-		PackageFragmentRoot root;
-		if ((underlyingResource instanceof IFolder) && (root = getPackageFragmentRoot()).isArchive()) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=204652
-			return root.newDoesNotExistStatus();
-		}
-	}
-	return JavaModelStatus.VERIFIED_OK;
-}
-public ISourceRange getNameRange() {
-	return null;
-}
-
-@Override
-public IModuleDescription getModule() throws JavaModelException {
-	return ((ClassFileInfo)getElementInfo()).getModule();
-}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
index bd58fa5..20ecf0c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
@@ -19,7 +19,6 @@ import java.util.HashMap;
 
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryField;
@@ -255,17 +254,6 @@ private void generateInnerClassHandles(IType type, IBinaryType typeInfo, ArrayLi
 		}
 	}
 }
-private void generateModuleInfos(ClassFile classFile, IBinaryType info, HashMap newElements, ArrayList childrenHandles) {
-	// TODO: The following needs fix once we can get ModuleDeclaration from IndexBinaryType
-	IBinaryModule modDecl = (info instanceof ClassFileReader) ? ((ClassFileReader) info).getModuleDeclaration() : null;
-	if (modDecl != null) {
-		char[] modName = modDecl.name();
-		BinaryModule handle = new BinaryModule(classFile, new String(modName));
-		ModuleDescriptionInfo moduleInfo = ModuleDescriptionInfo.createModule(modDecl);
-		setModule(handle);
-		newElements.put(handle, moduleInfo);
-	}
-}
 /**
  * Creates the handles and infos for the methods of the given binary type.
  * Adds new handles to the given vector.
@@ -425,13 +413,6 @@ private void generateTypeParameterInfos(BinaryMember parent, char[] signature, H
 	}
 }
 /**
- * Returns true iff the <code>readBinaryChildren</code> has already
- * been called.
- */
-boolean hasReadBinaryChildren() {
-	return this.binaryChildren != null;
-}
-/**
  * Creates the handles for <code>BinaryMember</code>s defined in this
  * <code>ClassFile</code> and adds them to the
  * <code>JavaModelManager</code>'s cache.
@@ -446,9 +427,6 @@ protected void readBinaryChildren(ClassFile classFile, HashMap newElements, IBin
 		generateFieldInfos(type, typeInfo, newElements, childrenHandles);
 		generateMethodInfos(type, typeInfo, newElements, childrenHandles, typeParameterHandles);
 		generateInnerClassHandles(type, typeInfo, childrenHandles); // Note inner class are separate openables that are not opened here: no need to pass in newElements
-		if (Flags.isModule(typeInfo.getModifiers())) {
-			generateModuleInfos(classFile, typeInfo, newElements, childrenHandles);
-		}
 	}
 
 	this.binaryChildren = new JavaElement[childrenHandles.size()];
@@ -461,6 +439,21 @@ protected void readBinaryChildren(ClassFile classFile, HashMap newElements, IBin
 		typeParameterHandles.toArray(this.typeParameters);
 	}
 }
+protected BinaryModule readBinaryModule(AbstractClassFile classFile, HashMap newElements, IBinaryModule modDecl) {
+	this.binaryChildren = JavaElement.NO_ELEMENTS;
+	this.typeParameters = TypeParameter.NO_TYPE_PARAMETERS;
+	if (modDecl != null) {//may not be a valid class file
+		// TODO: The following needs fix once we can get ModuleDeclaration from IndexBinaryType
+		char[] modName = modDecl.name();
+		BinaryModule handle = new BinaryModule(classFile, new String(modName));
+		ModuleDescriptionInfo moduleInfo = ModuleDescriptionInfo.createModule(modDecl);
+		setModule(handle);
+		newElements.put(handle, moduleInfo);
+		this.binaryChildren = new JavaElement[] { handle };
+		return handle;
+	}
+	return null;
+}
 /**
  * Removes the binary children handles and remove their infos from
  * the <code>JavaModelManager</code>'s cache.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java
index 4c085ce..bdbae6e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for Bug 337935 - Test failures when run as an IDE (org.eclipse.sdk.ide)
@@ -23,6 +27,7 @@ import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
 import org.eclipse.jdt.core.util.IClassFileReader;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.util.Disassembler;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -31,12 +36,18 @@ import org.eclipse.jdt.internal.core.util.Util;
  */
 public class ClassFileWorkingCopy extends CompilationUnit {
 
-	public ClassFile classFile;
+	public AbstractClassFile classFile;
 
-public ClassFileWorkingCopy(ClassFile classFile, WorkingCopyOwner owner) {
-	super((PackageFragment) classFile.getParent(), ((BinaryType) classFile.getType()).getSourceFileName(null/*no info available*/), owner);
+public ClassFileWorkingCopy(AbstractClassFile classFile, WorkingCopyOwner owner) {
+	super((PackageFragment) classFile.getParent(), sourceFileName(classFile), owner);
 	this.classFile = classFile;
 }
+private static String sourceFileName(AbstractClassFile classFile) {
+	if (classFile instanceof ModularClassFile)
+		return TypeConstants.MODULE_INFO_FILE_NAME_STRING;
+	else
+		return ((BinaryType) ((ClassFile) classFile).getType()).getSourceFileName(null/*no info available*/);
+}
 
 public void commitWorkingCopy(boolean force, IProgressMonitor monitor) throws JavaModelException {
 	throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES, this));
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
index 5b57b7f..b96754e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
@@ -824,7 +824,10 @@ public class DeltaProcessor {
 							// create class file handle
 							// fileName validation has been done in elementType(IResourceDelta, int, boolean)
 							String fileName = path.lastSegment();
-							element = pkgFragment.getClassFile(fileName);
+							if (TypeConstants.MODULE_INFO_CLASS_NAME_STRING.equals(fileName))
+								element = pkgFragment.getModularClassFile();
+							else
+								element = pkgFragment.getClassFile(fileName);
 						}
 					}
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
index 9066ec0..1a8a185 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -25,6 +29,7 @@ import org.eclipse.jdt.core.IJarEntryResource;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaModelStatusConstants;
 import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -71,7 +76,10 @@ private IJavaElement[] computeChildren(ArrayList namesWithoutExtension) {
 	IJavaElement[] children = new IJavaElement[size];
 	for (int i = 0; i < size; i++) {
 		String nameWithoutExtension = (String) namesWithoutExtension.get(i);
-		children[i] = new ClassFile(this, nameWithoutExtension);
+		if (TypeConstants.MODULE_INFO_NAME_STRING.equals(nameWithoutExtension))
+			children[i] = new ModularClassFile(this);
+		else
+			children[i] = new ClassFile(this, nameWithoutExtension);
 	}
 	return children;
 }
@@ -165,7 +173,7 @@ protected Object createElementInfo() {
 /**
  * @see org.eclipse.jdt.core.IPackageFragment
  */
-public IClassFile[] getClassFiles() throws JavaModelException {
+public IClassFile[] getAllClassFiles() throws JavaModelException {
 	ArrayList list = getChildrenOfType(CLASS_FILE);
 	IClassFile[] array= new IClassFile[list.size()];
 	list.toArray(array);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
index 9630b03..e379001 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -86,6 +90,7 @@ public abstract class JavaElement extends PlatformObject implements IJavaElement
 	public static final char JEM_INITIALIZER = '|';
 	public static final char JEM_COMPILATIONUNIT = '{';
 	public static final char JEM_CLASSFILE = '(';
+	public static final char JEM_MODULAR_CLASSFILE = '\'';
 	public static final char JEM_TYPE = '[';
 	public static final char JEM_PACKAGEDECLARATION = '%';
 	public static final char JEM_IMPORTDECLARATION = '#';
@@ -202,6 +207,7 @@ public abstract class JavaElement extends PlatformObject implements IJavaElement
 				case JEM_INITIALIZER:
 				case JEM_COMPILATIONUNIT:
 				case JEM_CLASSFILE:
+				case JEM_MODULAR_CLASSFILE:
 				case JEM_TYPE:
 				case JEM_PACKAGEDECLARATION:
 				case JEM_IMPORTDECLARATION:
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 757abde..be3e851 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -128,6 +128,7 @@ import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
 import org.eclipse.jdt.internal.compiler.util.JRTUtil;
 import org.eclipse.jdt.internal.compiler.util.ObjectVector;
@@ -1069,6 +1070,9 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 			PackageFragmentRoot root = (PackageFragmentRoot) project.getPackageFragmentRoot(file.getParent());
 			pkg = root.getPackageFragment(CharOperation.NO_STRINGS);
 		}
+		String fileName = file.getName();
+		if (TypeConstants.MODULE_INFO_CLASS_NAME_STRING.equals(fileName))
+			return pkg.getModularClassFile();
 		return pkg.getClassFile(file.getName());
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
new file mode 100644
index 0000000..afd7690
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
@@ -0,0 +1,262 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
+import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.core.util.MementoTokenizer;
+import org.eclipse.jdt.internal.core.util.Util;
+
+/**
+ * A handle to a modular class file.
+ */
+public class ModularClassFile extends AbstractClassFile implements IModularClassFile {
+
+	private BinaryModule binaryModule;
+
+	protected ModularClassFile(PackageFragment parent) {
+		super(parent, TypeConstants.MODULE_INFO_NAME_STRING);
+	}
+
+	/**
+	 * Creates the single child element for this class file adding the resulting 
+	 * new handle (of type {@link IBinaryModule}) and info object to the newElements table.
+	 * Returns true if successful, or false if an error is encountered parsing the class file.
+	 *
+	 * @see Openable
+	 * @see Signature
+	 */
+	@Override
+	protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException {
+		IBinaryModule moduleInfo = getBinaryModuleInfo();
+		if (moduleInfo == null) {
+			// The structure of a class file is unknown if a class file format errors occurred
+			//during the creation of the diet class file representative of this ClassFile.
+			info.setChildren(JavaElement.NO_ELEMENTS);
+			return false;
+		}
+		
+		// Read the module	
+		BinaryModule module = ((ClassFileInfo) info).readBinaryModule(this, (HashMap<?,?>) newElements, moduleInfo);
+		if (module != null) {
+			this.binaryModule = module;
+			info.setChildren(new IJavaElement[] {module});
+			((PackageFragmentRootInfo) getPackageFragmentRoot().getElementInfo()).setModule(module);
+		}
+		return true;
+	}
+
+	@Override
+	public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException {
+		String source = getSource();
+		if (source != null) {
+			BasicCompilationUnit cu =
+				new BasicCompilationUnit(
+					getSource().toCharArray(),
+					null,
+					TypeConstants.MODULE_INFO_FILE_NAME_STRING,
+					getJavaProject()); // use project to retrieve corresponding .java IFile
+			codeComplete(cu, cu, offset, requestor, owner, null/*extended context isn't computed*/, monitor);
+		}
+	}
+
+	@Override
+	public IJavaElement[] codeSelect(int offset, int length, WorkingCopyOwner owner) throws JavaModelException {
+		IBuffer buffer = getBuffer();
+		char[] contents;
+		if (buffer != null && (contents = buffer.getCharacters()) != null) {
+			BasicCompilationUnit cu = new BasicCompilationUnit(contents, null, TypeConstants.MODULE_INFO_FILE_NAME_STRING);
+			return super.codeSelect(cu, offset, length, owner);
+		} else {
+			// has no associated source
+			return new IJavaElement[] {};
+		}
+	}
+
+	@Override
+	public IType findPrimaryType() {
+		return null;
+	}
+	
+	@Override
+	public boolean isClass() throws JavaModelException {
+		return false;
+	}
+	
+	@Override
+	public boolean isInterface() throws JavaModelException {
+		return false;
+	}
+	
+	@Override
+	public IType getType() {
+		throw new UnsupportedOperationException("IClassFile#getType() cannot be used on an IModularClassFile");
+	}
+
+	/**
+	 * Returns the <code>ClassFileReader</code>specific for this IClassFile, based
+	 * on its underlying resource, or <code>null</code> if unable to create
+	 * the diet class file.
+	 * There are two cases to consider:<ul>
+	 * <li>a class file corresponding to an IFile resource</li>
+	 * <li>a class file corresponding to a zip entry in a JAR</li>
+	 * </ul>
+	 *
+	 * @exception JavaModelException when the IFile resource or JAR is not available
+	 * or when this class file is not present in the JAR
+	 */
+	public IBinaryModule getBinaryModuleInfo() throws JavaModelException {
+		try {
+			IBinaryModule info = getJarBinaryModuleInfo();
+			if (info == null) {
+				throw newNotPresentException();
+			}
+			return info;
+		} catch (ClassFormatException cfe) {
+			//the structure remains unknown
+			if (JavaCore.getPlugin().isDebugging()) {
+				cfe.printStackTrace(System.err);
+			}
+			return null;
+		} catch (IOException ioe) {
+			throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
+		} catch (CoreException e) {
+			if (e instanceof JavaModelException) {
+				throw (JavaModelException)e;
+			} else {
+				throw new JavaModelException(e);
+			}
+		}
+	}
+	
+	private IBinaryModule getJarBinaryModuleInfo() throws CoreException, IOException, ClassFormatException {
+//		BinaryModuleDescriptor descriptor = BinaryModuleFactory.createDescriptor(this);
+//	
+//		if (descriptor == null) {
+//			return null;
+//		}
+		IBinaryModule result = null;
+		IPackageFragmentRoot root = getPackageFragmentRoot();
+		if (getPackageFragmentRoot() instanceof JarPackageFragmentRoot) {
+			if (root instanceof JrtPackageFragmentRoot || this.name.equals(IModule.MODULE_INFO)) {
+				PackageFragment pkg = (PackageFragment) getParent();
+				JarPackageFragmentRoot jarRoot = (JarPackageFragmentRoot) getPackageFragmentRoot();
+				String entryName = jarRoot.getClassFilePath(Util.concatWith(pkg.names, getElementName(), '/'));
+				byte[] contents = getClassFileContent(jarRoot, entryName);
+				if (contents != null) {
+					String fileName;
+					String rootPath = root.getPath().toOSString();
+					if (org.eclipse.jdt.internal.compiler.util.Util.isJrt(rootPath)) {
+						fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + 
+								root.getElementName() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
+					} else {
+						fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
+					}
+					ClassFileReader classFileReader = new ClassFileReader(contents, fileName.toCharArray(), false);
+					return classFileReader.getModuleDeclaration();
+				}
+			} else {
+//				result = BinaryModuleFactory.readModule(descriptor, null);
+			}
+		} else {
+//			result = BinaryModuleFactory.readModule(descriptor, null);
+		}
+			
+//		if (result == null) {
+//			return null;
+//		}
+
+		return result;
+	}
+
+	/**
+	 * @see ITypeRoot
+	 */
+	public IJavaElement getElementAt(int position) throws JavaModelException {
+		IJavaElement parentElement = getParent();
+		while (parentElement.getElementType() != IJavaElement.PACKAGE_FRAGMENT_ROOT) {
+			parentElement = parentElement.getParent();
+		}
+		PackageFragmentRoot root = (PackageFragmentRoot) parentElement;
+		SourceMapper mapper = root.getSourceMapper();
+		if (mapper == null) {
+			return null;
+		} else {
+			// ensure this class file's buffer is open so that source ranges are computed
+			getBuffer();
+
+			IModuleDescription module = getModule();
+			return findElement(module, position, mapper);
+		}
+	}
+	@Override
+	public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner owner) {
+		switch (token.charAt(0)) {
+			case JEM_MODULE:
+				if (!memento.hasMoreTokens()) return this;
+				String modName = memento.nextToken();
+				JavaElement mod = new BinaryModule(this, modName);
+				return mod.getHandleFromMemento(memento, owner);
+		}
+		return null;
+	}
+	/**
+	 * @see JavaElement#getHandleMemento()
+	 */
+	@Override
+	protected char getHandleMementoDelimiter() {
+		return JavaElement.JEM_MODULAR_CLASSFILE;
+	}
+	@Override
+	protected void escapeMementoName(StringBuffer buffer, String mementoName) {
+		// nop, name is irrelevant
+	}
+	@Override
+	public ICompilationUnit getWorkingCopy(WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException {
+		CompilationUnit workingCopy = new ClassFileWorkingCopy(this, owner == null ? DefaultWorkingCopyOwner.PRIMARY : owner);
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		JavaModelManager.PerWorkingCopyInfo perWorkingCopyInfo =
+			manager.getPerWorkingCopyInfo(workingCopy, false/*don't create*/, true/*record usage*/, null/*not used since don't create*/);
+		if (perWorkingCopyInfo != null) {
+			return perWorkingCopyInfo.getWorkingCopy(); // return existing handle instead of the one created above
+		}
+		BecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, null);
+		op.runOperation(monitor);
+		System.out.println("<<getWorkingCopy: "+workingCopy);
+		return workingCopy;
+	}
+
+	@Override
+	public IModuleDescription getModule() throws JavaModelException {
+		if (this.binaryModule == null) {
+			openWhenClosed(createElementInfo(), false, null);
+			if (this.binaryModule == null)
+				throw newNotPresentException();
+		}
+		return this.binaryModule;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleDescriptionInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleDescriptionInfo.java
index 97d5da0..dd3652b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleDescriptionInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleDescriptionInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
+ * Copyright (c) 2016, 2017 IBM Corporation.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -111,6 +111,7 @@ public class ModuleDescriptionInfo extends AnnotatableInfo implements IModule {
 	
 	public static ModuleDescriptionInfo createModule(IModule module) {
 		ModuleDescriptionInfo mod = new ModuleDescriptionInfo();
+		mod.children = JavaElement.NO_ELEMENTS;
 		mod.name = module.name();
 		mod.isOpen = module.isOpen();
 		if (module.requires().length > 0) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 0131fe2..6477b46 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -33,6 +33,7 @@ import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IOpenable;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.ISourceRange;
@@ -1638,11 +1639,13 @@ public class NameLookup implements SuffixConstants {
 					// MatchName will never have the extension ".class" and the elementName always will.
 					String elementName = classFile.getElementName();
 					if (elementName.regionMatches(true /*ignore case*/, 0, name, 0, matchLength)) {
-						IType type = ((ClassFile) classFile).getType();
-						String typeName = type.getElementName();
-						if (typeName.length() > 0 && !Character.isDigit(typeName.charAt(0))) { //not an anonymous type
-							if (nameMatches(unqualifiedName, type, true/*partial match*/) && acceptType(type, acceptFlags, false/*not a source type*/))
-								requestor.acceptType(type);
+						if (classFile instanceof IOrdinaryClassFile) {
+							IType type = ((IOrdinaryClassFile) classFile).getType();
+							String typeName = type.getElementName();
+							if (typeName.length() > 0 && !Character.isDigit(typeName.charAt(0))) { //not an anonymous type
+								if (nameMatches(unqualifiedName, type, true/*partial match*/) && acceptType(type, acceptFlags, false/*not a source type*/))
+									requestor.acceptType(type);
+							}
 						}
 					}
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java
index 5973987..7b83e68 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NamedMember.java
@@ -20,6 +20,7 @@ import org.eclipse.jdt.core.IField;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IMember;
 import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IModularClassFile;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IType;
@@ -213,6 +214,8 @@ public abstract class NamedMember extends Member {
 				}
 				return this.name;
 			case IJavaElement.CLASS_FILE:
+				if (this.parent instanceof IModularClassFile)
+					return null;
 				String classFileName = this.parent.getElementName();
 				String typeName;
 				if (classFileName.indexOf('$') == -1) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java
index 9ccad47..e542fb4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -13,6 +17,7 @@ package org.eclipse.jdt.internal.core;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.Map;
 
 import org.eclipse.core.resources.IContainer;
@@ -28,6 +33,8 @@ import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IModularClassFile;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IParent;
@@ -35,6 +42,7 @@ import org.eclipse.jdt.core.ISourceManipulation;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.JavaModelManager.PerProjectInfo;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
@@ -50,6 +58,7 @@ public class PackageFragment extends Openable implements IPackageFragment, Suffi
 	 * Constant empty list of class files
 	 */
 	protected static final IClassFile[] NO_CLASSFILES = new IClassFile[] {};
+	protected static final IOrdinaryClassFile[] NO_ORDINARY_CLASSFILES = new IOrdinaryClassFile[] {};
 	/**
 	 * Constant empty list of compilation units
 	 */
@@ -177,13 +186,17 @@ public boolean exists() {
 	return super.exists() && !Util.isExcluded(this) && isValidPackageName();
 }
 /**
- * @see IPackageFragment#getClassFile(String)
- * @exception IllegalArgumentException if the name does not end with ".class"
+ * @see IPackageFragment#getOrdinaryClassFile(String)
+ * @exception IllegalArgumentException if the name does not end with ".class" or if the name is "module-info.class".
  */
-public IClassFile getClassFile(String classFileName) {
+@Override
+public IOrdinaryClassFile getOrdinaryClassFile(String classFileName) {
 	if (!org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(classFileName)) {
 		throw new IllegalArgumentException(Messages.bind(Messages.element_invalidClassFileName, classFileName));
 	}
+	if (TypeConstants.MODULE_INFO_CLASS_NAME_STRING.equals(classFileName)) {
+		throw new IllegalArgumentException(Messages.element_moduleInfoNotSupported);
+	}
 	// don't hold on the .class file extension to save memory
 	// also make sure to not use substring as the resulting String may hold on the underlying char[] which might be much bigger than necessary
 	int length = classFileName.length() - 6;
@@ -192,13 +205,52 @@ public IClassFile getClassFile(String classFileName) {
 	return new ClassFile(this, new String(nameWithoutExtension));
 }
 /**
- * Returns a the collection of class files in this - a folder package fragment which has a root
+ * @see IPackageFragment#getClassFile(String)
+ * @exception IllegalArgumentException if the name does not end with ".class".
+ */
+@Override
+public IClassFile getClassFile(String classFileName) {
+	if (TypeConstants.MODULE_INFO_CLASS_NAME_STRING.equals(classFileName))
+		return getModularClassFile();
+	return getOrdinaryClassFile(classFileName);
+}
+@Override
+public IModularClassFile getModularClassFile() {
+	// don't hold on the .class file extension to save memory
+	// also make sure to not use substring as the resulting String may hold on the underlying char[] which might be much bigger than necessary
+	return new ModularClassFile(this);
+}
+
+/**
+ * Returns a collection of ordinary class files in this - a folder package fragment which has a root
  * that has its kind set to <code>IPackageFragmentRoot.K_Source</code> does not
  * recognize class files.
  *
- * @see IPackageFragment#getClassFiles()
+ * @see IPackageFragment#getOrdinaryClassFiles()
  */
-public IClassFile[] getClassFiles() throws JavaModelException {
+@Override
+public IOrdinaryClassFile[] getOrdinaryClassFiles() throws JavaModelException {
+	if (getKind() == IPackageFragmentRoot.K_SOURCE) {
+		return NO_ORDINARY_CLASSFILES;
+	}
+
+	ArrayList list = getChildrenOfType(CLASS_FILE);
+	for (Iterator iterator = list.iterator(); iterator.hasNext();) {
+		if (iterator.next() instanceof ModularClassFile)
+			iterator.remove();
+	}
+	IOrdinaryClassFile[] array= new IOrdinaryClassFile[list.size()];
+	list.toArray(array);
+	return array;
+}
+/**
+ * Returns a collection of all class files in this - a folder package fragment which has a root
+ * that has its kind set to <code>IPackageFragmentRoot.K_Source</code> does not
+ * recognize class files.
+ *
+ * @see IPackageFragment#getAllClassFiles()
+ */
+public IClassFile[] getAllClassFiles() throws JavaModelException {
 	if (getKind() == IPackageFragmentRoot.K_SOURCE) {
 		return NO_CLASSFILES;
 	}
@@ -208,6 +260,13 @@ public IClassFile[] getClassFiles() throws JavaModelException {
 	list.toArray(array);
 	return array;
 }
+
+@Deprecated
+@Override
+public IClassFile[] getClassFiles() throws JavaModelException {
+	return getOrdinaryClassFiles();
+}
+
 /**
  * @see IPackageFragment#getCompilationUnit(String)
  * @exception IllegalArgumentException if the name does not end with ".java"
@@ -270,7 +329,10 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 		case JEM_CLASSFILE:
 			if (!memento.hasMoreTokens()) return this;
 			String classFileName = memento.nextToken();
-			JavaElement classFile = (JavaElement)getClassFile(classFileName);
+			JavaElement classFile = (JavaElement) getClassFile(classFileName);
+			return classFile.getHandleFromMemento(memento, owner);
+		case JEM_MODULAR_CLASSFILE:
+			classFile = (JavaElement) getModularClassFile();
 			return classFile.getHandleFromMemento(memento, owner);
 		case JEM_COMPILATIONUNIT:
 			if (!memento.hasMoreTokens()) return this;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 1fd3d23..ec3ead3 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -450,7 +450,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			if (memento.hasMoreTokens()) {
 				token = memento.nextToken();
 				char firstChar = token.charAt(0);
-				if (firstChar == JEM_CLASSFILE || firstChar == JEM_COMPILATIONUNIT || firstChar == JEM_COUNT) {
+				if (firstChar == JEM_CLASSFILE || firstChar == JEM_MODULAR_CLASSFILE || firstChar == JEM_COMPILATIONUNIT || firstChar == JEM_COUNT) {
 					pkgName = CharOperation.NO_STRINGS;
 				} else {
 					pkgName = Util.splitOn('.', token, 0, token.length());
@@ -870,8 +870,8 @@ public IModuleDescription getModuleDescription() {
 							return info.getModule();
 					}
 				} else {
-					IClassFile classFile = ((IPackageFragment)pkgs[j]).getClassFile(TypeConstants.MODULE_INFO_CLASS_NAME_STRING);
-					if (classFile instanceof ClassFile && classFile.exists()) {
+					IModularClassFile classFile = ((IPackageFragment)pkgs[j]).getModularClassFile();
+					if (classFile.exists()) {
 						return classFile.getModule();
 					}
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
index 3a4305f..5ed1cd6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -16,10 +20,10 @@ import java.util.Iterator;
 import java.util.Map;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IType;
@@ -183,7 +187,7 @@ private void createTypeHierarchyBasedOnRegion(HashMap allOpenablesInRegion, IPro
 						openables.add(cus[i]);
 					}
 				} else {
-					IClassFile[] classFiles = packFrag.getClassFiles();
+					IOrdinaryClassFile[] classFiles = packFrag.getOrdinaryClassFiles();
 					for (int i = 0, length = classFiles.length; i < length; i++) {
 						openables.add(classFiles[i]);
 					}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
index eff8598..7704f45 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2011 IBM Corporation and others.
+ * Copyright (c) 2004, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -22,6 +26,7 @@ public class MementoTokenizer {
 	public static final String INITIALIZER = Character.toString(JavaElement.JEM_INITIALIZER);
 	public static final String COMPILATIONUNIT = Character.toString(JavaElement.JEM_COMPILATIONUNIT);
 	public static final String CLASSFILE = Character.toString(JavaElement.JEM_CLASSFILE);
+	public static final String MODULAR_CLASSFILE = Character.toString(JavaElement.JEM_MODULAR_CLASSFILE);
 	public static final String TYPE = Character.toString(JavaElement.JEM_TYPE);
 	public static final String MODULE = Character.toString(JavaElement.JEM_MODULE);
 	public static final String PACKAGEDECLARATION = Character.toString(JavaElement.JEM_PACKAGEDECLARATION);
@@ -91,6 +96,8 @@ public class MementoTokenizer {
 				return COMPILATIONUNIT;
 			case JavaElement.JEM_CLASSFILE:
 				return CLASSFILE;
+			case JavaElement.JEM_MODULAR_CLASSFILE:
+				return MODULAR_CLASSFILE;
 			case JavaElement.JEM_TYPE:
 				return TYPE;
 			case JavaElement.JEM_MODULE:
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
index 85d065e..f1dd556 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -40,6 +44,7 @@ public final class Messages extends NLS {
 	public static String element_nullName;
 	public static String element_nullType;
 	public static String element_illegalParent;
+	public static String element_moduleInfoNotSupported;
 	public static String javamodel_initialization;
 	public static String javamodel_initializing_delta_state;
 	public static String javamodel_building_after_upgrade;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
index 4b938a8..64fc3f5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
@@ -36,6 +36,7 @@ element_invalidResourceForProject = Illegal argument - must be one of IProject,
 element_nullName = Name cannot be null
 element_nullType = Type cannot be null
 element_illegalParent = Illegal parent argument
+element_moduleInfoNotSupported=module-info.class is not supported by method IPackageFragment.getClassFile(String).
 
 ### java model operations
 operation_needElements = Operation requires one or more elements
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
index ffefdd5..ccf9b3a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
@@ -2294,6 +2294,8 @@ private static char[][] enclosingTypeNames(IType type) {
 	IJavaElement parent = type.getParent();
 	switch (parent.getElementType()) {
 		case IJavaElement.CLASS_FILE:
+			if (parent instanceof IModularClassFile)
+				return null;
 			// For a binary type, the parent is not the enclosing type, but the declaring type is.
 			// (see bug 20532  Declaration of member binary type not found)
 			IType declaringType = type.getDeclaringType();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
index c177a93..f9c1e99 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 215139
@@ -12,10 +16,10 @@
 package org.eclipse.jdt.internal.core.search;
 
 import org.eclipse.core.runtime.Path;
-import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IType;
@@ -66,22 +70,19 @@ public IType getType(int modifiers, char[] packageName, char[] simpleTypeName, c
 		if (this.handleFactory != null) {
 			Openable openable = this.handleFactory.createOpenable(path, this.scope);
 			if (openable == null) return type;
-			switch (openable.getElementType()) {
-				case IJavaElement.COMPILATION_UNIT:
-					ICompilationUnit cu = (ICompilationUnit) openable;
-					if (enclosingTypeNames != null && enclosingTypeNames.length > 0) {
-						type = cu.getType(new String(enclosingTypeNames[0]));
-						for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
-							type = type.getType(new String(enclosingTypeNames[j]));
-						}
-						type = type.getType(new String(simpleTypeName));
-					} else {
-						type = cu.getType(new String(simpleTypeName));
+			if (openable instanceof ICompilationUnit) {
+				ICompilationUnit cu = (ICompilationUnit) openable;
+				if (enclosingTypeNames != null && enclosingTypeNames.length > 0) {
+					type = cu.getType(new String(enclosingTypeNames[0]));
+					for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
+						type = type.getType(new String(enclosingTypeNames[j]));
 					}
-					break;
-				case IJavaElement.CLASS_FILE:
-					type = ((IClassFile)openable).getType();
-					break;
+					type = type.getType(new String(simpleTypeName));
+				} else {
+					type = cu.getType(new String(simpleTypeName));
+				}
+			} else if (openable instanceof IOrdinaryClassFile) {
+				type = ((IOrdinaryClassFile)openable).getType();
 			}
 		} else {
 			int separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);
@@ -139,7 +140,7 @@ private IType createTypeFromJar(String resourcePath, int separatorIndex) throws
 		} 
 		this.packageHandles.put(pkgName, pkgFragment);
 	}
-	return pkgFragment.getClassFile(simpleNames[length]).getType();
+	return pkgFragment.getOrdinaryClassFile(simpleNames[length]).getType();
 }
 private IType createTypeFromPath(String resourcePath, String simpleTypeName, char[][] enclosingTypeNames) throws JavaModelException {
 	// path to a file in a directory
@@ -184,7 +185,7 @@ private IType createTypeFromPath(String resourcePath, String simpleTypeName, cha
 		}
 		return type;
 	} else if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(simpleName)){
-		IClassFile classFile= pkgFragment.getClassFile(simpleName);
+		IOrdinaryClassFile classFile= pkgFragment.getOrdinaryClassFile(simpleName);
 		return classFile.getType();
 	}
 	return null;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 57ee5e3..63ae87c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -41,6 +41,7 @@ import org.eclipse.jdt.core.IMember;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IOpenable;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.ISourceRange;
@@ -780,7 +781,7 @@ protected IType createTypeHandle(String simpleTypeName) {
 
 	// type name may be null for anonymous (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=164791)
 	String classFileName = simpleTypeName.length() == 0 ? binaryTypeQualifiedName : simpleTypeName;
-	IClassFile classFile = binaryType.getPackageFragment().getClassFile(classFileName + SuffixConstants.SUFFIX_STRING_class);
+	IOrdinaryClassFile classFile = binaryType.getPackageFragment().getOrdinaryClassFile(classFileName + SuffixConstants.SUFFIX_STRING_class);
 	return classFile.getType();
 }
 protected boolean encloses(IJavaElement element) {
@@ -2891,7 +2892,7 @@ protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int
 			// do nothing
 		}
 	}
-	if (moduleDesc == null) // should not happen - safety net.
+	if (moduleDesc == null) // could theoretically happen if openable is ICompilationUnit, but logically having a module should prevent this from happening
 		return;
 	if (accuracy > -1) { // report module declaration
 		SearchMatch match = this.patternLocator.newDeclarationMatch(module, moduleDesc, module.binding, accuracy, module.moduleName.length, this);
@@ -3001,7 +3002,7 @@ protected void reportMatching(TypeDeclaration type, IJavaElement parent, int acc
 				if ((type.bits & ASTNode.IsAnonymousType) != 0) {
 					if (fileName != null) {
 						if (fileName.endsWith("jar") || fileName.endsWith(SuffixConstants.SUFFIX_STRING_class)) { //$NON-NLS-1$
-							IClassFile classFile= binaryType.getPackageFragment().getClassFile(binaryType.getTypeQualifiedName() + 
+							IOrdinaryClassFile classFile= binaryType.getPackageFragment().getOrdinaryClassFile(binaryType.getTypeQualifiedName() + 
 									"$" + Integer.toString(occurrenceCount) + SuffixConstants.SUFFIX_STRING_class);//$NON-NLS-1$
 							anonType =  classFile.getType();
 						}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index 7503852..a81ab49 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -68,14 +68,25 @@ public boolean equals(Object obj) {
 public char[] getContents() {
 	char[] contents = (this.source == NO_SOURCE_FILE) ? null : this.source;
 	if (this.source == null) {
-		if (this.openable instanceof ClassFile) {
+		if (this.openable instanceof AbstractClassFile) {
 			String fileName = getSourceFileName();
 			if (fileName == NO_SOURCE_FILE_NAME) return CharOperation.NO_CHAR;
 
 			SourceMapper sourceMapper = this.openable.getSourceMapper();
 			if (sourceMapper != null) {
-				IType type = ((ClassFile) this.openable).getType();
-				contents = sourceMapper.findSource(type, fileName);
+				if (this.openable instanceof ClassFile) {
+					IType type = ((ClassFile) this.openable).getType();
+					contents = sourceMapper.findSource(type, fileName);
+				} else if (this.openable instanceof ModularClassFile) {
+					// FIXME(SHMOD): not working
+					try {
+						IModuleDescription module = ((ModularClassFile) this.openable).getModule();
+						contents = sourceMapper.findSource(module.getElementName()); // FIXME(SHMOD)
+					} catch (JavaModelException e) {
+						// TODO Auto-generated catch block
+						e.printStackTrace();
+					}
+				}
 			}
 		} else {
 			contents = this.document.getCharContents();
@@ -124,6 +135,11 @@ private char[] getQualifiedName() {
 		String simpleName = index==-1 ? fileName : fileName.substring(0, index);
 		PackageFragment pkg = (PackageFragment) this.openable.getParent();
 		return Util.concatWith(pkg.names, simpleName, '.').toCharArray();
+	} else if (this.openable instanceof ModularClassFile) {
+		// FIXME(SHMOD): not useful
+		String simpleName = TypeConstants.MODULE_INFO_NAME_STRING;
+		PackageFragment pkg = (PackageFragment) this.openable.getParent();
+		return Util.concatWith(pkg.names, simpleName, '.').toCharArray();
 	}
 	return null;
 }
@@ -139,11 +155,16 @@ private String getSourceFileName() {
 
 	this.sourceFileName = NO_SOURCE_FILE_NAME;
 	if (this.openable.getSourceMapper() != null) {
-		BinaryType type = (BinaryType) ((ClassFile) this.openable).getType();
-		IBinaryType reader = MatchLocator.classFileReader(type);
-		if (reader != null) {
-			String fileName = type.sourceFileName(reader);
-			this.sourceFileName = fileName == null ? NO_SOURCE_FILE_NAME : fileName;
+		if (this.openable instanceof ClassFile) {
+			BinaryType type = (BinaryType) ((ClassFile) this.openable).getType();
+			IBinaryType reader = MatchLocator.classFileReader(type);
+			if (reader != null) {
+				String fileName = type.sourceFileName(reader);
+				this.sourceFileName = fileName == null ? NO_SOURCE_FILE_NAME : fileName;
+			}
+		} else if (this.openable instanceof ModularClassFile) {
+			// FIXME(SHMOD): premature
+			this.sourceFileName = TypeConstants.MODULE_INFO_FILE_NAME_STRING;
 		}
 	}
 	return this.sourceFileName;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
index 776d91f..791032f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -206,8 +210,8 @@ public char[][][] collect() throws JavaModelException {
 				CompilationUnitDeclaration parsedUnit = buildBindings(unit, true /*only top level and member types are visible to the focus type*/);
 				if (parsedUnit != null)
 					parsedUnit.traverse(new TypeDeclarationVisitor(), parsedUnit.scope);
-			} else if (openable instanceof IClassFile) {
-				IClassFile classFile = (IClassFile) openable;
+			} else if (openable instanceof IOrdinaryClassFile) {
+				IOrdinaryClassFile classFile = (IOrdinaryClassFile) openable;
 				BinaryTypeBinding binding = this.locator.cacheBinaryType(classFile.getType(), null);
 				if (matches(binding))
 					collectSuperTypeNames(binding, binding.compoundName);
commit e5360e04e6ea5683cbe34b165b0e694733f4efde
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Aug 28 21:55:00 2017 +0200

    Bug 520651: [9] module-info.class has a type as its child
    
    - fix reading from class folder (not jar)
    
    Change-Id: I069ddcafb0032cf4eb47899d426711756389e27d

8	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
27	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
10	12	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
67	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleDescriptor.java
163	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleFactory.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 5ef43d29..482c668 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -34,6 +34,7 @@ import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.core.tests.junit.extension.TestCase;
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.core.ClasspathEntry;
 import org.eclipse.jdt.internal.core.JavaCorePreferenceInitializer;
@@ -1708,12 +1709,18 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 					}
 					if (lib.indexOf(File.separatorChar) == -1 && lib.charAt(0) != '/' && lib.equals(lib.toUpperCase())) { // all upper case is a var
 						char[][] vars = CharOperation.splitOn(',', lib.toCharArray());
+						IClasspathAttribute[] extraAttributes = ClasspathEntry.NO_EXTRA_ATTRIBUTES;
+						if (CompilerOptions.versionToJdkLevel(compliance) >= ClassFileConstants.JDK9 && lib.startsWith("JCL")) {
+							extraAttributes = new IClasspathAttribute[] {
+								JavaCore.newClasspathAttribute(IClasspathAttribute.AUTOMATIC_MODULE, "true")
+							};
+						}
 						entries[sourceLength+i] = JavaCore.newVariableEntry(
 							new Path(new String(vars[0])),
 							vars.length > 1 ? new Path(new String(vars[1])) : null,
 							vars.length > 2 ? new Path(new String(vars[2])) : null,
 							ClasspathEntry.getAccessRules(accessibleFiles, nonAccessibleFiles), // ClasspathEntry.NO_ACCESS_RULES,
-							ClasspathEntry.NO_EXTRA_ATTRIBUTES,
+							extraAttributes,
 							false);
 					} else if (lib.startsWith("org.eclipse.jdt.core.tests.model.")) { // container
 						entries[sourceLength+i] = JavaCore.newContainerEntry(
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
index 8f60254..125d6eb 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
@@ -17,6 +17,7 @@ package org.eclipse.jdt.core.tests.model;
 import java.io.IOException;
 import java.util.regex.Pattern;
 
+import org.eclipse.core.resources.IncrementalProjectBuilder;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
@@ -894,6 +895,32 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			deleteProject("Java9Elements");
 		}
 	}
+	public void test_module_in_classfolder_bug520651() throws Exception {
+		try {
+			IJavaProject libPrj= createJavaProject("Java9Lib", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+			createFile("Java9Lib/src/module-info.java", "module java9.lib {}\n");
+			libPrj.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			
+			IJavaProject project = createJavaProject("Java9Elements",
+					new String[] {"src"},
+					new String[] {"JCL19_LIB", "/Java9Lib/bin"},
+					"bin", "9");
+			project.open(null);
+			IModuleDescription moduleDescription = null;
+			for (IPackageFragmentRoot root : project.getAllPackageFragmentRoots()) {
+				if (root.getPath().toString().equals("/Java9Lib/bin")) {
+					moduleDescription = root.getModuleDescription();
+					assertEquals("module name", "java9.lib", moduleDescription.getElementName());
+					return;
+				}
+			}
+			fail("class folder not found");
+		}
+		finally {
+			deleteProject("Java9Lib");
+			deleteProject("Java9Elements");
+		}
+	}
 	public void testFindModule1() throws CoreException, IOException {
 		try {
 			createJavaProject("mod.zero", new String[]{"src"}, null, "bin", JavaCore.VERSION_9);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
index f213710..167624f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModularClassFile.java
@@ -28,6 +28,8 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
 import org.eclipse.jdt.internal.compiler.env.IDependent;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryModuleDescriptor;
+import org.eclipse.jdt.internal.core.nd.java.model.BinaryModuleFactory;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -118,7 +120,7 @@ public class ModularClassFile extends AbstractClassFile implements IModularClass
 	}
 
 	/**
-	 * Returns the <code>ClassFileReader</code>specific for this IClassFile, based
+	 * Returns the <code>IBinaryModule</code> specific for this IClassFile, based
 	 * on its underlying resource, or <code>null</code> if unable to create
 	 * the diet class file.
 	 * There are two cases to consider:<ul>
@@ -154,11 +156,11 @@ public class ModularClassFile extends AbstractClassFile implements IModularClass
 	}
 	
 	private IBinaryModule getJarBinaryModuleInfo() throws CoreException, IOException, ClassFormatException {
-//		BinaryModuleDescriptor descriptor = BinaryModuleFactory.createDescriptor(this);
-//	
-//		if (descriptor == null) {
-//			return null;
-//		}
+		BinaryModuleDescriptor descriptor = BinaryModuleFactory.createDescriptor(this);
+	
+		if (descriptor == null) {
+			return null;
+		}
 		IBinaryModule result = null;
 		IPackageFragmentRoot root = getPackageFragmentRoot();
 		if (getPackageFragmentRoot() instanceof JarPackageFragmentRoot) {
@@ -180,15 +182,11 @@ public class ModularClassFile extends AbstractClassFile implements IModularClass
 					return classFileReader.getModuleDeclaration();
 				}
 			} else {
-//				result = BinaryModuleFactory.readModule(descriptor, null);
+				result = BinaryModuleFactory.readModule(descriptor, null);
 			}
 		} else {
-//			result = BinaryModuleFactory.readModule(descriptor, null);
+			result = BinaryModuleFactory.readModule(descriptor, null);
 		}
-			
-//		if (result == null) {
-//			return null;
-//		}
 
 		return result;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleDescriptor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleDescriptor.java
new file mode 100644
index 0000000..b196f84
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleDescriptor.java
@@ -0,0 +1,67 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
+
+/**
+ * Holds a lightweight identifier for an IBinaryModule, with sufficient information to either read it from
+ * disk or read it from the index.
+ */
+public class BinaryModuleDescriptor {
+	public final char[] indexPath;
+	public final char[] moduleName; // TODO: not sure if this will be needed once wired to the index?
+	public final char[] location;
+	public final char[] workspacePath;
+
+	/**
+	 * Constructs a new descriptor
+	 * 
+	 * @param location
+	 *            location where the archive (.jar or .class) can be found in the local filesystem
+	 * @param moduleName
+	 *            name of the module
+	 * @param workspacePath
+	 *            location where the archive (.jar or class) can be found in the workspace. If it is not in the
+	 *            workspace, this is the path where it can be found on the local filesystem.
+	 * @param indexPath
+	 *            index path for the new module (workspace-or-local path to jar optionally followed by a | and a relative
+	 *            path within the .jar)
+	 */
+	public BinaryModuleDescriptor(char[] location, char[] moduleName, char[] workspacePath, char[] indexPath) {
+		super();
+		this.location = location;
+		this.moduleName = moduleName;
+		this.indexPath = indexPath;
+		this.workspacePath = workspacePath;
+	}
+
+	public boolean isInJarFile() {
+		return CharArrayUtils.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, this.indexPath) != -1;
+	}
+
+	/**
+	 * For debugging purposes only.
+	 */
+	@Override
+	public String toString() {
+		StringBuilder builder = new StringBuilder();
+		builder.append(this.workspacePath);
+		builder.append('|');
+		builder.append(this.moduleName);
+		return builder.toString();
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleFactory.java
new file mode 100644
index 0000000..2db18e2
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryModuleFactory.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Copyright (c) 2017 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java.model;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IResourceStatus;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
+import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
+import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.ModularClassFile;
+import org.eclipse.jdt.internal.core.PackageFragmentRoot;
+import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
+
+/**
+ * <strong>FIXME:</strong> this class is a stub as of now, it does not support modules in the new index.
+ */
+public class BinaryModuleFactory {
+
+	public static BinaryModuleDescriptor createDescriptor(ModularClassFile modularClassFile) {
+		return createDescriptor(modularClassFile.getPackageFragmentRoot(), modularClassFile);
+	}
+
+	/**
+	 * Returns a descriptor for the given class within the given package fragment, or null if the fragment doesn't have
+	 * a location on the filesystem.
+	 */
+	private static BinaryModuleDescriptor createDescriptor(PackageFragmentRoot root, ModularClassFile classFile) {
+		IPath location = JavaIndex.getLocationForElement(root);
+		if (location == null) {
+			return null;
+		}
+		String entryName = TypeConstants.MODULE_INFO_CLASS_NAME_STRING;
+		IPath workspacePath = root.getPath();
+		String indexPath;
+
+		if (root instanceof JarPackageFragmentRoot) {
+			entryName = ((JarPackageFragmentRoot) root).getClassFilePath(entryName);
+			indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
+			// see additional comments in BinaryTypeFactor.createDescriptor()
+		} else {
+			location = location.append(entryName);
+			indexPath = workspacePath.append(entryName).toString();
+			workspacePath = classFile.resource().getFullPath();
+		}
+
+		return new BinaryModuleDescriptor(location.toString().toCharArray(), null, // TODO: module name not know at this point
+				workspacePath.toString().toCharArray(), indexPath.toCharArray());
+	}
+
+	/**
+	 * Reads the given binary module. If the module can be found in the index with a fingerprint that exactly matches
+	 * the file on disk, the type is read from the index. Otherwise the type is read from disk. Returns null if
+	 * no such type exists.
+	 * <strong>caveat</strong> modules are not yet supported in the index.
+	 * 
+	 * @throws ClassFormatException 
+	 */
+	public static IBinaryModule readModule(BinaryModuleDescriptor descriptor, IProgressMonitor monitor) throws JavaModelException, ClassFormatException {
+// FIXME: support module in the new index
+//		if (JavaIndex.isEnabled()) {
+//			try {
+//				return readFromIndex(JavaIndex.getIndex(), descriptor, monitor);
+//			} catch (NotInIndexException e) {
+//				// fall back to reading the zip file, below
+//			}
+//		}
+		return rawReadModule(descriptor, true);
+	}
+	
+	public static IBinaryModule rawReadModule(BinaryModuleDescriptor descriptor, boolean fullyInitialize) throws JavaModelException, ClassFormatException {
+		try {
+			return rawReadModuleTestForExists(descriptor, fullyInitialize, true);
+		} catch (FileNotFoundException e) {
+			throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+		}
+	}
+
+	/**
+	 * Read the class file from disk, circumventing the index's cache. This should only be used by callers
+	 * that need to read information from the class file which aren't present in the index (such as method bodies).
+	 * 
+	 * @return the newly-created IBinaryModule or null if the given class file does not exist.
+	 * @throws ClassFormatException if the class file existed but was corrupt
+	 * @throws JavaModelException if unable to read the class file due to a transient failure
+	 * @throws FileNotFoundException if the file does not exist
+	 */
+	public static IBinaryModule rawReadModuleTestForExists(BinaryModuleDescriptor descriptor, boolean fullyInitialize,
+			boolean useInvalidArchiveCache) throws JavaModelException, ClassFormatException, FileNotFoundException {
+		if (descriptor == null) {
+			return null;
+		}
+		if (descriptor.isInJarFile()) {
+			ZipFile zip = null;
+			try {
+				zip = JavaModelManager.getJavaModelManager().getZipFile(new Path(new String(descriptor.workspacePath)),
+						useInvalidArchiveCache);
+				String entryName = TypeConstants.MODULE_INFO_CLASS_NAME_STRING;
+				ZipEntry ze = zip.getEntry(entryName);
+				if (ze != null) {
+					byte contents[];
+					try {
+						contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
+					} catch (IOException ioe) {
+						throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
+					}
+					ClassFileReader classFileReader = new ClassFileReader(contents, descriptor.indexPath, fullyInitialize);
+					return classFileReader.getModuleDeclaration();
+				}
+			} catch (CoreException e) {
+				throw new JavaModelException(e);
+			} finally {
+				JavaModelManager.getJavaModelManager().closeZipFile(zip);
+			}
+		} else {
+			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(new String(descriptor.workspacePath)));
+			byte[] contents;
+			try (InputStream stream = file.getContents(true)) {
+				contents = org.eclipse.jdt.internal.compiler.util.Util.getInputStreamAsByteArray(stream, -1);
+			} catch (CoreException e) {
+				IStatus status = e.getStatus();
+				if (status.getCode() == IResourceStatus.RESOURCE_NOT_FOUND) {
+					throw new FileNotFoundException();
+				}
+				throw new JavaModelException(e);
+			} catch (IOException e) {
+				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+			}
+			ClassFileReader classFileReader = new ClassFileReader(contents, file.getFullPath().toString().toCharArray(), fullyInitialize);
+			return classFileReader.getModuleDeclaration();
+		}
+		return null;
+	}
+}
