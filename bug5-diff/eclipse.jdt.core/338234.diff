commit 96a09d96e56ab454cb92b7163871c6f3413e482e
Author: Ayushman Jain <ajain>
Date:   Fri Mar 4 12:41:22 2011 +0000

    HEAD- Fixed bug 338234: [compiler] Missing warning for uninitialized variable in dead code

115	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
34	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
9	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
28	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
18	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
index d67fb46..32b50af 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2010 IBM Corporation and others.
+ * Copyright (c) 2005, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -2246,6 +2246,120 @@ public void test071() {
 		"Dead code\n" + 
 		"----------\n");
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234
+// Warn uninitialized variable in deadcode if deadcode has been inferred
+// by null analysis
+public void testBug338234a() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public static void main(String[] args) {\n" + 
+			"        int i;\n" + 
+			"        String str = null;\n" + 
+			"        if (str != null)\n" + 
+			"            i++;    \n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 6)\n" + 
+		"	i++;    \n" + 
+		"	^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	i++;    \n" + 
+		"	^\n" + 
+		"The local variable i may not have been initialized\n" + 
+		"----------\n");
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234
+// Don't warn uninitialized variable in deadcode if deadcode has not been inferred
+// by null analysis
+public void testBug338234b() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public static void main(String[] args) {\n" + 
+			"        int i;\n" + 
+			"        l: {\n" +
+			"			if(false)\n" +
+			"				break l;\n" + 
+			"        	return;\n" +
+			"		 }\n" + 
+			"        i++;    \n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"");
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234
+// Warn uninitialized field in deadcode if deadcode has been inferred
+// by null analysis
+public void testBug338234c() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public final int field1;\n" +
+			"    {\n" + 
+			"        int i;\n" + 
+			"        String str = null;\n" +
+			"		 if(str != null)\n" +
+			"			i = field1;\n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X {\n" + 
+		"	             ^\n" + 
+		"The blank final field field1 may not have been initialized\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 7)\n" + 
+		"	i = field1;\n" + 
+		"	^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	i = field1;\n" + 
+		"	    ^^^^^^\n" + 
+		"The blank final field field1 may not have been initialized\n" + 
+		"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234
+// Warn uninitialized field in deadcode if deadcode has been inferred
+// by null analysis
+public void testBug338234d() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(boolean b) {\n" +
+			"        int i;\n" +
+			"		 String str = null;\n" + 
+			"        if(b){\n" +
+			"		 	if(str == null)\n" +
+			"				return;\n" +
+			"		 } else {\n" +
+			"			i = 2;\n" +
+			"		 }\n" +
+			"		 i++;\n" + 
+			"    }\n" + 
+			"}\n"
+		}, 
+		"----------\n" + 
+		"1. ERROR in X.java (at line 11)\n" + 
+		"	i++;\n" + 
+		"	^\n" + 
+		"The local variable i may not have been initialized\n" + 
+		"----------\n");
+}
 public static Class testClass() {
 	return FlowAnalysisTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 8a22758..4959990 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -14204,4 +14204,38 @@ public void testBug338303() {
 		},
 		"");
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234
+public void testBug338234() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"   static int foo() {\n" + 
+			"        Object o = null;\n" +
+			"		 int i = 0;\n" + 
+			"        label: {\n" + 
+			"            if (o == null)\n" + 
+			"                break label;\n" +
+			"			 i++;" + 
+			"        }\n" + 
+			"         if (i != 0) {\n" + 
+			"            System.out.println(i);\n" + 
+			"        }\n" + 
+			"        return 0;\n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	if (o == null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The variable o can only be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	i++;        }\n" + 
+		"	^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 7d28512..456bd19 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -51,7 +51,9 @@ Eclipse SDK 3.7M6 - %date% - 3.7.0 M6
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=336428">336428</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=338234">338234</a>
+[compiler] Missing warning for uninitialized variable in dead code
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=336428">336428</a>
 [compiler][null] bogus warning &quot;redundant null check&quot; in condition of do {} while() loop
 
 <a name="v_B39"></a>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
index f1804a5..ce3da94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -57,7 +57,7 @@ public class AND_AND_Expression extends BinaryExpression {
 		if (isLeftOptimizedFalse) {
 			if ((rightInfo.reachMode() & FlowInfo.UNREACHABLE) == 0) {
 				currentScope.problemReporter().fakeReachable(this.right);
-				rightInfo.setReachMode(FlowInfo.UNREACHABLE);
+				rightInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 		}
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
index 12d989b..329c997 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
@@ -56,7 +56,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	UnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
 	FlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();
 	if (isOptimizedTrueAssertion) {
-		assertInfo.setReachMode(FlowInfo.UNREACHABLE);
+		assertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 	}
 
 	if (this.exceptionArgument != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 03d4e4a..08b4e0f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -55,7 +55,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		FlowInfo trueFlowInfo = flowInfo.initsWhenTrue().copy();
 		if (isConditionOptimizedFalse) {
 			if ((mode & FlowInfo.UNREACHABLE) == 0) {
-				trueFlowInfo.setReachMode(FlowInfo.UNREACHABLE);
+				trueFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
 				this.valueIfTrue.complainIfUnreachable(trueFlowInfo, currentScope, initialComplaintLevel);
@@ -68,7 +68,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		FlowInfo falseFlowInfo = flowInfo.initsWhenFalse().copy();
 		if (isConditionOptimizedTrue) {
 			if ((mode & FlowInfo.UNREACHABLE) == 0) {
-				falseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);
+				falseFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
 				this.valueIfFalse.complainIfUnreachable(falseFlowInfo, currentScope, initialComplaintLevel);
@@ -98,16 +98,16 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			UnconditionalFlowInfo trueInfoWhenFalse = trueFlowInfo.initsWhenFalse().unconditionalInits();
 			UnconditionalFlowInfo falseInfoWhenFalse = falseFlowInfo.initsWhenFalse().unconditionalInits();
 			if (isValueIfTrueOptimizedFalse) {
-				trueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE);				
+				trueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);				
 			}
 			if (isValueIfFalseOptimizedFalse) {
-				falseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE);	
+				falseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);	
 			}
 			if (isValueIfTrueOptimizedTrue) {
-				trueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE);	
+				trueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);	
 			}
 			if (isValueIfFalseOptimizedTrue) {
-				falseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE);	
+				falseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);	
 			}
 			mergedInfo =
 				FlowInfo.conditional(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index c792841..b9b8e34 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -135,7 +135,7 @@ public class ForStatement extends Statement {
 				} else {
 					actionInfo = initsWhenTrue.unconditionalCopy();
 					if (isConditionOptimizedFalse){
-						actionInfo.setReachMode(FlowInfo.UNREACHABLE);
+						actionInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 					}
 				}
 			if (this.action.complainIfUnreachable(actionInfo, this.scope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index ab37456..2341d1d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -67,11 +67,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	// process the THEN part
 	FlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();
 	if (isConditionOptimizedFalse) {
-		thenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);
+		thenFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 	}
 	FlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse().copy();
 	if (isConditionOptimizedTrue) {
-		elseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);
+		elseFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 	}
 	if (((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) && 
 			((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index c041fee..4b3fca4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -59,7 +59,7 @@ public class OR_OR_Expression extends BinaryExpression {
 		if (isLeftOptimizedTrue){
 			if ((rightInfo.reachMode() & FlowInfo.UNREACHABLE) == 0) {
 				currentScope.problemReporter().fakeReachable(this.right);
-				rightInfo.setReachMode(FlowInfo.UNREACHABLE);
+				rightInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 		}
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index ab49caf..5dc426a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -150,7 +150,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				ifTrue: [catchInits addPotentialInitializationsFrom: tryInits]."
 				*/
 				if (this.tryBlock.statements == null) {
-					catchInfo.setReachMode(FlowInfo.UNREACHABLE);
+					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
@@ -259,7 +259,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				ifTrue: [catchInits addPotentialInitializationsFrom: tryInits]."
 				*/
 				if (this.tryBlock.statements == null) {
-					catchInfo.setReachMode(FlowInfo.UNREACHABLE);
+					catchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 				catchInfo =
 					this.catchBlocks[i].analyseCode(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index ecbade2..371b65a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -646,7 +646,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 				// branch, since the previous initializer already got the blame.
 				if (staticFieldInfo == FlowInfo.DEAD_END) {
 					this.staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
-					staticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
+					staticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 			} else {
 				if ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)
@@ -662,7 +662,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 				// branch, since the previous initializer already got the blame.
 				if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
 					this.initializerScope.problemReporter().initializerMustCompleteNormally(field);
-					nonStaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
+					nonStaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 144e64e..2e0acb9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -82,7 +82,7 @@ public class WhileStatement extends Statement {
 			} else {
 				FlowInfo mergedInfo = flowInfo.copy().addInitializationsFrom(condInfo.initsWhenFalse());
 				if (isConditionOptimizedTrue){
-					mergedInfo.setReachMode(FlowInfo.UNREACHABLE);
+					mergedInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 				this.mergedInitStateIndex =
 					currentScope.methodScope().recordInitializationStates(mergedInfo);
@@ -104,7 +104,7 @@ public class WhileStatement extends Statement {
 			} else {
 				actionInfo = condInfo.initsWhenTrue().copy();
 				if (isConditionOptimizedFalse){
-					actionInfo.setReachMode(FlowInfo.UNREACHABLE);
+					actionInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 			}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
index c6c3348..c137b42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -195,7 +195,7 @@ public FlowInfo setReachMode(int reachMode) {
 		this.tagBits &= ~UNREACHABLE;
 	}
 	else {
-		this.tagBits |= UNREACHABLE;
+		this.tagBits |= reachMode;
 	}
 	this.initsWhenTrue.setReachMode(reachMode);
 	this.initsWhenFalse.setReachMode(reachMode);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 37bf18f..0590583 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -229,14 +229,14 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 									scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 								}
 								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 								}
 							} else if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
 								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
 								}
 								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 								}
 							}
 							return;
@@ -252,7 +252,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 										scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 									}
 									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									}
 									return;
 								case FlowContext.IN_COMPARISON_NON_NULL:
@@ -264,7 +264,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 										scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
 									}
 									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									}
 									return;
 								case FlowContext.IN_ASSIGNMENT:
@@ -314,14 +314,14 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 									scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 								}
 								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 								}
 							} else {
 								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
 								}
 								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 								}
 							}
 							return;
@@ -342,7 +342,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 										scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 									}
 									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									}
 									return;
 								case FlowContext.IN_COMPARISON_NON_NULL:
@@ -354,7 +354,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 										scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
 									}
 									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									}
 									return;
 								case FlowContext.IN_ASSIGNMENT:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 369d24e..645f19e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -578,14 +578,14 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 						scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				} else {
 					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				}
 				return;
@@ -609,7 +609,7 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 							scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 						}
 						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						}
 						return;
 					case FlowContext.IN_COMPARISON_NON_NULL:
@@ -621,7 +621,7 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 							scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
 						}
 						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						}
 						return;
 					case FlowContext.IN_ASSIGNMENT:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
index 6899c41..5c995f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -22,9 +22,24 @@ public abstract class FlowInfo {
 
 	public int tagBits; // REACHABLE by default
 	public final static int REACHABLE = 0;
-	public final static int UNREACHABLE = 1;
-	public final static int NULL_FLAG_MASK = 2;
-
+	/* unreachable code 
+	 * eg. while (true);
+	 *     i++;  --> unreachable code 
+	 */
+	public final static int UNREACHABLE_OR_DEAD = 1;
+	/* unreachable code as inferred by null analysis
+	 * eg. str = null;
+	 *     if (str != null) {
+	 *        // dead code
+	 *     }
+	 */
+	public final static int UNREACHABLE_BY_NULLANALYSIS = 2;
+	/*
+	 * code unreachable in any fashion
+	 */
+	public final static int UNREACHABLE = UNREACHABLE_OR_DEAD | UNREACHABLE_BY_NULLANALYSIS;
+	public final static int NULL_FLAG_MASK = 4;
+	
 	public final static int UNKNOWN = 1;
 	public final static int NULL = 2;
 	public final static int NON_NULL = 4;
@@ -355,7 +370,7 @@ public static UnconditionalFlowInfo mergedOptimizedBranches(
 	UnconditionalFlowInfo mergedInfo;
 	if (isOptimizedTrue){
 		if (initsWhenTrue == FlowInfo.DEAD_END && allowFakeDeadBranch) {
-			mergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE).
+			mergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).
 				unconditionalInits();
 		}
 		else {
@@ -367,7 +382,7 @@ public static UnconditionalFlowInfo mergedOptimizedBranches(
 	}
 	else if (isOptimizedFalse) {
 		if (initsWhenFalse == FlowInfo.DEAD_END && allowFakeDeadBranch) {
-			mergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE).
+			mergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).
 				unconditionalInits();
 		}
 		else {
@@ -394,7 +409,7 @@ public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse(
 	UnconditionalFlowInfo mergedInfo;
 	if (isOptimizedTrue){
 		if (initsWhenTrue == FlowInfo.DEAD_END && allowFakeDeadBranch) {
-			mergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE).
+			mergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).
 				unconditionalInits();
 		}
 		else {
@@ -406,7 +421,7 @@ public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse(
 	}
 	else if (isOptimizedFalse) {
 		if (initsWhenFalse == FlowInfo.DEAD_END && allowFakeDeadBranch) {
-			mergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE).
+			mergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).
 				unconditionalInits();
 		}
 		else {
@@ -456,10 +471,9 @@ public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse(
 }
 
 /**
- * Return REACHABLE if this flow info is reachable, UNREACHABLE
- * else.
- * @return REACHABLE if this flow info is reachable, UNREACHABLE
- *         else
+ * Find out the reachability mode of this flowInfo.
+ * @return REACHABLE if this flow info is reachable, otherwise
+ *         either UNREACHABLE_OR_DEAD or UNREACHABLE_BY_NULLANALYSIS.
  */
 public int reachMode() {
 	return this.tagBits & UNREACHABLE;
@@ -476,7 +490,8 @@ abstract public FlowInfo safeInitsWhenTrue();
 
 /**
  * Set this flow info reach mode and return this.
- * @param reachMode one of {@link #REACHABLE REACHABLE} or {@link #UNREACHABLE UNREACHABLE}
+ * @param reachMode one of {@link #REACHABLE REACHABLE}, {@link #UNREACHABLE_OR_DEAD UNREACHABLE_OR_DEAD},
+ * {@link #UNREACHABLE_BY_NULLANALYSIS UNREACHABLE_BY_NULLANALYSIS} or {@link #UNREACHABLE UNREACHABLE}
  * @return this, with the reach mode set to reachMode
  */
 abstract public FlowInfo setReachMode(int reachMode);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 2dd3d89..b8e570f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -494,14 +494,14 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 						scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				} else {
 					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				}
 			} else if (flowInfo.isDefinitelyNull(local)) {
@@ -510,14 +510,14 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 						scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				} else {
 					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
 					}
 					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 					}
 				}
 			} else if (this.upstreamNullFlowInfo.isDefinitelyNonNull(local) && !flowInfo.isPotentiallyNull(local) && !flowInfo.isPotentiallyUnknown(local)) {    
@@ -562,7 +562,7 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 							scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 						}
 						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE);
+							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						}
 						return;
 					case FlowContext.IN_COMPARISON_NON_NULL:
@@ -574,7 +574,7 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 							scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
 						}
 						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE);
+							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						}
 						return;
 					case FlowContext.IN_ASSIGNMENT:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
index 79558ae..8a63e6b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
@@ -731,7 +731,7 @@ final private boolean isDefinitelyAssigned(int position) {
 final public boolean isDefinitelyAssigned(FieldBinding field) {
 	// Mirrored in CodeStream.isDefinitelyAssigned(..)
 	// do not want to complain in unreachable code
-	if ((this.tagBits & UNREACHABLE) != 0) {
+	if ((this.tagBits & UNREACHABLE_OR_DEAD) != 0) {
 		return true;
 	}
 	return isDefinitelyAssigned(field.id);
@@ -739,7 +739,7 @@ final public boolean isDefinitelyAssigned(FieldBinding field) {
 
 final public boolean isDefinitelyAssigned(LocalVariableBinding local) {
 	// do not want to complain in unreachable code if local declared in reachable code
-	if ((this.tagBits & UNREACHABLE) != 0 && (local.declaration.bits & ASTNode.IsLocalDeclarationReachable) != 0) {
+	if ((this.tagBits & UNREACHABLE_OR_DEAD) != 0 && (local.declaration.bits & ASTNode.IsLocalDeclarationReachable) != 0) {
 		return true;
 	}
 	return isDefinitelyAssigned(local.id + this.maxFieldCount);
@@ -1529,7 +1529,7 @@ public void markPotentiallyNonNullBit(LocalVariableBinding local) {
 }
 
 public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
-	if ((otherInits.tagBits & UNREACHABLE) != 0 && this != DEAD_END) {
+	if ((otherInits.tagBits & UNREACHABLE_OR_DEAD) != 0 && this != DEAD_END) {
 		if (COVERAGE_TEST_FLAG) {
 			if(CoverageTestId == 28) {
 				throw new AssertionFailedException("COVERAGE 28"); //$NON-NLS-1$
@@ -1538,7 +1538,7 @@ public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
 		combineNullStatusChangeInAssertInfo(otherInits);
 		return this;
 	}
-	if ((this.tagBits & UNREACHABLE) != 0) {
+	if ((this.tagBits & UNREACHABLE_OR_DEAD) != 0) {
 		if (COVERAGE_TEST_FLAG) {
 			if(CoverageTestId == 29) {
 				throw new AssertionFailedException("COVERAGE 29"); //$NON-NLS-1$
@@ -1563,7 +1563,17 @@ public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
 		na1, na2, na3, na4,
 		nb1, nb2, nb3, nb4,
 		b1, b2, b3, b4;
-	if (thisHadNulls) {
+	if ((otherInits.tagBits & FlowInfo.UNREACHABLE_BY_NULLANALYSIS) != 0) {
+		otherHasNulls = false; // skip merging, otherInits is unreachable by null analysis
+	} else if ((this.tagBits & FlowInfo.UNREACHABLE_BY_NULLANALYSIS) != 0) { // directly copy if this is unreachable by null analysis
+		this.nullBit1 = otherInits.nullBit1;
+		this.nullBit2 = otherInits.nullBit2;
+		this.nullBit3 = otherInits.nullBit3;
+		this.nullBit4 = otherInits.nullBit4;
+		thisHadNulls = false;
+		thisHasNulls = otherHasNulls;
+		this.tagBits = otherInits.tagBits;
+	} else if (thisHadNulls) {
     	if (otherHasNulls) {
     		this.nullBit1 = (a2 = this.nullBit2) & (a3 = this.nullBit3)
     							& (a4 = this.nullBit4) & (b1 = otherInits.nullBit1)
@@ -1858,6 +1868,8 @@ public FlowInfo setReachMode(int reachMode) {
 	}	
 	if (reachMode == REACHABLE ) {
 		this.tagBits &= ~UNREACHABLE;
+	} else if (reachMode == UNREACHABLE_BY_NULLANALYSIS ) {
+		this.tagBits |= UNREACHABLE_BY_NULLANALYSIS;	// do not interfere with definite assignment analysis
 	} else {
 		if ((this.tagBits & UNREACHABLE) == 0) {
 			// reset optional inits when becoming unreachable
@@ -1870,7 +1882,7 @@ public FlowInfo setReachMode(int reachMode) {
 				}
 			}
 		}
-		this.tagBits |= UNREACHABLE;
+		this.tagBits |= reachMode;
 	}
 	return this;
 }
