commit 3c8b95412c50bb73a8372fbf9db9df68231cc311
Author: Jesper Moller <jesper@selskabet.org>
Date:   Sun Oct 13 17:28:56 2013 +0530

    Fixed Bug 412149 - [1.8][compiler] Emit repeated annotations into the
    designated container

4	4	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
462	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
12	29	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
23	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
70	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
89	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContainerAnnotation.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleMemberAnnotation.java
17	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
15	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 72110e5..cc7137a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -775,9 +775,9 @@ public class Factory {
 			AnnotationBinding annotation = repackagedBindings[i];
 			if (annotation == null) continue;
 			ReferenceBinding annotationType = annotation.getAnnotationType();
-			if (!annotationType.isRepeatableAnnotation())
+			if (!annotationType.isRepeatableAnnotationType())
 				continue;
-			ReferenceBinding containerType = annotationType.resolveContainerAnnotation();
+			ReferenceBinding containerType = annotationType.containerAnnotationType();
 			if (containerType == null)
 				continue; // FUBAR.
 			MethodBinding [] values = containerType.getMethods(TypeConstants.VALUE);
@@ -831,10 +831,10 @@ public class Factory {
 			MethodBinding value = values[0];
 			
 			TypeBinding containeeType = value.returnType.leafComponentType();
-			if (containeeType == null || !containeeType.isAnnotationType() || !containeeType.isRepeatableAnnotation())
+			if (containeeType == null || !containeeType.isAnnotationType() || !containeeType.isRepeatableAnnotationType())
 				continue;
 			
-			if (containeeType.resolveContainerAnnotation() != annotationType)
+			if (containeeType.containerAnnotationType() != annotationType)
 				continue;
 			
 			// We have a kosher container: unwrap the contained annotations.
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
index 1f2f5e0..63a3c87 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
@@ -12,6 +12,7 @@
  * Contributors:
  *     Jesper S Moller - initial API and implementation
  *     					Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
+ *     					Bug 412149 - [1.8][compiler] Emit repeated annotations into the designated container
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -837,4 +838,465 @@ public class RepeatableAnnotationTest extends AbstractComparableTest {
 			"The repeatable annotation @T is disallowed for this location since its container annotation @TC is disallowed at this location\n" + 
 			"----------\n");
 	}	
+	// 412149: [1.8][compiler] Emit repeated annotations into the designated container
+	public void test036() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@interface AttrContainer {\n" +
+				"  public Attr[] value();\n" +
+				"}\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Repeatable(AttrContainer.class)\n" + 
+				"@interface Attr {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"@Attr(1) @Attr(2)\n" +
+				"public class X {\n" +
+				"  public static void main(String args[]) {\n" +
+				"  	Object e[] = X.class.getAnnotationsByType(Attr.class);\n" +
+				"  	for (int i=0; i<e.length;++i) System.out.print(e[i] + \" \");\n" +
+				"  }\n" +
+				"}"
+			},
+			"@Attr(value=1) @Attr(value=2)");
+		
+	}
+	// 412149: [1.8][compiler] Emit repeated annotations into the designated container
+	// Test that only repetitions go into the container 
+	public void test037() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@interface AttrContainer {\n" +
+				"  public Attr[] value();\n" +
+				"}\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Repeatable(AttrContainer.class)\n" + 
+				"@interface Attr {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"public class X {\n" +
+				"  @Attr(1) class Y1 {}\n" +
+				"  @Attr(1) @Attr(2) class Y2 {} \n" +
+				"  public static void main(String args[]) {\n" +
+				"  	System.out.println(\"Y1: \" + Y1.class.getAnnotation(Attr.class));\n" +
+				"  	System.out.println(\"Y2: \" + Y2.class.getAnnotation(Attr.class));\n" +
+				"  	System.out.println(\"Y1: \" + Y1.class.getAnnotation(AttrContainer.class));\n" +
+				"  	System.out.println(\"Y2: \" + Y2.class.getAnnotation(AttrContainer.class));\n" +
+				"  }\n" +
+				"}"
+			},
+			"Y1: @Attr(value=1)\n" + 
+			"Y2: null\n" + 
+			"Y1: null\n" + 
+			"Y2: @AttrContainer(value=[@Attr(value=1), @Attr(value=2)])");
+		
+	}
+	// 412149: [1.8][compiler] Emit repeated annotations into the designated container
+	// Test that the retention from the containing annotation is used
+	public void test038() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@interface AttrContainer {\n" +
+				"  public Attr[] value();\n" +
+				"}\n" +
+				"@Retention(SOURCE)\n" +
+				"@Repeatable(AttrContainer.class)\n" + 
+				"@interface Attr {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"public class X {\n" +
+				"  @Attr(1) class Y1 {}\n" +
+				"  @Attr(1) @Attr(2) class Y2 {} \n" +
+				"  public static void main(String args[]) {\n" +
+				"  	System.out.println(\"Y1 has \" + Y1.class.getAnnotationsByType(Attr.class).length);\n" +
+				"  	System.out.println(\"Y2 has \" + Y2.class.getAnnotationsByType(Attr.class).length);\n" +
+				"  }\n" +
+				"}"
+			},
+			"Y1 has 0\n" + 
+			"Y2 has 2");
+		
+	}
+	// 412149: [1.8][compiler] Emit repeated annotations into the designated container
+	// Test that repeated annotations can appear at package targets - doesn't work due to VarifyClassLoader not defining packages.
+	public void _test039() {
+		String[] testFiles = {
+				"repeatable/Main.java",
+				"package repeatable;\n" +
+				"public class Main {\n" +
+				"    public static void main (String[] argv) {\n" + 
+				"          System.out.println(repeatable.Main.class.getClassLoader().getClass().getSimpleName());\n" + 
+				"          System.out.println(\"Pacakage has \" + Main.class.getClassLoader().getClass().getName());\n" +
+				"        System.out.println(\"The pacakage has \" + Main.class.getPackage().getAnnotationsByType(Foo.class).length + \" annotations\");\n" +
+				"    };\n" +
+				"}",
+
+			"repeatable/FooContainer.java",
+			"package repeatable;\n" +
+			"@java.lang.annotation.Target(java.lang.annotation.ElementType.PACKAGE)\n" +
+			"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
+			"public @interface FooContainer {\n" +
+			"	Foo[] value();\n" +
+			"}\n",
+
+			"repeatable/Foo.java",
+			"package repeatable;\n" +
+			"@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+			"public @interface Foo {}\n",
+
+			"repeatable/package-info.java",
+			"@Foo @Foo\n" +
+			"package repeatable;\n" +
+			"import repeatable.Foo;",
+		};
+		runConformTest(testFiles, "The package has 2 annotations");
+	}
+	// 412149: [1.8][compiler] Emit repeated annotations into the designated container
+	// Test that repeated annotations show up on fields, methods, and parameters
+	public void test040() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.reflect.Field;\n" + 
+				"import java.lang.reflect.Method;\n" + 
+				"import java.lang.reflect.Parameter;\n" + 
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@interface AttrContainer {\n" +
+				"  public Attr[] value();\n" +
+				"}\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Repeatable(AttrContainer.class)\n" + 
+				"@interface Attr {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"public class X {\n" +
+				"   @Attr(1) @Attr(2) public int field;\n" + 
+				"\n" + 
+				"   @Attr(3) @Attr(4)\n" + 
+				"   public static void main(@Attr(5) @Attr(6) String args[]) throws Exception {\n" + 
+				"    Field fieldField = X.class.getField(\"field\");\n" + 
+				"    dump(fieldField.getAnnotationsByType(Attr.class));\n" + 
+				"    Method mainMethod = X.class.getMethod(\"main\", (new String[0]).getClass());\n" + 
+				"    dump(mainMethod.getAnnotationsByType(Attr.class));\n" + 
+				"    Parameter argvParameter = mainMethod.getParameters()[0];\n" + 
+				"    dump(argvParameter.getAnnotationsByType(Attr.class));\n" + 
+				"   }\n" + 
+				"   static void dump(Attr[] attrs) {\n" + 
+				"    for (int i=0; i<attrs.length;++i) System.out.print(attrs[i] + \" \");\n" + 
+				"   }\n" +
+				"}"
+			},
+			"@Attr(value=1) @Attr(value=2) @Attr(value=3) @Attr(value=4) @Attr(value=5) @Attr(value=6)");
+	}
+	// Test that repeated annotations show up type parameters properly.
+	public void testTypeParameters() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Annotation;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.lang.reflect.AnnotatedElement;\n" +
+				"import java.lang.reflect.AnnotatedType;\n" +
+				"import java.lang.reflect.Field;\n" +
+				"import java.lang.reflect.Method;\n" +
+				"import java.lang.reflect.Type;\n" +
+				"import java.lang.reflect.TypeVariable;\n" +
+				"\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER,})\n" +
+				"@interface TC {\n" +
+				"  public T[] value();\n" +
+				"}\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Repeatable(TC.class)\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.METHOD})\n" +
+				"@interface T {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"interface I<@T(1) @T(2) K extends @T(3) @T(4) Object & java.lang.@T(5) @T(6) Comparable<?>> {\n" +
+				"}\n" +
+				"\n" +
+				"\n" +
+				"public class X {\n" +
+				"  public static void main(String args[]) {\n" +
+				"	Class<I> ci = I.class;  \n" +
+				"  	printAnnotations(\"I.class\", ci);\n" +
+				"  	TypeVariable<Class<I>>[] typeParameters = ci.getTypeParameters();\n" +
+				"  	for (TypeVariable<?> t: typeParameters) {\n" +
+				"  		printAnnotations(t.getName(), t);\n" +
+				"  		AnnotatedType[] bounds = t.getAnnotatedBounds();\n" +
+				"  		for (AnnotatedType bound : bounds) {\n" +
+				"  			printAnnotations(bound.getType().getTypeName(), bound);\n" +
+				"  		}\n" +
+				"  	}\n" +
+				"  }\n" +
+				"  \n" +
+				"  static void printAnnotations(String name, AnnotatedElement element) {\n" +
+				"	  int [] iterations = { 0, 1 };\n" +
+				"	  for (int i : iterations) {\n" +
+				"		  Class<? extends Annotation> annotation = i == 0 ? T.class : TC.class;\n" +
+				"		  for (int j: iterations) {\n" +
+				"			  Annotation [] annotations = j == 0 ? new Annotation [] { element.getAnnotation(annotation) } : element.getAnnotationsByType(annotation);\n" +
+				"			  if (annotations.length == 0 || (annotations.length == 1 && annotations[0] == null)) continue;\n" +
+				"			  System.out.print(name + (j == 0 ? \".getAnnotation(\" : \".getAnnotationByType(\") + annotation.getName() + \".class): \");\n" +
+				"			  for (Annotation a : annotations) {\n" +
+				"				  System.out.print(a + \" \");\n" +
+				"			  }\n" +
+				"			  System.out.println();\n" +
+				"		  }\n" +
+				"	  }\n" +
+				"  }\n" +
+				"}\n"
+
+			},
+			"K.getAnnotationByType(T.class): @T(value=1) @T(value=2) \n" +
+			"K.getAnnotation(TC.class): @TC(value=[@T(value=1), @T(value=2)]) \n" +
+			"K.getAnnotationByType(TC.class): @TC(value=[@T(value=1), @T(value=2)]) \n" +
+			"java.lang.Object.getAnnotationByType(T.class): @T(value=3) @T(value=4) \n" +
+			"java.lang.Object.getAnnotation(TC.class): @TC(value=[@T(value=3), @T(value=4)]) \n" +
+			"java.lang.Object.getAnnotationByType(TC.class): @TC(value=[@T(value=3), @T(value=4)]) \n" +
+			"java.lang.Comparable<?>.getAnnotationByType(T.class): @T(value=5) @T(value=6) \n" +
+			"java.lang.Comparable<?>.getAnnotation(TC.class): @TC(value=[@T(value=5), @T(value=6)]) \n" +
+			"java.lang.Comparable<?>.getAnnotationByType(TC.class): @TC(value=[@T(value=5), @T(value=6)])",
+			null,
+			true,
+			new String [] { "" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+	}
+	// Test that repeated annotations show up at various sites, both type use and declaration.
+	public void testVariousSites() {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Annotation;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Retention;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.lang.reflect.AnnotatedArrayType;\n" +
+				"import java.lang.reflect.AnnotatedElement;\n" +
+				"import java.lang.reflect.AnnotatedParameterizedType;\n" +
+				"import java.lang.reflect.AnnotatedType;\n" +
+				"import java.lang.reflect.Constructor;\n" +
+				"import java.lang.reflect.Field;\n" +
+				"import java.lang.reflect.Method;\n" +
+				"import java.lang.reflect.TypeVariable;\n" +
+				"\n" +
+				"import static java.lang.annotation.RetentionPolicy.*;\n" +
+				"\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.METHOD})\n" +
+				"@interface TC {\n" +
+				"  public T[] value();\n" +
+				"}\n" +
+				"@Retention(RUNTIME)\n" +
+				"@Repeatable(TC.class)\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.METHOD})\n" +
+				"@interface T {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"\n" +
+				"interface I {\n" +
+				"}\n" +
+				"\n" +
+				"@T(1) @T(2)\n" +
+				"public class X<@T(3) @T(4) K extends @T(5) @T(6) Object & java.lang.@T(7) @T(8) Comparable<?>, @T(9) @T(10) V> extends @T(11) @T(12) Object implements @T(13) @T(14) I {\n" +
+				"  public @T(15) @T(16) X<@T(17) @T(18) String, @T(19) @T(20) Integer> field;\n" +
+				"  @T(21) @T(22)\n" +
+				"  public <@T(23) @T(24) Q> X @T(25) @T(26) [] method(@T(27) @T(28) X<K, V> this, \n" +
+				"		                                             @T(29) @T(30) X<@T(31) @T(32) String, String> that) throws @T(33) @T(34) NullPointerException {\n" +
+				"	  return null;\n" +
+				"  }\n" +
+				"  @T(35) @T(36)\n" +
+				"  public X() {\n" +
+				"	  \n" +
+				"  }\n" +
+				"  @T(37) @T(48)\n" +
+				"  public class MemberType {\n" +
+				"	  \n" +
+				"  }\n" +
+				"  \n" +
+				"  public static void main(String args[]) {\n" +
+				"	Class<X> xc = X.class;  \n" +
+				"  	printAnnotations(\"Class: \" + \"X.class\", xc);\n" +
+				"  	TypeVariable<Class<X>>[] typeParameters = xc.getTypeParameters();\n" +
+				"  	for (TypeVariable<?> t: typeParameters) {\n" +
+				"  		printAnnotations(\"Type Parameter: \" + t.getName(), t);\n" +
+				"  		AnnotatedType[] bounds = t.getAnnotatedBounds();\n" +
+				"  		for (AnnotatedType bound : bounds) {\n" +
+				"  			printAnnotations(\"Type parameter bound: \" + bound.getType().getTypeName(), bound);\n" +
+				"  		}\n" +
+				"  	}\n" +
+				"  	AnnotatedType annotatedSuperclass = xc.getAnnotatedSuperclass();\n" +
+				"  	printAnnotations(\"Superclass: \" + annotatedSuperclass.getType().getTypeName(), annotatedSuperclass);\n" +
+				"  	\n" +
+				"  	AnnotatedType [] annotatedSuperInterfaces = xc.getAnnotatedInterfaces();\n" +
+				"  	printAnnotations(\"Superinterface: \" + annotatedSuperInterfaces[0].getType().getTypeName(), annotatedSuperInterfaces[0]);\n" +
+				"  	\n" +
+				"  	for (Field field: xc.getFields()) {\n" +
+				"  		printAnnotations(\"Field: \" + field.getName(), field);\n" +
+				"  		AnnotatedParameterizedType fType = (AnnotatedParameterizedType) field.getAnnotatedType();\n" +
+				"  		for (AnnotatedType typeArgumentType : fType.getAnnotatedActualTypeArguments())\n" +
+				"  			printAnnotations(\"Field Type argument: \" + typeArgumentType.getType().getTypeName(), typeArgumentType);\n" +
+				"  			\n" +
+				"  	}\n" +
+				"  	for (Method method: xc.getMethods()) {\n" +
+				"  		switch (method.getName()) {\n" +
+				"  		case \"method\"  :\n" +
+				"  			printAnnotations(method.getName(), method);\n" +
+				"  			AnnotatedArrayType mType = (AnnotatedArrayType) method.getAnnotatedReturnType();\n" +
+				"  			printAnnotations(\"Method return type: \" + mType.getType().getTypeName(), mType);\n" +
+				"  			AnnotatedType mTypeEtype = mType.getAnnotatedGenericComponentType();\n" +
+				"  			printAnnotations(\"Method return type, element type: \" + mTypeEtype.getType().getTypeName(), mTypeEtype);\n" +
+				"  			TypeVariable<Method>[] typeParameters2 = method.getTypeParameters();\n" +
+				"  		  	for (TypeVariable<?> t: typeParameters2) {\n" +
+				"  		  		printAnnotations(\"Method Type Parameter: \" + t.getName(), t);\n" +
+				"  		  	}\n" +
+				"  		  	AnnotatedType annotatedReceiverType = method.getAnnotatedReceiverType();\n" +
+				"  		  	printAnnotations(\"Receiver: \", annotatedReceiverType);\n" +
+				"  		  	AnnotatedType[] annotatedParameterTypes = method.getAnnotatedParameterTypes();\n" +
+				"  		  	for (AnnotatedType annotatedParameterType : annotatedParameterTypes) {\n" +
+				"  		  		printAnnotations(\"Parameter: \", annotatedParameterType);\n" +
+				"  		  	}\n" +
+				"  		  	AnnotatedType[] annotatedExceptionTypes = method.getAnnotatedExceptionTypes();\n" +
+				"  		  	for (AnnotatedType annotatedType : annotatedExceptionTypes) {\n" +
+				"				printAnnotations(\"Exception type: \", annotatedType);\n" +
+				"			}\n" +
+				"  			break;\n" +
+				"  		}\n" +
+				"  	}\n" +
+				"  	for (Constructor<?> constructor : xc.getConstructors()) {\n" +
+				"  		printAnnotations(\"Constructor: \", constructor);\n" +
+				"  	}\n" +
+				"  	// don't know how to get member classes.\n" +
+				"  }\n" +
+				"  \n" +
+				"  static void printAnnotations(String name, AnnotatedElement element) {\n" +
+				"	  int [] iterations = { 0, 1 };\n" +
+				"	  for (int i : iterations) {\n" +
+				"		  Class<? extends Annotation> annotation = i == 0 ? T.class : TC.class;\n" +
+				"		  for (int j: iterations) {\n" +
+				"			  Annotation [] annotations = j == 0 ? new Annotation [] { element.getAnnotation(annotation) } : element.getAnnotationsByType(annotation);\n" +
+				"			  if (annotations.length == 0 || (annotations.length == 1 && annotations[0] == null)) continue;\n" +
+				"			  System.out.print(name + (j == 0 ? \".getAnnotation(\" : \".getAnnotationByType(\") + annotation.getName() + \".class): \");\n" +
+				"			  for (Annotation a : annotations) {\n" +
+				"				  System.out.print(a + \" \");\n" +
+				"			  }\n" +
+				"			  System.out.println();\n" +
+				"		  }\n" +
+				"	  }\n" +
+				"  }\n" +
+				"}\n"
+
+			},
+			"Class: X.class.getAnnotationByType(T.class): @T(value=1) @T(value=2) \n" +
+			"Class: X.class.getAnnotation(TC.class): @TC(value=[@T(value=1), @T(value=2)]) \n" +
+			"Class: X.class.getAnnotationByType(TC.class): @TC(value=[@T(value=1), @T(value=2)]) \n" +
+			"Type Parameter: K.getAnnotationByType(T.class): @T(value=3) @T(value=4) \n" +
+			"Type Parameter: K.getAnnotation(TC.class): @TC(value=[@T(value=3), @T(value=4)]) \n" +
+			"Type Parameter: K.getAnnotationByType(TC.class): @TC(value=[@T(value=3), @T(value=4)]) \n" +
+			"Type parameter bound: java.lang.Object.getAnnotationByType(T.class): @T(value=5) @T(value=6) \n" +
+			"Type parameter bound: java.lang.Object.getAnnotation(TC.class): @TC(value=[@T(value=5), @T(value=6)]) \n" +
+			"Type parameter bound: java.lang.Object.getAnnotationByType(TC.class): @TC(value=[@T(value=5), @T(value=6)]) \n" +
+			"Type parameter bound: java.lang.Comparable<?>.getAnnotationByType(T.class): @T(value=7) @T(value=8) \n" +
+			"Type parameter bound: java.lang.Comparable<?>.getAnnotation(TC.class): @TC(value=[@T(value=7), @T(value=8)]) \n" +
+			"Type parameter bound: java.lang.Comparable<?>.getAnnotationByType(TC.class): @TC(value=[@T(value=7), @T(value=8)]) \n" +
+			"Type Parameter: V.getAnnotationByType(T.class): @T(value=9) @T(value=10) \n" +
+			"Type Parameter: V.getAnnotation(TC.class): @TC(value=[@T(value=9), @T(value=10)]) \n" +
+			"Type Parameter: V.getAnnotationByType(TC.class): @TC(value=[@T(value=9), @T(value=10)]) \n" +
+			"Superclass: java.lang.Object.getAnnotationByType(T.class): @T(value=11) @T(value=12) \n" +
+			"Superclass: java.lang.Object.getAnnotation(TC.class): @TC(value=[@T(value=11), @T(value=12)]) \n" +
+			"Superclass: java.lang.Object.getAnnotationByType(TC.class): @TC(value=[@T(value=11), @T(value=12)]) \n" +
+			"Superinterface: I.getAnnotationByType(T.class): @T(value=13) @T(value=14) \n" +
+			"Superinterface: I.getAnnotation(TC.class): @TC(value=[@T(value=13), @T(value=14)]) \n" +
+			"Superinterface: I.getAnnotationByType(TC.class): @TC(value=[@T(value=13), @T(value=14)]) \n" +
+			"Field: field.getAnnotationByType(T.class): @T(value=15) @T(value=16) \n" +
+			"Field: field.getAnnotation(TC.class): @TC(value=[@T(value=15), @T(value=16)]) \n" +
+			"Field: field.getAnnotationByType(TC.class): @TC(value=[@T(value=15), @T(value=16)]) \n" +
+			"Field Type argument: java.lang.String.getAnnotationByType(T.class): @T(value=17) @T(value=18) \n" +
+			"Field Type argument: java.lang.String.getAnnotation(TC.class): @TC(value=[@T(value=17), @T(value=18)]) \n" +
+			"Field Type argument: java.lang.String.getAnnotationByType(TC.class): @TC(value=[@T(value=17), @T(value=18)]) \n" +
+			"Field Type argument: java.lang.Integer.getAnnotationByType(T.class): @T(value=19) @T(value=20) \n" +
+			"Field Type argument: java.lang.Integer.getAnnotation(TC.class): @TC(value=[@T(value=19), @T(value=20)]) \n" +
+			"Field Type argument: java.lang.Integer.getAnnotationByType(TC.class): @TC(value=[@T(value=19), @T(value=20)]) \n" +
+			"method.getAnnotationByType(T.class): @T(value=21) @T(value=22) \n" +
+			"method.getAnnotation(TC.class): @TC(value=[@T(value=21), @T(value=22)]) \n" +
+			"method.getAnnotationByType(TC.class): @TC(value=[@T(value=21), @T(value=22)]) \n" +
+			"Method return type: X[].getAnnotationByType(T.class): @T(value=25) @T(value=26) \n" +
+			"Method return type: X[].getAnnotation(TC.class): @TC(value=[@T(value=25), @T(value=26)]) \n" +
+			"Method return type: X[].getAnnotationByType(TC.class): @TC(value=[@T(value=25), @T(value=26)]) \n" +
+			"Method return type, element type: X.getAnnotationByType(T.class): @T(value=21) @T(value=22) \n" +
+			"Method return type, element type: X.getAnnotation(TC.class): @TC(value=[@T(value=21), @T(value=22)]) \n" +
+			"Method return type, element type: X.getAnnotationByType(TC.class): @TC(value=[@T(value=21), @T(value=22)]) \n" +
+			"Method Type Parameter: Q.getAnnotationByType(T.class): @T(value=23) @T(value=24) \n" +
+			"Method Type Parameter: Q.getAnnotation(TC.class): @TC(value=[@T(value=23), @T(value=24)]) \n" +
+			"Method Type Parameter: Q.getAnnotationByType(TC.class): @TC(value=[@T(value=23), @T(value=24)]) \n" +
+			"Receiver: .getAnnotationByType(T.class): @T(value=27) @T(value=28) \n" +
+			"Receiver: .getAnnotation(TC.class): @TC(value=[@T(value=27), @T(value=28)]) \n" +
+			"Receiver: .getAnnotationByType(TC.class): @TC(value=[@T(value=27), @T(value=28)]) \n" +
+			"Parameter: .getAnnotationByType(T.class): @T(value=29) @T(value=30) \n" +
+			"Parameter: .getAnnotation(TC.class): @TC(value=[@T(value=29), @T(value=30)]) \n" +
+			"Parameter: .getAnnotationByType(TC.class): @TC(value=[@T(value=29), @T(value=30)]) \n" +
+			"Exception type: .getAnnotationByType(T.class): @T(value=33) @T(value=34) \n" +
+			"Exception type: .getAnnotation(TC.class): @TC(value=[@T(value=33), @T(value=34)]) \n" +
+			"Exception type: .getAnnotationByType(TC.class): @TC(value=[@T(value=33), @T(value=34)]) \n" +
+			"Constructor: .getAnnotationByType(T.class): @T(value=35) @T(value=36) \n" +
+			"Constructor: .getAnnotation(TC.class): @TC(value=[@T(value=35), @T(value=36)]) \n" +
+			"Constructor: .getAnnotationByType(TC.class): @TC(value=[@T(value=35), @T(value=36)])",
+			null,
+			true,
+			new String [] { "" }); // Not sure, unless we force the VM to not be reused by passing dummy vm argument, the generated program aborts midway through its execution.
+	}
+
+	// Test that bad container specifications are handled properly.
+	public void testBadContainerType() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Repeatable;\n" +
+				"@Repeatable(X.class)\n" +
+				"@interface T {\n" +
+				"  public int value() default -1;\n" +
+				"}\n" +
+				"public class X {\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 2)\n" + 
+			"	@Repeatable(X.class)\n" + 
+			"	            ^^^^^^^\n" + 
+			"Type mismatch: cannot convert from Class<X> to Class<? extends Annotation>\n" + 
+			"----------\n");
+	}	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 6aa3e2e..aaeadb2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -15,6 +15,7 @@
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335             
  *							Bug 406982 - [1.8][compiler] Generation of MethodParameters Attribute in classfile
  *							Bug 416885 - [1.8][compiler]IncompatibleClassChange error (edit)
+ *							Bug 412149 - [1.8][compiler] Emit repeated annotations into the designated container
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -3404,9 +3405,9 @@ public class ClassFile implements TypeConstants, TypeIds {
 		final int length = annotations.length;
 		int visibleAnnotationsCounter = 0;
 		int invisibleAnnotationsCounter = 0;
-
+		Annotation annotation;
 		for (int i = 0; i < length; i++) {
-			Annotation annotation = annotations[i];
+			if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 			if (annotation.isRuntimeInvisible() || (includeTypeUseAnnotations && annotation.isRuntimeTypeInvisible())) {
 				invisibleAnnotationsCounter++;
 			} else if (annotation.isRuntimeVisible() || (includeTypeUseAnnotations && annotation.isRuntimeTypeVisible())) {
@@ -3434,7 +3435,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 			int counter = 0;
 			loop: for (int i = 0; i < length; i++) {
 				if (invisibleAnnotationsCounter == 0) break loop;
-				Annotation annotation = annotations[i];
+				if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 				if (annotation.isRuntimeInvisible() || 
 						// No need to explicitly check it is type_use and not type_parameter, 
 						// that will already have been checked
@@ -3484,7 +3485,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 			int counter = 0;
 			loop: for (int i = 0; i < length; i++) {
 				if (visibleAnnotationsCounter == 0) break loop;
-				Annotation annotation = annotations[i];
+				if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 				if (annotation.isRuntimeVisible() || 
 					// No need to explicitly check it is type_use and not type_parameter, 
 					// that will already have been checked
@@ -3522,12 +3523,13 @@ public class ClassFile implements TypeConstants, TypeIds {
 		int invisibleParametersAnnotationsCounter = 0;
 		int visibleParametersAnnotationsCounter = 0;
 		int[][] annotationsCounters = new int[argumentsLength][2];
+		Annotation annotation;
 		for (int i = 0; i < argumentsLength; i++) {
 			Argument argument = arguments[i];
 			Annotation[] annotations = argument.annotations;
 			if (annotations != null) {
 				for (int j = 0, max2 = annotations.length; j < max2; j++) {
-					Annotation annotation = annotations[j];
+					if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 					if (annotation.isRuntimeInvisible()) {
 						annotationsCounters[i][INVISIBLE_INDEX]++;
 						invisibleParametersAnnotationsCounter++;
@@ -3570,7 +3572,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 						Argument argument = arguments[i];
 						Annotation[] annotations = argument.annotations;
 						for (int j = 0, max = annotations.length; j < max; j++) {
-							Annotation annotation = annotations[j];
+							if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 							if (annotation.isRuntimeInvisible()) {
 								int currentAnnotationOffset = this.contentsOffset;
 								generateAnnotation(annotation, currentAnnotationOffset);
@@ -3628,7 +3630,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 						Argument argument = arguments[i];
 						Annotation[] annotations = argument.annotations;
 						for (int j = 0, max = annotations.length; j < max; j++) {
-							Annotation annotation = annotations[j];
+							if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 							if (annotation.isRuntimeVisible()) {
 								int currentAnnotationOffset = this.contentsOffset;
 								generateAnnotation(annotation, currentAnnotationOffset);
@@ -4483,10 +4485,9 @@ public class ClassFile implements TypeConstants, TypeIds {
 	}
 	
 	private void generateTypeAnnotation(AnnotationContext annotationContext, int currentOffset) {
-		if (annotationContext.wildcard != null) {
-			generateWildcardTypeAnnotation(annotationContext, currentOffset);
+		Annotation annotation = annotationContext.annotation.getPersistibleAnnotation();
+		if (annotation == null || annotation.resolvedType == null)
 			return;
-		}
 		
 		int targetType = annotationContext.targetType;
 
@@ -4500,27 +4501,9 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.contents[this.contentsOffset++] = (byte) targetType;
 		dumpTargetTypeContents(targetType, annotationContext);
 		dumpLocations(locations);
-		
-		// common part between type annotation and annotation
-		generateAnnotation(annotationContext.annotation, currentOffset);
+		generateAnnotation(annotation, currentOffset);
 	}
 
-	private void generateWildcardTypeAnnotation(AnnotationContext annotationContext, int currentOffset) {
-		int targetType = annotationContext.targetType;
-
-		int[] locations = Annotation.getLocations(
-				annotationContext.typeReference,
-				annotationContext.annotation);
-		// reserve enough space
-		if (this.contentsOffset + 5 >= this.contents.length) {
-			resizeContents(5);
-		}
-		this.contents[this.contentsOffset++] = (byte) targetType;
-		dumpTargetTypeContents(targetType, annotationContext);
-		dumpLocations(locations);
-		generateAnnotation(annotationContext.annotation, currentOffset);
-	}
-	
 	private int generateTypeAnnotationAttributeForTypeDeclaration() {
 		TypeDeclaration typeDeclaration = this.referenceBinding.scope.referenceContext;
 		if ((typeDeclaration.bits & ASTNode.HasTypeAnnotations) == 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index ca92b16..dc44798 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -26,6 +26,7 @@
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+ *								bug 412149 - [1.8][compiler] Emit repeated annotations into the designated container
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -802,15 +803,15 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		if (copySE8AnnotationsToType)
 			copySE8AnnotationsToType(scope, recipient, sourceAnnotations);
 
+		/* See if the recipient is meta-annotated with @Repeatable and if so validate constraints. We can't do this during resolution of @Repeatable itself as @Target and 
+		   @Retention etc could come later
+		*/   
 		if (annotations != null && length > 0 && recipient != null && recipient.isAnnotationType()) {
-			// See if this is meta-annotated as repeatable and if so validate constraints.
 			for (int i = 0; i < length; i++) {
 				Annotation annotation = sourceAnnotations[i];
-				MemberValuePair[] valuePairs = annotation.memberValuePairs();
 				ReferenceBinding annotationType = annotations[i] != null ? annotations[i].getAnnotationType() : null;
-				if (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {
-					annotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);
-				}
+				if (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable)
+					annotation.checkRepeatableMetaAnnotation(scope);
 			}
 		}
 		
@@ -823,30 +824,35 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 				if (annotation == null) continue;
 				ReferenceBinding annotationType = annotation.getAnnotationType();
 				boolean foundDuplicate = false;
+				ContainerAnnotation container = null;
 				for (int j = i+1; j < length; j++) {
 					AnnotationBinding otherAnnotation = distinctAnnotations[j];
 					if (otherAnnotation == null) continue;
 					if (otherAnnotation.getAnnotationType() == annotationType) {
-						if (annotationType.isRepeatableAnnotation()) {
-							ReferenceBinding resolvedContainer = annotationType.resolveContainerAnnotation();
-							if (resolvedContainer != null) {
-								// Since this is a repeated annotation, we need to check if the container is also used - so store it
-								// in a map of (container's ReferenceBinding -> the repeated source Annotation)
+						if (distinctAnnotations == annotations) {
+							System.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);
+						}
+						distinctAnnotations[j] = null; // report/process it only once
+						if (annotationType.isRepeatableAnnotationType()) {
+							Annotation persistibleAnnotation = sourceAnnotations[i].getPersistibleAnnotation();
+							if (persistibleAnnotation instanceof ContainerAnnotation)
+								container = (ContainerAnnotation) persistibleAnnotation;
+							if (container == null) {  // first encounter with a duplicate.
+								ReferenceBinding containerAnnotationType = annotationType.containerAnnotationType();
+								container = new ContainerAnnotation(sourceAnnotations[i], containerAnnotationType, scope);
 								if (implicitContainerAnnotations == null) implicitContainerAnnotations = new HashMap(3);
-								implicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);
-								// Validate the repeated *use* of a repeatable annotation.
-								Annotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);
+								implicitContainerAnnotations.put(containerAnnotationType, sourceAnnotations[i]);
 							}
+							container.addContainee(sourceAnnotations[j]);
 						} else {
 							foundDuplicate = true;
-							if (distinctAnnotations == annotations) {
-								System.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);
-							}
-							distinctAnnotations[j] = null; // report it only once
 							scope.problemReporter().duplicateAnnotation(sourceAnnotations[j], scope.compilerOptions().sourceLevel);
 						}
 					}
 				}
+				if (container != null) {
+					container.resolveType(scope);
+				}
 				if (foundDuplicate) {
 					scope.problemReporter().duplicateAnnotation(sourceAnnotations[i], scope.compilerOptions().sourceLevel);
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index d101b95..d4cdd20 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -27,7 +27,8 @@
  *                          Bug 414384 - [1.8] type annotation on abbreviated inner class is not marked as inner type
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *                          Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
-#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
+ *                          Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
+ *                          Bug 412149 - [1.8][compiler] Emit repeated annotations into the designated container
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -46,6 +47,8 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
  */
 public abstract class Annotation extends Expression {
 	
+	Annotation persistibleAnnotation = this;  // Emit this into class file, unless this is a repeating annotation, in which case package this into the designated container.
+	
 	/**
 	 * Return the location for the corresponding annotation inside the type reference, <code>null</code> if none.
 	 */
@@ -232,7 +235,7 @@ public abstract class Annotation extends Expression {
 	/**
 	 *  The representation of this annotation in the type system.
 	 */
-	private AnnotationBinding compilerAnnotation = null;
+	protected AnnotationBinding compilerAnnotation = null;
 
 	public static long getRetentionPolicy(char[] policyName) {
 		if (policyName == null || policyName.length == 0)
@@ -411,18 +414,30 @@ public abstract class Annotation extends Expression {
 		// Retention defaults to CLASS
 		return retention != 0 ? retention : TagBits.AnnotationClassRetention;
 	}
-	
-	public void checkRepeatableAnnotation(ASTNode valueAttribute, Scope scope, Object containingBinding) {
-		if (! (this.recipient instanceof ReferenceBinding && containingBinding instanceof ReferenceBinding)) return; // Has deeper problems...
-		ReferenceBinding containing = (ReferenceBinding)containingBinding;
-		ReferenceBinding repeatableAnnotation = (ReferenceBinding) this.recipient;
-		repeatableAnnotation.setContainingAnnotation(containing);
 
-		checkContainingAnnotation(valueAttribute, scope, containing, repeatableAnnotation);
+	public void checkRepeatableMetaAnnotation(BlockScope scope) {
+		
+		// `this' is the @Repeatable meta annotation, its recipient is the *repeatable* annotation type - we are at the declaration site, not the repeating use site.
+		
+		ReferenceBinding repeatableAnnotationType = (ReferenceBinding) this.recipient; // know it to be an annotation type. On target miss we don't get here
+		
+		MemberValuePair[] valuePairs = this.memberValuePairs();
+		if (valuePairs == null || valuePairs.length != 1)
+			return;
+		
+		Object value = valuePairs[0].compilerElementPair.value;
+		if (!(value instanceof ReferenceBinding))
+			return; // Has deeper problems, will bark elsewhere.
+		ReferenceBinding containerAnnotationType = (ReferenceBinding) value;
+		if (!containerAnnotationType.isAnnotationType())
+			return; // Has deeper problems, will bark elsewhere.
+		
+		repeatableAnnotationType.setContainerAnnotationType(containerAnnotationType); // For now. May be reset later to PRB in case of problems.
+		checkContainerAnnotationType(valuePairs[0], scope, containerAnnotationType, repeatableAnnotationType, false); // false => not use site, i.e declaration site error reporting requested.
 	}
 
-	public static void checkContainingAnnotation(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {
-		MethodBinding[] annotationMethods = container.methods();
+	public static void checkContainerAnnotationType(ASTNode culpritNode, BlockScope scope, ReferenceBinding containerAnnotationType, ReferenceBinding repeatableAnnotationType, boolean useSite) {
+		MethodBinding[] annotationMethods = containerAnnotationType.methods();
 		boolean sawValue = false;
 		for (int i = 0, length = annotationMethods.length; i < length; ++i) {
 			MethodBinding method = annotationMethods[i];
@@ -430,39 +445,32 @@ public abstract class Annotation extends Expression {
 				sawValue = true;
 				if (method.returnType.isArrayType() && method.returnType.dimensions() == 1) {
 					ArrayBinding array = (ArrayBinding) method.returnType;
-					if (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotation)) continue;
+					if (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotationType)) continue;
 				}
-				scope.problemReporter().containingAnnotationHasWrongValueType(markerNode, container, repeatableAnnotation, method.returnType);
+				repeatableAnnotationType.tagAsHavingDefectiveContainerType();
+				scope.problemReporter().containingAnnotationHasWrongValueType(culpritNode, containerAnnotationType, repeatableAnnotationType, method.returnType);
 			} else {
-				// Not the value() - must have default (or else isn't suitable as container
+				// Not the value() - must have default (or else isn't suitable as container)
 				if ((method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0) {
-					scope.problemReporter().containingAnnotationHasNonDefaultMembers(markerNode, container, method.selector);
+					repeatableAnnotationType.tagAsHavingDefectiveContainerType();
+					scope.problemReporter().containingAnnotationHasNonDefaultMembers(culpritNode, containerAnnotationType, method.selector);
 				}
 			}
 		}
 		if (!sawValue) {
-			scope.problemReporter().containingAnnotationMustHaveValue(markerNode, container);
+			repeatableAnnotationType.tagAsHavingDefectiveContainerType();
+			scope.problemReporter().containingAnnotationMustHaveValue(culpritNode, containerAnnotationType);
 		}
 		
-		checkContainingAnnotationRetention(markerNode, scope, container, repeatableAnnotation);
-		if (markerNode instanceof Annotation)
-			checkContainingAnnotationTarget((Annotation) markerNode, (BlockScope) scope, (TypeBinding) container, repeatableAnnotation);
-		else
-			checkContainingAnnotationTarget(markerNode, scope, container, repeatableAnnotation);
-		checkContaintAnnotationDocumented(markerNode, scope, container, repeatableAnnotation);
-		checkContaintAnnotationInherited(markerNode, scope, container, repeatableAnnotation);
-	}
-
-	// This is for error reporting for bad targets at the repeated annotation use site (as opposed to repeatable annotation type declaration site) - Leads to better message.
-	public static void checkContainingAnnotationTarget(Annotation annotation, BlockScope scope, TypeBinding containerAnnotationType, TypeBinding annotationType) {
-		// check (meta)target compatibility
-		if (!annotationType.isValidBinding()) {
-			// no need to check annotation usage if missing
-			return;
-		}
-		if (! isAnnotationTargetAllowed(annotation, scope, containerAnnotationType, annotation.recipient.kind())) {
-			scope.problemReporter().disallowedTargetForContainerAnnotation(annotation, containerAnnotationType);
-		}
+		checkContainingAnnotationRetention(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);
+		
+		if (useSite)
+			checkContainingAnnotationTargetAtUse((Annotation) culpritNode, scope, containerAnnotationType, repeatableAnnotationType);
+		else 
+			checkContainingAnnotationTarget(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);
+		
+		checkContaintAnnotationDocumented(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);
+		checkContaintAnnotationInherited(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);
 	}
 	
 	// This is for error reporting for bad targets at annotation type declaration site (as opposed to the repeat site)
@@ -471,6 +479,7 @@ public abstract class Annotation extends Expression {
 		if ((tagBits & TagBits.AnnotationTargetMASK) != 0) { 
 			long containingTagBits = container.getAnnotationTagBits();
 			if ((containingTagBits & TagBits.AnnotationTargetMASK) == 0) {
+				repeatableAnnotation.tagAsHavingDefectiveContainerType();
 				scope.problemReporter().repeatableAnnotationHasTargets(markerNode, repeatableAnnotation, container);
 			} else {
 				final long targets = tagBits & TagBits.AnnotationTargetMASK;
@@ -516,21 +525,37 @@ public abstract class Annotation extends Expression {
 					builder.check(TagBits.AnnotationForTypeParameter, TypeConstants.TYPE_PARAMETER_TARGET);
 					builder.check(TagBits.AnnotationForTypeUse, TypeConstants.TYPE_USE_TARGET);
 					if (builder.hasError()) {
+						repeatableAnnotation.tagAsHavingDefectiveContainerType();
 						scope.problemReporter().repeatableAnnotationTargetMismatch(markerNode, repeatableAnnotation, container, builder.toString());
 					}
 				}
 			}
 		}
 	}
+	
+	// This is for error reporting for bad targets at the repeated annotation use site (as opposed to repeatable annotation type declaration site) - Leads to better message.
+	public static void checkContainingAnnotationTargetAtUse(Annotation annotation, BlockScope scope, TypeBinding containerAnnotationType, TypeBinding annotationType) {
+		// check (meta)target compatibility
+		if (!annotationType.isValidBinding()) {
+			// no need to check annotation usage if missing
+			return;
+		}
+		if (! isAnnotationTargetAllowed(annotation, scope, containerAnnotationType, annotation.recipient.kind())) {
+			scope.problemReporter().disallowedTargetForContainerAnnotation(annotation, containerAnnotationType);
+		}
+	}
+
 
 	private static void checkContaintAnnotationDocumented(ASTNode markerNode, Scope scope, ReferenceBinding containing, ReferenceBinding repeatableAnnotation) {
 		if ((repeatableAnnotation.getAnnotationTagBits() & TagBits.AnnotationDocumented) != 0 && (containing.getAnnotationTagBits() & TagBits.AnnotationDocumented) == 0) {
+			repeatableAnnotation.tagAsHavingDefectiveContainerType();
 			scope.problemReporter().repeatableAnnotationIsDocumented(markerNode, repeatableAnnotation, containing);
 		}
 	}
 
 	private static void checkContaintAnnotationInherited(ASTNode markerNode, Scope scope, ReferenceBinding containing, ReferenceBinding repeatableAnnotation) {
 		if ((repeatableAnnotation.getAnnotationTagBits() & TagBits.AnnotationInherited) != 0 && (containing.getAnnotationTagBits() & TagBits.AnnotationInherited) == 0) {
+			repeatableAnnotation.tagAsHavingDefectiveContainerType();
 			scope.problemReporter().repeatableAnnotationIsInherited(markerNode, repeatableAnnotation, containing);
 		}
 	}
@@ -540,6 +565,7 @@ public abstract class Annotation extends Expression {
 		long containerBits = getAnnotationRetention(container); 
 		// Due to clever layout of the bits, we can compare the absolute value directly
 		if (containerBits < annotationBits) {
+			repeatableAnnotation.tagAsHavingDefectiveContainerType();
 			scope.problemReporter().containingAnnotationHasShorterRetention(markerNode, repeatableAnnotation, getRetentionName(annotationBits), container, getRetentionName(containerBits));
 		}
 	}
@@ -1002,4 +1028,13 @@ public abstract class Annotation extends Expression {
 	public abstract void traverse(ASTVisitor visitor, BlockScope scope);
 
 	public abstract void traverse(ASTVisitor visitor, ClassScope scope);
+
+	public Annotation getPersistibleAnnotation() {
+		return this.persistibleAnnotation;      // will be this for non-repeating annotation, the container for the first of the repeating ones and null for the followers.
+	}
+	
+	public void setPersistibleAnnotation(ContainerAnnotation container) {
+		this.persistibleAnnotation = container; // will be a legitimate container for the first of the repeating ones and null for the followers.
+	}
+	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContainerAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContainerAnnotation.java
new file mode 100644
index 0000000..0d4a494
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContainerAnnotation.java
@@ -0,0 +1,89 @@
+/*******************************************************************************
+ * Copyright (c) 2013 Jesper S Moller and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     Jesper S Moller <jesper@selskabet.org> - initial API and implementation
+ ********************************************************************************/
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+
+public class ContainerAnnotation extends SingleMemberAnnotation {
+	
+	private Annotation [] containees;
+	private ArrayInitializer memberValues;
+	
+	public ContainerAnnotation(Annotation repeatingAnnotation, ReferenceBinding containerAnnotationType, BlockScope scope) {
+		
+		char [][] containerTypeName = containerAnnotationType.compoundName;
+		if (containerTypeName.length == 1) {
+			this.type = new SingleTypeReference(containerTypeName[0], 0);
+		} else {
+			this.type = new QualifiedTypeReference(containerTypeName, new long [containerTypeName.length]);
+		}
+		
+		this.sourceStart = repeatingAnnotation.sourceStart;
+		this.sourceEnd = repeatingAnnotation.sourceEnd;
+		
+		this.resolvedType = containerAnnotationType;
+		this.recipient = repeatingAnnotation.recipient;
+		this.containees = new Annotation[0];
+		this.memberValue = this.memberValues = new ArrayInitializer();
+		addContainee(repeatingAnnotation);
+	}
+	
+	public void addContainee(Annotation repeatingAnnotation) {
+		final int length = this.containees.length;
+		System.arraycopy(this.containees, 0, this.containees = new Annotation[length + 1], 0, length);
+		this.containees[length] = repeatingAnnotation;
+		this.memberValues.expressions = this.containees;
+		repeatingAnnotation.setPersistibleAnnotation(length == 0 ? this : null);
+	}
+	
+	// Resolve the compiler synthesized container annotation.
+	public TypeBinding resolveType(BlockScope scope) {
+
+		if (this.compilerAnnotation != null)
+			return this.resolvedType;
+
+		this.constant = Constant.NotAConstant;
+
+		ReferenceBinding containerAnnotationType = (ReferenceBinding) this.resolvedType;
+		if (!containerAnnotationType.isValidBinding())
+			containerAnnotationType = (ReferenceBinding) containerAnnotationType.closestMatch();
+		Annotation repeatingAnnotation = this.containees[0];
+		ReferenceBinding repeatingAnnotationType = (ReferenceBinding) repeatingAnnotation.resolvedType;
+		checkContainerAnnotationType(repeatingAnnotation, scope, containerAnnotationType, repeatingAnnotationType, true); // true => repeated *use* site error reporting requested.
+		this.resolvedType = containerAnnotationType = repeatingAnnotationType.containerAnnotationType();
+		if (!this.resolvedType.isValidBinding())
+			return this.resolvedType;
+		
+		// OK, the declaration site of the repeating annotation type as well as the use site where the annotations actually repeat pass muster. 
+		MethodBinding[] methods = containerAnnotationType.methods();
+		MemberValuePair pair = memberValuePairs()[0];
+		
+		for (int i = 0, length = methods.length; i < length; i++) {
+			MethodBinding method = methods[i];
+			if (CharOperation.equals(method.selector, TypeConstants.VALUE)) {
+				pair.binding = method;
+				pair.resolveTypeExpecting(scope, method.returnType);
+			}
+		}
+		this.compilerAnnotation = scope.environment().createAnnotation((ReferenceBinding) this.resolvedType, computeElementValuePairs());
+		return this.resolvedType;
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleMemberAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleMemberAnnotation.java
index 2eff389..abb6ad5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleMemberAnnotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleMemberAnnotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper Steen Moller - Contributions for:
+ *          Bug 412149: [1.8][compiler] Emit repeated annotations into the designated container
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -30,6 +32,10 @@ public class SingleMemberAnnotation extends Annotation {
 		this.sourceStart = sourceStart;
 		this.sourceEnd = type.sourceEnd;
 	}
+	
+	public SingleMemberAnnotation() {
+		// for subclasses.
+	}
 
 	public ElementValuePair[] computeElementValuePairs() {
 		return new ElementValuePair[] {memberValuePairs()[0].compilerElementPair};
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 27b27aa..98bb284 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -76,7 +76,7 @@ public class BinaryTypeBinding extends ReferenceBinding {
 
 	protected SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
-	private ReferenceBinding containingAnnotation;
+	private ReferenceBinding containerAnnotationType;
 
 static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char[][][] missingTypeNames) {
 	if (binaryValue == null) return null;
@@ -1259,9 +1259,9 @@ public boolean isHierarchyConnected() {
 	
 	return (this.tagBits & (TagBits.HasUnresolvedSuperclass | TagBits.HasUnresolvedSuperinterfaces)) == 0;
 }
-public boolean isRepeatableAnnotation() {
+public boolean isRepeatableAnnotationType() {
 	if (!isPrototype()) throw new IllegalStateException();
-	return this.containingAnnotation != null;
+	return this.containerAnnotationType != null;
 }
 public int kind() {
 	
@@ -1331,12 +1331,12 @@ private boolean isPrototype() {
 	return this == this.prototype; //$IDENTITY-COMPARISON$
 }
 
-public ReferenceBinding resolveContainerAnnotation() {
+public ReferenceBinding containerAnnotationType() {
 	if (!isPrototype()) throw new IllegalStateException();
-	if (this.containingAnnotation instanceof UnresolvedReferenceBinding) {
-		this.containingAnnotation = (ReferenceBinding) BinaryTypeBinding.resolveType(this.containingAnnotation, this.environment, false);
+	if (this.containerAnnotationType instanceof UnresolvedReferenceBinding) {
+		this.containerAnnotationType = (ReferenceBinding) BinaryTypeBinding.resolveType(this.containerAnnotationType, this.environment, false);
 	}
-	return this.containingAnnotation;
+	return this.containerAnnotationType;
 }
 
 private FieldBinding resolveTypeFor(FieldBinding field) {
@@ -1397,10 +1397,17 @@ AnnotationBinding[] retrieveAnnotations(Binding binding) {
 	
 	return AnnotationBinding.addStandardAnnotations(super.retrieveAnnotations(binding), binding.getAnnotationTagBits(), this.environment);
 }
-public void setContainingAnnotation(ReferenceBinding value) {
+
+public void setContainerAnnotationType(ReferenceBinding value) {
 	if (!isPrototype()) throw new IllegalStateException();
-	this.containingAnnotation = value;
+	this.containerAnnotationType = value;
+}
+
+public void tagAsHavingDefectiveContainerType() {
+	if (this.containerAnnotationType != null && this.containerAnnotationType.isValidBinding())
+		this.containerAnnotationType = new ProblemReferenceBinding(this.containerAnnotationType.compoundName, this.containerAnnotationType, ProblemReasons.DefectiveContainerAnnotationType);
 }
+
 SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	
 	if (!isPrototype())
@@ -1621,7 +1628,7 @@ private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] m
 				if (elementValuePairs != null && elementValuePairs.length == 1) {
 					Object value = elementValuePairs[0].getValue();
 					if (value instanceof ClassSignature) {
-						this.containingAnnotation = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
index fa11b45..b1a0642 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
@@ -37,4 +37,5 @@ public interface ProblemReasons {
 	final int IntersectionHasMultipleFunctionalInterfaces = 19;
 	final int NonStaticOrAlienTypeReceiver = 20;
 	final int AttemptToBypassDirectSuper = 21; // super access within default method
+	final int DefectiveContainerAnnotationType = 22;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 9ec687c..347718d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1548,7 +1548,10 @@ AnnotationBinding[] retrieveAnnotations(Binding binding) {
 public void setAnnotations(AnnotationBinding[] annotations) {
 	storeAnnotations(this, annotations);
 }
-public void setContainingAnnotation(ReferenceBinding value) {
+public void setContainerAnnotationType(ReferenceBinding value) {
+	// Leave this to subclasses
+}
+public void tagAsHavingDefectiveContainerType() {
 	// Leave this to subclasses
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index ba91196..4067585 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -89,7 +89,7 @@ public class SourceTypeBinding extends ReferenceBinding {
 	private int defaultNullness;
 	private int nullnessDefaultInitialized = 0; // 0: nothing; 1: type; 2: package
 	private int lambdaOrdinal = 0;
-	private ReferenceBinding containingAnnotation = null;
+	private ReferenceBinding containerAnnotationType = null;
 	
 public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassScope scope) {
 	this.compoundName = compoundName;
@@ -130,7 +130,7 @@ public SourceTypeBinding(SourceTypeBinding prototype) {
 	this.defaultNullness = prototype.defaultNullness;
 	this.nullnessDefaultInitialized= prototype.nullnessDefaultInitialized;
 	this.lambdaOrdinal = prototype.lambdaOrdinal;
-	this.containingAnnotation = prototype.containingAnnotation;
+	this.containerAnnotationType = prototype.containerAnnotationType;
 	this.tagBits |= TagBits.HasUnresolvedMemberTypes; // see memberTypes()
 }
 
@@ -1381,9 +1381,9 @@ public boolean isHierarchyConnected() {
 		return this.prototype.isHierarchyConnected();
 	return (this.tagBits & TagBits.EndHierarchyCheck) != 0;
 }
-public boolean isRepeatableAnnotation() {
+public boolean isRepeatableAnnotationType() {
 	if (!isPrototype()) throw new IllegalStateException();
-	return this.containingAnnotation != null;
+	return this.containerAnnotationType != null;
 }
 public ReferenceBinding[] memberTypes() {
 	if (!isPrototype()) {
@@ -1640,14 +1640,14 @@ public boolean isPrototype() {
 	return this == this.prototype;  //$IDENTITY-COMPARISON$
 }
 
-public ReferenceBinding resolveContainerAnnotation() {
+public ReferenceBinding containerAnnotationType() {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
-	if (this.containingAnnotation instanceof UnresolvedReferenceBinding) {
-		this.containingAnnotation = (ReferenceBinding)BinaryTypeBinding.resolveType(this.containingAnnotation, this.scope.environment(), false);
+	if (this.containerAnnotationType instanceof UnresolvedReferenceBinding) {
+		this.containerAnnotationType = (ReferenceBinding)BinaryTypeBinding.resolveType(this.containerAnnotationType, this.scope.environment(), false);
 	}
-	return this.containingAnnotation;
+	return this.containerAnnotationType;
 }
 
 public FieldBinding resolveTypeFor(FieldBinding field) {
@@ -2101,9 +2101,14 @@ public AnnotationHolder retrieveAnnotationHolder(Binding binding, boolean forceI
 	return super.retrieveAnnotationHolder(binding, false);
 }
 
-public void setContainingAnnotation(ReferenceBinding value) {
+public void setContainerAnnotationType(ReferenceBinding value) {
 	if (!isPrototype()) throw new IllegalStateException();
-	this.containingAnnotation  = value;
+	this.containerAnnotationType  = value;
+}
+
+public void tagAsHavingDefectiveContainerType() {
+	if (this.containerAnnotationType != null && this.containerAnnotationType.isValidBinding())
+		this.containerAnnotationType = new ProblemReferenceBinding(this.containerAnnotationType.compoundName, this.containerAnnotationType, ProblemReasons.DefectiveContainerAnnotationType);
 }
 
 // Propagate writes to all annotated variants so the clones evolve along.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 068065d..0726ce5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -161,7 +161,7 @@ int rank() {
 	return -1; // overridden in WildcardBinding
 }
 
-public ReferenceBinding resolveContainerAnnotation() {
+public ReferenceBinding containerAnnotationType() {
 	return null;
 }
 
@@ -983,7 +983,7 @@ private boolean isProvablyDistinctTypeArgument(TypeBinding otherArgument, final
 /**
  * Answer true if the receiver is an annotation which may be repeatable. Overridden as appropriate.
  */
-public boolean isRepeatableAnnotation() {
+public boolean isRepeatableAnnotationType() {
 	return false;
 }
 
commit d469b28de67962080fcf567963cfa5517cd349da
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Oct 15 06:38:21 2013 +0530

    Address review comment for Bug 412149 - [1.8][compiler] Emit repeated
    annotations into the designated container

6	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index aaeadb2..099ac2c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -3405,8 +3405,8 @@ public class ClassFile implements TypeConstants, TypeIds {
 		final int length = annotations.length;
 		int visibleAnnotationsCounter = 0;
 		int invisibleAnnotationsCounter = 0;
-		Annotation annotation;
 		for (int i = 0; i < length; i++) {
+			Annotation annotation;
 			if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 			if (annotation.isRuntimeInvisible() || (includeTypeUseAnnotations && annotation.isRuntimeTypeInvisible())) {
 				invisibleAnnotationsCounter++;
@@ -3435,6 +3435,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 			int counter = 0;
 			loop: for (int i = 0; i < length; i++) {
 				if (invisibleAnnotationsCounter == 0) break loop;
+				Annotation annotation;
 				if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 				if (annotation.isRuntimeInvisible() || 
 						// No need to explicitly check it is type_use and not type_parameter, 
@@ -3485,6 +3486,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 			int counter = 0;
 			loop: for (int i = 0; i < length; i++) {
 				if (visibleAnnotationsCounter == 0) break loop;
+				Annotation annotation;
 				if ((annotation = annotations[i].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 				if (annotation.isRuntimeVisible() || 
 					// No need to explicitly check it is type_use and not type_parameter, 
@@ -3523,12 +3525,12 @@ public class ClassFile implements TypeConstants, TypeIds {
 		int invisibleParametersAnnotationsCounter = 0;
 		int visibleParametersAnnotationsCounter = 0;
 		int[][] annotationsCounters = new int[argumentsLength][2];
-		Annotation annotation;
 		for (int i = 0; i < argumentsLength; i++) {
 			Argument argument = arguments[i];
 			Annotation[] annotations = argument.annotations;
 			if (annotations != null) {
 				for (int j = 0, max2 = annotations.length; j < max2; j++) {
+					Annotation annotation;
 					if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 					if (annotation.isRuntimeInvisible()) {
 						annotationsCounters[i][INVISIBLE_INDEX]++;
@@ -3572,6 +3574,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 						Argument argument = arguments[i];
 						Annotation[] annotations = argument.annotations;
 						for (int j = 0, max = annotations.length; j < max; j++) {
+							Annotation annotation;
 							if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 							if (annotation.isRuntimeInvisible()) {
 								int currentAnnotationOffset = this.contentsOffset;
@@ -3630,6 +3633,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 						Argument argument = arguments[i];
 						Annotation[] annotations = argument.annotations;
 						for (int j = 0, max = annotations.length; j < max; j++) {
+							Annotation annotation;
 							if ((annotation = annotations[j].getPersistibleAnnotation()) == null) continue; // already packaged into container.
 							if (annotation.isRuntimeVisible()) {
 								int currentAnnotationOffset = this.contentsOffset;
