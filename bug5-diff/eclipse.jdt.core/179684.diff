commit 355460267a070a52738f93cd1e4e0f2039fb0d85
Author: Jerome Lanneluc <jeromel>
Date:   Sat Apr 7 16:29:22 2007 +0000

    HEAD - bug 179684

3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
3	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
17	12	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
3	20	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java
9	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
2	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/LexStream.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/AbortCompilation.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
22	25	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
6	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
65	21	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java
10	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
3	23	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 2bd5b2d..1155db3 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.3M7 - %date%
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=180683">180683</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=179684">179684</a>
+&quot;Reconcile editor change&quot; perf test is getting slower
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=180683">180683</a>
 codeSelect does not work in unicode names like \u0042
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=181270">181270</a>
 [1.5][compiler] Class literal of array of type parameter should be rejected
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
index f4799a9..2bc8f68 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
@@ -30,6 +30,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.util.SimpleSetOfCharArray;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	private static final int MAX_LINE_COUNT = 100;
@@ -111,7 +112,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		
 		int maxEnd =
 			this.completionScanner.getLineEnd(
-					this.completionScanner.getLineNumber(from) + maxLineCount);
+					Util.getLineNumber(from, this.completionScanner.lineEnds, 0, this.completionScanner.linePtr) + maxLineCount);
 		
 		int end;
 		if (maxEnd < 0) {
@@ -160,7 +161,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		
 		int minStart =
 			this.completionScanner.getLineStart(
-					this.completionScanner.getLineNumber(to) - maxLineCount);
+					Util.getLineNumber(to, this.completionScanner.lineEnds, 0, this.completionScanner.linePtr) - maxLineCount);
 		
 		int start;
 		int fakeBlocksCount;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 0a0825a..e103acc 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -26,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.parser.*;
 import org.eclipse.jdt.internal.compiler.problem.*;
+import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.codeassist.impl.*;
@@ -264,7 +265,8 @@ protected void attachOrphanCompletionNode(){
 			if (method != null){
 				AbstractMethodDeclaration methodDecl = method.methodDeclaration;
 				if ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace
-					&& (scanner.getLineNumber(orphan.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){
+					&& (Util.getLineNumber(orphan.sourceStart, scanner.lineEnds, 0, scanner.linePtr) 
+							== Util.getLineNumber(methodDecl.sourceEnd, scanner.lineEnds, 0, scanner.linePtr))){
 					return;
 				}
 			}
@@ -440,7 +442,8 @@ protected void attachOrphanCompletionNode(){
 			if (method != null){
 				AbstractMethodDeclaration methodDecl = method.methodDeclaration;
 				if ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace
-					&& (this.scanner.getLineNumber(node.sourceStart) == this.scanner.getLineNumber(methodDecl.sourceEnd))){
+					&& (Util.getLineNumber(node.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr) 
+						== Util.getLineNumber(methodDecl.sourceEnd, this.scanner.lineEnds, 0, this.scanner.linePtr))){
 					return;
 				}
 			}
@@ -463,7 +466,8 @@ protected void attachOrphanCompletionNode(){
 			if (method != null){
 				AbstractMethodDeclaration methodDecl = method.methodDeclaration;
 				if ((methodDecl.bodyStart == methodDecl.sourceEnd+1) // was missing opening brace
-					&& (scanner.getLineNumber(expression.sourceStart) == scanner.getLineNumber(methodDecl.sourceEnd))){
+					&& (Util.getLineNumber(expression.sourceStart, scanner.lineEnds, 0, scanner.linePtr) 
+						== Util.getLineNumber(methodDecl.sourceEnd, scanner.lineEnds, 0, scanner.linePtr))){
 					return;
 				}
 			}
@@ -1540,8 +1544,8 @@ private boolean checkRecoveredMethod() {
 		/* check if on line with an error already - to avoid completing inside
 			illegal type names e.g.  int[<cursor> */
 		if (lastErrorEndPosition <= cursorLocation+1
-			&& scanner.getLineNumber(lastErrorEndPosition)
-				== scanner.getLineNumber(((CompletionScanner)scanner).completedIdentifierStart)){
+			&& Util.getLineNumber(lastErrorEndPosition, scanner.lineEnds, 0, scanner.linePtr)
+					== Util.getLineNumber(((CompletionScanner)scanner).completedIdentifierStart, scanner.lineEnds, 0, scanner.linePtr)){
 			return false;
 		}
  		RecoveredMethod recoveredMethod = (RecoveredMethod)currentElement;
@@ -1593,8 +1597,8 @@ private boolean checkRecoveredType() {
 		/* check if on line with an error already - to avoid completing inside
 			illegal type names e.g.  int[<cursor> */
 		if ((lastErrorEndPosition <= cursorLocation+1)
-			&& scanner.getLineNumber(lastErrorEndPosition)
-				== scanner.getLineNumber(((CompletionScanner)scanner).completedIdentifierStart)){
+			&& Util.getLineNumber(lastErrorEndPosition, scanner.lineEnds, 0, scanner.linePtr)
+					== Util.getLineNumber(((CompletionScanner)scanner).completedIdentifierStart, scanner.lineEnds, 0, scanner.linePtr)){
 			return false;
 		}
 		RecoveredType recoveredType = (RecoveredType)currentElement;
@@ -2030,8 +2034,8 @@ protected void consumeEnterVariable() {
 
 				if (!(currentElement instanceof RecoveredType)
 					&& (currentToken == TokenNameDOT
-						|| (scanner.getLineNumber(type.sourceStart)
-								!= scanner.getLineNumber(nameSourceStart)))){
+						|| (Util.getLineNumber(type.sourceStart, scanner.lineEnds, 0, scanner.linePtr)
+								!= Util.getLineNumber(nameSourceStart, scanner.lineEnds, 0, scanner.linePtr)))){
 					lastCheckPoint = nameSourceStart;
 					restartRecovery = true;
 					return;
@@ -2296,7 +2300,8 @@ protected void consumeMethodHeaderName(boolean isAnnotationMethod) {
 				int declarationSourceStart = intStack[intPtr--];
 				int mod = intStack[intPtr--];
 
-				if(scanner.getLineNumber(type.sourceStart) != scanner.getLineNumber((int) (selectorSource >>> 32))) {
+				if(Util.getLineNumber(type.sourceStart, scanner.lineEnds, 0, scanner.linePtr) 
+						!= Util.getLineNumber((int) (selectorSource >>> 32), scanner.lineEnds, 0, scanner.linePtr)) {
 					FieldDeclaration completionFieldDecl = new CompletionOnFieldType(type, false);
 					// consume annotations
 					int length;
@@ -2381,8 +2386,8 @@ protected void consumeMethodHeaderName(boolean isAnnotationMethod) {
 		if (currentElement != null){
 			if (currentElement instanceof RecoveredType
 				//|| md.modifiers != 0
-				|| (scanner.getLineNumber(md.returnType.sourceStart)
-						== scanner.getLineNumber(md.sourceStart))){
+				|| (Util.getLineNumber(md.returnType.sourceStart, scanner.lineEnds, 0, scanner.linePtr)
+						== Util.getLineNumber(md.sourceStart, scanner.lineEnds, 0, scanner.linePtr))){
 				lastCheckPoint = md.bodyStart;
 				currentElement = currentElement.add(md, 0);
 				lastIgnoredToken = -1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 5055da3..2f3ec02 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -3270,7 +3270,7 @@ public class ClassFile
 			this.contents[localContentsOffset++] = 0;
 			this.contents[localContentsOffset++] = 1;
 			if (problemLine == 0) {
-				problemLine = Util.searchLineNumber(startLineIndexes, binding.sourceStart());
+				problemLine = Util.getLineNumber(binding.sourceStart(), startLineIndexes, 0, startLineIndexes.length-1);
 			}
 			// first entry at pc = 0
 			this.contents[localContentsOffset++] = 0;
@@ -3712,7 +3712,7 @@ public class ClassFile
 			this.contents[localContentsOffset++] = 0;
 			this.contents[localContentsOffset++] = 1;
 			if (problemLine == 0) {
-				problemLine = Util.searchLineNumber(startLineIndexes, binding.sourceStart());
+				problemLine = Util.getLineNumber(binding.sourceStart(), startLineIndexes, 0, startLineIndexes.length-1);
 			}
 			// first entry at pc = 0
 			this.contents[localContentsOffset++] = 0;
@@ -4431,7 +4431,7 @@ public class ClassFile
 			localContentsOffset += 6;
 			// leave space for attribute_length and line_number_table_length
 			// Seems like do would be better, but this preserves the existing behavior.
-			index = Util.searchLineNumber(startLineIndexes, binding.sourceStart);
+			index = Util.getLineNumber(binding.sourceStart, startLineIndexes, 0, startLineIndexes.length-1);
 			contents[localContentsOffset++] = 0;
 			contents[localContentsOffset++] = 0;
 			contents[localContentsOffset++] = (byte) (index >> 8);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 480fce5..3218a92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -5765,7 +5765,7 @@ public void recordPositionsFrom(int startPC, int sourcePos, boolean widen) {
 		// resize the array pcToSourceMap
 		System.arraycopy(pcToSourceMap, 0, pcToSourceMap = new int[pcToSourceMapSize << 1], 0, pcToSourceMapSize);
 	}
-	int lineNumber = Util.searchLineNumber(lineSeparatorPositions, sourcePos);
+	int lineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, 0, lineSeparatorPositions.length-1);
 	// lastEntryPC represents the endPC of the lastEntry.
 	if (pcToSourceMapSize > 0) {
 		// in this case there is already an entry in the table
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java
index 98fb4e6..203e98d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java
@@ -16,6 +16,7 @@ import java.util.List;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
  * Parser specialized for decoding javadoc comments
@@ -358,29 +359,11 @@ public abstract class AbstractCommentParser implements JavadocTagConstants {
 	private int getLineNumber(int position) {
 	
 		if (this.scanner.linePtr != -1) {
-			return this.scanner.getLineNumber(position);
+			return Util.getLineNumber(position, this.scanner.lineEnds, 0, this.scanner.linePtr);
 		}
 		if (this.lineEnds == null)
 			return 1;
-		int length = this.lineEnds.length;
-		if (length == 0)
-			return 1;
-		int g = 0, d = length - 1;
-		int m = 0;
-		while (g <= d) {
-			m = g + (d - g) /2;
-			if (position < this.lineEnds[m]) {
-				d = m-1;
-			} else if (position > this.lineEnds[m]) {
-				g = m+1;
-			} else {
-				return m + 1;
-			}
-		}
-		if (position < this.lineEnds[m]) {
-			return m+1;
-		}
-		return m+2;
+		return Util.getLineNumber(position, this.lineEnds, 0, this.lineEnds.length-1);
 	}
 
 	private int getTokenEndPosition() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java
index b3039a3..3063cc9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java
@@ -16,6 +16,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
  * Parser specialized for decoding javadoc comments
@@ -82,8 +83,9 @@ public class JavadocParser extends AbstractCommentParser {
 			} else {
 				
 				// Parse comment
-				int firstLineNumber = this.sourceParser.scanner.getLineNumber(javadocStart);
-				int lastLineNumber = this.sourceParser.scanner.getLineNumber(javadocEnd);
+				Scanner sourceScanner = this.sourceParser.scanner;
+				int firstLineNumber = Util.getLineNumber(javadocStart, sourceScanner.lineEnds, 0, sourceScanner.linePtr);
+				int lastLineNumber = Util.getLineNumber(javadocEnd, sourceScanner.lineEnds, 0, sourceScanner.linePtr);
 				this.index = javadocStart +3;
 	
 				// scan line per line, since tags must be at beginning of lines only
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 04fb429..8350229 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -3030,8 +3030,8 @@ protected void consumeEnterVariable() {
 		if (!(this.currentElement instanceof RecoveredType)
 			&& (this.currentToken == TokenNameDOT
 				//|| declaration.modifiers != 0
-				|| (this.scanner.getLineNumber(declaration.type.sourceStart)
-						!= this.scanner.getLineNumber((int) (namePosition >>> 32))))){
+				|| (Util.getLineNumber(declaration.type.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr)
+						!= Util.getLineNumber((int) (namePosition >>> 32), this.scanner.lineEnds, 0, this.scanner.linePtr)))){
 			this.lastCheckPoint = (int) (namePosition >>> 32);
 			this.restartRecovery = true;
 			return;
@@ -4267,8 +4267,8 @@ protected void consumeMethodHeaderName(boolean isAnnotationMethod) {
 	if (this.currentElement != null){
 		if (this.currentElement instanceof RecoveredType 
 			//|| md.modifiers != 0
-			|| (this.scanner.getLineNumber(md.returnType.sourceStart)
-					== this.scanner.getLineNumber(md.sourceStart))){
+			|| (Util.getLineNumber(md.returnType.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr)
+					== Util.getLineNumber(md.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr))){
 			this.lastCheckPoint = md.bodyStart;
 			this.currentElement = this.currentElement.add(md, 0);
 			this.lastIgnoredToken = -1;
@@ -4330,8 +4330,8 @@ protected void consumeMethodHeaderNameWithTypeParameters(boolean isAnnotationMet
 		boolean isType;
 		if ((isType = this.currentElement instanceof RecoveredType) 
 			//|| md.modifiers != 0
-			|| (this.scanner.getLineNumber(md.returnType.sourceStart)
-					== this.scanner.getLineNumber(md.sourceStart))){
+			|| (Util.getLineNumber(md.returnType.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr)
+					== Util.getLineNumber(md.sourceStart, this.scanner.lineEnds, 0, this.scanner.linePtr))){
 			if(isType) {
 				((RecoveredType) this.currentElement).pendingTypeParameters = null;
 			}
@@ -7256,7 +7256,7 @@ protected void consumeToken(int type) {
 					this.scanner.getCurrentTokenSourceString(), 
 					this.scanner.startPosition, 
 					this.scanner.currentPosition - 1,
-					this.scanner.getLineNumber(this.scanner.startPosition));
+					Util.getLineNumber(this.scanner.startPosition, this.scanner.lineEnds, 0, this.scanner.linePtr));
 				this.compilationUnit.recordStringLiteral(stringLiteral);
 			} else {
 				stringLiteral = this.createStringLiteral(
@@ -8091,7 +8091,8 @@ public int flushCommentsDefinedPriorTo(int position) {
 		if (immediateCommentEnd > 0){ // only tolerating non-javadoc comments
 			// is there any line break until the end of the immediate comment ? (thus only tolerating line comment)
 			immediateCommentEnd--; // comment end in one char too far
-			if (this.scanner.getLineNumber(position) == this.scanner.getLineNumber(immediateCommentEnd)){
+			if (Util.getLineNumber(position, this.scanner.lineEnds, 0, this.scanner.linePtr) 
+					== Util.getLineNumber(immediateCommentEnd, this.scanner.lineEnds, 0, this.scanner.linePtr)){
 				position = immediateCommentEnd;
 				validCount--; // flush this comment
 				index++;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 39da840..2dae8bb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -21,6 +21,7 @@ import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class RecoveredElement {
 
@@ -210,7 +211,7 @@ public int previousAvailableLineEnd(int position){
 	Scanner scanner = parser.scanner;
 	if (scanner.lineEnds == null) return position;
 	
-	int index = scanner.getLineNumber(position);
+	int index = Util.getLineNumber(position, scanner.lineEnds, 0, scanner.linePtr);
 	if (index < 2) return position;
 	int previousLineEnd = scanner.lineEnds[index-2];
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
index 19dc7ad..2bdf6e4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
@@ -28,6 +28,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
  * Internal method structure for parsing recovery 
@@ -502,8 +503,9 @@ void attach(TypeParameter[] parameters, int startPos) {
 	int lastParameterEnd = parameters[parameters.length - 1].sourceEnd;
 	
 	Parser parser = this.parser();
-	if(parser.scanner.getLineNumber(methodDeclaration.declarationSourceStart)
-			!= parser.scanner.getLineNumber(lastParameterEnd)) return;
+	Scanner scanner = parser.scanner;
+	if(Util.getLineNumber(methodDeclaration.declarationSourceStart, scanner.lineEnds, 0, scanner.linePtr)
+			!= Util.getLineNumber(lastParameterEnd, scanner.lineEnds, 0, scanner.linePtr)) return;
 	
 	if(parser.modifiersSourceStart > lastParameterEnd
 			&& parser.modifiersSourceStart < methodDeclaration.declarationSourceStart) return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index 536160e..89a7221 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -3543,34 +3543,14 @@ public int scanNumber(boolean dotPrefix) throws InvalidInputException {
 
 	return floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;
 }
+
 /**
  * Search the line number corresponding to a specific position
  * @param position int
  * @return int
  */
 public final int getLineNumber(int position) {
-
-	if (this.lineEnds == null)
-		return 1;
-	int length = this.linePtr+1;
-	if (length == 0)
-		return 1;
-	int g = 0, d = length - 1;
-	int m = 0;
-	while (g <= d) {
-		m = g + (d - g) /2;
-		if (position < this.lineEnds[m]) {
-			d = m-1;
-		} else if (position > this.lineEnds[m]) {
-			g = m+1;
-		} else {
-			return m + 1;
-		}
-	}
-	if (position < this.lineEnds[m]) {
-		return m+1;
-	}
-	return m+2;
+	return Util.getLineNumber(position, this.lineEnds, 0, this.linePtr);
 }
 public final void setSource(char[] sourceString){
 	//the source-buffer is set to sourceString
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/LexStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/LexStream.java
index f27bb2c..25d5847 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/LexStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/LexStream.java
@@ -14,6 +14,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class LexStream implements TerminalTokens {
 	public static final int IS_AFTER_JUMP = 1;
@@ -89,7 +90,7 @@ public class LexStream implements TerminalTokens {
 						token.name = scanner.getCurrentTokenSource();
 						token.start = start;
 						token.end = end;
-						token.line = scanner.getLineNumber(end);
+						token.line = Util.getLineNumber(end, scanner.lineEnds, 0, scanner.linePtr);
 						
 						if(currentInterval != previousInterval && (intervalFlagsToSkip[currentInterval] & RangeUtil.IGNORE) == 0){
 							token.flags = IS_AFTER_JUMP;
@@ -113,7 +114,7 @@ public class LexStream implements TerminalTokens {
 					token.name = CharOperation.NO_CHAR;
 					token.start = start;
 					token.end = end;
-					token.line = scanner.getLineNumber(end);
+					token.line = Util.getLineNumber(end, scanner.lineEnds, 0, scanner.linePtr);
 					
 					tokenCache[++tokenCacheIndex % length] = token;
 					
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/AbortCompilation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/AbortCompilation.java
index 70495f0..2079436 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/AbortCompilation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/AbortCompilation.java
@@ -61,7 +61,8 @@ public class AbortCompilation extends RuntimeException {
 		if (this.problem.getSourceStart() != 0 || this.problem.getSourceEnd() != 0) return;
 		this.problem.setSourceStart(invocationSite.sourceStart());
 		this.problem.setSourceEnd(invocationSite.sourceEnd());
-		this.problem.setSourceLineNumber(Util.searchLineNumber(unitResult.getLineSeparatorPositions(), invocationSite.sourceStart()));
+		int[] lineEnds = unitResult.getLineSeparatorPositions();
+		this.problem.setSourceLineNumber(Util.getLineNumber(invocationSite.sourceStart(), lineEnds, 0, lineEnds.length-1));
 		this.compilationResult = unitResult;
 	}
 
@@ -70,7 +71,8 @@ public class AbortCompilation extends RuntimeException {
 		if (this.problem.getSourceStart() != 0 || this.problem.getSourceEnd() != 0) return;
 		this.problem.setSourceStart(astNode.sourceStart());
 		this.problem.setSourceEnd(astNode.sourceEnd());
-		this.problem.setSourceLineNumber(Util.searchLineNumber(unitResult.getLineSeparatorPositions(), astNode.sourceStart()));
+		int[] lineEnds = unitResult.getLineSeparatorPositions();
+		this.problem.setSourceLineNumber(Util.getLineNumber(astNode.sourceStart(), lineEnds, 0, lineEnds.length-1));
 		this.compilationResult = unitResult;
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
index b8af053..222d2cd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemHandler.java
@@ -100,8 +100,9 @@ public void handle(
 		}
 	}
 
+	int[] lineEnds;
 	int lineNumber = problemStartPosition >= 0
-			? Util.searchLineNumber(unitResult.getLineSeparatorPositions(), problemStartPosition)
+			? Util.getLineNumber(problemStartPosition, lineEnds = unitResult.getLineSeparatorPositions(), 0, lineEnds.length-1)
 			: 0;
 	int columnNumber = problemStartPosition >= 0
 			? Util.searchColumnNumber(unitResult.getLineSeparatorPositions(), lineNumber, problemStartPosition)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 2d2db0a..81d2dcd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -248,6 +248,28 @@ public class Util implements SuffixConstants {
 		return contents;
 	}
 	
+	public static int getLineNumber(int position, int[] lineEnds, int g, int d) {
+		if (lineEnds == null)
+			return 1;
+		if (d == -1)
+			return 1;
+		int m = g, start;
+		while (g <= d) {
+			m = g + (d - g) /2;
+			if (position < (start = lineEnds[m])) {
+				d = m-1;
+			} else if (position > start) {
+				g = m+1;
+			} else {
+				return m + 1;
+			}
+		}
+		if (position < lineEnds[m]) {
+			return m+1;
+		}
+		return m+2;
+	}
+
 	/**
 	 * Returns the contents of the given zip entry as a byte array.
 	 * @throws IOException if a problem occured reading the zip entry.
@@ -425,31 +447,6 @@ public class Util implements SuffixConstants {
 		}
 	}
 	/**
-	 * INTERNAL USE-ONLY
-	 * Search the line number corresponding to a specific position
-	 */
-	public static final int searchLineNumber(int[] startLineIndexes, int position) {
-		int length = startLineIndexes.length;
-		if (length == 0)
-			return 1;
-		int g = 0, d = length - 1;
-		int m = 0, start;
-		while (g <= d) {
-			m = d + (g - d) / 2;
-			if (position < (start = startLineIndexes[m])) {
-				d = m - 1;
-			} else if (position > start) {
-				g = m + 1;
-			} else {
-				return m + 1;
-			}
-		}
-		if (position < startLineIndexes[m]) {
-			return m + 1;
-		}
-		return m + 2;
-	}
-	/**
 	 * Converts a boolean value into Boolean.
 	 * @param bool The boolean to convert
 	 * @return The corresponding Boolean object (TRUE or FALSE).
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index 3e069b0..f4302cc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -239,6 +239,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(LineComment node) {
 		return visitNode(node);
 	}
+	public boolean visit(MarkerAnnotation node) {
+		return visitNode(node);
+	}
 	public boolean visit(MemberRef node) {
 		return visitNode(node);
 	}
@@ -455,6 +458,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(LineComment node) {
 		endVisitNode(node);
 	}
+	public void endVisit(MarkerAnnotation node) {
+		endVisitNode(node);
+	}
 	public void endVisit(MemberRef node) {
 		endVisitNode(node);
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java
index 6627dd9..9e04dce 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java
@@ -10,12 +10,11 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.dom;
 
-import java.util.HashMap;
-
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
  * Internal class for associating comments with AST nodes.
@@ -135,6 +134,19 @@ class DefaultCommentMapper {
 	}
 
 	/*
+	 * Search the line number corresponding to a specific position
+	 * between the given line range (inclusive)
+	 * @param position int
+	 * @parem lineRange size-2 int[]
+	 * @return int
+	 */
+	public final int getLineNumber(int position, int[] lineRange) {
+		int[] lineEnds = this.scanner.lineEnds;
+		int length = lineEnds.length;
+		return Util.getLineNumber(position, lineEnds, (lineRange[0] > length ? length : lineRange[0]) -1, (lineRange[1] > length ? length : lineRange[1]) - 1);
+	}
+
+	/*
 	 * Returns the extended end position of the given node.
 	 */
 	public int getExtendedEnd(ASTNode node) {
@@ -285,14 +297,14 @@ class DefaultCommentMapper {
 	 * If finally there's leading still comments, then stores indexes of the first and last one
 	 * in leading comments table.
 	 */
-	int storeLeadingComments(ASTNode node, int previousEnd) {
+	int storeLeadingComments(ASTNode node, int previousEnd, int[] parentLineRange) {
 		// Init extended position
 		int nodeStart = node.getStartPosition();
 		int extended = nodeStart;
 		
 		// Get line of node start position
-		int previousEndLine = this.scanner.getLineNumber(previousEnd);
-		int nodeStartLine = this.scanner.getLineNumber(nodeStart);
+		int previousEndLine = getLineNumber(previousEnd, parentLineRange);
+		int nodeStartLine = getLineNumber(nodeStart, parentLineRange);
 		
 		// Find first comment index
 		int idx = getCommentIndex(0, nodeStart, -1);
@@ -309,7 +321,7 @@ class DefaultCommentMapper {
 			Comment comment = this.comments[idx];
 			int commentStart = comment.getStartPosition();
 			int end = commentStart+comment.getLength()-1;
-			int commentLine = this.scanner.getLineNumber(commentStart);
+			int commentLine = getLineNumber(commentStart, parentLineRange);
 			if (end <= previousEnd || (commentLine == previousEndLine && commentLine != nodeStartLine)) {
 				// stop search on condition 1) and 2)
 				break;
@@ -360,9 +372,9 @@ class DefaultCommentMapper {
 				} catch (InvalidInputException e) {
 					// do nothing
 				}
-				int lastTokenLine = this.scanner.getLineNumber(lastTokenEnd);
+				int lastTokenLine = getLineNumber(lastTokenEnd, parentLineRange);
 				int length = this.comments.length;
-				while (startIdx<length && lastTokenLine == this.scanner.getLineNumber(this.comments[startIdx].getStartPosition()) && nodeStartLine != lastTokenLine) {
+				while (startIdx<length && lastTokenLine == getLineNumber(this.comments[startIdx].getStartPosition(), parentLineRange) && nodeStartLine != lastTokenLine) {
 					startIdx++;
 				}
 			}
@@ -405,7 +417,7 @@ class DefaultCommentMapper {
 	 * If finally there's still trailing comments, then stores indexes of the first and last one
 	 * in trailing comments table.
 	 */
-	int storeTrailingComments(ASTNode node, int nextStart,  boolean lastChild) {
+	int storeTrailingComments(ASTNode node, int nextStart,  boolean lastChild, int[] parentLineRange) {
 
 		// Init extended position
 		int nodeEnd = node.getStartPosition()+node.getLength()-1;
@@ -427,7 +439,7 @@ class DefaultCommentMapper {
 		int extended = nodeEnd;
 		
 		// Get line number
-		int nodeEndLine = this.scanner.getLineNumber(nodeEnd);
+		int nodeEndLine = getLineNumber(nodeEnd, parentLineRange);
 		
 		// Find comments range index
 		int idx = getCommentIndex(0, nodeEnd, 1);
@@ -480,7 +492,7 @@ class DefaultCommentMapper {
 				}
 			}
 			// Store index if we're on the same line than node end
-			int commentLine = this.scanner.getLineNumber(commentStart);
+			int commentLine = getLineNumber(commentStart, parentLineRange);
 			if (commentLine == nodeEndLine) {
 				sameLineIdx = idx;
 			}
@@ -491,8 +503,8 @@ class DefaultCommentMapper {
 		if (endIdx != -1) {
 			// Verify that following node start is separated
 			if (!lastChild) {
-				int nextLine = this.scanner.getLineNumber(nextStart);
-				int previousLine = this.scanner.getLineNumber(previousEnd);
+				int nextLine = getLineNumber(nextStart, parentLineRange);
+				int previousLine = getLineNumber(previousEnd, parentLineRange);
 				if((nextLine - previousLine) <= 1) {
 					if (sameLineIdx == -1) return nodeEnd;
 					endIdx = sameLineIdx;
@@ -541,20 +553,23 @@ class DefaultCommentMapper {
 
 	class CommentMapperVisitor extends DefaultASTVisitor {
 
-		HashMap waitingSiblings = new HashMap(10);
+		ASTNode topSiblingParent = null;
+		ASTNode[] siblings = new ASTNode[10];
+		int[][] parentLineRange = new int[10][];
+		int siblingPtr = -1;
 
 		protected boolean visitNode(ASTNode node) {
 
 			// Get default previous end
 			ASTNode parent = node.getParent();
 			int previousEnd = parent.getStartPosition();
-
+			
 			// Look for sibling node
-			ASTNode sibling = (ASTNode) this.waitingSiblings.get(parent);
+ 			ASTNode sibling = parent == this.topSiblingParent ? (ASTNode) this.siblings[this.siblingPtr] : null;
 			if (sibling != null) {
 				// Found one previous sibling, so compute its trailing comments using current node start position
 				try {
-					previousEnd = storeTrailingComments(sibling, node.getStartPosition(), false);
+					previousEnd = storeTrailingComments(sibling, node.getStartPosition(), false, this.parentLineRange[this.siblingPtr]);
 				} catch (Exception ex) {
 					// Give up extended ranges at this level if unexpected exception happens...
 				}
@@ -566,14 +581,37 @@ class DefaultCommentMapper {
 			}
 
 			// Compute leading comments for current node
+			int[] previousLineRange = this.siblingPtr > -1 ? this.parentLineRange[this.siblingPtr] : new int[] {1, DefaultCommentMapper.this.scanner.linePtr+1};
 			try {
-				storeLeadingComments(node, previousEnd);
+				storeLeadingComments(node, previousEnd, previousLineRange);
 			} catch (Exception ex) {
 				// Give up extended ranges at this level if unexpected exception happens...
 			}
 			
 			// Store current node as waiting sibling for its parent
-			this.waitingSiblings.put(parent, node);
+			if (this.topSiblingParent != parent) {
+				if (this.siblings.length == ++this.siblingPtr) {
+					System.arraycopy(this.siblings, 0, this.siblings = new ASTNode[this.siblingPtr*2], 0, this.siblingPtr);
+					System.arraycopy(this.parentLineRange, 0, this.parentLineRange = new int[this.siblingPtr*2][], 0, this.siblingPtr);
+				}
+				if (this.topSiblingParent == null) {
+					// node is a CompilationUnit
+					this.parentLineRange[this.siblingPtr] = previousLineRange;
+				} else {
+					int parentStart = parent.getStartPosition();
+					int firstLine = getLineNumber(parentStart, previousLineRange);
+					int lastLine = getLineNumber(parentStart + parent.getLength() - 1, previousLineRange);
+					if (this.parentLineRange[this.siblingPtr] == null) {
+						this.parentLineRange[this.siblingPtr] = new int[] {firstLine, lastLine};
+					} else {
+						int[] lineRange = this.parentLineRange[this.siblingPtr];
+						lineRange[0] = firstLine;
+						lineRange[1] = lastLine;
+					}
+				}
+				this.topSiblingParent = parent;
+			}
+			this.siblings[this.siblingPtr] = node;
 
 			// We're always ok to visit sub-levels
 			return true;
@@ -582,14 +620,20 @@ class DefaultCommentMapper {
 		protected void endVisitNode(ASTNode node) {
 
 			// Look if a child node is waiting for trailing comments computing
-			ASTNode sibling = (ASTNode) this.waitingSiblings.get(node);
+			ASTNode sibling = this.topSiblingParent == node ? (ASTNode) this.siblings[this.siblingPtr] : null;
 			if (sibling != null) {
 				try {
-					storeTrailingComments(sibling, node.getStartPosition()+node.getLength()-1, true);
+					storeTrailingComments(sibling, node.getStartPosition()+node.getLength()-1, true, this.parentLineRange[this.siblingPtr]);
 				} catch (Exception ex) {
 					// Give up extended ranges at this level if unexpected exception happens...
 				}
 			}
+			// Remove sibling if needed
+			if (this.topSiblingParent != null /*not a CompilationUnit*/
+					&& this.topSiblingParent == node) {
+				this.siblingPtr--;
+				this.topSiblingParent = node.getParent();
+			}
 		}
 
 		public boolean visit ( CompilationUnit node) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
index 9bf2f22..05f750f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
@@ -42,6 +42,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.core.*;
+import org.eclipse.jdt.internal.core.util.Util;
 
 public class SourceTypeConverter {
 	
@@ -128,7 +129,7 @@ public class SourceTypeConverter {
 		int end = topLevelTypeInfo.getNameSourceEnd();
 
 		/* convert package and imports */
-		char[] packageName = cuHandle.getParent().getElementName().toCharArray();
+		String[] packageName = ((PackageFragment) cuHandle.getParent()).names;
 		if (packageName.length > 0)
 			// if its null then it is defined in the default package
 			this.unit.currentPackage =
@@ -139,8 +140,9 @@ public class SourceTypeConverter {
 		for (int i = 0; i < importCount; i++) {
 			ImportDeclaration importDeclaration = (ImportDeclaration) importDeclarations[i];
 			ISourceImport sourceImport = (ISourceImport) importDeclaration.getElementInfo();
+			String nameWithoutStar = importDeclaration.getNameWithoutStar();
 			this.unit.imports[i] = createImportReference(
-				importDeclaration.getNameWithoutStar().toCharArray(), 
+				Util.splitOn('.', nameWithoutStar, 0, nameWithoutStar.length()), 
 				sourceImport.getDeclarationSourceStart(),
 				sourceImport.getDeclarationSourceEnd(),
 				importDeclaration.isOnDemand(),
@@ -627,16 +629,18 @@ public class SourceTypeConverter {
 	 * Build an import reference from an import name, e.g. java.lang.*
 	 */
 	private ImportReference createImportReference(
-		char[] importName,
+		String[] importName,
 		int start,
 		int end, 
 		boolean onDemand,
 		int modifiers) {
 	
-		char[][] qImportName = CharOperation.splitOn('.', importName);
-		long[] positions = new long[qImportName.length];
+		int length = importName.length;
+		long[] positions = new long[length];
 		long position = ((long) start << 32) + end;
-		for (int i = 0; i < qImportName.length; i++) {
+		char[][] qImportName = new char[length][];
+		for (int i = 0; i < length; i++) {
+			qImportName[i] = importName[i].toCharArray();
 			positions[i] = position; // dummy positions
 		}
 		return new ImportReference(
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
index bae96bf..4acbae8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
@@ -164,7 +164,8 @@ public class CommentRecorderParser extends Parser {
 			while (index<lastCommentIndex && (immediateCommentEnd = -this.scanner.commentStops[index+1])  > 0){ // only tolerating non-javadoc comments (non-javadoc comment end positions are negative)
 				// is there any line break until the end of the immediate comment ? (thus only tolerating line comment)
 				immediateCommentEnd--; // comment end in one char too far
-				if (this.scanner.getLineNumber(position) != this.scanner.getLineNumber(immediateCommentEnd)) break;
+				if (org.eclipse.jdt.internal.compiler.util.Util.getLineNumber(position, this.scanner.lineEnds, 0, this.scanner.linePtr) 
+						!= org.eclipse.jdt.internal.compiler.util.Util.getLineNumber(immediateCommentEnd, this.scanner.lineEnds, 0, this.scanner.linePtr)) break;
 				position = immediateCommentEnd;
 				validCount--; // flush this comment
 				index++;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
index 76aa2bd..4e94861 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java
@@ -65,7 +65,7 @@ public class PublicScanner implements IScanner, ITerminalSymbols {
 	public boolean scanningFloatLiteral = false;
 
 	//support for /** comments
-	public static int COMMENT_ARRAYS_SIZE = 30;
+	public final static int COMMENT_ARRAYS_SIZE = 30;
 	public int[] commentStops = new int[COMMENT_ARRAYS_SIZE];
 	public int[] commentStarts = new int[COMMENT_ARRAYS_SIZE];
 	public int[] commentTagStarts = new int[COMMENT_ARRAYS_SIZE];
@@ -3540,34 +3540,14 @@ public int scanNumber(boolean dotPrefix) throws InvalidInputException {
 
 	return floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;
 }
+
 /**
  * Search the line number corresponding to a specific position
  * @param position int
  * @return int
  */
 public final int getLineNumber(int position) {
-
-	if (this.lineEnds == null)
-		return 1;
-	int length = this.linePtr+1;
-	if (length == 0)
-		return 1;
-	int g = 0, d = length - 1;
-	int m = 0;
-	while (g <= d) {
-		m = g + (d - g) /2;
-		if (position < this.lineEnds[m]) {
-			d = m-1;
-		} else if (position > this.lineEnds[m]) {
-			g = m+1;
-		} else {
-			return m + 1;
-		}
-	}
-	if (position < this.lineEnds[m]) {
-		return m+1;
-	}
-	return m+2;
+	return Util.getLineNumber(position, this.lineEnds, 0, this.linePtr);
 }
 public final void setSource(char[] sourceString){
 	//the source-buffer is set to sourceString
