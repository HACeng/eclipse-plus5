commit dc897dd3e4818ca2b15bd3d143de606b0ce0335f
Author: Jim Desrivieres <jdesrivieres>
Date:   Thu Sep 19 22:47:57 2002 +0000

    Improve API to preserve bindings across AST modification (bug 23162)

15	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 3dd7669..180f871 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -191,9 +191,11 @@ public final class AST {
 	 * requested frivolously. The additional space is not reclaimed until the 
 	 * AST, all its nodes, and all its bindings become garbage. So it is very
 	 * important to not retain any of these objects longer than absolutely
-	 * necessary. Note that bindings can only be resolved while the AST remains
-	 * in its original unmodified state. Once the AST is modified, all 
-	 * <code>resolveBinding</code> methods return <code>null</code>.
+	 * necessary. Bindings are resolved at the time the AST is created. Subsequent
+	 * modifications to the AST do not affect the bindings returned by
+	 * <code>resolveBinding</code> methods in any way; these methods return the
+	 * same binding as before the AST was modified (including modifications
+	 * that rearrange subtrees by reparenting nodes).
 	 * If <code>resolveBindings</code> is <code>false</code>, the analysis 
 	 * does not go beyond parsing and building the tree, and all 
 	 * <code>resolveBinding</code> methods return <code>null</code> from the 
@@ -277,9 +279,11 @@ public final class AST {
 	 * requested frivolously. The additional space is not reclaimed until the 
 	 * AST, all its nodes, and all its bindings become garbage. So it is very
 	 * important to not retain any of these objects longer than absolutely
-	 * necessary. Note that bindings can only be resolved while the AST remains
-	 * in its original unmodified state. Once the AST is modified, all 
-	 * <code>resolveBinding</code> methods return <code>null</code>.
+	 * necessary. Bindings are resolved at the time the AST is created. Subsequent
+	 * modifications to the AST do not affect the bindings returned by
+	 * <code>resolveBinding</code> methods in any way; these methods return the
+	 * same binding as before the AST was modified (including modifications
+	 * that rearrange subtrees by reparenting nodes).
 	 * If the given project is <code>null</code>, the analysis 
 	 * does not go beyond parsing and building the tree, and all 
 	 * <code>resolveBinding</code> methods return <code>null</code> from the 
@@ -318,7 +322,7 @@ public final class AST {
 			throw new IllegalArgumentException();
 		}
 		if (project == null) {
-			// this just reuces to the other simplest case
+			// this just reduces to the other simplest case
 			return parseCompilationUnit(source);
 		}
 	
@@ -362,6 +366,10 @@ public final class AST {
 	 * If a syntax error is detected while parsing, the relevant node(s) of the
 	 * tree will be flagged as <code>MALFORMED</code>.
 	 * </p>
+	 * <p>
+	 * This method does not compute binding information; all <code>resolveBinding</code>
+	 * methods applied to nodes of the resulting AST return <code>null</code>.
+	 * </p>
 	 * 
 	 * @param source the string to be parsed as a Java compilation unit
 	 * @see ASTNode#getFlags()
commit 8536e94c328f058d5f377b8328af7061c65f8af1
Author: Olivier Thomann <othomann>
Date:   Thu Sep 19 23:13:15 2002 +0000

    Improve binding resolution and fix bugs for import declaration binding resolution.
    See bug 23162

96	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
25	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
176	323	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
3	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
47	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Name.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 52fc586..c656c6d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -11,7 +11,11 @@
 
 package org.eclipse.jdt.core.dom;
 
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
+
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.ast.*;
@@ -26,6 +30,8 @@ class ASTConverter {
 	private char[] compilationUnitSource;
 	private Scanner scanner;
 	private boolean resolveBindings;
+	private Set pendingThisExpressionScopeResolution;
+	private Set pendingNameScopeResolution;	
 	
 	public ASTConverter(boolean resolveBindings) {
 		this.resolveBindings = resolveBindings;
@@ -46,7 +52,8 @@ class ASTConverter {
 			recordNodes(compilationUnit, unit);
 		}
 		if (unit.currentPackage != null) {
-			compilationUnit.setPackage(convertPackage(unit.currentPackage));
+			PackageDeclaration packageDeclaration = convertPackage(unit);
+			compilationUnit.setPackage(packageDeclaration);
 		}
 		ImportReference[] imports = unit.imports;
 		if (imports != null) {
@@ -67,10 +74,14 @@ class ASTConverter {
 		if (unit.compilationResult.problemCount != 0) {
 			propagateErrors(compilationUnit, unit.compilationResult.problems, unit.compilationResult.problemCount);
 		}
+		if (resolveBindings) {
+			lookupForScopes();
+		}
 		return compilationUnit;
 	}
 	
-	public PackageDeclaration convertPackage(ImportReference importReference) {
+	public PackageDeclaration convertPackage(CompilationUnitDeclaration compilationUnitDeclaration) {
+		ImportReference importReference = compilationUnitDeclaration.currentPackage;
 		PackageDeclaration packageDeclaration = this.ast.newPackageDeclaration();
 		char[][] tokens = importReference.tokens;
 		int length = importReference.tokens.length;
@@ -88,6 +99,7 @@ class ASTConverter {
 		packageDeclaration.setName(name);
 		if (resolveBindings) {
 			recordNodes(packageDeclaration, importReference);
+			recordNodes(name, compilationUnitDeclaration);
 		}
 		return packageDeclaration;
 	}
@@ -158,6 +170,7 @@ class ASTConverter {
 		setJavaDocComment(typeDecl);
 		if (resolveBindings) {
 			recordNodes(typeDecl, typeDeclaration);
+			recordNodes(typeName, typeDeclaration);
 			typeDecl.resolveBinding();
 		}
 		return typeDecl;
@@ -303,28 +316,48 @@ class ASTConverter {
 	private QualifiedName setQualifiedNameNameAndSourceRanges(char[][] typeName, long[] positions, AstNode node) {
 		int length = typeName.length;
 		SimpleName firstToken = this.ast.newSimpleName(new String(typeName[0]));
+		firstToken.index = length - 1;
 		int start0 = (int)(positions[0]>>>32);
 		int start = start0;
 		int end = (int)(positions[0] & 0xFFFFFFFF);
 		firstToken.setSourceRange(start, end - start + 1);
 		SimpleName secondToken = this.ast.newSimpleName(new String(typeName[1]));
+		secondToken.index = length - 2;
 		start = (int)(positions[1]>>>32);
 		end = (int)(positions[1] & 0xFFFFFFFF);
 		secondToken.setSourceRange(start, end - start + 1);
 		QualifiedName qualifiedName = this.ast.newQualifiedName(firstToken, secondToken);
+		if (this.resolveBindings) {
+			recordNodes(qualifiedName, node);
+			recordPendingNameScopeResolution(qualifiedName);
+			recordNodes(firstToken, node);
+			recordNodes(secondToken, node);
+			recordPendingNameScopeResolution(firstToken);
+			recordPendingNameScopeResolution(secondToken);
+		}
+		qualifiedName.index = length - 2;
 		qualifiedName.setSourceRange(start0, end - start0 + 1);
 		SimpleName newPart = null;
 		for (int i = 2; i < length; i++) {
 			newPart = this.ast.newSimpleName(new String(typeName[i]));
+			newPart.index = length - i - 1;
 			start = (int)(positions[i]>>>32);
 			end = (int)(positions[i] & 0xFFFFFFFF);
 			newPart.setSourceRange(start,  end - start + 1);
 			qualifiedName = this.ast.newQualifiedName(qualifiedName, newPart);
+			qualifiedName.index = newPart.index;
 			qualifiedName.setSourceRange(start0, end - start0 + 1);
+			if (this.resolveBindings) {
+				recordNodes(qualifiedName, node);
+				recordNodes(newPart, node);				
+				recordPendingNameScopeResolution(qualifiedName);
+				recordPendingNameScopeResolution(newPart);
+			}
 		}
 		QualifiedName name = qualifiedName;
 		if (this.resolveBindings) {
 			recordNodes(name, node);
+			recordPendingNameScopeResolution(name);
 		}
 		return name;
 	}
@@ -339,21 +372,23 @@ class ASTConverter {
 			return convert((QualifiedThisReference) reference);
 		}  else {
 			ThisExpression thisExpression = this.ast.newThisExpression();
+			thisExpression.setSourceRange(reference.sourceStart, reference.sourceEnd - reference.sourceStart + 1);
 			if (this.resolveBindings) {
 				recordNodes(thisExpression, reference);
+				recordPendingThisExpressionScopeResolution(thisExpression);
 			}
-			thisExpression.setSourceRange(reference.sourceStart, reference.sourceEnd - reference.sourceStart + 1);
 			return thisExpression;
 		}
 	}
 
 	public ThisExpression convert(QualifiedThisReference reference) {
 		ThisExpression thisExpression = this.ast.newThisExpression();
+		thisExpression.setSourceRange(reference.sourceStart, reference.sourceEnd - reference.sourceStart + 1);
+		thisExpression.setQualifier(convert(reference.qualification));
 		if (this.resolveBindings) {
 			recordNodes(thisExpression, reference);
+			recordPendingThisExpressionScopeResolution(thisExpression);
 		}
-		thisExpression.setSourceRange(reference.sourceStart, reference.sourceEnd - reference.sourceStart + 1);
-		thisExpression.setQualifier(convert(reference.qualification));
 		return thisExpression;
 	}
 
@@ -482,11 +517,24 @@ class ASTConverter {
 		setJavaDocComment(typeDecl);
 		if (this.resolveBindings) {
 			recordNodes(typeDecl, typeDeclaration);
+			recordNodes(typeName, typeDeclaration);
 			typeDecl.resolveBinding();
 		}
 		return typeDecl;
 	}
 
+	private void completeRecord(ArrayType arrayType, AstNode astNode) {
+		ArrayType array = arrayType;
+		int dimensions = array.getDimensions();
+		for (int i = 0; i < dimensions; i++) {
+			Type componentType = array.getComponentType();
+			this.recordNodes(componentType, astNode);
+			if (componentType.isArrayType()) {
+				array = (ArrayType) componentType;
+			}
+		}
+	}
+	
 	public Type convertType(TypeReference typeReference) {
 		Type type = null;				
 		int sourceStart = -1;
@@ -507,6 +555,10 @@ class ASTConverter {
 					PrimitiveType primitiveType = this.ast.newPrimitiveType(getPrimitiveTypeCode(name));
 					primitiveType.setSourceRange(sourceStart, end - sourceStart + 1);
 					type = this.ast.newArrayType(primitiveType, dimensions);
+					if (resolveBindings) {
+						// store keys for inner types
+						completeRecord((ArrayType) type, typeReference);
+					}
 					type.setSourceRange(sourceStart, length);
 				} else {
 					SimpleName simpleName = this.ast.newSimpleName(new String(name));
@@ -522,6 +574,7 @@ class ASTConverter {
 					type = this.ast.newArrayType(simpleType, dimensions);
 					type.setSourceRange(sourceStart, length);
 					if (this.resolveBindings) {
+						completeRecord((ArrayType) type, typeReference);
 						this.recordNodes(simpleName, typeReference);
 					}
 				}
@@ -545,12 +598,15 @@ class ASTConverter {
 			long[] positions = ((QualifiedTypeReference) typeReference).sourcePositions;
 			sourceStart = (int)(positions[0]>>>32);
 			length = (int)(positions[nameLength - 1] & 0xFFFFFFFF) - sourceStart + 1;
+			Name qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference);
 			if (dimensions != 0) {
 				// need to find out if this is an array type of primitive types or not
-				Name qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference);
 				SimpleType simpleType = this.ast.newSimpleType(qualifiedName);
 				simpleType.setSourceRange(sourceStart, length);
 				type = this.ast.newArrayType(simpleType, dimensions);
+				if (this.resolveBindings) {
+					completeRecord((ArrayType) type, typeReference);
+				}				
 				int end = retrieveEndOfDimensionsPosition(sourceStart+length, this.compilationUnitSource.length);
 				if (end != -1) {
 					type.setSourceRange(sourceStart, end - sourceStart + 1);
@@ -558,7 +614,6 @@ class ASTConverter {
 					type.setSourceRange(sourceStart, length);
 				}
 			} else {
-				Name qualifiedName = this.setQualifiedNameNameAndSourceRanges(name, positions, typeReference);
 				type = this.ast.newSimpleType(qualifiedName);
 				type.setSourceRange(sourceStart, length);
 			}
@@ -663,6 +718,7 @@ class ASTConverter {
 		setJavaDocComment(methodDecl);
 		if (this.resolveBindings) {
 			recordNodes(methodDecl, methodDeclaration);
+			recordNodes(methodName, methodDeclaration);
 			methodDecl.resolveBinding();
 		}
 		return methodDecl;
@@ -918,6 +974,9 @@ class ASTConverter {
 			arrayType = (ArrayType) type;
 		} else {
 			arrayType = this.ast.newArrayType(type, dimensionsLength);
+			if (this.resolveBindings) {
+				completeRecord(arrayType, expression);
+			}			
 			int start = type.getStartPosition();
 			int end = type.getStartPosition() + type.getLength();
 			int previousSearchStart = end;
@@ -3175,5 +3234,35 @@ class ASTConverter {
 		} catch(InvalidInputException e) {
 		}
 	}
+	
+	private void recordPendingThisExpressionScopeResolution(ThisExpression thisExpression) {
+		if (this.pendingThisExpressionScopeResolution == null) {
+			this.pendingThisExpressionScopeResolution = new HashSet();
+		}
+		this.pendingThisExpressionScopeResolution.add(thisExpression);
+	}
+	
+	private void recordPendingNameScopeResolution(Name name) {
+		if (this.pendingNameScopeResolution == null) {
+			this.pendingNameScopeResolution = new HashSet();
+		}
+		this.pendingNameScopeResolution.add(name);
+	}
+	
+	private void lookupForScopes() {
+		if (this.pendingNameScopeResolution != null) {
+			for (Iterator iterator = this.pendingNameScopeResolution.iterator(); iterator.hasNext(); ) {
+				Name name = (Name) iterator.next();
+				this.ast.getBindingResolver().recordScope(name, name.lookupScope());
+			}
+		}
+		if (this.pendingThisExpressionScopeResolution != null) {
+			for (Iterator iterator = this.pendingThisExpressionScopeResolution.iterator(); iterator.hasNext(); ) {
+				ThisExpression thisExpression = (ThisExpression) iterator.next();
+				this.ast.getBindingResolver().recordScope(thisExpression, thisExpression.lookupScope());
+			}
+		}
+		
+	}
 }
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
index e6e7c55..21a50a8 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
@@ -11,6 +11,9 @@
 
 package org.eclipse.jdt.core.dom;
 
+import org.eclipse.jdt.internal.compiler.ast.AstNode;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+
 /**
  * A binding resolver is an internal mechanism for figuring out the binding
  * for a major declaration, type, or name reference.
@@ -50,7 +53,7 @@ class BindingResolver {
 	 * @param newNode the new AST node
 	 * @param oldNode the old AST node
 	 */
-	void store(ASTNode newNode, org.eclipse.jdt.internal.compiler.ast.AstNode oldASTNode) {
+	void store(ASTNode newNode, AstNode oldASTNode) {
 	}
 
 	/**
@@ -464,4 +467,25 @@ class BindingResolver {
 	 */
 	void updateKey(ASTNode node, ASTNode newNode) {
 	}
+	
+	/**
+	 * Allows the user to get information about the given old/new pair of
+	 * AST nodes.
+	 * <p>
+	 * The default implementation of this method does nothing.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *	 * @param currentNode the new node	 * @return AstNode	 */
+	AstNode getCorrespondingNode(ASTNode currentNode) {
+		return null;
+	} 
+
+	/**
+	 * This method is used to record the scope and its corresponding node.	 * <p>
+	 * The default implementation of this method does nothing.
+	 * Subclasses may reimplement.
+	 * </p>
+	 * @param astNode	 */	
+	void recordScope(ASTNode astNode, BlockScope blockScope) {
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 965eb90..1282b44 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -83,154 +83,206 @@ class DefaultBindingResolver extends BindingResolver {
 	 * Method declared on BindingResolver.
 	 */
 	IBinding resolveName(Name name) {
-		if (name instanceof QualifiedName) {
-			return this.internalResolveNameForQualifiedName(name);
-		}
-		if (name instanceof SimpleName) {
-			return this.internalResolveNameForSimpleName(name);
-		}
-		return null;
-	}
-
-	/*
-	 * Method declared on BindingResolver.
-	 */
-	ITypeBinding resolveType(Type type) {
-		// retrieve the old ast node
-		int index = 0;
-		AstNode node = (AstNode) this.newAstToOldAst.get(type);
-		if (node == null) {
-			Type arrayType = null;
-			ASTNode parentType = type.getParent();
-			if (parentType instanceof ArrayCreation) {
-				node = (AstNode) this.newAstToOldAst.get(parentType);
-			} else {
-				// we try to retrieve the type as an element type of an array type
-				while ((parentType instanceof Type) && ((Type) parentType).isArrayType()) {
-					arrayType = (Type) parentType;
-					parentType = parentType.getParent();
-					index++;
-				}
-				if (index != 0) {
-					node = (AstNode) this.newAstToOldAst.get(arrayType);
-				}
-			}
-		}
-		if (node != null) {
-			if (node instanceof TypeReference) {
-				TypeReference typeReference = (TypeReference) node;
-				if (typeReference.binding == null || !typeReference.binding.isValidBinding()) {
-					return null;
-				}
-				ITypeBinding typeBinding = this.getTypeBinding(typeReference.binding);
-				if (typeBinding == null) {
-					return null;
+		AstNode node = (AstNode) this.newAstToOldAst.get(name);
+		int index = name.index;
+		if (node instanceof QualifiedNameReference) {
+			QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) node;
+			int qualifiedNameLength = qualifiedNameReference.tokens.length;
+			int indexInQualifiedName = qualifiedNameLength - index; // one-based
+			int indexOfFirstFieldBinding = qualifiedNameReference.indexOfFirstFieldBinding; // one-based
+			int otherBindingLength = qualifiedNameLength - indexOfFirstFieldBinding;
+			if (indexInQualifiedName < indexOfFirstFieldBinding) {
+				// a extra lookup is required
+				BlockScope internalScope = (BlockScope) this.astNodesToBlockScope.get(name);
+				Binding binding = null;
+				if (internalScope == null) {
+					binding = this.scope.getTypeOrPackage(CharOperation.subarray(qualifiedNameReference.tokens, 0, indexInQualifiedName));
+				} else {
+					binding = internalScope.getTypeOrPackage(CharOperation.subarray(qualifiedNameReference.tokens, 0, indexInQualifiedName));
 				}
-				if (index != 0) {
-					if (typeBinding.isArray()) {
-						ArrayBinding arrayBinding = (ArrayBinding)typeReference.binding;
-						if (index == arrayBinding.dimensions) {
-							return this.getTypeBinding(arrayBinding.leafComponentType);
-						} else {
-							for (int i = 0; i < index; i++) {
-								arrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);
-							}
-							return this.getTypeBinding(arrayBinding);
-						}
+				if (binding != null && binding.isValidBinding()) {
+					if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
+						return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
 					} else {
-						return null;
+						// it is a type
+						return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
 					}
+				}
+				return null;
+			} else if (indexInQualifiedName == indexOfFirstFieldBinding) {
+				if (qualifiedNameReference.isTypeReference()) {
+					return this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);
 				} else {
-					if (type.isArrayType()) {
-						ArrayType array = (ArrayType) type;
-						if (typeBinding.getDimensions() != array.getDimensions()) {
-							ArrayBinding arrayBinding = (ArrayBinding)typeReference.binding;
-							for (int i = 0, max = typeBinding.getDimensions() - array.getDimensions(); i < max; i++) {
-								arrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);
-							}
-							return this.getTypeBinding(arrayBinding);
-						}
-					} else if (typeBinding.isArray() && type.isSimpleType()) {
-						return this.getTypeBinding(((ArrayBinding)typeReference.binding).leafComponentType());
+					Binding binding = qualifiedNameReference.binding;
+					if (binding != null && binding.isValidBinding()) {
+						return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) binding);				
+					} else {
+						return null;
 					}
-					return typeBinding;
 				}
-			} else if (node instanceof SingleNameReference) {
-				SingleNameReference singleNameReference = (SingleNameReference) node;
-				if (singleNameReference.binding == null || !singleNameReference.binding.isValidBinding()) {
+			} else {
+				/* This is the case for a name which is part of a qualified name that
+				 * cannot be resolved. See PR 13063.
+				 */
+				if (qualifiedNameReference.otherBindings == null || (otherBindingLength - index - 1) < 0) {
 					return null;
+				} else {
+					return this.getVariableBinding(qualifiedNameReference.otherBindings[otherBindingLength - index - 1]);				
 				}
-				if (singleNameReference.isTypeReference()) {
-					ITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)singleNameReference.binding);
-					if (typeBinding == null) {
-						return null;
+			}
+		} else if (node instanceof QualifiedTypeReference) {
+			QualifiedTypeReference qualifiedTypeReference = (QualifiedTypeReference) node;
+			if (qualifiedTypeReference.binding == null || !qualifiedTypeReference.binding.isValidBinding()) {
+				return null;
+			}
+			if (index == 0) {
+				return this.getTypeBinding(qualifiedTypeReference.binding.leafComponentType());
+			} else {
+				int qualifiedTypeLength = qualifiedTypeReference.tokens.length;
+				int indexInQualifiedName = qualifiedTypeLength - index; // one-based
+				if (indexInQualifiedName >= 0) {
+					BlockScope internalScope = (BlockScope) this.astNodesToBlockScope.get(name);
+					Binding binding = null;
+					if (internalScope == null) {
+						binding = this.scope.getTypeOrPackage(CharOperation.subarray(qualifiedTypeReference.tokens, 0, indexInQualifiedName));
+					} else {
+						binding = internalScope.getTypeOrPackage(CharOperation.subarray(qualifiedTypeReference.tokens, 0, indexInQualifiedName));
 					}
-					if (index != 0) {
-						if (typeBinding.isArray()) {
-							ArrayBinding arrayBinding = (ArrayBinding)singleNameReference.binding;
-							if (index == arrayBinding.dimensions) {
-								return this.getTypeBinding(arrayBinding.leafComponentType);
-							} else {
-								for (int i = 0; i < index; i++) {
-									arrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);
-								}
-								return this.getTypeBinding(arrayBinding);
-							}
+					if (binding != null && binding.isValidBinding()) {
+						if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
+							return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
 						} else {
-							return null;
+							// it is a type
+							return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
 						}
-					} else {
-						return typeBinding;
 					}
-				} else {
-					// it should be a type reference
-					return null;
 				}
-			} else if (node instanceof QualifiedNameReference) {
-				QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) node;
-				if (qualifiedNameReference.isTypeReference()) {
-					if (qualifiedNameReference.binding == null || !qualifiedNameReference.binding.isValidBinding()) {
-						return null;
-					}
-					ITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);
-					if (typeBinding == null) {
-						return null;
-					} 
-					if (index != 0) {
-						if (typeBinding.isArray()) {
-							ArrayBinding arrayBinding = (ArrayBinding)qualifiedNameReference.binding;
-							if (index == arrayBinding.dimensions) {
-								return this.getTypeBinding(arrayBinding.leafComponentType);
-							} else {
-								for (int i = 0; i < index; i++) {
-									arrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);
-								}
-							}
-							return this.getTypeBinding(arrayBinding);
-						} else {
-							return null;
-						}
+			}
+		} else if (node instanceof ImportReference) {
+			ImportReference importReference = (ImportReference) node;
+			int importReferenceLength = importReference.tokens.length;
+			int indexInImportReference = importReferenceLength - index; // one-based
+			if (indexInImportReference >= 0) {
+				Binding binding = this.scope.getTypeOrPackage(CharOperation.subarray(importReference.tokens, 0, indexInImportReference));
+				if (binding != null && binding.isValidBinding()) {
+					if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
+						return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
 					} else {
-						return typeBinding;
+						// it is a type
+						return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
 					}
+				}
+			}
+		} else if (node instanceof CompilationUnitDeclaration) {
+			CompilationUnitDeclaration compilationUnitDeclaration = (CompilationUnitDeclaration) node;
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;
+			if (types == null || types.length == 0) {
+				return null;
+			}
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration type = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) types[0];
+			if (type != null) {
+				ITypeBinding typeBinding = this.getTypeBinding(type.binding);
+				if (typeBinding == null) {
+					return null;
+				}
+				return typeBinding.getPackage();
+			}
+		} else if (node instanceof AbstractMethodDeclaration) {
+			AbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;
+			if (methodDeclaration != null) {
+				IMethodBinding methodBinding = this.getMethodBinding(methodDeclaration.binding);
+				if (methodBinding == null) {
+					return null;
+				}
+				this.bindingsToAstNodes.put(methodBinding, node);
+				return methodBinding;
+			}
+		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;
+			ITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);
+			if (typeBinding == null) {
+				return null;
+			}
+			this.bindingsToAstNodes.put(typeBinding, node);
+			return typeBinding;
+		} if (node instanceof SingleNameReference) {
+			SingleNameReference singleNameReference = (SingleNameReference) node;
+			if (singleNameReference.isTypeReference()) {
+				return this.getTypeBinding((ReferenceBinding)singleNameReference.binding);
+			} else {
+				// this is a variable or a field
+				Binding binding = singleNameReference.binding;
+				if (binding != null && binding.isValidBinding()) {
+					return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) binding);				
 				} else {
-					// it should be a type reference
 					return null;
 				}
+			}
+		} else if (node instanceof QualifiedSuperReference) {
+			QualifiedSuperReference qualifiedSuperReference = (QualifiedSuperReference) node;
+			return this.getTypeBinding(qualifiedSuperReference.qualification.binding);
+		} else if (node instanceof LocalDeclaration) {
+			return this.getVariableBinding(((LocalDeclaration)node).binding);
+		} else if (node instanceof FieldReference) {
+			return getVariableBinding(((FieldReference) node).binding);
+		} else if (node instanceof SingleTypeReference) {
+			SingleTypeReference singleTypeReference = (SingleTypeReference) node;
+			org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding = singleTypeReference.binding;
+			if (binding == null || !binding.isValidBinding()) {
+				return null;
+			}
+			return this.getTypeBinding(binding.leafComponentType());
+		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) {
+			org.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration = (org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) node;
+			return this.getVariableBinding(fieldDeclaration.binding);
+		} else if (node instanceof MessageSend) {
+			MessageSend messageSend = (MessageSend) node;
+			return getMethodBinding(messageSend.binding);
+		}
+		return null;
+	}
+
+	/*
+	 * Method declared on BindingResolver.
+	 */
+	ITypeBinding resolveType(Type type) {
+		// retrieve the old ast node
+		AstNode node = (AstNode) this.newAstToOldAst.get(type);
+		org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding = null;
+		if (node != null) {
+			if (node instanceof TypeReference) {
+				TypeReference typeReference = (TypeReference) node;
+				binding = typeReference.binding;
+			} else if (node instanceof SingleNameReference && ((SingleNameReference)node).isTypeReference()) {
+				binding = (org.eclipse.jdt.internal.compiler.lookup.TypeBinding) (((SingleNameReference)node).binding);
+			} else if (node instanceof QualifiedNameReference && ((QualifiedNameReference)node).isTypeReference()) {
+				binding = (org.eclipse.jdt.internal.compiler.lookup.TypeBinding) (((QualifiedNameReference)node).binding);
 			} else if (node instanceof ArrayAllocationExpression) {
-				ArrayAllocationExpression arrayAllocationExpression = (ArrayAllocationExpression) node;
-				ArrayBinding arrayBinding = arrayAllocationExpression.arrayTb;
-				if (arrayBinding == null || !arrayBinding.isValidBinding()) {
-					return null;
+				binding = ((ArrayAllocationExpression) node).arrayTb;
+			}
+			if (binding == null || !binding.isValidBinding()) {
+				return null;
+			}
+			if (type.isArrayType()) {
+				ArrayType arrayType = (ArrayType) type;
+				if (binding.isArrayType()) {
+					ArrayBinding arrayBinding = (ArrayBinding) binding;
+					return getTypeBinding(this.scope.createArray(arrayBinding.leafComponentType, arrayType.getDimensions()));
+				} else {
+					return getTypeBinding(this.scope.createArray(binding, arrayType.getDimensions()));
+				}
+			} else {
+				if (binding.isArrayType()) {
+					ArrayBinding arrayBinding = (ArrayBinding) binding;
+					return getTypeBinding(arrayBinding.leafComponentType);
+				} else {
+					return getTypeBinding(binding);
 				}
-				if (index != 0) {
-					return this.getTypeBinding(this.scope.createArray(arrayBinding.leafComponentType, arrayBinding.dimensions - index));
-				} 
-				return this.getTypeBinding(arrayBinding);
 			}
 		}
 		return null;
 	}
+	
 	/*
 	 * Method declared on BindingResolver.
 	 */
@@ -648,205 +700,6 @@ class DefaultBindingResolver extends BindingResolver {
 		return binding;
 	}
 	
-	private IBinding internalResolveNameForQualifiedName(Name name) {
-		QualifiedName qualifiedName = (QualifiedName) name;
-		ASTNode parent = qualifiedName.getParent();
-		int index = 0;
-		while (parent instanceof QualifiedName) {
-			qualifiedName = (QualifiedName) parent;
-			parent = parent.getParent();
-			index++;
-		}
-		return returnBindingForQualifiedNamePart(qualifiedName, index);
-	}
-
-	private IBinding returnBindingForQualifiedNamePart(ASTNode currentNode, int index) {
-		// now we can retrieve the compiler's node
-		if (!(currentNode instanceof QualifiedName)) {
-			return null;
-		}
-		QualifiedName qualifiedName = (QualifiedName) currentNode;
-		AstNode node = (AstNode) this.newAstToOldAst.get(qualifiedName);
-		if (node instanceof QualifiedNameReference) {
-			QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) node;
-			int qualifiedNameLength = qualifiedNameReference.tokens.length;
-			int indexInQualifiedName = qualifiedNameLength - index; // one-based
-			int indexOfFirstFieldBinding = qualifiedNameReference.indexOfFirstFieldBinding; // one-based
-			int otherBindingLength = qualifiedNameLength - indexOfFirstFieldBinding;
-			if (indexInQualifiedName < indexOfFirstFieldBinding) {
-				// a extra lookup is required
-				BlockScope internalScope = (BlockScope) this.astNodesToBlockScope.get(qualifiedName);
-				Binding binding = null;
-				if (internalScope == null) {
-					binding = this.scope.getTypeOrPackage(CharOperation.subarray(qualifiedNameReference.tokens, 0, indexInQualifiedName));
-				} else {
-					binding = internalScope.getTypeOrPackage(CharOperation.subarray(qualifiedNameReference.tokens, 0, indexInQualifiedName));
-				}
-				if (binding != null && binding.isValidBinding()) {
-					if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
-						return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
-					} else {
-						// it is a type
-						return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
-					}
-				}
-				return null;
-			} else if (indexInQualifiedName == indexOfFirstFieldBinding) {
-				if (qualifiedNameReference.isTypeReference()) {
-					return this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);
-				} else {
-					Binding binding = qualifiedNameReference.binding;
-					if (binding != null && binding.isValidBinding()) {
-						return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) binding);				
-					} else {
-						return null;
-					}
-				}
-			} else {
-				/* This is the case for a name which is part of a qualified name that
-				 * cannot be resolved. See PR 13063.
-				 */
-				if (qualifiedNameReference.otherBindings == null || (otherBindingLength - index - 1) < 0) {
-					return null;
-				} else {
-					return this.getVariableBinding(qualifiedNameReference.otherBindings[otherBindingLength - index - 1]);				
-				}
-			}
-		} else if (node instanceof QualifiedTypeReference) {
-			QualifiedTypeReference qualifiedTypeReference = (QualifiedTypeReference) node;
-			if (qualifiedTypeReference.binding == null || !qualifiedTypeReference.binding.isValidBinding()) {
-				return null;
-			}
-			if (index == 0) {
-				return this.getTypeBinding(qualifiedTypeReference.binding.leafComponentType());
-			} else {
-				int qualifiedTypeLength = qualifiedTypeReference.tokens.length;
-				int indexInQualifiedName = qualifiedTypeLength - index; // one-based
-				if (indexInQualifiedName >= 0) {
-					BlockScope internalScope = (BlockScope) this.astNodesToBlockScope.get(qualifiedName);
-					Binding binding = null;
-					if (internalScope == null) {
-						binding = this.scope.getTypeOrPackage(CharOperation.subarray(qualifiedTypeReference.tokens, 0, indexInQualifiedName));
-					} else {
-						binding = internalScope.getTypeOrPackage(CharOperation.subarray(qualifiedTypeReference.tokens, 0, indexInQualifiedName));
-					}
-					if (binding != null && binding.isValidBinding()) {
-						if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
-							return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
-						} else {
-							// it is a type
-							return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
-						}
-					}
-				}
-			}
-		} else if (node instanceof ImportReference) {
-			ImportReference importReference = (ImportReference) node;
-			int importReferenceLength = importReference.tokens.length;
-			int indexInImportReference = importReferenceLength - index; // one-based
-			if (indexInImportReference >= 0) {
-				Binding binding = this.scope.getTypeOrPackage(CharOperation.subarray(importReference.tokens, 0, indexInImportReference));
-				if (binding != null && binding.isValidBinding()) {
-					if (binding instanceof org.eclipse.jdt.internal.compiler.lookup.PackageBinding) {
-						return this.getPackageBinding((org.eclipse.jdt.internal.compiler.lookup.PackageBinding)binding);
-					} else {
-						// it is a type
-						return this.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding)binding);
-					}
-				}
-			}
-		}
-		return null;
-	}
-
-	private IBinding internalResolveNameForSimpleName(Name name) {
-		AstNode node = (AstNode) this.newAstToOldAst.get(name);
-		if (node == null) {
-			ASTNode parent = name.getParent();
-			if (parent instanceof QualifiedName) {
-				// retrieve the qualified name and remember at which position is the simple name
-				QualifiedName qualifiedName = (QualifiedName) parent;
-				int index = -1;
-				if (qualifiedName.getQualifier() == name) {
-					index++;
-				}
-				while (parent instanceof QualifiedName) {
-					qualifiedName = (QualifiedName) parent;
-					parent = parent.getParent();
-					index++;
-				}
-				return returnBindingForQualifiedNamePart(qualifiedName, index);
-			}
-		}
-		if (node instanceof CompilationUnitDeclaration) {
-			CompilationUnitDeclaration compilationUnitDeclaration = (CompilationUnitDeclaration) node;
-			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;
-			if (types == null || types.length == 0) {
-				return null;
-			}
-			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration type = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) types[0];
-			if (type != null) {
-				ITypeBinding typeBinding = this.getTypeBinding(type.binding);
-				if (typeBinding == null) {
-					return null;
-				}
-				return typeBinding.getPackage();
-			}
-		} else if (node instanceof AbstractMethodDeclaration) {
-			AbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;
-			if (methodDeclaration != null) {
-				IMethodBinding methodBinding = this.getMethodBinding(methodDeclaration.binding);
-				if (methodBinding == null) {
-					return null;
-				}
-				this.bindingsToAstNodes.put(methodBinding, node);
-				return methodBinding;
-			}
-		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {
-			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;
-			ITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);
-			if (typeBinding == null) {
-				return null;
-			}
-			this.bindingsToAstNodes.put(typeBinding, node);
-			return typeBinding;
-		} if (node instanceof SingleNameReference) {
-			SingleNameReference singleNameReference = (SingleNameReference) node;
-			if (singleNameReference.isTypeReference()) {
-				return this.getTypeBinding((ReferenceBinding)singleNameReference.binding);
-			} else {
-				// this is a variable or a field
-				Binding binding = singleNameReference.binding;
-				if (binding != null && binding.isValidBinding()) {
-					return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) binding);				
-				} else {
-					return null;
-				}
-			}
-		} else if (node instanceof QualifiedSuperReference) {
-			QualifiedSuperReference qualifiedSuperReference = (QualifiedSuperReference) node;
-			return this.getTypeBinding(qualifiedSuperReference.qualification.binding);
-		} else if (node instanceof LocalDeclaration) {
-			return this.getVariableBinding(((LocalDeclaration)node).binding);
-		} else if (node instanceof FieldReference) {
-			return getVariableBinding(((FieldReference) node).binding);
-		} else if (node instanceof SingleTypeReference) {
-			SingleTypeReference singleTypeReference = (SingleTypeReference) node;
-			org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding = singleTypeReference.binding;
-			if (binding == null || !binding.isValidBinding()) {
-				return null;
-			}
-			return this.getTypeBinding(binding.leafComponentType());
-		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) {
-			org.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration = (org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) node;
-			return this.getVariableBinding(fieldDeclaration.binding);
-		} else if (node instanceof MessageSend) {
-			MessageSend messageSend = (MessageSend) node;
-			return getMethodBinding(messageSend.binding);
-		}
-		return null;
-	}
-	
 	/*
 	 * @see BindingResolver#resolveConstructor(ClassInstanceCreation)
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index e77b66f..86e19eb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -170,7 +170,9 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (visitChildren) {
 			// visit children in normal left to right reading order
 			acceptChild(visitor, getJavadoc());
-			acceptChild(visitor, getReturnType());
+			if (!isConstructor) {
+				acceptChild(visitor, getReturnType());
+			}
 			acceptChild(visitor, getName());
 			acceptChildren(visitor, parameters);
 			acceptChildren(visitor, thrownExceptions);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Name.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Name.java
index 10e3f6b..5624518 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Name.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Name.java
@@ -11,6 +11,9 @@
 
 package org.eclipse.jdt.core.dom;
 
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+
 /**
  * Abstract base class for all AST nodes that represent names.
  * There are exactly two kinds of name: simple ones 
@@ -28,6 +31,11 @@ package org.eclipse.jdt.core.dom;
 public abstract class Name extends Expression {
 	
 	/**
+	 * This index reprensents the position inside a qualified name.
+	 */
+	int index;
+	
+	/**
 	 * Creates a new AST node for a name owned by the given AST.
 	 * <p>
 	 * N.B. This constructor is package-private.
@@ -74,4 +82,43 @@ public abstract class Name extends Expression {
 	public final IBinding resolveBinding() {
 		return getAST().getBindingResolver().resolveName(this);
 	}
+
+	BlockScope lookupScope() {
+		ASTNode currentNode = this;
+		while(currentNode != null
+			&&!(currentNode instanceof MethodDeclaration)
+			&& !(currentNode instanceof Initializer)
+			&& !(currentNode instanceof FieldDeclaration)) {
+			currentNode = currentNode.getParent();
+		}
+		if (currentNode == null) {
+			return null;
+		}
+		if (currentNode instanceof Initializer) {
+			Initializer initializer = (Initializer) currentNode;
+			while(!(currentNode instanceof TypeDeclaration)) {
+				currentNode = currentNode.getParent();
+			}
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+			if ((initializer.getModifiers() & Modifier.STATIC) != 0) {
+				return typeDecl.staticInitializerScope;
+			} else {
+				return typeDecl.initializerScope;
+			}
+		} else if (currentNode instanceof FieldDeclaration) {
+			FieldDeclaration fieldDeclaration = (FieldDeclaration) currentNode;
+			while(!(currentNode instanceof TypeDeclaration)) {
+				currentNode = currentNode.getParent();
+			}
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+			if ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {
+				return typeDecl.staticInitializerScope;
+			} else {
+				return typeDecl.initializerScope;
+			}
+		}
+		AbstractMethodDeclaration abstractMethodDeclaration = (AbstractMethodDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+		return abstractMethodDeclaration.scope;
+	}	
+	
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
index e273eba..ac8be90 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
@@ -11,6 +11,7 @@
 
 package org.eclipse.jdt.core.dom;
 
+
 /**
  * AST node for a qualified name. A qualified name is defined recursively
  * as a simple name preceded by a name, which qualifies it. Expressing it this
@@ -37,8 +38,7 @@ public class QualifiedName extends Name {
 	 * Java identifier.
 	 */
 	private Name qualifier = null;
-	
-	/**
+		/**
 	 * The name being qualified; lazily initialized; defaults to a unspecified,
 	 * legal Java identifier.
 	 */
commit c211427b1cf2916619f7e5e3c49d8ed0818b7738
Author: Olivier Thomann <othomann>
Date:   Thu Sep 19 23:14:06 2002 +0000

    Improve binding resolution and fix bugs for import declaration binding resolution.
    See bug 23162

1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleName.java
41	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ThisExpression.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
index ac8be90..9942c48 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedName.java
@@ -169,7 +169,7 @@ public class QualifiedName extends Name {
 	 * Method declared on ASTNode.
 	 */
 	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
+		return BASE_NODE_SIZE + 3 * 4;
 	}
 	
 	/* (omit javadoc for this method)
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleName.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleName.java
index 603e809..9e23857 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleName.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleName.java
@@ -187,7 +187,7 @@ public class SimpleName extends Name {
 	int memSize() {
 		int size = BASE_NODE_SIZE + 1 * 4;
 		if (identifier != null) {
-			size += HEADERS + 2 * 4 + HEADERS + 2 * identifier.length();
+			size += HEADERS + 3 * 4 + HEADERS + 2 * identifier.length();
 		}
 		return size;
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ThisExpression.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ThisExpression.java
index 1e45970..cfb83a5 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ThisExpression.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ThisExpression.java
@@ -11,6 +11,9 @@
 
 package org.eclipse.jdt.core.dom;
 
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+
 /**
  * Simple or qualified "this" AST node type.
  *
@@ -122,4 +125,42 @@ public class ThisExpression extends Expression {
 			memSize()
 			+ (optionalQualifier == null ? 0 : getQualifier().treeSize());
 	}
+
+	BlockScope lookupScope() {
+		ASTNode currentNode = this;
+		while(currentNode != null
+			&&!(currentNode instanceof MethodDeclaration)
+			&& !(currentNode instanceof Initializer)
+			&& !(currentNode instanceof FieldDeclaration)) {
+			currentNode = currentNode.getParent();
+		}
+		if (currentNode == null) {
+			return null;
+		}
+		if (currentNode instanceof Initializer) {
+			Initializer initializer = (Initializer) currentNode;
+			while(!(currentNode instanceof TypeDeclaration)) {
+				currentNode = currentNode.getParent();
+			}
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+			if ((initializer.getModifiers() & Modifier.STATIC) != 0) {
+				return typeDecl.staticInitializerScope;
+			} else {
+				return typeDecl.initializerScope;
+			}
+		} else if (currentNode instanceof FieldDeclaration) {
+			FieldDeclaration fieldDeclaration = (FieldDeclaration) currentNode;
+			while(!(currentNode instanceof TypeDeclaration)) {
+				currentNode = currentNode.getParent();
+			}
+			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDecl = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+			if ((fieldDeclaration.getModifiers() & Modifier.STATIC) != 0) {
+				return typeDecl.staticInitializerScope;
+			} else {
+				return typeDecl.initializerScope;
+			}
+		}
+		AbstractMethodDeclaration abstractMethodDeclaration = (AbstractMethodDeclaration) this.getAST().getBindingResolver().getCorrespondingNode(currentNode);
+		return abstractMethodDeclaration.scope;
+	}	
 }
