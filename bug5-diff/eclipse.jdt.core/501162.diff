commit 172a553a3616e67e2ed139a28d41a9dbf8b98c43
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Thu Apr 13 15:01:07 2017 +0530

    Fix (second) fix for bug 501162 [9][search] find constructs in
    module-info
    
    Change-Id: If4bcb863ff1f5fda77337515213d0e357bf35ae1

14	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
169	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
6	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
16	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageExport.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
45	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleDeclarationMatch.java
14	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
15	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
148	22	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
36	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
26	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
88	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
121	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModulePattern.java
16	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
index 387a787..9d43695 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -316,7 +320,12 @@ public class AbstractJavaSearchTests extends ModifyingResourceTests implements I
 					this.line.append("]");
 				}
 				ICompilationUnit unit = null;
-				if (element instanceof IMethod) {
+				if (element instanceof IModuleDescription) {
+					IModuleDescription md = (IModuleDescription) element;
+					this.line.append(" ");
+					append(md);
+					unit = md.getCompilationUnit();
+				} else if (element instanceof IMethod) {
 					this.line.append(" ");
 					IMethod method = (IMethod)element;
 					append(method);
@@ -596,6 +605,9 @@ public class AbstractJavaSearchTests extends ModifyingResourceTests implements I
 			}
 			this.line.append(")");
 		}
+		private void append(IModuleDescription md) {
+			this.line.append(md.getElementName());
+		}
 		private void append(IPackageFragment pkg) {
 			this.line.append(pkg.getElementName());
 		}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index 5d20e3b..7312870 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -20,6 +20,7 @@ import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.ILocalVariable;
+import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
@@ -28,6 +29,7 @@ import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.core.search.ReferenceMatch;
 import org.eclipse.jdt.core.search.SearchEngine;
 import org.eclipse.jdt.core.search.SearchMatch;
+import org.eclipse.jdt.core.search.SearchPattern;
 import org.eclipse.jdt.core.search.TypeReferenceMatch;
 import junit.framework.Test;
 
@@ -38,7 +40,7 @@ public class JavaSearchBugs9Tests extends AbstractJavaSearchTests {
 
 	static {
 //	 org.eclipse.jdt.internal.core.search.BasicSearchEngine.VERBOSE = true;
-//	TESTS_NAMES = new String[] {"testBug501162_003"};
+//	TESTS_NAMES = new String[] {"testBug501162_001"};
 }
 
 public JavaSearchBugs9Tests(String name) {
@@ -325,6 +327,172 @@ public void testBug501162_003() throws Exception {
 		deleteProject("second");
 	}
 }
+public void testBug501162_005() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/module-info.java",
+			"module first {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n"
+			);
+	String str = this.workingCopies[0].getSource();
+	String selection = "first";
+	int start = str.indexOf(selection);
+	int length = selection.length();
+	
+	IJavaElement[] elements = this.workingCopies[0].codeSelect(start, length);
+	IModuleDescription module = (IModuleDescription) elements[0];
+	search(module, ALL_OCCURRENCES, EXACT_RULE);
+	assertSearchResults(	
+			"src/module-info.java first [first] EXACT_MATCH");
+}
+public void testBug501162_006() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 implements pack22.I22{}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    exports pack22 to first;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+		createFolder("/second/src/pack1");
+		createFile("/second/src/pack1/I22.java",
+				"package pack22;\n" +
+				"public interface I22 {}\n");
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+
+		SearchPattern pattern = SearchPattern.createPattern("first", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+			"src/module-info.java [first] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
+public void testBug501162_007() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first.test.org {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 implements pack22.I22{}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    exports pack22 to first.test.org;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+		createFolder("/second/src/pack1");
+		createFile("/second/src/pack1/I22.java",
+				"package pack22;\n" +
+				"public interface I22 {}\n");
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+
+		SearchPattern pattern = SearchPattern.createPattern("first.test.org", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[] {getJavaProject("JavaSearchBugs9")});
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+			"src/module-info.java [first.test.org] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
+public void testBug501162_008() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 implements pack22.I22{}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    exports pack22 to first;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+		createFolder("/second/src/pack1");
+		createFile("/second/src/pack1/I22.java",
+				"package pack22;\n" +
+				"public interface I22 {}\n");
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+
+		SearchPattern pattern = SearchPattern.createPattern("second", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+			"src/module-info.java [second] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
 
 // Add more tests here
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
index 3d9e166..bb36ec0 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,4 +23,9 @@ public class SelectionOnModuleDeclaration extends ModuleDeclaration {
 	public SelectionOnModuleDeclaration(CompilationResult compilationResult, char[][] tokens, long[] positions) {
 		super(compilationResult, tokens, positions);
 	}
+	public void resolve() {
+		super.resolve();
+		throw new SelectionNodeFound(this.moduleBinding);
+	}
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
index 6a34cbc..62114c5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@ public class ModuleReference extends ASTNode {
 	public char[][] tokens;
 	public long[] sourcePositions; //each entry is using the code : (start<<32) + end
 	public char[] moduleName;
+	ModuleBinding binding = null;
 
 	public ModuleReference(char[][] tokens, long[] sourcePositions) {
 		this.tokens = tokens;
@@ -42,10 +43,9 @@ public class ModuleReference extends ASTNode {
 	}
 
 	public ModuleBinding resolve(Scope scope) {
-		ModuleBinding binding = null;
-		if ((binding = scope.environment().getModule(this.moduleName)) == null) {
+		if (scope != null && (this.binding = scope.environment().getModule(this.moduleName)) == null) {
 			scope.problemReporter().invalidModule(this);
 		}
-		return binding;
+		return this.binding;
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
index 847fbc6..b1a8138 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -51,6 +51,7 @@ public abstract class PackageVisibilityStatement extends ModuleStatement {
 					scope.problemReporter().duplicateModuleReference(IProblem.DuplicateModuleRef, ref);
 					errorsExist = true;
 				} else {
+					ref.resolve(scope.compilationUnitScope());
 					modules.put(ref.moduleName, ref);
 				}
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 206d0c1..635cb57 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -1136,7 +1136,7 @@ public class NameLookup implements SuffixConstants {
 		return type == null ? null : new Answer(type, null, null);
 	}
 
-	public IModule getModuleDescriptionInfo(IModuleDescription moduleDesc) {
+	public static IModule getModuleDescriptionInfo(IModuleDescription moduleDesc) {
 		if (moduleDesc != null) {
 			try {
 				if (moduleDesc instanceof BinaryModule) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageExport.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageExport.java
index efe4284..f783278 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageExport.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageExport.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
+ * Copyright (c) 2016, 2017 IBM Corporation.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -46,6 +46,21 @@ public class PackageExport extends SourceRefElement implements IModuleDescriptio
 	public String toString() {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append(this.pack);
+		String[] s;
+		try {
+			s = getTargetModules();
+			if (s != null && s.length > 0) {
+				buffer.append(" to "); //$NON-NLS-1$
+				int l = s.length - 1;
+				for (int i = 0; i < l; ++i) {
+					buffer.append(s[i] + ',');
+				}
+				buffer.append(s[l]);  // no comma
+			}
+		} catch (JavaModelException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 		buffer.append(';');
 		return buffer.toString();
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index 3da3eb4..f3a28c1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -776,7 +776,7 @@ public class SearchableEnvironment
 		NameLookup.Answer answer = this.nameLookup.findModule(CharOperation.charToString(name));
 		IModule module = null;
 		if (answer != null) {
-			module = this.nameLookup.getModuleDescriptionInfo(answer.module);
+			module = NameLookup.getModuleDescriptionInfo(answer.module);
 		}
 		return module;
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index d3ae218..f1fc8ff 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -38,7 +38,7 @@ public abstract class ClasspathLocation implements IModuleEnvironment {
 		return findClass(fileName, qualifiedPackageName, qualifiedBinaryFileName, asBinaryOnly);
 	}
 	public void setModule (IModule mod) {
-		// do nothing
+		this.module = mod;
 	}
 	static ClasspathLocation forSourceFolder(IContainer sourceFolder, IContainer outputFolder,
 			char[][] inclusionPatterns, char[][] exclusionPatterns, boolean ignoreOptionalProblems,
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleDeclarationMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleDeclarationMatch.java
new file mode 100644
index 0000000..218fa12
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleDeclarationMatch.java
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.search;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.jdt.core.IJavaElement;
+
+/**
+ * A Java search match that represents a module declaration.
+ * The element is an <code>IType</code>.
+ * <p>
+ * This class is intended to be instantiated and subclassed by clients.
+ * </p>
+ *
+ * @since 3.13
+ */
+public class ModuleDeclarationMatch extends SearchMatch {
+
+	/**
+	 * Creates a new type declaration match.
+	 *
+	 * @param element the module declaration
+	 * @param accuracy one of A_ACCURATE or A_INACCURATE
+	 * @param offset the offset the match starts at, or -1 if unknown
+	 * @param length the length of the match, or -1 if unknown
+	 * @param participant the search participant that created the match
+	 * @param resource the resource of the element
+	 */
+	public ModuleDeclarationMatch(IJavaElement element, int accuracy, int offset, int length, SearchParticipant participant, IResource resource) {
+		super(element, accuracy, offset, length, participant, resource);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
index 7975107..b361fe4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -1373,6 +1377,10 @@ private static SearchPattern createMethodOrConstructorPattern(String patternStri
 	}
 }
 
+private static SearchPattern createModulePattern(String patternString, int limitTo, int matchRule) {
+	return new ModulePattern(patternString.toCharArray(), limitTo, matchRule);
+}
+
 /**
  * Returns a search pattern that combines the given two patterns into an
  * "or" pattern. The search result will match either the left pattern or the
@@ -1640,6 +1648,8 @@ public static SearchPattern createPattern(String stringPattern, int searchFor, i
 			return createFieldPattern(stringPattern, limitTo, matchRule);
 		case IJavaSearchConstants.PACKAGE:
 			return createPackagePattern(stringPattern, limitTo, matchRule);
+		case IJavaElement.JAVA_MODULE :
+			return createModulePattern(stringPattern, limitTo, matchRule);
 	}
 	return null;
 }
@@ -2113,6 +2123,9 @@ public static SearchPattern createPattern(IJavaElement element, int limitTo, int
 		case IJavaElement.PACKAGE_FRAGMENT :
 			searchPattern = createPackagePattern(element.getElementName(), maskedLimitTo, matchRule);
 			break;
+		case IJavaElement.JAVA_MODULE :
+			searchPattern = createModulePattern(element.getElementName(), maskedLimitTo, matchRule);
+			break;
 	}
 	if (searchPattern != null)
 		MatchLocator.setFocus(searchPattern, element);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 7cda601..b72d039 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -217,7 +217,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		addIndexEntry(METHOD_REF, MethodPattern.createIndexKey(methodName, argCount));
 	}
 	public void addModuleDeclaration(char[] moduleName) {
-		addIndexEntry(MODULE_DECL, moduleName);
+		addIndexEntry(MODULE_DECL, ModulePattern.createIndexKey(moduleName));
 	}
 	public void addModuleExportedPackages(char[] packageName) {
 		char[][] tokens = CharOperation.splitOn('.', packageName);
@@ -225,7 +225,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 			addNameReference(tokens[i]);
 	}
 	public void addModuleReference(char[] moduleName) {
-		addIndexEntry(MODULE_REF, moduleName);
+		addIndexEntry(MODULE_REF, ModulePattern.createIndexKey(moduleName));
 	}
 	public void addNameReference(char[] name) {
 		addIndexEntry(REF, name);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
index 27f1ad5..3341006 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -71,4 +71,5 @@ public interface IIndexConstants {
 	int TYPE_PARAM_PATTERN = 0x0400;
 	int AND_PATTERN = 0x0800;
 	int ANNOT_REF_PATTERN = 0x1000;
+	int MODULE_PATTERN = 0x2000;
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index 27941fd..bea768f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -316,7 +316,7 @@ public void enterModule(ModuleInfo moduleInfo) {
 			if (packInfo == null || packInfo.pkgName == null || packInfo.pkgName.equals(CharOperation.NO_CHAR)) continue;
 			this.indexer.addModuleExportedPackages(packInfo.pkgName);
 			char[][] tgt = packInfo.targets;
-			if (tgt != null && tgt == CharOperation.NO_CHAR_CHAR) 
+			if (tgt != null && !tgt.equals(CharOperation.NO_CHAR_CHAR)) 
 				this.indexer.addModuleReference(CharOperation.concatWith(tgt, '.'));
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
index 1f6e87e..ffb7b83 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -27,6 +27,9 @@ import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
+import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
@@ -36,7 +39,7 @@ import org.eclipse.jdt.internal.core.util.ResourceCompilationUnit;
 import org.eclipse.jdt.internal.core.util.Util;
 
 @SuppressWarnings("rawtypes")
-public class ClasspathSourceDirectory extends ClasspathLocation {
+public class ClasspathSourceDirectory extends ClasspathLocation implements IModulePathEntry {
 
 	IContainer sourceFolder;
 	SimpleLookupTable directoryCache;
@@ -162,4 +165,14 @@ public IPackageLookup packageLookup() {
 	//
 	return this::isPackage;
 }
+
+@Override
+public IModuleEnvironment getLookupEnvironment() {
+	return this;
+}
+
+@Override
+public IModuleEnvironment getLookupEnvironmentFor(IModule mod) {
+	return this.module == mod ? this : null;
+}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 7ea3c33..e9ad82e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,27 +16,41 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.matching;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageDeclaration;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
-import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
+import org.eclipse.jdt.internal.compiler.env.IModuleContext;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
+import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.ClasspathEntry;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.JavaElementRequestor;
 import org.eclipse.jdt.internal.core.JavaModel;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.JavaProject;
+import org.eclipse.jdt.internal.core.ModuleDescriptionInfo;
+import org.eclipse.jdt.internal.core.NameLookup;
 import org.eclipse.jdt.internal.core.PackageFragmentRoot;
 import org.eclipse.jdt.internal.core.builder.ClasspathJar;
 import org.eclipse.jdt.internal.core.builder.ClasspathJrt;
@@ -46,9 +60,12 @@ import org.eclipse.jdt.internal.core.util.Util;
 /*
  * A name environment based on the classpath of a Java project.
  */
-public class JavaSearchNameEnvironment implements INameEnvironment, SuffixConstants {
+public class JavaSearchNameEnvironment implements IModuleAwareNameEnvironment, SuffixConstants {
 
-	LinkedHashSet<ClasspathLocation> locationSet;
+	LinkedHashSet<IModuleEnvironment> locationSet;
+	Map<String, IModuleDescription> modules;
+	private boolean modulesComputed = false;
+	List<IModulePathEntry> modulePathEntries;
 
 	/*
 	 * A map from the fully qualified slash-separated name of the main type (String) to the working copy
@@ -56,6 +73,8 @@ public class JavaSearchNameEnvironment implements INameEnvironment, SuffixConsta
 	Map<String, org.eclipse.jdt.core.ICompilationUnit> workingCopies;
 
 public JavaSearchNameEnvironment(IJavaProject javaProject, org.eclipse.jdt.core.ICompilationUnit[] copies) {
+	this.modulePathEntries = new ArrayList<>();
+	this.modules = new HashMap<>();
 	this.locationSet = computeClasspathLocations((JavaProject) javaProject);
 	this.workingCopies = getWorkingCopyMap(copies);
 }
@@ -74,6 +93,7 @@ public static Map<String, org.eclipse.jdt.core.ICompilationUnit> getWorkingCopyM
 				String mainTypeName = Util.getNameWithoutJavaLikeExtension(cuName);
 				String qualifiedMainTypeName = pkg.length() == 0 ? mainTypeName : pkg.replace('.', '/') + '/' + mainTypeName;
 				result.put(qualifiedMainTypeName, workingCopy);
+				// TODO : JAVA 9 - module-info.java has the same name across modules - Any issues here?
 			}
 		}
 	} catch (JavaModelException e) {
@@ -87,11 +107,11 @@ public void cleanup() {
 }
 
 void addProjectClassPath(JavaProject javaProject) {
-	LinkedHashSet<ClasspathLocation> locations = computeClasspathLocations(javaProject);
+	LinkedHashSet<IModuleEnvironment> locations = computeClasspathLocations(javaProject);
 	if (locations != null) this.locationSet.addAll(locations);
 }
 
-private LinkedHashSet<ClasspathLocation> computeClasspathLocations(JavaProject javaProject) {
+private LinkedHashSet<IModuleEnvironment> computeClasspathLocations(JavaProject javaProject) {
 
 	IPackageFragmentRoot[] roots = null;
 	try {
@@ -99,7 +119,7 @@ private LinkedHashSet<ClasspathLocation> computeClasspathLocations(JavaProject j
 	} catch (JavaModelException e) {
 		return null;// project doesn't exist
 	}
-	LinkedHashSet<ClasspathLocation> locations = new LinkedHashSet<ClasspathLocation>();
+	LinkedHashSet<IModuleEnvironment> locations = new LinkedHashSet<>();
 	int length = roots.length;
 	JavaModelManager manager = JavaModelManager.getJavaModelManager();
 	for (int i = 0; i < length; i++) {
@@ -109,9 +129,28 @@ private LinkedHashSet<ClasspathLocation> computeClasspathLocations(JavaProject j
 	return locations;
 }
 
+private void computeModules() {
+	if (!this.modulesComputed) {
+		this.modulesComputed = true;
+		JavaElementRequestor requestor = new JavaElementRequestor();
+		try {
+			JavaModelManager.getModulePathManager().seekModule(CharOperation.ALL_PREFIX, true, requestor);
+			IModuleDescription[] mods = requestor.getModules();
+			for (IModuleDescription mod : mods) {
+				this.modules.putIfAbsent(mod.getElementName(), mod);
+			}
+		} catch (JavaModelException e) {
+			// do nothing
+		}
+	}
+}
 private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, PackageFragmentRoot root) {
 	ClasspathLocation cp = null;
 	IPath path = root.getPath();
+	IModuleDescription imd = root.getModuleDescription();
+	IModule mod = NameLookup.getModuleDescriptionInfo(imd);
+	this.modules.put(new String(mod.name()), imd);
+	IModulePathEntry ime = null;
 	try {
 		if (root.isArchive()) {
 			ClasspathEntry rawClasspathEntry = (ClasspathEntry) root.getRawClasspathEntry();
@@ -121,19 +160,27 @@ private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, Packa
 						new ClasspathJar(manager.getZipFile(path), rawClasspathEntry.getAccessRuleSet(),
 								ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry,
 										((IJavaProject) root.getParent()).getProject(), true),
-								this, rawClasspathEntry.isAutomaticModule());
+								this, rawClasspathEntry.isAutomaticModule());		
+			ime = (IModulePathEntry) cp;
 		} else {
 			Object target = JavaModel.getTarget(path, true);
 			if (target != null) {
 				if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
 					cp = new ClasspathSourceDirectory((IContainer)target, root.fullExclusionPatternChars(), root.fullInclusionPatternChars());
+					ime = (IModulePathEntry) cp;
 				} else {
 					ClasspathEntry rawClasspathEntry = (ClasspathEntry) root.getRawClasspathEntry();
 					cp = ClasspathLocation.forBinaryFolder((IContainer) target, false, rawClasspathEntry.getAccessRuleSet(), 
 							ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true), this, rawClasspathEntry.isAutomaticModule());
+					if (cp instanceof IModulePathEntry && ((IModulePathEntry) cp).getModule() != null) {
+						ime = (IModulePathEntry) cp;
+					}
 				}
 			}
 		}
+		cp.setModule(mod);
+		if (ime != null)
+			this.modulePathEntries.add(ime);
 	} catch (CoreException e1) {
 		// problem opening zip file or getting root kind
 		// consider root corrupt and ignore
@@ -141,17 +188,29 @@ private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, Packa
 	return cp;
 }
 
-private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeName) {
+private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeName, IModuleContext moduleContext) {
+	if (moduleContext == IModuleContext.UNNAMED_MODULE_CONTEXT)
+		return findClass(qualifiedTypeName, typeName);
+
+	IModuleEnvironment[] envs = moduleContext.getEnvironment().toArray(IModuleEnvironment[] :: new);
+	LinkedHashSet<IModuleEnvironment> cLocs = new LinkedHashSet<>();
+	for  (IModuleEnvironment e : envs) {
+		cLocs.add(e);
+	}
+	return findClass(qualifiedTypeName, typeName, cLocs);
+}
+private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeName, LinkedHashSet<IModuleEnvironment> locSets) {
 	String
 		binaryFileName = null, qBinaryFileName = null,
 		sourceFileName = null, qSourceFileName = null,
 		qPackageName = null;
 	NameEnvironmentAnswer suggestedAnswer = null;
-	Iterator <ClasspathLocation> iter = this.locationSet.iterator();
+	Iterator <IModuleEnvironment> iter = locSets.iterator();
 	while (iter.hasNext()) {
-		ClasspathLocation location = iter.next();
+		IModuleEnvironment location = iter.next();
 		NameEnvironmentAnswer answer = null;
 		if (location instanceof ClasspathSourceDirectory) {
+			ClasspathSourceDirectory csd = (ClasspathSourceDirectory) location;
 			if (sourceFileName == null) {
 				qSourceFileName = qualifiedTypeName; // doesn't include the file extension
 				sourceFileName = qSourceFileName;
@@ -166,12 +225,12 @@ private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeNam
 			if (workingCopy != null) {
 				answer = new NameEnvironmentAnswer(workingCopy, null /*no access restriction*/);
 			} else {
-					answer = location.findClass(
+					answer = csd.findClass(
 							sourceFileName, // doesn't include the file extension
 							qPackageName,
 							qSourceFileName);  // doesn't include the file extension
 			}
-		} else {
+		} else if (location instanceof ClasspathLocation){
 			if (binaryFileName == null) {
 				qBinaryFileName = qualifiedTypeName + SUFFIX_STRING_class;
 				binaryFileName = qBinaryFileName;
@@ -183,10 +242,12 @@ private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeNam
 				}
 			}
 			answer =
-					location.findClass(
+					((ClasspathLocation) location).findClass(
 							binaryFileName,
 							qPackageName,
 							qBinaryFileName);
+		} else {
+			// TODO: handle anything other than ClassPathLocation, if any.
 		}
 		if (answer != null) {
 			if (!answer.ignoreIfBetter()) {
@@ -203,20 +264,28 @@ private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeNam
 	return null;
 }
 
-public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {
+private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeName) {
+	return findClass(qualifiedTypeName, typeName, this.locationSet);
+}
+
+@Override
+public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName, IModuleContext context) {
 	if (typeName != null)
 		return findClass(
 			new String(CharOperation.concatWith(packageName, typeName, '/')),
-			typeName);
+			typeName, context);
 	return null;
 }
 
+@Override
+public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {
+	return findType(typeName, 
+			packageName,
+			IModuleContext.UNNAMED_MODULE_CONTEXT);
+}
+
 public NameEnvironmentAnswer findType(char[][] compoundName) {
-	if (compoundName != null)
-		return findClass(
-			new String(CharOperation.concatWith(compoundName, '/')),
-			compoundName[compoundName.length - 1]);
-	return null;
+	return findType(compoundName, IModuleContext.UNNAMED_MODULE_CONTEXT);
 }
 
 public boolean isPackage(char[][] compoundName, char[] packageName) {
@@ -224,10 +293,67 @@ public boolean isPackage(char[][] compoundName, char[] packageName) {
 }
 
 public boolean isPackage(String qualifiedPackageName) {
-	Iterator<ClasspathLocation> iter = this.locationSet.iterator();
+	Iterator<IModuleEnvironment> iter = this.locationSet.iterator();
 	while (iter.hasNext()) {
 		if (iter.next().isPackage(qualifiedPackageName)) return true;
 	}
 	return false;
 }
+
+@Override
+public NameEnvironmentAnswer findType(char[][] compoundName, IModuleContext moduleContext) {
+	if (compoundName != null)
+		return findClass(
+			new String(CharOperation.concatWith(compoundName, '/')),
+			compoundName[compoundName.length - 1],
+			moduleContext);
+	return null;
+}
+
+@Override
+public boolean isPackage(char[][] parentPackageName, char[] packageName, IModuleContext moduleContext) {
+	if (moduleContext == IModuleContext.UNNAMED_MODULE_CONTEXT)
+		return isPackage(parentPackageName, packageName);
+	String qualifiedPackageName = new String(CharOperation.concatWith(parentPackageName, packageName, '/'));
+	Stream<IModuleEnvironment> env = moduleContext.getEnvironment();
+	List<IModuleEnvironment> envs = env.collect(Collectors.toList());
+	for (IModuleEnvironment e : envs) {
+		if (e.isPackage(qualifiedPackageName)) 
+			return true;
+	}
+	return false;
+}
+
+@Override
+public IModule getModule(char[] moduleName) {
+	computeModules();
+	IModuleDescription moduleDesc = this.modules.get(new String(moduleName));
+	IModule module = null;
+	try {
+		if (moduleDesc != null)
+			module =  ((ModuleDescriptionInfo)((JavaElement) moduleDesc).getElementInfo());
+	} catch (JavaModelException e) {
+		// do nothing
+	}
+	return module;
+}
+
+@Override
+public IModuleEnvironment getModuleEnvironmentFor(char[] moduleName) {
+	IModule module = null;
+	for (IModulePathEntry mpe : this.modulePathEntries) {
+		if ((module = mpe.getModule(moduleName)) != null)
+			return mpe.getLookupEnvironmentFor(module);
+	}
+	return null;
+}
+
+@Override
+public IModule[] getAllAutomaticModules() {
+	if (this.modulePathEntries == null || this.modulePathEntries.size() == 0)
+		return IModule.NO_MODULES;
+	Set<IModule> set = this.modulePathEntries.stream().map(e -> e.getModule()).filter(m -> m.isAutomatic())
+			.collect(Collectors.toSet());
+	return set.toArray(new IModule[set.size()]);
+}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index fb30c54..8ff17be 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -40,6 +40,7 @@ import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMember;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
+import org.eclipse.jdt.core.IModuleDescription.IModuleReference;
 import org.eclipse.jdt.core.IModuleDescription.IPackageExport;
 import org.eclipse.jdt.core.IModuleDescription.IProvidedService;
 import org.eclipse.jdt.core.IOpenable;
@@ -47,6 +48,7 @@ import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.ISourceRange;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.*;
@@ -1654,6 +1656,8 @@ public SearchMatch newDeclarationMatch(
 			return new PackageDeclarationMatch(element, accuracy, offset, length, participant, resource);
 		case IJavaElement.TYPE_PARAMETER:
 			return new TypeParameterDeclarationMatch(element, accuracy, offset, length, participant, resource);
+		case IJavaElement.JAVA_MODULE:
+			return new ModuleDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);
 		default:
 			return null;
 	}
@@ -2865,15 +2869,20 @@ protected void reportMatching(FieldDeclaration field, FieldDeclaration[] otherFi
 protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {
 	IModuleDescription moduleDesc =  null;
 	Openable openable = this.currentPossibleMatch.openable;
-	if (openable instanceof CompilationUnit) {
-		CompilationUnit cu = (CompilationUnit) openable;
+	if (openable instanceof ITypeRoot) {
+		ITypeRoot typeRoot = (ITypeRoot) openable;
 		try {
-			moduleDesc =  cu.getModule();
+			moduleDesc =  typeRoot.getModule();
 		} catch (JavaModelException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+			// do nothing
 		}
 	}
+	if (moduleDesc == null) // should not happen - safety net.
+		return;
+	if (accuracy > -1) { // report module declaration
+		SearchMatch match = this.patternLocator.newDeclarationMatch(module, moduleDesc, module.binding, accuracy, module.moduleName.length, this);
+		report(match);
+	}
 	reportMatching(module.requires, module,  nodeSet, moduleDesc);
 	reportMatching(module.exports, nodeSet, moduleDesc);
 	reportMatching(module.opens, nodeSet, moduleDesc);
@@ -2882,7 +2891,20 @@ protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int
 }
 
 private void reportMatching(RequiresStatement[] reqs, ModuleDeclaration module, MatchingNodeSet nodeSet, IModuleDescription moduleDesc) {
-	// TODO:
+	if (reqs == null || reqs.length == 0)
+		return;
+	try {
+		IModuleReference[] refs = moduleDesc.getRequiredModules();
+		for (int i = 0, l = refs.length; i < l; ++i) {
+			RequiresStatement req = reqs[i];
+			Integer level = (Integer) nodeSet.matchingNodes.removeKey(req.module);
+			if (level != null) {
+				this.patternLocator.matchReportReference(req.module, refs[i], req.resolvedBinding, level.intValue(), this);
+			}
+		}
+	} catch (CoreException e) {
+		// do nothing
+	}
 }
 
 private void reportMatching(PackageVisibilityStatement[] psvs, MatchingNodeSet nodeSet, IModuleDescription moduleDesc)
@@ -2897,6 +2919,14 @@ private void reportMatching(PackageVisibilityStatement[] psvs, MatchingNodeSet n
 				Binding binding = this.unitScope.getImport(CharOperation.subarray(importRef.tokens, 0, importRef.tokens.length), true, false);
 				this.patternLocator.matchReportImportRef(importRef, binding, pkgExports[i], level.intValue(), this);
 			}
+			ModuleReference[] tgts = psv.targets;
+			if (tgts == null || tgts.length == 0) return;
+			for (ModuleReference tgt : tgts) {
+				level = (Integer) nodeSet.matchingNodes.removeKey(tgt);
+				if (level != null) {
+					this.patternLocator.matchReportReference(tgt, pkgExports[i], tgt.resolve(this.unitScope), level.intValue(), this);
+				}
+			}
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
index 660abe1..b84a57b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
@@ -491,6 +491,11 @@ protected void consumeMethodInvocationSuperWithTypeArguments() {
 	}
 }
 
+@Override
+protected void consumeModuleHeader() {
+	super.consumeModuleHeader();
+	this.patternLocator.match(((ModuleDeclaration) this.astStack[this.astPtr]), this.nodeSet);
+}
 protected void consumeNormalAnnotation(boolean isTypeAnnotation) {
 	super.consumeNormalAnnotation(isTypeAnnotation);
 	if (this.patternFineGrain == 0 || (this.patternFineGrain & IJavaSearchConstants.ANNOTATION_TYPE_REFERENCE) != 0) {
@@ -512,15 +517,18 @@ protected void consumeOnlyTypeArguments() {
 		}
 	}
 }
+@Override
 protected void consumeOpensHeader() {
 	super.consumeOpensHeader();
 	this.patternLocator.match(((OpensStatement) this.astStack[this.astPtr]).pkgRef, this.nodeSet);
 }
+@Override
 protected void consumeProvidesInterface() {
 	super.consumeProvidesInterface();
 	ProvidesStatement ref = (ProvidesStatement) this.astStack[this.astPtr];
 	this.patternLocator.match(ref.serviceInterface, this.nodeSet);
 }
+@Override
 protected void consumeProvidesStatement() {
 	super.consumeProvidesStatement();
 	ProvidesStatement ref = (ProvidesStatement) this.astStack[this.astPtr];
@@ -568,6 +576,24 @@ protected void consumeSingleMemberAnnotation(boolean isTypeAnnotation) {
 		this.patternLocator.match(annotation, this.nodeSet);
 	}
 }
+@Override
+protected void consumeSingleRequiresModuleName() {
+	super.consumeSingleRequiresModuleName();
+	RequiresStatement req = (RequiresStatement) this.astStack[this.astPtr];
+	this.patternLocator.match(req.module, this.nodeSet);
+}
+private void setTarget(boolean flag) {
+	if (this.patternLocator instanceof ModuleLocator) {
+		((ModuleLocator) this.patternLocator).target = flag;
+	}
+}
+@Override
+protected void consumeSingleTargetModuleName() {
+	super.consumeSingleTargetModuleName();
+	setTarget(true);
+	this.patternLocator.match((ModuleReference)this.astStack[this.astPtr], this.nodeSet);
+	setTarget(false);
+}
 
 protected void consumeStatementCatch() {
 	super.consumeStatementCatch();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
new file mode 100644
index 0000000..d98c722
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
@@ -0,0 +1,88 @@
+package org.eclipse.jdt.internal.core.search.matching;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.search.SearchMatch;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
+
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
+public class ModuleLocator extends PatternLocator {
+
+	private ModulePattern pattern;
+	/* package */ boolean target = false;
+
+	public ModuleLocator(ModulePattern pattern) {
+		super(pattern);
+		this.pattern = pattern;
+	}
+	public int match(ModuleDeclaration node, MatchingNodeSet nodeSet) {
+		if (!this.pattern.findDeclarations) return IMPOSSIBLE_MATCH;
+		if (!matchesName(this.pattern.name, node.moduleName)) return IMPOSSIBLE_MATCH;
+		nodeSet.mustResolve = true;
+		return nodeSet.addMatch(node, POSSIBLE_MATCH);
+	}
+	@Override
+	protected int match(ModuleReference node, MatchingNodeSet nodeSet) {
+		if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
+		if (!matchesName(this.pattern.name, node.moduleName)) return IMPOSSIBLE_MATCH;
+		if (this.target) {
+			return nodeSet.addMatch(node, ACCURATE_MATCH);
+		}
+		nodeSet.mustResolve = true;
+		return nodeSet.addMatch(node, POSSIBLE_MATCH);
+	}
+	@Override
+	protected int matchContainer() {
+		return COMPILATION_UNIT_CONTAINER;
+	}
+	public int resolveLevel(ASTNode possibleMatchingNode) {
+		if (this.pattern.findDeclarations && possibleMatchingNode instanceof ModuleDeclaration) {
+			return resolveLevel(((ModuleDeclaration) possibleMatchingNode).moduleBinding);
+		}
+		if (this.pattern.findReferences && possibleMatchingNode instanceof ModuleReference) {
+			return resolveLevel(((ModuleReference) possibleMatchingNode).resolve(null));
+		}
+		return IMPOSSIBLE_MATCH;
+	}
+	@Override
+	protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException {
+		super.matchReportReference(reference, element, elementBinding, accuracy, locator);
+	}
+	@Override
+	protected void matchReportReference(ASTNode reference, IJavaElement element, IJavaElement localElement, IJavaElement[] otherElements, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException {
+		matchReportReference(reference, element, elementBinding, accuracy, locator);
+	}
+
+	@Override
+	public SearchMatch newDeclarationMatch(ASTNode node, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator) {
+		return super.newDeclarationMatch(node, element, elementBinding, accuracy, length, locator);
+	}
+	@Override
+	protected int referenceType() {
+		return IJavaElement.JAVA_MODULE;
+	}
+	public int resolveLevel(Binding binding) {
+		if (binding == null) return INACCURATE_MATCH;
+		if (!(binding instanceof ModuleBinding)) return IMPOSSIBLE_MATCH;
+		return (matchesName(this.pattern.name, binding.readableName())) ? ACCURATE_MATCH : IMPOSSIBLE_MATCH;
+			
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModulePattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModulePattern.java
new file mode 100644
index 0000000..8e99d10
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModulePattern.java
@@ -0,0 +1,121 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search.matching;
+
+import java.io.IOException;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.core.search.SearchPattern;
+import org.eclipse.jdt.internal.core.index.EntryResult;
+import org.eclipse.jdt.internal.core.index.Index;
+
+public class ModulePattern extends JavaSearchPattern {
+
+	boolean findDeclarations = true; /* package visible */
+	boolean findReferences = true; /* package visible */
+	char[] name; /* package visible */
+
+	protected static char[][] REF_CATEGORIES = { MODULE_REF };
+	protected static char[][] REF_AND_DECL_CATEGORIES = { MODULE_REF, MODULE_DECL };
+	protected static char[][] DECL_CATEGORIES = { MODULE_DECL };
+
+	public static char[] createIndexKey(char[] name) {
+		return name; // until a need arises, let the name itself be the index key.
+	}
+	protected ModulePattern(int matchRule) {
+		super(MODULE_PATTERN, matchRule);
+	}
+	public ModulePattern(char[] name, int limitTo, int matchRule) {
+		this(matchRule);
+		this.name = name;
+		switch (limitTo & 0xF) {
+			case IJavaSearchConstants.DECLARATIONS :
+				this.findReferences = false;
+				break;
+			case IJavaSearchConstants.REFERENCES :
+				this.findDeclarations = false;
+				break;
+			case IJavaSearchConstants.ALL_OCCURRENCES :
+				break;
+		}
+		this.mustResolve = mustResolve();
+	}
+	public void decodeIndexKey(char[] key) {
+		this.name = key;
+	}
+	public SearchPattern getBlankPattern() {
+		return new ModulePattern(R_EXACT_MATCH);
+	}
+	public char[][] getIndexCategories() {
+		if (this.findReferences)
+			return this.findDeclarations ? REF_AND_DECL_CATEGORIES : REF_CATEGORIES;
+		if (this.findDeclarations)
+			return DECL_CATEGORIES;
+		return CharOperation.NO_CHAR_CHAR;
+	}
+	public boolean matchesDecodedKey(SearchPattern decodedPattern) {
+		return matchesName(this.name, ((ModulePattern) decodedPattern).name);
+	}
+	public EntryResult[] queryIn(Index index) throws IOException {
+		char[] key = this.name; // can be null
+		int matchRule = getMatchRule();
+
+		switch(getMatchMode()) {
+			case R_EXACT_MATCH :
+				if (this.name != null) {
+					key = createIndexKey(this.name);
+				} else { // do a prefix query with the selector
+					matchRule &= ~R_EXACT_MATCH;
+					matchRule |= R_PREFIX_MATCH;
+				}
+				break;
+			case R_PREFIX_MATCH :
+				// do a prefix query with the selector
+				break;
+			case R_PATTERN_MATCH :
+				if (this.name != null) {
+					key = createIndexKey(this.name);
+				}
+				// else do a pattern query with just the selector
+				break;
+			case R_REGEXP_MATCH :
+				// TODO implement regular expression match
+				break;
+			case R_CAMELCASE_MATCH:
+			case R_CAMELCASE_SAME_PART_COUNT_MATCH:
+				// do a prefix query with the selector
+				break;
+		}
+
+		return index.query(getIndexCategories(), key, matchRule); // match rule is irrelevant when the key is null
+	}
+
+	protected boolean mustResolve() {
+		return true;
+	}
+	protected StringBuffer print(StringBuffer output) {
+		if (this.findDeclarations) {
+			output.append(this.findReferences
+				? "ModuleCombinedPattern: " //$NON-NLS-1$
+				: "ModuleDeclarationPattern: "); //$NON-NLS-1$
+		} else {
+			output.append("ModuleReferencePattern: "); //$NON-NLS-1$
+		}
+		output.append("module "); //$NON-NLS-1$
+		output.append(this.name);
+		return super.print(output);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
index b667b73..dfb079b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -93,6 +97,8 @@ public static PatternLocator patternLocator(SearchPattern pattern) {
 			return new LocalVariableLocator((LocalVariablePattern) pattern);
 		case IIndexConstants.TYPE_PARAM_PATTERN:
 			return new TypeParameterLocator((TypeParameterPattern) pattern);
+		case IIndexConstants.MODULE_PATTERN:
+			return new ModuleLocator((ModulePattern) pattern);
 	}
 	return null;
 }
@@ -222,6 +228,12 @@ public int match(MessageSend node, MatchingNodeSet nodeSet) {
 	// each subtype should override if needed
 	return IMPOSSIBLE_MATCH;
 }
+protected int match(ModuleDeclaration node, MatchingNodeSet nodeSet) {
+	return IMPOSSIBLE_MATCH;
+}
+protected int match(ModuleReference node, MatchingNodeSet nodeSet) {
+	return IMPOSSIBLE_MATCH;
+}
 public int match(Reference node, MatchingNodeSet nodeSet) {
 	// each subtype should override if needed
 	return IMPOSSIBLE_MATCH;
@@ -418,6 +430,9 @@ protected void matchReportReference(ASTNode reference, IJavaElement element, Bin
 		case IJavaElement.TYPE_PARAMETER:
 			this.match = locator.newTypeParameterReferenceMatch(element, accuracy, offset, reference.sourceEnd-offset+1, reference);
 			break;
+		case IJavaElement.JAVA_MODULE:
+			this.match = locator.newTypeReferenceMatch(element, elementBinding, accuracy, offset, reference.sourceEnd-offset+1, reference);
+			break;
 	}
 	if (this.match != null) {
 		locator.report(this.match);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index 96d06b8..74a589e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -172,6 +172,9 @@ public String toString() {
 }
 @Override
 public char[] module() {
+	if (this.openable instanceof CompilationUnit) {
+		return ((CompilationUnit) this.openable).module();
+	}
 	// TODO BETA_JAVA9 Auto-generated method stub
 	return null;
 }
commit 3b9ec6d1d7dd6152169f1e64a9606afdaeeddb74
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Sun Apr 16 09:51:44 2017 +0530

    follow up commit for bug 501162 [9][search] find constructs in
    module-info

13	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
14	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
7	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index 3e45562..1f378d7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -847,15 +847,8 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 				addModuleReference(req.name());
 			}
 		}
-		IPackageExport[] exportedPackages = module.exports();
-		if (exportedPackages != null) {
-			for (IPackageExport pack : exportedPackages) {
-				addModuleExportedPackages(pack.name());
-				char[][] tgtTokens = pack.targets();
-				char[] tgt = tgtTokens != null ? CharOperation.concatWith(tgtTokens, '.') : CharOperation.NO_CHAR;
-				if (!tgt.equals(CharOperation.NO_CHAR)) addModuleExportedPackages(tgt);
-			}
-		}
+		indexPackageExport(module.exports());
+		indexPackageExport(module.opens());
 		char[][] refUsed = module.uses();
 		if (refUsed != null) {
 			for (char[] ref : refUsed) {
@@ -870,6 +863,16 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			}
 		}
 	}
+	private void indexPackageExport(IPackageExport[] exportedPackages) {
+		if (exportedPackages != null) {
+			for (IPackageExport pack : exportedPackages) {
+				addModuleExportedPackages(pack.name());
+				char[][] tgtTokens = pack.targets();
+				char[] tgt = tgtTokens != null ? CharOperation.concatWith(tgtTokens, '.') : CharOperation.NO_CHAR;
+				if (!tgt.equals(CharOperation.NO_CHAR)) addModuleExportedPackages(tgt);
+			}
+		}
+	}
 	private void indexTypeReferences(char[][] ref) {
 		if (ref == null || ref.equals(CharOperation.NO_CHAR))
 			return;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 8ff17be..59c7e73 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -2890,16 +2890,28 @@ protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int
 	reportMatching(module.uses, module, nodeSet, moduleDesc);
 }
 
+private IModuleReference getExplicitModuleReference(IModuleReference[] refs, RequiresStatement req) {
+	String needle = new String(req.module.moduleName);
+	for (IModuleReference ref : refs) {
+		if (needle.equals(ref.getModuleName()))
+			return ref;
+	}
+	return null;
+}
 private void reportMatching(RequiresStatement[] reqs, ModuleDeclaration module, MatchingNodeSet nodeSet, IModuleDescription moduleDesc) {
 	if (reqs == null || reqs.length == 0)
 		return;
 	try {
 		IModuleReference[] refs = moduleDesc.getRequiredModules();
-		for (int i = 0, l = refs.length; i < l; ++i) {
+		if (refs == null || refs.length == 0)
+			return;
+		for (int i = 0, l = reqs.length; i < l; ++i) {
 			RequiresStatement req = reqs[i];
+			IModuleReference ref = getExplicitModuleReference(refs, req);
+			if (ref == null) continue;
 			Integer level = (Integer) nodeSet.matchingNodes.removeKey(req.module);
 			if (level != null) {
-				this.patternLocator.matchReportReference(req.module, refs[i], req.resolvedBinding, level.intValue(), this);
+				this.patternLocator.matchReportReference(req.module, ref, req.resolvedBinding, level.intValue(), this);
 			}
 		}
 	} catch (CoreException e) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index 74a589e..6b5077c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,6 +21,7 @@ import org.eclipse.jdt.core.search.SearchDocument;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.*;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -148,7 +149,7 @@ private String getSourceFileName() {
 	return this.sourceFileName;
 }
 boolean hasSimilarMatch() {
-	return this.similarMatch != null && this.source == NO_SOURCE_FILE;
+	return this.similarMatch != null && (this.source == NO_SOURCE_FILE || isModuleInfo(this));
 }
 public int hashCode() {
 	if (this.compoundName == null) return super.hashCode();
@@ -161,10 +162,13 @@ public int hashCode() {
 public boolean ignoreOptionalProblems() {
 	return false;
 }
+private boolean isModuleInfo(PossibleMatch possibleMatch) {
+	return CharOperation.equals(getMainTypeName(), TypeConstants.MODULE_INFO_NAME);
+}
 void setSimilarMatch(PossibleMatch possibleMatch) {
 	// source does not matter on similar match as it is read on
 	// the first stored possible match
-	possibleMatch.source = NO_SOURCE_FILE;
+	possibleMatch.source = isModuleInfo(possibleMatch) ? null : NO_SOURCE_FILE;
 	this.similarMatch = possibleMatch;
 }
 public String toString() {
commit 0ccfa2eb28a3895db659c4621451558ebe515ba0
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Mon Apr 17 18:27:36 2017 +0530

    Moving search results dependent only on IModuleDescription - part of bug
    501162 [9][search] find constructs in module-info
    
    Change-Id: I95f1dcc54a05d4318ffd21d8fc7a2d04cd137a98

13	12	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
11	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/IJavaSearchConstants.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
9	34	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index 7312870..1287fab 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -25,6 +25,7 @@ import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.core.search.ReferenceMatch;
 import org.eclipse.jdt.core.search.SearchEngine;
@@ -206,7 +207,7 @@ public void testBug501162_001() throws Exception {
 			scope,
 			this.resultCollector);
 		assertSearchResults(
-			"src/module-info.java [pack1] EXACT_MATCH\n" +
+			"src/module-info.java first [pack1] EXACT_MATCH\n" + 
 			"src/pack1 pack1 EXACT_MATCH",
 			this.resultCollector);
 
@@ -259,9 +260,9 @@ public void testBug501162_002() throws Exception {
 			scope,
 			this.resultCollector);
 		assertSearchResults(
-			"src/module-info.java [pack1] EXACT_MATCH\n" +
-			"src/module-info.java [pack1] EXACT_MATCH\n" +
-			"src/module-info.java [pack1] EXACT_MATCH\n" +
+			"src/module-info.java first [pack1] EXACT_MATCH\n" + 
+			"src/module-info.java first [pack1] EXACT_MATCH\n" + 
+			"src/module-info.java first [pack1] EXACT_MATCH\n" + 
 			"src/pack1 pack1 EXACT_MATCH",
 			this.resultCollector);
 
@@ -317,9 +318,9 @@ public void testBug501162_003() throws Exception {
 			scope,
 			this.resultCollector);
 		assertSearchResults(
-			"src/module-info.java [pack22] EXACT_MATCH\n" + 
+			"src/module-info.java first [pack22] EXACT_MATCH\n" + 
 			"src/pack1/X11.java pack1.X11 [pack22] EXACT_MATCH\n" + 
-			"src/module-info.java [pack22] EXACT_MATCH",
+			"src/module-info.java second [pack22] EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -382,12 +383,12 @@ public void testBug501162_006() throws Exception {
 		project2.open(null);
 		project1.open(null);
 
-		SearchPattern pattern = SearchPattern.createPattern("first", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		SearchPattern pattern = SearchPattern.createPattern("first", IJavaSearchConstants.MODULE, REFERENCES, ERASURE_RULE);
 		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-			"src/module-info.java [first] EXACT_MATCH",
+				"src/module-info.java second [first] EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -431,12 +432,12 @@ public void testBug501162_007() throws Exception {
 		project2.open(null);
 		project1.open(null);
 
-		SearchPattern pattern = SearchPattern.createPattern("first.test.org", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		SearchPattern pattern = SearchPattern.createPattern("first.test.org", IJavaSearchConstants.MODULE, REFERENCES, ERASURE_RULE);
 		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[] {getJavaProject("JavaSearchBugs9")});
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-			"src/module-info.java [first.test.org] EXACT_MATCH",
+			"src/module-info.java second [first.test.org] EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -480,12 +481,12 @@ public void testBug501162_008() throws Exception {
 		project2.open(null);
 		project1.open(null);
 
-		SearchPattern pattern = SearchPattern.createPattern("second", IJavaElement.JAVA_MODULE, REFERENCES, ERASURE_RULE);
+		SearchPattern pattern = SearchPattern.createPattern("second", IJavaSearchConstants.MODULE, REFERENCES, ERASURE_RULE);
 		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-			"src/module-info.java [second] EXACT_MATCH",
+			"src/module-info.java first [second] EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/IJavaSearchConstants.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/IJavaSearchConstants.java
index 77f77cd..1717096 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/IJavaSearchConstants.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/IJavaSearchConstants.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -128,6 +132,12 @@ public interface IJavaSearchConstants {
 	 */
 	int INTERFACE_AND_ANNOTATION= 11;
 
+	/**
+	 * The searched element is a module.
+	 * @since 3.13 BETA_JAVA9
+	 * @category searchFor
+	 */
+	int MODULE= 12;
 	/* Nature of match */
 
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
index b361fe4..ffefdd5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java
@@ -1648,7 +1648,7 @@ public static SearchPattern createPattern(String stringPattern, int searchFor, i
 			return createFieldPattern(stringPattern, limitTo, matchRule);
 		case IJavaSearchConstants.PACKAGE:
 			return createPackagePattern(stringPattern, limitTo, matchRule);
-		case IJavaElement.JAVA_MODULE :
+		case IJavaSearchConstants.MODULE :
 			return createModulePattern(stringPattern, limitTo, matchRule);
 	}
 	return null;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 59c7e73..ea13b04 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -40,9 +40,6 @@ import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMember;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
-import org.eclipse.jdt.core.IModuleDescription.IModuleReference;
-import org.eclipse.jdt.core.IModuleDescription.IPackageExport;
-import org.eclipse.jdt.core.IModuleDescription.IProvidedService;
 import org.eclipse.jdt.core.IOpenable;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
@@ -2890,28 +2887,14 @@ protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int
 	reportMatching(module.uses, module, nodeSet, moduleDesc);
 }
 
-private IModuleReference getExplicitModuleReference(IModuleReference[] refs, RequiresStatement req) {
-	String needle = new String(req.module.moduleName);
-	for (IModuleReference ref : refs) {
-		if (needle.equals(ref.getModuleName()))
-			return ref;
-	}
-	return null;
-}
 private void reportMatching(RequiresStatement[] reqs, ModuleDeclaration module, MatchingNodeSet nodeSet, IModuleDescription moduleDesc) {
 	if (reqs == null || reqs.length == 0)
 		return;
 	try {
-		IModuleReference[] refs = moduleDesc.getRequiredModules();
-		if (refs == null || refs.length == 0)
-			return;
-		for (int i = 0, l = reqs.length; i < l; ++i) {
-			RequiresStatement req = reqs[i];
-			IModuleReference ref = getExplicitModuleReference(refs, req);
-			if (ref == null) continue;
+		for (RequiresStatement req : reqs) {
 			Integer level = (Integer) nodeSet.matchingNodes.removeKey(req.module);
 			if (level != null) {
-				this.patternLocator.matchReportReference(req.module, ref, req.resolvedBinding, level.intValue(), this);
+				this.patternLocator.matchReportReference(req.module, moduleDesc, req.resolvedBinding, level.intValue(), this);
 			}
 		}
 	} catch (CoreException e) {
@@ -2922,21 +2905,19 @@ private void reportMatching(RequiresStatement[] reqs, ModuleDeclaration module,
 private void reportMatching(PackageVisibilityStatement[] psvs, MatchingNodeSet nodeSet, IModuleDescription moduleDesc)
 		throws JavaModelException, CoreException {
 	if (psvs != null && psvs.length > 0) {
-		IPackageExport[] pkgExports = moduleDesc.getExportedPackages();
-		for (int i = 0, l = psvs.length; i < l; i++) {
-			PackageVisibilityStatement psv = psvs[i];
+		for (PackageVisibilityStatement psv : psvs) {
 			ImportReference importRef = psv.pkgRef;
 			Integer level = (Integer) nodeSet.matchingNodes.removeKey(importRef);
 			if (level != null) {
 				Binding binding = this.unitScope.getImport(CharOperation.subarray(importRef.tokens, 0, importRef.tokens.length), true, false);
-				this.patternLocator.matchReportImportRef(importRef, binding, pkgExports[i], level.intValue(), this);
+				this.patternLocator.matchReportImportRef(importRef, binding, moduleDesc, level.intValue(), this);
 			}
 			ModuleReference[] tgts = psv.targets;
 			if (tgts == null || tgts.length == 0) return;
 			for (ModuleReference tgt : tgts) {
 				level = (Integer) nodeSet.matchingNodes.removeKey(tgt);
 				if (level != null) {
-					this.patternLocator.matchReportReference(tgt, pkgExports[i], tgt.resolve(this.unitScope), level.intValue(), this);
+					this.patternLocator.matchReportReference(tgt, moduleDesc, tgt.resolve(this.unitScope), level.intValue(), this);
 				}
 			}
 		}
@@ -2944,23 +2925,19 @@ private void reportMatching(PackageVisibilityStatement[] psvs, MatchingNodeSet n
 }
 private void reportMatching(ProvidesStatement[] provides, ModuleDeclaration module, MatchingNodeSet nodeSet, IModuleDescription moduleDesc) throws JavaModelException, CoreException {
 	if (provides != null && provides.length > 0) {
-		IProvidedService[] ipss = moduleDesc.getProvidedServices();
-		for (int i = 0, l = provides.length; i < l; ++i) {
-			ProvidesStatement service = provides[i];
-			IProvidedService ips = ipss[i];
-
+		for (ProvidesStatement service : provides) {
 			TypeReference intf = service.serviceInterface;
 			if (intf != null) {
 				Integer level = (Integer) nodeSet.matchingNodes.removeKey(intf);
 				if (level != null)
-					this.patternLocator.matchReportReference(intf, ips, null, null, module.binding, level.intValue(), this);
+					this.patternLocator.matchReportReference(intf, moduleDesc, null, null, module.binding, level.intValue(), this);
 			}
 			TypeReference[] impls = service.implementations;
 			for (TypeReference impl : impls) {
 				if (impl != null) {
 					Integer level = (Integer) nodeSet.matchingNodes.removeKey(impl);
 					if (level != null)
-						this.patternLocator.matchReportReference(impl, ips, null, null, module.binding, level.intValue(), this);
+						this.patternLocator.matchReportReference(impl, moduleDesc, null, null, module.binding, level.intValue(), this);
 				}
 			}
 		}
@@ -2969,9 +2946,7 @@ private void reportMatching(ProvidesStatement[] provides, ModuleDeclaration modu
 private void reportMatching(UsesStatement[] uses, ModuleDeclaration module, MatchingNodeSet nodeSet, IModuleDescription moduleDesc) {
 	if (uses != null && uses.length > 0) {
 		try {
-			for (int i = 0, l = uses.length; i < l; ++i) {
-				UsesStatement service = uses[i];
-
+			for (UsesStatement service : uses) {
 				TypeReference intf = service.serviceInterface;
 				if (intf != null) {
 					Integer level = (Integer) nodeSet.matchingNodes.removeKey(intf);
commit 02ab66e03d223634af136cf4a0d6f8ed2291bf17
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Thu Aug 17 08:28:11 2017 +0530

    Fix for the package search comment 13 of bug 501162 [9][search] find
    constructs in module-info

57	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index 4050176..c8b19fa 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -495,6 +495,63 @@ public void testBug501162_008() throws Exception {
 	}
 }
 
+public void testBug501162_009() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first {\n" +
+			"    exports pack1;\n" +
+			"    exports pack2;\n" +
+			"    opens pack1 to fourth;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 {}\n");
+		createFolder("/JavaSearchBugs9/src/pack2");
+		createFile("/JavaSearchBugs9/src/pack2/X21.java",
+				"package pack2;\n" +
+				"public class X21 {}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    requires first;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+		
+		IPackageFragment pkg = getPackageFragment("JavaSearchBugs9", "src", "pack2");
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[] 
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(
+			pkg,
+			ALL_OCCURRENCES,
+			scope,
+			this.resultCollector);
+		assertSearchResults(
+			"src/module-info.java first [pack2] EXACT_MATCH\n" + 
+			"src/pack2 pack2 EXACT_MATCH",
+			this.resultCollector);
+
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
 public void testBug519211_001() throws CoreException {
 	try {
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 4f15cf5..57ee5e3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -2930,7 +2930,7 @@ private void reportMatching(PackageVisibilityStatement[] psvs, MatchingNodeSet n
 				this.patternLocator.matchReportImportRef(importRef, binding, moduleDesc, level.intValue(), this);
 			}
 			ModuleReference[] tgts = psv.targets;
-			if (tgts == null || tgts.length == 0) return;
+			if (tgts == null || tgts.length == 0) continue;
 			for (ModuleReference tgt : tgts) {
 				level = (Integer) nodeSet.matchingNodes.removeKey(tgt);
 				if (level != null) {
commit 71b20aa6bcdc5f908761105871ce4a964db74e07
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Fri Aug 18 10:17:35 2017 +0530

    Fix for target exports in Bug 501162: [9][search] find constructs in
    module-info

98	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
9	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
16	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index c8b19fa..b0d6403 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -552,6 +552,104 @@ public void testBug501162_009() throws Exception {
 		deleteProject("second");
 	}
 }
+public void testBug501162_010() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 implements pack22.I22{}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    exports pack22 to first, zero;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+		createFolder("/second/src/pack1");
+		createFile("/second/src/pack1/I22.java",
+				"package pack22;\n" +
+				"public interface I22 {}\n");
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+
+		SearchPattern pattern = SearchPattern.createPattern("first", IJavaSearchConstants.MODULE, REFERENCES, ERASURE_RULE);
+		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/module-info.java second [first] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
+public void testBug501162_011() throws Exception {
+	try {
+
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent = 
+			"module first {\n" +
+			"    requires second;" +
+			"    provides pack22.I22 with pack1.X11;" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X11.java",
+				"package pack1;\n" +
+				"public class X11 implements pack22.I22{}\n");
+
+		IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String secondFile = 
+				"module second {\n" +
+				"    opens pack22 to first, zero;\n" +
+				"}\n";
+		createFile("/second/src/module-info.java",	secondFile);
+		createFolder("/second/src/pack1");
+		createFile("/second/src/pack1/I22.java",
+				"package pack22;\n" +
+				"public interface I22 {}\n");
+
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+		project1.close(); // sync
+		project2.close();
+		project2.open(null);
+		project1.open(null);
+
+		SearchPattern pattern = SearchPattern.createPattern("first", IJavaSearchConstants.MODULE, REFERENCES, ERASURE_RULE);
+		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/module-info.java second [first] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("second");
+	}
+}
 public void testBug519211_001() throws CoreException {
 	try {
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index 27c2223..728a6de 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -854,8 +854,8 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 				addModuleReference(req.name());
 			}
 		}
-		indexPackageExport(module.exports());
-		indexPackageExport(module.opens());
+		indexPackageVisibilityDirective(module.exports());
+		indexPackageVisibilityDirective(module.opens());
 		char[][] refUsed = module.uses();
 		if (refUsed != null) {
 			for (char[] ref : refUsed) {
@@ -870,13 +870,16 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			}
 		}
 	}
-	private void indexPackageExport(IPackageExport[] exportedPackages) {
+	private void indexPackageVisibilityDirective(IPackageExport[] exportedPackages) {
 		if (exportedPackages != null) {
 			for (IPackageExport pack : exportedPackages) {
 				addModuleExportedPackages(pack.name());
-				char[][] tgtTokens = pack.targets();
-				char[] tgt = tgtTokens != null ? CharOperation.concatWith(tgtTokens, '.') : CharOperation.NO_CHAR;
-				if (!tgt.equals(CharOperation.NO_CHAR)) addModuleExportedPackages(tgt);
+				char[][] tgts = pack.targets();
+				if (tgts == null || tgts.equals(CharOperation.NO_CHAR_CHAR)) continue;
+				for (char[] tgt : tgts) {
+					if (tgt != null && !tgt.equals(CharOperation.NO_CHAR)) 
+						addModuleReference(tgt);
+				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index 2448f92..a6a2726 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -303,6 +303,7 @@ private void enterInterface(TypeInfo typeInfo) {
 	addDefaultConstructorIfNecessary(typeInfo);
 	pushTypeName(typeInfo.name);
 }
+
 public void enterModule(ModuleInfo moduleInfo) {
 	this.indexer.addModuleDeclaration(moduleInfo.moduleName);
 	if (moduleInfo.requires != null) {
@@ -311,13 +312,21 @@ public void enterModule(ModuleInfo moduleInfo) {
 			this.indexer.addModuleReference(req.moduleName);
 		}
 	}
-	if (moduleInfo.exports != null) {
-		for (ISourceElementRequestor.PackageExportInfo packInfo : moduleInfo.exports) {
-			if (packInfo == null || packInfo.pkgName == null || packInfo.pkgName.equals(CharOperation.NO_CHAR)) continue;
-			this.indexer.addModuleExportedPackages(packInfo.pkgName);
-			char[][] tgt = packInfo.targets;
-			if (tgt != null && !tgt.equals(CharOperation.NO_CHAR_CHAR)) 
-				this.indexer.addModuleReference(CharOperation.concatWith(tgt, '.'));
+	enterPackageVisibilityInfo(moduleInfo.exports);
+	enterPackageVisibilityInfo(moduleInfo.opens); 
+	/* note: provides and uses directives processed automatically on IParser (SEParser) */
+}
+private void enterPackageVisibilityInfo(ISourceElementRequestor.PackageExportInfo[] packInfos) {
+	if (packInfos == null)
+		return;
+	for (ISourceElementRequestor.PackageExportInfo packInfo : packInfos) {
+		if (packInfo == null || packInfo.pkgName == null || packInfo.pkgName.equals(CharOperation.NO_CHAR)) continue;
+		this.indexer.addModuleExportedPackages(packInfo.pkgName);
+		char[][] tgts = packInfo.targets;
+		if (tgts == null || tgts.equals(CharOperation.NO_CHAR_CHAR)) continue;
+		for (char[] tgt : tgts) {
+			if (tgt != null && !tgt.equals(CharOperation.NO_CHAR)) 
+				this.indexer.addModuleReference(tgt);
 		}
 	}
 }
commit a6ac586eddf581750bdde0cff974177944429f4b
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Fri Sep 8 08:52:33 2017 +0530

    Fix for MCF addition for bug 501162 : [9][search] find constructs in
    module-info (ref comment 32)
    
    Change-Id: I36fb8639a6eee4ec5efc87e2d5763ad63ea9bf42

532	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
-	-	org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero501162.jar
47	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleReferenceMatch.java
37	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
224	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModularClassFileMatchLocator.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index deb56a8..4a20b81 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -1036,13 +1036,544 @@ public void testBug501162_018() throws Exception {
 		deleteProject("second");
 	}
 }
+public void testBug501162_019() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.one",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [pack.one] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_020() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.two",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [pack.two] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_021() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.three",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_022() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("java.base",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_023() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("zerotest",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_024() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("first",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_025() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("four",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_026() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("nomodule",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_027() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);		
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [XOne] EXACT_MATCH\n" + 
+				"src/pack1/X.java pack1.X.X1 [XOne] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_028() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XFourOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_029() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("ITwo",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [ITwo] EXACT_MATCH\n" +
+				"src/pack1/X.java pack1.X.i2 [ITwo] EXACT_MATCH\n" +
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_030() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("IThreeOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_031() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XThreeOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_032() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("zero",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.DECLARATIONS, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
 public void testBug519211_001() throws CoreException {
 	try {
 
 		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 		project1.open(null);
 		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
-		String fileContent = 
+		String fileContent =
 			"module first {\n" +
 			"    requires second;" +
 			"    provides pack22.I22 with pack1.X11;" +
diff --git a/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero501162.jar b/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero501162.jar
new file mode 100644
index 0000000..e831bd4
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero501162.jar differ
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleReferenceMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleReferenceMatch.java
new file mode 100644
index 0000000..0c1caa5
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/ModuleReferenceMatch.java
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.search;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.jdt.core.IJavaElement;
+
+/**
+ * A Java search match that represents a module reference.
+ * The element is the innermost enclosing member (mostly module declaration) that references this module reference.
+ * <p>
+ * This class is intended to be instantiated and subclassed by clients.
+ * </p>
+ * @since 3.13 BETA_JAVA9
+ */
+public class ModuleReferenceMatch extends ReferenceMatch {
+
+	/**
+	 * Creates a new module reference match.
+	 *
+	 * @param enclosingElement the inner-most enclosing member that references this module reference
+	 * @param accuracy one of {@link #A_ACCURATE} or {@link #A_INACCURATE}
+	 * @param offset the offset the match starts at, or -1 if unknown
+	 * @param length the length of the match, or -1 if unknown
+	 * @param insideDocComment <code>true</code> if this search match is inside a doc
+	 * 				comment, and <code>false</code> otherwise
+	 * @param participant the search participant that created the match
+	 * @param resource the resource of the element
+	 */
+	public ModuleReferenceMatch(IJavaElement enclosingElement, int accuracy, int offset, int length,
+			boolean insideDocComment, SearchParticipant participant, IResource resource) {
+		super(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 63ae87c..ac30c09 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -80,6 +80,7 @@ import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.JavaProject;
 import org.eclipse.jdt.internal.core.LambdaFactory;
 import org.eclipse.jdt.internal.core.LocalVariable;
+import org.eclipse.jdt.internal.core.ModularClassFile;
 import org.eclipse.jdt.internal.core.NameLookup;
 import org.eclipse.jdt.internal.core.Openable;
 import org.eclipse.jdt.internal.core.PackageFragment;
@@ -746,6 +747,8 @@ protected IJavaElement createImportHandle(ImportReference importRef) {
 	if (openable instanceof CompilationUnit)
 		return ((CompilationUnit) openable).getImport(new String(importName));
 
+	if (openable instanceof ModularClassFile)
+		return openable;
 	// binary types do not contain import statements so just answer the top-level type as the element
 	IType binaryType = ((ClassFile) openable).getType();
 	String typeName = binaryType.getElementName();
@@ -1761,7 +1764,7 @@ public PackageReferenceMatch newPackageReferenceMatch(
 		ASTNode reference) {
 	SearchParticipant participant = getParticipant();
 	IResource resource = this.currentPossibleMatch.resource;
-	boolean insideDocComment = (reference.bits & ASTNode.InsideJavadoc) != 0;
+	boolean insideDocComment = reference != null && (reference.bits & ASTNode.InsideJavadoc) != 0;
 	return new PackageReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);
 }
 
@@ -1787,7 +1790,7 @@ public TypeReferenceMatch newTypeReferenceMatch(
 		ASTNode reference) {
 	SearchParticipant participant = getParticipant();
 	IResource resource = this.currentPossibleMatch.resource;
-	boolean insideDocComment = (reference.bits & ASTNode.InsideJavadoc) != 0;
+	boolean insideDocComment = reference != null && (reference.bits & ASTNode.InsideJavadoc) != 0;
 	if (enclosingBinding != null)
 		enclosingElement = ((JavaElement) enclosingElement).resolved(enclosingBinding);
 	return new TypeReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);
@@ -1801,6 +1804,28 @@ public TypeReferenceMatch newTypeReferenceMatch(
 	return newTypeReferenceMatch(enclosingElement, enclosingBinding, accuracy, reference.sourceStart, reference.sourceEnd-reference.sourceStart+1, reference);
 }
 
+public ModuleReferenceMatch newModuleReferenceMatch(
+		IJavaElement enclosingElement,
+		Binding enclosingBinding,
+		int accuracy,
+		int offset,
+		int length,
+		ASTNode reference) {
+	SearchParticipant participant = getParticipant();
+	IResource resource = this.currentPossibleMatch.resource;
+	boolean insideDocComment = reference != null ? (reference.bits & ASTNode.InsideJavadoc) != 0 : false;
+	if (enclosingBinding != null)
+		enclosingElement = ((JavaElement) enclosingElement).resolved(enclosingBinding);
+	return new ModuleReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);
+}
+
+public ModuleReferenceMatch newModuleReferenceMatch(
+		IJavaElement enclosingElement,
+		Binding enclosingBinding,
+		int accuracy,
+		ASTNode reference) {
+	return newModuleReferenceMatch(enclosingElement, enclosingBinding, accuracy, reference.sourceStart, reference.sourceEnd-reference.sourceStart+1, reference);
+}
 /**
  * Add the possibleMatch to the loop
  *  ->  build compilation unit declarations, their bindings and record their results.
@@ -1873,6 +1898,16 @@ protected void process(PossibleMatch possibleMatch, boolean bindingsWereCreated)
 						this.patternLocator.mayBeGeneric = mayBeGeneric;
 					}
 				}
+			} else if (this.currentPossibleMatch.openable instanceof ModularClassFile) {
+				boolean mayBeGeneric = this.patternLocator.mayBeGeneric;
+				this.patternLocator.mayBeGeneric = false; // there's no longer generic in class files
+				try {
+					new ModularClassFileMatchLocator().locateMatches(this, (ModularClassFile) this.currentPossibleMatch.openable);
+				}
+				finally {
+					this.patternLocator.mayBeGeneric = mayBeGeneric;
+				}
+				return;
 			}
 			if (!unit.isModuleInfo())
 				return;
@@ -2360,7 +2395,6 @@ protected void reportBinaryMemberDeclaration(IResource resource, IMember binaryM
 	SearchMatch match = newDeclarationMatch(binaryMember, binaryMemberBinding, accuracy, range.getOffset(), range.getLength(), getParticipant(), resource);
 	report(match);
 }
-
 protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, boolean typeInHierarchy) throws CoreException {
 	IJavaElement enclosingElement = null;
 	// Report the lambda declaration itself.
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModularClassFileMatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModularClassFileMatchLocator.java
new file mode 100644
index 0000000..77ee29c
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModularClassFileMatchLocator.java
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ * Copyright (c)  2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search.matching;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.IModuleDescription;
+import org.eclipse.jdt.core.search.ModuleReferenceMatch;
+import org.eclipse.jdt.core.search.PackageReferenceMatch;
+import org.eclipse.jdt.core.search.SearchMatch;
+import org.eclipse.jdt.core.search.SearchPattern;
+import org.eclipse.jdt.core.search.TypeReferenceMatch;
+import org.eclipse.jdt.internal.compiler.env.IBinaryModule;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.core.ModularClassFile;
+import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;
+
+public class ModularClassFileMatchLocator implements IIndexConstants {
+
+	private IBinaryModule binaryModule;
+	private ModularClassFile modularClassFile;
+	private IModuleDescription moduleDesc;
+	private char[] moduleName;
+	private ModuleBinding module;
+
+	public void locateMatches(MatchLocator locator, ModularClassFile mClassFile) throws CoreException {
+		SearchPattern pattern = locator.pattern;
+		this.modularClassFile = mClassFile;
+		this.binaryModule = this.modularClassFile.getBinaryModuleInfo();
+		if (this.binaryModule == null) return;
+
+		// cache all the details
+		this.moduleDesc = mClassFile.getModule();
+		this.moduleName = this.binaryModule.name();
+		this.module = locator.lookupEnvironment.getModule(this.moduleName);
+
+		matchModuleDeclaration(pattern, locator);
+		matchModuleReferences(pattern, locator);
+		matchPackageReferences(pattern, locator);
+		matchTypeReferences(pattern, locator);
+	}
+	private void matchModuleDeclaration(SearchPattern pattern, MatchLocator locator) throws CoreException {
+		switch (pattern.kind) {
+			case MODULE_PATTERN:
+				break;
+			case OR_PATTERN:
+				SearchPattern[] patterns = ((OrPattern) pattern).patterns;
+				for (int i = 0, length = patterns.length; i < length; i++) {
+					SearchPattern p = patterns[i];
+					if (p.kind == MODULE_PATTERN)
+						matchModuleReferences(patterns[i], locator);
+				}
+				// $FALL-THROUGH$ - fall through default to return
+			default:
+				return;
+		}
+		ModulePattern modulePattern  = (ModulePattern) pattern;
+		if (!locator.patternLocator.matchesName(modulePattern.name, this.moduleName))
+			return;
+		ModuleBinding moduleBinding = null;
+		int level = PatternLocator.ACCURATE_MATCH;
+		if (locator.patternLocator.mustResolve) {
+			moduleBinding = locator.lookupEnvironment.getModule(this.moduleName);
+			level = locator.patternLocator.resolveLevel(moduleBinding);
+		}
+		if (level == PatternLocator.IMPOSSIBLE_MATCH)
+			return;
+		int accuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;
+		SearchMatch match = locator.newDeclarationMatch(this.moduleDesc, moduleBinding, accuracy, -1, 0);
+		locator.report(match);
+	}
+	private void matchModuleReferences(SearchPattern pattern, MatchLocator locator) throws CoreException {
+		// Only process Module patterns
+		switch (pattern.kind) {
+			case MODULE_PATTERN:
+				break;
+			case OR_PATTERN:
+				SearchPattern[] patterns = ((OrPattern) pattern).patterns;
+				for (int i = 0, length = patterns.length; i < length; i++) {
+					SearchPattern p = patterns[i];
+					if (p.kind == MODULE_PATTERN)
+						matchModuleReferences(patterns[i], locator);
+				}
+				// $FALL-THROUGH$ - fall through default to return
+			default:
+				return;
+		}
+		ModulePattern modulePattern  = (ModulePattern) pattern;
+		matchModuleReferences(locator, modulePattern, this.binaryModule.exports());
+		matchModuleReferences(locator, modulePattern, this.binaryModule.opens());
+		matchModuleReferences(locator, modulePattern, this.module.getAllRequiredModules());
+	}
+	private void matchModuleReference(MatchLocator locator, ModulePattern modulePattern,
+			char[][] modules, boolean isTarget) throws CoreException {
+		if (modules == null)
+			return;
+		for (char[] module1 : modules) {
+			if (module1 == null || module1.length == 0) continue;
+			if (!locator.patternLocator.matchesName(modulePattern.name, module1)) continue;
+			// no resolve for target modules - report accurate match else resolve
+			ModuleReferenceMatch match = locator.newModuleReferenceMatch(this.moduleDesc, null, isTarget ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE, -1, 0, null);
+			locator.report(match);
+		}
+	}
+	private void matchModuleReferences(MatchLocator locator, ModulePattern modulePattern,
+			IPackageExport[] pvs) throws CoreException {
+		if (pvs == null) return;
+		for (IPackageExport pv : pvs) {
+			matchModuleReference(locator, modulePattern, pv.targets(), true /* isTarget */);
+		}
+	}
+	private void matchModuleReferences(MatchLocator locator, ModulePattern modulePattern,
+			ModuleBinding[] refs) throws CoreException {
+		if (refs == null) return;
+		for (ModuleBinding ref : refs) {
+			char[] name = ref.name();
+			if (name == null) continue;
+			int level =  locator.patternLocator.resolveLevel(ref);
+			if (level == PatternLocator.IMPOSSIBLE_MATCH) continue;
+			int accuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;
+			ModuleReferenceMatch match = locator.newModuleReferenceMatch(this.moduleDesc, null, accuracy, -1, 0, null);
+			locator.report(match);
+		}
+	}
+	private void matchPackageReferences(SearchPattern pattern, MatchLocator locator) throws CoreException {
+		// Only process PackageReference patterns
+		switch (pattern.kind) {
+			case PKG_REF_PATTERN:
+				break;
+			case OR_PATTERN:
+				SearchPattern[] patterns = ((OrPattern) pattern).patterns;
+				for (int i = 0, length = patterns.length; i < length; i++) {
+					SearchPattern p = patterns[i];
+					if (p.kind == PKG_REF_PATTERN)
+						matchPackageReferences(patterns[i], locator);
+				}
+				// $FALL-THROUGH$ - fall through default to return
+			default:
+				return;
+		}
+		matchPackReferences(locator, (PackageReferencePattern) pattern, this.module.getExports());
+		matchPackReferences(locator, (PackageReferencePattern) pattern, this.module.getOpens());
+		matchPackReferences(locator, (PackageReferencePattern) pattern, this.module.getUses());
+		TypeBinding[] services = this.module.getServices();
+		if (services != null) {
+			matchPackReferences(locator, (PackageReferencePattern) pattern, services);
+			for (TypeBinding service : services) {
+				matchPackReferences(locator, (PackageReferencePattern) pattern, this.module.getImplementations(service));
+			}
+		}
+	}
+	private void matchPackReferences(MatchLocator locator, PackageReferencePattern packReferencePattern,
+			PackageBinding[] packBindings) throws CoreException {
+		if (packBindings == null) return;
+		for (PackageBinding pb : packBindings) {
+			reportPackageMatch(locator, pb);
+		}
+	}
+	private void reportPackageMatch(MatchLocator locator, PackageBinding packageBinding) throws CoreException{
+		if (packageBinding == null) return;
+		int level =  locator.patternLocator.resolveLevel(packageBinding);
+		if (level == PatternLocator.IMPOSSIBLE_MATCH) return;
+		int accuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;
+		PackageReferenceMatch match = locator.newPackageReferenceMatch(this.moduleDesc, accuracy, -1, 0, null);
+		locator.report(match);
+	}
+	private void matchPackReferences(MatchLocator locator, PackageReferencePattern packReferencePattern,
+			TypeBinding[] types) throws CoreException {
+		if (types == null) return;
+		for (TypeBinding type : types) {
+			reportPackageMatch(locator, type.getPackage());
+		}
+	}
+	private void matchTypeReferences(SearchPattern pattern, MatchLocator locator) throws CoreException {
+		// Only process TypeReference patterns
+		switch (pattern.kind) {
+			case TYPE_REF_PATTERN:
+				break;
+			case OR_PATTERN:
+				SearchPattern[] patterns = ((OrPattern) pattern).patterns;
+				for (int i = 0, length = patterns.length; i < length; i++) {
+					SearchPattern p = patterns[i];
+					if (p.kind == TYPE_REF_PATTERN)
+						matchTypeReferences(patterns[i], locator);
+				}
+				// $FALL-THROUGH$ - fall through default to return
+			default:
+				return;
+		}
+		matchTypeReferences(locator, (TypeReferencePattern) pattern, this.module.getUses());
+		TypeBinding[] services = this.module.getServices();
+		if (services != null) {
+			matchTypeReferences(locator, (TypeReferencePattern) pattern, services);
+			for (TypeBinding service : services) {
+				matchTypeReferences(locator, (TypeReferencePattern) pattern, this.module.getImplementations(service));
+			}
+		}
+	}
+	private void matchTypeReferences(MatchLocator locator, TypeReferencePattern typeReferencePattern,
+			TypeBinding[] types) throws CoreException {
+		if (types == null) 	return;
+		for (TypeBinding type : types) {
+			int level =  locator.patternLocator.resolveLevel(type);
+			if (level == PatternLocator.IMPOSSIBLE_MATCH) continue;
+			int accuracy = level == PatternLocator.ACCURATE_MATCH ? SearchMatch.A_ACCURATE : SearchMatch.A_INACCURATE;
+			TypeReferenceMatch match = locator.newTypeReferenceMatch(this.moduleDesc, null, accuracy, -1, 0, null);
+			locator.report(match);
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
index 2de1236..9180d6f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ModuleLocator.java
@@ -79,10 +79,10 @@ public class ModuleLocator extends PatternLocator {
 	protected int referenceType() {
 		return IJavaElement.JAVA_MODULE;
 	}
+	@Override
 	public int resolveLevel(Binding binding) {
 		if (binding == null) return INACCURATE_MATCH;
 		if (!(binding instanceof ModuleBinding)) return IMPOSSIBLE_MATCH;
 		return (matchesName(this.pattern.name, binding.readableName())) ? ACCURATE_MATCH : IMPOSSIBLE_MATCH;
-			
 	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
index dfb079b..51da1ef 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java
@@ -431,7 +431,7 @@ protected void matchReportReference(ASTNode reference, IJavaElement element, Bin
 			this.match = locator.newTypeParameterReferenceMatch(element, accuracy, offset, reference.sourceEnd-offset+1, reference);
 			break;
 		case IJavaElement.JAVA_MODULE:
-			this.match = locator.newTypeReferenceMatch(element, elementBinding, accuracy, offset, reference.sourceEnd-offset+1, reference);
+			this.match = locator.newModuleReferenceMatch(element, elementBinding, accuracy, offset, reference.sourceEnd-offset+1, reference);
 			break;
 	}
 	if (this.match != null) {
commit 9228b527f2119ceb61b755b355bde00106082ec7
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Fri Sep 8 17:08:58 2017 +0530

    Fix for Bug 501162: [9][search] find constructs in module-info [comment
    32 : part and multi-module splitpackagebinding code fix]
    
    Change-Id: I51c962f8832f0144ed42484fcab7e56f8290383b

608	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
-	-	org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero.src.501162.jar
3	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
1	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index 4a20b81..4065575 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -1567,6 +1567,614 @@ public void testBug501162_032() throws Exception {
 		deleteProject("JavaSearchBugs9");
 	}
 }
+public void testBug501162_033() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.one",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [pack.one] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_034() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.two",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [pack.two] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_035() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.three",
+				IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_036() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("java.base",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_037() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("zerotest",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_038() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("first",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_039() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("four",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_040() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("nomodule",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_041() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);		
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [XOne] EXACT_MATCH\n" + 
+				"src/pack1/X.java pack1.X.X1 [XOne] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_042() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XFourOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_043() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("ITwo",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack1/X.java [ITwo] EXACT_MATCH\n" +
+				"src/pack1/X.java pack1.X.i2 [ITwo] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" + 
+				"lib/bzero.src.501162.jar pack.one.XOne EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar pack.one.XOne.itwo EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar pack.two.XTwo EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_044() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("IThreeOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar pack.three.XThreeOne EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_045() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("XThreeOne",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void testBug501162_046() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+			"module zerotest {\n" +
+			"    requires zero;\n" +
+			"}\n";
+		createFile("/JavaSearchBugs9/src/module-info.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/pack1");
+		createFile("/JavaSearchBugs9/src/pack1/X.java",
+				"package pack1;\n" +
+				"import pack.one.XOne;\n" +
+				"import pack.two.ITwo;\n" +
+				"public class X {\n" +
+				"    public ITwo i2;\n" +
+				"    public XOne X1;\n" +
+				"}\n");
+		addLibraryEntry(project1, "/JavaSearchBugs/lib/bzero.src.501162.jar", false);
+		project1.close(); // sync
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("zero",
+				IJavaSearchConstants.MODULE, IJavaSearchConstants.DECLARATIONS, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+	}
+}
+public void _testBug501162_047() throws Exception {
+	try {
+		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project1.open(null);
+		addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String fileContent =
+				"package pack.top;\n" +
+				"import pack.first.Y;\n" +
+				"import pack.first.second.Z;\n" +
+				"\n" +
+				"public class X {\n" +
+				"	public Y y;\n" +
+				"	public Z z;\n" +
+				"}\n";
+		createFolder("/JavaSearchBugs9/src/pack");
+		createFolder("/JavaSearchBugs9/src/pack/top");
+		createFile("/JavaSearchBugs9/src/pack/top/X.java",	fileContent);
+		project1.close(); // sync
+		project1.open(null);
+
+		IJavaProject project2 = createJavaProject("split.first", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project2.open(null);
+		addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+		String file = 
+				"module split.first {\n" +
+				"    exports  pack.first;\n" +
+				"}\n";
+		createFile("/split.first/src/module-info.java",	file);
+		createFolder("/split.first/src/pack");
+		createFolder("/split.first/src/pack/first");
+		createFile("/split.first/src/pack/first/Y.java",
+				"package pack.first;\n" +
+				"public class Y{}\n");
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+
+		IJavaProject project3 = createJavaProject("split.second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
+		project3.open(null);
+		file = 
+				"module split.second {\n" +
+				"    exports  pack.first.second;\n" +
+				"}\n";
+		createFile("/split.second/src/module-info.java", file);
+		createFolder("/split.second/src/pack");
+		createFolder("/split.second/src/pack/first");
+		createFolder("/split.second/src/pack/first/second");
+		createFile("/split.second/src/pack/first/second/Z.java",
+				"package pack.first.second;\n" +
+				"public class Z{}\n");
+		addClasspathEntry(project1, JavaCore.newProjectEntry(project3.getPath()));
+
+		project1.close(); // sync
+		project2.close();
+		project3.close();
+		project3.open(null);
+		project2.open(null);
+		project1.open(null);
+		SearchPattern pattern = SearchPattern.createPattern("pack.first.Y",
+				IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, EXACT_RULE);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaProject[]
+				{getJavaProject("JavaSearchBugs9")});
+		search(pattern, scope, this.resultCollector);
+
+		assertSearchResults(
+				"src/pack/top/X.java [pack.first.Y] EXACT_MATCH\n" +
+				"src/pack/top/X.java pack.top.X.y [Y] EXACT_MATCH",
+			this.resultCollector);
+	}
+	finally {
+		deleteProject("JavaSearchBugs9");
+		deleteProject("split.first");
+		deleteProject("split.second");
+	}
+}
 public void testBug519211_001() throws CoreException {
 	try {
 
diff --git a/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero.src.501162.jar b/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero.src.501162.jar
new file mode 100644
index 0000000..eb39805
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/JavaSearchBugs/lib/bzero.src.501162.jar differ
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index da0eb13..7828b0a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -40,7 +40,6 @@ import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.ClasspathEntry;
 import org.eclipse.jdt.internal.core.JavaElement;
@@ -340,9 +339,9 @@ public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] pa
 	for (ClasspathLocation location : this.locationSet) {
 		if (strategy.matches(location, ClasspathLocation::hasModule) ) {
 			if (location.isPackage(qualifiedPackageName, null)) {
-				IModule module = location.getModule();
-				char[] aName = module != null ? module.name() : ModuleBinding.UNNAMED;
-				moduleNames = CharOperation.arrayConcat(moduleNames, aName); // FIXME(SHMOD): handle multiple modules per location https://bugs.eclipse.org/501162#c29
+				char[][] mNames = location.getModulesDeclaringPackage(qualifiedPackageName, null);
+				if (mNames == null || mNames.length == 0) continue;
+				moduleNames = CharOperation.arrayConcat(moduleNames, mNames);
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index ee5e393..5fc43e0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -78,12 +78,7 @@ public char[] getContents() {
 					IType type = ((ClassFile) this.openable).getType();
 					contents = sourceMapper.findSource(type, fileName);
 				} else if (this.openable instanceof ModularClassFile) {
-					try {
-						IModuleDescription module = ((ModularClassFile) this.openable).getModule();
-						contents = sourceMapper.findSource(module);
-					} catch (JavaModelException e) {
-						return CharOperation.NO_CHAR;
-					}
+					return CharOperation.NO_CHAR; // do not return contents
 				}
 			}
 		} else {
commit 9a39316c189235298947b6f52380404f073fe3bc
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Wed Sep 13 15:24:24 2017 +0530

    Fix for Bug 501162: [9][search] find constructs in module-info [ref
    comment 39]

26	27	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
3	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
6	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
index 4065575..c19e06a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs9Tests.java
@@ -1598,8 +1598,8 @@ public void testBug501162_033() throws Exception {
 
 		assertSearchResults(
 				"src/pack1/X.java [pack.one] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1637,9 +1637,9 @@ public void testBug501162_034() throws Exception {
 
 		assertSearchResults(
 				"src/pack1/X.java [pack.two] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1676,17 +1676,17 @@ public void testBug501162_035() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
 		deleteProject("JavaSearchBugs9");
 	}
 }
-public void testBug501162_036() throws Exception {
+public void _testBug501162_036() throws Exception {
 	try {
 		IJavaProject project1 = createJavaProject("JavaSearchBugs9", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 		project1.open(null);
@@ -1753,8 +1753,8 @@ public void testBug501162_037() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1791,7 +1791,7 @@ public void testBug501162_038() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1828,7 +1828,7 @@ public void testBug501162_039() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1904,7 +1904,7 @@ public void testBug501162_041() throws Exception {
 		assertSearchResults(
 				"src/pack1/X.java [XOne] EXACT_MATCH\n" + 
 				"src/pack1/X.java pack1.X.X1 [XOne] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1941,7 +1941,7 @@ public void testBug501162_042() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -1980,7 +1980,7 @@ public void testBug501162_043() throws Exception {
 		assertSearchResults(
 				"src/pack1/X.java [ITwo] EXACT_MATCH\n" +
 				"src/pack1/X.java pack1.X.i2 [ITwo] EXACT_MATCH\n" +
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" + 
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" + 
 				"lib/bzero.src.501162.jar pack.one.XOne EXACT_MATCH\n" +
 				"lib/bzero.src.501162.jar pack.one.XOne.itwo EXACT_MATCH\n" +
 				"lib/bzero.src.501162.jar pack.two.XTwo EXACT_MATCH",
@@ -2020,7 +2020,7 @@ public void testBug501162_044() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH\n" +
+				"lib/bzero.src.501162.jar zero EXACT_MATCH\n" +
 				"lib/bzero.src.501162.jar pack.three.XThreeOne EXACT_MATCH",
 			this.resultCollector);
 	}
@@ -2058,7 +2058,7 @@ public void testBug501162_045() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -2095,7 +2095,7 @@ public void testBug501162_046() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"lib/bzero.src.501162.jar zero [No source] EXACT_MATCH",
+				"lib/bzero.src.501162.jar zero EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
@@ -2110,15 +2110,14 @@ public void _testBug501162_047() throws Exception {
 		String fileContent =
 				"package pack.top;\n" +
 				"import pack.first.Y;\n" +
-				"import pack.first.second.Z;\n" +
+				"//import pack.first.second.Z;\n" +
 				"\n" +
 				"public class X {\n" +
 				"	public Y y;\n" +
-				"	public Z z;\n" +
+				"	//public Z z;\n" +
 				"}\n";
-		createFolder("/JavaSearchBugs9/src/pack");
-		createFolder("/JavaSearchBugs9/src/pack/top");
-		createFile("/JavaSearchBugs9/src/pack/top/X.java",	fileContent);
+		createFolder("/JavaSearchBugs9/src/top");
+		createFile("/JavaSearchBugs9/src/top/X.java",	fileContent);
 		project1.close(); // sync
 		project1.open(null);
 
@@ -2165,8 +2164,8 @@ public void _testBug501162_047() throws Exception {
 		search(pattern, scope, this.resultCollector);
 
 		assertSearchResults(
-				"src/pack/top/X.java [pack.first.Y] EXACT_MATCH\n" +
-				"src/pack/top/X.java pack.top.X.y [Y] EXACT_MATCH",
+				"src/top/X.java [pack.first.Y] EXACT_MATCH\n" +
+				"src/top/X.java pack.top.X.y [Y] EXACT_MATCH",
 			this.resultCollector);
 	}
 	finally {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index ac30c09..fae4fdb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -1898,7 +1898,8 @@ protected void process(PossibleMatch possibleMatch, boolean bindingsWereCreated)
 						this.patternLocator.mayBeGeneric = mayBeGeneric;
 					}
 				}
-			} else if (this.currentPossibleMatch.openable instanceof ModularClassFile) {
+			} else if (this.currentPossibleMatch.openable instanceof ModularClassFile &&
+					unit.moduleDeclaration == null) { // no source
 				boolean mayBeGeneric = this.patternLocator.mayBeGeneric;
 				this.patternLocator.mayBeGeneric = false; // there's no longer generic in class files
 				try {
@@ -3045,7 +3046,7 @@ protected void reportMatching(TypeDeclaration type, IJavaElement parent, int acc
 					}
 				}
 			}
-			enclosingElement = anonType != null ? anonType : ((IClassFile)this.currentPossibleMatch.openable).getType() ;
+			enclosingElement = anonType != null ? anonType : ((IOrdinaryClassFile)this.currentPossibleMatch.openable).getType() ;
 		} else {
 			enclosingElement = member.getType(new String(type.name), occurrenceCount);
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index 5fc43e0..d7a92b4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -78,7 +78,12 @@ public char[] getContents() {
 					IType type = ((ClassFile) this.openable).getType();
 					contents = sourceMapper.findSource(type, fileName);
 				} else if (this.openable instanceof ModularClassFile) {
-					return CharOperation.NO_CHAR; // do not return contents
+					try {
+						IModuleDescription module = ((ModularClassFile) this.openable).getModule();
+						contents = module != null ? sourceMapper.findSource(module) : CharOperation.NO_CHAR; // FIXME(SHMOD)
+					} catch (JavaModelException e) {
+						return CharOperation.NO_CHAR;
+					}
 				}
 			}
 		} else {
