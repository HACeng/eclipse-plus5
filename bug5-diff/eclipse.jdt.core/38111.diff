commit 627e74400f5d869da7cccfccaf9f22c5e00c372a
Author: David Audel <daudel>
Date:   Wed Oct 22 08:27:57 2008 +0000

    HEAD - bug 38111

122	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
627	202	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
14	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
39	57	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
26	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
48	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
26	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
372	175	org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
589	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
2	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
2	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 54e92ae..7e70c8a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -5160,8 +5160,123 @@ public void testCompletionFieldName2() throws JavaModelException {
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
 	assertResults(
-			"nameRequestor[VARIABLE_DECLARATION]{nameRequestor, null, Ltest.TypeNameRequestor;, nameRequestor, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}\n" +
-			"nameTypeNameRequestor[VARIABLE_DECLARATION]{nameTypeNameRequestor, null, Ltest.TypeNameRequestor;, nameTypeNameRequestor, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}",
+			"nameTypeNameRequestor[VARIABLE_DECLARATION]{nameTypeNameRequestor, null, Ltest.TypeNameRequestor;, nameTypeNameRequestor, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}\n" +
+			"nameRequestor[VARIABLE_DECLARATION]{nameRequestor, null, Ltest.TypeNameRequestor;, nameRequestor, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_LESS_NEW_CHARACTERS + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+public void testCompletionFieldName3() throws JavaModelException { 
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/TypeNameRequestor.java",
+		"package test;"+
+		"public class TypeNameRequestor {\n" +
+		"  public static final TypeNameRequestor \n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "final TypeNameRequestor ";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"NAME_REQUESTOR[VARIABLE_DECLARATION]{NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}\n" +
+			"REQUESTOR[VARIABLE_DECLARATION]{REQUESTOR, null, Ltest.TypeNameRequestor;, REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}\n" +
+			"TYPE_NAME_REQUESTOR[VARIABLE_DECLARATION]{TYPE_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, TYPE_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+public void testCompletionFieldName4() throws JavaModelException { 
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/TypeNameRequestor.java",
+		"package test;"+
+		"public class TypeNameRequestor {\n" +
+		"  public static final TypeNameRequestor nam\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "final TypeNameRequestor nam";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"NAM_REQUESTOR[VARIABLE_DECLARATION]{NAM_REQUESTOR, null, Ltest.TypeNameRequestor;, NAM_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_NON_RESTRICTED) + "}\n" +
+			"NAM_TYPE_NAME_REQUESTOR[VARIABLE_DECLARATION]{NAM_TYPE_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, NAM_TYPE_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_NON_RESTRICTED) + "}\n" +
+			"NAME_REQUESTOR[VARIABLE_DECLARATION]{NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_NAME_LESS_NEW_CHARACTERS+ R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+public void testCompletionFieldName5() throws JavaModelException { 
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/TypeNameRequestor.java",
+		"package test;"+
+		"public class TypeNameRequestor {\n" +
+		"  public static final TypeNameRequestor ZZ\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "final TypeNameRequestor ZZ";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"ZZ_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZ_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZ_REQUESTOR[VARIABLE_DECLARATION]{ZZ_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZ_TYPE_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZ_TYPE_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_TYPE_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+public void testCompletionFieldName6() throws JavaModelException { 
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/TypeNameRequestor.java",
+		"package test;"+
+		"public class TypeNameRequestor {\n" +
+		"  public static final TypeNameRequestor ZZN\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "final TypeNameRequestor ZZN";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"ZZN_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZN_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZN_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZN_REQUESTOR[VARIABLE_DECLARATION]{ZZN_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZN_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZN_TYPE_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZN_TYPE_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZN_TYPE_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+public void testCompletionFieldName7() throws JavaModelException { 
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/TypeNameRequestor.java",
+		"package test;"+
+		"public class TypeNameRequestor {\n" +
+		"  public static final TypeNameRequestor ZZ_N\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "final TypeNameRequestor ZZ_N";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"ZZ_N_REQUESTOR[VARIABLE_DECLARATION]{ZZ_N_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_N_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZ_N_TYPE_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZ_N_TYPE_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_N_TYPE_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED) + "}\n" +
+			"ZZ_NAME_REQUESTOR[VARIABLE_DECLARATION]{ZZ_NAME_REQUESTOR, null, Ltest.TypeNameRequestor;, ZZ_NAME_REQUESTOR, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_LESS_NEW_CHARACTERS + R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
 
@@ -13906,7 +14021,9 @@ public void testCompletionVariableName1() throws JavaModelException {
 
 	assertEquals(
 		"element:class1    completion:class1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
-		"element:myClass    completion:myClass    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED),
+		"element:fooMyClass    completion:fooMyClass    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
+		"element:myClass    completion:myClass    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
+		"element:testFooMyClass    completion:testFooMyClass    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE+ R_NON_RESTRICTED),
 		requestor.getResults());
 }
 public void testCompletionVariableName10() throws JavaModelException {
@@ -14296,10 +14413,10 @@ public void testCompletionVariableName2() throws JavaModelException {
 	cu.codeComplete(cursorLocation, requestor);
 
 	assertEquals(
-		"element:bar_MyClass    completion:bar_MyClass    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
+		"element:barMyClass    completion:barMyClass    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
 		"element:class1    completion:class1    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
 		"element:myClass    completion:myClass    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE + R_NON_RESTRICTED)+"\n" +
-		"element:test_Bar_MyClass    completion:test_Bar_MyClass    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE+ R_NON_RESTRICTED),
+		"element:testBarMyClass    completion:testBarMyClass    relevance:"+(R_DEFAULT  + R_INTERESTING + R_CASE+ R_NON_RESTRICTED),
 		requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=150228
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
index 35ebaa2..febc750 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
@@ -41,7 +41,7 @@ public void setUp() throws Exception {
 	super.setUp();
 	this.project = createJavaProject("P", new String[]{"src"}, "bin"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 	this.oldOptions = JavaCore.getOptions();
-	this.abortOnFailure = false; // some tests have failing one time on macos boxes => do not abort on failures
+//	this.abortOnFailure = false; // some tests have failing one time on macos boxes => do not abort on failures
 }
 /**
  * Cleanup after the previous test.
@@ -53,45 +53,96 @@ public void tearDown() throws Exception {
 
 	super.tearDown();
 }
-private String toString(char[][] suggestions) {
-	if(suggestions == null) {
-		return ""; //$NON-NLS-1$
-	}
-
-	StringBuffer buffer = new StringBuffer();
-	for (int i = 0; i < suggestions.length; i++) {
-		if(i != 0) {
-			buffer.append('\n');
-		}
-		buffer.append(suggestions[i]);
-	}
-	return buffer.toString();
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testGetBaseName001() {
+	String baseName = NamingConventions.getBaseName(
+			NamingConventions.VK_INSTANCE_FIELD,
+			"OneName", //$NON-NLS-1$
+			this.project);
+	
+	assertEquals(
+			"OneName", //$NON-NLS-1$
+			baseName);
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testGetBaseName002() {
+	String baseName = NamingConventions.getBaseName(
+			NamingConventions.VK_CONSTANT_FIELD,
+			"ONE_NAME", //$NON-NLS-1$
+			this.project);
+	
+	assertEquals(
+			"OneName", //$NON-NLS-1$
+			baseName);
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testGetBaseName003() {
+	Hashtable options = JavaCore.getOptions();
+	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
+	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
+	JavaCore.setOptions(options);
+	
+	String baseName = NamingConventions.getBaseName(
+			NamingConventions.VK_INSTANCE_FIELD,
+			"preOneNamesuf", //$NON-NLS-1$
+			this.project);
+	
+	assertEquals(
+			"OneName", //$NON-NLS-1$
+			baseName);
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testGetBaseName004() {
+	Hashtable options = JavaCore.getOptions();
+	options.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
+	options.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
+	JavaCore.setOptions(options);
+	
+	String baseName = NamingConventions.getBaseName(
+			NamingConventions.VK_CONSTANT_FIELD,
+			"preONE_NAMEsuf", //$NON-NLS-1$
+			this.project);
+	
+	assertEquals(
+			"OneName", //$NON-NLS-1$
+			baseName);
 }
 public void testSuggestFieldName001() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
 	assumeEquals(
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName002() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneClass".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
-
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneClass", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+	
 	assumeEquals(
-		"class1\n" + //$NON-NLS-1$
-		"oneClass", //$NON-NLS-1$
+		"oneClass\n" + //$NON-NLS-1$
+		"class1", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName003() {
@@ -99,19 +150,20 @@ public void testSuggestFieldName003() {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"f"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
 
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"fName\n" + //$NON-NLS-1$
 		"fOneName\n" + //$NON-NLS-1$
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"fName\n" + //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName004() {
@@ -119,19 +171,20 @@ public void testSuggestFieldName004() {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"_"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
 
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"_name\n" + //$NON-NLS-1$
 		"_oneName\n" + //$NON-NLS-1$
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"_name\n" + //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName005() {
@@ -139,20 +192,21 @@ public void testSuggestFieldName005() {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"f"); //$NON-NLS-1$
 	options.put(JavaCore.CODEASSIST_STATIC_FIELD_PREFIXES,"fg"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
-
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		Flags.AccStatic,
-		CharOperation.NO_CHAR_CHAR);
+	
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_STATIC_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"fgName\n" + //$NON-NLS-1$
 		"fgOneName\n" + //$NON-NLS-1$
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"fgName\n" + //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName006() {
@@ -161,23 +215,24 @@ public void testSuggestFieldName006() {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
 
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"preNamesuf\n" + //$NON-NLS-1$
 		"preOneNamesuf\n" + //$NON-NLS-1$
-		"preName\n" + //$NON-NLS-1$
+		"preNamesuf\n" + //$NON-NLS-1$
 		"preOneName\n" + //$NON-NLS-1$
-		"namesuf\n" + //$NON-NLS-1$
+		"preName\n" + //$NON-NLS-1$
 		"oneNamesuf\n" + //$NON-NLS-1$
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"namesuf\n" + //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName007() {
@@ -186,13 +241,14 @@ public void testSuggestFieldName007() {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
 
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"int".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"int", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"preIsuf\n" + //$NON-NLS-1$
@@ -202,17 +258,18 @@ public void testSuggestFieldName007() {
 		toString(suggestions));
 }
 public void testSuggestFieldName008() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{"name".toCharArray()}); //$NON-NLS-1$
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{"name"}, //$NON-NLS-1$
+			true);
 
 	assumeEquals(
-		"name2\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name2", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName009() {
@@ -221,23 +278,24 @@ public void testSuggestFieldName009() {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
 
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{"preNamesuf".toCharArray()}); //$NON-NLS-1$
-
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{"preNamesuf"}, //$NON-NLS-1$
+			true);
+	
 	assumeEquals(
-		"preName2suf\n" + //$NON-NLS-1$
 		"preOneNamesuf\n" + //$NON-NLS-1$
-		"preName\n" + //$NON-NLS-1$
+		"preName2suf\n" + //$NON-NLS-1$
 		"preOneName\n" + //$NON-NLS-1$
-		"namesuf\n" + //$NON-NLS-1$
+		"preName\n" + //$NON-NLS-1$
 		"oneNamesuf\n" + //$NON-NLS-1$
-		"name\n" + //$NON-NLS-1$
-		"oneName", //$NON-NLS-1$
+		"namesuf\n" + //$NON-NLS-1$
+		"oneName\n" + //$NON-NLS-1$
+		"name", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName010() {
@@ -245,100 +303,108 @@ public void testSuggestFieldName010() {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
 	JavaCore.setOptions(options);
-
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"OneName".toCharArray(), //$NON-NLS-1$
-		1,
-		0,
-		new char[][]{"preNamesuf".toCharArray()}); //$NON-NLS-1$
+	
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"OneName", //$NON-NLS-1$
+			this.project,
+			1,
+			new String[]{"preNamesuf"}, //$NON-NLS-1$
+			true);
 
 	assumeEquals(
-		"preNamessuf\n" + //$NON-NLS-1$
 		"preOneNamessuf\n" + //$NON-NLS-1$
-		"preNames\n" + //$NON-NLS-1$
+		"preNamessuf\n" + //$NON-NLS-1$
 		"preOneNames\n" + //$NON-NLS-1$
-		"namessuf\n" + //$NON-NLS-1$
+		"preNames\n" + //$NON-NLS-1$
 		"oneNamessuf\n" + //$NON-NLS-1$
-		"names\n" + //$NON-NLS-1$
-		"oneNames", //$NON-NLS-1$
+		"namessuf\n" + //$NON-NLS-1$
+		"oneNames\n" + //$NON-NLS-1$
+		"names", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName011() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c".toCharArray(), //$NON-NLS-1$
-		"Factory".toCharArray(), //$NON-NLS-1$
-		1,
-		0,
-		CharOperation.NO_CHAR_CHAR); //$NON-NLS-1$
+	
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"Factory", //$NON-NLS-1$
+			this.project,
+			1,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"factories", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName012() {
-	String[] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"a.b.c", //$NON-NLS-1$
-		"FooBar", //$NON-NLS-1$
-		0,
-		0,
-		new String[]{"bar"}); //$NON-NLS-1$
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"FooBar", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{"bar"}, //$NON-NLS-1$
+			true);
 
 	assumeEquals(
-		"bar2\n" + //$NON-NLS-1$
-		"fooBar", //$NON-NLS-1$
+		"fooBar\n" + //$NON-NLS-1$
+		"bar2", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName013() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"java.lang".toCharArray(), //$NON-NLS-1$
-		"Class".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"Class", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"class1",//$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName014() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"java.lang".toCharArray(), //$NON-NLS-1$
-		"Class".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{"class1".toCharArray()}); //$NON-NLS-1$
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"Class", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{"class1"}, //$NON-NLS-1$
+			true);
 
 	assumeEquals(
 		"class2",//$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName015() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"#".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		CharOperation.NO_CHAR_CHAR);
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"#", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"name",//$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName016() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"#".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{"name".toCharArray()}); //$NON-NLS-1$
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"#", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{"name"}, //$NON-NLS-1$
+			true);
 
 	assumeEquals(
 		"name2",//$NON-NLS-1$
@@ -348,13 +414,14 @@ public void testSuggestFieldName016() {
  * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=35356
  */
 public void testSuggestFieldName017() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"names".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{});
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"names", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"names",//$NON-NLS-1$
@@ -364,13 +431,14 @@ public void testSuggestFieldName017() {
  * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=35356
  */
 public void testSuggestFieldName018() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"names".toCharArray(), //$NON-NLS-1$
-		1,
-		0,
-		new char[][]{});
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"names", //$NON-NLS-1$
+			this.project,
+			1,
+			new String[]{},
+			true);
 
 	assumeEquals(
 		"names",//$NON-NLS-1$
@@ -380,36 +448,385 @@ public void testSuggestFieldName018() {
  * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=35356
  */
 public void testSuggestFieldName019() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"MyClass".toCharArray(), //$NON-NLS-1$
-		0,
-		0,
-		new char[][]{});
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyClass", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"class1\n" + //$NON-NLS-1$
-		"myClass", //$NON-NLS-1$
+		"myClass\n" + //$NON-NLS-1$
+		"class1", //$NON-NLS-1$
 		toString(suggestions));
 }
 /*
  * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=35356
  */
 public void testSuggestFieldName020() {
-	char[][] suggestions = NamingConventions.suggestFieldNames(
-		this.project,
-		"".toCharArray(), //$NON-NLS-1$
-		"MyClass".toCharArray(), //$NON-NLS-1$
-		1,
-		0,
-		new char[][]{});
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyClass", //$NON-NLS-1$
+			this.project,
+			1,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"myClasses\n" + //$NON-NLS-1$
+		"classes", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName021() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"MY_TYPE\n" + //$NON-NLS-1$
+		"TYPE", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName022() {
+	Hashtable options = JavaCore.getOptions();
+	options.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
+	options.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
+	JavaCore.setOptions(options);
+	
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"preMY_TYPEsuf\n" + //$NON-NLS-1$
+		"preTYPEsuf\n" + //$NON-NLS-1$
+		"preMY_TYPE\n" + //$NON-NLS-1$
+		"preTYPE\n" + //$NON-NLS-1$
+		"MY_TYPEsuf\n" + //$NON-NLS-1$
+		"TYPEsuf\n" + //$NON-NLS-1$
+		"MY_TYPE\n" + //$NON-NLS-1$
+		"TYPE", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName023() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_NAME,
+			"oneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"oneName", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName024() {
+	Hashtable options = JavaCore.getOptions();
+	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
+	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,"suf"); //$NON-NLS-1$
+	JavaCore.setOptions(options);
+	
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_NAME,
+			"oneName", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"preOneNamesuf\n" + //$NON-NLS-1$
+		"preOneName\n" + //$NON-NLS-1$
+		"oneNamesuf\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName025() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"My_Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"MY_TYPE\n" + //$NON-NLS-1$
+		"TYPE", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName026() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"_MyType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"MY_TYPE\n" + //$NON-NLS-1$
+		"TYPE", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName027() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyType_", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"MY_TYPE\n" + //$NON-NLS-1$
+		"TYPE", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName028() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_CONSTANT_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyTyp_e", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"MY_TYP_E\n" + //$NON-NLS-1$
+		"TYP_E\n" + //$NON-NLS-1$
+		"E", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName029() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"My1Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"my1Type\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName030() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"M1yType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"m1yType\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName031() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MY1Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"my1Type\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName032() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"M1YType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"m1yType\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName033() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"My_First_Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"myFirstType\n" +  //$NON-NLS-1$
+		"firstType\n" +  //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName034() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MY_FIRST_Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"myFirstType\n" +  //$NON-NLS-1$
+		"firstType\n" +  //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName035() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"my_first_Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"myFirstType\n" + //$NON-NLS-1$
+		"firstType\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName036() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"MyFirst_9_Type", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"myFirst_9Type\n" + //$NON-NLS-1$
+		"first_9Type\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName037() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"AType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
+
+	assumeEquals(
+		"aType\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
+		toString(suggestions));
+}
+/*
+ * bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=38111
+ */
+public void testSuggestFieldName038() {
+	String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_INSTANCE_FIELD,
+			NamingConventions.BK_TYPE_NAME,
+			"aType", //$NON-NLS-1$
+			this.project,
+			0,
+			new String[]{},
+			true);
 
 	assumeEquals(
-		"classes\n" + //$NON-NLS-1$
-		"myClasses", //$NON-NLS-1$
+		"aType\n" + //$NON-NLS-1$
+		"type", //$NON-NLS-1$
 		toString(suggestions));
 }
+/** @deprecated */
 public void testRemovePrefixAndSuffixForFieldName001() {
 	Hashtable options = JavaCore.getOptions();
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pre"); //$NON-NLS-1$
@@ -425,6 +842,7 @@ public void testRemovePrefixAndSuffixForFieldName001() {
 		"oneName", //$NON-NLS-1$
 		new String(name));
 }
+/** @deprecated */
 public void testRemovePrefixAndSuffixForFieldName002() {
 	Hashtable options = JavaCore.getOptions();
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pr, pre"); //$NON-NLS-1$
@@ -440,6 +858,7 @@ public void testRemovePrefixAndSuffixForFieldName002() {
 		"preOneNamesuf", //$NON-NLS-1$
 		new String(name));
 }
+/** @deprecated */
 public void testRemovePrefixAndSuffixForFieldName003() {
 	Hashtable options = JavaCore.getOptions();
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pr, pre"); //$NON-NLS-1$
@@ -456,6 +875,7 @@ public void testRemovePrefixAndSuffixForFieldName003() {
 		new String(name));
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=114086
+/** @deprecated */
 public void testRemovePrefixAndSuffixForFieldName004() {
 	Hashtable options = JavaCore.getOptions();
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,"pre,"); //$NON-NLS-1$
@@ -470,6 +890,7 @@ public void testRemovePrefixAndSuffixForFieldName004() {
 		"oneName", //$NON-NLS-1$
 		new String(name));
 }
+/** @deprecated */
 public void testRemovePrefixAndSuffixForLocalName001() {
 	Hashtable options = JavaCore.getOptions();
 	options.put(JavaCore.CODEASSIST_LOCAL_PREFIXES,"pr, pre"); //$NON-NLS-1$
@@ -633,12 +1054,14 @@ public void testSuggestLocalName001() {
 		newOptions.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
 		this.project.setOptions(newOptions);
 
-		String[] suggestions = NamingConventions.suggestLocalVariableNames(
+		String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_LOCAL,
+			NamingConventions.BK_TYPE_NAME,
+			"Enum",
 			this.project,
-			"",//$NON-NLS-1$
-			"Enum",//$NON-NLS-1$
 			0,
-			new String[]{"o"});
+			new String[]{"o"}, //$NON-NLS-1$
+			true);
 
 		assumeEquals(
 			"enum1", //$NON-NLS-1$
@@ -659,12 +1082,14 @@ public void testSuggestLocalName002() {
 		newOptions.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
 		this.project.setOptions(newOptions);
 
-		String[] suggestions = NamingConventions.suggestLocalVariableNames(
+		String[] suggestions = NamingConventions.suggestVariableNames(
+			NamingConventions.VK_LOCAL,
+			NamingConventions.BK_TYPE_NAME,
+			"Enums",
 			this.project,
-			"",//$NON-NLS-1$
-			"Enums",//$NON-NLS-1$
 			0,
-			new String[]{"o"});
+			new String[]{"o"}, //$NON-NLS-1$
+			true);
 
 		assumeEquals(
 			"enums", //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index e5e58e0..c3c8693 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -15,7 +15,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Java Compiler
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.919, 3.5.0 milestone-3
+compiler.version = 0.920, 3.5.0 milestone-3
 compiler.copyright = Copyright IBM Corp 2000, 2008. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 737a7e4..6f1f2e4 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -39,11 +39,24 @@
 	</td>
   </tr>
 </table>
+<a name="v_920"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java Development Tooling Core</h1>
+Eclipse SDK 3.5M3 - %date% - 3.5 MILESTONE 3
+<br>Project org.eclipse.jdt.core v_920
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_920">cvs</a>).
+<h2>What's new in this drop</h2>
+
+<h3>Problem Reports Fixed</h3>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=38111">38111</a>
+[DCR] Make NamingConventions more flexible
+
 <a name="v_919"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java Development Tooling Core</h1>
-Eclipse SDK 3.5M3 - October 21, 2008 - 3.5 MILESTONE 3
+Eclipse SDK 3.5M3 - October 21, 2008
 <br>Project org.eclipse.jdt.core v_919
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_919">cvs</a>).
 <h2>What's new in this drop</h2>
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 2f3f3da..69124c0 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -342,10 +342,6 @@ public final class CompletionEngine
 	private final static int SUPERTYPE = 1;
 	private final static int SUBTYPE = 2;
 	
-	private final static int FIELD = 0;
-	private final static int LOCAL = 1;
-	private final static int ARGUMENT = 2;
-	
 	int expectedTypesPtr = -1;
 	TypeBinding[] expectedTypes = new TypeBinding[1];
 	int expectedTypesFilter;
@@ -1559,7 +1555,15 @@ public final class CompletionEngine
 
 			this.completionToken = field.realName;
 
-			findVariableNames(field.realName, field.type, excludeNames, null, FIELD, field.modifiers);
+			
+			int kind =
+				 (field.modifiers & ClassFileConstants.AccStatic) == 0 ? 
+						InternalNamingConventions.VK_INSTANCE_FIELD :
+							(field.modifiers & ClassFileConstants.AccFinal) == 0 ? 
+									InternalNamingConventions.VK_STATIC_FIELD :
+										InternalNamingConventions.VK_CONSTANT_FIELD;
+			
+			findVariableNames(field.realName, field.type, excludeNames, null, kind);
 		}
 	}
 	
@@ -1826,11 +1830,11 @@ public final class CompletionEngine
 			int kind;
 			if (variable instanceof CompletionOnLocalName){
 				this.completionToken = ((CompletionOnLocalName) variable).realName;
-				kind = LOCAL;
+				kind = InternalNamingConventions.VK_LOCAL;
 			} else {
 				CompletionOnArgumentName arg = (CompletionOnArgumentName) variable;
 				this.completionToken = arg.realName;
-				kind = arg.isCatchArgument ? LOCAL : ARGUMENT;
+				kind = arg.isCatchArgument ? InternalNamingConventions.VK_LOCAL : InternalNamingConventions.VK_PARAMETER;
 			}
 
 			char[][] alreadyDefinedName = computeAlreadyDefinedName((BlockScope)scope, variable);
@@ -1848,7 +1852,7 @@ public final class CompletionEngine
 
 			System.arraycopy(discouragedNames, 0, discouragedNames = new char[localCount][], 0, localCount);
 
-			findVariableNames(this.completionToken, variable.type, discouragedNames, forbiddenNames, kind, variable.modifiers);
+			findVariableNames(this.completionToken, variable.type, discouragedNames, forbiddenNames, kind);
 		}
 	}
 	
@@ -2166,7 +2170,15 @@ public final class CompletionEngine
 
 			this.completionToken = method.selector;
 
-			findVariableNames(this.completionToken, method.returnType, excludeNames, null, FIELD, method.modifiers);
+			
+			int kind =
+				 (method.modifiers & ClassFileConstants.AccStatic) == 0 ? 
+						InternalNamingConventions.VK_INSTANCE_FIELD :
+							(method.modifiers & ClassFileConstants.AccFinal) == 0 ? 
+									InternalNamingConventions.VK_STATIC_FIELD :
+										InternalNamingConventions.VK_CONSTANT_FIELD;
+						
+			findVariableNames(this.completionToken, method.returnType, excludeNames, null, kind);
 		}
 	}
 	
@@ -9674,8 +9686,7 @@ public final class CompletionEngine
 			final char[][] forbiddenNames,
 			boolean forCollection,
 			int dim,
-			int kind,
-			int modifiers){
+			int kind){
 
 		if(sourceName == null || sourceName.length == 0)
 			return;
@@ -9755,39 +9766,16 @@ public final class CompletionEngine
 			}
 		};
 
-		switch (kind) {
-			case FIELD :
-				InternalNamingConventions.suggestFieldNames(
-					this.javaProject,
-					qualifiedPackageName,
-					qualifiedSourceName,
-					dim,
-					modifiers,
-					token,
-					discouragedNames,
-					namingRequestor);
-				break;
-			case LOCAL :
-				InternalNamingConventions.suggestLocalVariableNames(
-					this.javaProject,
-					qualifiedPackageName,
-					qualifiedSourceName,
-					dim,
-					token,
-					discouragedNames,
-					namingRequestor);
-				break;
-			case ARGUMENT :
-				InternalNamingConventions.suggestArgumentNames(
-					this.javaProject,
-					qualifiedPackageName,
-					qualifiedSourceName,
-					dim,
-					token,
-					discouragedNames,
-					namingRequestor);
-				break;
-		}
+		InternalNamingConventions.suggestVariableNames(
+				kind,
+				InternalNamingConventions.BK_SIMPLE_TYPE_NAME,
+				qualifiedSourceName,
+				this.javaProject,
+				dim,
+				token,
+				discouragedNames,
+				true,
+				namingRequestor);
 	}
 
 	// Helper method for private void findVariableNames(char[] name, TypeReference type )
@@ -9800,8 +9788,7 @@ public final class CompletionEngine
 			char[][] discouragedNames,
 			final char[][] forbiddenNames,
 			int dim,
-			int kind,
-			int modifiers){
+			int kind){
 		findVariableName(
 				token,
 				qualifiedPackageName,
@@ -9812,8 +9799,7 @@ public final class CompletionEngine
 				forbiddenNames,
 				false,
 				dim,
-				kind,
-				modifiers);
+				kind);
 	}
 	private void findVariableNameForCollection(
 			char[] token,
@@ -9823,8 +9809,7 @@ public final class CompletionEngine
 			final TypeBinding typeBinding,
 			char[][] discouragedNames,
 			final char[][] forbiddenNames,
-			int kind,
-			int modifiers){
+			int kind){
 
 		findVariableName(
 				token,
@@ -9836,10 +9821,9 @@ public final class CompletionEngine
 				forbiddenNames,
 				false,
 				1,
-				kind,
-				modifiers);
+				kind);
 	}
-	private void findVariableNames(char[] name, TypeReference type , char[][] discouragedNames, char[][] forbiddenNames, int kind, int modifiers){
+	private void findVariableNames(char[] name, TypeReference type , char[][] discouragedNames, char[][] forbiddenNames, int kind){
 		if(type != null &&
 			type.resolvedType != null) {
 			TypeBinding tb = type.resolvedType;
@@ -9855,8 +9839,7 @@ public final class CompletionEngine
 					discouragedNames,
 					forbiddenNames,
 					type.dimensions(),
-					kind,
-					modifiers);
+					kind);
 				
 				if (tb.isParameterizedType() &&
 						tb.findSuperTypeOriginatingFrom(TypeIds.T_JavaUtilCollection, false) != null) {
@@ -9872,8 +9855,7 @@ public final class CompletionEngine
 							tb,
 							discouragedNames,
 							forbiddenNames,
-							kind,
-							modifiers);
+							kind);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
index a564d03..97570cc 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
@@ -28,6 +28,8 @@ public class AssistOptions {
 		"org.eclipse.jdt.core.codeComplete.fieldPrefixes"; 	//$NON-NLS-1$
 	public static final String OPTION_StaticFieldPrefixes =
 		"org.eclipse.jdt.core.codeComplete.staticFieldPrefixes"; 	//$NON-NLS-1$
+	public static final String OPTION_StaticFinalFieldPrefixes =
+		"org.eclipse.jdt.core.codeComplete.staticFinalFieldPrefixes"; 	//$NON-NLS-1$
 	public static final String OPTION_LocalPrefixes =
 		"org.eclipse.jdt.core.codeComplete.localPrefixes"; 	//$NON-NLS-1$
 	public static final String OPTION_ArgumentPrefixes =
@@ -36,6 +38,8 @@ public class AssistOptions {
 		"org.eclipse.jdt.core.codeComplete.fieldSuffixes"; 	//$NON-NLS-1$
 	public static final String OPTION_StaticFieldSuffixes =
 		"org.eclipse.jdt.core.codeComplete.staticFieldSuffixes"; 	//$NON-NLS-1$
+	public static final String OPTION_StaticFinalFieldSuffixes =
+		"org.eclipse.jdt.core.codeComplete.staticFinalFieldSuffixes"; 	//$NON-NLS-1$
 	public static final String OPTION_LocalSuffixes =
 		"org.eclipse.jdt.core.codeComplete.localSuffixes"; 	//$NON-NLS-1$
 	public static final String OPTION_ArgumentSuffixes =
@@ -61,10 +65,12 @@ public class AssistOptions {
 	public boolean suggestStaticImport = true;
 	public char[][] fieldPrefixes = null;
 	public char[][] staticFieldPrefixes = null;
+	public char[][] staticFinalFieldPrefixes = null;
 	public char[][] localPrefixes = null;
 	public char[][] argumentPrefixes = null;
 	public char[][] fieldSuffixes = null;
 	public char[][] staticFieldSuffixes = null;
+	public char[][] staticFinalFieldSuffixes = null;
 	public char[][] localSuffixes = null;
 	public char[][] argumentSuffixes = null;
 
@@ -121,6 +127,16 @@ public class AssistOptions {
 				}
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_StaticFinalFieldPrefixes)) != null) {
+			if (optionValue instanceof String) {
+				String stringValue = (String) optionValue;
+				if (stringValue.length() > 0){
+					this.staticFinalFieldPrefixes = splitAndTrimOn(',', stringValue.toCharArray());
+				} else {
+					this.staticFinalFieldPrefixes = null;
+				}
+			}
+		}
 		if ((optionValue = optionsMap.get(OPTION_LocalPrefixes)) != null) {
 			if (optionValue instanceof String) {
 				String stringValue = (String) optionValue;
@@ -161,6 +177,16 @@ public class AssistOptions {
 				}
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_StaticFinalFieldSuffixes)) != null) {
+			if (optionValue instanceof String) {
+				String stringValue = (String) optionValue;
+				if (stringValue.length() > 0){
+					this.staticFinalFieldSuffixes = splitAndTrimOn(',', stringValue.toCharArray());
+				} else {
+					this.staticFinalFieldSuffixes = null;
+				}
+			}
+		}
 		if ((optionValue = optionsMap.get(OPTION_LocalSuffixes)) != null) {
 			if (optionValue instanceof String) {
 				String stringValue = (String) optionValue;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
index f49e20c..83770ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
@@ -3582,6 +3582,54 @@ final static public char[] toLowerCase(char[] chars) {
 }
 
 /**
+ * Answers the result of a char[] conversion to uppercase. Answers null if the given chars array is null.
+ * <br>
+ * NOTE: If no conversion was necessary, then answers back the argument one.
+ * <br>
+ * <br>
+ * For example:
+ * <ol>
+ * <li><pre>
+ *    chars = { 'A' , 'B' }
+ *    result => { 'A' , 'B' }
+ * </pre>
+ * </li>
+ * <li><pre>
+ *    array = { 'a', 'B' }
+ *    result => { 'A' , 'B' }
+ * </pre>
+ * </li>
+ * </ol>
+ *
+ * @param chars the chars to convert
+ * @return the result of a char[] conversion to uppercase
+ * 
+ * @since 3.5
+ */
+final static public char[] toUpperCase(char[] chars) {
+	if (chars == null)
+		return null;
+	int length = chars.length;
+	char[] upperChars = null;
+	for (int i = 0; i < length; i++) {
+		char c = chars[i];
+		char lc = ScannerHelper.toUpperCase(c);
+		if ((c != lc) || (upperChars != null)) {
+			if (upperChars == null) {
+				System.arraycopy(
+					chars,
+					0,
+					upperChars = new char[length],
+					0,
+					i);
+			}
+			upperChars[i] = lc;
+		}
+	}
+	return upperChars == null ? chars : upperChars;
+}
+
+/**
  * Answers a new array removing leading and trailing spaces (' '). Answers the given array if there is no
  * space characters to remove.
  * <br>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 1ee8032..f896747 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1812,6 +1812,19 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String CODEASSIST_STATIC_FIELD_PREFIXES = PLUGIN_ID + ".codeComplete.staticFieldPrefixes"; //$NON-NLS-1$
 	/**
+	 * Code assist option ID: Define the Prefixes for Static Final Field Name.
+	 * <p>When the prefixes is non empty, completion for static final field name will begin with
+	 *    one of the proposed prefixes.
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.codeComplete.staticFinalFieldPrefixes"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "&lt;prefix&gt;[,&lt;prefix&gt;]*" }</code> where <code>&lt;prefix&gt;</code> is a String without any wild-card</dd>
+	 * <dt>Default:</dt><dd><code>""</code></dd>
+	 * </dl>
+	 * @since 3.5
+	 * @category CodeAssistOptionID
+	 */
+	public static final String CODEASSIST_STATIC_FINAL_FIELD_PREFIXES = PLUGIN_ID + ".codeComplete.staticFinalFieldPrefixes"; //$NON-NLS-1$
+	/**
 	 * Code assist option ID: Define the Prefixes for Local Variable Name.
 	 * <p>When the prefixes is non empty, completion for local variable name will begin with
 	 *    one of the proposed prefixes.
@@ -1864,6 +1877,19 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String CODEASSIST_STATIC_FIELD_SUFFIXES = PLUGIN_ID + ".codeComplete.staticFieldSuffixes"; //$NON-NLS-1$
 	/**
+	 * Code assist option ID: Define the Suffixes for Static Final Field Name.
+	 * <p>When the suffixes is non empty, completion for static final field name will end with
+	 *    one of the proposed suffixes.
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.codeComplete.staticFinalFieldSuffixes"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "&lt;suffix&gt;[,&lt;suffix&gt;]*" }</code>< where <code>&lt;suffix&gt;</code> is a String without any wild-card</dd>
+	 * <dt>Default:</dt><dd><code>""</code></dd>
+	 * </dl>
+	 * @since 3.5
+	 * @category CodeAssistOptionID
+	 */
+	public static final String CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES = PLUGIN_ID + ".codeComplete.staticFinalFieldSuffixes"; //$NON-NLS-1$
+	/**
 	 * Code assist option ID: Define the Suffixes for Local Variable Name.
 	 * <p>When the suffixes is non empty, completion for local variable name will end with
 	 *    one of the proposed suffixes.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
index 93123ae..c01445f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
@@ -48,10 +48,6 @@ import org.eclipse.jdt.internal.core.InternalNamingConventions;
  * @noinstantiate This class is not intended to be instantiated by clients.
  */
 public final class NamingConventions {
-	private static final char[] GETTER_BOOL_NAME = "is".toCharArray(); //$NON-NLS-1$
-	private static final char[] GETTER_NAME = "get".toCharArray(); //$NON-NLS-1$
-	private static final char[] SETTER_NAME = "set".toCharArray(); //$NON-NLS-1$
-
 	static class NamingRequestor implements INamingRequestor {
 		private final static int SIZE = 10;
 
@@ -80,6 +76,45 @@ public final class NamingConventions {
 		// for acceptNameWithoutPrefixAndSuffix
 		private char[][] otherResults = new char[SIZE][];
 		private int otherResultsCount = 0;
+		public void acceptNameWithoutPrefixAndSuffix(char[] name, int reusedCharacters) {
+			int length = this.otherResults.length;
+			if(length == this.otherResultsCount) {
+				System.arraycopy(
+					this.otherResults,
+					0,
+					this.otherResults = new char[length * 2][],
+					0,
+					length);
+			}
+			this.otherResults[this.otherResultsCount++] = name;
+		}
+
+		public void acceptNameWithPrefix(char[] name, boolean isFirstPrefix, int reusedCharacters) {
+			if(isFirstPrefix) {
+				int length = this.firstPrefixResults.length;
+				if(length == this.firstPrefixResultsCount) {
+					System.arraycopy(
+						this.firstPrefixResults,
+						0,
+						this.firstPrefixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				this.firstPrefixResults[this.firstPrefixResultsCount++] = name;
+			} else{
+				int length = this.prefixResults.length;
+				if(length == this.prefixResultsCount) {
+					System.arraycopy(
+						this.prefixResults,
+						0,
+						this.prefixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				this.prefixResults[this.prefixResultsCount++] = name;
+			}
+		}
+
 		public void acceptNameWithPrefixAndSuffix(char[] name, boolean isFirstPrefix, boolean isFirstSuffix, int reusedCharacters) {
 			if(isFirstPrefix && isFirstSuffix) {
 				int length = this.firstPrefixAndFirstSuffixResults.length;
@@ -128,32 +163,6 @@ public final class NamingConventions {
 			}
 		}
 
-		public void acceptNameWithPrefix(char[] name, boolean isFirstPrefix, int reusedCharacters) {
-			if(isFirstPrefix) {
-				int length = this.firstPrefixResults.length;
-				if(length == this.firstPrefixResultsCount) {
-					System.arraycopy(
-						this.firstPrefixResults,
-						0,
-						this.firstPrefixResults = new char[length * 2][],
-						0,
-						length);
-				}
-				this.firstPrefixResults[this.firstPrefixResultsCount++] = name;
-			} else{
-				int length = this.prefixResults.length;
-				if(length == this.prefixResultsCount) {
-					System.arraycopy(
-						this.prefixResults,
-						0,
-						this.prefixResults = new char[length * 2][],
-						0,
-						length);
-				}
-				this.prefixResults[this.prefixResultsCount++] = name;
-			}
-		}
-
 		public void acceptNameWithSuffix(char[] name, boolean isFirstSuffix, int reusedCharacters) {
 			if(isFirstSuffix) {
 				int length = this.firstSuffixResults.length;
@@ -179,19 +188,6 @@ public final class NamingConventions {
 				this.suffixResults[this.suffixResultsCount++] = name;
 			}
 		}
-
-		public void acceptNameWithoutPrefixAndSuffix(char[] name, int reusedCharacters) {
-			int length = this.otherResults.length;
-			if(length == this.otherResultsCount) {
-				System.arraycopy(
-					this.otherResults,
-					0,
-					this.otherResults = new char[length * 2][],
-					0,
-					length);
-			}
-			this.otherResults[this.otherResultsCount++] = name;
-		}
 		public char[][] getResults(){
 			int count =
 				this.firstPrefixAndFirstSuffixResultsCount
@@ -228,10 +224,82 @@ public final class NamingConventions {
 			return results;
 		}
 	}
+	private static final char[] GETTER_BOOL_NAME = "is".toCharArray(); //$NON-NLS-1$
+	private static final char[] GETTER_NAME = "get".toCharArray(); //$NON-NLS-1$
+
+	private static final char[] SETTER_NAME = "set".toCharArray(); //$NON-NLS-1$
 
 
-	private NamingConventions() {
-		// Not instantiable
+	/**
+	 * Variable kind which represents a static field.
+	 * 
+	 * @since 3.5
+	 */
+	public static final int VK_STATIC_FIELD = InternalNamingConventions.VK_STATIC_FIELD;
+	/**
+	 * Variable kind which represents an instance field.
+	 * 
+	 * @since 3.5
+	 */
+	public static final int VK_INSTANCE_FIELD = InternalNamingConventions.VK_INSTANCE_FIELD;
+	/**
+	 * Variable kind which represents a constant field (static final).
+	 * 
+	 * @since 3.5
+	 */
+	public static final int VK_CONSTANT_FIELD = InternalNamingConventions.VK_CONSTANT_FIELD;
+	/**
+	 * Variable kind which represents an argument.
+	 * 
+	 * @since 3.5
+	 */
+	public static final int VK_PARAMETER = InternalNamingConventions.VK_PARAMETER;
+	/**
+	 * Variable kind which represents a local variable.
+	 * 
+	 * @since 3.5
+	 */
+	public static final int VK_LOCAL = InternalNamingConventions.VK_LOCAL;
+	
+	/**
+	 * The base name associated to this base name kind is a simple name.
+	 * When this base name is used the whole name is considered.
+	 * 
+	 * @see #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)
+	 * 
+	 * @since 3.5
+	 */
+	public static final int BK_NAME = InternalNamingConventions.BK_SIMPLE_NAME;
+	
+	/**
+	 * The base name associated to this base name kind is a simple type name.
+	 * When this base name is used to all the words of the name are considered.
+	 * 
+	 * @see #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)
+	 * 
+	 * @since 3.5
+	 */
+	public static final int BK_TYPE_NAME = InternalNamingConventions.BK_SIMPLE_TYPE_NAME;
+
+	private static String[] convertCharsToString(char[][] c) {
+		int length = c == null ? 0 : c.length;
+		String[] s = new String[length];
+		for (int i = 0; i < length; i++) {
+			s[i] = String.valueOf(c[i]);
+		}
+		return s;
+	}
+	private static char[][] convertStringToChars(String[] s) {
+		int length = s == null ? 0 : s.length;
+		char[][] c = new char[length][];
+		for (int i = 0; i < length; i++) {
+			if(s[i] == null) {
+				c[i] = CharOperation.NO_CHAR;
+			} else {
+				c[i] = s[i].toCharArray();
+			}
+		}
+		return c;
 	}
 
 	private static char[] removePrefixAndSuffix(char[] name, char[][] prefixes, char[][] suffixes) {
@@ -296,6 +364,8 @@ public final class NamingConventions {
 	 * @return char[] the name without prefix and suffix.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead with {@link #VK_PARAMETER} as variable kind.
 	 */
 	public static char[] removePrefixAndSuffixForArgumentName(IJavaProject javaProject, char[] argumentName) {
 		AssistOptions assistOptions = new AssistOptions(javaProject.getOptions(true));
@@ -327,11 +397,12 @@ public final class NamingConventions {
 	 * @return char[] the name without prefix and suffix.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead with {@link #VK_PARAMETER} as variable kind.
 	 */
 	public static String removePrefixAndSuffixForArgumentName(IJavaProject javaProject, String argumentName) {
 		return String.valueOf(removePrefixAndSuffixForArgumentName(javaProject, argumentName.toCharArray()));
 	}
-
 	/**
 	 * Remove prefix and suffix from a field name.
 	 * <p>
@@ -358,6 +429,9 @@ public final class NamingConventions {
 	 * @see Flags
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead
+	 * with {@link #VK_INSTANCE_FIELD} or {@link #VK_STATIC_FIELD} as variable kind.
 	 */
 	public static char[] removePrefixAndSuffixForFieldName(IJavaProject javaProject, char[] fieldName, int modifiers) {
 		boolean isStatic = Flags.isStatic(modifiers);
@@ -394,10 +468,14 @@ public final class NamingConventions {
 	 * @see Flags
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead
+	 * with {@link #VK_INSTANCE_FIELD} or {@link #VK_STATIC_FIELD} as variable kind.
 	 */
 	public static String removePrefixAndSuffixForFieldName(IJavaProject javaProject, String fieldName, int modifiers) {
 		return String.valueOf(removePrefixAndSuffixForFieldName(javaProject, fieldName.toCharArray(), modifiers));
 	}
+
 	/**
 	 * Remove prefix and suffix from a local variable name.
 	 * <p>
@@ -420,6 +498,8 @@ public final class NamingConventions {
 	 * @return char[] the name without prefix and suffix.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead with {@link #VK_LOCAL} as variable kind.
 	 */
 	public static char[] removePrefixAndSuffixForLocalVariableName(IJavaProject javaProject, char[] localName) {
 		AssistOptions assistOptions = new AssistOptions(javaProject.getOptions(true));
@@ -451,10 +531,43 @@ public final class NamingConventions {
 	 * @return char[] the name without prefix and suffix.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #getBaseName(int, String, IJavaProject)} instead with {@link #VK_LOCAL} as variable kind.
 	 */
 	public static String removePrefixAndSuffixForLocalVariableName(IJavaProject javaProject, String localName) {
 		return String.valueOf(removePrefixAndSuffixForLocalVariableName(javaProject, localName.toCharArray()));
 	}
+	
+	/**
+	 * Returns a base name which could be used to generate this variable name with {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)}.
+	 * <p>
+	 * e.g.<br>
+	 * If the variable is a {@link #VK_LOCAL} and the variable name is <code>variableName</code> then the base name will be <code>VariableName</code>.<br>
+	 * If the variable is a {@link #VK_CONSTANT_FIELD} and the variable name is <code>VARIABLE_NAME</code> then the base name will be <code>VariableName</code>.<br>
+	 * </p>
+	 * 
+	 * @param variableKind specifies what type the variable is: {@link #VK_LOCAL}, {@link #VK_PARAMETER}, {@link #VK_STATIC_FIELD},
+	 * {@link #VK_INSTANCE_FIELD} or {@link #VK_CONSTANT_FIELD}.
+	 * @param variableName a variable name
+	 * @param javaProject project which contains the variable or <code>null</code> to take into account only workspace settings.
+	 * 
+	 * @see #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)
+	 * @since 3.5
+	 */
+	public static String getBaseName(
+			int variableKind,
+			String variableName,
+			IJavaProject javaProject) {
+		return String.valueOf(InternalNamingConventions.getBaseName(variableKind, javaProject, variableName.toCharArray()));
+	}
+
+	private static char[] suggestAccessorName(IJavaProject project, char[] fieldName, int modifiers) {
+		char[] name = removePrefixAndSuffixForFieldName(project, fieldName, modifiers);
+		if (name.length > 0 && ScannerHelper.isLowerCase(name[0])) {
+			name[0] = ScannerHelper.toUpperCase(name[0]);
+		}
+		return name;
+	}
 
 	/**
 	 * Suggest names for an argument. The name is computed from argument's type
@@ -483,6 +596,8 @@ public final class NamingConventions {
 	 * @return char[][] an array of names.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead with {@link #VK_PARAMETER} as variable kind.
 	 */
 	public static char[][] suggestArgumentNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames) {
 		NamingRequestor requestor = new NamingRequestor();
@@ -525,6 +640,8 @@ public final class NamingConventions {
 	 * @return char[][] an array of names.
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead with {@link #VK_PARAMETER} as variable kind.
 	 */
 	public static String[] suggestArgumentNames(IJavaProject javaProject, String packageName, String qualifiedTypeName, int dim, String[] excludedNames) {
 		return convertCharsToString(
@@ -535,6 +652,7 @@ public final class NamingConventions {
 				dim,
 				convertStringToChars(excludedNames)));
 	}
+
 	/**
 	 * Suggest names for a field. The name is computed from field's type
 	 * and possible prefixes or suffixes are added.
@@ -566,6 +684,9 @@ public final class NamingConventions {
 	 * @see Flags
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead 
+	 * with {@link #VK_INSTANCE_FIELD} or  {@link #VK_STATIC_FIELD} as variable kind.
 	 */
 	public static char[][] suggestFieldNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, int modifiers, char[][] excludedNames) {
 		NamingRequestor requestor = new NamingRequestor();
@@ -613,6 +734,9 @@ public final class NamingConventions {
 	 * @see Flags
 	 * @see JavaCore#setOptions(java.util.Hashtable)
 	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead 
+	 * with {@link #VK_INSTANCE_FIELD} or  {@link #VK_STATIC_FIELD} as variable kind.
 	 */
 	public static String[] suggestFieldNames(IJavaProject javaProject, String packageName, String qualifiedTypeName, int dim, int modifiers, String[] excludedNames) {
 		return convertCharsToString(
@@ -624,87 +748,7 @@ public final class NamingConventions {
 				modifiers,
 				convertStringToChars(excludedNames)));
 	}
-
-	/**
-	 * Suggest names for a local variable. The name is computed from variable's type
-	 * and possible prefixes or suffixes are added.
-	 * <p>
-	 * If the type of the local variable is <code>TypeName</code>, the prefix for local variable is <code>pre</code>
-	 * and the suffix for local variable is <code>suf</code> then the proposed names are <code>preTypeNamesuf</code>
-	 * and <code>preNamesuf</code>. If there is no prefix or suffix the proposals are <code>typeName</code>
-	 * and <code>name</code>.
-	 * </p>
-	 * <p>
-	 * This method is affected by the following JavaCore options :  {@link JavaCore#CODEASSIST_LOCAL_PREFIXES} and
-	 *  {@link JavaCore#CODEASSIST_LOCAL_SUFFIXES}.
-	 * </p>
-	 * <p>
-	 * For a complete description of these configurable options, see <code>getDefaultOptions</code>.
-	 * For programmaticaly change these options, see <code>JavaCore#setOptions()</code>.
-	 * </p>
-	 *
-	 * @param javaProject project which contains the variable.
-	 * @param packageName package of the variable's type.
-	 * @param qualifiedTypeName variable's type.
-	 * @param dim variable's dimension (0 if the variable is not an array).
-	 * @param excludedNames a list of names which cannot be suggested (already used names).
-	 *         Can be <code>null</code> if there is no excluded names.
-	 * @return char[][] an array of names.
-	 * @see JavaCore#setOptions(java.util.Hashtable)
-	 * @see JavaCore#getDefaultOptions()
-	 */
-	public static char[][] suggestLocalVariableNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames) {
-		NamingRequestor requestor = new NamingRequestor();
-		InternalNamingConventions.suggestLocalVariableNames(
-			javaProject,
-			packageName,
-			qualifiedTypeName,
-			dim,
-			null,
-			excludedNames,
-			requestor);
-
-		return requestor.getResults();
-	}
-
-	/**
-	 * Suggest names for a local variable. The name is computed from variable's type
-	 * and possible prefixes or suffixes are added.
-	 * <p>
-	 * If the type of the local variable is <code>TypeName</code>, the prefix for local variable is <code>pre</code>
-	 * and the suffix for local variable is <code>suf</code> then the proposed names are <code>preTypeNamesuf</code>
-	 * and <code>preNamesuf</code>. If there is no prefix or suffix the proposals are <code>typeName</code>
-	 * and <code>name</code>.
-	 * </p>
-	 * <p>
-	 * This method is affected by the following JavaCore options :  {@link JavaCore#CODEASSIST_LOCAL_PREFIXES} and
-	 *  {@link JavaCore#CODEASSIST_LOCAL_SUFFIXES}.
-	 * </p>
-	 * <p>
-	 * For a complete description of these configurable options, see <code>getDefaultOptions</code>.
-	 * For programmaticaly change these options, see <code>JavaCore#setOptions()</code>.
-	 * </p>
-	 *
-	 * @param javaProject project which contains the variable.
-	 * @param packageName package of the variable's type.
-	 * @param qualifiedTypeName variable's type.
-	 * @param dim variable's dimension (0 if the variable is not an array).
-	 * @param excludedNames a list of names which cannot be suggested (already used names).
-	 *         Can be <code>null</code> if there is no excluded names.
-	 * @return char[][] an array of names.
-	 * @see JavaCore#setOptions(java.util.Hashtable)
-	 * @see JavaCore#getDefaultOptions()
-	 */
-	public static String[] suggestLocalVariableNames(IJavaProject javaProject, String packageName, String qualifiedTypeName, int dim, String[] excludedNames) {
-		return convertCharsToString(
-			suggestLocalVariableNames(
-				javaProject,
-				packageName.toCharArray(),
-				qualifiedTypeName.toCharArray(),
-				dim,
-				convertStringToChars(excludedNames)));
-	}
-
+	
 	/**
 	 * Suggest name for a getter method. The name is computed from field's name
 	 * and possible prefixes or suffixes are removed.
@@ -756,7 +800,6 @@ public final class NamingConventions {
 			);
 		}
 	}
-
 	/**
 	 * Suggest name for a getter method. The name is computed from field's name
 	 * and possible prefixes or suffixes are removed.
@@ -797,7 +840,107 @@ public final class NamingConventions {
 				isBoolean,
 				convertStringToChars(excludedNames)));
 	}
+	/**
+	 * Suggest names for a local variable. The name is computed from variable's type
+	 * and possible prefixes or suffixes are added.
+	 * <p>
+	 * If the type of the local variable is <code>TypeName</code>, the prefix for local variable is <code>pre</code>
+	 * and the suffix for local variable is <code>suf</code> then the proposed names are <code>preTypeNamesuf</code>
+	 * and <code>preNamesuf</code>. If there is no prefix or suffix the proposals are <code>typeName</code>
+	 * and <code>name</code>.
+	 * </p>
+	 * <p>
+	 * This method is affected by the following JavaCore options :  {@link JavaCore#CODEASSIST_LOCAL_PREFIXES} and
+	 *  {@link JavaCore#CODEASSIST_LOCAL_SUFFIXES}.
+	 * </p>
+	 * <p>
+	 * For a complete description of these configurable options, see <code>getDefaultOptions</code>.
+	 * For programmaticaly change these options, see <code>JavaCore#setOptions()</code>.
+	 * </p>
+	 *
+	 * @param javaProject project which contains the variable.
+	 * @param packageName package of the variable's type.
+	 * @param qualifiedTypeName variable's type.
+	 * @param dim variable's dimension (0 if the variable is not an array).
+	 * @param excludedNames a list of names which cannot be suggested (already used names).
+	 *         Can be <code>null</code> if there is no excluded names.
+	 * @return char[][] an array of names.
+	 * @see JavaCore#setOptions(java.util.Hashtable)
+	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead with {@link #VK_LOCAL} as variable kind.
+	 */
+	public static char[][] suggestLocalVariableNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames) {
+		NamingRequestor requestor = new NamingRequestor();
+		InternalNamingConventions.suggestLocalVariableNames(
+			javaProject,
+			packageName,
+			qualifiedTypeName,
+			dim,
+			null,
+			excludedNames,
+			requestor);
 
+		return requestor.getResults();
+	}
+	/**
+	 * Suggest names for a local variable. The name is computed from variable's type
+	 * and possible prefixes or suffixes are added.
+	 * <p>
+	 * If the type of the local variable is <code>TypeName</code>, the prefix for local variable is <code>pre</code>
+	 * and the suffix for local variable is <code>suf</code> then the proposed names are <code>preTypeNamesuf</code>
+	 * and <code>preNamesuf</code>. If there is no prefix or suffix the proposals are <code>typeName</code>
+	 * and <code>name</code>.
+	 * </p>
+	 * <p>
+	 * This method is affected by the following JavaCore options :  {@link JavaCore#CODEASSIST_LOCAL_PREFIXES} and
+	 *  {@link JavaCore#CODEASSIST_LOCAL_SUFFIXES}.
+	 * </p>
+	 * <p>
+	 * For a complete description of these configurable options, see <code>getDefaultOptions</code>.
+	 * For programmaticaly change these options, see <code>JavaCore#setOptions()</code>.
+	 * </p>
+	 *
+	 * @param javaProject project which contains the variable.
+	 * @param packageName package of the variable's type.
+	 * @param qualifiedTypeName variable's type.
+	 * @param dim variable's dimension (0 if the variable is not an array).
+	 * @param excludedNames a list of names which cannot be suggested (already used names).
+	 *         Can be <code>null</code> if there is no excluded names.
+	 * @return char[][] an array of names.
+	 * @see JavaCore#setOptions(java.util.Hashtable)
+	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @deprecated Use {@link #suggestVariableNames(int, int, String, IJavaProject, int, String[], boolean)} instead with {@link #VK_LOCAL} as variable kind.
+	 */
+	public static String[] suggestLocalVariableNames(IJavaProject javaProject, String packageName, String qualifiedTypeName, int dim, String[] excludedNames) {
+		return convertCharsToString(
+			suggestLocalVariableNames(
+				javaProject,
+				packageName.toCharArray(),
+				qualifiedTypeName.toCharArray(),
+				dim,
+				convertStringToChars(excludedNames)));
+	}
+	private static char[] suggestNewName(char[] name, char[][] excludedNames){
+		if(excludedNames == null) {
+			return name;
+		}
+
+		char[] newName = name;
+		int count = 2;
+		int i = 0;
+		while (i < excludedNames.length) {
+			if(CharOperation.equals(newName, excludedNames[i], false)) {
+				newName = CharOperation.concat(name, String.valueOf(count++).toCharArray());
+				i = 0;
+			} else {
+				i++;
+			}
+		}
+		return newName;
+	}
+	
 	/**
 	 * Suggest name for a setter method. The name is computed from field's name
 	 * and possible prefixes or suffixes are removed.
@@ -853,7 +996,6 @@ public final class NamingConventions {
 			);
 		}
 	}
-
 	/**
 	 * Suggest name for a setter method. The name is computed from field's name
 	 * and possible prefixes or suffixes are removed.
@@ -893,53 +1035,108 @@ public final class NamingConventions {
 				isBoolean,
 				convertStringToChars(excludedNames)));
 	}
+	
+	/**
+	 * Suggests names for a variable. The name is computed from a base name and possible prefixes or suffixes are added.
+	 *
+	 * <p>
+	 * The base name is used to compute the variable name.
+	 * Some different kinds of base name are possible and each kind is associated to a different heuristic to compute variable names.<br>
+	 * The heuristic depends also of the kind of the variable. Each kind of variable is identified by a constant starting with <code>VK_</code>.<br>
+	 * When a prefix and a suffix can be added then all combinations of prefix and suffix are suggested.
+	 * If the name is <code>name</code>, the prefix is <code>pre</code> and the suffix is <code>suf</code> then the suggested names will be
+	 * <code>prenamesuf</code>, <code>prename</code>, <code>namesuf</code> and <code>name</code>.<br>
+	 * <br>
+	 * The different kinds of base name are:
+	 * <ul>
+	 * <li>{@link #BK_NAME}: the base name is a Java name and the whole base name is considered to compute the variable names. A prefix and a suffix can be added.<br>
+	 * There is an heuristic by variable kind.
+	 * <ul>
+	 * <li>{@link #VK_PARAMETER}, {@link #VK_LOCAL}, {@link #VK_INSTANCE_FIELD} and {@link #VK_STATIC_FIELD}:<br>
+	 * In this case the first character will be converted to lower case and the other characters won't be changed.<br>
+	 * If the base name is <code>SimpleName</code> then the suggested name will be <code>simpleName</code>.<br></li>
+	 * <li>{@link #VK_CONSTANT_FIELD} :<br>
+	 * In this case all letters of the name will be converted to upper case and words will be separated by an underscore (<code>"_"</code>).<br>
+	 * If the base name is <code>SimpleName</code> then the suggested name will be <code>SIMPLE_NAME</code>.</li>
+	 * </ul></li>
+	 * <li>{@link #BK_TYPE_NAME}: the base name is a Java simple type name (e.g. <code>HashMap</code>) and all the words of the base name are considered to compute the variable names. A prefix and a suffix can be added to these names.<br>
+	 * There is an heuristic by variable kind.
+	 * <ul>
+	 * <li>{@link #VK_PARAMETER}, {@link #VK_LOCAL}, {@link #VK_INSTANCE_FIELD} and {@link #VK_STATIC_FIELD}:<br>
+	 * In this case a variable name will contain some words of the base name and the first character will be converted to lower case.<br>
+	 * If the type is <code>TypeName</code> then the suggested names will be <code>typeName</code> and <code>name</code>.</li>
+	 * <li>{@link #VK_CONSTANT_FIELD} :<br>
+	 * In this case a variable name will contain some words of the base name, all letters of the name will be converted to upper case and segments will be separated by a underscore (<code>"_"</code>).<br>
+	 * If the base name is <code>TypeName</code> then the suggested name will be <code>TYPE_NAME</code> and <code>NAME</code>.</li>
+	 * </ul></li>
+	 * </ul>
+	 * Some other kinds could be added in the future.
+	 * </p>
+	 * <p>
+	 * Each variable kind is affected by the following JavaCore options:
+	 * <ul>
+	 * <li>{@link #VK_PARAMETER}: {@link JavaCore#CODEASSIST_ARGUMENT_PREFIXES} and {@link JavaCore#CODEASSIST_ARGUMENT_SUFFIXES}</li>
+	 * <li>{@link #VK_LOCAL}: {@link JavaCore#CODEASSIST_LOCAL_PREFIXES} and {@link JavaCore#CODEASSIST_LOCAL_SUFFIXES}</li>
+	 * <li>{@link #VK_INSTANCE_FIELD}: {@link JavaCore#CODEASSIST_FIELD_PREFIXES} and {@link JavaCore#CODEASSIST_FIELD_SUFFIXES}</li>
+	 * <li>{@link #VK_STATIC_FIELD}: {@link JavaCore#CODEASSIST_STATIC_FIELD_PREFIXES} and {@link JavaCore#CODEASSIST_STATIC_FIELD_SUFFIXES}</li>
+	 * <li>{@link #VK_CONSTANT_FIELD}: {@link JavaCore#CODEASSIST_STATIC_FINAL_FIELD_PREFIXES} and {@link JavaCore#CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES}</li>
+	 * </ul>
+	 * </p>
+	 * <p>
+	 * For a complete description of these configurable options, see <code>getDefaultOptions</code>.
+	 * For programmaticaly change these options, see <code>JavaCore#setOptions()</code>.
+	 * </p>
+	 * <p>
+	 * Proposed names are sorted by relevance (best proposal first).<br>
+	 * The names are proposed in the following order:
+	 * <ol>
+	 * <li>Names with prefix and suffix. Longest name are proposed first</li>
+	 * <li>Names with prefix. Longest name are proposed first</li>
+	 * <li>Names with suffix. Longest name are proposed first</li>
+	 * <li>Names without prefix and suffix. Longest name are proposed first</li>
+	 * </ol>
+	 * </p>
+	 *
+	 * @param variableKind specifies what type the variable is: {@link #VK_LOCAL}, {@link #VK_PARAMETER}, {@link #VK_STATIC_FIELD},
+	 * {@link #VK_INSTANCE_FIELD} or {@link #VK_CONSTANT_FIELD}.
+	 * @param baseNameKind specifies what type the base name is: {@link #BK_NAME} or {@link #BK_TYPE_NAME}
+	 * @param baseName name used to compute the suggested names.
+	 * @param javaProject project which contains the variable or <code>null</code> to take into account only workspace settings.
+	 * @param dim variable dimension (0 if the field is not an array).
+	 * @param excluded a list of names which cannot be suggested (already used names).
+	 *         Can be <code>null</code> if there is no excluded names.
+	 * @param evaluateDefault if set, the result is guaranteed to contain at least one result. If not, the result can be an empty array. 
+	 * @return String[] an array of names.
+	 * @see JavaCore#setOptions(java.util.Hashtable)
+	 * @see JavaCore#getDefaultOptions()
+	 * 
+	 * @since 3.5
+	 */
+	public static String[] suggestVariableNames(
+			int variableKind,
+			int baseNameKind,
+			String baseName,
+			IJavaProject javaProject,
+			int dim,
+			String[] excluded,
+			boolean evaluateDefault) {
+		
+		NamingRequestor requestor = new NamingRequestor();
+		InternalNamingConventions.suggestVariableNames(
+			variableKind,
+			baseNameKind,
+			baseName.toCharArray(),
+			javaProject,
+			dim,
+			null,
+			convertStringToChars(excluded),
+			evaluateDefault,
+			requestor);
 
-	private static char[] suggestAccessorName(IJavaProject project, char[] fieldName, int modifiers) {
-		char[] name = removePrefixAndSuffixForFieldName(project, fieldName, modifiers);
-		if (name.length > 0 && ScannerHelper.isLowerCase(name[0])) {
-			name[0] = ScannerHelper.toUpperCase(name[0]);
-		}
-		return name;
-	}
-
-	private static char[] suggestNewName(char[] name, char[][] excludedNames){
-		if(excludedNames == null) {
-			return name;
-		}
-
-		char[] newName = name;
-		int count = 2;
-		int i = 0;
-		while (i < excludedNames.length) {
-			if(CharOperation.equals(newName, excludedNames[i], false)) {
-				newName = CharOperation.concat(name, String.valueOf(count++).toCharArray());
-				i = 0;
-			} else {
-				i++;
-			}
-		}
-		return newName;
-	}
-
-	private static String[] convertCharsToString(char[][] c) {
-		int length = c == null ? 0 : c.length;
-		String[] s = new String[length];
-		for (int i = 0; i < length; i++) {
-			s[i] = String.valueOf(c[i]);
-		}
-		return s;
+		return convertCharsToString(requestor.getResults());
 	}
-
-	private static char[][] convertStringToChars(String[] s) {
-		int length = s == null ? 0 : s.length;
-		char[][] c = new char[length][];
-		for (int i = 0; i < length; i++) {
-			if(s[i] == null) {
-				c[i] = CharOperation.NO_CHAR;
-			} else {
-				c[i] = s[i].toCharArray();
-			}
-		}
-		return c;
+	
+	private NamingConventions() {
+		// Not instantiable
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
index 053b8f5..5fbf45f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
@@ -14,6 +14,7 @@ import java.util.Map;
 
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.codeassist.impl.AssistOptions;
@@ -53,6 +54,7 @@ public class InternalNamingConventions {
 			getNameScanner(compilerOptions),
 			requestor);
 	}
+	
 	public static void suggestFieldNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, int modifiers, char[] internalPrefix, char[][] excludedNames, INamingRequestor requestor) {
 		boolean isStatic = Flags.isStatic(modifiers);
 
@@ -258,6 +260,7 @@ public class InternalNamingConventions {
 			requestor.acceptNameWithoutPrefixAndSuffix(name, 0);
 		}
 	}
+	
 
 	private static void acceptName(
 		char[] name,
@@ -278,6 +281,15 @@ public class InternalNamingConventions {
 		}
 	}
 
+	private static char[][] computeBaseTypeNames(char[] typeName, boolean isConstantField, char[][] excludedNames){
+		char[] name = computeBaseTypeNames(typeName[0], excludedNames);
+		if(name != null) {
+			return new char[][]{name};
+		} else {
+			// compute variable name like from non base type
+			return  computeNonBaseTypeNames(typeName, isConstantField);
+		}
+	}
 	private static char[] computeBaseTypeNames(char firstName, char[][] excludedNames){
 		char[] name = new char[]{firstName};
 
@@ -322,6 +334,112 @@ public class InternalNamingConventions {
 		System.arraycopy(names, 0, names = new char[nameCount][], 0, nameCount);
 		return names;
 	}
+	
+	
+	private static char[][] computeNonBaseTypeNames(char[] sourceName, boolean isConstantField){
+		int length = sourceName.length;
+		
+		if (length == 0) {
+			return CharOperation.NO_CHAR_CHAR;
+		}
+		
+		if (length == 1) {
+			return new char[][]{CharOperation.toLowerCase(sourceName)};
+		}
+		
+		char[][] nameParts = new char[length][];
+		int namePartsPtr = -1;
+		
+		int endIndex = length;
+		char c = sourceName[length - 1];
+		
+		final int IS_LOWER_CASE = 1;
+		final int IS_UPPER_CASE = 2;
+		final int IS_UNDERSCORE = 3;
+		final int IS_OTHER = 4;
+		
+		int previousCharKind =
+			ScannerHelper.isLowerCase(c) ? IS_LOWER_CASE :
+				ScannerHelper.isUpperCase(c) ? IS_UPPER_CASE :
+					c == '_' ? IS_UNDERSCORE : IS_OTHER;
+		
+		for(int i = length - 1 ; i >= 0 ; i--){
+			c = sourceName[i];
+			
+			int charKind =
+				ScannerHelper.isLowerCase(c) ? IS_LOWER_CASE :
+					ScannerHelper.isUpperCase(c) ? IS_UPPER_CASE :
+						c == '_' ? IS_UNDERSCORE : IS_OTHER;
+			
+			switch (charKind) {
+				case IS_LOWER_CASE:
+					if (previousCharKind == IS_UPPER_CASE) {
+						nameParts[++namePartsPtr] = CharOperation.subarray(sourceName, i + 1, endIndex);
+						endIndex = i + 1;
+					}
+					previousCharKind = IS_LOWER_CASE;
+					break;
+				case IS_UPPER_CASE:
+					if (previousCharKind == IS_LOWER_CASE) {
+						nameParts[++namePartsPtr] = CharOperation.subarray(sourceName, i, endIndex);
+						if (i > 0) {
+							char pc = sourceName[i - 1];
+							previousCharKind =
+								ScannerHelper.isLowerCase(pc) ? IS_LOWER_CASE :
+									ScannerHelper.isUpperCase(pc) ? IS_UPPER_CASE :
+										pc == '_' ? IS_UNDERSCORE : IS_OTHER;
+						}
+						endIndex = i;
+					} else {
+						previousCharKind = IS_UPPER_CASE;
+					}
+					break;
+				case IS_UNDERSCORE:
+					switch (previousCharKind) {
+						case IS_UNDERSCORE:
+							if (i > 0) {
+								char pc = sourceName[i - 1];
+								previousCharKind =
+									ScannerHelper.isLowerCase(pc) ? IS_LOWER_CASE :
+										ScannerHelper.isUpperCase(pc) ? IS_UPPER_CASE :
+											pc == '_' ? IS_UNDERSCORE : IS_OTHER;
+							}
+							endIndex = i;
+							break;
+						case IS_LOWER_CASE:
+						case IS_UPPER_CASE:
+							nameParts[++namePartsPtr] = CharOperation.subarray(sourceName, i + 1, endIndex);
+							if (i > 0) {
+								char pc = sourceName[i - 1];
+								previousCharKind =
+									ScannerHelper.isLowerCase(pc) ? IS_LOWER_CASE :
+										ScannerHelper.isUpperCase(pc) ? IS_UPPER_CASE :
+											pc == '_' ? IS_UNDERSCORE : IS_OTHER;
+							}
+							endIndex = i;
+							break;
+						default:
+							previousCharKind = IS_UNDERSCORE;
+							break;
+					}
+					break;
+				default:
+					previousCharKind = IS_OTHER;
+					break;
+			}
+		}
+		if (endIndex > 0) {
+			nameParts[++namePartsPtr] = CharOperation.subarray(sourceName, 0, endIndex);
+		}
+		
+		if (isConstantField) {
+			return generateConstantName(nameParts, namePartsPtr);
+		} else {
+			return generateNonConstantName(nameParts, namePartsPtr);
+		}
+	}
+	
+	
 
 	private static char[] excludeNames(
 		char[] suffixName,
@@ -344,6 +462,204 @@ public class InternalNamingConventions {
 		}
 		return suffixName;
 	}
+	
+	private static char[][] generateNonConstantName(char[][] nameParts, int namePartsPtr) {
+		char[][] names = new char[namePartsPtr + 1][];
+		
+		char[] namePart = CharOperation.toLowerCase(nameParts[0]);
+		int namePartLength = namePart.length;
+		System.arraycopy(namePart, 0, namePart, 0, namePartLength);
+		
+		char[] name = namePart;
+		
+		names[namePartsPtr] = name;
+		
+		for (int i = 1; i <= namePartsPtr; i++) {
+			namePart = CharOperation.toLowerCase(nameParts[i]);
+			namePartLength = namePart.length;
+			name = CharOperation.concat(namePart, name);
+			name[namePartLength] = ScannerHelper.toUpperCase(name[namePartLength]);
+			
+			names[namePartsPtr - i] = name;
+		}
+		return names;
+	}
+
+	private static char[][] generateConstantName(char[][] nameParts, int namePartsPtr) {
+		char[][] names = new char[namePartsPtr + 1][];
+		
+		char[] namePart = CharOperation.toUpperCase(nameParts[0]);
+		int namePartLength = namePart.length;
+		System.arraycopy(namePart, 0, namePart, 0, namePartLength);
+		
+		char[] name = namePart;
+		
+		names[namePartsPtr] = name;
+		
+		for (int i = 1; i <= namePartsPtr; i++) {
+			namePart = CharOperation.toUpperCase(nameParts[i]);
+			namePartLength = namePart.length;
+			if (namePart[namePartLength - 1] != '_') {
+				name = CharOperation.concat(namePart, name, '_');
+			} else {
+				name = CharOperation.concat(namePart, name);
+			}
+			
+			names[namePartsPtr - i] = name;
+		}
+		return names;
+	}
+	
+	public static char[] getBaseName(
+			int variableKind,
+			IJavaProject javaProject,
+			char[] name) {
+		
+		AssistOptions assistOptions;
+		if (javaProject != null) {
+			assistOptions = new AssistOptions(javaProject.getOptions(true));
+		} else {
+			assistOptions = new AssistOptions(JavaCore.getOptions());
+		}
+		
+		char[][] prefixes = null;
+		char[][] suffixes = null;
+		switch (variableKind) {
+			case VK_INSTANCE_FIELD:
+				prefixes = assistOptions.fieldPrefixes;
+				suffixes = assistOptions.fieldSuffixes;
+				break;
+			case VK_STATIC_FIELD:
+				prefixes = assistOptions.staticFieldPrefixes;
+				suffixes = assistOptions.staticFieldSuffixes;
+				break;
+			case VK_CONSTANT_FIELD:
+				prefixes = assistOptions.staticFinalFieldPrefixes;
+				suffixes = assistOptions.staticFinalFieldSuffixes;
+				break;
+			case VK_LOCAL:
+				prefixes = assistOptions.localPrefixes;
+				suffixes = assistOptions.localSuffixes;
+				break;
+			case VK_PARAMETER:
+				prefixes = assistOptions.argumentPrefixes;
+				suffixes = assistOptions.argumentSuffixes;
+				break;
+		}
+		
+		
+		return getBaseName(name, prefixes, suffixes, variableKind == VK_CONSTANT_FIELD);
+	}
+
+	private static char[] getBaseName(char[] name, char[][] prefixes, char[][] suffixes, boolean isConstant) {
+		char[] nameWithoutPrefixAndSiffix = removeVariablePrefixAndSuffix(name, prefixes, suffixes, false);
+		
+		char[] baseName;
+		if (isConstant) {
+			int length = nameWithoutPrefixAndSiffix.length;
+			baseName = new char[length];
+			int baseNamePtr = -1;
+			
+			boolean previousIsUnderscore = false;
+			for (int i = 0; i < length; i++) {
+				char c = nameWithoutPrefixAndSiffix[i];
+				if (c != '_') {
+					if (previousIsUnderscore || i == 0) {
+						baseName[++baseNamePtr] = ScannerHelper.toUpperCase(c);
+						previousIsUnderscore = false;
+					} else {
+						baseName[++baseNamePtr] = ScannerHelper.toLowerCase(c);
+					}
+				} else {
+					previousIsUnderscore = true;
+				}
+			}
+			System.arraycopy(baseName, 0, baseName = new char[baseNamePtr + 1], 0, baseNamePtr + 1);
+		} else {
+			baseName = nameWithoutPrefixAndSiffix;
+		}
+		
+		return baseName;
+	}
+	
+	public static char[] removeVariablePrefixAndSuffix(
+			int variableKind,
+			IJavaProject javaProject,
+			char[] name) {
+		AssistOptions assistOptions;
+		if (javaProject != null) {
+			assistOptions = new AssistOptions(javaProject.getOptions(true));
+		} else {
+			assistOptions = new AssistOptions(JavaCore.getOptions());
+		}
+		
+		char[][] prefixes = null;
+		char[][] suffixes = null;
+		switch (variableKind) {
+			case VK_INSTANCE_FIELD:
+				prefixes = assistOptions.fieldPrefixes;
+				suffixes = assistOptions.fieldSuffixes;
+				break;
+			case VK_STATIC_FIELD:
+				prefixes = assistOptions.staticFieldPrefixes;
+				suffixes = assistOptions.staticFieldSuffixes;
+				break;
+			case VK_CONSTANT_FIELD:
+				prefixes = assistOptions.staticFinalFieldPrefixes;
+				suffixes = assistOptions.staticFinalFieldSuffixes;
+				break;
+			case VK_LOCAL:
+				prefixes = assistOptions.localPrefixes;
+				suffixes = assistOptions.localSuffixes;
+				break;
+			case VK_PARAMETER:
+				prefixes = assistOptions.argumentPrefixes;
+				suffixes = assistOptions.argumentSuffixes;
+				break;
+		}
+		
+		return InternalNamingConventions.removeVariablePrefixAndSuffix(name,	prefixes, suffixes, true);
+	}
+	
+	private static char[] removeVariablePrefixAndSuffix(char[] name, char[][] prefixes, char[][] suffixes, boolean updateFirstCharacter) {
+		// remove longer prefix
+		char[] withoutPrefixName = name;
+		if (prefixes != null) {
+			int bestLength = 0;
+			for (int i= 0; i < prefixes.length; i++) {
+				char[] prefix = prefixes[i];
+				if (CharOperation.prefixEquals(prefix, name)) {
+					int currLen = prefix.length;
+					boolean lastCharIsLetter = ScannerHelper.isLetter(prefix[currLen - 1]);
+					if(!lastCharIsLetter || (lastCharIsLetter && name.length > currLen && ScannerHelper.isUpperCase(name[currLen]))) {
+						if (bestLength < currLen && name.length != currLen) {
+							withoutPrefixName = CharOperation.subarray(name, currLen, name.length);
+							bestLength = currLen;
+						}
+					}
+				}
+			}
+		}
+
+		// remove longer suffix
+		char[] withoutSuffixName = withoutPrefixName;
+		if(suffixes != null) {
+			int bestLength = 0;
+			for (int i = 0; i < suffixes.length; i++) {
+				char[] suffix = suffixes[i];
+				if(CharOperation.endsWith(withoutPrefixName, suffix)) {
+					int currLen = suffix.length;
+					if(bestLength < currLen && withoutPrefixName.length != currLen) {
+						withoutSuffixName = CharOperation.subarray(withoutPrefixName, 0, withoutPrefixName.length - currLen);
+						bestLength = currLen;
+					}
+				}
+			}
+		}
+
+		if (updateFirstCharacter) withoutSuffixName[0] = ScannerHelper.toLowerCase(withoutSuffixName[0]);
+		return withoutSuffixName;
+	}
 
 	private static char[] removePrefix(char[] name, char[][] prefixes) {
 		// remove longer prefix
@@ -430,4 +746,277 @@ public class InternalNamingConventions {
 					return false;
 			return true;
 	}
+	
+	public static final int VK_STATIC_FIELD = 1;
+	public static final int VK_INSTANCE_FIELD = 2;
+	public static final int VK_CONSTANT_FIELD = 3;
+	public static final int VK_PARAMETER = 4;
+	public static final int VK_LOCAL = 5;
+	
+	public static final int BK_SIMPLE_NAME = 1;
+	public static final int BK_SIMPLE_TYPE_NAME = 2;
+
+	public static void suggestVariableNames(
+			int variableKind,
+			int baseNameKind,
+			char[] baseName,
+			IJavaProject javaProject,
+			int dim,
+			char[] internalPrefix,
+			char[][] excluded,
+			boolean evaluateDefault,
+			INamingRequestor requestor) {
+		
+		if(baseName == null || baseName.length == 0)
+			return;
+		
+		Map options;
+		if (javaProject != null) {
+			options = javaProject.getOptions(true);
+		} else {
+			options = JavaCore.getOptions();
+		}
+		CompilerOptions compilerOptions = new CompilerOptions(options);
+		AssistOptions assistOptions = new AssistOptions(options);
+		
+		boolean isConstantField = false;
+		
+		char[][] prefixes = null;
+		char[][] suffixes = null;
+		switch (variableKind) {
+			case VK_INSTANCE_FIELD:
+				prefixes = assistOptions.fieldPrefixes;
+				suffixes = assistOptions.fieldSuffixes;
+				break;
+			case VK_STATIC_FIELD:
+				prefixes = assistOptions.staticFieldPrefixes;
+				suffixes = assistOptions.staticFieldSuffixes;
+				break;
+			case VK_CONSTANT_FIELD:
+				isConstantField = true;
+				prefixes = assistOptions.staticFinalFieldPrefixes;
+				suffixes = assistOptions.staticFinalFieldSuffixes;
+				break;
+			case VK_LOCAL:
+				prefixes = assistOptions.localPrefixes;
+				suffixes = assistOptions.localSuffixes;
+				break;
+			case VK_PARAMETER:
+				prefixes = assistOptions.argumentPrefixes;
+				suffixes = assistOptions.argumentSuffixes;
+				break;
+		}
+		
+		if(prefixes == null || prefixes.length == 0) {
+			prefixes = new char[1][0];
+		} else {
+			int length = prefixes.length;
+			System.arraycopy(prefixes, 0, prefixes = new char[length+1][], 0, length);
+			prefixes[length] = CharOperation.NO_CHAR;
+		}
+
+		if(suffixes == null || suffixes.length == 0) {
+			suffixes = new char[1][0];
+		} else {
+			int length = suffixes.length;
+			System.arraycopy(suffixes, 0, suffixes = new char[length+1][], 0, length);
+			suffixes[length] = CharOperation.NO_CHAR;
+		}
+		
+		if(internalPrefix == null) {
+			internalPrefix = CharOperation.NO_CHAR;
+		} else {
+			internalPrefix = removePrefix(internalPrefix, prefixes);
+		}
+
+		char[][] tempNames = null;
+		
+		Scanner nameScanner = getNameScanner(compilerOptions);
+		if (baseNameKind == BK_SIMPLE_TYPE_NAME) {
+			boolean isBaseType = false;
+			
+			try{
+				nameScanner.setSource(baseName);
+				switch (nameScanner.getNextToken()) {
+					case TerminalTokens.TokenNameint :
+					case TerminalTokens.TokenNamebyte :
+					case TerminalTokens.TokenNameshort :
+					case TerminalTokens.TokenNamechar :
+					case TerminalTokens.TokenNamelong :
+					case TerminalTokens.TokenNamefloat :
+					case TerminalTokens.TokenNamedouble :
+					case TerminalTokens.TokenNameboolean :
+						isBaseType = true;
+						break;
+				}
+			} catch(InvalidInputException e){
+				// ignore
+			}
+			if (isBaseType) {
+				// compute variable name from base type
+				if (internalPrefix.length > 0) return;
+	
+				tempNames = computeBaseTypeNames(baseName, isConstantField, excluded);
+			} else {
+				// compute variable name for non base type
+				tempNames = computeNonBaseTypeNames(baseName, isConstantField);
+			}
+		} else {
+			tempNames = new char[][]{baseName};
+		}
+
+		boolean acceptDefaultName = true;
+		SimpleSetOfCharArray foundNames = new SimpleSetOfCharArray();
+
+		for (int i = 0; i < tempNames.length; i++) {
+			char[] tempName = tempNames[i];
+			
+			// add English plural form is necessary
+			if(dim > 0) {
+				int length = tempName.length;
+				
+				if (isConstantField) {
+					if (tempName[length-1] == 'S'){
+						if(tempName.length > 1 && tempName[length-2] == 'S') {
+							System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+							tempName[length] = 'E';
+							tempName[length+1] = 'S';
+						}
+					} else if(tempName[length-1] == 'Y') {
+						System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+						tempName[length-1] = 'I';
+						tempName[length] = 'E';
+						tempName[length+1] = 'S';
+					} else {
+						System.arraycopy(tempName, 0, tempName = new char[length + 1], 0, length);
+						tempName[length] = 'S';
+					}
+				} else {
+					if (tempName[length-1] == 's'){
+						if(tempName.length > 1 && tempName[length-2] == 's') {
+							System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+							tempName[length] = 'e';
+							tempName[length+1] = 's';
+						}
+					} else if(tempName[length-1] == 'y') {
+						System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+						tempName[length-1] = 'i';
+						tempName[length] = 'e';
+						tempName[length+1] = 's';
+					} else {
+						System.arraycopy(tempName, 0, tempName = new char[length + 1], 0, length);
+						tempName[length] = 's';
+					}
+				}
+			}
+			
+			char[] unprefixedName = tempName;
+			
+			int matchingIndex = -1;
+			if (!isConstantField) {
+				unprefixedName[0] = ScannerHelper.toUpperCase(unprefixedName[0]);
+				
+				done : for (int j = 0; j <= internalPrefix.length; j++) {
+					if(j == internalPrefix.length ||
+							CharOperation.prefixEquals(CharOperation.subarray(internalPrefix, j, -1), unprefixedName, j != 0 /*do not check case when there is no prefix*/)) {
+						matchingIndex = j;
+						break done;
+					}
+				}
+			} else {
+				done : for (int j = 0; j <= internalPrefix.length; j++) {
+					if(j == internalPrefix.length) {
+						matchingIndex = j;
+						break done;
+					} else if(CharOperation.prefixEquals(CharOperation.subarray(internalPrefix, j, -1), unprefixedName, j != 0 /*do not check case when there is no prefix*/)) {
+						if (j == 0 || internalPrefix[j - 1] == '_') {
+							matchingIndex = j;
+							break done;
+						}
+						
+					}
+				}
+			}
+
+			if(matchingIndex > -1) {
+				if (!isConstantField) {
+					tempName = CharOperation.concat(CharOperation.subarray(internalPrefix, 0, matchingIndex), unprefixedName);
+					if(matchingIndex == 0) tempName[0] = ScannerHelper.toLowerCase(tempName[0]);
+				} else {
+					if(matchingIndex != 0 && tempName[0] != '_' && internalPrefix[matchingIndex - 1] != '_') {
+						tempName = CharOperation.concat(CharOperation.subarray(CharOperation.toUpperCase(internalPrefix), 0, matchingIndex), unprefixedName, '_');
+					} else {
+						tempName = CharOperation.concat(CharOperation.subarray(CharOperation.toUpperCase(internalPrefix), 0, matchingIndex), unprefixedName);
+					}
+				}
+				
+				for (int k = 0; k < prefixes.length; k++) {
+					if (!isConstantField) {
+						if(prefixes[k].length > 0
+							&& ScannerHelper.isLetterOrDigit(prefixes[k][prefixes[k].length - 1])) {
+							tempName[0] = ScannerHelper.toUpperCase(tempName[0]);
+						} else {
+							tempName[0] = ScannerHelper.toLowerCase(tempName[0]);
+						}
+					}
+					char[] prefixName = CharOperation.concat(prefixes[k], tempName);
+					for (int l = 0; l < suffixes.length; l++) {
+						char[] suffixName = CharOperation.concat(prefixName, suffixes[l]);
+						suffixName =
+							excludeNames(
+								suffixName,
+								prefixName,
+								suffixes[l],
+								excluded);
+						try{
+							nameScanner.setSource(suffixName);
+							switch (nameScanner.getNextToken()) {
+								case TerminalTokens.TokenNameIdentifier :
+									int token = nameScanner.getNextToken();
+									if (token == TerminalTokens.TokenNameEOF && nameScanner.startPosition == suffixName.length) {
+										if (!foundNames.includes(suffixName)) {
+											acceptName(suffixName, prefixes[k], suffixes[l],  k == 0, l == 0, internalPrefix.length - matchingIndex, requestor);
+											foundNames.add(suffixName);
+											acceptDefaultName = false;
+										}
+									}
+									break;
+								default:
+									suffixName = CharOperation.concat(
+										prefixName,
+										String.valueOf(1).toCharArray(),
+										suffixes[l]
+									);
+									suffixName =
+										excludeNames(
+											suffixName,
+											prefixName,
+											suffixes[l],
+											excluded);
+									nameScanner.setSource(suffixName);
+									switch (nameScanner.getNextToken()) {
+										case TerminalTokens.TokenNameIdentifier :
+											token = nameScanner.getNextToken();
+											if (token == TerminalTokens.TokenNameEOF && nameScanner.startPosition == suffixName.length) {
+												if (!foundNames.includes(suffixName)) {
+													acceptName(suffixName, prefixes[k], suffixes[l], k == 0, l == 0, internalPrefix.length - matchingIndex, requestor);
+													foundNames.add(suffixName);
+													acceptDefaultName = false;
+												}
+											}
+									}
+							}
+						} catch(InvalidInputException e){
+							// ignore
+						}
+					}
+				}
+			}
+		}
+		// if no names were found
+		if(evaluateDefault && acceptDefaultName) {
+			char[] name = excludeNames(DEFAULT_NAME, DEFAULT_NAME, CharOperation.NO_CHAR, excluded);
+			requestor.acceptNameWithoutPrefixAndSuffix(name, 0);
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
index b7a3ac7..2620250 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
@@ -77,10 +77,12 @@ public class JavaCorePreferenceInitializer extends AbstractPreferenceInitializer
 		defaultOptionsMap.put(JavaCore.CODEASSIST_IMPLICIT_QUALIFICATION, JavaCore.DISABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FIELD_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FIELD_PREFIXES, ""); //$NON-NLS-1$
+		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_LOCAL_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_ARGUMENT_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FIELD_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FIELD_SUFFIXES, ""); //$NON-NLS-1$
+		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_LOCAL_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_ARGUMENT_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.ENABLED);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index c57f64d..e65f0a8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -1965,10 +1965,12 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		defaultOptionsMap.put(JavaCore.CODEASSIST_IMPLICIT_QUALIFICATION, JavaCore.DISABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FIELD_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FIELD_PREFIXES, ""); //$NON-NLS-1$
+		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_LOCAL_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_ARGUMENT_PREFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FIELD_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FIELD_SUFFIXES, ""); //$NON-NLS-1$
+		defaultOptionsMap.put(JavaCore.CODEASSIST_STATIC_FINAL_FIELD_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_LOCAL_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_ARGUMENT_SUFFIXES, ""); //$NON-NLS-1$
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.ENABLED);
