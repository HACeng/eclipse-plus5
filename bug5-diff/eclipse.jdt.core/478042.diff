commit bdd2ddc06125eff9d34246fb7941b569e87e3115
Author: manoj <manpalat@in.ibm.com>
Date:   Mon Oct 26 09:47:25 2015 +0530

    Fix for Bug 478042 [search] Support for Open Method using a single api
    
    Change-Id: Ie4773cd3db2904a0658b250927c60c30a0769378

326	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
269	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java
280	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests2.java
84	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SearchTests.java
119	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopySearchTests.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
3	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
66	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatch.java
54	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatchRequestor.java
70	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameRequestor.java
109	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
410	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
36	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IRestrictedAccessMethodRequestor.java
55	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchMethodNameMatch.java
74	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameMatchRequestorWrapper.java
64	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameRequestorWrapper.java
189	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
21	177	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
36	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
21	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
50	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
330	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
index 75638b0..a62548a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
@@ -27,12 +27,14 @@ import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.internal.compiler.ExtraFlags;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
+import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.internal.core.LambdaExpression;
 import org.eclipse.jdt.internal.core.Member;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.SourceRefElement;
 import org.eclipse.jdt.internal.core.search.BasicSearchEngine;
 import org.eclipse.jdt.internal.core.search.IRestrictedAccessConstructorRequestor;
+import org.eclipse.jdt.internal.core.search.IRestrictedAccessMethodRequestor;
 import org.eclipse.jdt.internal.core.search.matching.PatternLocator;
 
 /**
@@ -152,6 +154,122 @@ public class AbstractJavaSearchTests extends ModifyingResourceTests implements I
 			return this.results.size();
 		}
 	}
+	
+	static void checkAndAddtoBuffer(StringBuffer buffer, char[] precond, char c) {
+		if (precond == null || precond.length == 0) return;
+		buffer.append(precond);
+		buffer.append(c);
+	}
+	public static class MethodDeclarationsCollector implements IRestrictedAccessMethodRequestor {
+		Vector results = new Vector();
+
+		@Override
+		public void acceptMethod(
+				char[] methodName, 
+				int parameterCount, 
+				char[] declaringQualifier,
+				char[] simpleTypeName, 
+				int typeModifiers, 
+				char[] packageName, 
+				char[] signature, 
+				char[][] parameterTypes,
+				char[][] parameterNames, 
+				char[] returnType, 
+				int modifiers, 
+				String path,
+				AccessRestriction access,
+				int methodIndex) {
+
+			StringBuffer buffer = new StringBuffer();
+			char c = '.';
+			char[] noname = new String("<NONAME>").toCharArray();
+			buffer.append(path);
+			buffer.append(' ');
+			buffer.append(returnType == null ? CharOperation.NO_CHAR: returnType);
+			buffer.append(' ');
+			checkAndAddtoBuffer(buffer, packageName, c);
+			checkAndAddtoBuffer(buffer, declaringQualifier, c);
+			checkAndAddtoBuffer(buffer, simpleTypeName == null ? noname : simpleTypeName, c);
+			buffer.append(methodName);
+			buffer.append('(');
+			parameterTypes = signature == null ? parameterTypes : Signature.getParameterTypes(signature);
+
+			for (int i = 0; i < parameterCount; i++) {
+				if (parameterTypes != null) {
+					char[] parameterType;
+					if (parameterTypes.length != parameterCount) {
+						System.out.println("Error");
+					}
+					if (signature != null) {
+						parameterType = Signature.toCharArray(Signature.getTypeErasure(parameterTypes[i]));
+						CharOperation.replace(parameterType, '/', '.');
+					} else {
+						parameterType = this.getTypeErasure(parameterTypes[i]);
+					}
+					buffer.append(parameterType);
+				} else {
+					buffer.append('?'); // parameter type names are not stored in the indexes
+					buffer.append('?');
+					buffer.append('?');
+				}
+				buffer.append(' ');
+				if (parameterNames != null) {
+					buffer.append(parameterNames[i]);
+				} else {
+					buffer.append("arg"+i);
+				}
+				if (parameterCount > 1 && i < parameterCount - 1) buffer.append(',');
+			}
+			buffer.append(')');
+			this.results.addElement(buffer.toString());
+		}
+		private char[] getTypeErasure(char[] typeName) {
+			int index;
+			if ((index = CharOperation.indexOf('<', typeName)) == -1) return typeName;
+			
+			int length = typeName.length;
+			char[] typeErasurename = new char[length - 2];
+			
+			System.arraycopy(typeName, 0, typeErasurename, 0, index);
+			
+			int depth = 1;
+			for (int i = index + 1; i < length; i++) {
+				switch (typeName[i]) {
+					case '<':
+						depth++;
+						break;
+					case '>':
+						depth--;
+						break;
+					default:
+						if (depth == 0) {
+							typeErasurename[index++] = typeName[i];
+						}
+						break;
+				}
+			}
+			
+			System.arraycopy(typeErasurename, 0, typeErasurename = new char[index], 0, index);
+			return typeErasurename;
+		}
+		public String toString(){
+			int length = this.results.size();
+			String[] strings = new String[length];
+			this.results.toArray(strings);
+			org.eclipse.jdt.internal.core.util.Util.sort(strings);
+			StringBuffer buffer = new StringBuffer(100);
+			for (int i = 0; i < length; i++){
+				buffer.append(strings[i]);
+				if (i != length-1) {
+					buffer.append('\n');
+				}
+			}
+			return buffer.toString();
+		}
+		public int size() {
+			return this.results.size();
+		}
+	}
 	/**
 	 * Collects results as a string.
 	 */
@@ -630,6 +748,84 @@ public class AbstractJavaSearchTests extends ModifyingResourceTests implements I
 	    }
 	}
 
+	static class MethodNameMatchCollector extends MethodNameMatchRequestor {
+		List matches = new ArrayList();
+		public void acceptMethodNameMatch(MethodNameMatch match) {
+			IMethod method = match.getMethod();
+			if (method != null) {
+				this.matches.add(method);
+			}
+		}
+		public int size() {
+			return this.matches.size();
+		}
+		private String toString(boolean withTypeName) {
+			int size = size();
+			if (size == 0) return "";
+			String[] strings = new String[size];
+			for (int i=0; i<size; i++) {
+				IMethod method = (IMethod) this.matches.get(i);
+				IType type = method.getDeclaringType();
+				String path = type.getPath().toPortableString();
+				String declaringTypeName = type.getFullyQualifiedName('.');
+				String[] parameterTypes = method.getParameterTypes();
+				String[] parameterNames;
+				try {
+					parameterNames = method.getParameterNames();
+				} catch (JavaModelException e1) {
+					parameterNames = new String[] {Util.EMPTY_STRING};
+				}
+				int nParameterNames = parameterNames.length;
+				
+				StringBuffer buf = new StringBuffer();
+				buf.append(path);
+				buf.append(' ');
+				try {
+					buf.append(Signature.toString(Signature.getTypeErasure(method.getReturnType())));
+					buf.append(' ');
+				} catch (JavaModelException e) {
+					// do nothing
+				}
+				if (withTypeName) {
+					buf.append(declaringTypeName);
+					buf.append('.');
+				}
+				buf.append(method.getElementName());
+				buf.append('(');
+				int l = parameterTypes.length;
+				if (l > 0) {
+					buf.append(Signature.toString(Signature.getTypeErasure(parameterTypes[0])));
+					if (nParameterNames > 0) {
+						buf.append(' ');
+						buf.append(parameterNames[0]);
+					}
+					for (int j = 1; j < l; ++j) {
+						buf.append(',');
+						buf.append(Signature.toString(Signature.getTypeErasure(parameterTypes[j])));
+						if (j < nParameterNames) {
+							buf.append(' ');
+							buf.append(parameterNames[j]);
+						}
+					}
+				}
+				buf.append(')');
+				if (i < size - 1) buf.append('\n');
+				strings[i] = buf.toString();
+			}
+			StringBuffer buffer = new StringBuffer();
+			for (int i=0; i<size; i++) {
+				buffer.append(strings[i]);
+			}
+			return buffer.toString();
+		}
+		public String toString() {
+			return toString(false);
+		}
+		public String toFullyQualifiedNamesString() {
+			return toString(true);
+		}
+	}
+
 	static class TypeNameMatchCollector extends TypeNameMatchRequestor {
 		List matches = new ArrayList();
 		public void acceptTypeNameMatch(TypeNameMatch match) {
@@ -879,6 +1075,136 @@ protected JavaSearchResultCollector resultCollector;
 				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
 				null);
 	}
+	protected void searchAllMethodNames(String pattern, int matchRule, IRestrictedAccessMethodRequestor requestor) throws JavaModelException {
+		new BasicSearchEngine(this.workingCopies).searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				null, SearchPattern.R_EXACT_MATCH, 
+				null, SearchPattern.R_EXACT_MATCH, 
+				pattern.toCharArray(), matchRule, 
+				getJavaSearchScope(),
+				requestor,
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
+				null);
+	}
+	protected void searchAllMethodNames(String pattern, int matchRule, IJavaSearchScope scope, IRestrictedAccessMethodRequestor requestor) throws JavaModelException {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				pattern, matchRule, 
+				scope,
+				requestor);
+	}
+	protected void searchAllMethodNames(
+			String declSimpleNamePattern, int declSimpleNameMatchRule,
+			String patternMethod, int methodMatchRule, 
+			IJavaSearchScope scope, 
+			IRestrictedAccessMethodRequestor requestor) throws JavaModelException {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				declSimpleNamePattern, declSimpleNameMatchRule, 
+				patternMethod, methodMatchRule, 
+				scope,
+				requestor);
+	}
+	protected void searchAllMethodNames(
+			String declQualificationPattern, int declQualificationMatchRule,
+			String declSimpleNamePattern, int declSimpleNameMatchRule,
+			String patternMethod, int methodMatchRule, 
+			IJavaSearchScope scope, 
+			IRestrictedAccessMethodRequestor requestor) throws JavaModelException {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				declQualificationPattern, declQualificationMatchRule, 
+				declSimpleNamePattern, declSimpleNameMatchRule, 
+				patternMethod, methodMatchRule, 
+				scope,
+				requestor);
+	}
+	protected void searchAllMethodNames(
+			String patternPackage, int pkgMatchRule,
+			String declQualificationPattern, int declQualificationMatchRule,
+			String declSimpleNamePattern, int declSimpleNameMatchRule,
+			String patternMethod, int methodMatchRule, 
+			IJavaSearchScope scope, 
+			IRestrictedAccessMethodRequestor requestor) throws JavaModelException {
+		new BasicSearchEngine(this.workingCopies).searchAllMethodNames(
+				patternPackage == null ? null : patternPackage.toCharArray(), pkgMatchRule, 
+				declQualificationPattern == null ? null : declQualificationPattern.toCharArray(), declQualificationMatchRule, 
+				declSimpleNamePattern == null ? null : declSimpleNamePattern.toCharArray(), declSimpleNameMatchRule, 
+				patternMethod == null ? null : patternMethod.toCharArray(), methodMatchRule, 
+				scope,
+				requestor,
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
+				null);
+	}
+
+	public void searchAllMethodNames(
+			String methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameMatchRequestor nameRequestor) {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				null, SearchPattern.R_EXACT_MATCH, 
+				null, SearchPattern.R_EXACT_MATCH, 
+				methodName, methodMatchRule, 
+				scope, nameRequestor);
+	}
+	public void searchAllMethodNames(
+			String declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			String methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameMatchRequestor nameRequestor) {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				null, SearchPattern.R_EXACT_MATCH, 
+				declaringSimpleName, declSimpleNameMatchRule, 
+				methodName, methodMatchRule, 
+				scope, nameRequestor);
+	}
+	public void searchAllMethodNames(
+			String declaringQualification,
+			final int declQualificationMatchRule,
+			String declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			String methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameMatchRequestor nameRequestor) {
+		searchAllMethodNames(
+				null, SearchPattern.R_EXACT_MATCH, 
+				declaringQualification, declQualificationMatchRule, 
+				declaringSimpleName, declSimpleNameMatchRule, 
+				methodName, methodMatchRule, 
+				scope, nameRequestor);
+	}
+	public void searchAllMethodNames(
+			String packageName,
+			final int pkgMatchRule,
+			String declaringQualification,
+			final int declQualificationMatchRule,
+			String declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			String methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameMatchRequestor nameRequestor) {
+		try {
+			new SearchEngine(this.workingCopies).searchAllMethodNames(
+					packageName != null ? packageName.toCharArray() : null, pkgMatchRule, 
+					declaringQualification != null ? declaringQualification.toCharArray() : null, declQualificationMatchRule, 
+					declaringSimpleName != null ? declaringSimpleName.toCharArray() : null, declSimpleNameMatchRule, 
+					methodName != null ? methodName.toCharArray() : null, methodMatchRule, 
+					scope, nameRequestor, 
+					IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, 
+					null);
+		} catch (JavaModelException e) {
+			e.printStackTrace();
+		}
+		
+	}
+
 	protected void searchAllTypeNames(String pattern, int matchRule, TypeNameRequestor requestor) throws JavaModelException {
 		new SearchEngine(this.workingCopies).searchAllTypeNames(
 			null,
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java
index 824c5d5..60220c8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java
@@ -14433,5 +14433,273 @@ public void testBug476738_002() throws CoreException {
 			"src/X.java void X.bar(I, Bar.InnerKey) [query(key)] EXACT_MATCH"
 	);
 }
-
+public void testBug478042_wScope_0001() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void foo01() {}\n" +
+		"  public int foo02(Object o) {return null;}\n" +
+		"  public char foo03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+			requestor
+	);
+}
+public void testBug478042_wScope_0002() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void foo01() {}\n" +
+		"  public int foo02(Object o) {return null;}\n" +
+		"  public char foo03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+			requestor
+	);
+}
+public void testBug478042_wScope_003() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void foo01() {}\n" +
+		"  public int foo02(Object o) {return null;}\n" +
+		"  public char foo03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames("AllMethod", SearchPattern.R_PREFIX_MATCH, "foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+			requestor
+	);
+}
+public void testBug478042_wScope_004() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void foo01() {}\n" +
+		"  public int foo02(Object o) {return null;}\n" +
+		"  public char foo03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames(
+			"p478042", SearchPattern.R_EXACT_MATCH, //package
+			null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+			"AllMethod", SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+			"foo", SearchPattern.R_PREFIX_MATCH, 
+			scope, requestor);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+			requestor
+	);
+}
+public void testBug478042_wScope_005() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void foo01() {}\n" +
+		"  public int foo02(Object o) {return null;}\n" +
+		"  public char foo03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodNameMatchCollector collector = new MethodNameMatchCollector() {
+		@Override
+		public String toString() {
+			return toFullyQualifiedNamesString();
+		}
+	};
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames(
+			"p478042", SearchPattern.R_EXACT_MATCH, //package
+			null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+			"AllMethod", SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+			"foo", SearchPattern.R_PREFIX_MATCH, 
+			scope, collector);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+			collector
+	);
+}
+public void testBug478042_wScope_006() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public void fooCamelCase01() {}\n" +
+		"  public int fooCamelCase02(Object o) {return null;}\n" +
+		"  public char fooCamel03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooCamelCaseInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodNameMatchCollector collector = new MethodNameMatchCollector() {
+		@Override
+		public String toString() {
+			return toFullyQualifiedNamesString();
+		}
+	};
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames(
+			"p478042", SearchPattern.R_EXACT_MATCH, //package
+			null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+			"AllMethod", SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+			"fooCC", SearchPattern.R_CAMELCASE_MATCH, 
+			scope, collector);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.fooCamelCase01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.fooCamelCase02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooCamelCaseInt()",
+			collector
+	);
+}
+public void testBug478042_wScope_007() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+		"package p478042;\n" +
+		"class Y<T> {}\n" +
+		"class X<T> {}\n" +
+		"public class AllMethodDeclarations01 {\n" +
+		"  public Y<X> fooCamelCase01(Y<X> t) {}\n" +
+		"  public int fooCamelCase02(Object o) {return null;}\n" +
+		"  public char fooCamel03(Object o, String s) {return null;}\n" +
+		"}\n"
+	);
+	
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooCamelCaseInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodNameMatchCollector collector = new MethodNameMatchCollector() {
+		@Override
+		public String toString() {
+			return toFullyQualifiedNamesString();
+		}
+	};
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames(
+			"p478042", SearchPattern.R_EXACT_MATCH, //package
+			null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+			"AllMethod", SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+			"fooCC", SearchPattern.R_CAMELCASE_MATCH, 
+			scope, collector);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java Y p478042.AllMethodDeclarations01.fooCamelCase01(Y t)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.fooCamelCase02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooCamelCaseInt()",
+			collector
+	);
+}
+public void testBug478042_wScope_008() throws Exception {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java",
+			"package p478042;\n" +
+			"public class AllMethodDeclarations01 {\n" +
+			"public class Nested {\n" +
+			"public class Inner {\n" +
+			"  public void foo01() {}\n" +
+			"  public int foo02(Object o) {return 0;}\n" +
+			"  public char foo03(Object o, String s) {return '0';}\n" +
+			"}\n" +
+			"}\n" +
+			"}\n"
+	);
+	
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/p478042/AllMethodDeclarations01b.java",
+		"package p478042;\n" +
+		"public class AllMethodDeclarations01b {\n" +
+		"  public Integer fooInt() {return null;}\n" +
+		"}\n"
+	);
+	MethodNameMatchCollector collector = new MethodNameMatchCollector() {
+		@Override
+		public String toString() {
+			return toFullyQualifiedNamesString();
+		}
+	};
+	IJavaSearchScope scope = SearchEngine.createJavaSearchScope(this.workingCopies);
+	searchAllMethodNames(
+			"p478042", SearchPattern.R_EXACT_MATCH, //package
+			"AllMethod", SearchPattern.R_PREFIX_MATCH,  // declaring Qualification
+			"Inn", SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+			"foo", SearchPattern.R_PREFIX_MATCH, 
+			scope, collector);
+	assertSearchResults(
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.Nested.Inner.foo01()\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.Nested.Inner.foo02(Object o)\n" + 
+			"/JavaSearchBugs/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.Nested.Inner.foo03(Object o,String s)", 
+			collector
+	);
 }
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests2.java
index 4c0e682..bf96d1e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests2.java
@@ -30,6 +30,8 @@ import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.search.IJavaSearchConstants;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.MethodNameMatch;
+import org.eclipse.jdt.core.search.MethodNameMatchRequestor;
 import org.eclipse.jdt.core.search.SearchEngine;
 import org.eclipse.jdt.core.search.SearchMatch;
 import org.eclipse.jdt.core.search.SearchPattern;
@@ -1961,4 +1963,281 @@ public class JavaSearchBugsTests2 extends AbstractJavaSearchTests {
 			deleteProject("P");
 		}
 	}
-}
+	public void testBug478042_0001() throws Exception {
+		IJavaProject project = null;
+		try
+		{
+			// create the common project and create an interface
+			project = createJavaProject("P", new String[] {"src"}, new String[] {"JCL15_LIB"}, "bin","1.5");
+			createFolder("P/src/p478042");
+			createFile("/P/src/p478042/AllMethodDeclarations01.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return null;}\n" +
+				"  public char foo03(Object o, String s) {return null;}\n" +
+				"    }");
+			createFile("/P/src/p478042/AllMethodDeclarations01b.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01b {\n" +
+				"  public Integer fooInt() {return null;}\n" +
+				"    }");
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.SOURCES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+					"/P/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+					requestor
+			);
+		} finally {
+			deleteProject(project);
+		}
+	}
+	public void testBug478042_0002() throws Exception {
+		IJavaProject project = null;
+		try
+		{
+			// create the common project and create an interface
+			project = createJavaProject("P", new String[] {"src"}, new String[] {"JCL15_LIB"}, "bin","1.5");
+			createFolder("P/src/p478042");
+			createFile("/P/src/p478042/AllMethodDeclarations01.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return null;}\n" +
+				"  public char foo03(Object o, String s) {return null;}\n" +
+				"    }");
+			createFile("/P/src/p478042/AllMethodDeclarations01b.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01b {\n" +
+				"  public Integer fooInt() {return null;}\n" +
+				"    }");
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.SOURCES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.foo01()\n" + 
+					"/P/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+					requestor
+			);
+		} finally {
+			deleteProject(project);
+		}
+	}
+	public void testBug478042_0003() throws Exception {
+		IJavaProject project = null;
+		try {
+			project = createJavaProject("P", new String[] {"src"}, new String[] {"JCL15_LIB"}, "bin","1.5");
+			createFolder("P/src/p478042");
+			createFile("/P/src/p478042/AllMethodDeclarations01.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"  public void foo() {}\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return null;}\n" +
+				"  public char foo03(Object o, String s) {return null;}\n" +
+				"    }");
+			createFile("/P/src/p478042/AllMethodDeclarations01b.java", 
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01b {\n" +
+				"  public Integer fooInt() {return null;}\n" +
+				"    }");
+			class Collector extends MethodNameMatchRequestor {
+				List<MethodNameMatch> matches = new ArrayList<>();
+				@Override
+				public void acceptMethodNameMatch(MethodNameMatch match) {
+					this.matches.add(match);					
+				}
+			}
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.SOURCES);
+			Collector collector = new Collector();
+			new SearchEngine().searchAllMethodNames(
+					null, SearchPattern.R_EXACT_MATCH,
+					null, SearchPattern.R_EXACT_MATCH,
+					"AllMethodDeclarations01".toCharArray(), SearchPattern.R_EXACT_MATCH,
+					"foo".toCharArray(), SearchPattern.R_PREFIX_MATCH,
+					scope, collector, IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
+			assertEquals(4, collector.matches.size());
+		} finally {
+			deleteProject("P");
+		}
+	}
+	public void testBug478042_0004() throws Exception {
+		IJavaProject project = null;
+		try
+		{
+			// create the common project and create an interface
+			project = createJavaProject("P", new String[] {"src"}, new String[] {"JCL15_LIB"}, "bin","1.5");
+			createFolder("P/src/p478042");
+			createFile("/P/src/p478042/AllMethodDeclarations01.java", 
+					"package p478042;\n" +
+					"class Y<T> {}\n" +
+					"class X<T> {}\n" +
+					"public class AllMethodDeclarations01 {\n" +
+					"  public Y<X> foo01(Y<X> t) {}\n" +
+					"  public int foo02(Object o) {return null;}\n" +
+					"  public char foo03(Object o, String s) {return null;}\n" +
+					"}");
+			createFile("/P/src/p478042/AllMethodDeclarations01b.java", 
+					"package p478042;\n" +
+					"public class AllMethodDeclarations01b {\n" +
+					"  public Integer fooInt() {return null;}\n" +
+					"}");
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.SOURCES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/src/p478042/AllMethodDeclarations01.java Y p478042.AllMethodDeclarations01.foo01(Y t)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01b.java Integer p478042.AllMethodDeclarations01b.fooInt()",
+					requestor
+			);
+		} finally {
+			deleteProject(project);
+		}
+	}
+	public void testBug478042_005() throws Exception {
+		try {
+			IJavaProject p = createJavaProject("P", new String[] {}, new String[] { "/P/lib478042.jar", "JCL15_LIB" }, "", "1.5");
+			createJar(new String[] {
+				"p478042/AllMethodDeclarations02.java",
+				"package p478042;\n" +
+				"class X {}\n" +
+				"class Y<T>{}\n" +
+				"public class AllMethodDeclarations02 {\n" +
+				"  public Y<X> foo01(Y<X> t) { return null;}\n" +
+				"  public int foo02(Object o) {return 0;}\n" +
+				"  public char foo03(Object o, String s) {return '0';}\n" +
+				"}",
+				"p478042/AllMethodDeclarations02b.java",
+				"package p478042;\n" +
+				"class AllMethodDeclarations02b {\n" +
+				"  public void fooInt() {}\n" +
+				"}"
+			}, p.getProject().getLocation().append("lib478042.jar").toOSString(),
+				new String[] { p.getProject().getLocation().append("lib478042.jar").toOSString() },
+				"1.5");
+			refresh(p);
+			
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { p }, IJavaSearchScope.SOURCES|IJavaSearchScope.APPLICATION_LIBRARIES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/lib478042.jar|p478042/AllMethodDeclarations02.class char p478042.AllMethodDeclarations02.foo03(java.lang.Object o,java.lang.String s)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations02.class int p478042.AllMethodDeclarations02.foo02(java.lang.Object o)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations02.class p478042.Y p478042.AllMethodDeclarations02.foo01(p478042.Y t)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations02b.class void p478042.AllMethodDeclarations02b.fooInt()",
+					requestor
+			);
+		} finally {
+			deleteProject("P");
+		}
+	}
+	public void testBug478042_006() throws Exception {
+		try {
+			IJavaProject p = createJavaProject("P", new String[] {}, new String[] { "/P/lib478042.jar", "JCL15_LIB" }, "", "1.5");
+			createJar(new String[] {
+				"p478042/AllMethodDeclarations01.java",
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"    public class Nested {\n" +
+				"        public class Inner {\n" +
+				"            public void foo01() {}\n" +
+				"            public int foo02(Object o) {return 0;}\n" +
+				"            public char foo03(Object o, String s) {return '0';}\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n"
+			}, p.getProject().getLocation().append("lib478042.jar").toOSString(),
+				new String[] { p.getProject().getLocation().append("lib478042.jar").toOSString() },
+				"1.5");
+			refresh(p);
+			
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { p }, IJavaSearchScope.SOURCES|IJavaSearchScope.APPLICATION_LIBRARIES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class char p478042.Inner.foo03(java.lang.Object o,java.lang.String s)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class int p478042.Inner.foo02(java.lang.Object o)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class void p478042.Inner.foo01()",
+					requestor
+			);
+		} finally {
+			deleteProject("P");
+		}
+	}
+	public void testBug478042_007() throws Exception {
+		try {
+			IJavaProject p = createJavaProject("P", new String[] {}, new String[] { "/P/lib478042.jar", "JCL15_LIB" }, "", "1.5");
+			createJar(new String[] {
+				"p478042/AllMethodDeclarations01.java",
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"    public class Nested {\n" +
+				"        public class Inner {\n" +
+				"            public void foo01() {}\n" +
+				"            public int foo02(Object o) {return 0;}\n" +
+				"            public char foo03(Object o, String s) {return '0';}\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n"
+			}, p.getProject().getLocation().append("lib478042.jar").toOSString(),
+				new String[] { p.getProject().getLocation().append("lib478042.jar").toOSString() },
+				"1.5");
+			refresh(p);
+			
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { p }, IJavaSearchScope.SOURCES|IJavaSearchScope.APPLICATION_LIBRARIES);
+			searchAllMethodNames(
+					"Inner", SearchPattern.R_EXACT_MATCH,
+					"foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class char p478042.Inner.foo03(java.lang.Object o,java.lang.String s)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class int p478042.Inner.foo02(java.lang.Object o)\n" + 
+					"/P/lib478042.jar|p478042/AllMethodDeclarations01$Nested$Inner.class void p478042.Inner.foo01()",
+					requestor
+			);
+		} finally {
+			deleteProject("P");
+		}
+	}
+	public void testBug478042_008() throws Exception {
+		IJavaProject project = null;
+		try
+		{
+			// create the common project and create an interface
+			project = createJavaProject("P", new String[] {"src"}, new String[] {"JCL15_LIB"}, "bin","1.5");
+			createFolder("P/src/p478042");
+			createFile("/P/src/p478042/AllMethodDeclarations01.java", 
+					"package p478042;\n" +
+					"public class AllMethodDeclarations01 {\n" +
+					"    public class Nested {\n" +
+					"        public class Inner {\n" +
+					"            public void foo01() {}\n" +
+					"            public int foo02(Object o) {return 0;}\n" +
+					"            public char foo03(Object o, String s) {return '0';}\n" +
+					"        }\n" +
+					"    }\n" +
+					"}");
+			MethodDeclarationsCollector requestor = new MethodDeclarationsCollector();
+			IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.SOURCES);
+			searchAllMethodNames("foo", SearchPattern.R_PREFIX_MATCH, scope, requestor);
+			assertSearchResults(
+					"/P/src/p478042/AllMethodDeclarations01.java char p478042.AllMethodDeclarations01.Nested .Inner.foo03(Object o,String s)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java int p478042.AllMethodDeclarations01.Nested .Inner.foo02(Object o)\n" + 
+					"/P/src/p478042/AllMethodDeclarations01.java void p478042.AllMethodDeclarations01.Nested .Inner.foo01()",
+					requestor
+			);
+		} catch(Exception e) {
+			e.printStackTrace();
+		} finally {
+			deleteProject(project);
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SearchTests.java
index 629d497..0f74092 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SearchTests.java
@@ -74,6 +74,90 @@ public class SearchTests extends ModifyingResourceTests implements IJavaSearchCo
 		public void worked(int work) {
 		}
 	}
+	public static class SearchMethodNameRequestor extends MethodNameRequestor {
+		Vector results = new Vector<>();
+		@Override
+		public void acceptMethod(
+				char[] methodName, 
+				int parameterCount, 
+				char[] declaringQualifier, 
+				char[] simpleTypeName, 
+				int typeModifiers, 
+				char[] packageName, 
+				char[] signature, 
+				char[][] parameterTypes, 
+				char[][] parameterNames, 
+				char[] returnType, 
+				int modifiers, 
+				String path, 
+				int methodIndex) {
+			StringBuffer buffer = new StringBuffer();
+			char c = '.';
+			char[] noname = new String("<NONAME>").toCharArray();
+			buffer.append(path);
+			buffer.append(' ');
+			buffer.append(returnType == null ? CharOperation.NO_CHAR: returnType);
+			buffer.append(' ');
+			checkAndAddtoBuffer(buffer, packageName, c);
+			checkAndAddtoBuffer(buffer, declaringQualifier, c);
+			checkAndAddtoBuffer(buffer, simpleTypeName == null ? noname : simpleTypeName, c);
+			buffer.append(methodName);
+			buffer.append('(');
+			parameterTypes = signature == null ? parameterTypes : Signature.getParameterTypes(signature);
+			
+			for (int i = 0; i < parameterCount; i++) {
+				
+				if (parameterTypes != null) {
+					char[] parameterType;
+					if (parameterTypes.length != parameterCount) {
+						System.out.println("Error");
+					}
+					if (signature != null) {
+						parameterType = Signature.toCharArray(Signature.getTypeErasure(parameterTypes[i]));
+						CharOperation.replace(parameterType, '/', '.');
+					} else {
+						parameterType = parameterTypes[i];
+					}
+					buffer.append(parameterType);
+				} else {
+					buffer.append('?'); // parameter type names are not stored in the indexes
+					buffer.append('?');
+					buffer.append('?');
+				}
+				buffer.append(' ');
+				if (parameterNames != null) {
+					buffer.append(parameterNames[i]);
+				} else {
+					buffer.append("arg"+i);
+				}
+				if (parameterCount > 1 && i < parameterCount - 1) buffer.append(',');
+			}
+			buffer.append(')');
+			this.results.addElement(buffer.toString());
+		}
+		static void checkAndAddtoBuffer(StringBuffer buffer, char[] precond, char c) {
+			if (precond == null || precond.length == 0) return;
+			buffer.append(precond);
+			buffer.append(c);
+		}
+		public String toString(){
+			int length = this.results.size();
+			String[] strings = new String[length];
+			this.results.toArray(strings);
+			org.eclipse.jdt.internal.core.util.Util.sort(strings);
+			StringBuffer buffer = new StringBuffer(100);
+			for (int i = 0; i < length; i++){
+				buffer.append(strings[i]);
+				if (i != length-1) {
+					buffer.append('\n');
+				}
+			}
+			return buffer.toString();
+		}
+		public int size() {
+			return this.results.size();
+		}
+	}
 	public static class SearchTypeNameRequestor extends TypeNameRequestor {
 		Vector results = new Vector();
 		public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path) {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopySearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopySearchTests.java
index 353e859..b249251 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopySearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopySearchTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -450,5 +450,123 @@ public class WorkingCopySearchTests extends JavaSearchTests {
 			this.resultCollector);
 
 	}
+	/*
+	 * Search all method names in working copies test (without reconciling working copies).
+	 */
+	public void testBug478042_dirtyWC_001() throws CoreException {
+		this.workingCopy.getBuffer().setContents(
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return 0;}\n" +
+				"  public char foo03(Object o, String s) {return '0';}\n" +
+				"}\n"
+		);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {this.workingCopy.getParent()});
+		SearchTests.SearchMethodNameRequestor requestor = new SearchTests.SearchMethodNameRequestor();
+		new SearchEngine(new ICompilationUnit[] {this.workingCopy}).searchAllMethodNames(
+				"p478042".toCharArray(), SearchPattern.R_EXACT_MATCH, //package
+				null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+				"AllMethod".toCharArray(), SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+				"foo".toCharArray(), SearchPattern.R_PREFIX_MATCH, 
+				scope, requestor, 
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
+		assertSearchResults(
+				"/JavaSearch/src/wc/X.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+				"/JavaSearch/src/wc/X.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+				"/JavaSearch/src/wc/X.java void p478042.AllMethodDeclarations01.foo01()",
+				requestor
+		);
+	}
+	/*
+	 * Search all method names in working copies test (without reconciling working copies).
+	 */
+	public void testBug478042_dirtyWC_002() throws CoreException {
+		this.workingCopy.getBuffer().setContents(
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"public class Nested {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return 0;}\n" +
+				"  public char foo03(Object o, String s) {return '0';}\n" +
+				"}\n" +
+				"}\n"
+		);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {this.workingCopy.getParent()});
+		SearchTests.SearchMethodNameRequestor requestor = new SearchTests.SearchMethodNameRequestor();
+		new SearchEngine(new ICompilationUnit[] {this.workingCopy}).searchAllMethodNames(
+				"p478042".toCharArray(), SearchPattern.R_EXACT_MATCH, //package
+				"AllMethod".toCharArray(), SearchPattern.R_PREFIX_MATCH,  // declaring Qualification
+				"Nested".toCharArray(), SearchPattern.R_EXACT_MATCH, // declaring SimpleType
+				"foo".toCharArray(), SearchPattern.R_PREFIX_MATCH, 
+				scope, requestor, 
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
+		assertSearchResults(
+				"/JavaSearch/src/wc/X.java char p478042.AllMethodDeclarations01.Nested.foo03(Object o,String s)\n" + 
+				"/JavaSearch/src/wc/X.java int p478042.AllMethodDeclarations01.Nested.foo02(Object o)\n" + 
+				"/JavaSearch/src/wc/X.java void p478042.AllMethodDeclarations01.Nested.foo01()",
+				requestor
+		);
+	}
+	/*
+	 * Search all method names in working copies test (without reconciling working copies).
+	 */
+	public void testBug478042_dirtyWC_003() throws CoreException {
+		this.workingCopy.getBuffer().setContents(
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"public class Nested {\n" +
+				"public class Inner {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return 0;}\n" +
+				"  public char foo03(Object o, String s) {return '0';}\n" +
+				"}\n" +
+				"}\n" +
+				"}\n"
+		);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {this.workingCopy.getParent()});
+		SearchTests.SearchMethodNameRequestor requestor = new SearchTests.SearchMethodNameRequestor();
+		new SearchEngine(new ICompilationUnit[] {this.workingCopy}).searchAllMethodNames(
+				"p478042".toCharArray(), SearchPattern.R_EXACT_MATCH, //package
+				"AllMethod".toCharArray(), SearchPattern.R_PREFIX_MATCH,  // declaring Qualification
+				"Inner".toCharArray(), SearchPattern.R_EXACT_MATCH, // declaring SimpleType
+				"foo".toCharArray(), SearchPattern.R_PREFIX_MATCH, 
+				scope, requestor, 
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
+		assertSearchResults(
+				"/JavaSearch/src/wc/X.java char p478042.AllMethodDeclarations01.Nested.Inner.foo03(Object o,String s)\n" + 
+				"/JavaSearch/src/wc/X.java int p478042.AllMethodDeclarations01.Nested.Inner.foo02(Object o)\n" + 
+				"/JavaSearch/src/wc/X.java void p478042.AllMethodDeclarations01.Nested.Inner.foo01()",
+				requestor
+		);
+	}
+	/*
+	 * Search all method names in working copies test (without reconciling working copies).
+	 */
+	public void testBug478042_dirtyWC_004() throws CoreException {
+		this.workingCopy.getBuffer().setContents(
+				"package p478042;\n" +
+				"public class AllMethodDeclarations01 {\n" +
+				"  public void foo01() {}\n" +
+				"  public int foo02(Object o) {return 0;}\n" +
+				"  public char foo03(Object o, String s) {return '0';}\n" +
+				"}\n"
+		);
+		IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {this.workingCopy.getParent()});
+		SearchTests.SearchMethodNameRequestor requestor = new SearchTests.SearchMethodNameRequestor();
+		new SearchEngine(new ICompilationUnit[] {this.workingCopy}).searchAllMethodNames(
+				"p478042".toCharArray(), SearchPattern.R_EXACT_MATCH, //package
+				null, SearchPattern.R_EXACT_MATCH,  // declaring Qualification
+				"AllMethod".toCharArray(), SearchPattern.R_PREFIX_MATCH, // declaring SimpleType
+				"foo".toCharArray(), SearchPattern.R_PREFIX_MATCH, 
+				scope, requestor, 
+				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);
+		assertSearchResults(
+				"/JavaSearch/src/wc/X.java char p478042.AllMethodDeclarations01.foo03(Object o,String s)\n" + 
+				"/JavaSearch/src/wc/X.java int p478042.AllMethodDeclarations01.foo02(Object o)\n" + 
+				"/JavaSearch/src/wc/X.java void p478042.AllMethodDeclarations01.foo01()",
+				requestor
+		);
+	}
 
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
index 78bf310..126ffac 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -95,6 +95,7 @@ public interface ISourceElementRequestor {
 		public int extraFlags;
 		public AbstractMethodDeclaration node;
 		public ParameterInfo[] parameterInfos;
+		public TypeDeclaration enclosingType;
 	}
 
 	public static class ParameterInfo {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
index d7791d8..6e69956 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2013 IBM Corporation and others.
+ * Copyright (c) 2008, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -367,6 +367,8 @@ protected void notifySourceElementRequestor(AbstractMethodDeclaration methodDecl
 		methodInfo.categories = (char[][]) this.nodesToCategories.get(methodDeclaration);
 		methodInfo.annotations = methodDeclaration.annotations;
 		methodInfo.node = methodDeclaration;
+		methodInfo.enclosingType = declaringType;
+		methodInfo.declaringPackageName = currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(currentPackage.tokens, '.');
 		this.requestor.enterMethod(methodInfo);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatch.java
new file mode 100644
index 0000000..2b37f01
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatch.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.search;
+
+import org.eclipse.jdt.core.IAccessRule;
+import org.eclipse.jdt.core.IMethod;
+
+/**
+ * A match collected while {@link SearchEngine searching} for
+ * all type names methods using a {@link MethodNameRequestor requestor}.
+ * <p>
+ * The method of this match is available from {@link #getMethod()}.
+ * </p>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ *
+ * @see MethodNameMatchRequestor
+ * @see SearchEngine#searchAllMethodNames(char[], int, char[], int, char[], int, char[], int, IJavaSearchScope, MethodNameMatchRequestor, int, org.eclipse.core.runtime.IProgressMonitor)
+ * @since 3.12
+ */
+public abstract class MethodNameMatch {
+
+	/**
+	 * Returns the accessibility of the declaring type of the method name match
+	 *
+	 * @see IAccessRule
+	 *
+	 * @return the accessibility of the declaring type of the method name which may be
+	 * 		{@link IAccessRule#K_ACCESSIBLE}, {@link IAccessRule#K_DISCOURAGED}
+	 * 		or {@link IAccessRule#K_NON_ACCESSIBLE}.
+	 * 		The default returned value is {@link IAccessRule#K_ACCESSIBLE}.
+	 *
+	 */
+	public abstract int getAccessibility();
+
+	/**
+	 * Returns the modifiers of the matched method.
+	 * <p>
+	 * This is a handle-only method as neither Java Model nor classpath
+	 * initialization is done while calling this method.
+	 *
+	 * @return the type modifiers
+	 */
+	public abstract int getModifiers();
+
+	/**
+	 * Returns a java model method handle.
+	 * This handle may exist or not, but is not supposed to be <code>null</code>.
+	 * <p>
+	 * This is a handle-only method as neither Java Model nor classpath
+	 * initializations are done while calling this method.
+	 *
+	 * @see IMethod
+	 * @return the non-null handle on matched java model method.
+	 */
+	public abstract IMethod getMethod();
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatchRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatchRequestor.java
new file mode 100644
index 0000000..b43957a
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameMatchRequestor.java
@@ -0,0 +1,54 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.search;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+
+/**
+ * A <code>MethodNameMatchRequestor</code> collects matches from a <code>searchAllMethodNames</code>
+ * query to a <code>SearchEngine</code>. Clients must subclass this abstract class and pass an instance to the
+ * {@link SearchEngine#searchAllMethodNames(
+ * char[] packageName,
+ * int pkgMatchRule,
+ * char[] declaringQualification,
+ * int declQualificationMatchRule,
+ * char[] delcaringSimpleName,
+ * int declSimpleNameMatchRule,
+ * char[] methodName,
+ * int methodMatchRule,
+ * IJavaSearchScope scope,
+ * MethodNameMatchRequestor methodRequestor,
+ * int waitingPolicy,
+ * IProgressMonitor progressMonitor)} method.
+ * <p>
+ * While {@link MethodNameRequestor} only reports method names information (e.g. package, enclosing types, method name, modifiers, etc.),
+ * this class reports {@link MethodNameMatch} objects instead, which store this information and can return
+ * an {@link org.eclipse.jdt.core.IMethod} handle.
+ * </p>
+ * <p>
+ * This class may be subclassed by clients.
+ * </p>
+ * @see MethodNameMatch
+ * @see MethodNameRequestor
+ *
+ * @since 3.12
+ */
+public abstract class MethodNameMatchRequestor {
+
+	/**
+	 * Accepts a method name match ({@link MethodNameMatch}) which contains a method
+	 * information as package name, enclosing types names, method name, modifiers, etc.
+	 *
+	 * @param match the match which contains all method information
+	 */
+	public abstract void acceptMethodNameMatch(MethodNameMatch match);
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameRequestor.java
new file mode 100644
index 0000000..03ab216
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/MethodNameRequestor.java
@@ -0,0 +1,70 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.search;
+
+ /**
+  * 
+  * A <code> MethodDeclarationRequestor</code> collects search results from a <code> searchAllMethodDeclarations</code>
+  * query to a <code>SearchEngine</code>. Clients must subclass this abstract class and pass an instance to the
+  * <code>SearchEngine.searchAllMethodDeclarations</code> method. 
+  * 
+  * <p>
+  * This class may be subclassed by clients
+  * </p>
+ * @since 3.12
+  * 
+  */
+public abstract class MethodNameRequestor {
+	
+	/**
+	 * Accepts a method.
+	 * 
+	 * <p>
+	 * The default implementation of this method does nothing. 
+	 * Subclasses should override.
+	 * </p>
+	 * 
+	 * @param methodName name of the method.
+	 * @param parameterCount number of parameters in this method.
+	 * @param declaringQualifier the qualified name of parent of the enclosing type of this method.
+	 * @param simpleTypeName name of the enclosing type of this method.
+	 * @param typeModifiers modifiers of the type
+	 * @param packageName the package name as specified in the package declaration (i.e. a dot-separated name).
+	 * @param signature signature of the method - this would be null for methods in source files.
+	 * @param parameterTypes types of all the parameters.
+	 * @param parameterNames names of all the parameters.
+	 * @param returnType return type of the method.
+	 * @param modifiers modifiers of the method.
+	 * @param path the full path to the resource containing the type. If the resource is a .class file
+	 *          or a source file, this is the full path in the workspace to this resource. If the
+	 *          resource is an archive (that is, a .zip or .jar file), the path is composed of 2 paths separated
+	 *		 	 by <code>IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR</code>:
+	 *			 the first path is the full OS path to the archive (if it is an external archive),
+	 *			 or the workspace relative <code>IPath</code> to the archive (if it is an internal archive),
+	 * 		 the second path is the path to the resource inside the archive.
+	 */
+	public void acceptMethod(
+			char[] methodName,
+			int parameterCount,
+			char[] declaringQualifier,
+			char[] simpleTypeName,
+			int typeModifiers,
+			char[] packageName,
+			char[] signature,
+			char[][] parameterTypes,
+			char[][] parameterNames,
+			char[] returnType,
+			int modifiers,
+			String path,
+			int methodIndex) {
+		//do nothing
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
index 586cd89..e28b2d2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
@@ -585,6 +585,115 @@ public class SearchEngine {
 	}
 
 	/**
+	 * Searches for all method declarations in the given scope. Accepted matches will be returned by
+	 * {@link MethodNameRequestor#acceptMethod}
+	 * 
+	 * @param packageName the full name of the package of the searched types, or a prefix for this
+	 *						package, or a wild-carded string for this package.
+	 *						May be <code>null</code>, then any package name is accepted.
+	 * @param pkgMatchRule match rule for package.
+	 * @param declaringQualification Qualification of the declaring type.
+	 * @param declQualificationMatchRule match rule for declaring qualifier of parent of the type.
+	 * @param declaringSimpleName simple name of the declaring type.
+	 * @param declSimpleNameMatchRule match rule for the simple name of the enclosing type.
+	 * @param methodName the method name searched for.
+	 * @param methodMatchRule match rule for the method name.
+	 * @param scope the scope to search in
+	 * @param nameRequestor the requestor that collects the results of the search.
+	 * @param waitingPolicy one of
+	 * <ul>
+	 *		<li>{@link IJavaSearchConstants#FORCE_IMMEDIATE_SEARCH} if the search should start immediately</li>
+	 *		<li>{@link IJavaSearchConstants#CANCEL_IF_NOT_READY_TO_SEARCH} if the search should be cancelled if the
+	 *			underlying indexer has not finished indexing the workspace</li>
+	 *		<li>{@link IJavaSearchConstants#WAIT_UNTIL_READY_TO_SEARCH} if the search should wait for the
+	 *			underlying indexer to finish indexing the workspace</li>
+	 * </ul>
+	 * @param progressMonitor the progress monitor to report progress to, or <code>null</code> if no progress
+	 *							monitor is provided
+	 * @exception JavaModelException if the search failed.
+	 * 
+	 * @since 3.12
+	 */
+	public void searchAllMethodNames(
+			final char[] packageName,
+			final int pkgMatchRule,
+			final char[] declaringQualification,
+			final int declQualificationMatchRule,
+			final char[] declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			final char[] methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameRequestor nameRequestor,
+			int waitingPolicy,
+			IProgressMonitor progressMonitor)  throws JavaModelException {
+		MethodNameRequestorWrapper requestorWrapper = new MethodNameRequestorWrapper(nameRequestor);
+		this.basicEngine.searchAllMethodNames(
+				packageName, pkgMatchRule, 
+				declaringQualification, declQualificationMatchRule, 
+				declaringSimpleName, declSimpleNameMatchRule, 
+				methodName, methodMatchRule, 
+				scope, requestorWrapper, 
+				waitingPolicy, progressMonitor);
+	}
+
+	/**
+	 * Searches for all method declarations in the given scope. 
+	 * <p>
+	 * Provided {@link MethodNameMatchRequestor} requestor will collect the {@link MethodNameMatch}
+	 * matches found during the search.
+	 * </p>
+	 * 
+	 * @param packageName the full name of the package of the searched types, or a prefix for this
+	 *						package, or a wild-carded string for this package.
+	 *						May be <code>null</code>, then any package name is accepted.
+	 * @param pkgMatchRule match rule for package.
+	 * @param declaringQualification Qualification of the declaring type.
+	 * @param declQualificationMatchRule match rule for declaring qualifier of parent of the type.
+	 * @param declaringSimpleName simple name of the declaring type.
+	 * @param declSimpleNameMatchRule match rule for the simple name of the enclosing type.
+	 * @param methodName the method name searched for.
+	 * @param methodMatchRule match rule for the method name.
+	 * @param scope the scope to search in
+	 * @param nameRequestor the {@link MethodNameMatchRequestor}
+	 * @param waitingPolicy one of
+	 * <ul>
+	 *		<li>{@link IJavaSearchConstants#FORCE_IMMEDIATE_SEARCH} if the search should start immediately</li>
+	 *		<li>{@link IJavaSearchConstants#CANCEL_IF_NOT_READY_TO_SEARCH} if the search should be cancelled if the
+	 *			underlying indexer has not finished indexing the workspace</li>
+	 *		<li>{@link IJavaSearchConstants#WAIT_UNTIL_READY_TO_SEARCH} if the search should wait for the
+	 *			underlying indexer to finish indexing the workspace</li>
+	 * </ul>
+	 * @param progressMonitor the progress monitor to report progress to, or <code>null</code> if no progress
+	 *							monitor is provided
+	 * @exception JavaModelException if the search failed.
+	 * 
+	 * @since 3.12
+	 */
+	public void searchAllMethodNames(
+			final char[] packageName,
+			final int pkgMatchRule,
+			final char[] declaringQualification,
+			final int declQualificationMatchRule,
+			final char[] declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			final char[] methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final MethodNameMatchRequestor nameRequestor,
+			int waitingPolicy,
+			IProgressMonitor progressMonitor)  throws JavaModelException {
+		MethodNameMatchRequestorWrapper requestorWrapper = new MethodNameMatchRequestorWrapper(nameRequestor, scope);
+		this.basicEngine.searchAllMethodNames(
+				packageName, pkgMatchRule,
+				declaringQualification, declQualificationMatchRule,
+				declaringSimpleName, declSimpleNameMatchRule,
+				methodName, methodMatchRule,
+				scope, requestorWrapper, 
+				waitingPolicy, progressMonitor);
+	}
+
+	/**
 	 * Searches for all top-level types and member types in the given scope.
 	 * The search can be selecting specific types (given a package exact full name or
 	 * a type name with specific match mode).
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
index 43ca37e..8e799d6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -46,7 +46,7 @@ private int bufferIndex, bufferEnd; // used when reading from the file into the
 private int streamEnd; // used when writing data from the streamBuffer to the file
 char separator = Index.DEFAULT_SEPARATOR;
 
-public static final String SIGNATURE= "INDEX VERSION 1.127"; //$NON-NLS-1$
+public static final String SIGNATURE= "INDEX VERSION 1.128"; //$NON-NLS-1$
 private static final char[] SIGNATURE_CHARS = SIGNATURE.toCharArray();
 public static boolean DEBUG = false;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
index fa43a28..f447138 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
@@ -501,6 +501,52 @@ public class BasicSearchEngine {
 
 	}
 
+boolean match(char[] patternName, int matchRule, char[] name) {
+		boolean isCaseSensitive = (matchRule & SearchPattern.R_CASE_SENSITIVE) != 0;
+		if (patternName != null) {
+			boolean isCamelCase = (matchRule & (SearchPattern.R_CAMELCASE_MATCH | SearchPattern.R_CAMELCASE_SAME_PART_COUNT_MATCH)) != 0;
+			int matchMode = matchRule & JavaSearchPattern.MATCH_MODE_MASK;
+			if (!isCaseSensitive && !isCamelCase) {
+				patternName = CharOperation.toLowerCase(patternName);
+			}
+			boolean matchFirstChar = !isCaseSensitive || patternName[0] == name[0];
+			switch(matchMode) {
+				case SearchPattern.R_EXACT_MATCH :
+					return matchFirstChar && CharOperation.equals(patternName, name, isCaseSensitive);
+				case SearchPattern.R_PREFIX_MATCH :
+					return matchFirstChar && CharOperation.prefixEquals(patternName, name, isCaseSensitive);
+				case SearchPattern.R_PATTERN_MATCH :
+					return CharOperation.match(patternName, name, isCaseSensitive);
+				case SearchPattern.R_REGEXP_MATCH :
+					// TODO implement regular expression match
+					break;
+				case SearchPattern.R_CAMELCASE_MATCH:
+					if (matchFirstChar && CharOperation.camelCaseMatch(patternName, name, false)) {
+						return true;
+					}
+					return !isCaseSensitive && matchFirstChar && CharOperation.prefixEquals(patternName, name, false);
+				case SearchPattern.R_CAMELCASE_SAME_PART_COUNT_MATCH:
+					return matchFirstChar && CharOperation.camelCaseMatch(patternName, name, true);
+			}
+		}
+		return true;		
+	}
+
+	boolean match(char[] patternPkg, int matchRulePkg, 
+			char[] patternDeclaringQualifier, int matchRuleDeclaringQualifier,
+			char[] patternDeclaringSimpleName, int matchRuleDeclaringSimpleName,
+			char[] patternMethodName, int methodMatchRule, 
+			char[] packageName, char[] declaringQualifier, char[] declaringSimpleName, char[] methodName) {
+		
+		if (patternPkg != null && !CharOperation.equals(patternPkg, packageName, (matchRulePkg & SearchPattern.R_CASE_SENSITIVE) != 0))
+			return false;
+		
+		return match(patternDeclaringQualifier, matchRuleDeclaringQualifier, declaringQualifier) &&
+				match(patternDeclaringSimpleName, matchRuleDeclaringSimpleName, declaringSimpleName) &&
+				match(patternMethodName, methodMatchRule, methodName);
+		
+	}
+	
 	/**
 	 * Searches for matches of a given search pattern. Search patterns can be created using helper
 	 * methods (from a String pattern or a Java element) and encapsulate the description of what is
@@ -852,6 +898,370 @@ public class BasicSearchEngine {
 		}
 	}
 
+	public void searchAllMethodNames(
+			final char[] packageName,
+			final int pkgMatchRule,
+			final char[] declaringQualification,
+			final int declQualificationMatchRule,
+			final char[] declaringSimpleName,
+			final int declSimpleNameMatchRule,
+			final char[] methodName,
+			final int methodMatchRule,
+			IJavaSearchScope scope,
+			final IRestrictedAccessMethodRequestor nameRequestor,
+			int waitingPolicy,
+			IProgressMonitor progressMonitor)  throws JavaModelException {
+
+			// Validate match rule first
+			final int validatedMethodMatchRule = SearchPattern.validateMatchRule(methodName == null ? null : new String (methodName), methodMatchRule);
+			// Debug
+			if (VERBOSE) {
+				Util.verbose("BasicSearchEngine.searchAllMethodDeclarations(char[] packageName, char[] declaringQualification, char[] declaringSimpleName, "//$NON-NLS-1$
+						+ "char[] methodName, int methodMatchRule, IJavaSearchScope, IRestrictedAccessConstructorRequestor, int waitingPolicy, IProgressMonitor)"); //$NON-NLS-1$
+				Util.verbose("	- package name: "+(packageName==null?"null":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- declaringQualification name: "+(declaringQualification==null?"null":new String(declaringQualification))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- declaringSimple name: "+(declaringSimpleName==null?"null":new String(declaringSimpleName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- method name: "+(methodName==null?"null":new String(methodName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- method match rule: "+getMatchRuleString(methodMatchRule)); //$NON-NLS-1$
+				if (validatedMethodMatchRule != methodMatchRule) {
+					Util.verbose("	- validated method match rule: "+getMatchRuleString(validatedMethodMatchRule)); //$NON-NLS-1$
+				}
+				Util.verbose("	- scope: "+scope); //$NON-NLS-1$
+			}
+			if (validatedMethodMatchRule == -1) return; // invalid match rule => return no results
+
+			// Create pattern
+			IndexManager indexManager = JavaModelManager.getIndexManager();
+			final MethodDeclarationPattern pattern = new MethodDeclarationPattern(packageName, declaringQualification, declaringSimpleName, methodName, methodMatchRule);
+
+			// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
+			final HashSet workingCopyPaths = new HashSet();
+			String workingCopyPath = null;
+			ICompilationUnit[] copies = getWorkingCopies();
+			final int copiesLength = copies == null ? 0 : copies.length;
+			if (copies != null) {
+				if (copiesLength == 1) {
+					workingCopyPath = copies[0].getPath().toString();
+				} else {
+					for (int i = 0; i < copiesLength; i++) {
+						ICompilationUnit workingCopy = copies[i];
+						workingCopyPaths.add(workingCopy.getPath().toString());
+					}
+				}
+			}
+			final String singleWkcpPath = workingCopyPath;
+
+			// Index requestor
+			IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
+				public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
+					MethodDeclarationPattern record = (MethodDeclarationPattern)indexRecord;
+					
+					if ((record.extraFlags & ExtraFlags.IsLocalType) != 0) {
+						return true; // filter out local and anonymous classes
+					}
+					switch (copiesLength) {
+						case 0:
+							break;
+						case 1:
+							if (singleWkcpPath.equals(documentPath)) {
+								return true; // filter out *the* working copy
+							}
+							break;
+						default:
+							if (workingCopyPaths.contains(documentPath)) {
+								return true; // filter out working copies
+							}
+							break;
+					}
+
+					// Accept document path
+					AccessRestriction accessRestriction = null;
+					if (access != null) {
+						// Compute document relative path
+						int pkgLength = (record.declaringPackageName==null || record.declaringPackageName.length==0) ? 0 : record.declaringPackageName.length+1;
+						int qualificationLength = (record.declaringQualification == null || record.declaringQualification.length == 0) ? 0 : record.declaringQualification.length;
+						int nameLength = record.declaringSimpleName==null ? 0 : record.declaringSimpleName.length;
+						char[] path = new char[pkgLength + qualificationLength + nameLength];
+						int pos = 0;
+						if (pkgLength > 0) {
+							System.arraycopy(record.declaringPackageName, 0, path, pos, pkgLength-1);
+							CharOperation.replace(path, '.', '/');
+							path[pkgLength-1] = '/';
+							pos += pkgLength;
+						}
+						if (qualificationLength > 0) {
+							System.arraycopy(record.declaringQualification, 0, path, pos, qualificationLength);
+						}
+						if (nameLength > 0) {
+							System.arraycopy(record.declaringSimpleName, 0, path, pos, nameLength);
+							pos += nameLength;
+						}
+						// Update access restriction if path is not empty
+						if (pos > 0) {
+							accessRestriction = access.getViolatedRestriction(path);
+						}
+					}
+					if (match(packageName, pkgMatchRule, declaringQualification, declQualificationMatchRule, declaringSimpleName, declSimpleNameMatchRule, methodName, methodMatchRule, 
+							record.declaringPackageName, record.declaringQualification, record.declaringSimpleName, record.selector)) {
+						nameRequestor.acceptMethod(
+								record.selector, 
+								record.parameterCount,
+								record.declaringQualification,
+								record.declaringSimpleName, 
+								record.declaringTypeModifiers, 
+								record.declaringPackageName,
+								record.signature, 
+								record.parameterTypes, 
+								record.parameterNames,
+								record.returnSimpleName,
+								record.modifiers, 
+								documentPath, 
+								accessRestriction,
+								-1 /* method index not applicable as there is no IType here */);
+					}
+					return true;
+				}
+			};
+
+			try {
+				if (progressMonitor != null) {
+					progressMonitor.beginTask(Messages.engine_searching, 1000);
+				}
+				// add type names from indexes
+				indexManager.performConcurrentJob(
+					new PatternSearchJob(
+						pattern,
+						getDefaultSearchParticipant(), // Java search only
+						scope,
+						searchRequestor),
+					waitingPolicy,
+					progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
+
+				// add type names from working copies
+				if (copies != null) {
+					boolean isPkgCaseSensitive = (pkgMatchRule & SearchPattern.R_CASE_SENSITIVE) != 0; 
+					for (int i = 0; i < copiesLength; i++) {
+						final ICompilationUnit workingCopy = copies[i];
+						if (scope instanceof HierarchyScope) {
+							if (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;
+						} else {
+							if (!scope.encloses(workingCopy)) continue;
+						}
+
+						final String path = workingCopy.getPath().toString();
+						if (workingCopy.isConsistent()) {
+							IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+							char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+							if (packageName != null && !CharOperation.equals(packageName, packageDeclaration, isPkgCaseSensitive))
+								continue;
+							
+							IType[] allTypes = workingCopy.getAllTypes();
+							for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+								IType type = allTypes[j];
+								IJavaElement parent = type.getParent();
+								char[] rDeclaringQualification = parent instanceof IType ? ((IType) parent).getTypeQualifiedName('.').toCharArray() : CharOperation.NO_CHAR;
+								char[] rSimpleName = type.getElementName().toCharArray();
+								if (!match(declaringQualification, declQualificationMatchRule, rDeclaringQualification) ||
+										!match(declaringSimpleName, declSimpleNameMatchRule, rSimpleName))
+									continue;
+								reportMatchingMethods(methodName, methodMatchRule, nameRequestor, path,
+										packageDeclaration, type, rDeclaringQualification, rSimpleName); 
+							}
+						} else {
+							Parser basicParser = getParser();
+							org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+							CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+							CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+							if (parsedUnit != null) {
+								final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+								class AllMethodDeclarationVisitor extends ASTVisitor {
+
+									class TypeInfo {
+										public TypeDeclaration typeDecl;
+										public IType type;
+										public boolean visitMethods;
+										public char[] enclosingTypeName;
+										
+										TypeInfo(TypeDeclaration typeDecl, boolean visitMethods, char[] enclosingTypeName) {
+											this.typeDecl = typeDecl;
+											this.type = workingCopy.getType(new String(typeDecl.name));
+											this.visitMethods = visitMethods;
+											this.enclosingTypeName = enclosingTypeName;
+										}
+									}
+									Stack<TypeInfo> typeInfoStack = new Stack<>();
+									IType getCurrentType() {
+										int l = this.typeInfoStack.size();
+										if (l <= 0) return null;
+										TypeInfo typeInfo = this.typeInfoStack.get(0);
+										IType type = typeInfo.type;
+										if (type == null) {
+											TypeInfo ti = this.typeInfoStack.get(0);
+											ti.type = ti.type == null ? workingCopy.getType(new String(ti.typeDecl.name)) : ti.type;
+											type = ti.type;
+											for (int j = 1; j < l && type != null; ++j) {
+												ti = this.typeInfoStack.get(j);
+												if (ti.type == null) {
+													ti.type = type.getType(new String(ti.typeDecl.name));
+												}
+												type = ti.type;
+											}
+										}
+										return type;
+									}
+
+									private void addStackEntry(TypeDeclaration typeDeclaration, char[] enclosingTypeName) {
+										boolean visitMethods = match(declaringQualification, declQualificationMatchRule, enclosingTypeName) &&
+												match(declaringSimpleName, declSimpleNameMatchRule, typeDeclaration.name);
+										this.typeInfoStack.push(new TypeInfo(typeDeclaration, visitMethods, enclosingTypeName));
+									}
+									public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+										this.typeInfoStack.pop();
+									}
+									public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+										this.typeInfoStack.pop();
+									}
+									public boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {
+										TypeInfo typeInfo = this.typeInfoStack.peek();
+										if (typeInfo.visitMethods &&
+											match(methodName, methodMatchRule, methodDeclaration.selector)) {
+											reportMatchingMethod(path, packageDeclaration,
+													typeInfo.enclosingTypeName, 
+													typeInfo.typeDecl, 
+													methodDeclaration,
+													getCurrentType(),
+													nameRequestor);
+										}
+										
+										return false; // no need to find methods from local/anonymous type
+									}
+									public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+										return false; // do not visit local/anonymous types
+									}
+									public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+										addStackEntry(typeDeclaration, CharOperation.NO_CHAR);
+										return true;
+									}
+									public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+										TypeInfo typeInfo = this.typeInfoStack.peek();
+										addStackEntry(memberTypeDeclaration, typeInfo.enclosingTypeName == CharOperation.NO_CHAR ? typeInfo.typeDecl.name :
+												CharOperation.concat(typeInfo.enclosingTypeName, typeInfo.typeDecl.name, '.'));
+										return true;
+									}
+								}
+								if (match(packageName, pkgMatchRule, packageDeclaration))
+									parsedUnit.traverse(new AllMethodDeclarationVisitor(), parsedUnit.scope);
+							}
+						}
+						if (progressMonitor != null) {
+							if (progressMonitor.isCanceled()) throw new OperationCanceledException();
+							progressMonitor.worked(1);
+						}
+					}
+				}
+			} finally {
+				if (progressMonitor != null) {
+					progressMonitor.done();
+				}
+			}
+		}
+
+	void reportMatchingMethod(
+			final String path,
+			final char[] packageDeclaration,
+			final char[] declaringQualifier,
+			final TypeDeclaration typeDeclaration, 
+			final MethodDeclaration methodDeclaration,
+			final IType type,
+			final IRestrictedAccessMethodRequestor nameRequestor) {
+
+		Argument[] arguments = methodDeclaration.arguments;
+		int argsLength = 0;
+		char[][] parameterTypes = CharOperation.NO_CHAR_CHAR;
+		char[][] parameterNames = CharOperation.NO_CHAR_CHAR;
+		if (arguments != null) {
+			argsLength = arguments.length;
+			parameterTypes = new char[argsLength][];
+			parameterNames = new char[argsLength][];
+		}
+		for (int i = 0; i < argsLength; ++i) {
+			Argument argument = arguments[i];
+			parameterNames[i] = argument.name;
+			parameterTypes[i] = CharOperation.concatWith(argument.type.getTypeName(), '.');
+		}
+		if (nameRequestor instanceof MethodNameMatchRequestorWrapper) {
+			IMethod method = type.getMethod(new String(methodDeclaration.selector), CharOperation.toStrings(parameterTypes));
+			((MethodNameMatchRequestorWrapper)nameRequestor).requestor.acceptMethodNameMatch(new JavaSearchMethodNameMatch(method, methodDeclaration.modifiers));
+		} else {
+			char[] returnType = CharOperation.toString(methodDeclaration.returnType.getTypeName()).toCharArray();
+			nameRequestor.acceptMethod(
+					methodDeclaration.selector, 
+					argsLength, 
+					declaringQualifier, 
+					typeDeclaration.name, 
+					typeDeclaration.modifiers, 
+					packageDeclaration, 
+					null, 
+					parameterTypes, 
+					parameterNames, 
+					returnType, 
+					methodDeclaration.modifiers, 
+					path, 
+					null, 
+					-1 /* method index */);
+		}
+	}
+	void reportMatchingMethods(final char[] methodName, final int methodMatchRule,
+			final IRestrictedAccessMethodRequestor nameRequestor, final String path, char[] packageDeclaration,
+			IType type, char[] rDeclaringQualification, char[] rSimpleName)
+					throws JavaModelException {
+		IMethod[] methods = type.getMethods();
+		
+		for (int k = 0; k < methods.length; k++) {
+			IMethod method = methods[k];
+			if (method.isConstructor()) continue;
+			
+			char[] rMethodName = method.getElementName().toCharArray();
+			if (match(methodName, methodMatchRule, rMethodName)) {
+				if (nameRequestor instanceof MethodNameMatchRequestorWrapper) {
+					((MethodNameMatchRequestorWrapper) nameRequestor).requestor.acceptMethodNameMatch(new JavaSearchMethodNameMatch(method, method.getFlags()));
+				} else {
+
+					String[] stringParameterNames = method.getParameterNames();
+					String[] stringParameterTypes = method.getParameterTypes();
+					int length = stringParameterNames.length;
+					char[][] parameterNames = new char[length][];
+					char[][] parameterTypes = new char[length][];
+					for (int l = 0; l < length; l++) {
+						parameterNames[l] = stringParameterNames[l].toCharArray();
+						parameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());
+					}
+					String returnSignature = method.getReturnType();
+					char[] signature = returnSignature.toCharArray();
+					char[] returnErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
+					CharOperation.replace(returnErasure, '$', '.');
+					char[] returnTypeName =  returnErasure;
+					
+					nameRequestor.acceptMethod(
+							rMethodName, 
+							parameterNames.length, 
+							rDeclaringQualification, 
+							rSimpleName, 
+							type.getFlags(),
+							packageDeclaration, 
+							null, // signature not used for source 
+							parameterTypes, 
+							parameterNames, 
+							returnTypeName, 
+							method.getFlags(), 
+							path, 
+							null,
+							k);
+				}
+			}
+		}
+	}
+
 	/**
 	 * Searches for all secondary types in the given scope.
 	 * The search can be selecting specific types (given a package or a type name
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IRestrictedAccessMethodRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IRestrictedAccessMethodRequestor.java
new file mode 100644
index 0000000..d2db695
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IRestrictedAccessMethodRequestor.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search;
+
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+
+/**
+ * A <code>IRestrictedAccessMethodRequestor</code> collects search results from a <code>searchAllMethodDeclarations</code>
+ * query to a <code>SearchBasicEngine</code> providing restricted access information of declaring type when a method is accepted.
+ */
+public interface IRestrictedAccessMethodRequestor {
+
+	public void acceptMethod(
+			char[] methodName,
+			int parameterCount,
+			char[] declaringQualification,
+			char[] simpleTypeName,
+			int typeModifiers,
+			char[] packageName,
+			char[] signature,
+			char[][] parameterTypes,
+			char[][] parameterNames,
+			char[] returnType,
+			int modifiers,
+			String path,
+			AccessRestriction access,
+			int methodIndex);
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchMethodNameMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchMethodNameMatch.java
new file mode 100644
index 0000000..a934296
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchMethodNameMatch.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search;
+
+import org.eclipse.jdt.core.IAccessRule;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.search.MethodNameMatch;
+
+/**
+ * Java Search concrete class for a method name match.
+ *
+ */
+public class JavaSearchMethodNameMatch extends MethodNameMatch {
+	
+	IMethod method = null;
+	int modifiers = -1;
+	
+	private int accessibility = IAccessRule.K_ACCESSIBLE; // TODO: this pertains to class/type - need to revisit whether this is required in method name match
+	public JavaSearchMethodNameMatch(IMethod method, int modifiers) {
+		this.method = method;
+		this.modifiers = modifiers;
+	}
+
+	@Override
+	public int getAccessibility() {
+		return this.accessibility;
+	}
+
+	@Override
+	public int getModifiers() {
+		return this.modifiers;
+	}
+
+	@Override
+	public IMethod getMethod() {
+		return this.method;
+	}
+	
+	public void setAccessibility(int accessibility) {
+		this.accessibility = accessibility;
+	}
+	
+	public String toString() {
+		return this.method == null ? super.toString() : this.method.toString();
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameMatchRequestorWrapper.java
new file mode 100644
index 0000000..7d4b262
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameMatchRequestorWrapper.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.MethodNameMatchRequestor;
+import org.eclipse.jdt.core.search.MethodNameRequestor;
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+/**
+ * Wrapper used to link {@link IRestrictedAccessMethodRequestor} with {@link MethodNameRequestor}.
+ * This wrapper specifically allows usage of internal method {@link BasicSearchEngine#searchAllMethodNames(
+ * char[] packageName,
+ * int pkgMatchRule,
+ * char[] declaringQualification,
+ * int declQualificationMatchRule,
+ * char[] delcaringSimpleName,
+ * int declSimpleNameMatchRule,
+ * char[] methodName,
+ * int methodMatchRule,
+ * IJavaSearchScope scope,
+ * IRestrictedAccessMethodRequestor methodRequestor,
+ * int waitingPolicy,
+ * IProgressMonitor progressMonitor)} from  API method 
+ * {@link org.eclipse.jdt.core.search.SearchEngine#searchAllMethodNames(
+ * char[] packageName,
+ * int pkgMatchRule,
+ * char[] declaringQualification,
+ * int declQualificationMatchRule,
+ * char[] delcaringSimpleName,
+ * int declSimpleNameMatchRule,
+ * char[] methodName,
+ * int methodMatchRule,
+ * IJavaSearchScope scope,
+ * MethodNameRequestor methodRequestor,
+ * int waitingPolicy,
+ * IProgressMonitor progressMonitor)}.
+ */
+
+public class MethodNameMatchRequestorWrapper extends NameMatchRequestorWrapper implements IRestrictedAccessMethodRequestor {
+
+	MethodNameMatchRequestor requestor;
+
+	public MethodNameMatchRequestorWrapper(MethodNameMatchRequestor requestor, IJavaSearchScope scope) {
+		super(scope);
+		this.requestor = requestor;
+	}
+
+	@Override
+	public void acceptMethod(char[] methodName, int parameterCount, char[] declaringQualifier,
+			char[] simpleTypeName, int typeModifiers, char[] packageName, char[] signature, char[][] parameterTypes,
+			char[][] parameterNames, char[] returnType, int modifiers, String path,
+			AccessRestriction access, int methodIndex) {
+		// Get the type
+		char[][] enclosingTypeNames = declaringQualifier != null && declaringQualifier.length > 0 ? CharOperation.splitOn('.', declaringQualifier) : CharOperation.NO_CHAR_CHAR;
+		IType type = getType(typeModifiers, packageName, simpleTypeName, enclosingTypeNames, path, access);
+		if (type == null) return;
+		if (!(!(this.scope instanceof HierarchyScope) || ((HierarchyScope) this.scope).enclosesFineGrained(type))) return;
+		parameterTypes = parameterTypes == null ? CharOperation.NO_CHAR_CHAR : parameterTypes;
+		IMethod method = type.getMethod(new String(methodName), CharOperation.toStrings(parameterTypes));
+		this.requestor.acceptMethodNameMatch(new JavaSearchMethodNameMatch(method, modifiers));
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameRequestorWrapper.java
new file mode 100644
index 0000000..b031456
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/MethodNameRequestorWrapper.java
@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.MethodNameRequestor;
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+
+/**
+ * Wrapper used to linke {@link IRestrictedAccessMethodRequestor} with {@link MethodNameRequestor}.
+ * This wrapper specifically allows the usage of internal method {@link BasicSearchEngine#searchAllMethodNames(
+ * char[] packageName,
+ * int pkgMatchRule,
+ * char[] declaringQualification,
+ * int declQualificationMatchRule,
+ * char[] delcaringSimpleName,
+ * int declSimpleNameMatchRule,
+ * char[] methodName,
+ * int methodMatchRule,
+ * IJavaSearchScope scope,
+ * IRestrictedAccessMethodRequestor methodRequestor,
+ * int waitingPolicy,
+ * IProgressMonitor progressMonitor)} from API method
+ * {@link org.eclipse.jdt.core.search.SearchEngine#searchAllMethodNames(
+ * char[] packageName,
+ * int pkgMatchRule,
+ * char[] declaringQualification,
+ * int declQualificationMatchRule,
+ * char[] delcaringSimpleName,
+ * int declSimpleNameMatchRule,
+ * char[] methodName,
+ * int methodMatchRule,
+ * IJavaSearchScope scope,
+ * MethodNameRequestor methodRequestor,
+ * int waitingPolicy,
+ * IProgressMonitor progressMonitor)}.  
+ *
+ */
+public class MethodNameRequestorWrapper implements IRestrictedAccessMethodRequestor {
+	
+	MethodNameRequestor requestor;
+	
+	public MethodNameRequestorWrapper(MethodNameRequestor requestor) {
+		this.requestor = requestor;
+	}
+
+	@Override
+	public void acceptMethod(char[] methodName, int parameterCount, char[] declaringQualification,
+			char[] simpleTypeName, int typeModifiers, char[] packageName, char[] signature, char[][] parameterTypes,
+			char[][] parameterNames, char[] returnType, int modifiers, String path,
+			AccessRestriction access, int methodIndex) {
+		this.requestor.acceptMethod(methodName, parameterCount, declaringQualification, simpleTypeName, typeModifiers, 
+				packageName, signature, parameterTypes, parameterNames, returnType, modifiers, path, methodIndex);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
new file mode 100644
index 0000000..67f8083
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/NameMatchRequestorWrapper.java
@@ -0,0 +1,189 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 215139
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search;
+
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.core.Openable;
+import org.eclipse.jdt.internal.core.PackageFragmentRoot;
+import org.eclipse.jdt.internal.core.util.HandleFactory;
+import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
+
+/**
+ * Parent class for Type and Method NameMatchRequestor classes
+ */
+public abstract class NameMatchRequestorWrapper {
+	protected IJavaSearchScope scope; // scope is needed to retrieve project path for external resource
+	private HandleFactory handleFactory; // in case of IJavaSearchScope defined by clients, use an HandleFactory instead
+
+	/**
+	 * Cache package fragment root information to optimize speed performance.
+	 */
+	private String lastPkgFragmentRootPath;
+	private IPackageFragmentRoot lastPkgFragmentRoot;
+
+	/**
+	 * Cache package handles to optimize memory.
+	 */
+	private HashtableOfArrayToObject packageHandles;
+	private Object lastProject;
+	private long complianceValue;
+
+public NameMatchRequestorWrapper(IJavaSearchScope scope) {
+	this.scope = scope;
+	if (!(scope instanceof AbstractJavaSearchScope)) {
+		this.handleFactory = new HandleFactory();
+	}
+}
+
+/* (non-Javadoc)
+ * @see org.eclipse.jdt.internal.core.search.IRestrictedAccessTypeRequestor#acceptType(int, char[], char[], char[][], java.lang.String, org.eclipse.jdt.internal.compiler.env.AccessRestriction)
+ */
+public IType getType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access) {
+	IType type = null;
+	try {
+		if (this.handleFactory != null) {
+			Openable openable = this.handleFactory.createOpenable(path, this.scope);
+			if (openable == null) return type;
+			switch (openable.getElementType()) {
+				case IJavaElement.COMPILATION_UNIT:
+					ICompilationUnit cu = (ICompilationUnit) openable;
+					if (enclosingTypeNames != null && enclosingTypeNames.length > 0) {
+						type = cu.getType(new String(enclosingTypeNames[0]));
+						for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
+							type = type.getType(new String(enclosingTypeNames[j]));
+						}
+						type = type.getType(new String(simpleTypeName));
+					} else {
+						type = cu.getType(new String(simpleTypeName));
+					}
+					break;
+				case IJavaElement.CLASS_FILE:
+					type = ((IClassFile)openable).getType();
+					break;
+			}
+		} else {
+			int separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);
+			type = separatorIndex == -1
+				? createTypeFromPath(path, new String(simpleTypeName), enclosingTypeNames)
+				: createTypeFromJar(path, separatorIndex);
+		}
+	} catch (JavaModelException e) {
+		// skip
+	}
+	return type;
+}
+
+private IType createTypeFromJar(String resourcePath, int separatorIndex) throws JavaModelException {
+	// path to a class file inside a jar
+	// Optimization: cache package fragment root handle and package handles
+	if (this.lastPkgFragmentRootPath == null
+			|| this.lastPkgFragmentRootPath.length() > resourcePath.length()
+			|| !resourcePath.startsWith(this.lastPkgFragmentRootPath)) {
+		String jarPath= resourcePath.substring(0, separatorIndex);
+		IPackageFragmentRoot root= ((AbstractJavaSearchScope)this.scope).packageFragmentRoot(resourcePath, separatorIndex, jarPath);
+		if (root == null) return null;
+		this.lastPkgFragmentRootPath= jarPath;
+		this.lastPkgFragmentRoot= root;
+		this.packageHandles= new HashtableOfArrayToObject(5);
+	}
+	// create handle
+	String classFilePath= resourcePath.substring(separatorIndex + 1);
+	String[] simpleNames = new Path(classFilePath).segments();
+	String[] pkgName;
+	int length = simpleNames.length-1;
+	if (length > 0) {
+		pkgName = new String[length];
+		System.arraycopy(simpleNames, 0, pkgName, 0, length);
+	} else {
+		pkgName = CharOperation.NO_STRINGS;
+	}
+	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
+	if (pkgFragment == null) {
+		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);
+		// filter org.apache.commons.lang.enum package for projects above 1.5 
+		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=317264
+		if (length == 5 && pkgName[4].equals("enum")) { //$NON-NLS-1$
+			IJavaProject proj = (IJavaProject)pkgFragment.getAncestor(IJavaElement.JAVA_PROJECT);
+			if (!proj.equals(this.lastProject)) {
+				String complianceStr = proj.getOption(CompilerOptions.OPTION_Source, true);
+				this.complianceValue = CompilerOptions.versionToJdkLevel(complianceStr);
+				this.lastProject = proj;
+			}
+			if (this.complianceValue >= ClassFileConstants.JDK1_5)
+				return null;
+		} 
+		this.packageHandles.put(pkgName, pkgFragment);
+	}
+	return pkgFragment.getClassFile(simpleNames[length]).getType();
+}
+private IType createTypeFromPath(String resourcePath, String simpleTypeName, char[][] enclosingTypeNames) throws JavaModelException {
+	// path to a file in a directory
+	// Optimization: cache package fragment root handle and package handles
+	int rootPathLength = -1;
+	if (this.lastPkgFragmentRootPath == null
+		|| !(resourcePath.startsWith(this.lastPkgFragmentRootPath)
+			&& (rootPathLength = this.lastPkgFragmentRootPath.length()) > 0
+			&& resourcePath.charAt(rootPathLength) == '/')) {
+		PackageFragmentRoot root = (PackageFragmentRoot) ((AbstractJavaSearchScope)this.scope).packageFragmentRoot(resourcePath, -1/*not a jar*/, null/*no jar path*/);
+		if (root == null) return null;
+		this.lastPkgFragmentRoot = root;
+		this.lastPkgFragmentRootPath = root.internalPath().toString();
+		this.packageHandles = new HashtableOfArrayToObject(5);
+	}
+	// create handle
+	resourcePath = resourcePath.substring(this.lastPkgFragmentRootPath.length() + 1);
+	String[] simpleNames = new Path(resourcePath).segments();
+	String[] pkgName;
+	int length = simpleNames.length-1;
+	if (length > 0) {
+		pkgName = new String[length];
+		System.arraycopy(simpleNames, 0, pkgName, 0, length);
+	} else {
+		pkgName = CharOperation.NO_STRINGS;
+	}
+	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
+	if (pkgFragment == null) {
+		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);
+		this.packageHandles.put(pkgName, pkgFragment);
+	}
+	String simpleName= simpleNames[length];
+	if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(simpleName)) {
+		ICompilationUnit unit= pkgFragment.getCompilationUnit(simpleName);
+		int etnLength = enclosingTypeNames == null ? 0 : enclosingTypeNames.length;
+		IType type = (etnLength == 0) ? unit.getType(simpleTypeName) : unit.getType(new String(enclosingTypeNames[0]));
+		if (etnLength > 0) {
+			for (int i=1; i<etnLength; i++) {
+				type = type.getType(new String(enclosingTypeNames[i]));
+			}
+			type = type.getType(simpleTypeName);
+		}
+		return type;
+	} else if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(simpleName)){
+		IClassFile classFile= pkgFragment.getClassFile(simpleName);
+		return classFile.getType();
+	}
+	return null;
+}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
index 81a74da..7f5e331 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,28 +11,13 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search;
 
-import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.IAccessRule;
-import org.eclipse.jdt.core.IClassFile;
-import org.eclipse.jdt.core.ICompilationUnit;
-import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IJavaProject;
-import org.eclipse.jdt.core.IPackageFragment;
-import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IType;
-import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.core.search.TypeNameMatchRequestor;
 import org.eclipse.jdt.core.search.TypeNameRequestor;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.core.Openable;
-import org.eclipse.jdt.internal.core.PackageFragmentRoot;
-import org.eclipse.jdt.internal.core.util.HandleFactory;
-import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
 
 /**
  * Wrapper used to link {@link IRestrictedAccessTypeRequestor} with {@link TypeNameRequestor}.
@@ -57,30 +42,12 @@ import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
  * 	int waitingPolicy,
  * 	org.eclipse.core.runtime.IProgressMonitor monitor) }.
  */
-public class TypeNameMatchRequestorWrapper implements IRestrictedAccessTypeRequestor {
+public class TypeNameMatchRequestorWrapper extends NameMatchRequestorWrapper  implements IRestrictedAccessTypeRequestor {
 	TypeNameMatchRequestor requestor;
-	private IJavaSearchScope scope; // scope is needed to retrieve project path for external resource
-	private HandleFactory handleFactory; // in case of IJavaSearchScope defined by clients, use an HandleFactory instead
-
-	/**
-	 * Cache package fragment root information to optimize speed performance.
-	 */
-	private String lastPkgFragmentRootPath;
-	private IPackageFragmentRoot lastPkgFragmentRoot;
-
-	/**
-	 * Cache package handles to optimize memory.
-	 */
-	private HashtableOfArrayToObject packageHandles;
-	private Object lastProject;
-	private long complianceValue;
 
 public TypeNameMatchRequestorWrapper(TypeNameMatchRequestor requestor, IJavaSearchScope scope) {
+	super(scope);
 	this.requestor = requestor;
-	this.scope = scope;
-	if (!(scope instanceof AbstractJavaSearchScope)) {
-		this.handleFactory = new HandleFactory();
-	}
 }
 
 /* (non-Javadoc)
@@ -89,152 +56,29 @@ public TypeNameMatchRequestorWrapper(TypeNameMatchRequestor requestor, IJavaSear
 public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access) {
 
 	// Get type
-	try {
-		IType type = null;
-		if (this.handleFactory != null) {
-			Openable openable = this.handleFactory.createOpenable(path, this.scope);
-			if (openable == null) return;
-			switch (openable.getElementType()) {
-				case IJavaElement.COMPILATION_UNIT:
-					ICompilationUnit cu = (ICompilationUnit) openable;
-					if (enclosingTypeNames != null && enclosingTypeNames.length > 0) {
-						type = cu.getType(new String(enclosingTypeNames[0]));
-						for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
-							type = type.getType(new String(enclosingTypeNames[j]));
-						}
-						type = type.getType(new String(simpleTypeName));
-					} else {
-						type = cu.getType(new String(simpleTypeName));
-					}
-					break;
-				case IJavaElement.CLASS_FILE:
-					type = ((IClassFile)openable).getType();
-					break;
-			}
-		} else {
-			int separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);
-			type = separatorIndex == -1
-				? createTypeFromPath(path, new String(simpleTypeName), enclosingTypeNames)
-				: createTypeFromJar(path, separatorIndex);
-		}
+	IType type = getType(modifiers, packageName, simpleTypeName, enclosingTypeNames, path, access);
+	// Accept match if the type has been found
+	if (type != null) {
+		// hierarchy scopes require one more check:
+		if (!(this.scope instanceof HierarchyScope) || ((HierarchyScope)this.scope).enclosesFineGrained(type)) {
 
-		// Accept match if the type has been found
-		if (type != null) {
-			// hierarchy scopes require one more check:
-			if (!(this.scope instanceof HierarchyScope) || ((HierarchyScope)this.scope).enclosesFineGrained(type)) {
+			// Create the match
+			final JavaSearchTypeNameMatch match = new JavaSearchTypeNameMatch(type, modifiers);
 
-				// Create the match
-				final JavaSearchTypeNameMatch match = new JavaSearchTypeNameMatch(type, modifiers);
-
-				// Update match accessibility
-				if(access != null) {
-					switch (access.getProblemId()) {
-						case IProblem.ForbiddenReference:
-							match.setAccessibility(IAccessRule.K_NON_ACCESSIBLE);
-							break;
-						case IProblem.DiscouragedReference:
-							match.setAccessibility(IAccessRule.K_DISCOURAGED);
-							break;
-					}
+			// Update match accessibility
+			if(access != null) {
+				switch (access.getProblemId()) {
+					case IProblem.ForbiddenReference:
+						match.setAccessibility(IAccessRule.K_NON_ACCESSIBLE);
+						break;
+					case IProblem.DiscouragedReference:
+						match.setAccessibility(IAccessRule.K_DISCOURAGED);
+						break;
 				}
-
-				// Accept match
-				this.requestor.acceptTypeNameMatch(match);
-			}
-		}
-	} catch (JavaModelException e) {
-		// skip
-	}
-}
-private IType createTypeFromJar(String resourcePath, int separatorIndex) throws JavaModelException {
-	// path to a class file inside a jar
-	// Optimization: cache package fragment root handle and package handles
-	if (this.lastPkgFragmentRootPath == null
-			|| this.lastPkgFragmentRootPath.length() > resourcePath.length()
-			|| !resourcePath.startsWith(this.lastPkgFragmentRootPath)) {
-		String jarPath= resourcePath.substring(0, separatorIndex);
-		IPackageFragmentRoot root= ((AbstractJavaSearchScope)this.scope).packageFragmentRoot(resourcePath, separatorIndex, jarPath);
-		if (root == null) return null;
-		this.lastPkgFragmentRootPath= jarPath;
-		this.lastPkgFragmentRoot= root;
-		this.packageHandles= new HashtableOfArrayToObject(5);
-	}
-	// create handle
-	String classFilePath= resourcePath.substring(separatorIndex + 1);
-	String[] simpleNames = new Path(classFilePath).segments();
-	String[] pkgName;
-	int length = simpleNames.length-1;
-	if (length > 0) {
-		pkgName = new String[length];
-		System.arraycopy(simpleNames, 0, pkgName, 0, length);
-	} else {
-		pkgName = CharOperation.NO_STRINGS;
-	}
-	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
-	if (pkgFragment == null) {
-		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);
-		// filter org.apache.commons.lang.enum package for projects above 1.5 
-		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=317264
-		if (length == 5 && pkgName[4].equals("enum")) { //$NON-NLS-1$
-			IJavaProject proj = (IJavaProject)pkgFragment.getAncestor(IJavaElement.JAVA_PROJECT);
-			if (!proj.equals(this.lastProject)) {
-				String complianceStr = proj.getOption(CompilerOptions.OPTION_Source, true);
-				this.complianceValue = CompilerOptions.versionToJdkLevel(complianceStr);
-				this.lastProject = proj;
-			}
-			if (this.complianceValue >= ClassFileConstants.JDK1_5)
-				return null;
-		} 
-		this.packageHandles.put(pkgName, pkgFragment);
-	}
-	return pkgFragment.getClassFile(simpleNames[length]).getType();
-}
-private IType createTypeFromPath(String resourcePath, String simpleTypeName, char[][] enclosingTypeNames) throws JavaModelException {
-	// path to a file in a directory
-	// Optimization: cache package fragment root handle and package handles
-	int rootPathLength = -1;
-	if (this.lastPkgFragmentRootPath == null
-		|| !(resourcePath.startsWith(this.lastPkgFragmentRootPath)
-			&& (rootPathLength = this.lastPkgFragmentRootPath.length()) > 0
-			&& resourcePath.charAt(rootPathLength) == '/')) {
-		PackageFragmentRoot root = (PackageFragmentRoot) ((AbstractJavaSearchScope)this.scope).packageFragmentRoot(resourcePath, -1/*not a jar*/, null/*no jar path*/);
-		if (root == null) return null;
-		this.lastPkgFragmentRoot = root;
-		this.lastPkgFragmentRootPath = root.internalPath().toString();
-		this.packageHandles = new HashtableOfArrayToObject(5);
-	}
-	// create handle
-	resourcePath = resourcePath.substring(this.lastPkgFragmentRootPath.length() + 1);
-	String[] simpleNames = new Path(resourcePath).segments();
-	String[] pkgName;
-	int length = simpleNames.length-1;
-	if (length > 0) {
-		pkgName = new String[length];
-		System.arraycopy(simpleNames, 0, pkgName, 0, length);
-	} else {
-		pkgName = CharOperation.NO_STRINGS;
-	}
-	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
-	if (pkgFragment == null) {
-		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);
-		this.packageHandles.put(pkgName, pkgFragment);
-	}
-	String simpleName= simpleNames[length];
-	if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(simpleName)) {
-		ICompilationUnit unit= pkgFragment.getCompilationUnit(simpleName);
-		int etnLength = enclosingTypeNames == null ? 0 : enclosingTypeNames.length;
-		IType type = (etnLength == 0) ? unit.getType(simpleTypeName) : unit.getType(new String(enclosingTypeNames[0]));
-		if (etnLength > 0) {
-			for (int i=1; i<etnLength; i++) {
-				type = type.getType(new String(enclosingTypeNames[i]));
 			}
-			type = type.getType(simpleTypeName);
+			// Accept match
+			this.requestor.acceptTypeNameMatch(match);
 		}
-		return type;
-	} else if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(simpleName)){
-		IClassFile classFile= pkgFragment.getClassFile(simpleName);
-		return classFile.getType();
 	}
-	return null;
 }
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 8d40822..8111757 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -160,6 +160,41 @@ public abstract class AbstractIndexer implements IIndexConstants {
 			}
 		}
 	}
+	public void addMethodDeclaration(
+			char[] typeName,
+			char[] declaringQualification,
+			char[] methodName,
+			int argCount,
+			char[] signature,
+			char[][] parameterTypes,
+			char[][] parameterNames,
+			char[] returnType,
+			int modifiers,
+			char[] packageName,
+			int typeModifiers,
+			char[][] exceptionTypes,
+			int extraFlags) {
+		try {
+			addIndexEntry(
+					METHOD_DECL_PLUS,
+					MethodDeclarationPattern.createDeclarationIndexKey(
+							typeName,
+							declaringQualification,
+							methodName,
+							argCount,
+							signature,
+							parameterTypes,
+							parameterNames,
+							returnType,
+							modifiers,
+							packageName,
+							typeModifiers,
+							extraFlags));
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
 	public void addMethodDeclaration(char[] methodName, char[][] parameterTypes, char[] returnType, char[][] exceptionTypes) {
 		int argCount = parameterTypes == null ? 0 : parameterTypes.length;
 		addIndexEntry(METHOD_DECL, MethodPattern.createIndexKey(methodName, argCount));
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index f752c34..4243f31 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -749,6 +749,26 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 					} else {
 						if (!method.isClinit()) {
 							addMethodDeclaration(method.getSelector(), parameterTypes, returnType, exceptionTypes);
+							char[] signature = method.getGenericSignature();
+							if (signature == null) {
+								signature = descriptor;
+							}
+							if (name.length > 0)  {
+								addMethodDeclaration(
+										name,
+										null,
+										method.getSelector(),
+										parameterTypes == null ? 0 : parameterTypes.length,
+												signature,	
+												parameterTypes,
+												method.getArgumentNames(),
+												returnType,
+												method.getModifiers(),
+												packageName,
+												modifiers,
+												exceptionTypes,
+												extraFlags);
+							}
 						}
 					}
 					// look for references in method annotations
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
index 0ae4567..1234a05 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IIndexConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -22,6 +22,7 @@ public interface IIndexConstants {
 	char[] SUPER_REF = "superRef".toCharArray(); //$NON-NLS-1$
 	char[] TYPE_DECL = "typeDecl".toCharArray(); //$NON-NLS-1$
 	char[] METHOD_DECL= "methodDecl".toCharArray(); //$NON-NLS-1$
+	char[] METHOD_DECL_PLUS= "methodDeclPlus".toCharArray(); //$NON-NLS-1$
 	char[] CONSTRUCTOR_DECL= "constructorDecl".toCharArray(); //$NON-NLS-1$
 	char[] FIELD_DECL= "fieldDecl".toCharArray(); //$NON-NLS-1$
 	char[] OBJECT = "Object".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index 4ada576..8824b1d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.indexing;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.compiler.ExtraFlags;
@@ -302,8 +304,55 @@ private void enterInterface(TypeInfo typeInfo) {
  */
 public void enterMethod(MethodInfo methodInfo) {
 	this.indexer.addMethodDeclaration(methodInfo.name, methodInfo.parameterTypes, methodInfo.returnType, methodInfo.exceptionTypes);
+	int argCount = methodInfo.parameterTypes == null ? 0 : methodInfo.parameterTypes.length;
+	char[] typeName = methodInfo.enclosingType != null ? methodInfo.enclosingType.name : null;
+	if (typeName == null || typeName.length == 0) return;
+	this.indexer.addMethodDeclaration(
+			typeName,
+			getDeclaringQualification(methodInfo.enclosingType),
+			methodInfo.name,
+			argCount,
+			null,
+			methodInfo.parameterTypes,
+			methodInfo.parameterNames,
+			methodInfo.returnType,
+			methodInfo.modifiers,
+			methodInfo.declaringPackageName,
+			methodInfo.declaringTypeModifiers,
+			methodInfo.exceptionTypes,
+			getMoreExtraFlags(methodInfo.extraFlags));
 	this.methodDepth++;
 }
+
+private static char[] getDeclaringQualification(TypeDeclaration typeDecl) {
+	if (typeDecl.name == null) return null;
+	TypeDeclaration enclosingType = typeDecl.enclosingType;
+
+	List<char[]> nlist = new ArrayList<>();
+	char[] name = null;
+	int size = 0;
+	while (enclosingType != null && (name = enclosingType.name) != null) {
+		nlist.add(0, name);
+		size += name.length + 1;
+		enclosingType = enclosingType.enclosingType;
+	}
+	if (name == null) return null;
+
+	int l = nlist.size();
+	if (l == 1) return name;
+	
+	name = new char[size];
+	int index = 0;
+	for (int i = 0; i < l - 1; ++i) {
+		char[] e = nlist.get(i);
+		System.arraycopy(e, 0, name, index, e.length);
+		index += e.length;
+		name[index++] = '.';
+	}
+	char[] e = nlist.get(l - 1);
+	System.arraycopy(e, 0, name, index, e.length);
+	return name;
+}
 /**
  * @see ISourceElementRequestor#enterType(ISourceElementRequestor.TypeInfo)
  */
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java
new file mode 100644
index 0000000..6079368
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java
@@ -0,0 +1,330 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.search.matching;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.core.search.SearchPattern;
+import org.eclipse.jdt.internal.compiler.ExtraFlags;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+
+public class MethodDeclarationPattern extends MethodPattern {
+
+	public int extraFlags;
+	public int declaringTypeModifiers;
+	
+	public int modifiers;
+	public char[] signature;
+	public char[][] parameterTypes;
+	public char[][] parameterNames;
+	/**
+	 * Method Declaration entries are encoded as described
+	 * 
+	 * Binary Method Declaration for class
+	 * MethodName '/' Arity '/' DeclaringQualifier '/' TypeName '/' TypeModifers '/' PackageName '/' Signature '/' ParameterNamesopt '/' Modifiers '/' returnType
+	 * Source method for class
+	 * MethodName '/' Arity '/' DeclaringQualifier '/' TypeName '/' TypeModifers '/' PackageName '/' ParameterTypes '/' ParameterNamesopt '/' Modifiers '/' returnType
+	 * TypeModifiers contains some encoded extra information
+	 * 		{@link ExtraFlags#IsMemberType}
+	 * 		{@link ExtraFlags#HasNonPrivateStaticMemberTypes}
+	 * 		{@link ExtraFlags#ParameterTypesStoredAsSignature}
+	 */
+	public static char[] createDeclarationIndexKey(
+			char[] typeName,
+			char[] declaringQualification,
+			char[] methodName,
+			int argCount,
+			char[] signature,
+			char[][] parameterTypes,
+			char[][] parameterNames,
+			char[] returnType,
+			int modifiers,
+			char[] packageName,
+			int typeModifiers,
+			int extraFlags) {
+		
+		char[] countChars;
+		char[] parameterTypesChars = null;
+		char[] parameterNamesChars = null;
+		
+		
+		countChars = argCount < 10 ? COUNTS[argCount]: ("/" + String.valueOf(argCount)).toCharArray(); //$NON-NLS-1$
+		if (argCount > 0) {
+			if (signature == null) {
+				if (parameterTypes != null && parameterTypes.length == argCount) {
+					char[][] parameterTypeErasures = new char[argCount][];
+					for (int i = 0; i < parameterTypes.length; i++) {
+						parameterTypeErasures[i] = getTypeErasure(parameterTypes[i]);
+					}
+					parameterTypesChars = CharOperation.concatWith(parameterTypeErasures, PARAMETER_SEPARATOR);
+				}
+			} else {
+				extraFlags |= ExtraFlags.ParameterTypesStoredAsSignature;
+			}
+			
+			if (parameterNames != null && parameterNames.length == argCount) {
+				parameterNamesChars = CharOperation.concatWith(parameterNames, PARAMETER_SEPARATOR);
+			}
+		}
+				
+		char[] returnTypeChars = returnType == null ? CharOperation.NO_CHAR : getTypeErasure(returnType);
+		
+		
+		int typeNameLength = typeName == null ? 0 : typeName.length;
+		int qualifierLength = declaringQualification == null ? 0 : declaringQualification.length;
+		int methodNameLength = methodName == null ? 0 : methodName.length;
+		int packageNameLength = packageName == null ? 0 : packageName.length;
+		int countCharsLength = countChars.length;
+		int parameterTypesLength = signature == null ? (parameterTypesChars == null ? 0 : parameterTypesChars.length): signature.length;
+		int parameterNamesLength = parameterNamesChars == null ? 0 : parameterNamesChars.length;
+		int returnTypeLength = returnTypeChars.length;
+		
+		int resultLength = methodNameLength + countCharsLength + qualifierLength + typeNameLength + 2 /* type modifiers */
+				+ packageNameLength + parameterTypesLength + parameterNamesLength + returnTypeLength + 2 /* modifiers*/ + 9; // SEPARATOR = 9
+		char[] result = new char[resultLength];
+		
+		int pos = 0;
+		if (methodNameLength > 0) {
+			System.arraycopy(methodName, 0, result, pos, methodNameLength);
+			pos += methodNameLength;
+		}
+		if (countCharsLength > 0) {
+			System.arraycopy(countChars, 0, result, pos, countCharsLength);
+			pos += countCharsLength;
+		}
+		result[pos++] = SEPARATOR;
+		if (qualifierLength > 0) {
+			System.arraycopy(declaringQualification, 0, result, pos, qualifierLength);
+			pos += qualifierLength;
+		}
+		result[pos++] = SEPARATOR;
+
+		if (typeNameLength > 0) {
+			System.arraycopy(typeName, 0, result, pos, typeNameLength);
+			pos += typeNameLength;
+		}
+
+		
+		int typeModifiersWithExtraFlags = typeModifiers | encodeExtraFlags(extraFlags);
+		result[pos++] = SEPARATOR;
+		result[pos++] = (char) typeModifiersWithExtraFlags;
+		result[pos++] = (char) (typeModifiersWithExtraFlags>>16);
+		
+		result[pos++] = SEPARATOR;
+		if (packageNameLength > 0) {
+			System.arraycopy(packageName, 0, result, pos, packageNameLength);
+			pos += packageNameLength;
+		}
+		
+		if (argCount == 0) {
+			result[pos++] = SEPARATOR;
+			result[pos++] = SEPARATOR;
+			result[pos++] = SEPARATOR;
+		} else if (argCount > 0) {
+			result[pos++] = SEPARATOR;
+			if (parameterTypesLength > 0) {
+				if (signature == null) {
+					System.arraycopy(parameterTypesChars, 0, result, pos, parameterTypesLength);
+				} else {
+					System.arraycopy(CharOperation.replaceOnCopy(signature, SEPARATOR, '\\'), 0, result, pos, parameterTypesLength);
+				}
+				pos += parameterTypesLength;
+			}
+			
+			result[pos++] = SEPARATOR;
+			if (parameterNamesLength > 0) {
+				System.arraycopy(parameterNamesChars, 0, result, pos, parameterNamesLength);
+				pos += parameterNamesLength;
+			}
+			
+			result[pos++] = SEPARATOR;
+		}
+		result[pos++] = (char) modifiers;
+		result[pos++] = (char) (modifiers>>16);
+		result[pos++] = SEPARATOR;
+
+		if (returnTypeLength > 0) {
+			System.arraycopy(returnTypeChars, 0, result, pos, returnTypeLength);
+			pos += returnTypeLength;
+		}
+		result[pos++] = SEPARATOR;
+		return result;
+	}
+	
+	private static int encodeExtraFlags(int extraFlags) {
+		int encodedExtraFlags = 0;
+		
+		if ((extraFlags & ExtraFlags.ParameterTypesStoredAsSignature) != 0) {
+			encodedExtraFlags |= ASTNode.Bit28;
+		}
+		
+		if ((extraFlags & ExtraFlags.IsLocalType) != 0) {
+			encodedExtraFlags |= ASTNode.Bit29;
+		}
+		
+		if ((extraFlags & ExtraFlags.IsMemberType) != 0) {
+			encodedExtraFlags |= ASTNode.Bit30;
+		}
+		if ((extraFlags & ExtraFlags.HasNonPrivateStaticMemberTypes) != 0) {
+			encodedExtraFlags |= ASTNode.Bit31;
+		}
+		
+		return encodedExtraFlags;
+	}
+	private static char[] getTypeErasure(char[] typeName) {
+		int index;
+		if ((index = CharOperation.indexOf('<', typeName)) == -1) return typeName;
+		
+		int length = typeName.length;
+		char[] typeErasurename = new char[length - 2];
+		
+		System.arraycopy(typeName, 0, typeErasurename, 0, index);
+		
+		int depth = 1;
+		for (int i = index + 1; i < length; i++) {
+			switch (typeName[i]) {
+				case '<':
+					depth++;
+					break;
+				case '>':
+					depth--;
+					break;
+				default:
+					if (depth == 0) {
+						typeErasurename[index++] = typeName[i];
+					}
+					break;
+			}
+		}
+		
+		System.arraycopy(typeErasurename, 0, typeErasurename = new char[index], 0, index);
+		return typeErasurename;
+	}
+
+public MethodDeclarationPattern(
+		char[] declaringPackageName, 
+		char[] declaringQualification, 
+		char[] declaringSimpleName,
+		char[] methodName,
+		int matchRule) {
+	super(methodName, declaringQualification, declaringSimpleName, 
+			null, null, null, null, null, 
+			IJavaSearchConstants.DECLARATIONS, matchRule);
+	this.declaringPackageName = declaringPackageName;
+}
+
+public MethodDeclarationPattern(int matchRule) {
+	super(matchRule);
+}
+
+public void decodeIndexKey(char[] key) {
+	
+	int start = 0;
+	int slash = CharOperation.indexOf(SEPARATOR, key, start);
+	this.selector = CharOperation.subarray(key, start, slash);
+
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	int last = slash - 1;
+	
+	this.parameterCount = 0;
+	int power = 1;
+	for (int i = last; i >= start; i--) {
+		if (i == last) {
+			this.parameterCount = key[i] - '0';
+		} else {
+			power *= 10;
+			this.parameterCount += power * (key[i] - '0');
+		}
+	}
+
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	this.declaringQualification = CharOperation.subarray(key, start, slash);
+	
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	this.declaringSimpleName = CharOperation.subarray(key, start, slash);
+	
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	last = slash - 1;
+	int typeModifiersWithExtraFlags = key[last-1] + (key[last]<<16);
+	this.declaringTypeModifiers = ConstructorPattern.decodeModifers(typeModifiersWithExtraFlags);
+	this.extraFlags = ConstructorPattern.decodeExtraFlags(typeModifiersWithExtraFlags);
+	
+	// initialize optional fields
+	this.declaringPackageName = null;
+	this.modifiers = 0;
+	this.signature = null;
+	this.parameterTypes = null;
+	this.parameterNames = null;
+	
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	this.declaringPackageName = CharOperation.subarray(key, start, slash);
+	
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	if (this.parameterCount == 0) {
+		start = slash + 1;
+		slash = CharOperation.indexOf(SEPARATOR, key, start); // skip parameter type/signature
+
+		start = slash + 1;
+		slash = CharOperation.indexOf(SEPARATOR, key, start); //skip parameter names
+
+		this.modifiers = key[last-1] + (key[last]<<16);
+	} else if (this.parameterCount > 0){
+
+		boolean hasParameterStoredAsSignature = (this.extraFlags & ExtraFlags.ParameterTypesStoredAsSignature) != 0;
+		if (hasParameterStoredAsSignature) {
+			this.signature  = CharOperation.subarray(key, start, slash);
+			CharOperation.replace(this.signature , '\\', SEPARATOR);
+		} else {
+			this.parameterTypes = CharOperation.splitOn(PARAMETER_SEPARATOR, key, start, slash);
+		}
+		start = slash + 1;
+		slash = CharOperation.indexOf(SEPARATOR, key, start);
+		
+		if (slash != start) {
+			this.parameterNames = CharOperation.splitOn(PARAMETER_SEPARATOR, key, start, slash);
+		}
+		
+		start = slash + 1;
+		slash = CharOperation.indexOf(SEPARATOR, key, start);
+		last = slash - 1;
+		
+		this.modifiers = key[last-1] + (key[last]<<16);
+	} else {
+		this.modifiers = ClassFileConstants.AccPublic;
+	}
+
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	this.returnSimpleName = CharOperation.subarray(key, start, slash); //TODO : separate return qualified and simple names - currently stored together in simple name.
+
+	removeInternalFlags(); // remove internal flags
+}
+
+	public SearchPattern getBlankPattern() {
+		return new MethodDeclarationPattern(R_EXACT_MATCH | R_CASE_SENSITIVE);
+	}
+
+	public char[][] getIndexCategories() {
+		return new char[][] { METHOD_DECL_PLUS };
+	}
+
+	private void removeInternalFlags() {
+		this.extraFlags = this.extraFlags & ~ExtraFlags.ParameterTypesStoredAsSignature; // ParameterTypesStoredAsSignature is an internal flags only used to decode key
+	}
+
+}
commit c42c7e657b077ec634fd7716be6404b721c1a1dc
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Mon Apr 18 14:12:01 2016 +0530

    Javadoc changes for bug 478042 [search] Support for Open Method using a
    single api

18	10	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
index 77c371e..c7aa453 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchEngine.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -436,7 +436,11 @@ public class SearchEngine {
 
 	/**
 	 * Create a method name match on a given method with specific modifiers.
-	 *
+	 * <p>
+	 * NOTE: this is a first-cut version and might have noticeable delay times in some cases. 
+	 * Targeted for optimization during 4.7. It is recommended to contact JDT Team if 
+	 * anyone plans to use this.
+	 * </p>
 	 * @param method The Java model handle of the method
 	 * @param modifiers Modifiers of the method
 	 * @return A non-null match on the given method.
@@ -600,8 +604,9 @@ public class SearchEngine {
 	 * Searches for all method declarations in the given scope. Accepted matches will be returned by
 	 * {@link MethodNameRequestor#acceptMethod}.
 	 * <p>
-	 * Warning: This API is in experimental phase and may be modified/removed. Do not use this until this
-	 * comment is removed.
+	 * NOTE: this is a first-cut version and might have noticeable delay times in some cases. 
+	 * Targeted for optimization during 4.7. It is recommended to contact JDT Team if 
+	 * anyone plans to use this.
 	 * </p>
 	 * 
 	 * @param packageName the full name of the package of the searched types, or a prefix for this
@@ -661,8 +666,9 @@ public class SearchEngine {
 
 	 * </p>
 	 * <p>
-	 * Warning: This API is in experimental phase and may be modified/removed. Do not use this until this
-	 * comment is removed.
+	 * NOTE: this is a first-cut version and might have noticeable delay times in some cases. 
+	 * Targeted for optimization during 4.7. It is recommended to contact JDT Team if 
+	 * anyone plans to use this.
 	 * </p>
 	 * 
 	 * @param packageName the full name of the package of the searched types, or a prefix for this
@@ -718,8 +724,9 @@ public class SearchEngine {
 	 * Searches for all method declarations in the given scope. Accepted matches will be returned by
 	 * {@link MethodNameRequestor#acceptMethod}.
 	 * <p>
-	 * Warning: This API is in experimental phase and may be modified/removed. Do not use this until this
-	 * comment is removed.
+	 * NOTE: this is a first-cut version and might have noticeable delay times in some cases. 
+	 * Targeted for optimization during 4.7. It is recommended to contact JDT Team if 
+	 * anyone plans to use this.
 	 * </p>
 	 * 
 	 * @param qualifier qualifier including package name and qualified type name
@@ -793,8 +800,9 @@ public class SearchEngine {
 	 * matches found during the search.
 	 * </p>
 	 * <p>
-	 * Warning: This API is in experimental phase and may be modified/removed. Do not use this until this
-	 * comment is removed.
+	 * NOTE: this is a first-cut version and might have noticeable delay times in some cases. 
+	 * Targeted for optimization during 4.7. It is recommended to contact JDT Team if 
+	 * anyone plans to use this.
 	 * </p>
 	 * 
 	 * @param qualifier qualifier including package name and qualified type name
