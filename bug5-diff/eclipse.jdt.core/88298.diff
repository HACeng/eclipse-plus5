commit 9635fd418f2d5b55fe3d3dc4ccb7797a5daf3a53
Author: David Audel <daudel>
Date:   Wed Apr 13 14:38:06 2005 +0000

    bug 88298

1857	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationCompletionParserTest.java
2017	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
9	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
127	57	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
12	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeDetector.java
10	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeFound.java
11	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMarkerAnnotationName.java
3	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
8	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnSingleNameReference.java
116	36	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
24	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
32	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
11	1	org.eclipse.jdt.core/grammar/java_1_5.g
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationCompletionParserTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationCompletionParserTest.java
index 4a6cf9e..6ab0fe9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationCompletionParserTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationCompletionParserTest.java
@@ -2750,6 +2750,271 @@ public void test0073(){
 			expectedReplacedSource,
 	"diet ast");
 }
+public void test0074(){
+	String str =
+		"@Annot(zzz=foo)\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public @Annot(zzz = <CompleteOnName:foo>) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0075(){
+	String str =
+		"@Annot(zzz= a && foo)\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public @Annot(zzz = (a && <CompleteOnName:foo>)) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0076(){
+	String str =
+		"@Annot(zzz= {foo})\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public @Annot(zzz = {<CompleteOnName:foo>}) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0078(){
+	String str =
+		"@Annot(zzz= {yyy, foo})\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public @Annot(zzz = {yyy, <CompleteOnName:foo>}) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0079(){
+	String str =
+		"@Annot(zzz=foo\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"@Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0080(){
+	String str =
+		"@Annot(zzz= a && foo\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"@Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0081(){
+	String str =
+		"@Annot(zzz= {yyy, foo}\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "{yyy, <CompleteOnName:foo>}";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"@Annot(zzz = {yyy, <CompleteOnName:foo>})\n" +
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0082(){
+	String str =
+		"@Annot(zzz= {yyy, foo\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"@Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0083(){
+	String str =
+		"@Annot(zzz= a && (b || (foo && c)))\n" +
+		"public class X {\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public @Annot(zzz = (a && (b || (<CompleteOnName:foo> && c)))) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
 public void test0084(){
 	String str =
 		"@Annot(zzz= a && (b || (foo\n" +
@@ -2764,6 +3029,7 @@ public void test0084(){
 	String completionIdentifier = "foo";
 	String expectedReplacedSource = "foo";
 	String expectedUnitDisplayString =
+		"@Annot(zzz = <CompleteOnName:foo>)\n" + 
 		"public class X {\n" + 
 		"  public X() {\n" + 
 		"  }\n" + 
@@ -2779,4 +3045,1595 @@ public void test0084(){
 			expectedReplacedSource,
 	"diet ast");
 }
+public void test0085(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz=foo)\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>) void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0086(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && foo)\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @Annot(zzz = (a && <CompleteOnName:foo>)) void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0087(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {foo})\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @Annot(zzz = {<CompleteOnName:foo>}) void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0088(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo})\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @Annot(zzz = {yyy, <CompleteOnName:foo>}) void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0089(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz=foo\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0090(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && foo\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0091(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo}\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "{yyy, <CompleteOnName:foo>}";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = {yyy, <CompleteOnName:foo>})\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0092(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0093(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && (b || (foo && c)))\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @Annot(zzz = (a && (b || (<CompleteOnName:foo> && c)))) void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0094(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && (b || (foo\n" +
+		"  void bar() {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0095(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz=foo)\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>) int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0096(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && foo)\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = (a && <CompleteOnName:foo>)) int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0097(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {foo})\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = {<CompleteOnName:foo>}) int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0098(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo})\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = {yyy, <CompleteOnName:foo>}) int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0099(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz=foo\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0100(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && foo\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"  int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0101(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo}\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "{yyy, <CompleteOnName:foo>}";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = {yyy, <CompleteOnName:foo>})\n" + 
+		"  int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0102(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= {yyy, foo\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0103(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && (b || (foo && c)))\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = (a && (b || (<CompleteOnName:foo> && c)))) int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0104(){
+	String str =
+		"public class X {\n" +
+		"  @Annot(zzz= a && (b || (foo\n" +
+		"  int bar;\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  int bar;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0105(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz=foo)\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0106(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= a && foo)\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0107(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= {foo})\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0108(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= {yyy, foo})\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0109(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz=foo\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0110(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    int var;\n" +
+		"    @Annot(zzz= a && foo\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    int var;\n" + 
+		"    @Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0111(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= {yyy, foo}\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0112(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= {yyy, foo\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0113(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= a && (b || (foo && c)))\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0114(){
+	String str =
+		"public class X {\n" +
+		"  void bar() {\n" +
+		"    @Annot(zzz= a && (b || (foo\n" +
+		"    int var;\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<NONE>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "<NONE>";
+	String expectedReplacedSource = "<NONE>";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "<NONE>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0115(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz=foo) int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar(@Annot(zzz = <CompleteOnName:foo>) int var) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0116(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= a && foo) int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar(@Annot(zzz = (a && <CompleteOnName:foo>)) int var) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0117(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= {foo}) int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar(@Annot(zzz = {<CompleteOnName:foo>}) int var) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0118(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= {yyy, foo}) int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar(@Annot(zzz = {yyy, <CompleteOnName:foo>}) int var) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0119(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz=foo int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "zzz = <CompleteOnName:foo>";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = <CompleteOnName:foo>)\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0120(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= a && foo int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+	
+	expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	expectedParentNodeToString = "(a && <CompleteOnName:foo>)";
+	completionIdentifier = "foo";
+	expectedReplacedSource = "foo";
+	expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"    @Annot(zzz = (a && <CompleteOnName:foo>))\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkMethodParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+			"full ast");
+}
+public void test0121(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= {yyy, foo} int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "{yyy, <CompleteOnName:foo>}";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  @Annot(zzz = {yyy, <CompleteOnName:foo>})\n" + 
+		"  int var;\n" + 
+		"  {\n" + 
+		"  }\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0122(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= {yyy, foo int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0123(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= a && (b || (foo && c))) int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar(@Annot(zzz = (a && (b || (<CompleteOnName:foo> && c)))) int var) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
+public void test0124(){
+	String str =
+		"public class X {\n" +
+		"  void bar(@Annot(zzz= a && (b || (foo int var) {\n" +
+		"  }\n" +
+		"}";
+
+
+	String completeBehind = "foo";
+	int cursorLocation = str.indexOf(completeBehind) + completeBehind.length() - 1;
+	String expectedCompletionNodeToString = "<CompleteOnName:foo>";
+	String expectedParentNodeToString = "<NONE>";
+	String completionIdentifier = "foo";
+	String expectedReplacedSource = "foo";
+	String expectedUnitDisplayString =
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void bar() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	checkDietParse(
+			str.toCharArray(),
+			cursorLocation,
+			expectedCompletionNodeToString,
+			expectedParentNodeToString,
+			expectedUnitDisplayString,
+			completionIdentifier,
+			expectedReplacedSource,
+	"diet ast");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
index 5f77a1c..08fac23 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
@@ -46,7 +46,7 @@ public static Test suite() {
 		}
 		return suite;
 	}
-	suite.addTest(new CompletionTests_1_5("test0136"));			
+	suite.addTest(new CompletionTests_1_5("test0184"));			
 	return suite;
 }
 
@@ -3047,4 +3047,2020 @@ public void test0144() throws JavaModelException {
 		JavaCore.setOptions(oldCurrentOptions);
 	}
 }
+// complete annotation attribute value
+public void test0145() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0145/ZZAnnotation.java",
+				"package test0145;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0145/ZZClass.java",
+				"package test0145;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0145/Test.java",
+				"package test0145;\n" +
+				"@ZZAnnotation(foo1=ZZ)\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0145, Ltest0145.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0145, Ltest0145.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0146() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0146/ZZAnnotation.java",
+				"package test0146;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0146/ZZClass.java",
+				"package test0146;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0146/Test.java",
+				"package test0146;\n" +
+				"@ZZAnnotation(foo1= 0 + ZZ)\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0146, Ltest0146.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0146, Ltest0146.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0147() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0147/ZZAnnotation.java",
+				"package test0147;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0147/ZZClass.java",
+				"package test0147;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0147/Test.java",
+				"package test0147;\n" +
+				"@ZZAnnotation(foo1= {ZZ})\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0147, Ltest0147.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0147, Ltest0147.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0148() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0148/ZZAnnotation.java",
+				"package test0148;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0148/ZZClass.java",
+				"package test0148;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0148/Test.java",
+				"package test0148;\n" +
+				"@ZZAnnotation(foo1=ZZ\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0148, Ltest0148.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0148, Ltest0148.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0149() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0149/ZZAnnotation.java",
+				"package test0149;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0149/ZZClass.java",
+				"package test0149;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0149/Test.java",
+				"package test0149;\n" +
+				"@ZZAnnotation(foo1= 0 + ZZ\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0149, Ltest0149.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0149, Ltest0149.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0150() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0150/ZZAnnotation.java",
+				"package test0150;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0150/ZZClass.java",
+				"package test0150;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0150/Test.java",
+				"package test0150;\n" +
+				"@ZZAnnotation(foo1= {ZZ}\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0150, Ltest0150.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0150, Ltest0150.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0151() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0151/ZZAnnotation.java",
+				"package test0151;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0151/ZZClass.java",
+				"package test0151;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0151/Test.java",
+				"package test0151;\n" +
+				"@ZZAnnotation(foo1= {ZZ\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0151, Ltest0151.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0151, Ltest0151.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0152() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0152/ZZAnnotation.java",
+				"package test0152;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0152/ZZClass.java",
+				"package test0152;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0152/Test.java",
+				"package test0152;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1=ZZ)\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0152, Ltest0152.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0152, Ltest0152.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0152.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0153() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0153/ZZAnnotation.java",
+				"package test0153;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0153/ZZClass.java",
+				"package test0153;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0153/Test.java",
+				"package test0153;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= 0 + ZZ)\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0153, Ltest0153.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0153, Ltest0153.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0153.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0154() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0154/ZZAnnotation.java",
+				"package test0154;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0154/ZZClass.java",
+				"package test0154;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0154/Test.java",
+				"package test0154;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ})\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0154.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0154, Ltest0154.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0154, Ltest0154.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0155() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0155/ZZAnnotation.java",
+				"package test0155;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0155/ZZClass.java",
+				"package test0155;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0155/Test.java",
+				"package test0155;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1=ZZ\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0155, Ltest0155.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0155, Ltest0155.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0155.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0156() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0156/ZZAnnotation.java",
+				"package test0156;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0156/ZZClass.java",
+				"package test0156;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0156/Test.java",
+				"package test0156;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= 0 + ZZ\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0156, Ltest0156.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0156, Ltest0156.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0156.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0157() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0157/ZZAnnotation.java",
+				"package test0157;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0157/ZZClass.java",
+				"package test0157;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0157/Test.java",
+				"package test0157;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ}\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0157.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0157, Ltest0157.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0157, Ltest0157.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0158() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0158/ZZAnnotation.java",
+				"package test0158;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0158/ZZClass.java",
+				"package test0158;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0158/Test.java",
+				"package test0158;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ\n" +
+				"  void bar(){}\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0158.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0158, Ltest0158.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0158, Ltest0158.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0159() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0159/ZZAnnotation.java",
+				"package test0159;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0159/ZZClass.java",
+				"package test0159;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0159/Test.java",
+				"package test0159;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1=ZZ)\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0159, Ltest0159.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0159, Ltest0159.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0159.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0160() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0160/ZZAnnotation.java",
+				"package test0160;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0160/ZZClass.java",
+				"package test0160;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0160/Test.java",
+				"package test0160;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= 0 + ZZ)\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0160, Ltest0160.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0160, Ltest0160.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0160.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0161() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0161/ZZAnnotation.java",
+				"package test0161;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0161/ZZClass.java",
+				"package test0161;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0161/Test.java",
+				"package test0161;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ})\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0161.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0161, Ltest0161.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0161, Ltest0161.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0162() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0162/ZZAnnotation.java",
+				"package test0162;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0162/ZZClass.java",
+				"package test0162;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0162/Test.java",
+				"package test0162;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1=ZZ\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0162, Ltest0162.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0162, Ltest0162.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0162.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0163() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0163/ZZAnnotation.java",
+				"package test0163;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0163/ZZClass.java",
+				"package test0163;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0163/Test.java",
+				"package test0163;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= 0 + ZZ\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0163, Ltest0163.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0163, Ltest0163.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0163.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0164() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0164/ZZAnnotation.java",
+				"package test0164;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0164/ZZClass.java",
+				"package test0164;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0164/Test.java",
+				"package test0164;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ}\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0164.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0164, Ltest0164.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0164, Ltest0164.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0165() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0165/ZZAnnotation.java",
+				"package test0165;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0165/ZZClass.java",
+				"package test0165;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0165/Test.java",
+				"package test0165;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(foo1= {ZZ\n" +
+				"  int bar;\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0165.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0165, Ltest0165.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0165, Ltest0165.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0166() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0166/ZZAnnotation.java",
+				"package test0166;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0166/ZZClass.java",
+				"package test0166;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0166/Test.java",
+				"package test0166;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1=ZZ)\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0166, Ltest0166.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0166, Ltest0166.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0166.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0167() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0167/ZZAnnotation.java",
+				"package test0167;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0167/ZZClass.java",
+				"package test0167;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0167/Test.java",
+				"package test0167;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1= 0 + ZZ)\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0167, Ltest0167.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0167, Ltest0167.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0167.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0168() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0168/ZZAnnotation.java",
+				"package test0168;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0168/ZZClass.java",
+				"package test0168;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0168/Test.java",
+				"package test0168;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1= {ZZ})\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0168.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0168, Ltest0168.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0168, Ltest0168.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0169() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0169/ZZAnnotation.java",
+				"package test0169;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0169/ZZClass.java",
+				"package test0169;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0169/Test.java",
+				"package test0169;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1=ZZ\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0169, Ltest0169.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0169, Ltest0169.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0169.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0170() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0170/ZZAnnotation.java",
+				"package test0170;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0170/ZZClass.java",
+				"package test0170;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0170/Test.java",
+				"package test0170;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1= 0 + ZZ\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0170, Ltest0170.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0170, Ltest0170.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0170.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0171() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0171/ZZAnnotation.java",
+				"package test0171;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0171/ZZClass.java",
+				"package test0171;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0171/Test.java",
+				"package test0171;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1= {ZZ}\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0171.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0171, Ltest0171.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0171, Ltest0171.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0172() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0172/ZZAnnotation.java",
+				"package test0172;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0172/ZZClass.java",
+				"package test0172;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0172/Test.java",
+				"package test0172;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz() {\n" +
+				"    @ZZAnnotation(foo1= {ZZ\n" +
+				"    int bar;\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0172.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0172, Ltest0172.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0172, Ltest0172.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0173() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0173/ZZAnnotation.java",
+				"package test0173;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0173/ZZClass.java",
+				"package test0173;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0173/Test.java",
+				"package test0173;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1=ZZ) int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0173, Ltest0173.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0173, Ltest0173.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0173.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0174() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0174/ZZAnnotation.java",
+				"package test0174;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0174/ZZClass.java",
+				"package test0174;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0174/Test.java",
+				"package test0174;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1= 0 + ZZ) int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0174, Ltest0174.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0174, Ltest0174.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0174.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0175() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0175/ZZAnnotation.java",
+				"package test0175;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0175/ZZClass.java",
+				"package test0175;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0175/Test.java",
+				"package test0175;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1= {ZZ}) int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0175.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0175, Ltest0175.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0175, Ltest0175.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0176() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0176/ZZAnnotation.java",
+				"package test0176;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0176/ZZClass.java",
+				"package test0176;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0176/Test.java",
+				"package test0176;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1=ZZ int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0176, Ltest0176.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0176, Ltest0176.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0176.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0177() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0177/ZZAnnotation.java",
+				"package test0177;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0177/ZZClass.java",
+				"package test0177;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0177/Test.java",
+				"package test0177;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1= 0 + ZZ int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0177, Ltest0177.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0177, Ltest0177.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0177.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0178() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0178/ZZAnnotation.java",
+				"package test0178;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0178/ZZClass.java",
+				"package test0178;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0178/Test.java",
+				"package test0178;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1= {ZZ} int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0178.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0178, Ltest0178.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0178, Ltest0178.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0179() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0179/ZZAnnotation.java",
+				"package test0179;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] foo1();\n" +
+				"  int foo2();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0179/ZZClass.java",
+				"package test0179;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0179/Test.java",
+				"package test0179;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  void baz(@ZZAnnotation(foo1= {ZZ int bar) {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0179.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0179, Ltest0179.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0179, Ltest0179.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0180() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0180/ZZAnnotation.java",
+				"package test0180;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0180/ZZClass.java",
+				"package test0180;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0180/Test.java",
+				"package test0180;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(ZZ)\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0180, Ltest0180.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0180, Ltest0180.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0180.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0181() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0181/ZZAnnotation.java",
+				"package test0181;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0181/ZZClass.java",
+				"package test0181;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0181/Test.java",
+				"package test0181;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(0 + ZZ)\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0181, Ltest0181.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0181, Ltest0181.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0181.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0182() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0182/ZZAnnotation.java",
+				"package test0182;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0182/ZZClass.java",
+				"package test0182;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0182/Test.java",
+				"package test0182;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation({ZZ})\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0182.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0182, Ltest0182.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0182, Ltest0182.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0183() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0183/ZZAnnotation.java",
+				"package test0183;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0183/ZZClass.java",
+				"package test0183;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0183/Test.java",
+				"package test0183;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(ZZ\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={I}\n" +
+				"expectedTypesKeys={I}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0183, Ltest0183.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0183, Ltest0183.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0183.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0184() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0184/ZZAnnotation.java",
+				"package test0184;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0184/ZZClass.java",
+				"package test0184;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0184/Test.java",
+				"package test0184;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation(0 + ZZ\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures={S,I,J,F,D,C,B,Ljava.lang.String;}\n" +
+				"expectedTypesKeys={S,I,J,F,D,C,B,Ljava/lang/String;}",
+				result.context);
+		
+		assertResults(
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0184, Ltest0184.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0184, Ltest0184.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"zzint[FIELD_REF]{zzint, Ltest0184.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0185() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0185/ZZAnnotation.java",
+				"package test0185;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0185/ZZClass.java",
+				"package test0185;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0185/Test.java",
+				"package test0185;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation({ZZ}\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0185.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0185, Ltest0185.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0185, Ltest0185.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
+// complete annotation attribute value
+public void test0186() throws JavaModelException {
+	ICompilationUnit anAnnotation = null;
+	ICompilationUnit aClass = null;
+	try {
+		anAnnotation = getWorkingCopy(
+				"/Completion/src3/test0186/ZZAnnotation.java",
+				"package test0186;\n" +
+				"public @interface ZZAnnotation {\n" +
+				"  int[] value();\n" +
+				"}");
+		
+		aClass = getWorkingCopy(
+				"/Completion/src3/test0186/ZZClass.java",
+				"package test0186;\n" +
+				"public class ZZClass {\n" +
+				"}");
+		
+		CompletionResult result = complete(
+				"/Completion/src3/test0186/Test.java",
+				"package test0186;\n" +
+				"public class Test {\n" +
+				"  public static final int zzint = 0;\n" +
+				"  @ZZAnnotation({ZZ\n" +
+				"  void bar() {\n" +
+				"  }\n" +
+				"}",
+				"ZZ");
+		
+		assertResults(
+				"expectedTypesSignatures=null\n" +
+				"expectedTypesKeys=null",
+				result.context);
+		
+		assertResults(
+				"zzint[FIELD_REF]{zzint, Ltest0186.Test;, I, zzint, null, " + (R_DEFAULT + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZAnnotation[TYPE_REF]{ZZAnnotation, test0186, Ltest0186.ZZAnnotation;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+				"ZZClass[TYPE_REF]{ZZClass, test0186, Ltest0186.ZZClass;, null, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+				result.proposals);
+	} finally {
+		if(anAnnotation != null) {
+			anAnnotation.discardWorkingCopy();
+		}
+		if(aClass != null) {
+			aClass.discardWorkingCopy();
+		}
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index e0accc9..c789d1b 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -46,10 +46,18 @@ Eclipse SDK 3.1M7 - ?th April 2005
 <h2>
 What's new in this drop</h2>
 <ul>
+<li>Added support for completion inside single member annotation and annotation attribute value.
+<pre>
+@MyAnnotation(&lt;complete here&gt;
+@MyAnnotation(foo=&lt;complete here&gt;
+</pre>
+</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=91238">91238</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=88298">88298</a>
+[1.5][assist] no completion inside SingleMemberAnnotation
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=91238">91238</a>
 Malfunction of Format function
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=91160">91160</a>
 SourceField.getConstant() incorrect for char constants
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 90b7286..987f0d2 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -75,6 +75,7 @@ public final class CompletionEngine
 	private final static char[] VOID = "void".toCharArray();  //$NON-NLS-1$
 	private final static char[] INT = "int".toCharArray();  //$NON-NLS-1$
 	private final static char[] INT_SIGNATURE = new char[]{Signature.C_INT};
+	private final static char[] VALUE = "value".toCharArray();  //$NON-NLS-1$
 	
 	private final static int SUPERTYPE = 1;
 	private final static int SUBTYPE = 2;
@@ -399,7 +400,7 @@ public final class CompletionEngine
 		this.requestor.acceptContext(context);
 	}
 	
-	private void complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope) {
+	private void complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
 
 		setSourceRange(astNode.sourceStart, astNode.sourceEnd);
 		
@@ -465,23 +466,29 @@ public final class CompletionEngine
 							this.findEnumConstant(this.completionToken, (SwitchStatement) astNodeParent);
 						}
 					} else {
-						findVariablesAndMethods(
-							this.completionToken,
-							scope,
-							(CompletionOnSingleNameReference) astNode,
-							scope);
-						// can be the start of a qualified type name
-						findTypesAndPackages(this.completionToken, scope);
-						if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-							findKeywords(this.completionToken, singleNameReference.possibleKeywords);
-						}
-						if(singleNameReference.canBeExplicitConstructor && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)){
-							if(CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {
-								ReferenceBinding ref = scope.enclosingSourceType();
-								findExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);
-							} else if(CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {
-								ReferenceBinding ref = scope.enclosingSourceType();
-								findExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);
+						if(this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
+							findTypesAndPackages(this.completionToken, scope);
+						} else {
+							findVariablesAndMethods(
+								this.completionToken,
+								scope,
+								singleNameReference,
+								scope,
+								insideTypeAnnotation,
+								singleNameReference.isInsideAnnotationAttribute);
+							// can be the start of a qualified type name
+							findTypesAndPackages(this.completionToken, scope);
+							if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+								findKeywords(this.completionToken, singleNameReference.possibleKeywords);
+							}
+							if(singleNameReference.canBeExplicitConstructor && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)){
+								if(CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {
+									ReferenceBinding ref = scope.enclosingSourceType();
+									findExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);
+								} else if(CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {
+									ReferenceBinding ref = scope.enclosingSourceType();
+									findExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);
+								}
 							}
 						}
 					}
@@ -531,7 +538,7 @@ public final class CompletionEngine
 							} else {
 	
 								if (qualifiedBinding instanceof ReferenceBinding) {
-	
+									boolean isInsideAnnotationAttribute = ref.isInsideAnnotationAttribute;
 									ReferenceBinding receiverType = (ReferenceBinding) qualifiedBinding;
 									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
 	
@@ -543,7 +550,8 @@ public final class CompletionEngine
 									}
 									
 									MethodScope methodScope = null;
-									if(!this.requestor.isIgnored(CompletionProposal.KEYWORD) &&
+									if(isInsideAnnotationAttribute &&
+											!this.requestor.isIgnored(CompletionProposal.KEYWORD) &&
 											((scope instanceof MethodScope && !((MethodScope)scope).isStatic)
 											|| ((methodScope = scope.enclosingMethodScope()) != null && !methodScope.isStatic))) {
 										if(this.completionToken.length > 0) {
@@ -582,7 +590,7 @@ public final class CompletionEngine
 											true);
 									}
 	
-									if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+									if(!isInsideAnnotationAttribute && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
 										findMethods(
 											this.completionToken,
 											null,
@@ -860,9 +868,16 @@ public final class CompletionEngine
 																	} else if(annot.type instanceof CompletionOnQualifiedTypeReference) {
 																		CompletionOnQualifiedTypeReference type = (CompletionOnQualifiedTypeReference) annot.type;
 																		this.completionToken = type.completionIdentifier;
-																		setSourceRange(type.sourceStart, type.sourceEnd);
-																		
-																		findTypesAndPackages(this.completionToken, scope);
+																		long completionPosition = type.sourcePositions[type.tokens.length];
+																		setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+										
+																		findMemberTypes(
+																			this.completionToken,
+																			(ReferenceBinding) qualifiedBinding,
+																			scope,
+																			scope.enclosingSourceType(),
+																			false,
+																			new ObjectVector());
 																	}
 																} else if (astNode instanceof CompletionOnMemberValueName) {
 																	if(!this.requestor.isIgnored(CompletionProposal.ANNOTATION_ATTRIBUTE_REF)) {
@@ -871,7 +886,32 @@ public final class CompletionEngine
 																		
 																		this.completionToken = memberValuePair.name;
 																		
+																		MemberValuePair[] memberValuePairs = annotation.memberValuePairs();
 																		this.findAnnotationAttributes(this.completionToken, annotation.memberValuePairs(), (ReferenceBinding)annotation.resolvedType);
+																		if(memberValuePairs == null || memberValuePairs.length == 0) {
+																			if(annotation.resolvedType instanceof ReferenceBinding) {
+																				MethodBinding[] methodBindings =
+																					((ReferenceBinding)annotation.resolvedType).availableMethods();
+																				if(methodBindings != null &&
+																						methodBindings.length == 1 &&
+																						CharOperation.equals(methodBindings[0].selector, VALUE)) {
+																					if(this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
+																						findTypesAndPackages(this.completionToken, scope);
+																					} else {
+																						findVariablesAndMethods(
+																							this.completionToken,
+																							scope,
+																							FakeInvocationSite,
+																							scope,
+																							insideTypeAnnotation,
+																							true);
+																						// can be the start of a qualified type name
+																						findTypesAndPackages(this.completionToken, scope);
+																					}
+																				}
+																			}
+																			
+																		}
 																	}
 																}
 															}
@@ -960,7 +1000,7 @@ public final class CompletionEngine
 						if (e.astNode != null) {
 							contextAccepted = true;
 							// if null then we found a problem in the completion node
-							complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope);
+							complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope, e.insideTypeAnnotation);
 						}
 					}
 				}
@@ -1164,7 +1204,7 @@ public final class CompletionEngine
 							}
 							contextAccepted = true;
 							// if null then we found a problem in the completion node
-							complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope);
+							complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope, e.insideTypeAnnotation);
 						}
 					}
 				}
@@ -3922,7 +3962,9 @@ public final class CompletionEngine
 		char[] token,
 		Scope scope,
 		InvocationSite invocationSite,
-		Scope invocationScope) {
+		Scope invocationScope,
+		boolean insideTypeAnnotation,
+		boolean insideAnnotationAttribute) {
 
 		if (token == null)
 			return;
@@ -4042,36 +4084,39 @@ public final class CompletionEngine
 											findMethods(token, enclosingType.methods(), classScope, methodsFound, staticsOnly, false);
 											break done;
 										} else { */
-						if(proposeField) {
-							findFields(
-								token,
-								enclosingType,
-								classScope,
-								fieldsFound,
-								localsFound,
-								staticsOnly,
-								invocationSite,
-								invocationScope,
-								true,
-								true);
-						}
-						if(proposeMethod) {
-							findMethods(
-								token,
-								null,
-								enclosingType,
-								classScope,
-								methodsFound,
-								staticsOnly,
-								false,
-								false,
-								invocationSite,
-								invocationScope,
-								true,
-								false,
-								true);
+						if(!insideTypeAnnotation) {
+							if(proposeField) {
+								findFields(
+									token,
+									enclosingType,
+									classScope,
+									fieldsFound,
+									localsFound,
+									staticsOnly,
+									invocationSite,
+									invocationScope,
+									true,
+									true);
+							}
+							if(proposeMethod && !insideAnnotationAttribute) {
+								findMethods(
+									token,
+									null,
+									enclosingType,
+									classScope,
+									methodsFound,
+									staticsOnly,
+									false,
+									false,
+									invocationSite,
+									invocationScope,
+									true,
+									false,
+									true);
+							}
 						}
 						staticsOnly |= enclosingType.isStatic();
+						insideTypeAnnotation = false;
 						//				}
 						break;
 	
@@ -4102,7 +4147,7 @@ public final class CompletionEngine
 										true,
 										false);
 								}
-								if(proposeMethod) {
+								if(proposeMethod && !insideAnnotationAttribute) {
 									findMethods(
 										token,
 										null,
@@ -4136,7 +4181,7 @@ public final class CompletionEngine
 												false);
 								}
 							} else if ((binding.kind() & Binding.METHOD) != 0) {
-								if(proposeMethod) {
+								if(proposeMethod && !insideAnnotationAttribute) {
 									MethodBinding methodBinding = (MethodBinding)binding;
 									if(CharOperation.prefixEquals(token, methodBinding.selector))
 										
@@ -4499,6 +4544,25 @@ public final class CompletionEngine
 					}
 				}
 			}
+		} else if(parent instanceof MemberValuePair) {
+			MemberValuePair memberValuePair = (MemberValuePair) parent;
+			if(memberValuePair.binding != null) {
+				addExpectedType(memberValuePair.binding.returnType);
+			}
+		} else if (parent instanceof NormalAnnotation) {
+			NormalAnnotation annotation = (NormalAnnotation) parent;
+			MemberValuePair[] memberValuePairs = annotation.memberValuePairs();
+			if(memberValuePairs == null || memberValuePairs.length == 0) {
+				if(annotation.resolvedType instanceof ReferenceBinding) {
+					MethodBinding[] methodBindings =
+						((ReferenceBinding)annotation.resolvedType).availableMethods();
+					if(methodBindings != null &&
+							methodBindings.length == 1 &&
+							CharOperation.equals(methodBindings[0].selector, VALUE)) {
+						addExpectedType(methodBindings[0].returnType);
+					}
+				}
+			}
 		}
 		
 		if(this.expectedTypesPtr + 1 != this.expectedTypes.length) {
@@ -4688,6 +4752,12 @@ public final class CompletionEngine
 				}
 			}
 		}
+//		else if(scope instanceof MethodScope) {
+//			MethodScope methodScope = (MethodScope) scope;
+//			if(methodScope.insideTypeAnnotation) {
+//				return methodScope.parent.parent;
+//			}
+//		}
 		return scope;
 	}
 	private char[] computePrefix(SourceTypeBinding declarationType, SourceTypeBinding invocationType, boolean isStatic){
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeDetector.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeDetector.java
index 86e2405..a7ae738 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeDetector.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeDetector.java
@@ -152,6 +152,12 @@ public class CompletionNodeDetector extends ASTVisitor {
 	public void endVisit(UnaryExpression unaryExpression, BlockScope scope) {
 		endVisit(unaryExpression);
 	}
+	public void endVisit(MemberValuePair pair, BlockScope scope) {
+		endVisit(pair);
+	}
+	public void endVisit(MemberValuePair pair, CompilationUnitScope scope) {
+		endVisit(pair);
+	}
 	public boolean visit(AllocationExpression allocationExpression, BlockScope scope) {
 		return this.visit(allocationExpression);
 	}
@@ -266,7 +272,12 @@ public class CompletionNodeDetector extends ASTVisitor {
 	public boolean visit(UnaryExpression unaryExpression, BlockScope scope) {
 		return this.visit(unaryExpression);
 	}
-	
+	public boolean visit(MemberValuePair pair, BlockScope scope) {
+		return this.visit(pair);
+	}
+	public boolean visit(MemberValuePair pair, CompilationUnitScope scope) {
+		return this.visit(pair);
+	}
 	private void endVisit(ASTNode astNode) {
 		if(this.result && this.parent == null && astNode != this.searchedNode) {
 			if(!(astNode instanceof AllocationExpression && ((AllocationExpression) astNode).type == this.searchedNode)
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeFound.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeFound.java
index 6af9dfd..8fbd908 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeFound.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionNodeFound.java
@@ -19,18 +19,26 @@ public class CompletionNodeFound extends RuntimeException {
 	public ASTNode astNode;
 	public Binding qualifiedBinding;
 	public Scope scope;
+	public boolean insideTypeAnnotation = false;
 
 	private static final long serialVersionUID = 6981437684184091462L; // backward compatible
 	
 public CompletionNodeFound() {
-	this(null, null, null); // we found a problem in the completion node
+	this(null, null, null, false); // we found a problem in the completion node
 }
 public CompletionNodeFound(ASTNode astNode, Binding qualifiedBinding, Scope scope) {
+	this(astNode, qualifiedBinding, scope, false);
+}
+public CompletionNodeFound(ASTNode astNode, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
 	this.astNode = astNode;
 	this.qualifiedBinding = qualifiedBinding;
 	this.scope = scope;
+	this.insideTypeAnnotation = insideTypeAnnotation;
 }
 public CompletionNodeFound(ASTNode astNode, Scope scope) {
-	this(astNode, null, scope);
+	this(astNode, null, scope, false);
+}
+public CompletionNodeFound(ASTNode astNode, Scope scope, boolean insideTypeAnnotation) {
+	this(astNode, null, scope, insideTypeAnnotation);
 }
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMarkerAnnotationName.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMarkerAnnotationName.java
index 0162232..a67e4ad 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMarkerAnnotationName.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMarkerAnnotationName.java
@@ -11,7 +11,9 @@
 package org.eclipse.jdt.internal.codeassist.complete;
 
 import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
@@ -21,6 +23,15 @@ public class CompletionOnMarkerAnnotationName extends MarkerAnnotation {
 	}
 	
 	public TypeBinding resolveType(BlockScope scope) {
+		if(type instanceof QualifiedTypeReference) {
+			QualifiedTypeReference qualifiedTypeReference = (QualifiedTypeReference) type;
+			Binding binding = scope.parent.getTypeOrPackage(qualifiedTypeReference.tokens); // step up from the ClassScope
+			if (!binding.isValidBinding()) {
+				scope.problemReporter().invalidType(this, (TypeBinding) binding);
+				throw new CompletionNodeFound();
+			}
+			throw new CompletionNodeFound(this, binding, scope);
+		}
 		throw new CompletionNodeFound(this, null, scope);
 	}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
index 9215de8..fa5efef 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
@@ -38,9 +38,11 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 
 public class CompletionOnQualifiedNameReference extends QualifiedNameReference {
 	public char[] completionIdentifier;
-public CompletionOnQualifiedNameReference(char[][] previousIdentifiers, char[] completionIdentifier, long[] positions) {
+	public boolean isInsideAnnotationAttribute;
+public CompletionOnQualifiedNameReference(char[][] previousIdentifiers, char[] completionIdentifier, long[] positions, boolean isInsideAnnotationAttribute) {
 	super(previousIdentifiers, positions, (int) (positions[0] >>> 32), (int) positions[positions.length - 1]);
 	this.completionIdentifier = completionIdentifier;
+	this.isInsideAnnotationAttribute = isInsideAnnotationAttribute;
 }
 public StringBuffer printExpression(int indent, StringBuffer output) {
 
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnSingleNameReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnSingleNameReference.java
index 12d1f22..d69aac2 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnSingleNameReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnSingleNameReference.java
@@ -38,15 +38,17 @@ public class CompletionOnSingleNameReference extends SingleNameReference {
 
 	public char[][] possibleKeywords;
 	public boolean canBeExplicitConstructor;
+	public boolean isInsideAnnotationAttribute;
 
-	public CompletionOnSingleNameReference(char[] source, long pos) {
-		this(source, pos, null, false);
+	public CompletionOnSingleNameReference(char[] source, long pos, boolean isInsideAnnotationAttribute) {
+		this(source, pos, null, false, isInsideAnnotationAttribute);
 	}
 
-	public CompletionOnSingleNameReference(char[] source, long pos, char[][] possibleKeywords, boolean canBeExplicitConstructor) {
+	public CompletionOnSingleNameReference(char[] source, long pos, char[][] possibleKeywords, boolean canBeExplicitConstructor, boolean isInsideAnnotationAttribute) {
 		super(source, pos);
 		this.possibleKeywords = possibleKeywords;
 		this.canBeExplicitConstructor = canBeExplicitConstructor;
+		this.isInsideAnnotationAttribute = isInsideAnnotationAttribute;
 	}
 
 	public StringBuffer printExpression(int indent, StringBuffer output) {
@@ -56,6 +58,9 @@ public class CompletionOnSingleNameReference extends SingleNameReference {
 	}
 
 	public TypeBinding resolveType(BlockScope scope) {
+		if(scope instanceof MethodScope) {
+			throw new CompletionNodeFound(this, scope, ((MethodScope)scope).insideTypeAnnotation);
+		}
 		throw new CompletionNodeFound(this, scope);
 	}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 84115c8..02f5f3a 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -67,9 +67,9 @@ public class CompletionParser extends AssistParser {
 	protected static final int K_PARAMETERIZED_ALLOCATION = COMPLETION_PARSER + 31;
 	protected static final int K_PARAMETERIZED_CAST = COMPLETION_PARSER + 32;
 	protected static final int K_BETWEEN_ANNOTATION_NAME_AND_RPAREN = COMPLETION_PARSER + 33;
-	protected static final int K_ANNOTATION_ASSIGNMENT_OPERATOR = COMPLETION_PARSER + 34;
 
 	public final static char[] FAKE_TYPE_NAME = new char[]{' '};
+	public final static char[] VALUE = new char[]{'v', 'a', 'l', 'u', 'e'};
 	
 	/* public fields */
 
@@ -244,7 +244,56 @@ protected void attachOrphanCompletionNode(){
 						
 						buildMoreAnnotationCompletionContext(memberValueName);
 						return;
+					} else if (expression instanceof QualifiedNameReference) {
+						MemberValuePair valuePair =
+							new MemberValuePair(VALUE, expression.sourceStart, expression.sourceEnd, expression);
+						buildMoreAnnotationCompletionContext(valuePair);
 					}
+				} else {
+					int index;
+					if((index = lastIndexOfElement(K_ATTRIBUTE_VALUE_DELIMITER)) != -1) {
+						int attributeIndentifierPtr = this.elementInfoStack[index];
+						int identLengthPtr = this.identifierLengthPtr;
+						int identPtr = this.identifierPtr;
+						while (attributeIndentifierPtr < identPtr) {
+							identPtr -= this.identifierLengthStack[identLengthPtr--];
+						}
+						
+						if(attributeIndentifierPtr != identPtr) return;
+						
+						this.identifierLengthPtr = identLengthPtr;
+						this.identifierPtr = identPtr;
+						
+						this.identifierLengthPtr--;
+						MemberValuePair memberValuePair = new MemberValuePair(
+								this.identifierStack[this.identifierPtr--],
+								expression.sourceStart,
+								expression.sourceEnd,
+								expression);
+						
+						buildMoreAnnotationCompletionContext(memberValuePair);
+						return;
+					}
+				}
+			} else {
+				CompletionNodeDetector detector =  new CompletionNodeDetector(this.assistNode, expression);
+				if(detector.containsCompletionNode()) {
+					MemberValuePair valuePair =
+						new MemberValuePair(VALUE, expression.sourceStart, expression.sourceEnd, expression);
+					buildMoreAnnotationCompletionContext(valuePair);
+				}
+			}
+		}
+		
+		if (this.astPtr > -1) {
+			ASTNode node = this.astStack[this.astPtr];
+			if(node instanceof MemberValuePair) {
+				MemberValuePair memberValuePair = (MemberValuePair) node;
+				CompletionNodeDetector detector =  new CompletionNodeDetector(this.assistNode, memberValuePair);
+				if(detector.containsCompletionNode()) {
+					buildMoreAnnotationCompletionContext(memberValuePair);
+					this.assistNodeParent = detector.getCompletionNodeParent();
+					return;
 				}
 			}
 		}
@@ -307,7 +356,7 @@ protected void attachOrphanCompletionNode(){
 	}
 	
 	// the following code applies only in methods, constructors or initializers
-	if ((!isInsideMethod() && !isInsideFieldInitialization())) { 
+	if ((!isInsideMethod() && !isInsideFieldInitialization() && !isInsideAttributeValue())) { 
 		return;
 	}
 	
@@ -372,33 +421,67 @@ private void buildMoreAnnotationCompletionContext(MemberValuePair memberValuePai
 	
 	int nodesToRemove = this.astPtr > -1 && this.astStack[this.astPtr] == memberValuePair ? 1 : 0;
 
-	MemberValuePair[] memberValuePairs = null;
-	int length;
-	if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) > nodesToRemove) {
-		if (this.astStack[this.astPtr] instanceof MemberValuePair) {
-			System.arraycopy(
-				this.astStack, 
-				(this.astPtr -= length) + 1, 
-				memberValuePairs = new MemberValuePair[length - nodesToRemove], 
-				0, 
-				length - nodesToRemove); 
+	NormalAnnotation annotation;
+	if (memberValuePair instanceof CompletionOnMemberValueName) { 
+		MemberValuePair[] memberValuePairs = null;
+		int length;
+		if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) > nodesToRemove) {
+			if (this.astStack[this.astPtr] instanceof MemberValuePair) {
+				System.arraycopy(
+					this.astStack, 
+					(this.astPtr -= length) + 1, 
+					memberValuePairs = new MemberValuePair[length - nodesToRemove], 
+					0, 
+					length - nodesToRemove); 
+			}
 		}
+		annotation =
+			new CompletionOnAnnotationMemberValuePair(
+					typeReference,
+					this.intStack[this.intPtr--],
+					memberValuePairs,
+					memberValuePair);
+		
+		this.assistNode = memberValuePair;
+		this.assistNodeParent = annotation;
+		
+		if (memberValuePair.sourceEnd >= this.lastCheckPoint) {
+			this.lastCheckPoint = memberValuePair.sourceEnd + 1;
+		}
+	} else {
+		MemberValuePair[] memberValuePairs = null;
+		int length = 0;
+		if (astLengthPtr > -1 && (length = this.astLengthStack[this.astLengthPtr--]) > nodesToRemove) {
+			if (this.astStack[this.astPtr] instanceof MemberValuePair) {
+				System.arraycopy(
+					this.astStack, 
+					(this.astPtr -= length) + 1, 
+					memberValuePairs = new MemberValuePair[length - nodesToRemove + 1], 
+					0, 
+					length - nodesToRemove); 
+			}
+			if(memberValuePairs != null) {
+				memberValuePairs[length - nodesToRemove] = memberValuePair;
+			} else {
+				memberValuePairs = new MemberValuePair[]{memberValuePair};
+			}
+		} else {
+			memberValuePairs = new MemberValuePair[]{memberValuePair};
+		}
+		
+		annotation =
+			new NormalAnnotation(
+					typeReference,
+					this.intStack[this.intPtr--]);
+		annotation.memberValuePairs = memberValuePairs;
+					
 	}
-	
-	CompletionOnAnnotationMemberValuePair annotation =
-		new CompletionOnAnnotationMemberValuePair(typeReference, this.intStack[this.intPtr--], memberValuePairs, memberValuePair);
 	TypeDeclaration fakeType =
 		new CompletionOnAnnotationOfType(
 				FAKE_TYPE_NAME, 
 				this.compilationUnit.compilationResult(),
 				annotation);
 	
-	this.assistNode = memberValuePair;
-	this.assistNodeParent = annotation;
-	if (memberValuePair.sourceEnd >= this.lastCheckPoint) {
-		this.lastCheckPoint = memberValuePair.sourceEnd + 1;
-	}
-	
 	currentElement.add(fakeType, 0);
 }
 private void buildMoreCompletionContext(Expression expression) {
@@ -1286,7 +1369,8 @@ public void completionIdentifierCheck(){
 
 	// if not in a method in non diet mode and if not inside a field initializer, only record references attached to types
 	if (!(isInsideMethod() && !this.diet)
-		&& !isIndirectlyInsideFieldInitialization()) return; 
+		&& !isIndirectlyInsideFieldInitialization()
+		&& !isInsideAttributeValue()) return; 
 
 	/*
 	 	In some cases, the completion identifier may not have yet been consumed,
@@ -2095,8 +2179,11 @@ protected void consumeMarkerAnnotation() {
 protected void consumeMemberValuePair() {
 	/* check if current awaiting identifier is the completion identifier */
 	if (this.indexOfAssistIdentifier() < 0){
-		this.popElement(K_ANNOTATION_ASSIGNMENT_OPERATOR);
 		super.consumeMemberValuePair();
+		MemberValuePair memberValuePair = (MemberValuePair) this.astStack[this.astPtr];
+		if(this.assistNode != null && memberValuePair.value == this.assistNode) {
+			this.assistNodeParent = memberValuePair;
+		}
 		return;
 	}
 	
@@ -2203,7 +2290,7 @@ protected void consumeToken(int token) {
 	int previous = this.previousToken;
 	int prevIdentifierPtr = this.previousIdentifierPtr;
 	
-	if (isInsideMethod() || isInsideFieldInitialization()) {
+	if (isInsideMethod() || isInsideFieldInitialization() || isInsideAnnotation()) {
 		switch(token) {
 			case TokenNameLPAREN:
 				popElement(K_BETWEEN_NEW_AND_LEFT_BRACKET);
@@ -2233,14 +2320,6 @@ protected void consumeToken(int token) {
 		}
 	}
 	super.consumeToken(token);
-
-	switch(token) {
-		case TokenNameEQUAL:
-			if(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN) {
-				pushOnElementStack(K_ANNOTATION_ASSIGNMENT_OPERATOR);
-			}
-			break;
-	}
 	
 	// if in field initializer (directly or not), on the completion identifier and not in recovery mode yet
 	// then position end of file at cursor location (so that we have the same behavior as
@@ -2253,7 +2332,7 @@ protected void consumeToken(int token) {
 	}
 	
 	// if in a method or if in a field initializer 
-	if (isInsideMethod() || isInsideFieldInitialization()) {
+	if (isInsideMethod() || isInsideFieldInitialization() || isInsideAttributeValue()) {
 		switch (token) {
 			case TokenNameDOT:
 				switch (previous) {
@@ -2743,7 +2822,8 @@ public NameReference createQualifiedAssistNameReference(char[][] previousIdentif
 	return new CompletionOnQualifiedNameReference(
 					previousIdentifiers, 
 					assistName, 
-					positions); 	
+					positions,
+					isInsideAttributeValue()); 	
 }
 public TypeReference createQualifiedAssistTypeReference(char[][] previousIdentifiers, char[] assistName, long[] positions){
 	switch (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER)) {
@@ -2801,7 +2881,7 @@ public TypeReference createParameterizedQualifiedAssistTypeReference(char[][] pr
 public NameReference createSingleAssistNameReference(char[] assistName, long position) {
 	int kind = topKnownElementKind(COMPLETION_OR_ASSIST_PARSER);
 	if(!isInsideMethod()) {
-		return new CompletionOnSingleNameReference(assistName, position);
+		return new CompletionOnSingleNameReference(assistName, position, isInsideAttributeValue());
 	} else {
 		boolean canBeExplicitConstructorCall = false;
 		if(kind == K_BLOCK_DELIMITER
@@ -2876,7 +2956,7 @@ public NameReference createSingleAssistNameReference(char[] assistName, long pos
 			}
 			System.arraycopy(keywords, 0 , keywords = new char[count][], 0, count);
 			
-			return new CompletionOnSingleNameReference(assistName, position, keywords, canBeExplicitConstructorCall);
+			return new CompletionOnSingleNameReference(assistName, position, keywords, canBeExplicitConstructorCall, isInsideAttributeValue());
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 066c8bc..eebf89a 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -73,6 +73,7 @@ public abstract class AssistParser extends Parser {
 	protected static final int K_TYPE_DELIMITER = ASSIST_PARSER + 2; // whether we are inside a type declaration
 	protected static final int K_METHOD_DELIMITER = ASSIST_PARSER + 3; // whether we are inside a method declaration
 	protected static final int K_FIELD_INITIALIZER_DELIMITER = ASSIST_PARSER + 4; // whether we are inside a field initializer
+	protected static final int K_ATTRIBUTE_VALUE_DELIMITER = ASSIST_PARSER + 5; // whether we are inside a annotation attribute valuer
 	
 	// selector constants
 	protected static final int THIS_CONSTRUCTOR = -1;
@@ -274,10 +275,18 @@ protected void consumeEnterAnonymousClassBody() {
 	popElement(K_SELECTOR);
 	pushOnElementStack(K_TYPE_DELIMITER);
 }
+protected void consumeEnterMemberValue() {
+	super.consumeEnterMemberValue();
+	pushOnElementStack(K_ATTRIBUTE_VALUE_DELIMITER, this.identifierPtr);
+}
 protected void consumeEnumHeader() {
 	super.consumeEnumHeader();
 	pushOnElementStack(K_TYPE_DELIMITER);
 }
+protected void consumeExitMemberValue() {
+	super.consumeExitMemberValue();
+	popElement(K_ATTRIBUTE_VALUE_DELIMITER);
+}
 protected void consumeExplicitConstructorInvocation(int flag, int recFlag) {
 	super.consumeExplicitConstructorInvocation(flag, recFlag);
 	popElement(K_SELECTOR);
@@ -671,7 +680,7 @@ protected void consumeToken(int token) {
 	}
 	// register message send selector only if inside a method or if looking at a field initializer 
 	// and if the current token is an open parenthesis
-	if (isInsideMethod() || isInsideFieldInitialization()) {
+	if (isInsideMethod() || isInsideFieldInitialization() || isInsideAttributeValue()) {
 		switch (token) {
 			case TokenNameLPAREN :
 				switch (this.previousToken) {
@@ -1071,6 +1080,19 @@ protected boolean isIndirectlyInsideType(){
 	}
 	return false;
 }
+protected boolean isInsideAttributeValue(){
+	int i = elementPtr;
+	while(i > -1) {
+		switch (elementKindStack[i]) {
+			case K_TYPE_DELIMITER : return false;
+			case K_METHOD_DELIMITER : return false;
+			case K_FIELD_INITIALIZER_DELIMITER : return false;
+			case K_ATTRIBUTE_VALUE_DELIMITER : return true;
+		}
+		i--;
+	}
+	return false;
+}
 protected boolean isInsideFieldInitialization(){
 	int i = elementPtr;
 	while(i > -1) {
@@ -1411,7 +1433,7 @@ public void recoveryTokenCheck() {
 			break;
 		case TokenNameRBRACE :
 			super.recoveryTokenCheck();
-			if(currentElement != oldElement) {
+			if(currentElement != oldElement && !isInsideAttributeValue()) {
 				if(oldElement instanceof RecoveredInitializer
 					|| oldElement instanceof RecoveredMethod
 					|| (oldElement instanceof RecoveredBlock && oldElement.parent instanceof RecoveredInitializer)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index f98e28c..6a62f7e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -2587,6 +2587,13 @@ protected void consumeEnterCompilationUnit() {
 	// EnterCompilationUnit ::= $empty
 	// do nothing by default
 }
+protected void consumeEnterMemberValue() {
+	// EnterMemberValue ::= $empty
+	if(this.currentElement != null && this.currentToken == TokenNameLBRACE) {
+		this.ignoreNextOpeningBrace = true;
+		this.currentElement.bracketBalance++; 
+	}
+}
 protected void consumeEnterVariable() {
 	// EnterVariable ::= $empty
 	// do nothing by default
@@ -2988,6 +2995,10 @@ protected void consumeEqualityExpressionWithName(int op) {
 			this.expressionStack[this.expressionPtr],
 			op);
 }
+protected void consumeExitMemberValue() {
+	// ExitMemberValue ::= $empty
+	// do nothing by default
+}
 protected void consumeExitTryBlock() {
 	//ExitTryBlock ::= $empty
 	if(this.currentElement != null) {
@@ -6083,55 +6094,63 @@ protected void consumeRule(int act) {
 		    consumeMemberValuePairs() ;  
 			break;
  
-    case 673 : if (DEBUG) { System.out.println("MemberValuePair ::= SimpleName EQUAL MemberValue"); }  //$NON-NLS-1$
+    case 673 : if (DEBUG) { System.out.println("MemberValuePair ::= SimpleName EQUAL EnterMemberValue..."); }  //$NON-NLS-1$
 		    consumeMemberValuePair() ;  
 			break;
  
-    case 675 : if (DEBUG) { System.out.println("MemberValue ::= Name"); }  //$NON-NLS-1$
+    case 674 : if (DEBUG) { System.out.println("EnterMemberValue ::="); }  //$NON-NLS-1$
+		    consumeEnterMemberValue() ;  
+			break;
+ 
+    case 675 : if (DEBUG) { System.out.println("ExitMemberValue ::="); }  //$NON-NLS-1$
+		    consumeExitMemberValue() ;  
+			break;
+ 
+    case 677 : if (DEBUG) { System.out.println("MemberValue ::= Name"); }  //$NON-NLS-1$
 		    consumeMemberValueAsName() ;  
 			break;
  
-    case 678 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 680 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeMemberValueArrayInitializer() ;  
 			break;
  
-    case 679 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 681 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeMemberValueArrayInitializer() ;  
 			break;
  
-    case 680 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 682 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeEmptyMemberValueArrayInitializer() ;  
 			break;
  
-    case 681 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
+    case 683 : if (DEBUG) { System.out.println("MemberValueArrayInitializer ::= LBRACE PushLeftBrace..."); }  //$NON-NLS-1$
 		    consumeEmptyMemberValueArrayInitializer() ;  
 			break;
  
-    case 683 : if (DEBUG) { System.out.println("MemberValues ::= MemberValues COMMA MemberValue"); }  //$NON-NLS-1$
+    case 685 : if (DEBUG) { System.out.println("MemberValues ::= MemberValues COMMA MemberValue"); }  //$NON-NLS-1$
 		    consumeMemberValues() ;  
 			break;
  
-    case 684 : if (DEBUG) { System.out.println("MarkerAnnotation ::= AnnotationName"); }  //$NON-NLS-1$
+    case 686 : if (DEBUG) { System.out.println("MarkerAnnotation ::= AnnotationName"); }  //$NON-NLS-1$
 		    consumeMarkerAnnotation() ;  
 			break;
  
-    case 685 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
+    case 687 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
 		    consumeSingleMemberAnnotation() ;  
 			break;
  
-    case 686 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
+    case 688 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderNameWithTypeParameters();  
 			break;
  
-    case 687 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
+    case 689 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderName();  
 			break;
  
-    case 688 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 690 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
-    case 689 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 691 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
index fab7e9a..b277b64 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
@@ -16,20 +16,20 @@ public interface ParserBasicInformation {
 
 	int ERROR_SYMBOL = 110,
 		MAX_NAME_LENGTH = 41,
-		NUM_STATES = 951,
+		NUM_STATES = 953,
 
 		NT_OFFSET = 110,
 		SCOPE_UBOUND = 131,
 		SCOPE_SIZE = 132,
-		LA_STATE_OFFSET = 12566,
+		LA_STATE_OFFSET = 12568,
 		MAX_LA = 1,
-		NUM_RULES = 689,
+		NUM_RULES = 691,
 		NUM_TERMINALS = 110,
-		NUM_NON_TERMINALS = 304,
-		NUM_SYMBOLS = 414,
-		START_STATE = 1043,
+		NUM_NON_TERMINALS = 306,
+		NUM_SYMBOLS = 416,
+		START_STATE = 1045,
 		EOFT_SYMBOL = 66,
 		EOLT_SYMBOL = 66,
-		ACCEPT_ACTION = 12565,
-		ERROR_ACTION = 12566;
+		ACCEPT_ACTION = 12567,
+		ERROR_ACTION = 12568;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
index d37b95b..f08b9bf 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
index c4faddb..d62f283 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
index 0cf6300..9a18dbc 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
index 1ad1103..5e93598 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
index c422998..1365bda 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
index 948b77a..f088262 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
index 61c6fd9..79d03fc 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
index 28b1f50..0a15223 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
index ef16112..920127b 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
index 95f0dca..d383385 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
index 9ce9736..355084e 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
index 630ef92..0000f7c 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
index 310f362..5379910 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
index 7616760..4a50e3d 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
index 6052883..dbe7834 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
@@ -96,6 +96,7 @@ EnhancedForStatementHeader=EnhancedForStatementHeader
 EnhancedForStatementNoShortIf=EnhancedForStatementNoShortIf
 EnterAnonymousClassBody=EnterAnonymousClassBody
 EnterCompilationUnit=EnterCompilationUnit
+EnterMemberValue=EnterMemberValue
 EnterVariable=EnterVariable
 EnumBody=EnumBody
 EnumBodyDeclarationsopt=EnumBodyDeclarationsopt
@@ -111,6 +112,7 @@ EqualityExpression=Expression
 EqualityExpression_NotName=Expression
 ExclusiveOrExpression=Expression
 ExclusiveOrExpression_NotName=Expression
+ExitMemberValue=ExitMemberValue
 ExitTryBlock=ExitTryBlock
 ExitVariableWithInitialization=ExitVariableWithInitialization
 ExitVariableWithoutInitialization=ExitVariableWithoutInitialization
diff --git a/org.eclipse.jdt.core/grammar/java_1_5.g b/org.eclipse.jdt.core/grammar/java_1_5.g
index 0600bc9..fb13d07 100644
--- a/org.eclipse.jdt.core/grammar/java_1_5.g
+++ b/org.eclipse.jdt.core/grammar/java_1_5.g
@@ -2128,11 +2128,21 @@ MemberValuePairs ::= MemberValuePairs ',' MemberValuePair
 /:$readableName MemberValuePairs:/
 /:$compliance 1.5:/
 
-MemberValuePair ::= SimpleName '=' MemberValue
+MemberValuePair ::= SimpleName '=' EnterMemberValue MemberValue ExitMemberValue
 /.$putCase consumeMemberValuePair() ; $break ./
 /:$readableName MemberValuePair:/
 /:$compliance 1.5:/
 
+EnterMemberValue ::= $empty
+/.$putCase consumeEnterMemberValue() ; $break ./
+/:$readableName EnterMemberValue:/
+/:$compliance 1.5:/
+
+ExitMemberValue ::= $empty
+/.$putCase consumeExitMemberValue() ; $break ./
+/:$readableName ExitMemberValue:/
+/:$compliance 1.5:/
+
 MemberValue -> ConditionalExpression_NotName
 /:$compliance 1.5:/
 MemberValue ::= Name
