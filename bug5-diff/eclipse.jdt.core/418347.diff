commit e1bb62a6f97249ff77a2f0164d289109644f1d09
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Wed Oct 2 14:13:30 2013 +0530

    Fixed Bug 418347 - [1.8][compiler] Type annotations from SE7 locations
    not handled properly during code generation.

3	12	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
178	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
12	8	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
3	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
97	404	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
0	43	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
30	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
15	36	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
4	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
9	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
index aeef8a3..4ffc3d4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
@@ -61,7 +61,6 @@ public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
 	}
 	
 	static final class LocationPrinterVisitor extends ASTVisitor {
-		Annotation[] primaryAnnotations;
 		TypeReference enclosingReference;
 		Map locations;
 
@@ -73,13 +72,10 @@ public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
 			return this.locations;
 		}
 		public boolean visit(FieldDeclaration fieldDeclaration, MethodScope scope) {
-			Annotation[] annotations = fieldDeclaration.annotations;
 			this.enclosingReference = fieldDeclaration.type;
-			this.primaryAnnotations = annotations;
 			return true;
 		}
 		public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
-			this.primaryAnnotations = methodDeclaration.annotations;
 			TypeReference returnType = methodDeclaration.returnType;
 			if (returnType != null) {
 				this.enclosingReference = returnType;
@@ -90,39 +86,34 @@ public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
 				for (int i = 0; i < thrownExceptionsLength; i++) {
 					TypeReference typeReference = methodDeclaration.thrownExceptions[i];
 					this.enclosingReference = typeReference;
-					this.primaryAnnotations = null;
 					typeReference.traverse(this, scope);
 				}
 			}
 			return false;
 		}
 		public boolean visit(Argument argument, ClassScope scope) {
-			Annotation[] annotations = argument.annotations;
 			this.enclosingReference = argument.type;
-			this.primaryAnnotations = annotations;
 			return true;
 		}
 		public boolean visit(Argument argument, BlockScope scope) {
-			Annotation[] annotations = argument.annotations;
 			this.enclosingReference = argument.type;
-			this.primaryAnnotations = annotations;
 			return true;
 		}
 		public boolean visit(MarkerAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
 			}
 			return false;
 		}
 		public boolean visit(SingleMemberAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
 			}
 			return false;
 		}
 		public boolean visit(NormalAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
 			}
 			return false;
 		}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
index f556c7f..859c039 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
@@ -5690,5 +5690,183 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 					"}";
 			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418347,  [1.8][compiler] Type annotations dropped during code generation.
+	public void testPQTRArray() throws Exception {
+		this.runConformTest(
+				new String[] {
+						"Outer.java",
+						"public class Outer<K>  {\n" +
+						"	class Inner<P> {\n" +
+						"	}\n" +
+						"	public @T(1) Outer<@T(2) String>.@T(3) Inner<@T(4) Integer> @T(5) [] omi @T(6) [];\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface T {\n" +
+						"	int value();\n" +
+						"}\n",
+			},
+			"");
+			String expectedOutput =
+					"  public Outer$Inner[][] omi;\n" + 
+					"    RuntimeInvisibleTypeAnnotations: \n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 5 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 6 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, TYPE_ARGUMENT(0)]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 4 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+					"      )\n" + 
+					"  \n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "Outer.class", "Outer", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418347,  [1.8][compiler] Type annotations dropped during code generation.
+	public void testPQTRArray2() throws Exception {
+		this.runConformTest(
+				new String[] {
+						"Outer.java",
+						"public class Outer<K1, K2>  {\n" +
+						"	class Inner<P1, P2> {\n" +
+						"	}\n" +
+						"	public @T(1) Outer<@T(2) String, @T(3) Inner>.@T(4) Inner<@T(5) Integer, @T(6) Outer.@T(7) Inner> @T(7) [] omi @T(8) [];\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface T {\n" +
+						"	int value();\n" +
+						"}\n",
+			},
+			"");
+			String expectedOutput =
+					"  // Field descriptor #6 [[LOuter$Inner;\n" + 
+					"  // Signature: [[LOuter<Ljava/lang/String;LOuter$Inner;>.Inner<Ljava/lang/Integer;LOuter$Inner;>;\n" + 
+					"  public Outer$Inner[][] omi;\n" + 
+					"    RuntimeInvisibleTypeAnnotations: \n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 4 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 7 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 8 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, TYPE_ARGUMENT(0)]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, TYPE_ARGUMENT(1), INNER_TYPE]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 5 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 6 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(1)]\n" + 
+					"      )\n" + 
+					"      #10 @T(\n" + 
+					"        #11 value=(int) 7 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(1), INNER_TYPE]\n" + 
+					"      )\n" + 
+					"  \n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "Outer.class", "Outer", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418347,  [1.8][compiler] Type annotations dropped during code generation.
+	public void testConstructorResult() throws Exception {
+		this.runConformTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface T {\n" +
+						"}\n" +
+						"public class X {\n" +
+						"	@T X() {}\n" +
+						"	class Y {\n" +
+						"	 @T Y () {\n" +
+						"	}\n" +
+						"	}\n" +
+						"}\n",
+			},
+			"");
+			String expectedOutput =
+					"  // Method descriptor #6 ()V\n" + 
+					"  // Stack: 1, Locals: 1\n" + 
+					"  X();\n" + 
+					"    0  aload_0 [this]\n" + 
+					"    1  invokespecial java.lang.Object() [8]\n" + 
+					"    4  return\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 7]\n" + 
+					"      Local variable table:\n" + 
+					"        [pc: 0, pc: 5] local: this index: 0 type: X\n" + 
+					"    RuntimeInvisibleTypeAnnotations: \n" + 
+					"      #15 @T(\n" + 
+					"        target type = 0x14 METHOD_RETURN\n" + 
+					"      )\n" + 
+					"\n";
+			String expectedOutForY = 
+					"  // Method descriptor #8 (LX;)V\n" + 
+					"  // Stack: 2, Locals: 2\n" + 
+					"  X$Y(X arg0);\n" + 
+					"     0  aload_0 [this]\n" + 
+					"     1  aload_1 [arg0]\n" + 
+					"     2  putfield X$Y.this$0 : X [10]\n" + 
+					"     5  aload_0 [this]\n" + 
+					"     6  invokespecial java.lang.Object() [12]\n" + 
+					"     9  return\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 9]\n" + 
+					"        [pc: 9, line: 10]\n" + 
+					"      Local variable table:\n" + 
+					"        [pc: 0, pc: 10] local: this index: 0 type: X.Y\n" + 
+					"    RuntimeInvisibleTypeAnnotations: \n" + 
+					"      #20 @T(\n" + 
+					"        target type = 0x14 METHOD_RETURN\n" + 
+					"      )\n" + 
+					"\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X$Y.class", "Y", expectedOutForY, ClassFileBytesDisassembler.SYSTEM);
+	}
 }
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
index f32596b..3983a9a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -1093,7 +1093,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 	public void _testAnnotatedBinaryMemberType() throws CoreException, IOException {
 		String jarName = "TypeBindingTests308.jar";
 		String srcName = "TypeBindingTests308_src.zip";
-		
+		IJavaProject javaProject = getJavaProject("Converter18");
 		try {
 			String[] pathAndContents = new String[] {
 				"Outer.java",
@@ -1110,9 +1110,12 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 				"}\n"
 			};
 		
-			HashMap libraryOptions = new HashMap(this.currentProject.getOptions(true));
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
 			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(this.currentProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			libraryOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);
+			libraryOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);
+			libraryOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
 			
 			String contents = 
 					"public class X {\n" +
@@ -1140,12 +1143,13 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 			ITypeBinding type = left.resolveTypeBinding();
 			assertEquals("Wrong type", "@Marker{ value = (String)\"Outer\"} Outer.@Marker{ value = (String)\"Middle\"} Middle.@Marker{ value = (String)\"Inner\"} Inner", type.toString());		
 		} finally {
-				removeLibrary(this.currentProject, jarName, srcName);
+				removeLibrary(javaProject, jarName, srcName);
 		}
 	}
 	public void _testAnnotatedBinaryMemberType2() throws CoreException, IOException {
 		String jarName = "TypeBindingTests308.jar";
 		String srcName = "TypeBindingTests308_src.zip";
+		IJavaProject javaProject = getJavaProject("Converter18");
 		try {
 			String[] pathAndContents = new String[] {
 				"Outer.java",
@@ -1162,9 +1166,9 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 				"}\n"
 			};
 		
-			HashMap libraryOptions = new HashMap(this.currentProject.getOptions(true));
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
 			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(this.currentProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
 			
 			String contents = 
 					"public class X {\n" +
@@ -1192,7 +1196,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 			ITypeBinding type = left.resolveTypeBinding();
 			assertEquals("Wrong type", "@Marker{ value = (String)\"Outer\"} Outer.Middle.@Marker{ value = (String)\"Middle\"} @Marker{ value = (String)\"Inner\"} Inner @Marker{ value = (String)\"Extended []\"} [] @Marker{ value = (String)\"Prefix []\"} []", type.toString());		
 		} finally {
-				removeLibrary(this.currentProject, jarName, srcName);
+				removeLibrary(javaProject, jarName, srcName);
 		}
 	}
 	public void _testAnnotatedBinaryMemberType3() throws CoreException, IOException {
@@ -1212,7 +1216,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 				"	int value();\n" +
 				"}\n"
 			};
-		
+			// Outer<@T(2) String>.Inner<@T(2) Integer> @T(1) @T(6) [] @T(5) []
 			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
 			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
 			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 65b6dbb..6aa3e2e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -1415,7 +1415,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		for (int i = 0, max = this.codeStream.exceptionLabelsCounter; i < max; i++) {
 			ExceptionLabel exceptionLabel = exceptionLabels[i];
 			if (exceptionLabel.exceptionTypeReference != null && (exceptionLabel.exceptionTypeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-				exceptionLabel.exceptionTypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.EXCEPTION_PARAMETER, i, allTypeAnnotationContexts);
+				exceptionLabel.exceptionTypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.EXCEPTION_PARAMETER, i, allTypeAnnotationContexts, exceptionLabel.se7Annotations);
 			}
 		}
 		
@@ -4492,10 +4492,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 
 		int[] locations = Annotation.getLocations(
 			annotationContext.typeReference,
-			annotationContext.primaryAnnotations,
-			annotationContext.annotation,
-			annotationContext.annotationsOnDimensions,
-			annotationContext.dimensions);
+			annotationContext.annotation);
 
 		if (this.contentsOffset + 5 >= this.contents.length) {
 			resizeContents(5);
@@ -4513,10 +4510,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 
 		int[] locations = Annotation.getLocations(
 				annotationContext.typeReference,
-				null,
-				annotationContext.annotation,
-				null,
-				0);
+				annotationContext.annotation);
 		// reserve enough space
 		if (this.contentsOffset + 5 >= this.contents.length) {
 			resizeContents(5);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 8b573b1..fcb81fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -906,6 +906,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 						TypeReference typeRef = local.declaration.type;
 						if (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on package qualified types.
 							local.declaration.bits |= HasTypeAnnotations;
+							typeRef.bits |= HasTypeAnnotations;
 							local.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, typeRef, local.type);
 						}
 						break;
@@ -914,6 +915,8 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 						SourceTypeBinding sourceType = (SourceTypeBinding) field.declaringClass;
 						FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);
 						if (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.
+							fieldDeclaration.bits |= HasTypeAnnotations;
+							fieldDeclaration.type.bits |= HasTypeAnnotations;
 							field.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, fieldDeclaration.type, field.type);
 						}
 						break;
@@ -923,6 +926,8 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 							sourceType = (SourceTypeBinding) method.declaringClass;
 							MethodDeclaration methodDecl = (MethodDeclaration) sourceType.scope.referenceContext.declarationOf(method);
 							if (Annotation.isTypeUseCompatible(methodDecl.returnType, scope)) {
+								methodDecl.bits |= HasTypeAnnotations;
+								methodDecl.returnType.bits |= HasTypeAnnotations;
 								method.returnType = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, methodDecl.returnType, method.returnType);
 							}
 						}
@@ -951,6 +956,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 			typeRef.resolvedType = existingType.isArrayType() ? scope.environment().createArrayType(newLeafType, existingType.dimensions(), existingType.getTypeAnnotations()) : newLeafType;
 		} else {
 			unionRef.resolvedType = newLeafType;
+			unionRef.bits |= HasTypeAnnotations;
 		}
 		return typeRef.resolvedType;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 4823662..609f370 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -49,454 +49,145 @@ public abstract class Annotation extends Expression {
 	 * Return the location for the corresponding annotation inside the type reference, <code>null</code> if none.
 	 */
 	public static int[] getLocations(
-			final TypeReference reference,
-			final Annotation[] primaryAnnotation,
-			final Annotation annotation,
-			final Annotation[][] annotationsOnDimensionsOnExpression,
-			final int dimensions) {
+			final Expression reference,
+			final Annotation annotation) {
 	
 		class LocationCollector extends ASTVisitor {
 			Stack typePathEntries;
-			Annotation currentAnnotation;
-			boolean search = true;
+			Annotation searchedAnnotation;
+			boolean continueSearch = true;
 			
 			public LocationCollector(Annotation currentAnnotation) {
 				this.typePathEntries = new Stack();
-				this.currentAnnotation = currentAnnotation;
+				this.searchedAnnotation = currentAnnotation;
 			}
 			
-			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-								
-				Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();
-				if (annotationsOnDimensions != null) {
-					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
-						Annotation[] annotations = annotationsOnDimensions[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									// found it, push any relevant type path entries
-									for (int k = 0; k < i; k++) {
-										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-									}
-									this.search = false;
-									return false;
-								}
-							}
-						}
-						
-					}
-				}
-				
-				// Example cases handled here: @B(1) List<String>[]
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							this.search = false;
-							// Found it, insert any necessary type path elements
-							for (int k = 0; k < typeReference.dimensions; k++) {
-								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-							}
-							return false;
-						}
-					}
-				}
-				
-				// If a type argument is annotated it is necessary jump past the array elements
-				if (typeReference.dimensions != 0) {
-					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+			private int[] computeNestingDepth(TypeReference typeReference) {
+				TypeBinding type = typeReference.resolvedType == null ? null : typeReference.resolvedType.leafComponentType(); 
+				int[] nestingDepths = new int[typeReference.getAnnotatableLevels()];
+				if (type != null && type.isNestedType()) {
+					int depth = 0;
+					TypeBinding currentType = type;
+					while (currentType != null) {
+						depth += (currentType.isStatic()) ? 0 : 1;
+						currentType = currentType.enclosingType();
 					}
-				}
-				TypeReference[] typeReferences = typeReference.typeArguments;
-				for (int i = 0, max = typeReferences.length; i < max; i++) {
-					this.typePathEntries.add(new int[]{3,i});
-					typeReferences[i].traverse(this, scope);
-					if (!this.search) {
-						return false;
-					} else {
-						this.typePathEntries.pop();
+					// Work backwards computing whether a INNER_TYPE entry is required for each level
+					int counter = nestingDepths.length - 1;
+					while (type != null && counter >= 0) {
+						nestingDepths[counter--] = depth;
+						depth -= type.isStatic() ? 0 : 1;
+						type = type.enclosingType();
 					}
 				}
-				if (typeReference.dimensions != 0) {
-					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-						this.typePathEntries.pop();
-					}					
-				}
-				return true;
+				return nestingDepths;
 			}
+			
 
-			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-
-				// Example case handled by this block: X[][] x = new @A X @B [] @C[]{ { null }, { null } };
-				if (dimensions != 0 && annotationsOnDimensionsOnExpression != null) {
-					for (int i = 0, max = annotationsOnDimensionsOnExpression.length; i < max; i++) {
-						Annotation[] annotations = annotationsOnDimensionsOnExpression[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									this.search = false;
-									// Found it, insert relevant type path elements
-									for (int k = 0, maxk = i; k < maxk; k++) {
-										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-									}
-									return false;
-								}
-							}
-						}
-					}
-				}
-				
-				if (dimensions != 0) {
-					for (int k = 0; k < dimensions; k++) {
-						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-					}
-				}
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							// Found
-							this.search = false;
-							int depth = getInnerDepth(typeReference.resolvedType);
-							if (depth != 0) {
-								for (int k = 0; k<depth; k++) {
-									this.typePathEntries.add(TYPE_PATH_INNER_TYPE);
-								}
-							}
-							return false;
-						}
-					}
-				}
-				if (dimensions != 0) {
-					for (int k = 0; k < dimensions; k++) {
-						this.typePathEntries.pop();
-					}
+			private void inspectAnnotations(Annotation [] annotations) {
+				for (int i = 0, length = annotations == null ? 0 : annotations.length; this.continueSearch && i < length; i++) {
+					if (annotations[i] == this.searchedAnnotation)
+						this.continueSearch = false;
 				}
-				return false;
 			}
 
-			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				
-				Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();
-				if (annotationsOnDimensions != null) {
-					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
-						Annotation[] annotations = annotationsOnDimensions[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									for (int k = 0; k < i; k++) {
-										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-									}
-									this.search = false;
-									return false;
-								}
-							}
-						}
-						
-					}
-				}
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							for (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {
-								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-							}
-							this.search = false;
-							return false;
-						}
-					}
+			private void inspectArrayDimensions(Annotation [][] annotationsOnDimensions, int dimensions) {
+				for (int i = 0; this.continueSearch && i < dimensions; i++) {
+					Annotation[] annotations = annotationsOnDimensions == null ? null : annotationsOnDimensions[i];
+					inspectAnnotations(annotations);
+					if (!this.continueSearch) return;
+					this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
 				}
-				return true;
 			}
 			
-			public boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();
-				if (annotationsOnDimensions != null) {
-					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
-						Annotation[] annotations = annotationsOnDimensions[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									this.search = false;
-									// Found it, insert relevant type path elements
-									for (int k = 0, maxk = i; k < maxk; k++) {
-										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-									}
-									return false;
-								}
-							}
-						}
-					}
-				}
-
-				if (primaryAnnotation != null) {
-					for (int i = 0, max = primaryAnnotation.length; i < max; i++) {
-						if (primaryAnnotation[i] == this.currentAnnotation) {
-							this.search = false;
-							for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-							}
-							return false;
-						}
-					}
-				}
-
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations != null) {
-					int annotationsLevels = annotations.length;
-					for (int i = 0; i < annotationsLevels; i++) {
-						Annotation [] current = annotations[i];
-						int annotationsLength = current == null ? 0 : current.length;
-						for (int j = 0; j < annotationsLength; j++) {
-							if (current[j] == this.currentAnnotation) {
-								this.search = false;
-								for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-									this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-								}
-								// depth allows for references like: one.two.three.@B Foo[]
-								// the inner_type elements to the type path depend on the types not the package qualifiers
-								int depth = getInnerDepth(typeReference.resolvedType);
-								if (depth != 0) {
-									for (int k = 0; k < depth; k++) {
-										this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
-									}
-								}
-								return false;
-							}
-						}
-					}
+			private void inspectTypeArguments(TypeReference[] typeReferences) {
+				for (int i = 0, length = typeReferences == null ? 0 : typeReferences.length; this.continueSearch && i < length; i++) {
+					int size = this.typePathEntries.size();
+					this.typePathEntries.add(new int[]{3,i});
+					typeReferences[i].traverse(this, (BlockScope) null);
+					if (!this.continueSearch) return;
+					this.typePathEntries.setSize(size);
 				}
-				return true;
 			}
 			
-			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				
-				// Example case handled by this block: java.util.List<String>[]@A[]
-				Annotation[][] annotationsOnDimensions = typeReference.getAnnotationsOnDimensions();
-				if (annotationsOnDimensions != null) {
-					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
-						Annotation[] annotations = annotationsOnDimensions[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									this.search = false;
-									// Found it, insert relevant type path elements
-									for (int k = 0, maxk = i; k < maxk; k++) {
-										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-									}
-									return false;
-								}
-							}
-						}
-					}
-				}
-
-				boolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);
-
-				// Example cases handled by this block:
-				// java.util.@A List<String>[][], com.demo.@A Outer.@B Inner<String>, java.util.Map.@A Entry<String,String>
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							this.search = false;
-							// Found, insert any relevant type path elements
-							for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+			public boolean visit(TypeReference typeReference, BlockScope scope) {
+				if (this.continueSearch) {
+					inspectArrayDimensions(typeReference.getAnnotationsOnDimensions(), typeReference.dimensions());
+					if (this.continueSearch) {
+						int[] nestingDepths = computeNestingDepth(typeReference);
+						Annotation[][] annotations = typeReference.annotations;
+						TypeReference [][] typeArguments = typeReference.getTypeArguments();
+						int levels = typeReference.getAnnotatableLevels();
+						int size = this.typePathEntries.size();
+						for (int i = levels - 1; this.continueSearch && i >= 0; i--) {  // traverse outwards, see comment below about type annotations from SE7 locations.
+							this.typePathEntries.setSize(size);
+							for (int j = 0, depth = nestingDepths[i]; j < depth; j++)
+								this.typePathEntries.add(TYPE_PATH_INNER_TYPE);
+							if (annotations != null)
+								inspectAnnotations(annotations[i]);
+							if (this.continueSearch && typeArguments != null) {
+								inspectTypeArguments(typeArguments[i]);
 							}
-							// Found, insert any relevant type path elements
-							if (needsInnerEntryInfo != null) {
-								for (int k = 0; k <= i; k++) {
-									if (needsInnerEntryInfo[k]) {
-										this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
-									}
-								}
-							}
-							return false;
-						}
-					}
-				}
-				
-				// Example cases handled by this block:
-				// java.util.List<@A String>
-				if (typeReference.dimensions != 0) {
-					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
-						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-					}
-				}
-				int toPop = 0;
-				for (int i = 0, max = typeReference.typeArguments.length; i < max; i++) {
-					TypeReference[] typeArgumentsForComponent = typeReference.typeArguments[i];
-					if (needsInnerEntryInfo != null && needsInnerEntryInfo[i]) { 
-						this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
-						toPop++;
-					}
-					if (typeArgumentsForComponent != null) {
-						for (int j = 0, max2 = typeArgumentsForComponent.length; j < max2; j++) {
-							this.typePathEntries.push(new int[]{3,j});
-							typeArgumentsForComponent[j].traverse(this,scope);
-							if (!this.search) return false;
-							this.typePathEntries.pop();
 						}
 					}
 				}
-				toPop += typeReference.dimensions;
-				for (int k = 0, maxk = toPop; k < maxk; k++) {
-					this.typePathEntries.pop();
-				}
-				return true;
+				return false; // if annotation is not found in the type reference, it must be one from SE7 location, typePathEntries captures the proper path entries for them. 
+			}	
+			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
 			}
 			
-			public boolean visit(Wildcard typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				
-				// This block handles List<@Foo ? extends Serializable>
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							this.search = false;
-							return false;
-						}
-					}
-				}
+			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
+			}
+			
+			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
+			}
 
-				this.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);
-				TypeReference bound = typeReference.bound;
-				if (bound != null)
-					bound.traverse(this, scope);
-				if (!this.search) {
-					return false;
-				}
-				this.typePathEntries.pop();
-				return true;
+			public boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
 			}
 			
-			private boolean[] computeInnerEntryInfo(QualifiedTypeReference typeReference) {
-				ReferenceBinding resolvedType = (ReferenceBinding) 
-						(typeReference.resolvedType instanceof ArrayBinding ? typeReference.resolvedType.leafComponentType() : typeReference.resolvedType);
-				boolean[] needsInnerEntryInfo = null;
-				if (resolvedType != null && resolvedType.isNestedType()) {
-					// Work backwards computing whether a INNER_TYPE entry is required for each level
-					needsInnerEntryInfo = new boolean[typeReference.tokens.length];
-					int counter = needsInnerEntryInfo.length - 1;
-					ReferenceBinding type = resolvedType;//resolvedType.enclosingType();
-					while (type != null && counter > 0) {
-						needsInnerEntryInfo[counter--] = !type.isStatic();
-						type = type.enclosingType();
-					}
-				}
-				return needsInnerEntryInfo;
+			public boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
 			}
 			
-			private int getInnerDepth(TypeBinding resolvedType) {
-				ReferenceBinding type = null;
-				if (resolvedType instanceof ReferenceBinding) {
-					type = (ReferenceBinding)resolvedType;
-				} else if (resolvedType instanceof ArrayBinding) {
-					TypeBinding leafComponentType = ((ArrayBinding)resolvedType).leafComponentType;
-					if (leafComponentType instanceof ReferenceBinding) {
-						type = (ReferenceBinding)leafComponentType;
-					}
-				}
-				int depth = 0;
-				while (type != null) {
-					depth += (type.isStatic())?0:1;
-					type = type.enclosingType();
-				}
-				return depth;
+			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
+				return visit((TypeReference) typeReference, scope);
 			}
 			
-			public boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				boolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);
-				
-				if (dimensions != 0) {
-					for (int k = 0; k < dimensions; k++) {
-						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
-					}
-				}
-				
-				// Example cases handled by this block:
-				// java.util.@A List, com.demo.@A Outer.@B Inner, java.util.Map.@A Entry
-				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
-				for (int i = 0; i < annotationsLevels; i++) {
-					Annotation [] current = annotations[i];
-					int annotationsLength = current == null ? 0 : current.length;
-					for (int j = 0; j < annotationsLength; j++) {
-						if (current[j] == this.currentAnnotation) {
-							this.search = false;
-							// Found, insert any relevant type path elements
-							if (needsInnerEntryInfo != null) {
-								for (int k = 0; k <= i; k++) {
-									if (needsInnerEntryInfo[k]) {
-										this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
-									}
-								}
-							}
-							return false;
-						}
+			public boolean visit(Wildcard typeReference, BlockScope scope) {
+				visit((TypeReference) typeReference, scope);
+				if (this.continueSearch) {
+					TypeReference bound = typeReference.bound;
+					if (bound != null) {
+						int size = this.typePathEntries.size();
+						this.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);
+						bound.traverse(this, scope);
+						if (this.continueSearch)
+							this.typePathEntries.setSize(size);
 					}
 				}
-				if (dimensions != 0) {
-					for (int k = 0; k < dimensions; k++) {
-						this.typePathEntries.pop();
+				return false;
+			}
+
+			public boolean visit(ArrayAllocationExpression allocationExpression, BlockScope scope) {
+				if (this.continueSearch) {
+					inspectArrayDimensions(allocationExpression.getAnnotationsOnDimensions(), allocationExpression.dimensions.length);
+					if (this.continueSearch) {
+						allocationExpression.type.traverse(this, scope);
 					}
+					if (this.continueSearch) throw new IllegalStateException();
 				}
-				return true;
+				return false;
 			}
-			
+						
 			public String toString() {
 				StringBuffer buffer = new StringBuffer();
 				buffer
 					.append("search location for ") //$NON-NLS-1$
-					.append(this.currentAnnotation)
+					.append(this.searchedAnnotation)
 					.append("\ncurrent type_path entries : "); //$NON-NLS-1$
 				for (int i = 0, maxi = this.typePathEntries.size(); i < maxi; i++) {
 					int[] typePathEntry = (int[]) this.typePathEntries.get(i);
@@ -1151,6 +842,8 @@ public abstract class Annotation extends Expression {
 	public static void isTypeUseCompatible(TypeReference reference, Scope scope, Annotation[] annotations) {
 		if (annotations == null || reference == null || reference.getAnnotatableLevels() == 1)
 			return;
+		if (scope.environment().globalOptions.sourceLevel < ClassFileConstants.JDK1_8)
+			return;
 
 		TypeBinding resolvedType = reference.resolvedType == null ? null : reference.resolvedType.leafComponentType();
 		if (resolvedType == null || !resolvedType.isNestedType())
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index 3f36712..400a0db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -199,49 +199,6 @@ public class Argument extends LocalDeclaration {
 		resolveAnnotations(scope, this.annotations, this.binding, true);
 		Annotation.isTypeUseCompatible(this.type, scope, this.annotations);
 
-		// Type annotations may need attaching to the type references
-		// Example of code this block handles: } catch(@A Exception e) {
-		if (this.annotations != null) {
-			for (int i = 0, max = this.annotations.length; i < max; i++) {
-				Annotation annotation = this.annotations[i];
-				if ((annotation.resolvedType.tagBits & (TagBits.AnnotationForTypeParameter | TagBits.AnnotationForTypeUse)) != 0) {
-					// Copy it to the type reference.
-					if (this.type instanceof UnionTypeReference) {
-						// Only need to consider the first element of the union type reference
-						TypeReference firstTypeReference = ((UnionTypeReference) this.type).typeReferences[0];
-						Annotation[][] annotationsOnFirstReference = firstTypeReference.annotations;
-						if (annotationsOnFirstReference == null) {
-							firstTypeReference.annotations = annotationsOnFirstReference = new Annotation[firstTypeReference.getAnnotatableLevels()][];
-						} 
-						if (annotationsOnFirstReference[0] == null) {
-							firstTypeReference.annotations[0] = new Annotation[] { annotation };
-						} else {
-							int len = annotationsOnFirstReference.length;
-							Annotation[] newAnnotations = new Annotation[len + 1];
-							System.arraycopy(annotationsOnFirstReference[0], 0, newAnnotations, 0, len);
-							newAnnotations[len] = annotation;
-							firstTypeReference.annotations[0] = newAnnotations;
-						}
-						firstTypeReference.bits |= ASTNode.HasTypeAnnotations;
-					} else {
-						if (this.type.annotations == null) {
-							this.type.annotations = new Annotation[this.type.getAnnotatableLevels()][];
-						}
-						if (this.type.annotations[0] == null) {
-							this.type.annotations[0] = new Annotation[] { annotation };
-						} else {
-							int len = this.type.annotations[0].length;
-							Annotation[] newAnnotations = new Annotation[len + 1];
-							System.arraycopy(this.type.annotations[0], 0, newAnnotations, 0, len);
-							newAnnotations[len] = annotation;
-							this.type.annotations[0] = newAnnotations;
-						}
-						this.type.bits |= ASTNode.HasTypeAnnotations;
-					}
-				}
-			}
-		}
-
 		scope.addLocalVariable(this.binding);
 		this.binding.setConstant(Constant.NotAConstant);
 		if (hasError) return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index f58f7a8..322e360 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -22,8 +22,11 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.impl.*;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference.AnnotationCollector;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
 import org.eclipse.jdt.internal.compiler.lookup.*;
@@ -62,7 +65,7 @@ public class ArrayAllocationExpression extends Expression {
 		int pc = codeStream.position;
 
 		if (this.initializer != null) {
-			this.initializer.generateCode(this.type, this.annotationsOnDimensions, currentScope, codeStream, valueRequired);
+			this.initializer.generateCode(this.type, this, currentScope, codeStream, valueRequired);
 			return;
 		}
 
@@ -77,10 +80,10 @@ public class ArrayAllocationExpression extends Expression {
 		// array allocation
 		if (explicitDimCount == 1) {
 			// Mono-dimensional array
-			codeStream.newArray(this.type, this.annotationsOnDimensions, (ArrayBinding)this.resolvedType);
+			codeStream.newArray(this.type, this, (ArrayBinding)this.resolvedType);
 		} else {
 			// Multi-dimensional array
-			codeStream.multianewarray(this.type, this.resolvedType, explicitDimCount, this.dimensions.length, this.annotationsOnDimensions);
+			codeStream.multianewarray(this.type, this.resolvedType, explicitDimCount, this);
 		}
 		if (valueRequired) {
 			codeStream.generateImplicitConversion(this.implicitConversion);
@@ -193,6 +196,11 @@ public class ArrayAllocationExpression extends Expression {
 			int dimensionsLength = this.dimensions.length;
 			this.type.traverse(visitor, scope);
 			for (int i = 0; i < dimensionsLength; i++) {
+				Annotation [] annotations = this.annotationsOnDimensions == null ? null : this.annotationsOnDimensions[i];
+				int annotationsLength = annotations == null ? 0 : annotations.length;
+				for (int j = 0; j < annotationsLength; j++) {
+					annotations[j].traverse(visitor, scope);
+				}
 				if (this.dimensions[i] != null)
 					this.dimensions[i].traverse(visitor, scope);
 			}
@@ -201,4 +209,23 @@ public class ArrayAllocationExpression extends Expression {
 		}
 		visitor.endVisit(this, scope);
 	}
+
+	public void getAllAnnotationContexts(int targetType, int info, List allTypeAnnotationContexts) {
+		AnnotationCollector collector = new AnnotationCollector(this, targetType, info, allTypeAnnotationContexts);
+		this.type.traverse(collector, (BlockScope) null);
+		if (this.annotationsOnDimensions != null)  {
+			int dimensionsLength = this.dimensions.length;
+			for (int i = 0; i < dimensionsLength; i++) {
+				Annotation [] annotations = this.annotationsOnDimensions[i];
+				int annotationsLength = annotations == null ? 0 : annotations.length;
+				for (int j = 0; j < annotationsLength; j++) {
+					annotations[j].traverse(collector, (BlockScope) null);
+				}
+			}
+		}
+	}
+
+	public Annotation[][] getAnnotationsOnDimensions() {
+		return this.annotationsOnDimensions;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index d02c2a2..caa6e5b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -70,13 +70,13 @@ public class ArrayInitializer extends Expression {
 	/**
 	 * Code generation for a array initializer
 	 */
-	public void generateCode(TypeReference typeReference, Annotation[][] annotationsOnDimensions, BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
+	public void generateCode(TypeReference typeReference, ArrayAllocationExpression allocationExpression, BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
 
 		// Flatten the values and compute the dimensions, by iterating in depth into nested array initializers
 		int pc = codeStream.position;
 		int expressionLength = (this.expressions == null) ? 0: this.expressions.length;
 		codeStream.generateInlinedValue(expressionLength);
-		codeStream.newArray(typeReference, annotationsOnDimensions, this.binding);
+		codeStream.newArray(typeReference, allocationExpression, this.binding);
 		if (this.expressions != null) {
 			// binding is an ArrayType, so I can just deal with the dimension
 			int elementsTypeID = this.binding.dimensions > 1 ? -1 : this.binding.leafComponentType.id;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 8759e09..5f84d08 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -441,7 +441,7 @@ private void internalGenerateCode(ClassScope classScope, ClassFile classFile) {
 }
 
 public void getAllAnnotationContexts(int targetType, List allAnnotationContexts) {
-	AnnotationCollector collector = new AnnotationCollector(this, targetType, allAnnotationContexts);
+	AnnotationCollector collector = new AnnotationCollector(null, targetType, allAnnotationContexts);
 	for (int i = 0, max = this.annotations.length; i < max; i++) {
 		Annotation annotation = this.annotations[i];
 		annotation.traverse(collector, (BlockScope) null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index afa1434..f017ced 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -134,7 +134,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 	codeStream.recordPositionsFrom(pc, this.sourceStart);
 }
 public void getAllAnnotationContexts(int targetType, List allAnnotationContexts) {
-	AnnotationCollector collector = new AnnotationCollector(this, targetType, allAnnotationContexts);
+	AnnotationCollector collector = new AnnotationCollector(this.type, targetType, allAnnotationContexts);
 	for (int i = 0, max = this.annotations.length; i < max; i++) {
 		Annotation annotation = this.annotations[i];
 		annotation.traverse(collector, (BlockScope) null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 2c22d3d..2e8b81e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -168,7 +168,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	}
 
 	public void getAllAnnotationContexts(int targetType, List allAnnotationContexts) {
-		AnnotationCollector collector = new AnnotationCollector(this, targetType, allAnnotationContexts);
+		AnnotationCollector collector = new AnnotationCollector(this.returnType, targetType, allAnnotationContexts);
 		for (int i = 0, max = this.annotations.length; i < max; i++) {
 			Annotation annotation = this.annotations[i];
 			annotation.traverse(collector, (BlockScope) null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index cb3fc6b..93b2e00 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -136,6 +136,10 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		return qParamName;
 	}
 
+	public TypeReference[][] getTypeArguments() {
+		return this.typeArguments;
+	}
+	
 	/* (non-Javadoc)
      * @see org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference#getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.Scope)
      */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 6166a62..290384a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -103,6 +103,11 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		}
 		return new char[][]{ name };
 	}
+	
+	public TypeReference[][] getTypeArguments() {
+		return new TypeReference[][] { this.typeArguments };
+	}
+	
 	/**
      * @see org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference#getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.Scope)
      */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 108015d..aa02596 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -498,10 +498,10 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 			ExceptionLabel exceptionLabel = null;
 			if ((argument.binding.tagBits & TagBits.MultiCatchParameter) != 0) {
 				MultiCatchExceptionLabel multiCatchExceptionLabel = new MultiCatchExceptionLabel(codeStream, argument.binding.type);
-				multiCatchExceptionLabel.initialize((UnionTypeReference) argument.type);
+				multiCatchExceptionLabel.initialize((UnionTypeReference) argument.type, argument.annotations);
 				exceptionLabel = multiCatchExceptionLabel;
 			} else {
-				exceptionLabel = new ExceptionLabel(codeStream, argument.binding.type, argument.type);
+				exceptionLabel = new ExceptionLabel(codeStream, argument.binding.type, argument.type, argument.annotations);
 			}
 			exceptionLabel.placeStart();
 			exceptionLabels[i] = exceptionLabel;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 07efcbf..afa5cd6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -54,9 +54,8 @@ public abstract class TypeReference extends Expression {
 	public static final TypeReference[] NO_TYPE_ARGUMENTS = new TypeReference[0];
 static class AnnotationCollector extends ASTVisitor {
 	List annotationContexts;
-	TypeReference typeReference;
+	Expression typeReference;
 	int targetType;
-	Annotation[] primaryAnnotations;
 	int info = 0;
 	int info2 = 0;
 	LocalVariableBinding localVariable;
@@ -72,7 +71,6 @@ static class AnnotationCollector extends ASTVisitor {
 		this.annotationContexts = annotationContexts;
 		this.typeReference = typeParameter.type;
 		this.targetType = targetType;
-		this.primaryAnnotations = typeParameter.annotations;
 		this.info = typeParameterIndex;
 	}
 
@@ -84,7 +82,6 @@ static class AnnotationCollector extends ASTVisitor {
 		this.annotationContexts = annotationContexts;
 		this.typeReference = localDeclaration.type;
 		this.targetType = targetType;
-		this.primaryAnnotations = localDeclaration.annotations;
 		this.localVariable = localVariable;
 	}
 
@@ -96,39 +93,10 @@ static class AnnotationCollector extends ASTVisitor {
 		this.annotationContexts = annotationContexts;
 		this.typeReference = localDeclaration.type;
 		this.targetType = targetType;
-		this.primaryAnnotations = localDeclaration.annotations;
 		this.info = parameterIndex;
 	}
 
 	public AnnotationCollector(
-			MethodDeclaration methodDeclaration,
-			int targetType,
-			List annotationContexts) {
-		this.annotationContexts = annotationContexts;
-		this.typeReference = methodDeclaration.returnType;
-		this.targetType = targetType;
-		this.primaryAnnotations = methodDeclaration.annotations;
-	}
-
-	public AnnotationCollector(
-			ConstructorDeclaration constructorDeclaration,
-			int targetType,
-			List annotationContexts) {
-		this.annotationContexts = annotationContexts;
-		this.targetType = targetType;
-		this.primaryAnnotations = constructorDeclaration.annotations;
-	}
-
-	public AnnotationCollector(
-			FieldDeclaration fieldDeclaration,
-			int targetType,
-			List annotationContexts) {
-		this.annotationContexts = annotationContexts;
-		this.typeReference = fieldDeclaration.type;
-		this.targetType = targetType;
-		this.primaryAnnotations = fieldDeclaration.annotations;
-	}
-	public AnnotationCollector(
 			TypeReference typeReference,
 			int targetType,
 			List annotationContexts) {
@@ -137,7 +105,7 @@ static class AnnotationCollector extends ASTVisitor {
 		this.targetType = targetType;
 	}
 	public AnnotationCollector(
-			TypeReference typeReference,
+			Expression typeReference,
 			int targetType,
 			int info,
 			List annotationContexts) {
@@ -181,9 +149,9 @@ static class AnnotationCollector extends ASTVisitor {
 	private boolean internalVisit(Annotation annotation) {
 		AnnotationContext annotationContext = null;
 		if (annotation.isRuntimeTypeInvisible()) {
-			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.INVISIBLE, this.annotationsOnDimensions, this.dimensions);
+			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, AnnotationContext.INVISIBLE);
 		} else if (annotation.isRuntimeTypeVisible()) {
-			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.VISIBLE, this.annotationsOnDimensions, this.dimensions);
+			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, AnnotationContext.VISIBLE);
 		}
 		if (annotationContext != null) {
 			annotationContext.wildcard = this.currentWildcard;
@@ -396,6 +364,14 @@ public void getAllAnnotationContexts(int targetType, int info, List allAnnotatio
 	AnnotationCollector collector = new AnnotationCollector(this, targetType, info, allAnnotationContexts);
 	this.traverse(collector, (BlockScope) null);
 }
+public void getAllAnnotationContexts(int targetType, int info, List allAnnotationContexts, Annotation [] se7Annotations) {
+	AnnotationCollector collector = new AnnotationCollector(this, targetType, info, allAnnotationContexts);
+	for (int i = 0, length = se7Annotations == null ? 0 : se7Annotations.length; i < length; i++) {
+		Annotation annotation = se7Annotations[i];
+		annotation.traverse(collector, (BlockScope) null);
+	}
+	this.traverse(collector, (BlockScope) null);
+}
 /**
  * info can be either a type index (superclass/superinterfaces) or a pc into the bytecode
  */
@@ -425,6 +401,9 @@ public Annotation[][] getAnnotationsOnDimensions() {
 	return getAnnotationsOnDimensions(false);
 }
 
+public TypeReference [][] getTypeArguments() {
+	return null;
+}
 /**
  * @param useSourceOrder if true annotations on dimensions are returned in source order, otherwise they are returned per
  * how they ought to be interpreted by a type system, or external persistence view. For example, given the following:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
index c743d43..865db39 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
@@ -17,7 +17,7 @@
 package org.eclipse.jdt.internal.compiler.codegen;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 
@@ -25,34 +25,23 @@ public class AnnotationContext {
 	public static final int VISIBLE = 0x1;
 	public static final int INVISIBLE = 0x2;
 	public Annotation annotation;
-	public TypeReference typeReference;
+	public Expression typeReference;
 	public int targetType;
 	public int info;
 	public int info2;
 	public int visibility;
-	public Annotation[] primaryAnnotations;
 	public LocalVariableBinding variableBinding;
-	public Annotation[][] annotationsOnDimensions;
 	public Wildcard wildcard;
-	// annotationsOnDimensions might be null but the dimensions may still be important. In some
-	// cases they are not on the reference.
-	public int dimensions;
 
 	public AnnotationContext(
 			Annotation annotation,
-			TypeReference typeReference,
+			Expression typeReference,
 			int targetType,
-			Annotation[] primaryAnnotations,
-			int visibility,
-			Annotation[][] annotationsOnDimensions,
-			int dimensions) {
+			int visibility) {
 		this.annotation = annotation;
 		this.typeReference = typeReference;
 		this.targetType = targetType;
-		this.primaryAnnotations = primaryAnnotations;
 		this.visibility = visibility;
-		this.annotationsOnDimensions = annotationsOnDimensions;
-		this.dimensions = dimensions;
 	}
 
 	public String toString() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index a3146ab..cea3970 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -31,7 +31,7 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
-import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
@@ -5714,8 +5714,7 @@ public void multianewarray(
 		TypeReference typeReference,
 		TypeBinding typeBinding,
 		int dimensions,
-		int declaredDimensions,
-		Annotation [][] annotationsOnDimensions) {
+		ArrayAllocationExpression allocationExpression) {
 	this.countLabels = 0;
 	this.stackDepth += (1 - dimensions);
 	if (this.classFileOffset + 3 >= this.bCodeStream.length) {
@@ -5760,7 +5759,7 @@ public void newArray(ArrayBinding arrayBinding) {
 	this.newArray(null, null, arrayBinding);
 }
 
-public void newArray(TypeReference typeReference, Annotation[][] annotationsOnDimensions, ArrayBinding arrayBinding) {
+public void newArray(TypeReference typeReference, ArrayAllocationExpression allocationExpression, ArrayBinding arrayBinding) {
 	TypeBinding component = arrayBinding.elementsType();
 	switch (component.id) {
 		case TypeIds.T_int :
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
index e6e619d..ccc8063 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
@@ -17,6 +17,7 @@
 package org.eclipse.jdt.internal.compiler.codegen;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
@@ -26,11 +27,13 @@ public class ExceptionLabel extends Label {
 	private int count = 0; // incremented each time placeStart or placeEnd is called
 	public TypeBinding exceptionType;
 	public TypeReference exceptionTypeReference;
+	public Annotation [] se7Annotations;
 
-public ExceptionLabel(CodeStream codeStream, TypeBinding exceptionType, TypeReference exceptionTypeReference) {
+public ExceptionLabel(CodeStream codeStream, TypeBinding exceptionType, TypeReference exceptionTypeReference, Annotation [] se7Annotations) {
 	super(codeStream);
 	this.exceptionType = exceptionType;
 	this.exceptionTypeReference = exceptionTypeReference;
+	this.se7Annotations = se7Annotations;
 }
 
 public ExceptionLabel(CodeStream codeStream, TypeBinding exceptionType) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
index 89462a9..629010d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
@@ -17,6 +17,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
@@ -29,12 +30,12 @@ public class MultiCatchExceptionLabel extends ExceptionLabel {
 		super(codeStream, exceptionType);
 	}
 	
-	public void initialize(UnionTypeReference typeReference) {
+	public void initialize(UnionTypeReference typeReference, Annotation [] annotations) {
 		TypeReference[] typeReferences = typeReference.typeReferences;
 		int length = typeReferences.length;
 		this.exceptionLabels = new ExceptionLabel[length];
 		for (int i = 0; i < length; i++) {
-			this.exceptionLabels[i] = new ExceptionLabel(this.codeStream, typeReferences[i].resolvedType, typeReferences[i]);
+			this.exceptionLabels[i] = new ExceptionLabel(this.codeStream, typeReferences[i].resolvedType, typeReferences[i], i == 0 ? annotations : null);
 		}
 	}
 	public void place() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
index bc66e5b..e5342e9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
@@ -24,7 +24,7 @@ import java.util.List;
 
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
-import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
@@ -40,8 +40,8 @@ public class TypeAnnotationCodeStream extends StackMapFrameCodeStream {
 		this.allTypeAnnotationContexts = new ArrayList();
 	}
 	
-	private void addAnnotationContext(TypeReference typeReference, int info, int targetType, Annotation[][] annotationsOnDimensions, int dimensions) {
-		typeReference.getAllAnnotationContexts(targetType, info, this.allTypeAnnotationContexts, annotationsOnDimensions, dimensions);
+	private void addAnnotationContext(TypeReference typeReference, int info, int targetType, ArrayAllocationExpression allocationExpression) {
+		allocationExpression.getAllAnnotationContexts(targetType, info, this.allTypeAnnotationContexts);
 	}
 	
 	private void addAnnotationContext(TypeReference typeReference, int info, int targetType) {
@@ -63,12 +63,11 @@ public class TypeAnnotationCodeStream extends StackMapFrameCodeStream {
 			TypeReference typeReference,
 			TypeBinding typeBinding,
 			int dimensions,
-			int declaredDimensions,
-			Annotation [][] annotationsOnDimensions) {
+			ArrayAllocationExpression allocationExpression) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, annotationsOnDimensions, declaredDimensions);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, allocationExpression);
 		}
-		super.multianewarray(typeReference, typeBinding, dimensions, declaredDimensions, annotationsOnDimensions);
+		super.multianewarray(typeReference, typeBinding, dimensions, allocationExpression);
 	}
 
 	public void new_(TypeReference typeReference, TypeBinding typeBinding) {
@@ -78,11 +77,11 @@ public class TypeAnnotationCodeStream extends StackMapFrameCodeStream {
 		super.new_(typeReference, typeBinding);
 	}
 	
-	public void newArray(TypeReference typeReference, Annotation[][] annotationsOnDimensions, ArrayBinding arrayBinding) {
+	public void newArray(TypeReference typeReference, ArrayAllocationExpression allocationExpression, ArrayBinding arrayBinding) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, annotationsOnDimensions, arrayBinding.dimensions);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, allocationExpression);
 		}
-		super.newArray(typeReference, annotationsOnDimensions, arrayBinding);
+		super.newArray(typeReference, allocationExpression, arrayBinding);
 	}
 	
 	public void checkcast(TypeReference typeReference, TypeBinding typeBinding) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 7d39089..60bcea8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1642,8 +1642,8 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 				if (annotations != null && annotations != Binding.NO_ANNOTATIONS) {
 					ASTNode.copySE8AnnotationsToType(initializationScope, field, fieldDecl.annotations);
 				}
+				Annotation.isTypeUseCompatible(fieldDecl.type, this.scope, fieldDecl.annotations);
 			}
-			Annotation.isTypeUseCompatible(fieldDecl.type, this.scope, fieldDecl.annotations);
 			// apply null default:
 			LookupEnvironment environment = this.scope.environment();
 			if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 8c10c82..ca25ef6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1031,6 +1031,13 @@ public boolean isReifiable() {
 }
 
 /**
+ * Answer true if the receiver is a static member type (or toplevel)
+ */
+public boolean isStatic() {
+	return false;
+}
+
+/**
  * Returns true if a given type may be thrown
  */
 public boolean isThrowable() {
