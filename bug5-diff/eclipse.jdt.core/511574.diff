commit c8e6cc98263ec5ad8c1cb9bed30ebdd3ad9eb223
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Wed Feb 22 11:33:39 2017 +0530

    bug 511574 - [1.9] ModuleBinding.kind() uses wrong constant
    
    Change-Id: I794925e8eb8903d102c9ab51d91ffefbe5bc6e06

5	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
2	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
3	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
6	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
9	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
48	40	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
37	36	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredModule.java
9	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
32	28	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
16	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
33	9	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
37	32	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
0	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
7	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
index a67b46c..8277965 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -132,8 +132,7 @@ public class ModuleDeclarationSyntaxTest extends AbstractSyntaxTreeTest {
 		String expectedUnitToString = 
 				"module org.fastsocket {\n" +
 				"  requires com.socket;\n" +
-				"  provides com.socket.spi.NetworkSocketProvider\n" +
-				"    with org.fastsocket.FastNetworkSocketProvider;\n" +
+				"  provides com.socket.spi.NetworkSocketProvider with org.fastsocket.FastNetworkSocketProvider;\n" +
 				"}\n";
 		CompilerOptions options = new CompilerOptions(getCompilerOptions());
 		options.complianceLevel = ClassFileConstants.JDK9;
@@ -378,8 +377,7 @@ public class ModuleDeclarationSyntaxTest extends AbstractSyntaxTreeTest {
 				"import com.socket.spi.NetworkSocketProvider;\n" +
 				"module org.fastsocket {\n" +
 				"  requires com.socket;\n" +
-				"  provides NetworkSocketProvider\n" +
-				"    with org.fastsocket.FastNetworkSocketProvider;\n" +
+				"  provides NetworkSocketProvider with org.fastsocket.FastNetworkSocketProvider;\n" +
 				"}\n";
 		CompilerOptions options = new CompilerOptions(getCompilerOptions());
 		options.complianceLevel = ClassFileConstants.JDK9;
@@ -399,8 +397,7 @@ public class ModuleDeclarationSyntaxTest extends AbstractSyntaxTreeTest {
 				"import com.socket.spi.*;\n" +
 				"module org.fastsocket {\n" +
 				"  requires com.socket;\n" +
-				"  provides NetworkSocketProvider\n" +
-				"    with org.fastsocket.FastNetworkSocketProvider;\n" +
+				"  provides NetworkSocketProvider with org.fastsocket.FastNetworkSocketProvider;\n" +
 				"}\n";
 		CompilerOptions options = new CompilerOptions(getCompilerOptions());
 		options.complianceLevel = ClassFileConstants.JDK9;
@@ -433,8 +430,7 @@ public class ModuleDeclarationSyntaxTest extends AbstractSyntaxTreeTest {
 		String expectedUnitToString = 
 				"module org.fastsocket {\n" +
 				"  requires com.socket;\n" +
-				"  provides com.socket.spi.NetworkSocketProvider\n" +
-				"    with org.fastsocket.FastNetworkSocketProvider, org.fastSocket.SlowNetworkSocketProvider;\n" +
+				"  provides com.socket.spi.NetworkSocketProvider with org.fastsocket.FastNetworkSocketProvider, org.fastSocket.SlowNetworkSocketProvider;\n" +
 				"}\n";
 		CompilerOptions options = new CompilerOptions(getCompilerOptions());
 		options.complianceLevel = ClassFileConstants.JDK9;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index 22c7b49..360c7cf 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -1027,7 +1027,8 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				}
 				if (parsedUnit.isModuleInfo() && parsedUnit.types != null &&
 						parsedUnit.types.length > 0) {
-					ModuleDeclaration module = (ModuleDeclaration) parsedUnit.types[0];//TODO, could be null
+					//TypeDeclaration modInfo = parsedUnit.types[0];
+					ModuleDeclaration module = parsedUnit.moduleDeclaration;//modInfo.scope.compilationUnitScope().referenceContext.moduleDeclaration ;//TODO, could be null
 					this.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);
 					acceptPackageVisibilityStatements(module.exports, parsedUnit.scope);
 					acceptPackageVisibilityStatements(module.opens, parsedUnit.scope);
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
index bb36ec0..f325224 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnModuleDeclaration.java
@@ -17,14 +17,15 @@ package org.eclipse.jdt.internal.codeassist.select;
 
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 
 public class SelectionOnModuleDeclaration extends ModuleDeclaration {
 
 	public SelectionOnModuleDeclaration(CompilationResult compilationResult, char[][] tokens, long[] positions) {
 		super(compilationResult, tokens, positions);
 	}
-	public void resolve() {
-		super.resolve();
+	public void resolve(ClassScope scope) {
+		super.resolve(scope);
 		throw new SelectionNodeFound(this.moduleBinding);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 2722bd7..106a447 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -183,6 +183,8 @@ public class ClassFile implements TypeConstants, TypeIds {
 	 * @param unitResult org.eclipse.jdt.internal.compiler.CompilationUnitResult
 	 */
 	public static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult) {
+		if (typeDeclaration.isModuleInfo())
+			return; //TODO No idea what a problem module declaration should look like
 		SourceTypeBinding typeBinding = typeDeclaration.binding;
 		ClassFile classFile = ClassFile.getNewInstance(typeBinding);
 		classFile.initialize(typeBinding, null, true);
@@ -2602,7 +2604,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		return 1;
 	}
 	private int generateModuleAttribute() {
-		ModuleDeclaration module = (ModuleDeclaration)this.referenceBinding.scope.referenceContext;
+		ModuleDeclaration module = this.referenceBinding.scope.compilationUnitScope().referenceContext.moduleDeclaration;
 		ModuleBinding binding = module.moduleBinding;
 		int localContentsOffset = this.contentsOffset;
 		if (localContentsOffset + 10 >= this.contents.length) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 9828dc1..0da08b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -66,6 +66,7 @@ import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
@@ -778,6 +779,11 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 					// deliberately don't set the annotation resolved tagbits, it is not material and also we are working with a dummy static object.
 					annotations = new AnnotationBinding[length];
 					break;
+				case Binding.MODULE:
+					ModuleBinding module = (ModuleBinding)recipient;
+					if ((module.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
+					module.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
+					break;
 				default :
 					return annotations;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index d96c551..3eee089 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -1071,13 +1071,6 @@ public abstract class Annotation extends Expression {
 				}
 				break;
 			case Binding.TYPE :
-				if (((ReferenceBinding)recipient).isModule()) {
-					if ((metaTagBits & (TagBits.AnnotationForModule)) != 0) {
-						return AnnotationTargetAllowed.YES;
-					}
-					break;
-				}
-				//$FALL-THROUGH$
 			case Binding.GENERIC_TYPE :
 				if (((ReferenceBinding)recipient).isAnnotationType()) {
 					if ((metaTagBits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType | TagBits.AnnotationForTypeUse)) != 0)
@@ -1147,6 +1140,12 @@ public abstract class Annotation extends Expression {
 				if ((metaTagBits & (TagBits.AnnotationForTypeParameter | TagBits.AnnotationForTypeUse)) != 0) {
 					return AnnotationTargetAllowed.YES;
 				}
+				break;
+			case Binding.MODULE:
+				if ((metaTagBits & (TagBits.AnnotationForModule)) != 0) {
+					return AnnotationTargetAllowed.YES;
+				}
+				break;
 		}
 		return AnnotationTargetAllowed.NO;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index da1994b..e98c07c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -214,11 +214,11 @@ public void createPackageInfoType() {
 }
 
 public void createModuleInfoType(ModuleDeclaration declaration) {
-	//TypeDeclaration declaration = new TypeDeclaration(this.compilationResult);
-	declaration.name = TypeConstants.MODULE_INFO_NAME;
-	declaration.modifiers |= ClassFileConstants.AccModule;
-	declaration.javadoc = this.javadoc;
-	this.types[0] = declaration; // Assumes the first slot is meant for this type
+	TypeDeclaration type = new TypeDeclaration(this.compilationResult);
+	type.name = TypeConstants.MODULE_INFO_NAME;
+	type.modifiers = declaration.modifiers | ClassFileConstants.AccModule;
+	type.javadoc = this.javadoc;
+	this.types[0] = type; // Assumes the first slot is meant for this type
 }
 
 /*
@@ -485,8 +485,9 @@ public StringBuffer print(int indent, StringBuffer output) {
 			}
 			currentImport.print(0, output).append(";\n"); //$NON-NLS-1$
 		}
-
-	if (this.types != null) {
+	if (this.moduleDeclaration != null) {
+		this.moduleDeclaration.print(indent, output).append("\n"); //$NON-NLS-1$
+	} else if (this.types != null) {
 		for (int i = 0; i < this.types.length; i++) {
 			this.types[i].print(indent, output).append("\n"); //$NON-NLS-1$
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
index 6a70cd8..7a2ff12 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
@@ -21,37 +21,41 @@ import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
-import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.flow.FlowContext;
-import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
-import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
-public class ModuleDeclaration extends TypeDeclaration {
+public class ModuleDeclaration extends ASTNode {
 
 	public ExportsStatement[] exports;
 	public RequiresStatement[] requires;
 	public UsesStatement[] uses;
 	public ProvidesStatement[] services;
 	public OpensStatement[] opens;
+	public Annotation[] annotations;
 	public int exportsCount;
 	public int requiresCount;
 	public int usesCount;
 	public int servicesCount;
 	public int opensCount;
 	public ModuleBinding moduleBinding;
-
+	public int declarationSourceStart;
+	public int declarationSourceEnd;
+	public int bodyStart;
+	public int bodyEnd; // doesn't include the trailing comment if any.
+	public int modifiersSourceStart;
+	//public ClassScope scope;
 	public char[][] tokens;
 	public char[] moduleName;
 	public long[] sourcePositions;
+	public int modifiers = ClassFileConstants.AccDefault;
 
 	public ModuleDeclaration(CompilationResult compilationResult, char[][] tokens, long[] positions) {
-		super(compilationResult);
-		this.compilationResult = compilationResult;
+//		super(compilationResult);
+//		this.compilationResult = compilationResult;
 		this.exportsCount = 0;
 		this.requiresCount = 0;
 		this.tokens = tokens;
@@ -60,45 +64,41 @@ public class ModuleDeclaration extends TypeDeclaration {
 		this.sourceEnd = (int) (positions[positions.length-1] & 0x00000000FFFFFFFF);
 		this.sourceStart = (int) (positions[0] >>> 32);
 	}
-	@Override
-	public void generateCode(ClassFile enclosingClassFile) {
-		if (this.ignoreFurtherInvestigation) {
-			return;
-		}
-		super.generateCode(enclosingClassFile);
-	}
-	@Override
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
-		// TODO Auto-generated method stub
-		return null;
-	}
+//	@Override
+//	public void generateCode(ClassFile enclosingClassFile) {
+//		if (this.ignoreFurtherInvestigation) {
+//			return;
+//		}
+//		super.generateCode(enclosingClassFile);
+//	}
 
-	@Override
-	public void resolve() {
+	//@Override
+	public void resolve(ClassScope scope) {
 		//
-		if (this.binding == null) {
-			this.ignoreFurtherInvestigation = true;
-			return;
-		}
-		this.moduleBinding = this.scope.environment().getModule(this.moduleName);
+//		if (this.binding == null) {
+//			this.ignoreFurtherInvestigation = true;
+//			return;
+//		}
+		this.moduleBinding = scope.environment().getModule(this.moduleName);
+		ASTNode.resolveAnnotations(scope.referenceContext.staticInitializerScope, this.annotations, this.moduleBinding);
 		Set<ModuleBinding> requiredModules = new HashSet<ModuleBinding>();
 		for(int i = 0; i < this.requiresCount; i++) {
 			RequiresStatement ref = this.requires[i];
-			if (ref != null && ref.resolve(this.scope) != null) {
+			if (ref != null && ref.resolve(scope) != null) {
 				if (!requiredModules.add(ref.resolvedBinding)) {
-					this.scope.problemReporter().duplicateModuleReference(IProblem.DuplicateRequires, ref.module);
+					scope.problemReporter().duplicateModuleReference(IProblem.DuplicateRequires, ref.module);
 				}
 				Collection<ModuleBinding> deps = ref.resolvedBinding.dependencyGraphCollector().get();
 				if (deps.contains(this.moduleBinding))
-					this.scope.problemReporter().cyclicModuleDependency(this.moduleBinding, ref.module);
+					scope.problemReporter().cyclicModuleDependency(this.moduleBinding, ref.module);
 			}
 		}
 		Set<PackageBinding> exportedPkgs = new HashSet<>();
 		for (int i = 0; i < this.exportsCount; i++) {
 			ExportsStatement ref = this.exports[i];
- 			if (ref != null && ref.resolve(this.scope)) {
+ 			if (ref != null && ref.resolve(scope)) {
 				if (!exportedPkgs.add(ref.resolvedPackage)) {
-					this.scope.problemReporter().invalidPackageReference(IProblem.DuplicateExports, ref);
+					scope.problemReporter().invalidPackageReference(IProblem.DuplicateExports, ref);
 				}
 			}
 		}
@@ -106,34 +106,34 @@ public class ModuleDeclaration extends TypeDeclaration {
 		for (int i = 0; i < this.opensCount; i++) {
 			OpensStatement ref = this.opens[i];
 			if (isOpen()) {
-				this.scope.problemReporter().invalidOpensStatement(ref, this);
+				scope.problemReporter().invalidOpensStatement(ref, this);
 			} else {
-				if (ref.resolve(this.scope)) {
+				if (ref.resolve(scope)) {
 					if (!openedPkgs.add(ref.resolvedPackage)) {
-						this.scope.problemReporter().invalidPackageReference(IProblem.DuplicateOpens, ref);
+						scope.problemReporter().invalidPackageReference(IProblem.DuplicateOpens, ref);
 					}
 				}
 			}
 		}
 		Set<TypeBinding> allTypes = new HashSet<TypeBinding>();
 		for(int i = 0; i < this.usesCount; i++) {
-			TypeBinding serviceBinding = this.uses[i].serviceInterface.resolveType(this.scope);
+			TypeBinding serviceBinding = this.uses[i].serviceInterface.resolveType(scope);
 			if (serviceBinding != null && serviceBinding.isValidBinding()) {
 				if (!(serviceBinding.isClass() || serviceBinding.isInterface() || serviceBinding.isAnnotationType())) {
-					this.scope.problemReporter().invalidServiceRef(IProblem.InvalidServiceIntfType, this.uses[i].serviceInterface);
+					scope.problemReporter().invalidServiceRef(IProblem.InvalidServiceIntfType, this.uses[i].serviceInterface);
 				}
 				if (!allTypes.add(this.uses[i].serviceInterface.resolvedType)) {
-					this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateUses, this.uses[i].serviceInterface);
+					scope.problemReporter().duplicateTypeReference(IProblem.DuplicateUses, this.uses[i].serviceInterface);
 				}
 			}
 		}
 		Set<TypeBinding> interfaces = new HashSet<>();
 		for(int i = 0; i < this.servicesCount; i++) {
-			this.services[i].resolve(this.scope);
+			this.services[i].resolve(scope);
 			TypeBinding infBinding = this.services[i].serviceInterface.resolvedType;
 			if (infBinding != null && infBinding.isValidBinding()) {
 				if (!interfaces.add(this.services[i].serviceInterface.resolvedType)) { 
-					this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateServices,
+					scope.problemReporter().duplicateTypeReference(IProblem.DuplicateServices,
 							this.services[i].serviceInterface);
 				}
 			}
@@ -198,4 +198,12 @@ public class ModuleDeclaration extends TypeDeclaration {
 		output.append('\n');
 		return printIndent(indent, output).append('}');
 	}
+
+	@Override
+	public StringBuffer print(int indent, StringBuffer output) {
+		//
+		printIndent(indent, output);
+		printHeader(0, output);
+		return printBody(indent, output);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
index b1a8138..03a9940 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PackageVisibilityStatement.java
@@ -61,7 +61,7 @@ public abstract class PackageVisibilityStatement extends ModuleStatement {
 	protected PackageBinding resolvePackageReference(Scope scope) {
 		if (this.resolvedPackage != null)
 			return this.resolvedPackage;
-		ModuleDeclaration exportingModule = (ModuleDeclaration)scope.referenceContext();
+		ModuleDeclaration exportingModule = scope.compilationUnitScope().referenceContext.moduleDeclaration;
 		ModuleBinding src = exportingModule.moduleBinding;
 		this.resolvedPackage = src != null ? src.getDeclaredPackage(this.pkgRef.tokens) : null;
 		if (this.resolvedPackage == null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
index 17835e6..773b3c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
@@ -35,7 +35,7 @@ public class ProvidesStatement extends ModuleStatement {
 	public TypeReference[] implementations;
 
 	public boolean resolve(ClassScope scope) {
-		ModuleDeclaration module = (ModuleDeclaration)scope.referenceContext();
+		ModuleDeclaration module = scope.compilationUnitScope().referenceContext.moduleDeclaration;
 		ModuleBinding src = module.moduleBinding;
 		TypeBinding infBinding = this.serviceInterface.resolveType(scope);
 		boolean hasErrors = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index 46ad4c8..a5c5bf0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -1308,6 +1312,11 @@ public void resolve(ClassScope upperScope) {
  */
 public void resolve(CompilationUnitScope upperScope) {
 	// top level : scope are already created
+	if (isModuleInfo()) {
+		ModuleDeclaration module = upperScope.referenceContext.moduleDeclaration;
+		module.resolve(this.scope);
+		return;
+	}
 	resolve();
 	updateMaxFieldCount();
 }
@@ -1511,6 +1520,9 @@ void updateMaxFieldCount() {
 public boolean isPackageInfo() {
 	return CharOperation.equals(this.name,  TypeConstants.PACKAGE_INFO_NAME);
 }
+public boolean isModuleInfo() {
+	return CharOperation.equals(this.name,  TypeConstants.MODULE_INFO_NAME);
+}
 /**
  * Returns whether the type is a secondary one or not.
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index 46fc51b..81f2ce3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -28,6 +28,7 @@ public abstract class Binding {
 	public static final int METHOD = ASTNode.Bit4;
 	public static final int PACKAGE = ASTNode.Bit5;
 	public static final int IMPORT = ASTNode.Bit6;
+	public static final int MODULE = ASTNode.Bit7;
 	public static final int ARRAY_TYPE = TYPE | ASTNode.Bit7;
 	public static final int BASE_TYPE = TYPE | ASTNode.Bit8;
 	public static final int PARAMETERIZED_TYPE = TYPE | ASTNode.Bit9;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 7556ee3..d20f4d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -43,7 +43,6 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
@@ -652,7 +651,7 @@ public class ClassScope extends Scope {
 				// TBD - allowed only at source level 9 or above
 				modifiers = ClassFileConstants.AccModule;
 				if ((realModifiers & ~(ClassFileConstants.ACC_OPEN | ClassFileConstants.AccModule)) != 0) {
-					problemReporter().illegalModifierForModule((ModuleDeclaration) this.referenceContext);
+					problemReporter().illegalModifierForModule(compilationUnitScope().referenceContext.moduleDeclaration);
 				}
 				if ((realModifiers & ClassFileConstants.ACC_OPEN) != 0) {
 					modifiers |= ClassFileConstants.ACC_OPEN;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index 0669caa..ec463c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -23,7 +23,6 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IModuleContext;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
@@ -377,7 +376,7 @@ public class ModuleBinding extends Binding {
 	@Override
 	public int kind() {
 		//
-		return ClassFileConstants.AccModule;
+		return Binding.MODULE;
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 7c202aa..c03f87b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -20,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ModuleStatement;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -137,6 +142,12 @@ public RecoveredElement add(Statement statement, int bracketBalanceValue) {
 	this.updateSourceEndIfNecessary(previousAvailableLineEnd(statement.sourceStart - 1));
 	return this.parent.add(statement, bracketBalanceValue);
 }
+public RecoveredElement add(ModuleDeclaration moduleDeclaration, int bracketBalanceValue){
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(moduleDeclaration.declarationSourceStart - 1));
+	return this.parent.add(moduleDeclaration, bracketBalanceValue);
+}
 /*
  *	Record a type declaration
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredModule.java
index 261916d..0fa471a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredModule.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredModule.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -24,7 +24,7 @@ import org.eclipse.jdt.internal.compiler.ast.ProvidesStatement;
 import org.eclipse.jdt.internal.compiler.ast.RequiresStatement;
 import org.eclipse.jdt.internal.compiler.ast.UsesStatement;
 
-public class RecoveredModule extends RecoveredType {
+public class RecoveredModule extends RecoveredElement {
 	
 	public RecoveredExportsStatement[] exports;
 	public int exportCount;
@@ -36,9 +36,11 @@ public class RecoveredModule extends RecoveredType {
 	public int usesCount;
 	public RecoveredProvidesStatement[] services;
 	public int servicesCount;
+	public ModuleDeclaration moduleDeclaration;
 
 	public RecoveredModule(ModuleDeclaration moduleDeclaration, RecoveredElement parent, int bracketBalance) {
-		super(moduleDeclaration, parent, bracketBalance);
+		super(parent, bracketBalance);
+		this.moduleDeclaration = moduleDeclaration;
 	}
 	public RecoveredElement add(ModuleStatement moduleStatement, int bracketBalanceValue) {
 		
@@ -166,7 +168,7 @@ public class RecoveredModule extends RecoveredType {
 		StringBuffer result = new StringBuffer(tabString(tab));
 		result.append("Recovered module:\n"); //$NON-NLS-1$
 		result.append("module ");//$NON-NLS-1$
-		result.append(CharOperation.charToString(((ModuleDeclaration) this.typeDeclaration).moduleName));
+		result.append(CharOperation.charToString(this.moduleDeclaration.moduleName));
 		result.append(" {");//$NON-NLS-1$
 		if (this.exportCount > 0) {
 			for (int i = 0; i < this.exportCount; ++i) {
@@ -197,87 +199,86 @@ public class RecoveredModule extends RecoveredType {
 	}
 	public ModuleDeclaration updatedModuleDeclaration() {
 
-		ModuleDeclaration moduleDeclaration = (ModuleDeclaration) this.typeDeclaration;
-		updateExports(moduleDeclaration);
-		updateOpens(moduleDeclaration);
-		updateRequires(moduleDeclaration);
-		updateUses(moduleDeclaration);
-		updateServices(moduleDeclaration);
-		return moduleDeclaration;
+		updateExports(this.moduleDeclaration);
+		updateOpens(this.moduleDeclaration);
+		updateRequires(this.moduleDeclaration);
+		updateUses(this.moduleDeclaration);
+		updateServices(this.moduleDeclaration);
+		return this.moduleDeclaration;
 	}
-	private void updateExports(ModuleDeclaration moduleDeclaration) {
+	private void updateExports(ModuleDeclaration mod) {
 		if (this.exportCount > 0) {
-			int existingCount = moduleDeclaration.exportsCount, actualCount = 0;
+			int existingCount = mod.exportsCount, actualCount = 0;
 			ExportsStatement[] exports1 = new ExportsStatement[existingCount + this.exportCount];
 			if (existingCount > 0){
-				System.arraycopy(moduleDeclaration.exports, 0, exports1, 0, existingCount);
+				System.arraycopy(mod.exports, 0, exports1, 0, existingCount);
 				actualCount = existingCount;
 			}
 			for (int i = 0; i < this.exportCount; i++){
 				exports1[actualCount++] = (ExportsStatement)this.exports[i].updatedPackageVisibilityStatement();
 			}
-			moduleDeclaration.exports = exports1;
-			moduleDeclaration.exportsCount = actualCount;
+			mod.exports = exports1;
+			mod.exportsCount = actualCount;
 		}
 	}
-	private void updateOpens(ModuleDeclaration moduleDeclaration) {
+	private void updateOpens(ModuleDeclaration mod) {
 		if (this.opensCount > 0) {
-			int existingCount = moduleDeclaration.opensCount, actualCount = 0;
+			int existingCount = mod.opensCount, actualCount = 0;
 			OpensStatement[] opens1 = new OpensStatement[existingCount + this.opensCount];
 			if (existingCount > 0){
-				System.arraycopy(moduleDeclaration.exports, 0, opens1, 0, existingCount);
+				System.arraycopy(mod.exports, 0, opens1, 0, existingCount);
 				actualCount = existingCount;
 			}
 			for (int i = 0; i < this.opensCount; i++){
 				opens1[actualCount++] = (OpensStatement)this.opens[i].updatedPackageVisibilityStatement();
 			}
-			moduleDeclaration.opens = opens1;
-			moduleDeclaration.opensCount = actualCount;
+			mod.opens = opens1;
+			mod.opensCount = actualCount;
 		}
 	}
-	private void updateRequires(ModuleDeclaration moduleDeclaration) {
+	private void updateRequires(ModuleDeclaration mod) {
 		if (this.requiresCount > 0) {
-			int existingCount = moduleDeclaration.requiresCount, actualCount = 0;
+			int existingCount = mod.requiresCount, actualCount = 0;
 			RequiresStatement[] requiresStmts = new RequiresStatement[existingCount + this.requiresCount];
 			if (existingCount > 0){
-				System.arraycopy(moduleDeclaration.requires, 0, requiresStmts, 0, existingCount);
+				System.arraycopy(mod.requires, 0, requiresStmts, 0, existingCount);
 				actualCount = existingCount;
 			}
 			for (int i = 0; i < this.requiresCount; i++){
 				requiresStmts[actualCount++] = this.requires[i].updatedRequiresStatement();
 			}
-			moduleDeclaration.requires = requiresStmts;
-			moduleDeclaration.requiresCount = actualCount;
+			mod.requires = requiresStmts;
+			mod.requiresCount = actualCount;
 		}
 	}
-	private void updateUses(ModuleDeclaration moduleDeclaration) {
+	private void updateUses(ModuleDeclaration mod) {
 		if (this.usesCount > 0) {
-			int existingCount = moduleDeclaration.usesCount, actualCount = 0;
+			int existingCount = mod.usesCount, actualCount = 0;
 			UsesStatement[] usesStmts = new UsesStatement[existingCount + this.usesCount];
 			if (existingCount > 0){
-				System.arraycopy(moduleDeclaration.uses, 0, usesStmts, 0, existingCount);
+				System.arraycopy(mod.uses, 0, usesStmts, 0, existingCount);
 				actualCount = existingCount;
 			}
 			for (int i = 0; i < this.usesCount; ++i) {
 				usesStmts[actualCount++] = this.uses[i].updatedUsesStatement();
 			}
-			moduleDeclaration.uses = usesStmts;
-			moduleDeclaration.usesCount = actualCount;
+			mod.uses = usesStmts;
+			mod.usesCount = actualCount;
 		}
 	}
-	private void updateServices(ModuleDeclaration moduleDeclaration) {
+	private void updateServices(ModuleDeclaration mod) {
 		if (this.servicesCount > 0) {
-			int existingCount = moduleDeclaration.servicesCount, actualCount = 0;
+			int existingCount = mod.servicesCount, actualCount = 0;
 			ProvidesStatement[] providesStmts = new ProvidesStatement[existingCount + this.servicesCount];
 			if (existingCount > 0){
-				System.arraycopy(moduleDeclaration.services, 0, providesStmts, 0, existingCount);
+				System.arraycopy(mod.services, 0, providesStmts, 0, existingCount);
 				actualCount = existingCount;
 			}
 			for (int i = 0; i < this.servicesCount; ++i) {
 				providesStmts[actualCount++] = this.services[i].updatedProvidesStatement();
 			}
-			moduleDeclaration.services = providesStmts;
-			moduleDeclaration.servicesCount = actualCount;  			
+			mod.services = providesStmts;
+			mod.servicesCount = actualCount;  			
 		}
 	}
 	public void updateParseTree(){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
index d2aeaa8..386fb68 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -157,13 +161,12 @@ public RecoveredElement add(ImportReference importReference, int bracketBalanceV
 	if (importReference.declarationSourceEnd == 0) return element;
 	return this;
 }
+public RecoveredElement add(ModuleDeclaration moduleDeclaration, int bracketBalanceValue){
+	this.module = new RecoveredModule(moduleDeclaration, this, bracketBalanceValue);
+	return this.module;
+}
 public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue) {
 	
-	if (typeDeclaration instanceof ModuleDeclaration) {
-		this.module = new RecoveredModule((ModuleDeclaration)typeDeclaration, this, bracketBalanceValue);
-		return this.module;
-	}
-
 	if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0){
 		if (this.typeCount > 0) {
 			// add it to the last type
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 55e073b..ca150ed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -1371,22 +1371,32 @@ class ASTConverter {
 				}
 			}
 	
-			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;
-			if (types != null) {
-				int typesLength = types.length;
-				for (int i = 0; i < typesLength; i++) {
-					org.eclipse.jdt.internal.compiler.ast.TypeDeclaration declaration = types[i];
-					if (CharOperation.equals(declaration.name, TypeConstants.PACKAGE_INFO_NAME)) {
-						continue;
-					}
-					ASTNode type = convert(declaration);
-					if (type == null) {
-						compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
-					} else {
-						if (type instanceof ModuleDeclaration)
-							compilationUnit.setModule((ModuleDeclaration) type);
-						else
-							compilationUnit.types().add(type);
+			org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration mod = unit.moduleDeclaration;
+			if (mod != null) {
+				ASTNode declaration = convertToModuleDeclaration(mod);
+				if (declaration == null) {
+					compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
+				} else {
+					compilationUnit.setModule((ModuleDeclaration) declaration);
+				}
+			} else {
+				org.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;
+				if (types != null) {
+					int typesLength = types.length;
+					for (int i = 0; i < typesLength; i++) {
+						org.eclipse.jdt.internal.compiler.ast.TypeDeclaration declaration = types[i];
+						if (CharOperation.equals(declaration.name, TypeConstants.PACKAGE_INFO_NAME)) {
+							continue;
+						}
+						ASTNode type = convert(declaration);
+						if (type == null) {
+							compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
+						} else {
+							if (type instanceof ModuleDeclaration)
+								compilationUnit.setModule((ModuleDeclaration) type);
+							else
+								compilationUnit.types().add(type);
+						}
 					}
 				}
 			}
@@ -2960,12 +2970,6 @@ class ASTConverter {
 				} else {
 					return convertToAnnotationDeclaration(typeDeclaration);
 				}
-			case org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.MODULE_DECL :
-				if (this.ast.apiLevel < AST.JLS9_INTERNAL) {
-					return null;
-				} else {
-					return convertToModuleDeclaration(typeDeclaration);
-				}
 		}
 
 		checkCanceled();
@@ -3292,12 +3296,12 @@ class ASTConverter {
 		return fieldDeclaration;
 	}
 
-	public ModuleDeclaration convertToModuleDeclaration(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
+	public ModuleDeclaration convertToModuleDeclaration(org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration) {
 		checkCanceled();
 		if (this.scanner.sourceLevel < ClassFileConstants.JDK9) return null;
-		org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) typeDeclaration;
 		ModuleDeclaration moduleDecl = this.ast.newModuleDeclaration();
-		convert(moduleDeclaration.javadoc, moduleDecl);
+		// TODO
+		//convert(moduleDeclaration.javadoc, moduleDecl);
 		setModifiers(moduleDecl, moduleDeclaration);
 		Name moduleName = getName(moduleDeclaration, CharOperation.splitOn('.', moduleDeclaration.moduleName), moduleDeclaration.sourcePositions);
 		moduleDecl.setName(moduleName);
@@ -5283,9 +5287,9 @@ class ASTConverter {
 		}
 	}
 
-	protected void setModifiers(ModuleDeclaration moduleDecl, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
-		this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
-		this.setModifiers(moduleDecl.modifiers(), typeDeclaration.annotations, typeDeclaration.sourceStart);
+	protected void setModifiers(ModuleDeclaration moduleDecl, org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration) {
+		this.scanner.resetTo(moduleDeclaration.declarationSourceStart, moduleDeclaration.sourceStart);
+		this.setModifiers(moduleDecl.modifiers(), moduleDeclaration.annotations, moduleDeclaration.sourceStart);
 	}
 	/**
 	 * @param variableDecl
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
index 195671d..8ca1eeb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
@@ -22,6 +22,7 @@ import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 
 /*
@@ -51,13 +52,20 @@ import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 @SuppressWarnings("rawtypes")
 public interface ISourceElementRequestor {
 
-	public static class ModuleInfo extends TypeInfo {
+	public static class ModuleInfo {
+		public int declarationStart;
+		public int modifiers;
+		public char[] name;
+		public int nameSourceStart;
+		public int nameSourceEnd;
 		public char[] moduleName;
 		public RequiresInfo[] requires;
 		public PackageExportInfo[] exports;
 		public ServicesInfo[] services;
 		public PackageExportInfo[] opens;
 		public char[][] usedServices;
+		public Annotation[] annotations;
+		public ModuleDeclaration node;
 	}
 	public static class RequiresInfo {
 		public char[] moduleName;
@@ -225,4 +233,11 @@ public interface ISourceElementRequestor {
 	void exitMethod(int declarationEnd, Expression defaultValue);
 
 	void exitType(int declarationEnd);
+	
+	default void enterModule(ModuleInfo info) {
+		// do nothing
+	}
+	default void exitModule(int declarationEnd) {
+		// do nothing
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
index 9663736..b35eb20 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
@@ -18,7 +18,6 @@ import java.util.ArrayList;
 import java.util.Map;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.ModuleInfo;
 import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.ParameterInfo;
 import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.TypeParameterInfo;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -465,7 +464,12 @@ public void notifySourceElementRequestor(
 						notifySourceElementRequestor(importRef, false);
 					}
 				} else { // instanceof TypeDeclaration
-					notifySourceElementRequestor((TypeDeclaration)node, true, null, currentPackage);
+					TypeDeclaration type = (TypeDeclaration) node;
+					if (type.isModuleInfo()) {
+						notifySourceElementRequestor(parsedUnit.moduleDeclaration);
+					} else {
+						notifySourceElementRequestor((TypeDeclaration)node, true, null, currentPackage);
+					}
 				}
 			}
 		}
@@ -584,6 +588,31 @@ protected void notifySourceElementRequestor(
 			importReference.modifiers);
 	}
 }
+protected void notifySourceElementRequestor(ModuleDeclaration moduleDeclaration) {
+	boolean isInRange =
+			this.initialPosition <= moduleDeclaration.declarationSourceStart
+			&& this.eofPosition >= moduleDeclaration.declarationSourceEnd;
+	ISourceElementRequestor.ModuleInfo info = new ISourceElementRequestor.ModuleInfo();
+	if (isInRange) {
+
+		int currentModifiers = moduleDeclaration.modifiers;
+
+		// remember deprecation so as to not lose it below
+		boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(moduleDeclaration.annotations);
+
+		info.declarationStart = moduleDeclaration.declarationSourceStart;
+		info.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
+		info.name = TypeConstants.MODULE_INFO_NAME;
+		info.nameSourceStart = moduleDeclaration.sourceStart;
+		info.nameSourceEnd = moduleDeclaration.sourceEnd;
+		info.moduleName = moduleDeclaration.moduleName;
+		info.annotations = moduleDeclaration.annotations;
+		info.node = moduleDeclaration;
+		fillModuleInfo(moduleDeclaration, info);
+		this.requestor.enterModule(info);
+		this.requestor.exitModule(moduleDeclaration.declarationSourceEnd);
+	}
+}
 protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType, ImportReference currentPackage) {
 
 	if (CharOperation.equals(TypeConstants.PACKAGE_INFO_NAME, typeDeclaration.name)) return;
@@ -607,7 +636,7 @@ protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boo
 		char[][] interfaceNames = getInterfaceNames(typeDeclaration);
 		int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
 		char[] implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
-		ISourceElementRequestor.TypeInfo typeInfo = kind == TypeDeclaration.MODULE_DECL ? new ISourceElementRequestor.ModuleInfo(): new ISourceElementRequestor.TypeInfo();
+		ISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();
 		typeInfo.typeAnnotated = ((typeDeclaration.bits & ASTNode.HasTypeAnnotations) != 0);
 		if (isInRange) {
 			int currentModifiers = typeDeclaration.modifiers;
@@ -643,7 +672,6 @@ protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boo
 			typeInfo.annotations = typeDeclaration.annotations;
 			typeInfo.extraFlags = ExtraFlags.getExtraFlags(typeDeclaration);
 			typeInfo.node = typeDeclaration;
-			fillModuleInfo(typeDeclaration, typeInfo, kind);
 			this.requestor.enterType(typeInfo);
 			switch (kind) {
 				case TypeDeclaration.CLASS_DECL :
@@ -720,11 +748,7 @@ protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boo
 		this.nestedTypeIndex--;
 	}
 }
-private void fillModuleInfo(TypeDeclaration typeDeclaration, ISourceElementRequestor.TypeInfo typeInfo, int kind) {
-	if (kind != TypeDeclaration.MODULE_DECL) return;
-	ModuleDeclaration mod = (ModuleDeclaration)typeDeclaration;
-	ModuleInfo modInfo = (ModuleInfo)typeInfo;
-	modInfo.moduleName = mod.moduleName;
+private void fillModuleInfo(ModuleDeclaration mod, ISourceElementRequestor.ModuleInfo modInfo) {
 	if (mod.requiresCount > 0) {
 		ISourceElementRequestor.RequiresInfo reqs[] = new ISourceElementRequestor.RequiresInfo[mod.requiresCount];
 		for (int i = 0; i < mod.requiresCount; i++) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
index bb0c2e2..fa18b9c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
@@ -41,7 +41,6 @@ import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.Literal;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
-import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
@@ -501,7 +500,17 @@ private LocalVariable[] acceptMethodParameters(Argument[] arguments, JavaElement
 	}
 	return result;
 }
+public void enterModule(ModuleInfo info) {
 
+	Object parentInfo = this.infoStack.peek();
+	JavaElement parentHandle= (JavaElement) this.handleStack.peek();
+	JavaElement handle = createModuleHandle(parentHandle, info);
+	
+	this.infoStack.push(info);
+	this.handleStack.push(handle);
+
+	addToChildren(parentInfo, handle);
+}
 /**
  * @see ISourceElementRequestor
  */
@@ -509,15 +518,9 @@ public void enterType(TypeInfo typeInfo) {
 
 	Object parentInfo = this.infoStack.peek();
 	JavaElement parentHandle= (JavaElement) this.handleStack.peek();
-	JavaElement handle = null;
-	if (typeInfo instanceof ModuleInfo) {
-		handle = createModuleHandle(parentHandle, (ModuleInfo) typeInfo);
-	} else {
-		handle = createTypeHandle(parentHandle, typeInfo);
-		 //NB: occurenceCount is computed in resolveDuplicates
-		resolveDuplicates((SourceType) handle);
-	}
-
+	JavaElement handle = createTypeHandle(parentHandle, typeInfo);
+	 //NB: occurenceCount is computed in resolveDuplicates
+	resolveDuplicates((SourceType) handle);
 	this.infoStack.push(typeInfo);
 	this.handleStack.push(handle);
 
@@ -526,7 +529,7 @@ public void enterType(TypeInfo typeInfo) {
 	addToChildren(parentInfo, handle);
 }
 private org.eclipse.jdt.internal.core.ModuleDescriptionInfo createModuleInfo(ModuleInfo modInfo, org.eclipse.jdt.internal.core.SourceModule handle) {
-	org.eclipse.jdt.internal.core.ModuleDescriptionInfo info = org.eclipse.jdt.internal.core.ModuleDescriptionInfo.createModule((ModuleDeclaration) modInfo.node);
+	org.eclipse.jdt.internal.core.ModuleDescriptionInfo info = org.eclipse.jdt.internal.core.ModuleDescriptionInfo.createModule(modInfo.node);
 	info.setHandle(handle);
 	info.setSourceRangeStart(modInfo.declarationStart);
 	info.setFlags(modInfo.modifiers);
@@ -729,32 +732,34 @@ public void exitMethod(int declarationEnd, Expression defaultValue) {
 	this.handleStack.pop();
 	this.infoStack.pop();
 }
+public void exitModule(int declarationEnd) {
+	ModuleInfo moduleInfo = (ModuleInfo) this.infoStack.peek();
+	SourceModule handle = (SourceModule) this.handleStack.peek();
+	JavaProject proj = (JavaProject) handle.getAncestor(IJavaElement.JAVA_PROJECT);
+	if (proj != null) {
+		try {
+			org.eclipse.jdt.internal.core.SourceModule moduleDecl = handle;
+			org.eclipse.jdt.internal.core.ModuleDescriptionInfo info = createModuleInfo(moduleInfo, moduleDecl);
+			info.setSourceRangeEnd(declarationEnd);
+			info.children = getChildren(info);
+			this.unitInfo.setModule(moduleDecl);
+			proj.setModuleDescription(moduleDecl);
+		} catch (JavaModelException e) {
+			// Unexpected while creating
+		}
+	}
+	this.handleStack.pop();
+	this.infoStack.pop();
+}
 /**
  * @see ISourceElementRequestor
  */
 public void exitType(int declarationEnd) {
 	TypeInfo typeInfo = (TypeInfo) this.infoStack.peek();
-	if (typeInfo instanceof ModuleInfo) {
-		SourceModule handle = (SourceModule) this.handleStack.peek();
-		JavaProject proj = (JavaProject) handle.getAncestor(IJavaElement.JAVA_PROJECT);
-		if (proj != null) {
-			try {
-				org.eclipse.jdt.internal.core.SourceModule moduleDecl = handle;
-				org.eclipse.jdt.internal.core.ModuleDescriptionInfo info = createModuleInfo((ModuleInfo) typeInfo, moduleDecl);
-				info.setSourceRangeEnd(declarationEnd);
-				info.children = getChildren(info);
-				this.unitInfo.setModule(moduleDecl);
-				proj.setModuleDescription(moduleDecl);
-			} catch (JavaModelException e) {
-				// Unexpected while creating
-			}
-		}
-	} else {
-		SourceType handle = (SourceType) this.handleStack.peek();
-		SourceTypeElementInfo info = createTypeInfo(typeInfo, handle);
-		info.setSourceRangeEnd(declarationEnd);
-		info.children = getChildren(typeInfo);
-	}
+	SourceType handle = (SourceType) this.handleStack.peek();
+	SourceTypeElementInfo info = createTypeInfo(typeInfo, handle);
+	info.setSourceRangeEnd(declarationEnd);
+	info.children = getChildren(typeInfo);
 	this.handleStack.pop();
 	this.infoStack.pop();
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index bea768f..2448f92 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -396,9 +396,6 @@ public void enterType(TypeInfo typeInfo) {
 		case TypeDeclaration.ENUM_DECL:
 			enterEnum(typeInfo);
 			break;
-		case TypeDeclaration.MODULE_DECL:
-			enterModule((ModuleInfo) typeInfo);
-			break;
 	}
 }
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index ea13b04..5e07161 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -2877,7 +2877,7 @@ protected void reportMatching(ModuleDeclaration module, IJavaElement parent, int
 	if (moduleDesc == null) // should not happen - safety net.
 		return;
 	if (accuracy > -1) { // report module declaration
-		SearchMatch match = this.patternLocator.newDeclarationMatch(module, moduleDesc, module.binding, accuracy, module.moduleName.length, this);
+		SearchMatch match = this.patternLocator.newDeclarationMatch(module, moduleDesc, module.moduleBinding, accuracy, module.moduleName.length, this);
 		report(match);
 	}
 	reportMatching(module.requires, module,  nodeSet, moduleDesc);
@@ -2930,14 +2930,14 @@ private void reportMatching(ProvidesStatement[] provides, ModuleDeclaration modu
 			if (intf != null) {
 				Integer level = (Integer) nodeSet.matchingNodes.removeKey(intf);
 				if (level != null)
-					this.patternLocator.matchReportReference(intf, moduleDesc, null, null, module.binding, level.intValue(), this);
+					this.patternLocator.matchReportReference(intf, moduleDesc, null, null, module.moduleBinding, level.intValue(), this);
 			}
 			TypeReference[] impls = service.implementations;
 			for (TypeReference impl : impls) {
 				if (impl != null) {
 					Integer level = (Integer) nodeSet.matchingNodes.removeKey(impl);
 					if (level != null)
-						this.patternLocator.matchReportReference(impl, moduleDesc, null, null, module.binding, level.intValue(), this);
+						this.patternLocator.matchReportReference(impl, moduleDesc, null, null, module.moduleBinding, level.intValue(), this);
 				}
 			}
 		}
@@ -2951,7 +2951,7 @@ private void reportMatching(UsesStatement[] uses, ModuleDeclaration module, Matc
 				if (intf != null) {
 					Integer level = (Integer) nodeSet.matchingNodes.removeKey(intf);
 					if (level != null) {
-						this.patternLocator.matchReportReference(intf, moduleDesc, null, null, module.binding, level.intValue(), this);
+						this.patternLocator.matchReportReference(intf, moduleDesc, null, null, module.moduleBinding, level.intValue(), this);
 					}
 				}
 			}
@@ -2967,8 +2967,9 @@ private void reportMatching(UsesStatement[] uses, ModuleDeclaration module, Matc
  * search pattern (i.e. the ones in the matching nodes set)
  */
 protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {
-	if (TypeDeclaration.kind(type.modifiers) == TypeDeclaration.MODULE_DECL) {
-		reportMatching((ModuleDeclaration) type, parent, accuracy, nodeSet, occurrenceCount);
+	if (type.isModuleInfo()) {
+		ModuleDeclaration mod = type.scope.compilationUnitScope().referenceContext.moduleDeclaration;
+		reportMatching(mod, parent, accuracy, nodeSet, occurrenceCount);
 		return;
 	}
 	// create type handle
commit 8da0e962f462b3ac291f0a38083147774d27e039
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Fri Apr 28 14:46:22 2017 +0530

    bug 511574 - [1.9] ModuleBinding.kind() uses wrong constant - fix test
    failure in search
    
    Change-Id: I111014c9696e01c03fe76e231d26bbaf38597b07

12	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 5e07161..1c9893e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -2719,10 +2719,18 @@ protected void reportMatching(CompilationUnitDeclaration unit, boolean mustResol
 		for (int i = 0, l = types.length; i < l; i++) {
 			if (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes
 			TypeDeclaration type = types[i];
-			Integer level = (Integer) nodeSet.matchingNodes.removeKey(type);
-			int accuracy = (level != null && matchedUnitContainer) ? level.intValue() : -1;
-			this.inTypeOccurrencesCounts = new HashtableOfIntValues();
-			reportMatching(type, null, accuracy, nodeSet, 1);
+			if (type.isModuleInfo()) {
+				ModuleDeclaration mod = type.scope.compilationUnitScope().referenceContext.moduleDeclaration;
+				Integer level = (Integer) nodeSet.matchingNodes.removeKey(mod);
+				int accuracy = (level != null && matchedUnitContainer) ? level.intValue() : -1;
+				reportMatching(mod, null, accuracy, nodeSet, 1);
+				return;
+			} else {
+				Integer level = (Integer) nodeSet.matchingNodes.removeKey(type);
+				int accuracy = (level != null && matchedUnitContainer) ? level.intValue() : -1;
+				this.inTypeOccurrencesCounts = new HashtableOfIntValues();
+				reportMatching(type, null, accuracy, nodeSet, 1);
+			}
 		}
 	}
 
@@ -2967,11 +2975,6 @@ private void reportMatching(UsesStatement[] uses, ModuleDeclaration module, Matc
  * search pattern (i.e. the ones in the matching nodes set)
  */
 protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {
-	if (type.isModuleInfo()) {
-		ModuleDeclaration mod = type.scope.compilationUnitScope().referenceContext.moduleDeclaration;
-		reportMatching(mod, parent, accuracy, nodeSet, occurrenceCount);
-		return;
-	}
 	// create type handle
 	IJavaElement enclosingElement = parent;
 	if (enclosingElement == null) {
