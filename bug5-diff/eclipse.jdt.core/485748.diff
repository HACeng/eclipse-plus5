commit 85672b1f54c6a7c6153897b09cba101c488e62e1
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Jan 25 13:04:48 2016 -0800

    Bug 485748 - Progress bar stays even after completion
    
    Restore all the calls to IProgressMonitor#done that were present prior
    to adoption of SubMonitor.
    
    Change-Id: I79926c6ebb3646e239c7ea7a76dc908eb9a99b99
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

53	47	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
156	150	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
60	52	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
850	817	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index f7c257e..765a32c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -1131,54 +1131,60 @@ public final class ImportRewrite {
 	 */
 	public final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException {
 
-		SubMonitor subMonitor = SubMonitor.convert(monitor,
-				Messages.bind(Messages.importRewrite_processDescription), 2);
-		if (!hasRecordedChanges()) {
-			this.createdImports= CharOperation.NO_STRINGS;
-			this.createdStaticImports= CharOperation.NO_STRINGS;
-			return new MultiTextEdit();
-		}
-
-		CompilationUnit usedAstRoot= this.astRoot;
-		if (usedAstRoot == null) {
-			ASTParser parser= ASTParser.newParser(AST.JLS8);
-			parser.setSource(this.compilationUnit);
-			parser.setFocalPosition(0); // reduced AST
-			parser.setResolveBindings(false);
-			usedAstRoot= (CompilationUnit) parser.createAST(subMonitor.split(1));
-		}
-
-		ImportRewriteConfiguration config= buildImportRewriteConfiguration();
-
-		ImportRewriteAnalyzer computer=
-			new ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);
-
-		for (String addedImport : this.addedImports) {
-			boolean isStatic = STATIC_PREFIX == addedImport.charAt(0);
-			String qualifiedName = addedImport.substring(1);
-			computer.addImport(isStatic, qualifiedName);
-		}
-
-		for (String removedImport : this.removedImports) {
-			boolean isStatic = STATIC_PREFIX == removedImport.charAt(0);
-			String qualifiedName = removedImport.substring(1);
-			computer.removeImport(isStatic, qualifiedName);
-		}
-
-		for (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {
-			computer.requireExplicitImport(false, typeExplicitSimpleName);
-		}
-
-		for (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {
-			computer.requireExplicitImport(true, staticExplicitSimpleName);
+		try {
+			SubMonitor subMonitor = SubMonitor.convert(monitor,
+					Messages.bind(Messages.importRewrite_processDescription), 2);
+			if (!hasRecordedChanges()) {
+				this.createdImports= CharOperation.NO_STRINGS;
+				this.createdStaticImports= CharOperation.NO_STRINGS;
+				return new MultiTextEdit();
+			}
+	
+			CompilationUnit usedAstRoot= this.astRoot;
+			if (usedAstRoot == null) {
+				ASTParser parser= ASTParser.newParser(AST.JLS8);
+				parser.setSource(this.compilationUnit);
+				parser.setFocalPosition(0); // reduced AST
+				parser.setResolveBindings(false);
+				usedAstRoot= (CompilationUnit) parser.createAST(subMonitor.split(1));
+			}
+	
+			ImportRewriteConfiguration config= buildImportRewriteConfiguration();
+	
+			ImportRewriteAnalyzer computer=
+				new ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);
+	
+			for (String addedImport : this.addedImports) {
+				boolean isStatic = STATIC_PREFIX == addedImport.charAt(0);
+				String qualifiedName = addedImport.substring(1);
+				computer.addImport(isStatic, qualifiedName);
+			}
+	
+			for (String removedImport : this.removedImports) {
+				boolean isStatic = STATIC_PREFIX == removedImport.charAt(0);
+				String qualifiedName = removedImport.substring(1);
+				computer.removeImport(isStatic, qualifiedName);
+			}
+	
+			for (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {
+				computer.requireExplicitImport(false, typeExplicitSimpleName);
+			}
+	
+			for (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {
+				computer.requireExplicitImport(true, staticExplicitSimpleName);
+			}
+	
+			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(subMonitor.split(1));
+	
+			this.createdImports= result.getCreatedImports();
+			this.createdStaticImports= result.getCreatedStaticImports();
+	
+			return result.getTextEdit();
+		} finally {
+			if (monitor != null) {
+				monitor.done();
+			}
 		}
-
-		ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(subMonitor.split(1));
-
-		this.createdImports= result.getCreatedImports();
-		this.createdStaticImports= result.getCreatedStaticImports();
-
-		return result.getTextEdit();
 	}
 
 	private ImportRewriteConfiguration buildImportRewriteConfiguration() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 59ed127..95e3c83 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -4133,170 +4133,176 @@ public final class JavaCore extends Plugin {
 	 * @since 3.1
 	 */
 	public static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException {
-		SubMonitor mainMonitor = SubMonitor.convert(monitor, Messages.javamodel_initialization, 100);
-		mainMonitor.subTask(Messages.javamodel_configuring_classpath_containers);
-
-		// initialize all containers and variables
-		JavaModelManager manager = JavaModelManager.getJavaModelManager();
 		try {
-			SubMonitor subMonitor = mainMonitor.split(50).setWorkRemaining(100); // 50% of the time is spent in initializing containers and variables
-			subMonitor.worked(5); // give feedback to the user that something is happening
-			manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
-			if (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations
-				manager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization
-			} else { // else wait for the batch initialization to finish
-				while (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {
-					subMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);
-					subMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());
-					synchronized(manager) {
-						try {
-							manager.wait(100);
-						} catch (InterruptedException e) {
-							// continue
+			SubMonitor mainMonitor = SubMonitor.convert(monitor, Messages.javamodel_initialization, 100);
+			mainMonitor.subTask(Messages.javamodel_configuring_classpath_containers);
+	
+			// initialize all containers and variables
+			JavaModelManager manager = JavaModelManager.getJavaModelManager();
+			try {
+				SubMonitor subMonitor = mainMonitor.split(50).setWorkRemaining(100); // 50% of the time is spent in initializing containers and variables
+				subMonitor.worked(5); // give feedback to the user that something is happening
+				manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
+				if (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations
+					manager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization
+				} else { // else wait for the batch initialization to finish
+					while (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {
+						subMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);
+						subMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());
+						synchronized(manager) {
+							try {
+								manager.wait(100);
+							} catch (InterruptedException e) {
+								// continue
+							}
 						}
 					}
 				}
+			} finally {
+				manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);
 			}
-		} finally {
-			manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);
-		}
-
-		// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )
-		// and recreate links for external folders if needed
-		mainMonitor.subTask(Messages.javamodel_resetting_source_attachment_properties);
-		final IJavaProject[] projects = manager.getJavaModel().getJavaProjects();
-		HashSet visitedPaths = new HashSet();
-		ExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();
-		for (int i = 0, length = projects.length; i < length; i++) {
-			JavaProject javaProject = (JavaProject) projects[i];
-			IClasspathEntry[] classpath;
-			try {
-				classpath = javaProject.getResolvedClasspath();
-			} catch (JavaModelException e) {
-				// project no longer exist: ignore
-				continue;
-			}
-			if (classpath != null) {
-				for (int j = 0, length2 = classpath.length; j < length2; j++) {
-					IClasspathEntry entry = classpath[j];
-					if (entry.getSourceAttachmentPath() != null) {
-						IPath entryPath = entry.getPath();
-						if (visitedPaths.add(entryPath)) {
-							Util.setSourceAttachmentProperty(entryPath, null);
+	
+			// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )
+			// and recreate links for external folders if needed
+			mainMonitor.subTask(Messages.javamodel_resetting_source_attachment_properties);
+			final IJavaProject[] projects = manager.getJavaModel().getJavaProjects();
+			HashSet visitedPaths = new HashSet();
+			ExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();
+			for (int i = 0, length = projects.length; i < length; i++) {
+				JavaProject javaProject = (JavaProject) projects[i];
+				IClasspathEntry[] classpath;
+				try {
+					classpath = javaProject.getResolvedClasspath();
+				} catch (JavaModelException e) {
+					// project no longer exist: ignore
+					continue;
+				}
+				if (classpath != null) {
+					for (int j = 0, length2 = classpath.length; j < length2; j++) {
+						IClasspathEntry entry = classpath[j];
+						if (entry.getSourceAttachmentPath() != null) {
+							IPath entryPath = entry.getPath();
+							if (visitedPaths.add(entryPath)) {
+								Util.setSourceAttachmentProperty(entryPath, null);
+							}
 						}
-					}
-					// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it
-					if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
-						IPath entryPath = entry.getPath();
-						if (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {
-							externalFoldersManager.addFolder(entryPath, true);
+						// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it
+						if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
+							IPath entryPath = entry.getPath();
+							if (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {
+								externalFoldersManager.addFolder(entryPath, true);
+							}
 						}
 					}
 				}
 			}
-		}
-		try {
-			externalFoldersManager.createPendingFolders(mainMonitor.split(1));
-		}
-		catch(JavaModelException jme) {
-			// Creation of external folder project failed. Log it and continue;
-			Util.log(jme, "Error while processing external folders"); //$NON-NLS-1$
-		}
-
-		// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
-		// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)
-		final JavaModel model = manager.getJavaModel();
-		try {
-			mainMonitor.subTask(Messages.javamodel_refreshing_external_jars);
-			model.refreshExternalArchives(
-				null/*refresh all projects*/,
-				mainMonitor.split(1) // 1% of the time is spent in jar refresh
-			);
-		} catch (JavaModelException e) {
-			// refreshing failed: ignore
-		}
-
-		// initialize delta state
-		mainMonitor.subTask(Messages.javamodel_initializing_delta_state);
-		manager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties
-		manager.deltaState.initializeRoots(true/*initAfteLoad*/);
-
-		// dummy query for waiting until the indexes are ready
-		mainMonitor.subTask(Messages.javamodel_configuring_searchengine);
-		SearchEngine engine = new SearchEngine();
-		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
-		try {
-			engine.searchAllTypeNames(
-				null,
-				SearchPattern.R_EXACT_MATCH,
-				"!@$#!@".toCharArray(), //$NON-NLS-1$
-				SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
-				IJavaSearchConstants.CLASS,
-				scope,
-				new TypeNameRequestor() {
-					public void acceptType(
-						int modifiers,
-						char[] packageName,
-						char[] simpleTypeName,
-						char[][] enclosingTypeNames,
-						String path) {
-						// no type to accept
-					}
-				},
-				// will not activate index query caches if indexes are not ready, since it would take to long
-				// to wait until indexes are fully rebuild
-				IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
-				mainMonitor.split(47) // 47% of the time is spent in the dummy search
-			);
-		} catch (JavaModelException e) {
-			// /search failed: ignore
-		} catch (OperationCanceledException e) {
-			if (mainMonitor.isCanceled())
-				throw e;
-			// else indexes were not ready: catch the exception so that jars are still refreshed
-		}
-
-		// check if the build state version number has changed since last session
-		// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)
-		mainMonitor.subTask(Messages.javamodel_getting_build_state_number);
-		QualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, "stateVersionNumber"); //$NON-NLS-1$
-		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
-		String versionNumber = null;
-		try {
-			versionNumber = root.getPersistentProperty(qName);
-		} catch (CoreException e) {
-			// could not read version number: consider it is new
-		}
-		String newVersionNumber = Byte.toString(State.VERSION);
-		if (!newVersionNumber.equals(versionNumber)) {
-			// build state version number has changed: touch every projects to force a rebuild
-			if (JavaBuilder.DEBUG)
-				System.out.println("Build state version number has changed"); //$NON-NLS-1$
-			IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
-				public void run(IProgressMonitor progressMonitor2) throws CoreException {
-					for (int i = 0, length = projects.length; i < length; i++) {
-						IJavaProject project = projects[i];
-						try {
-							if (JavaBuilder.DEBUG)
-								System.out.println("Touching " + project.getElementName()); //$NON-NLS-1$
-							new ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164
-							project.getProject().touch(progressMonitor2);
-						} catch (CoreException e) {
-							// could not touch this project: ignore
-						}
-					}
-				}
-			};
-			mainMonitor.subTask(Messages.javamodel_building_after_upgrade);
 			try {
-				ResourcesPlugin.getWorkspace().run(runnable, mainMonitor.split(1));
-			} catch (CoreException e) {
-				// could not touch all projects
+				externalFoldersManager.createPendingFolders(mainMonitor.split(1));
+			}
+			catch(JavaModelException jme) {
+				// Creation of external folder project failed. Log it and continue;
+				Util.log(jme, "Error while processing external folders"); //$NON-NLS-1$
 			}
+	
+			// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
+			// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)
+			final JavaModel model = manager.getJavaModel();
 			try {
-				root.setPersistentProperty(qName, newVersionNumber);
+				mainMonitor.subTask(Messages.javamodel_refreshing_external_jars);
+				model.refreshExternalArchives(
+					null/*refresh all projects*/,
+					mainMonitor.split(1) // 1% of the time is spent in jar refresh
+				);
+			} catch (JavaModelException e) {
+				// refreshing failed: ignore
+			}
+	
+			// initialize delta state
+			mainMonitor.subTask(Messages.javamodel_initializing_delta_state);
+			manager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties
+			manager.deltaState.initializeRoots(true/*initAfteLoad*/);
+	
+			// dummy query for waiting until the indexes are ready
+			mainMonitor.subTask(Messages.javamodel_configuring_searchengine);
+			SearchEngine engine = new SearchEngine();
+			IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+			try {
+				engine.searchAllTypeNames(
+					null,
+					SearchPattern.R_EXACT_MATCH,
+					"!@$#!@".toCharArray(), //$NON-NLS-1$
+					SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
+					IJavaSearchConstants.CLASS,
+					scope,
+					new TypeNameRequestor() {
+						public void acceptType(
+							int modifiers,
+							char[] packageName,
+							char[] simpleTypeName,
+							char[][] enclosingTypeNames,
+							String path) {
+							// no type to accept
+						}
+					},
+					// will not activate index query caches if indexes are not ready, since it would take to long
+					// to wait until indexes are fully rebuild
+					IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
+					mainMonitor.split(47) // 47% of the time is spent in the dummy search
+				);
+			} catch (JavaModelException e) {
+				// /search failed: ignore
+			} catch (OperationCanceledException e) {
+				if (mainMonitor.isCanceled())
+					throw e;
+				// else indexes were not ready: catch the exception so that jars are still refreshed
+			}
+	
+			// check if the build state version number has changed since last session
+			// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)
+			mainMonitor.subTask(Messages.javamodel_getting_build_state_number);
+			QualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, "stateVersionNumber"); //$NON-NLS-1$
+			IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+			String versionNumber = null;
+			try {
+				versionNumber = root.getPersistentProperty(qName);
 			} catch (CoreException e) {
-				Util.log(e, "Could not persist build state version number"); //$NON-NLS-1$
+				// could not read version number: consider it is new
+			}
+			String newVersionNumber = Byte.toString(State.VERSION);
+			if (!newVersionNumber.equals(versionNumber)) {
+				// build state version number has changed: touch every projects to force a rebuild
+				if (JavaBuilder.DEBUG)
+					System.out.println("Build state version number has changed"); //$NON-NLS-1$
+				IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
+					public void run(IProgressMonitor progressMonitor2) throws CoreException {
+						for (int i = 0, length = projects.length; i < length; i++) {
+							IJavaProject project = projects[i];
+							try {
+								if (JavaBuilder.DEBUG)
+									System.out.println("Touching " + project.getElementName()); //$NON-NLS-1$
+								new ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164
+								project.getProject().touch(progressMonitor2);
+							} catch (CoreException e) {
+								// could not touch this project: ignore
+							}
+						}
+					}
+				};
+				mainMonitor.subTask(Messages.javamodel_building_after_upgrade);
+				try {
+					ResourcesPlugin.getWorkspace().run(runnable, mainMonitor.split(1));
+				} catch (CoreException e) {
+					// could not touch all projects
+				}
+				try {
+					root.setPersistentProperty(qName, newVersionNumber);
+				} catch (CoreException e) {
+					Util.log(e, "Could not persist build state version number"); //$NON-NLS-1$
+				}
+			}
+		} finally {
+			if (monitor != null) {
+				monitor.done();
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 66ccb75..74f2b35 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -706,66 +706,74 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * @exception CoreException if the operation fails
 	 */
 	public void run(IProgressMonitor monitor) throws CoreException {
-		JavaModelManager manager = JavaModelManager.getJavaModelManager();
-		DeltaProcessor deltaProcessor = manager.getDeltaProcessor();
-		int previousDeltaCount = deltaProcessor.javaModelDeltas.size();
+		SubMonitor oldMonitor = this.progressMonitor;
 		try {
-			this.progressMonitor = SubMonitor.convert(monitor);
-			pushOperation(this);
+			JavaModelManager manager = JavaModelManager.getJavaModelManager();
+			DeltaProcessor deltaProcessor = manager.getDeltaProcessor();
+			int previousDeltaCount = deltaProcessor.javaModelDeltas.size();
 			try {
-				if (canModifyRoots()) {
-					// computes the root infos before executing the operation
-					// noop if aready initialized
-					JavaModelManager.getDeltaState().initializeRoots(false/*not initiAfterLoad*/);
+				this.progressMonitor = SubMonitor.convert(monitor);
+				pushOperation(this);
+				try {
+					if (canModifyRoots()) {
+						// computes the root infos before executing the operation
+						// noop if aready initialized
+						JavaModelManager.getDeltaState().initializeRoots(false/*not initiAfterLoad*/);
+					}
+	
+					executeOperation();
+				} finally {
+					if (isTopLevelOperation()) {
+						runPostActions();
+					}
 				}
-
-				executeOperation();
 			} finally {
-				if (isTopLevelOperation()) {
-					runPostActions();
-				}
-			}
-		} finally {
-			try {
-				// reacquire delta processor as it can have been reset during executeOperation()
-				deltaProcessor = manager.getDeltaProcessor();
-
-				// update JavaModel using deltas that were recorded during this operation
-				for (int i = previousDeltaCount, size = deltaProcessor.javaModelDeltas.size(); i < size; i++) {
-					deltaProcessor.updateJavaModel((IJavaElementDelta)deltaProcessor.javaModelDeltas.get(i));
-				}
-
-				// close the parents of the created elements and reset their project's cache (in case we are in an
-				// IWorkspaceRunnable and the clients wants to use the created element's parent)
-				// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=83646
-				for (int i = 0, length = this.resultElements.length; i < length; i++) {
-					IJavaElement element = this.resultElements[i];
-					Openable openable = (Openable) element.getOpenable();
-					if (!(openable instanceof CompilationUnit) || !((CompilationUnit) openable).isWorkingCopy()) { // a working copy must remain a child of its parent even after a move
-						((JavaElement) openable.getParent()).close();
+				try {
+					// reacquire delta processor as it can have been reset during executeOperation()
+					deltaProcessor = manager.getDeltaProcessor();
+	
+					// update JavaModel using deltas that were recorded during this operation
+					for (int i = previousDeltaCount, size = deltaProcessor.javaModelDeltas.size(); i < size; i++) {
+						deltaProcessor.updateJavaModel((IJavaElementDelta)deltaProcessor.javaModelDeltas.get(i));
 					}
-					switch (element.getElementType()) {
-						case IJavaElement.PACKAGE_FRAGMENT_ROOT:
-						case IJavaElement.PACKAGE_FRAGMENT:
-							deltaProcessor.projectCachesToReset.add(element.getJavaProject());
-							break;
+	
+					// close the parents of the created elements and reset their project's cache (in case we are in an
+					// IWorkspaceRunnable and the clients wants to use the created element's parent)
+					// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=83646
+					for (int i = 0, length = this.resultElements.length; i < length; i++) {
+						IJavaElement element = this.resultElements[i];
+						Openable openable = (Openable) element.getOpenable();
+						if (!(openable instanceof CompilationUnit) || !((CompilationUnit) openable).isWorkingCopy()) { // a working copy must remain a child of its parent even after a move
+							((JavaElement) openable.getParent()).close();
+						}
+						switch (element.getElementType()) {
+							case IJavaElement.PACKAGE_FRAGMENT_ROOT:
+							case IJavaElement.PACKAGE_FRAGMENT:
+								deltaProcessor.projectCachesToReset.add(element.getJavaProject());
+								break;
+						}
 					}
+					deltaProcessor.resetProjectCaches();
+	
+					// fire only iff:
+					// - the operation is a top level operation
+					// - the operation did produce some delta(s)
+					// - but the operation has not modified any resource
+					if (isTopLevelOperation()) {
+						if ((deltaProcessor.javaModelDeltas.size() > previousDeltaCount || !deltaProcessor.reconcileDeltas.isEmpty())
+								&& !hasModifiedResource()) {
+							deltaProcessor.fire(null, DeltaProcessor.DEFAULT_CHANGE_EVENT);
+						} // else deltas are fired while processing the resource delta
+					}
+				} finally {
+					popOperation();
 				}
-				deltaProcessor.resetProjectCaches();
-
-				// fire only iff:
-				// - the operation is a top level operation
-				// - the operation did produce some delta(s)
-				// - but the operation has not modified any resource
-				if (isTopLevelOperation()) {
-					if ((deltaProcessor.javaModelDeltas.size() > previousDeltaCount || !deltaProcessor.reconcileDeltas.isEmpty())
-							&& !hasModifiedResource()) {
-						deltaProcessor.fire(null, DeltaProcessor.DEFAULT_CHANGE_EVENT);
-					} // else deltas are fired while processing the resource delta
-				}
-			} finally {
-				popOperation();
 			}
+		} finally {
+			if (monitor != null) {
+				monitor.done();
+			}
+			this.progressMonitor = oldMonitor;
 		}
 	}
 	/**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
index d0be9e7..3bad36d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
@@ -242,6 +242,9 @@ public class BasicSearchEngine {
 			}
 		} finally {
 			requestor.endReporting();
+			if (monitor != null) {
+				monitor.done();
+			}
 		}
 	}
 	/**
@@ -503,7 +506,7 @@ public class BasicSearchEngine {
 
 	}
 
-boolean match(char[] patternName, int matchRule, char[] name) {
+	boolean match(char[] patternName, int matchRule, char[] name) {
 		boolean isCaseSensitive = (matchRule & SearchPattern.R_CASE_SENSITIVE) != 0;
 		if (patternName != null) {
 			boolean isCamelCase = (matchRule & (SearchPattern.R_CAMELCASE_MATCH | SearchPattern.R_CAMELCASE_SAME_PART_COUNT_MATCH)) != 0;
@@ -589,174 +592,191 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 		int waitingPolicy,
 		IProgressMonitor progressMonitor)  throws JavaModelException {
 
-		// Validate match rule first
-		final int validatedTypeMatchRule = SearchPattern.validateMatchRule(typeName == null ? null : new String (typeName), typeMatchRule);
-		
-		final int pkgMatchRule = SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE;
-		final char NoSuffix = IIndexConstants.TYPE_SUFFIX; // Used as TYPE_SUFFIX has no effect in method #match(char, char[] , int, char[], int , int, char[], char[])
-
-		// Debug
-		if (VERBOSE) {
-			Util.verbose("BasicSearchEngine.searchAllConstructorDeclarations(char[], char[], int, IJavaSearchScope, IRestrictedAccessConstructorRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
-			Util.verbose("	- package name: "+(packageName==null?"null":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- type name: "+(typeName==null?"null":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- type match rule: "+getMatchRuleString(typeMatchRule)); //$NON-NLS-1$
-			if (validatedTypeMatchRule != typeMatchRule) {
-				Util.verbose("	- validated type match rule: "+getMatchRuleString(validatedTypeMatchRule)); //$NON-NLS-1$
-			}
-			Util.verbose("	- scope: "+scope); //$NON-NLS-1$
-		}
-		if (validatedTypeMatchRule == -1) return; // invalid match rule => return no results
-
-		// Create pattern
-		IndexManager indexManager = JavaModelManager.getIndexManager();
-		final ConstructorDeclarationPattern pattern = new ConstructorDeclarationPattern(
-				packageName,
-				typeName,
-				validatedTypeMatchRule);
-
-		// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
-		final HashSet workingCopyPaths = new HashSet();
-		String workingCopyPath = null;
-		ICompilationUnit[] copies = getWorkingCopies();
-		final int copiesLength = copies == null ? 0 : copies.length;
-		if (copies != null) {
-			if (copiesLength == 1) {
-				workingCopyPath = copies[0].getPath().toString();
-			} else {
-				for (int i = 0; i < copiesLength; i++) {
-					ICompilationUnit workingCopy = copies[i];
-					workingCopyPaths.add(workingCopy.getPath().toString());
+		try {
+			// Validate match rule first
+			final int validatedTypeMatchRule = SearchPattern.validateMatchRule(typeName == null ? null : new String (typeName), typeMatchRule);
+			
+			final int pkgMatchRule = SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE;
+			final char NoSuffix = IIndexConstants.TYPE_SUFFIX; // Used as TYPE_SUFFIX has no effect in method #match(char, char[] , int, char[], int , int, char[], char[])
+	
+			// Debug
+			if (VERBOSE) {
+				Util.verbose("BasicSearchEngine.searchAllConstructorDeclarations(char[], char[], int, IJavaSearchScope, IRestrictedAccessConstructorRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
+				Util.verbose("	- package name: "+(packageName==null?"null":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- type name: "+(typeName==null?"null":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- type match rule: "+getMatchRuleString(typeMatchRule)); //$NON-NLS-1$
+				if (validatedTypeMatchRule != typeMatchRule) {
+					Util.verbose("	- validated type match rule: "+getMatchRuleString(validatedTypeMatchRule)); //$NON-NLS-1$
 				}
+				Util.verbose("	- scope: "+scope); //$NON-NLS-1$
 			}
-		}
-		final String singleWkcpPath = workingCopyPath;
-
-		// Index requestor
-		IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
-			public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
-				// Filter unexpected types
-				ConstructorDeclarationPattern record = (ConstructorDeclarationPattern)indexRecord;
-				
-				if ((record.extraFlags & ExtraFlags.IsMemberType) != 0) {
-					return true; // filter out member classes
-				}
-				if ((record.extraFlags & ExtraFlags.IsLocalType) != 0) {
-					return true; // filter out local and anonymous classes
-				}
-				switch (copiesLength) {
-					case 0:
-						break;
-					case 1:
-						if (singleWkcpPath.equals(documentPath)) {
-							return true; // filter out *the* working copy
-						}
-						break;
-					default:
-						if (workingCopyPaths.contains(documentPath)) {
-							return true; // filter out working copies
-						}
-						break;
+			if (validatedTypeMatchRule == -1) return; // invalid match rule => return no results
+	
+			// Create pattern
+			IndexManager indexManager = JavaModelManager.getIndexManager();
+			final ConstructorDeclarationPattern pattern = new ConstructorDeclarationPattern(
+					packageName,
+					typeName,
+					validatedTypeMatchRule);
+	
+			// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
+			final HashSet workingCopyPaths = new HashSet();
+			String workingCopyPath = null;
+			ICompilationUnit[] copies = getWorkingCopies();
+			final int copiesLength = copies == null ? 0 : copies.length;
+			if (copies != null) {
+				if (copiesLength == 1) {
+					workingCopyPath = copies[0].getPath().toString();
+				} else {
+					for (int i = 0; i < copiesLength; i++) {
+						ICompilationUnit workingCopy = copies[i];
+						workingCopyPaths.add(workingCopy.getPath().toString());
+					}
 				}
-
-				// Accept document path
-				AccessRestriction accessRestriction = null;
-				if (access != null) {
-					// Compute document relative path
-					int pkgLength = (record.declaringPackageName==null || record.declaringPackageName.length==0) ? 0 : record.declaringPackageName.length+1;
-					int nameLength = record.declaringSimpleName==null ? 0 : record.declaringSimpleName.length;
-					char[] path = new char[pkgLength+nameLength];
-					int pos = 0;
-					if (pkgLength > 0) {
-						System.arraycopy(record.declaringPackageName, 0, path, pos, pkgLength-1);
-						CharOperation.replace(path, '.', '/');
-						path[pkgLength-1] = '/';
-						pos += pkgLength;
+			}
+			final String singleWkcpPath = workingCopyPath;
+	
+			// Index requestor
+			IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
+				public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
+					// Filter unexpected types
+					ConstructorDeclarationPattern record = (ConstructorDeclarationPattern)indexRecord;
+					
+					if ((record.extraFlags & ExtraFlags.IsMemberType) != 0) {
+						return true; // filter out member classes
 					}
-					if (nameLength > 0) {
-						System.arraycopy(record.declaringSimpleName, 0, path, pos, nameLength);
-						pos += nameLength;
+					if ((record.extraFlags & ExtraFlags.IsLocalType) != 0) {
+						return true; // filter out local and anonymous classes
 					}
-					// Update access restriction if path is not empty
-					if (pos > 0) {
-						accessRestriction = access.getViolatedRestriction(path);
+					switch (copiesLength) {
+						case 0:
+							break;
+						case 1:
+							if (singleWkcpPath.equals(documentPath)) {
+								return true; // filter out *the* working copy
+							}
+							break;
+						default:
+							if (workingCopyPaths.contains(documentPath)) {
+								return true; // filter out working copies
+							}
+							break;
 					}
+	
+					// Accept document path
+					AccessRestriction accessRestriction = null;
+					if (access != null) {
+						// Compute document relative path
+						int pkgLength = (record.declaringPackageName==null || record.declaringPackageName.length==0) ? 0 : record.declaringPackageName.length+1;
+						int nameLength = record.declaringSimpleName==null ? 0 : record.declaringSimpleName.length;
+						char[] path = new char[pkgLength+nameLength];
+						int pos = 0;
+						if (pkgLength > 0) {
+							System.arraycopy(record.declaringPackageName, 0, path, pos, pkgLength-1);
+							CharOperation.replace(path, '.', '/');
+							path[pkgLength-1] = '/';
+							pos += pkgLength;
+						}
+						if (nameLength > 0) {
+							System.arraycopy(record.declaringSimpleName, 0, path, pos, nameLength);
+							pos += nameLength;
+						}
+						// Update access restriction if path is not empty
+						if (pos > 0) {
+							accessRestriction = access.getViolatedRestriction(path);
+						}
+					}
+					nameRequestor.acceptConstructor(
+							record.modifiers,
+							record.declaringSimpleName,
+							record.parameterCount,
+							record.signature,
+							record.parameterTypes,
+							record.parameterNames,
+							record.declaringTypeModifiers,
+							record.declaringPackageName,
+							record.extraFlags,
+							documentPath,
+							accessRestriction);
+					return true;
 				}
-				nameRequestor.acceptConstructor(
-						record.modifiers,
-						record.declaringSimpleName,
-						record.parameterCount,
-						record.signature,
-						record.parameterTypes,
-						record.parameterNames,
-						record.declaringTypeModifiers,
-						record.declaringPackageName,
-						record.extraFlags,
-						documentPath,
-						accessRestriction);
-				return true;
-			}
-		};
-
-		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
-		// add type names from indexes
-		indexManager.performConcurrentJob(
-			new PatternSearchJob(
-				pattern,
-				getDefaultSearchParticipant(), // Java search only
-				scope,
-				searchRequestor),
-			waitingPolicy,
-			subMonitor.split(Math.max(1000-copiesLength, 0)));
-
-		// add type names from working copies
-		if (copies != null) {
-			for (int i = 0; i < copiesLength; i++) {
-				SubMonitor iterationMonitor = subMonitor.split(1);
-				final ICompilationUnit workingCopy = copies[i];
-				if (scope instanceof HierarchyScope) {
-					if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
-				} else {
-					if (!scope.encloses(workingCopy)) continue;
-				}
-				
-				final String path = workingCopy.getPath().toString();
-				if (workingCopy.isConsistent()) {
-					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-					IType[] allTypes = workingCopy.getAllTypes();
-					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-						IType type = allTypes[j];
-						char[] simpleName = type.getElementName().toCharArray();
-						if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {
-							
-							int extraFlags = ExtraFlags.getExtraFlags(type);
-							
-							boolean hasConstructor = false;
-							
-							IMethod[] methods = type.getMethods();
-							for (int k = 0; k < methods.length; k++) {
-								IMethod method = methods[k];
-								if (method.isConstructor()) {
-									hasConstructor = true;
-									
-									String[] stringParameterNames = method.getParameterNames();
-									String[] stringParameterTypes = method.getParameterTypes();
-									int length = stringParameterNames.length;
-									char[][] parameterNames = new char[length][];
-									char[][] parameterTypes = new char[length][];
-									for (int l = 0; l < length; l++) {
-										parameterNames[l] = stringParameterNames[l].toCharArray();
-										parameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());
+			};
+	
+			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
+			// add type names from indexes
+			indexManager.performConcurrentJob(
+				new PatternSearchJob(
+					pattern,
+					getDefaultSearchParticipant(), // Java search only
+					scope,
+					searchRequestor),
+				waitingPolicy,
+				subMonitor.split(Math.max(1000-copiesLength, 0)));
+	
+			// add type names from working copies
+			if (copies != null) {
+				for (int i = 0; i < copiesLength; i++) {
+					SubMonitor iterationMonitor = subMonitor.split(1);
+					final ICompilationUnit workingCopy = copies[i];
+					if (scope instanceof HierarchyScope) {
+						if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
+					} else {
+						if (!scope.encloses(workingCopy)) continue;
+					}
+					
+					final String path = workingCopy.getPath().toString();
+					if (workingCopy.isConsistent()) {
+						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+						IType[] allTypes = workingCopy.getAllTypes();
+						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+							IType type = allTypes[j];
+							char[] simpleName = type.getElementName().toCharArray();
+							if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {
+								
+								int extraFlags = ExtraFlags.getExtraFlags(type);
+								
+								boolean hasConstructor = false;
+								
+								IMethod[] methods = type.getMethods();
+								for (int k = 0; k < methods.length; k++) {
+									IMethod method = methods[k];
+									if (method.isConstructor()) {
+										hasConstructor = true;
+										
+										String[] stringParameterNames = method.getParameterNames();
+										String[] stringParameterTypes = method.getParameterTypes();
+										int length = stringParameterNames.length;
+										char[][] parameterNames = new char[length][];
+										char[][] parameterTypes = new char[length][];
+										for (int l = 0; l < length; l++) {
+											parameterNames[l] = stringParameterNames[l].toCharArray();
+											parameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());
+										}
+										
+										nameRequestor.acceptConstructor(
+												method.getFlags(),
+												simpleName,
+												parameterNames.length,
+												null,// signature is not used for source type
+												parameterTypes, 
+												parameterNames,
+												type.getFlags(),
+												packageDeclaration,
+												extraFlags,
+												path,
+												null);
 									}
-									
+								}
+								
+								if (!hasConstructor) {
 									nameRequestor.acceptConstructor(
-											method.getFlags(),
+											Flags.AccPublic,
 											simpleName,
-											parameterNames.length,
-											null,// signature is not used for source type
-											parameterTypes, 
-											parameterNames,
+											-1,
+											null, // signature is not used for source type
+											CharOperation.NO_CHAR_CHAR,
+											CharOperation.NO_CHAR_CHAR,
 											type.getFlags(),
 											packageDeclaration,
 											extraFlags,
@@ -764,144 +784,133 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 											null);
 								}
 							}
-							
-							if (!hasConstructor) {
-								nameRequestor.acceptConstructor(
-										Flags.AccPublic,
-										simpleName,
-										-1,
-										null, // signature is not used for source type
-										CharOperation.NO_CHAR_CHAR,
-										CharOperation.NO_CHAR_CHAR,
-										type.getFlags(),
-										packageDeclaration,
-										extraFlags,
-										path,
-										null);
-							}
 						}
-					}
-				} else {
-					Parser basicParser = getParser();
-					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-					if (parsedUnit != null) {
-						final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-						class AllConstructorDeclarationsVisitor extends ASTVisitor {
-							private TypeDeclaration[] declaringTypes = new TypeDeclaration[0];
-							private int declaringTypesPtr = -1;
-							
-							private void endVisit(TypeDeclaration typeDeclaration) {
-								if (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {
+					} else {
+						Parser basicParser = getParser();
+						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+						if (parsedUnit != null) {
+							final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+							class AllConstructorDeclarationsVisitor extends ASTVisitor {
+								private TypeDeclaration[] declaringTypes = new TypeDeclaration[0];
+								private int declaringTypesPtr = -1;
+								
+								private void endVisit(TypeDeclaration typeDeclaration) {
+									if (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {
+									
+										if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
+											nameRequestor.acceptConstructor(
+													Flags.AccPublic,
+													typeName,
+													-1,
+													null, // signature is not used for source type
+													CharOperation.NO_CHAR_CHAR,
+													CharOperation.NO_CHAR_CHAR,
+													typeDeclaration.modifiers,
+													packageDeclaration,
+													ExtraFlags.getExtraFlags(typeDeclaration),
+													path,
+													null);
+										}
+									}
+									
+									this.declaringTypes[this.declaringTypesPtr] = null;
+									this.declaringTypesPtr--;
+								}
+								
+								public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+									endVisit(typeDeclaration);
+								}
 								
+								public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+									endVisit(memberTypeDeclaration);
+								}
+								
+								private boolean hasConstructor(TypeDeclaration typeDeclaration) {
+									AbstractMethodDeclaration[] methods = typeDeclaration.methods;
+									int length = methods == null ? 0 : methods.length;
+									for (int j = 0; j < length; j++) {
+										if (methods[j].isConstructor()) {
+											return true;
+										}
+									}
+									
+									return false;
+								}
+								public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
+									TypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];
 									if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
+										Argument[] arguments = constructorDeclaration.arguments;
+										int length = arguments == null ? 0 : arguments.length;
+										char[][] parameterNames = new char[length][];
+										char[][] parameterTypes = new char[length][];
+										for (int l = 0; l < length; l++) {
+											Argument argument = arguments[l];
+											parameterNames[l] = argument.name;
+											if (argument.type instanceof SingleTypeReference) {
+												parameterTypes[l] = ((SingleTypeReference)argument.type).token;
+											} else {
+												parameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');
+											}
+										}
+										
+										TypeDeclaration enclosing = typeDeclaration.enclosingType;
+										char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+										while (enclosing != null) {
+											enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+											if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+												enclosing = enclosing.enclosingType;
+											} else {
+												enclosing = null;
+											}
+										}
+										
 										nameRequestor.acceptConstructor(
-												Flags.AccPublic,
+												constructorDeclaration.modifiers,
 												typeName,
-												-1,
+												parameterNames.length,
 												null, // signature is not used for source type
-												CharOperation.NO_CHAR_CHAR,
-												CharOperation.NO_CHAR_CHAR,
+												parameterTypes,
+												parameterNames,
 												typeDeclaration.modifiers,
 												packageDeclaration,
 												ExtraFlags.getExtraFlags(typeDeclaration),
 												path,
 												null);
 									}
+									return false; // no need to find constructors from local/anonymous type
+								}
+								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+									return false; 
 								}
 								
-								this.declaringTypes[this.declaringTypesPtr] = null;
-								this.declaringTypesPtr--;
-							}
-							
-							public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-								endVisit(typeDeclaration);
-							}
-							
-							public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-								endVisit(memberTypeDeclaration);
-							}
-							
-							private boolean hasConstructor(TypeDeclaration typeDeclaration) {
-								AbstractMethodDeclaration[] methods = typeDeclaration.methods;
-								int length = methods == null ? 0 : methods.length;
-								for (int j = 0; j < length; j++) {
-									if (methods[j].isConstructor()) {
-										return true;
+								private boolean visit(TypeDeclaration typeDeclaration) {
+									if(this.declaringTypes.length <= ++this.declaringTypesPtr) {
+										int length = this.declaringTypesPtr;
+										System.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);
 									}
+									this.declaringTypes[this.declaringTypesPtr] = typeDeclaration;
+									return true;
 								}
 								
-								return false;
-							}
-							public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
-								TypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];
-								if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
-									Argument[] arguments = constructorDeclaration.arguments;
-									int length = arguments == null ? 0 : arguments.length;
-									char[][] parameterNames = new char[length][];
-									char[][] parameterTypes = new char[length][];
-									for (int l = 0; l < length; l++) {
-										Argument argument = arguments[l];
-										parameterNames[l] = argument.name;
-										if (argument.type instanceof SingleTypeReference) {
-											parameterTypes[l] = ((SingleTypeReference)argument.type).token;
-										} else {
-											parameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');
-										}
-									}
-									
-									TypeDeclaration enclosing = typeDeclaration.enclosingType;
-									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-									while (enclosing != null) {
-										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-											enclosing = enclosing.enclosingType;
-										} else {
-											enclosing = null;
-										}
-									}
-									
-									nameRequestor.acceptConstructor(
-											constructorDeclaration.modifiers,
-											typeName,
-											parameterNames.length,
-											null, // signature is not used for source type
-											parameterTypes,
-											parameterNames,
-											typeDeclaration.modifiers,
-											packageDeclaration,
-											ExtraFlags.getExtraFlags(typeDeclaration),
-											path,
-											null);
+								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+									return visit(typeDeclaration);
 								}
-								return false; // no need to find constructors from local/anonymous type
-							}
-							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-								return false; 
-							}
-							
-							private boolean visit(TypeDeclaration typeDeclaration) {
-								if(this.declaringTypes.length <= ++this.declaringTypesPtr) {
-									int length = this.declaringTypesPtr;
-									System.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);
+								
+								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+									return visit(memberTypeDeclaration);
 								}
-								this.declaringTypes[this.declaringTypesPtr] = typeDeclaration;
-								return true;
-							}
-							
-							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-								return visit(typeDeclaration);
-							}
-							
-							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-								return visit(memberTypeDeclaration);
 							}
+							parsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);
 						}
-						parsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
+		} finally {
+			if (progressMonitor != null) {
+				progressMonitor.done();
+			}
 		}
 	}
 
@@ -1536,112 +1545,118 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 			boolean waitForIndexes,
 			IProgressMonitor progressMonitor)  throws JavaModelException {
 
-		if (VERBOSE) {
-			Util.verbose("BasicSearchEngine.searchAllSecondaryTypeNames(IPackageFragmentRoot[], IRestrictedAccessTypeRequestor, boolean, IProgressMonitor)"); //$NON-NLS-1$
-			StringBuffer buffer = new StringBuffer("	- source folders: "); //$NON-NLS-1$
-			int length = sourceFolders.length;
-			for (int i=0; i<length; i++) {
-				if (i==0) {
-					buffer.append('[');
-				} else {
-					buffer.append(',');
+		try {
+			if (VERBOSE) {
+				Util.verbose("BasicSearchEngine.searchAllSecondaryTypeNames(IPackageFragmentRoot[], IRestrictedAccessTypeRequestor, boolean, IProgressMonitor)"); //$NON-NLS-1$
+				StringBuffer buffer = new StringBuffer("	- source folders: "); //$NON-NLS-1$
+				int length = sourceFolders.length;
+				for (int i=0; i<length; i++) {
+					if (i==0) {
+						buffer.append('[');
+					} else {
+						buffer.append(',');
+					}
+					buffer.append(sourceFolders[i].getElementName());
 				}
-				buffer.append(sourceFolders[i].getElementName());
+				buffer.append("]\n	- waitForIndexes: "); //$NON-NLS-1$
+				buffer.append(waitForIndexes);
+				Util.verbose(buffer.toString());
 			}
-			buffer.append("]\n	- waitForIndexes: "); //$NON-NLS-1$
-			buffer.append(waitForIndexes);
-			Util.verbose(buffer.toString());
-		}
-
-		IndexManager indexManager = JavaModelManager.getIndexManager();
-		final TypeDeclarationPattern pattern = new SecondaryTypeDeclarationPattern();
-
-		// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
-		final HashSet workingCopyPaths = new HashSet();
-		String workingCopyPath = null;
-		ICompilationUnit[] copies = getWorkingCopies();
-		final int copiesLength = copies == null ? 0 : copies.length;
-		if (copies != null) {
-			if (copiesLength == 1) {
-				workingCopyPath = copies[0].getPath().toString();
-			} else {
-				for (int i = 0; i < copiesLength; i++) {
-					ICompilationUnit workingCopy = copies[i];
-					workingCopyPaths.add(workingCopy.getPath().toString());
+	
+			IndexManager indexManager = JavaModelManager.getIndexManager();
+			final TypeDeclarationPattern pattern = new SecondaryTypeDeclarationPattern();
+	
+			// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
+			final HashSet workingCopyPaths = new HashSet();
+			String workingCopyPath = null;
+			ICompilationUnit[] copies = getWorkingCopies();
+			final int copiesLength = copies == null ? 0 : copies.length;
+			if (copies != null) {
+				if (copiesLength == 1) {
+					workingCopyPath = copies[0].getPath().toString();
+				} else {
+					for (int i = 0; i < copiesLength; i++) {
+						ICompilationUnit workingCopy = copies[i];
+						workingCopyPaths.add(workingCopy.getPath().toString());
+					}
 				}
 			}
-		}
-		final String singleWkcpPath = workingCopyPath;
-
-		// Index requestor
-		IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
-			public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
-				// Filter unexpected types
-				TypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;
-				if (!record.secondary) {
-					return true; // filter maint types
-				}
-				if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
-					return true; // filter out local and anonymous classes
-				}
-				switch (copiesLength) {
-					case 0:
-						break;
-					case 1:
-						if (singleWkcpPath.equals(documentPath)) {
-							return true; // fliter out *the* working copy
-						}
-						break;
-					default:
-						if (workingCopyPaths.contains(documentPath)) {
-							return true; // filter out working copies
-						}
-						break;
-				}
-
-				// Accept document path
-				AccessRestriction accessRestriction = null;
-				if (access != null) {
-					// Compute document relative path
-					int pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;
-					int nameLength = record.simpleName==null ? 0 : record.simpleName.length;
-					char[] path = new char[pkgLength+nameLength];
-					int pos = 0;
-					if (pkgLength > 0) {
-						System.arraycopy(record.pkg, 0, path, pos, pkgLength-1);
-						CharOperation.replace(path, '.', '/');
-						path[pkgLength-1] = '/';
-						pos += pkgLength;
+			final String singleWkcpPath = workingCopyPath;
+	
+			// Index requestor
+			IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
+				public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
+					// Filter unexpected types
+					TypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;
+					if (!record.secondary) {
+						return true; // filter maint types
 					}
-					if (nameLength > 0) {
-						System.arraycopy(record.simpleName, 0, path, pos, nameLength);
-						pos += nameLength;
+					if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
+						return true; // filter out local and anonymous classes
 					}
-					// Update access restriction if path is not empty
-					if (pos > 0) {
-						accessRestriction = access.getViolatedRestriction(path);
+					switch (copiesLength) {
+						case 0:
+							break;
+						case 1:
+							if (singleWkcpPath.equals(documentPath)) {
+								return true; // fliter out *the* working copy
+							}
+							break;
+						default:
+							if (workingCopyPaths.contains(documentPath)) {
+								return true; // filter out working copies
+							}
+							break;
 					}
-				}
-				nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
-				return true;
-			}
-		};
-
-		// add type names from indexes
-		try {
-			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
-			indexManager.performConcurrentJob(
-				new PatternSearchJob(
-					pattern,
-					getDefaultSearchParticipant(), // Java search only
-					createJavaSearchScope(sourceFolders),
-					searchRequestor),
-				waitForIndexes
-					? IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH
-					: IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH,
-				subMonitor.split(100));
-		} catch (OperationCanceledException oce) {
-			// do nothing
+	
+					// Accept document path
+					AccessRestriction accessRestriction = null;
+					if (access != null) {
+						// Compute document relative path
+						int pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;
+						int nameLength = record.simpleName==null ? 0 : record.simpleName.length;
+						char[] path = new char[pkgLength+nameLength];
+						int pos = 0;
+						if (pkgLength > 0) {
+							System.arraycopy(record.pkg, 0, path, pos, pkgLength-1);
+							CharOperation.replace(path, '.', '/');
+							path[pkgLength-1] = '/';
+							pos += pkgLength;
+						}
+						if (nameLength > 0) {
+							System.arraycopy(record.simpleName, 0, path, pos, nameLength);
+							pos += nameLength;
+						}
+						// Update access restriction if path is not empty
+						if (pos > 0) {
+							accessRestriction = access.getViolatedRestriction(path);
+						}
+					}
+					nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
+					return true;
+				}
+			};
+	
+			// add type names from indexes
+			try {
+				SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
+				indexManager.performConcurrentJob(
+					new PatternSearchJob(
+						pattern,
+						getDefaultSearchParticipant(), // Java search only
+						createJavaSearchScope(sourceFolders),
+						searchRequestor),
+					waitForIndexes
+						? IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH
+						: IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH,
+					subMonitor.split(100));
+			} catch (OperationCanceledException oce) {
+				// do nothing
+			}
+		} finally {
+			if (progressMonitor != null) {
+				progressMonitor.done();
+			}
 		}
 	}
 
@@ -1664,245 +1679,251 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 		int waitingPolicy,
 		IProgressMonitor progressMonitor)  throws JavaModelException {
 
-		// Validate match rule first
-		final int validatedTypeMatchRule = SearchPattern.validateMatchRule(typeName == null ? null : new String (typeName), typeMatchRule);
-
-		// Debug
-		if (VERBOSE) {
-			Util.verbose("BasicSearchEngine.searchAllTypeNames(char[], char[], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
-			Util.verbose("	- package name: "+(packageName==null?"null":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- package match rule: "+getMatchRuleString(packageMatchRule)); //$NON-NLS-1$
-			Util.verbose("	- type name: "+(typeName==null?"null":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- type match rule: "+getMatchRuleString(typeMatchRule)); //$NON-NLS-1$
-			if (validatedTypeMatchRule != typeMatchRule) {
-				Util.verbose("	- validated type match rule: "+getMatchRuleString(validatedTypeMatchRule)); //$NON-NLS-1$
-			}
-			Util.verbose("	- search for: "+searchFor); //$NON-NLS-1$
-			Util.verbose("	- scope: "+scope); //$NON-NLS-1$
-		}
-		if (validatedTypeMatchRule == -1) return; // invalid match rule => return no results
-
-		// Create pattern
-		IndexManager indexManager = JavaModelManager.getIndexManager();
-		final char typeSuffix;
-		switch(searchFor){
-			case IJavaSearchConstants.CLASS :
-				typeSuffix = IIndexConstants.CLASS_SUFFIX;
-				break;
-			case IJavaSearchConstants.CLASS_AND_INTERFACE :
-				typeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;
-				break;
-			case IJavaSearchConstants.CLASS_AND_ENUM :
-				typeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;
-				break;
-			case IJavaSearchConstants.INTERFACE :
-				typeSuffix = IIndexConstants.INTERFACE_SUFFIX;
-				break;
-			case IJavaSearchConstants.INTERFACE_AND_ANNOTATION :
-				typeSuffix = IIndexConstants.INTERFACE_AND_ANNOTATION_SUFFIX;
-				break;
-			case IJavaSearchConstants.ENUM :
-				typeSuffix = IIndexConstants.ENUM_SUFFIX;
-				break;
-			case IJavaSearchConstants.ANNOTATION_TYPE :
-				typeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
-				break;
-			default :
-				typeSuffix = IIndexConstants.TYPE_SUFFIX;
-				break;
-		}
-		final TypeDeclarationPattern pattern = packageMatchRule == SearchPattern.R_EXACT_MATCH
-			? new TypeDeclarationPattern(
-				packageName,
-				null,
-				typeName,
-				typeSuffix,
-				validatedTypeMatchRule)
-			: new QualifiedTypeDeclarationPattern(
-				packageName,
-				packageMatchRule,
-				typeName,
-				typeSuffix,
-				validatedTypeMatchRule);
-
-		// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
-		final HashSet workingCopyPaths = new HashSet();
-		String workingCopyPath = null;
-		ICompilationUnit[] copies = getWorkingCopies();
-		final int copiesLength = copies == null ? 0 : copies.length;
-		if (copies != null) {
-			if (copiesLength == 1) {
-				workingCopyPath = copies[0].getPath().toString();
-			} else {
-				for (int i = 0; i < copiesLength; i++) {
-					ICompilationUnit workingCopy = copies[i];
-					workingCopyPaths.add(workingCopy.getPath().toString());
+		try {
+			// Validate match rule first
+			final int validatedTypeMatchRule = SearchPattern.validateMatchRule(typeName == null ? null : new String (typeName), typeMatchRule);
+	
+			// Debug
+			if (VERBOSE) {
+				Util.verbose("BasicSearchEngine.searchAllTypeNames(char[], char[], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
+				Util.verbose("	- package name: "+(packageName==null?"null":new String(packageName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- package match rule: "+getMatchRuleString(packageMatchRule)); //$NON-NLS-1$
+				Util.verbose("	- type name: "+(typeName==null?"null":new String(typeName))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- type match rule: "+getMatchRuleString(typeMatchRule)); //$NON-NLS-1$
+				if (validatedTypeMatchRule != typeMatchRule) {
+					Util.verbose("	- validated type match rule: "+getMatchRuleString(validatedTypeMatchRule)); //$NON-NLS-1$
 				}
+				Util.verbose("	- search for: "+searchFor); //$NON-NLS-1$
+				Util.verbose("	- scope: "+scope); //$NON-NLS-1$
 			}
-		}
-		final String singleWkcpPath = workingCopyPath;
-
-		// Index requestor
-		IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
-			public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
-				// Filter unexpected types
-				TypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;
-				if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
-					return true; // filter out local and anonymous classes
+			if (validatedTypeMatchRule == -1) return; // invalid match rule => return no results
+	
+			// Create pattern
+			IndexManager indexManager = JavaModelManager.getIndexManager();
+			final char typeSuffix;
+			switch(searchFor){
+				case IJavaSearchConstants.CLASS :
+					typeSuffix = IIndexConstants.CLASS_SUFFIX;
+					break;
+				case IJavaSearchConstants.CLASS_AND_INTERFACE :
+					typeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;
+					break;
+				case IJavaSearchConstants.CLASS_AND_ENUM :
+					typeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;
+					break;
+				case IJavaSearchConstants.INTERFACE :
+					typeSuffix = IIndexConstants.INTERFACE_SUFFIX;
+					break;
+				case IJavaSearchConstants.INTERFACE_AND_ANNOTATION :
+					typeSuffix = IIndexConstants.INTERFACE_AND_ANNOTATION_SUFFIX;
+					break;
+				case IJavaSearchConstants.ENUM :
+					typeSuffix = IIndexConstants.ENUM_SUFFIX;
+					break;
+				case IJavaSearchConstants.ANNOTATION_TYPE :
+					typeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
+					break;
+				default :
+					typeSuffix = IIndexConstants.TYPE_SUFFIX;
+					break;
+			}
+			final TypeDeclarationPattern pattern = packageMatchRule == SearchPattern.R_EXACT_MATCH
+				? new TypeDeclarationPattern(
+					packageName,
+					null,
+					typeName,
+					typeSuffix,
+					validatedTypeMatchRule)
+				: new QualifiedTypeDeclarationPattern(
+					packageName,
+					packageMatchRule,
+					typeName,
+					typeSuffix,
+					validatedTypeMatchRule);
+	
+			// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
+			final HashSet workingCopyPaths = new HashSet();
+			String workingCopyPath = null;
+			ICompilationUnit[] copies = getWorkingCopies();
+			final int copiesLength = copies == null ? 0 : copies.length;
+			if (copies != null) {
+				if (copiesLength == 1) {
+					workingCopyPath = copies[0].getPath().toString();
+				} else {
+					for (int i = 0; i < copiesLength; i++) {
+						ICompilationUnit workingCopy = copies[i];
+						workingCopyPaths.add(workingCopy.getPath().toString());
+					}
 				}
-				switch (copiesLength) {
-					case 0:
-						break;
-					case 1:
-						if (singleWkcpPath.equals(documentPath)) {
-							return true; // filter out *the* working copy
+			}
+			final String singleWkcpPath = workingCopyPath;
+	
+			// Index requestor
+			IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
+				public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
+					// Filter unexpected types
+					TypeDeclarationPattern record = (TypeDeclarationPattern)indexRecord;
+					if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
+						return true; // filter out local and anonymous classes
+					}
+					switch (copiesLength) {
+						case 0:
+							break;
+						case 1:
+							if (singleWkcpPath.equals(documentPath)) {
+								return true; // filter out *the* working copy
+							}
+							break;
+						default:
+							if (workingCopyPaths.contains(documentPath)) {
+								return true; // filter out working copies
+							}
+							break;
+					}
+	
+					// Accept document path
+					AccessRestriction accessRestriction = null;
+					if (access != null) {
+						// Compute document relative path
+						int pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;
+						int nameLength = record.simpleName==null ? 0 : record.simpleName.length;
+						char[] path = new char[pkgLength+nameLength];
+						int pos = 0;
+						if (pkgLength > 0) {
+							System.arraycopy(record.pkg, 0, path, pos, pkgLength-1);
+							CharOperation.replace(path, '.', '/');
+							path[pkgLength-1] = '/';
+							pos += pkgLength;
 						}
-						break;
-					default:
-						if (workingCopyPaths.contains(documentPath)) {
-							return true; // filter out working copies
+						if (nameLength > 0) {
+							System.arraycopy(record.simpleName, 0, path, pos, nameLength);
+							pos += nameLength;
+						}
+						// Update access restriction if path is not empty
+						if (pos > 0) {
+							accessRestriction = access.getViolatedRestriction(path);
 						}
-						break;
-				}
-
-				// Accept document path
-				AccessRestriction accessRestriction = null;
-				if (access != null) {
-					// Compute document relative path
-					int pkgLength = (record.pkg==null || record.pkg.length==0) ? 0 : record.pkg.length+1;
-					int nameLength = record.simpleName==null ? 0 : record.simpleName.length;
-					char[] path = new char[pkgLength+nameLength];
-					int pos = 0;
-					if (pkgLength > 0) {
-						System.arraycopy(record.pkg, 0, path, pos, pkgLength-1);
-						CharOperation.replace(path, '.', '/');
-						path[pkgLength-1] = '/';
-						pos += pkgLength;
-					}
-					if (nameLength > 0) {
-						System.arraycopy(record.simpleName, 0, path, pos, nameLength);
-						pos += nameLength;
 					}
-					// Update access restriction if path is not empty
-					if (pos > 0) {
-						accessRestriction = access.getViolatedRestriction(path);
+					if (match(record.typeSuffix, record.modifiers)) {
+						nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
 					}
+					return true;
 				}
-				if (match(record.typeSuffix, record.modifiers)) {
-					nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
-				}
-				return true;
-			}
-		};
-
-		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
-		// add type names from indexes
-		indexManager.performConcurrentJob(
-			new PatternSearchJob(
-				pattern,
-				getDefaultSearchParticipant(), // Java search only
-				scope,
-				searchRequestor),
-			waitingPolicy,
-			subMonitor.split(Math.max(1000-copiesLength, 0)));
-
-		// add type names from working copies
-		if (copies != null) {
-			for (int i = 0; i < copiesLength; i++) {
-				SubMonitor iterationMonitor = subMonitor.split(i);
-				final ICompilationUnit workingCopy = copies[i];
-				if (scope instanceof HierarchyScope) {
-					if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
-				} else {
-					if (!scope.encloses(workingCopy)) continue;
-				}
-				final String path = workingCopy.getPath().toString();
-				if (workingCopy.isConsistent()) {
-					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-					IType[] allTypes = workingCopy.getAllTypes();
-					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-						IType type = allTypes[j];
-						IJavaElement parent = type.getParent();
-						char[][] enclosingTypeNames;
-						if (parent instanceof IType) {
-							char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
-							enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
-						} else {
-							enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-						}
-						char[] simpleName = type.getElementName().toCharArray();
-						int kind;
-						if (type.isEnum()) {
-							kind = TypeDeclaration.ENUM_DECL;
-						} else if (type.isAnnotation()) {
-							kind = TypeDeclaration.ANNOTATION_TYPE_DECL;
-						}	else if (type.isClass()) {
-							kind = TypeDeclaration.CLASS_DECL;
-						} else /*if (type.isInterface())*/ {
-							kind = TypeDeclaration.INTERFACE_DECL;
-						}
-						if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, kind, packageDeclaration, simpleName)) {
-							if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-								((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, type.getFlags()));
+			};
+	
+			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
+			// add type names from indexes
+			indexManager.performConcurrentJob(
+				new PatternSearchJob(
+					pattern,
+					getDefaultSearchParticipant(), // Java search only
+					scope,
+					searchRequestor),
+				waitingPolicy,
+				subMonitor.split(Math.max(1000-copiesLength, 0)));
+	
+			// add type names from working copies
+			if (copies != null) {
+				for (int i = 0; i < copiesLength; i++) {
+					SubMonitor iterationMonitor = subMonitor.split(i);
+					final ICompilationUnit workingCopy = copies[i];
+					if (scope instanceof HierarchyScope) {
+						if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
+					} else {
+						if (!scope.encloses(workingCopy)) continue;
+					}
+					final String path = workingCopy.getPath().toString();
+					if (workingCopy.isConsistent()) {
+						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+						IType[] allTypes = workingCopy.getAllTypes();
+						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+							IType type = allTypes[j];
+							IJavaElement parent = type.getParent();
+							char[][] enclosingTypeNames;
+							if (parent instanceof IType) {
+								char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
+								enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
 							} else {
-								nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
+								enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
 							}
-						}
-					}
-				} else {
-					Parser basicParser = getParser();
-					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-					if (parsedUnit != null) {
-						final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-						class AllTypeDeclarationsVisitor extends ASTVisitor {
-							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-								return false; // no local/anonymous type
+							char[] simpleName = type.getElementName().toCharArray();
+							int kind;
+							if (type.isEnum()) {
+								kind = TypeDeclaration.ENUM_DECL;
+							} else if (type.isAnnotation()) {
+								kind = TypeDeclaration.ANNOTATION_TYPE_DECL;
+							}	else if (type.isClass()) {
+								kind = TypeDeclaration.CLASS_DECL;
+							} else /*if (type.isInterface())*/ {
+								kind = TypeDeclaration.INTERFACE_DECL;
 							}
-							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
-								if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {
-									if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-										IType type = workingCopy.getType(new String(typeName));
-										((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, typeDeclaration.modifiers));
-									} else {
-										nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
-									}
+							if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, kind, packageDeclaration, simpleName)) {
+								if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+									((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, type.getFlags()));
+								} else {
+									nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
 								}
-								return true;
 							}
-							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
-								if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {
-									// compute enclosing type names
-									TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
-									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-									while (enclosing != null) {
-										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-											enclosing = enclosing.enclosingType;
+						}
+					} else {
+						Parser basicParser = getParser();
+						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+						if (parsedUnit != null) {
+							final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+							class AllTypeDeclarationsVisitor extends ASTVisitor {
+								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+									return false; // no local/anonymous type
+								}
+								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
+									if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {
+										if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+											IType type = workingCopy.getType(new String(typeName));
+											((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, typeDeclaration.modifiers));
 										} else {
-											enclosing = null;
+											nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
 										}
 									}
-									// report
-									if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-										IType type = workingCopy.getType(new String(enclosingTypeNames[0]));
-										for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
-											type = type.getType(new String(enclosingTypeNames[j]));
+									return true;
+								}
+								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
+									if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {
+										// compute enclosing type names
+										TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
+										char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+										while (enclosing != null) {
+											enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+											if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+												enclosing = enclosing.enclosingType;
+											} else {
+												enclosing = null;
+											}
+										}
+										// report
+										if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+											IType type = workingCopy.getType(new String(enclosingTypeNames[0]));
+											for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
+												type = type.getType(new String(enclosingTypeNames[j]));
+											}
+											((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, 0));
+										} else {
+											nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
 										}
-										((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, 0));
-									} else {
-										nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
 									}
+									return true;
 								}
-								return true;
 							}
+							parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 						}
-						parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
+		} finally {
+			if (progressMonitor != null) {
+				progressMonitor.done();
+			}
 		}
 	}
 
@@ -1923,266 +1944,278 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 		int waitingPolicy,
 		IProgressMonitor progressMonitor)  throws JavaModelException {
 
-		// Debug
-		if (VERBOSE) {
-			Util.verbose("BasicSearchEngine.searchAllTypeNames(char[][], char[][], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
-			Util.verbose("	- package name: "+(qualifications==null?"null":new String(CharOperation.concatWith(qualifications, ',')))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- type name: "+(typeNames==null?"null":new String(CharOperation.concatWith(typeNames, ',')))); //$NON-NLS-1$ //$NON-NLS-2$
-			Util.verbose("	- match rule: "+getMatchRuleString(matchRule)); //$NON-NLS-1$
-			Util.verbose("	- search for: "+searchFor); //$NON-NLS-1$
-			Util.verbose("	- scope: "+scope); //$NON-NLS-1$
-		}
-		IndexManager indexManager = JavaModelManager.getIndexManager();
-
-		// Create pattern
-		final char typeSuffix;
-		switch(searchFor){
-			case IJavaSearchConstants.CLASS :
-				typeSuffix = IIndexConstants.CLASS_SUFFIX;
-				break;
-			case IJavaSearchConstants.CLASS_AND_INTERFACE :
-				typeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;
-				break;
-			case IJavaSearchConstants.CLASS_AND_ENUM :
-				typeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;
-				break;
-			case IJavaSearchConstants.INTERFACE :
-				typeSuffix = IIndexConstants.INTERFACE_SUFFIX;
-				break;
-			case IJavaSearchConstants.INTERFACE_AND_ANNOTATION :
-				typeSuffix = IIndexConstants.INTERFACE_AND_ANNOTATION_SUFFIX;
-				break;
-			case IJavaSearchConstants.ENUM :
-				typeSuffix = IIndexConstants.ENUM_SUFFIX;
-				break;
-			case IJavaSearchConstants.ANNOTATION_TYPE :
-				typeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
-				break;
-			default :
-				typeSuffix = IIndexConstants.TYPE_SUFFIX;
-				break;
-		}
-		final MultiTypeDeclarationPattern pattern = new MultiTypeDeclarationPattern(qualifications, typeNames, typeSuffix, matchRule);
-
-		// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
-		final HashSet workingCopyPaths = new HashSet();
-		String workingCopyPath = null;
-		ICompilationUnit[] copies = getWorkingCopies();
-		final int copiesLength = copies == null ? 0 : copies.length;
-		if (copies != null) {
-			if (copiesLength == 1) {
-				workingCopyPath = copies[0].getPath().toString();
-			} else {
-				for (int i = 0; i < copiesLength; i++) {
-					ICompilationUnit workingCopy = copies[i];
-					workingCopyPaths.add(workingCopy.getPath().toString());
-				}
+		try {
+			// Debug
+			if (VERBOSE) {
+				Util.verbose("BasicSearchEngine.searchAllTypeNames(char[][], char[][], int, int, IJavaSearchScope, IRestrictedAccessTypeRequestor, int, IProgressMonitor)"); //$NON-NLS-1$
+				Util.verbose("	- package name: "+(qualifications==null?"null":new String(CharOperation.concatWith(qualifications, ',')))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- type name: "+(typeNames==null?"null":new String(CharOperation.concatWith(typeNames, ',')))); //$NON-NLS-1$ //$NON-NLS-2$
+				Util.verbose("	- match rule: "+getMatchRuleString(matchRule)); //$NON-NLS-1$
+				Util.verbose("	- search for: "+searchFor); //$NON-NLS-1$
+				Util.verbose("	- scope: "+scope); //$NON-NLS-1$
 			}
-		}
-		final String singleWkcpPath = workingCopyPath;
-
-		// Index requestor
-		IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
-			public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
-				// Filter unexpected types
-				QualifiedTypeDeclarationPattern record = (QualifiedTypeDeclarationPattern) indexRecord;
-				if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
-					return true; // filter out local and anonymous classes
-				}
-				switch (copiesLength) {
-					case 0:
-						break;
-					case 1:
-						if (singleWkcpPath.equals(documentPath)) {
-							return true; // filter out *the* working copy
-						}
-						break;
-					default:
-						if (workingCopyPaths.contains(documentPath)) {
-							return true; // filter out working copies
-						}
-						break;
-				}
-
-				// Accept document path
-				AccessRestriction accessRestriction = null;
-				if (access != null) {
-					// Compute document relative path
-					int qualificationLength = (record.qualification == null || record.qualification.length == 0) ? 0 : record.qualification.length + 1;
-					int nameLength = record.simpleName == null ? 0 : record.simpleName.length;
-					char[] path = new char[qualificationLength + nameLength];
-					int pos = 0;
-					if (qualificationLength > 0) {
-						System.arraycopy(record.qualification, 0, path, pos, qualificationLength - 1);
-						CharOperation.replace(path, '.', '/');
-
-						// Access rules work on package level and should not discriminate on enclosing types.
-						boolean isNestedType = record.enclosingTypeNames != null && record.enclosingTypeNames.length > 0;
-						path[qualificationLength-1] = isNestedType ? '$' : '/';
-						pos += qualificationLength;
-					}
-					if (nameLength > 0) {
-						System.arraycopy(record.simpleName, 0, path, pos, nameLength);
-						pos += nameLength;
-					}
-					// Update access restriction if path is not empty
-					if (pos > 0) {
-						accessRestriction = access.getViolatedRestriction(path);
+			IndexManager indexManager = JavaModelManager.getIndexManager();
+	
+			// Create pattern
+			final char typeSuffix;
+			switch(searchFor){
+				case IJavaSearchConstants.CLASS :
+					typeSuffix = IIndexConstants.CLASS_SUFFIX;
+					break;
+				case IJavaSearchConstants.CLASS_AND_INTERFACE :
+					typeSuffix = IIndexConstants.CLASS_AND_INTERFACE_SUFFIX;
+					break;
+				case IJavaSearchConstants.CLASS_AND_ENUM :
+					typeSuffix = IIndexConstants.CLASS_AND_ENUM_SUFFIX;
+					break;
+				case IJavaSearchConstants.INTERFACE :
+					typeSuffix = IIndexConstants.INTERFACE_SUFFIX;
+					break;
+				case IJavaSearchConstants.INTERFACE_AND_ANNOTATION :
+					typeSuffix = IIndexConstants.INTERFACE_AND_ANNOTATION_SUFFIX;
+					break;
+				case IJavaSearchConstants.ENUM :
+					typeSuffix = IIndexConstants.ENUM_SUFFIX;
+					break;
+				case IJavaSearchConstants.ANNOTATION_TYPE :
+					typeSuffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
+					break;
+				default :
+					typeSuffix = IIndexConstants.TYPE_SUFFIX;
+					break;
+			}
+			final MultiTypeDeclarationPattern pattern = new MultiTypeDeclarationPattern(qualifications, typeNames, typeSuffix, matchRule);
+	
+			// Get working copy path(s). Store in a single string in case of only one to optimize comparison in requestor
+			final HashSet workingCopyPaths = new HashSet();
+			String workingCopyPath = null;
+			ICompilationUnit[] copies = getWorkingCopies();
+			final int copiesLength = copies == null ? 0 : copies.length;
+			if (copies != null) {
+				if (copiesLength == 1) {
+					workingCopyPath = copies[0].getPath().toString();
+				} else {
+					for (int i = 0; i < copiesLength; i++) {
+						ICompilationUnit workingCopy = copies[i];
+						workingCopyPaths.add(workingCopy.getPath().toString());
 					}
 				}
-				nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
-				return true;
 			}
-		};
-
-		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
-		// add type names from indexes
-		indexManager.performConcurrentJob(
-			new PatternSearchJob(
-				pattern,
-				getDefaultSearchParticipant(), // Java search only
-				scope,
-				searchRequestor),
-			waitingPolicy,
-			subMonitor.split(100));
-
-		// add type names from working copies
-		if (copies != null) {
-			for (int i = 0, length = copies.length; i < length; i++) {
-				ICompilationUnit workingCopy = copies[i];
-				final String path = workingCopy.getPath().toString();
-				if (workingCopy.isConsistent()) {
-					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-					IType[] allTypes = workingCopy.getAllTypes();
-					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-						IType type = allTypes[j];
-						IJavaElement parent = type.getParent();
-						char[][] enclosingTypeNames;
-						char[] qualification = packageDeclaration;
-						if (parent instanceof IType) {
-							char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
-							enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
-							qualification = CharOperation.concat(qualification, parentQualifiedName);
-						} else {
-							enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+			final String singleWkcpPath = workingCopyPath;
+	
+			// Index requestor
+			IndexQueryRequestor searchRequestor = new IndexQueryRequestor(){
+				public boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant, AccessRuleSet access) {
+					// Filter unexpected types
+					QualifiedTypeDeclarationPattern record = (QualifiedTypeDeclarationPattern) indexRecord;
+					if (record.enclosingTypeNames == IIndexConstants.ONE_ZERO_CHAR) {
+						return true; // filter out local and anonymous classes
+					}
+					switch (copiesLength) {
+						case 0:
+							break;
+						case 1:
+							if (singleWkcpPath.equals(documentPath)) {
+								return true; // filter out *the* working copy
+							}
+							break;
+						default:
+							if (workingCopyPaths.contains(documentPath)) {
+								return true; // filter out working copies
+							}
+							break;
+					}
+	
+					// Accept document path
+					AccessRestriction accessRestriction = null;
+					if (access != null) {
+						// Compute document relative path
+						int qualificationLength = (record.qualification == null || record.qualification.length == 0) ? 0 : record.qualification.length + 1;
+						int nameLength = record.simpleName == null ? 0 : record.simpleName.length;
+						char[] path = new char[qualificationLength + nameLength];
+						int pos = 0;
+						if (qualificationLength > 0) {
+							System.arraycopy(record.qualification, 0, path, pos, qualificationLength - 1);
+							CharOperation.replace(path, '.', '/');
+	
+							// Access rules work on package level and should not discriminate on enclosing types.
+							boolean isNestedType = record.enclosingTypeNames != null && record.enclosingTypeNames.length > 0;
+							path[qualificationLength-1] = isNestedType ? '$' : '/';
+							pos += qualificationLength;
 						}
-						char[] simpleName = type.getElementName().toCharArray();
-						char suffix = IIndexConstants.TYPE_SUFFIX;
-						if (type.isClass()) {
-							suffix = IIndexConstants.CLASS_SUFFIX;
-						} else if (type.isInterface()) {
-							suffix = IIndexConstants.INTERFACE_SUFFIX;
-						} else if (type.isEnum()) {
-							suffix = IIndexConstants.ENUM_SUFFIX;
-						} else if (type.isAnnotation()) {
-							suffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
+						if (nameLength > 0) {
+							System.arraycopy(record.simpleName, 0, path, pos, nameLength);
+							pos += nameLength;
 						}
-						if (pattern.matchesDecodedKey(new QualifiedTypeDeclarationPattern(qualification, simpleName, suffix, matchRule))) {
-							nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
+						// Update access restriction if path is not empty
+						if (pos > 0) {
+							accessRestriction = access.getViolatedRestriction(path);
 						}
 					}
-				} else {
-					Parser basicParser = getParser();
-					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-					if (parsedUnit != null) {
-						final char[] packageDeclaration = parsedUnit.currentPackage == null
-							? CharOperation.NO_CHAR
-							: CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-						class AllTypeDeclarationsVisitor extends ASTVisitor {
-							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-								return false; // no local/anonymous type
+					nameRequestor.acceptType(record.modifiers, record.pkg, record.simpleName, record.enclosingTypeNames, documentPath, accessRestriction);
+					return true;
+				}
+			};
+	
+			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
+			// add type names from indexes
+			indexManager.performConcurrentJob(
+				new PatternSearchJob(
+					pattern,
+					getDefaultSearchParticipant(), // Java search only
+					scope,
+					searchRequestor),
+				waitingPolicy,
+				subMonitor.split(100));
+	
+			// add type names from working copies
+			if (copies != null) {
+				for (int i = 0, length = copies.length; i < length; i++) {
+					ICompilationUnit workingCopy = copies[i];
+					final String path = workingCopy.getPath().toString();
+					if (workingCopy.isConsistent()) {
+						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+						IType[] allTypes = workingCopy.getAllTypes();
+						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+							IType type = allTypes[j];
+							IJavaElement parent = type.getParent();
+							char[][] enclosingTypeNames;
+							char[] qualification = packageDeclaration;
+							if (parent instanceof IType) {
+								char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
+								enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
+								qualification = CharOperation.concat(qualification, parentQualifiedName);
+							} else {
+								enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
 							}
-							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
-								SearchPattern decodedPattern =
-									new QualifiedTypeDeclarationPattern(packageDeclaration, typeDeclaration.name, convertTypeKind(TypeDeclaration.kind(typeDeclaration.modifiers)), matchRule);
-								if (pattern.matchesDecodedKey(decodedPattern)) {
-									nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
-								}
-								return true;
+							char[] simpleName = type.getElementName().toCharArray();
+							char suffix = IIndexConstants.TYPE_SUFFIX;
+							if (type.isClass()) {
+								suffix = IIndexConstants.CLASS_SUFFIX;
+							} else if (type.isInterface()) {
+								suffix = IIndexConstants.INTERFACE_SUFFIX;
+							} else if (type.isEnum()) {
+								suffix = IIndexConstants.ENUM_SUFFIX;
+							} else if (type.isAnnotation()) {
+								suffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
 							}
-							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
-								// compute enclosing type names
-								char[] qualification = packageDeclaration;
-								TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
-								char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-								while (enclosing != null) {
-									qualification = CharOperation.concat(qualification, enclosing.name, '.');
-									enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-									if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-										enclosing = enclosing.enclosingType;
-									} else {
-										enclosing = null;
+							if (pattern.matchesDecodedKey(new QualifiedTypeDeclarationPattern(qualification, simpleName, suffix, matchRule))) {
+								nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
+							}
+						}
+					} else {
+						Parser basicParser = getParser();
+						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+						if (parsedUnit != null) {
+							final char[] packageDeclaration = parsedUnit.currentPackage == null
+								? CharOperation.NO_CHAR
+								: CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+							class AllTypeDeclarationsVisitor extends ASTVisitor {
+								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+									return false; // no local/anonymous type
+								}
+								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
+									SearchPattern decodedPattern =
+										new QualifiedTypeDeclarationPattern(packageDeclaration, typeDeclaration.name, convertTypeKind(TypeDeclaration.kind(typeDeclaration.modifiers)), matchRule);
+									if (pattern.matchesDecodedKey(decodedPattern)) {
+										nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
 									}
+									return true;
 								}
-								SearchPattern decodedPattern =
-									new QualifiedTypeDeclarationPattern(qualification, memberTypeDeclaration.name, convertTypeKind(TypeDeclaration.kind(memberTypeDeclaration.modifiers)), matchRule);
-								if (pattern.matchesDecodedKey(decodedPattern)) {
-									nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
+								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
+									// compute enclosing type names
+									char[] qualification = packageDeclaration;
+									TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
+									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+									while (enclosing != null) {
+										qualification = CharOperation.concat(qualification, enclosing.name, '.');
+										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+											enclosing = enclosing.enclosingType;
+										} else {
+											enclosing = null;
+										}
+									}
+									SearchPattern decodedPattern =
+										new QualifiedTypeDeclarationPattern(qualification, memberTypeDeclaration.name, convertTypeKind(TypeDeclaration.kind(memberTypeDeclaration.modifiers)), matchRule);
+									if (pattern.matchesDecodedKey(decodedPattern)) {
+										nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
+									}
+									return true;
 								}
-								return true;
 							}
+							parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 						}
-						parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
+		} finally {
+			if (progressMonitor != null) {
+				progressMonitor.done();
+			}
 		}
 	}
 
 	public void searchDeclarations(IJavaElement enclosingElement, SearchRequestor requestor, SearchPattern pattern, IProgressMonitor monitor) throws JavaModelException {
-		if (VERBOSE) {
-			Util.verbose("	- java element: "+enclosingElement); //$NON-NLS-1$
-		}
-		IJavaSearchScope scope = createJavaSearchScope(new IJavaElement[] {enclosingElement});
-		IResource resource = ((JavaElement) enclosingElement).resource();
-		if (enclosingElement instanceof IMember) {
-			IMember member = (IMember) enclosingElement;
-			ICompilationUnit cu = member.getCompilationUnit();
-			if (cu != null) {
-				resource = cu.getResource();
-			} else if (member.isBinary()) {
-				// binary member resource cannot be used as this
-				// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=148215
-				resource = null;
-			}
-		}
 		try {
-			if (resource instanceof IFile) {
-				try {
-					requestor.beginReporting();
-					if (VERBOSE) {
-						Util.verbose("Searching for " + pattern + " in " + resource.getFullPath()); //$NON-NLS-1$//$NON-NLS-2$
+			if (VERBOSE) {
+				Util.verbose("	- java element: "+enclosingElement); //$NON-NLS-1$
+			}
+			IJavaSearchScope scope = createJavaSearchScope(new IJavaElement[] {enclosingElement});
+			IResource resource = ((JavaElement) enclosingElement).resource();
+			if (enclosingElement instanceof IMember) {
+				IMember member = (IMember) enclosingElement;
+				ICompilationUnit cu = member.getCompilationUnit();
+				if (cu != null) {
+					resource = cu.getResource();
+				} else if (member.isBinary()) {
+					// binary member resource cannot be used as this
+					// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=148215
+					resource = null;
+				}
+			}
+			try {
+				if (resource instanceof IFile) {
+					try {
+						requestor.beginReporting();
+						if (VERBOSE) {
+							Util.verbose("Searching for " + pattern + " in " + resource.getFullPath()); //$NON-NLS-1$//$NON-NLS-2$
+						}
+						SearchParticipant participant = getDefaultSearchParticipant();
+						SearchDocument[] documents = MatchLocator.addWorkingCopies(
+							pattern,
+							new SearchDocument[] {new JavaSearchDocument(enclosingElement.getPath().toString(), participant)},
+							getWorkingCopies(enclosingElement),
+							participant);
+						participant.locateMatches(
+							documents,
+							pattern,
+							scope,
+							requestor,
+							monitor);
+					} finally {
+						requestor.endReporting();
 					}
-					SearchParticipant participant = getDefaultSearchParticipant();
-					SearchDocument[] documents = MatchLocator.addWorkingCopies(
-						pattern,
-						new SearchDocument[] {new JavaSearchDocument(enclosingElement.getPath().toString(), participant)},
-						getWorkingCopies(enclosingElement),
-						participant);
-					participant.locateMatches(
-						documents,
+				} else {
+					search(
 						pattern,
+						new SearchParticipant[] {getDefaultSearchParticipant()},
 						scope,
 						requestor,
 						monitor);
-				} finally {
-					requestor.endReporting();
 				}
-			} else {
-				search(
-					pattern,
-					new SearchParticipant[] {getDefaultSearchParticipant()},
-					scope,
-					requestor,
-					monitor);
+			} catch (CoreException e) {
+				if (e instanceof JavaModelException)
+					throw (JavaModelException) e;
+				throw new JavaModelException(e);
+			}
+		} finally {
+			if (monitor != null) {
+				monitor.done();
 			}
-		} catch (CoreException e) {
-			if (e instanceof JavaModelException)
-				throw (JavaModelException) e;
-			throw new JavaModelException(e);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
index 4626c37..4771e86 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
@@ -264,6 +264,9 @@ public abstract class JobManager implements Runnable {
 			}
 			status = searchJob.execute(subMonitor);
 		} finally {
+			if (progress != null) {
+				progress.done();
+			}
 			if (VERBOSE)
 				Util.verbose("FINISHED  concurrent job - " + searchJob); //$NON-NLS-1$
 		}
