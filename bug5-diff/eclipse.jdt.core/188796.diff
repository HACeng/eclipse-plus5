commit 30e98d6cc084dfe1b207ffb7493b2de7b6cec8c4
Author: Olivier Thomann <Olivier_Thomann@ca.ibm.com>
Date:   Mon Mar 16 04:31:59 2015 -0700

    Bug 188796 [jsr199] Using JSR199 to extend ECJ
    
    Change-Id: Ic851300c2069ec68675bd77cb24d8af51f328399
    
    Signed-off-by: Olivier Thomann <Olivier_Thomann@ca.ibm.com>

26	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Archive.java
91	45	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ArchiveFileObject.java
69	125	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
173	129	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Options.java
15	15	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Util.java
1	1	org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/AllTests.java
81	59	org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/CompilerToolTests.java
203	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
25	7	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Archive.java
73	46	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/ArchiveFileObject.java
9	5	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
223	61	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
42	104	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
9	6	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileObject.java
7	4	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Options.java
2	2	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Util.java
15	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Archive.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Archive.java
index c876523..aad37bb 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Archive.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Archive.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,8 +14,10 @@ import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.Hashtable;
+import java.util.List;
 import java.util.Set;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
@@ -30,20 +32,22 @@ public class Archive {
 	
 	ZipFile zipFile;
 	File file;
+
 	protected Hashtable<String, ArrayList<String>> packagesCache;
 	
 	private Archive() {
+		// used to construct UNKNOWN_ARCHIVE
 	}
 
 	public Archive(File file) throws ZipException, IOException {
 		this.file = file;
 		this.zipFile = new ZipFile(file);
-		initialize();		
+		initialize();
 	}
 
 	private void initialize() {
 		// initialize packages
-		this.packagesCache = new Hashtable<String, ArrayList<String>>();
+		this.packagesCache = new Hashtable<>();
 		nextEntry : for (Enumeration<? extends ZipEntry> e = this.zipFile.entries(); e.hasMoreElements(); ) {
 			String fileName = ((ZipEntry) e.nextElement()).getName();
 
@@ -58,7 +62,7 @@ public class Archive {
 				if (typeName.length() == 0) {
 					continue nextEntry;
 				}
-				types = new ArrayList<String>();
+				types = new ArrayList<>();
 				types.add(typeName);
 				this.packagesCache.put(packageName, types);
 			} else {
@@ -68,7 +72,7 @@ public class Archive {
 	}
 	
 	public ArchiveFileObject getArchiveFileObject(String entryName, Charset charset) {
-		return new ArchiveFileObject(this.file, this.zipFile, entryName, charset);
+		return new ArchiveFileObject(this.file, entryName, charset);
 	}
 	
 	public boolean contains(String entryName) {
@@ -82,8 +86,16 @@ public class Archive {
 		return this.packagesCache.keySet();
 	}
 	
-	public ArrayList<String> getTypes(String packageName) {
+	public List<String> getTypes(String packageName) {
 		// package name is expected to ends with '/'
+		if (this.packagesCache == null) {
+			try {
+				this.zipFile = new ZipFile(this.file);
+			} catch(IOException e) {
+				return Collections.<String>emptyList();
+			}
+			this.initialize();
+		}
 		return this.packagesCache.get(packageName);
 	}
 	
@@ -93,10 +105,17 @@ public class Archive {
 
 	public void close() {
 		try {
-			if (this.zipFile != null) this.zipFile.close();
+			if (this.zipFile != null) {
+				this.zipFile.close();
+			}
 			this.packagesCache = null;
 		} catch (IOException e) {
 			// ignore
 		}
 	}
+	
+	@Override
+	public String toString() {
+		return "Archive: " + (this.file == null ? "UNKNOWN_ARCHIVE" : this.file.getAbsolutePath()); //$NON-NLS-1$ //$NON-NLS-2$
+	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ArchiveFileObject.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ArchiveFileObject.java
index adae21a..16ca0b8 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ArchiveFileObject.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ArchiveFileObject.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,23 +34,33 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
  * Implementation of a Java file object that corresponds to an entry in a zip/jar file
  */
 public class ArchiveFileObject implements JavaFileObject {
-	private ZipEntry zipEntry;
-	private ZipFile zipFile;
 	private String entryName;
 	private File file;
+	private ZipFile zipFile;
 	private Charset charset;
-	
-	public ArchiveFileObject(File file, ZipFile zipFile, String entryName, Charset charset) {
-		this.zipFile = zipFile;
-		this.zipEntry = zipFile.getEntry(entryName);
+
+	public ArchiveFileObject(File file, String entryName, Charset charset) {
 		this.entryName = entryName;
 		this.file = file;
 		this.charset = charset;
 	}
 
+	@Override
+	protected void finalize() throws Throwable {
+		if (this.zipFile != null) {
+			try {
+				this.zipFile.close();
+			} catch (IOException e) {
+				// ignore
+			}
+		}
+		super.finalize();
+	}
+
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileObject#getAccessLevel()
 	 */
+	@Override
 	public Modifier getAccessLevel() {
 		// cannot express multiple modifier
 		if (getKind() != Kind.CLASS) {
@@ -58,12 +68,15 @@ public class ArchiveFileObject implements JavaFileObject {
 		}
 		ClassFileReader reader = null;
 		try {
-			reader = ClassFileReader.read(this.zipFile, this.entryName);
+			try (ZipFile zip = new ZipFile(this.file)) {
+				reader = ClassFileReader.read(zip, this.entryName);
+			}
 		} catch (ClassFormatException e) {
 			// ignore
 		} catch (IOException e) {
 			// ignore
 		}
+
 		if (reader == null) {
 			return null;
 		}
@@ -83,6 +96,7 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileObject#getKind()
 	 */
+	@Override
 	public Kind getKind() {
 		String name = this.entryName.toLowerCase();
 		if (name.endsWith(Kind.CLASS.extension)) {
@@ -98,51 +112,57 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileObject#getNestingKind()
 	 */
+	@Override
 	public NestingKind getNestingKind() {
 		switch(getKind()) {
-			case SOURCE :
-				return NestingKind.TOP_LEVEL;
-			case CLASS :
-        		ClassFileReader reader = null;
-        		try {
-        			reader = ClassFileReader.read(this.zipFile, this.entryName);
-        		} catch (ClassFormatException e) {
-        			// ignore
-        		} catch (IOException e) {
-        			// ignore
-        		}
-        		if (reader == null) {
-        			return null;
-        		}
-        		if (reader.isAnonymous()) {
-        			return NestingKind.ANONYMOUS;
-        		}
-        		if (reader.isLocal()) {
-        			return NestingKind.LOCAL;
-        		}
-        		if (reader.isMember()) {
-        			return NestingKind.MEMBER;
-        		}
-        		return NestingKind.TOP_LEVEL;
-        	default:
-        		return null;
+		case SOURCE :
+			return NestingKind.TOP_LEVEL;
+		case CLASS :
+			ClassFileReader reader = null;
+			try {
+				try (ZipFile zip = new ZipFile(this.file)) {
+					reader = ClassFileReader.read(zip, this.entryName);
+				}
+			} catch (ClassFormatException e) {
+				// ignore
+			} catch (IOException e) {
+				// ignore
+			}
+			if (reader == null) {
+				return null;
+			}
+			if (reader.isAnonymous()) {
+				return NestingKind.ANONYMOUS;
+			}
+			if (reader.isLocal()) {
+				return NestingKind.LOCAL;
+			}
+			if (reader.isMember()) {
+				return NestingKind.MEMBER;
+			}
+			return NestingKind.TOP_LEVEL;
+		default:
+			return null;
 		}
 	}
 
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileObject#isNameCompatible(java.lang.String, javax.tools.JavaFileObject.Kind)
 	 */
+	@Override
 	public boolean isNameCompatible(String simpleName, Kind kind) {
-		return this.zipEntry.getName().endsWith(simpleName + kind.extension);
+		return this.entryName.endsWith(simpleName + kind.extension);
 	}
 
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#delete()
 	 */
+	@Override
 	public boolean delete() {
 		throw new UnsupportedOperationException();
 	}
 
+	@Override
 	public boolean equals(Object o) {
 		if (!(o instanceof ArchiveFileObject)) {
 			return false;
@@ -151,12 +171,21 @@ public class ArchiveFileObject implements JavaFileObject {
 		return archiveFileObject.toUri().equals(this.toUri());
 	}
 
+	@Override
+	public int hashCode() {
+		return this.toUri().hashCode();
+	}
+
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#getCharContent(boolean)
 	 */
+	@Override
 	public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 		if (getKind() == Kind.SOURCE) {
-			return Util.getCharContents(this, ignoreEncodingErrors, org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(this.zipEntry, this.zipFile), this.charset.name());
+			try (ZipFile zipFile2 = new ZipFile(this.file)) {
+				ZipEntry zipEntry = zipFile2.getEntry(this.entryName);
+				return Util.getCharContents(this, ignoreEncodingErrors, org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(zipEntry, zipFile2), this.charset.name());
+			}
 		}
 		return null;
 	}
@@ -164,27 +193,41 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#getLastModified()
 	 */
+	@Override
 	public long getLastModified() {
-		return this.zipEntry.getTime(); // looks the closest from the last modification
+		try (ZipFile zip = new ZipFile(this.file)) {
+			ZipEntry zipEntry = zip.getEntry(this.entryName);
+			return zipEntry.getTime(); // looks the closest from the last modification
+		} catch(IOException e) {
+			// ignore
+		}
+		return 0;
 	}
 
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#getName()
 	 */
+	@Override
 	public String getName() {
-		return this.zipEntry.getName();
+		return this.entryName;
 	}
 
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#openInputStream()
 	 */
+	@Override
 	public InputStream openInputStream() throws IOException {
-		return this.zipFile.getInputStream(this.zipEntry);
+		if (this.zipFile == null) {
+			this.zipFile = new ZipFile(this.file);
+		}
+		ZipEntry zipEntry = this.zipFile.getEntry(this.entryName);
+		return this.zipFile.getInputStream(zipEntry);
 	}
 
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#openOutputStream()
 	 */
+	@Override
 	public OutputStream openOutputStream() throws IOException {
 		throw new UnsupportedOperationException();
 	}
@@ -192,6 +235,7 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#openReader(boolean)
 	 */
+	@Override
 	public Reader openReader(boolean ignoreEncodingErrors) throws IOException {
 		throw new UnsupportedOperationException();
 	}
@@ -199,6 +243,7 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#openWriter()
 	 */
+	@Override
 	public Writer openWriter() throws IOException {
 		throw new UnsupportedOperationException();
 	}
@@ -206,17 +251,18 @@ public class ArchiveFileObject implements JavaFileObject {
 	/* (non-Javadoc)
 	 * @see javax.tools.FileObject#toUri()
 	 */
+	@Override
 	public URI toUri() {
 		try {
-			return new URI("jar:" + this.file.toURI().getPath() + "!" + this.zipEntry.getName()); //$NON-NLS-1$//$NON-NLS-2$
+			return new URI("jar:" + this.file.toURI().getPath() + "!" + this.entryName); //$NON-NLS-1$//$NON-NLS-2$
 		} catch (URISyntaxException e) {
 			return null;
 		}
 	}
-	
 
-    @Override
-    public String toString() {
-        return this.file.getAbsolutePath() + "[" + this.zipEntry.getName() + "]";//$NON-NLS-1$//$NON-NLS-2$
-    }	
+
+	@Override
+	public String toString() {
+		return this.file.getAbsolutePath() + "[" + this.entryName + "]";//$NON-NLS-1$//$NON-NLS-2$
+	}	
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
index 1c0bda8..99192e7 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.MissingResourceException;
@@ -33,9 +34,9 @@ import java.util.zip.ZipException;
 
 import javax.tools.FileObject;
 import javax.tools.JavaFileObject;
+import javax.tools.JavaFileObject.Kind;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.StandardLocation;
-import javax.tools.JavaFileObject.Kind;
 
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem;
@@ -67,8 +68,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	public EclipseFileManager(Locale locale, Charset charset) {
 		this.locale = locale == null ? Locale.getDefault() : locale;
 		this.charset = charset == null ? Charset.defaultCharset() : charset;
-		this.locations = new HashMap<String, Iterable<? extends File>>();
-		this.archivesCache = new HashMap<File, Archive>();
+		this.locations = new HashMap<>();
+		this.archivesCache = new HashMap<>();
 		try {
 			this.setLocation(StandardLocation.PLATFORM_CLASS_PATH, getDefaultBootclasspath());
 			Iterable<? extends File> defaultClasspath = getDefaultClasspath();
@@ -84,55 +85,16 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		}
 	}
 
-	private void addFiles(File[][] jars, ArrayList<File> files) {
-		if (jars != null) {
-			for (File[] currentJars : jars) {
-				if (currentJars != null) {
-					for (File currentJar : currentJars) {
-						if (currentJar.exists()) {
-							files.add(currentJar);
-						}
-					}
-				}
-			}
-		}
-	}
-	
-	
-	private void addFilesFrom(File javaHome, String propertyName, String defaultPath, ArrayList<File> files) {
-		String extdirsStr = System.getProperty(propertyName);
-		File[] directoriesToCheck = null;
-		if (extdirsStr == null) {
-			if (javaHome != null) {
-				directoriesToCheck = new File[] { new File(javaHome, defaultPath) };
-			}
-		} else {
-			StringTokenizer tokenizer = new StringTokenizer(extdirsStr, File.pathSeparator);
-			ArrayList<String> paths = new ArrayList<String>();
-			while (tokenizer.hasMoreTokens()) {
-				paths.add(tokenizer.nextToken());
-			}
-			if (paths.size() != 0) {
-				directoriesToCheck = new File[paths.size()];
-				for (int i = 0; i < directoriesToCheck.length; i++)  {
-					directoriesToCheck[i] = new File(paths.get(i));
-				}
-			}
-		}
-		if (directoriesToCheck != null) {
-			addFiles(Main.getLibrariesFiles(directoriesToCheck), files);
-		}
-		
-	}
-	
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#close()
 	 */
+	@Override
 	public void close() throws IOException {
-		this.locations = null;
+		if (this.locations != null) this.locations.clear();
 		for (Archive archive : this.archivesCache.values()) {
 			archive.close();
 		}
+		this.archivesCache.clear();
 	}
 	
 	private void collectAllMatchingFiles(File file, String normalizedPackageName, Set<Kind> kinds, boolean recurse, ArrayList<JavaFileObject> collector) {
@@ -165,6 +127,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			}
 		} else {
 			Archive archive = this.getArchive(file);
+			if (archive == Archive.UNKNOWN_ARCHIVE) return;
 			String key = normalizedPackageName;
 			if (!normalizedPackageName.endsWith("/")) {//$NON-NLS-1$
 				key += '/';
@@ -173,7 +136,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			if (recurse) {
 				for (String packageName : archive.allPackages()) {
 					if (packageName.startsWith(key)) {
-						ArrayList<String> types = archive.getTypes(packageName);
+						List<String> types = archive.getTypes(packageName);
 						if (types != null) {
 							for (String typeName : types) {
 								final Kind kind = getKind(getExtension(typeName));
@@ -185,12 +148,12 @@ public class EclipseFileManager implements StandardJavaFileManager {
 					}
 				}
 			} else {
-				ArrayList<String> types = archive.getTypes(key);
+				List<String> types = archive.getTypes(key);
 				if (types != null) {
 					for (String typeName : types) {
-						final Kind kind = getKind(typeName);
+						final Kind kind = getKind(getExtension(typeName));
 						if (kinds.contains(kind)) {
-							collector.add(archive.getArchiveFileObject(normalizedPackageName + typeName, this.charset));
+							collector.add(archive.getArchiveFileObject(key + typeName, this.charset));
 						}
 					}
 				}
@@ -199,7 +162,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> concatFiles(Iterable<? extends File> iterable, Iterable<? extends File> iterable2) {
-		ArrayList<File> list = new ArrayList<File>();
+		ArrayList<File> list = new ArrayList<>();
 		if (iterable2 == null) return iterable;
 		for (Iterator<? extends File> iterator = iterable.iterator(); iterator.hasNext(); ) {
 			list.add(iterator.next());
@@ -213,6 +176,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#flush()
 	 */
+	@Override
 	public void flush() throws IOException {
 		for (Archive archive : this.archivesCache.values()) {
 			archive.flush();
@@ -223,23 +187,21 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		// check the archive (jar/zip) cache
 		Archive archive = this.archivesCache.get(f);
 		if (archive == null) {
+			archive = Archive.UNKNOWN_ARCHIVE;
 			// create a new archive
 			if (f.exists()) {
-    			try {
-    				archive = new Archive(f);
-    			} catch (ZipException e) {
-    				// ignore
-    			} catch (IOException e) {
-    				// ignore
-    			}
-    			if (archive != null) {
-    				this.archivesCache.put(f, archive);
-    			} else {
-    				this.archivesCache.put(f, Archive.UNKNOWN_ARCHIVE);
-    			}
-			} else {
-				this.archivesCache.put(f, Archive.UNKNOWN_ARCHIVE);
+				try {
+					archive = new Archive(f);
+				} catch (ZipException e) {
+					// ignore
+				} catch (IOException e) {
+					// ignore
+				}
+				if (archive != null) {
+					this.archivesCache.put(f, archive);
+				}
 			}
+			this.archivesCache.put(f, archive);
 		}
 		return archive;
 	}
@@ -247,13 +209,14 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#getClassLoader(javax.tools.JavaFileManager.Location)
 	 */
+	@Override
 	public ClassLoader getClassLoader(Location location) {
 		Iterable<? extends File> files = getLocation(location);
 		if (files == null) {
 			// location is unknown
 			return null;
 		}
-		ArrayList<URL> allURLs = new ArrayList<URL>();
+		ArrayList<URL> allURLs = new ArrayList<>();
 		for (File f : files) {
 			try {
 				allURLs.add(f.toURI().toURL());
@@ -267,8 +230,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getPathsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -281,7 +244,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	Iterable<? extends File> getDefaultBootclasspath() {
-		ArrayList<File> files = new ArrayList<File>();
+		List<File> files = new ArrayList<>();
 		String javaversion = System.getProperty("java.version");//$NON-NLS-1$
 		if(javaversion.length() > 3)
 			javaversion = javaversion.substring(0, 3);
@@ -291,32 +254,15 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			return null;
 		}
 
-		/*
-		 * Handle >= JDK 1.6
-		 */
-		String javaHome = System.getProperty("java.home"); //$NON-NLS-1$
-		File javaHomeFile = null;
-		if (javaHome != null) {
-			javaHomeFile = new File(javaHome);
-			if (!javaHomeFile.exists())
-				javaHomeFile = null;
+		for (String fileName : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
+			files.add(new File(fileName));
 		}
-
-		addFilesFrom(javaHomeFile, "java.endorsed.dirs", "/lib/endorsed", files);//$NON-NLS-1$//$NON-NLS-2$
-		if (javaHomeFile != null) {
-			File[] directoriesToCheck = null;
-			String libs = System.getProperty("os.name").startsWith("Mac") && jdkLevel == ClassFileConstants.JDK1_6 ? "../Classes" : "lib";//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
-			directoriesToCheck = new File[] { new File(javaHomeFile, libs)};
-			File[][] jars = Main.getLibrariesFiles(directoriesToCheck);
-			addFiles(jars, files);
-		}
-		addFilesFrom(javaHomeFile, "java.ext.dirs", "/lib/ext", files);//$NON-NLS-1$//$NON-NLS-2$
 		return files;
 	}
 
 	Iterable<? extends File> getDefaultClasspath() {
 		// default classpath
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<File> files = new ArrayList<>();
 		String classProp = System.getProperty("java.class.path"); //$NON-NLS-1$
 		if ((classProp == null) || (classProp.length() == 0)) {
 			return null;
@@ -335,8 +281,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getEndorsedDirsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -349,8 +295,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getExtdirsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -377,6 +323,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#getFileForInput(javax.tools.JavaFileManager.Location, java.lang.String, java.lang.String)
 	 */
+	@Override
 	public FileObject getFileForInput(Location location, String packageName, String relativeName) throws IOException {
 		Iterable<? extends File> files = getLocation(location);
 		if (files == null) {
@@ -408,6 +355,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#getFileForOutput(javax.tools.JavaFileManager.Location, java.lang.String, java.lang.String, javax.tools.FileObject)
 	 */
+	@Override
 	public FileObject getFileForOutput(Location location, String packageName, String relativeName, FileObject sibling)
 			throws IOException {
 		Iterable<? extends File> files = getLocation(location);
@@ -428,6 +376,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#getJavaFileForInput(javax.tools.JavaFileManager.Location, java.lang.String, javax.tools.JavaFileObject.Kind)
 	 */
+	@Override
 	public JavaFileObject getJavaFileForInput(Location location, String className, Kind kind) throws IOException {
 		if (kind != Kind.CLASS && kind != Kind.SOURCE) {
 			throw new IllegalArgumentException("Invalid kind : " + kind);//$NON-NLS-1$
@@ -463,6 +412,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#getJavaFileForOutput(javax.tools.JavaFileManager.Location, java.lang.String, javax.tools.JavaFileObject.Kind, javax.tools.FileObject)
 	 */
+	@Override
 	public JavaFileObject getJavaFileForOutput(Location location, String className, Kind kind, FileObject sibling)
 			throws IOException {
 		if (kind != Kind.CLASS && kind != Kind.SOURCE) {
@@ -517,6 +467,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#getJavaFileObjects(java.io.File[])
 	 */
+	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjects(File... files) {
 		return getJavaFileObjectsFromFiles(Arrays.asList(files));
 	}
@@ -524,6 +475,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#getJavaFileObjects(java.lang.String[])
 	 */
+	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjects(String... names) {
 		return getJavaFileObjectsFromStrings(Arrays.asList(names));
 	}
@@ -531,8 +483,9 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#getJavaFileObjectsFromFiles(java.lang.Iterable)
 	 */
+	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {
-		ArrayList<JavaFileObject> javaFileArrayList = new ArrayList<JavaFileObject>();
+		ArrayList<JavaFileObject> javaFileArrayList = new ArrayList<>();
 		for (File f : files) {
 			if (f.isDirectory()) {
 				throw new IllegalArgumentException("file : " + f.getAbsolutePath() + " is a directory"); //$NON-NLS-1$ //$NON-NLS-2$
@@ -545,8 +498,9 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#getJavaFileObjectsFromStrings(java.lang.Iterable)
 	 */
+	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> names) {
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<File> files = new ArrayList<>();
 		for (String name : names) {
 			files.add(new File(name));
 		}
@@ -571,6 +525,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#getLocation(javax.tools.JavaFileManager.Location)
 	 */
+	@Override
 	public Iterable<? extends File> getLocation(Location location) {
 		if (this.locations == null) return null;
 		return this.locations.get(location.getName());
@@ -584,7 +539,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		if (file.exists() && !file.isDirectory()) {
 			throw new IllegalArgumentException("file : " + file.getAbsolutePath() + " is not a directory");//$NON-NLS-1$//$NON-NLS-2$
 		}
-		ArrayList<File> list = new ArrayList<File>(1);
+		ArrayList<File> list = new ArrayList<>(1);
 		list.add(file);
 		return list;
 	}
@@ -592,19 +547,19 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#handleOption(java.lang.String, java.util.Iterator)
 	 */
+	@Override
 	public boolean handleOption(String current, Iterator<String> remaining) {
 		try {
 			if ("-bootclasspath".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> bootclasspaths = getPathsFrom(remaining.next());
 					if (bootclasspaths != null) {
 						Iterable<? extends File> iterable = getLocation(StandardLocation.PLATFORM_CLASS_PATH);
-						if ((this.flags & HAS_ENDORSED_DIRS) == 0
-								&& (this.flags & HAS_EXT_DIRS) == 0) {
+						if ((this.flags & EclipseFileManager.HAS_ENDORSED_DIRS) == 0
+								&& (this.flags & EclipseFileManager.HAS_EXT_DIRS) == 0) {
 							// override default bootclasspath
 							setLocation(StandardLocation.PLATFORM_CLASS_PATH, bootclasspaths);
-						} else if ((this.flags & HAS_ENDORSED_DIRS) != 0) {
+						} else if ((this.flags & EclipseFileManager.HAS_ENDORSED_DIRS) != 0) {
 							// endorseddirs have been processed first
 							setLocation(StandardLocation.PLATFORM_CLASS_PATH, 
 									concatFiles(iterable, bootclasspaths));
@@ -614,15 +569,13 @@ public class EclipseFileManager implements StandardJavaFileManager {
 									prependFiles(iterable, bootclasspaths));
 						}
 					}
-					remaining.remove();
-					this.flags |= HAS_BOOTCLASSPATH;
+					this.flags |= EclipseFileManager.HAS_BOOTCLASSPATH;
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-classpath".equals(current) || "-cp".equals(current)) {//$NON-NLS-1$//$NON-NLS-2$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> classpaths = getPathsFrom(remaining.next());
 					if (classpaths != null) {
@@ -633,98 +586,83 @@ public class EclipseFileManager implements StandardJavaFileManager {
 						} else {
 							setLocation(StandardLocation.CLASS_PATH, classpaths);
 						}
-						if ((this.flags & HAS_PROCESSORPATH) == 0) {
+						if ((this.flags & EclipseFileManager.HAS_PROCESSORPATH) == 0) {
 							setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpaths);
 						}
 					}
-					remaining.remove();
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-encoding".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					this.charset = Charset.forName(remaining.next());
-					remaining.remove();
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-sourcepath".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> sourcepaths = getPathsFrom(remaining.next());
 					if (sourcepaths != null) setLocation(StandardLocation.SOURCE_PATH, sourcepaths);
-					remaining.remove();
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-extdirs".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					Iterable<? extends File> iterable = getLocation(StandardLocation.PLATFORM_CLASS_PATH);
 					setLocation(StandardLocation.PLATFORM_CLASS_PATH, 
 							concatFiles(iterable, getExtdirsFrom(remaining.next())));
-					remaining.remove();
-					this.flags |= HAS_EXT_DIRS;
+					this.flags |= EclipseFileManager.HAS_EXT_DIRS;
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-endorseddirs".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					Iterable<? extends File> iterable = getLocation(StandardLocation.PLATFORM_CLASS_PATH);
 					setLocation(StandardLocation.PLATFORM_CLASS_PATH, 
 							prependFiles(iterable, getEndorsedDirsFrom(remaining.next())));
-					remaining.remove();
-					this.flags |= HAS_ENDORSED_DIRS;
+					this.flags |= EclipseFileManager.HAS_ENDORSED_DIRS;
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-d".equals(current)) { //$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> outputDir = getOutputDir(remaining.next());
 					if (outputDir != null) {
 						setLocation(StandardLocation.CLASS_OUTPUT, outputDir);
 					}
-					remaining.remove();
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}
 			}
 			if ("-s".equals(current)) { //$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> outputDir = getOutputDir(remaining.next());
 					if (outputDir != null) {
 						setLocation(StandardLocation.SOURCE_OUTPUT, outputDir);
 					}
-					remaining.remove();
 					return true;
 				} else {
 					throw new IllegalArgumentException();
 				}				
 			}
 			if ("-processorpath".equals(current)) {//$NON-NLS-1$
-				remaining.remove(); // remove the current option
 				if (remaining.hasNext()) {
 					final Iterable<? extends File> processorpaths = getPathsFrom(remaining.next());
 					if (processorpaths != null) {
 						setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, processorpaths);
 					}
-					remaining.remove();
-					this.flags |= HAS_PROCESSORPATH;
+					this.flags |= EclipseFileManager.HAS_PROCESSORPATH;
 					return true;
 				} else {
 					throw new IllegalArgumentException();
@@ -739,6 +677,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#hasLocation(javax.tools.JavaFileManager.Location)
 	 */
+	@Override
 	public boolean hasLocation(Location location) {
 		return this.locations != null && this.locations.containsKey(location.getName());
 	}
@@ -746,6 +685,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#inferBinaryName(javax.tools.JavaFileManager.Location, javax.tools.JavaFileObject)
 	 */
+	@Override
 	public String inferBinaryName(Location location, JavaFileObject file) {
 		String name = file.getName();
 		JavaFileObject javaFileObject = null;
@@ -763,7 +703,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		if (javaFileObject == null) {
 			return null;
 		}
-		return normalized(name);
+		return name.replace('/', '.');
 	}
 
 	private boolean isArchive(File f) {
@@ -774,6 +714,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#isSameFile(javax.tools.FileObject, javax.tools.FileObject)
 	 */
+	@Override
 	public boolean isSameFile(FileObject fileObject1, FileObject fileObject2) {
 		// EclipseFileManager creates only EcliseFileObject
 		if (!(fileObject1 instanceof EclipseFileObject)) throw new IllegalArgumentException("Unsupported file object class : " + fileObject1.getClass());//$NON-NLS-1$
@@ -783,6 +724,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.OptionChecker#isSupportedOption(java.lang.String)
 	 */
+	@Override
 	public int isSupportedOption(String option) {
 		return Options.processOptionsFileManager(option);
 	}
@@ -790,6 +732,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#list(javax.tools.JavaFileManager.Location, java.lang.String, java.util.Set, boolean)
 	 */
+	@Override
 	public Iterable<JavaFileObject> list(Location location, String packageName, Set<Kind> kinds, boolean recurse)
 			throws IOException {
 		
@@ -798,7 +741,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			throw new IllegalArgumentException("Unknown location : " + location);//$NON-NLS-1$
 		}
 		
-		ArrayList<JavaFileObject> collector = new ArrayList<JavaFileObject>();
+		ArrayList<JavaFileObject> collector = new ArrayList<>();
 		String normalizedPackageName = normalized(packageName);
 		for (File file : allFilesInLocations) {
 			collectAllMatchingFiles(file, normalizedPackageName, kinds, recurse, collector);
@@ -823,7 +766,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	private Iterable<? extends File> prependFiles(Iterable<? extends File> iterable,
 			Iterable<? extends File> iterable2) {
 		if (iterable2 == null) return iterable;
-		ArrayList<File> list = new ArrayList<File>();
+		ArrayList<File> list = new ArrayList<>();
 		for (Iterator<? extends File> iterator = iterable2.iterator(); iterator.hasNext(); ) {
 			list.add(iterator.next());
 		}
@@ -836,6 +779,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	/* (non-Javadoc)
 	 * @see javax.tools.StandardJavaFileManager#setLocation(javax.tools.JavaFileManager.Location, java.lang.Iterable)
 	 */
+	@Override
 	public void setLocation(Location location, Iterable<? extends File> path) throws IOException {
 		if (path != null) {
 			if (location.isOutputLocation()) {
@@ -863,7 +807,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		}
 	}
 
-	@SuppressWarnings({"rawtypes", "unchecked"})
+	@SuppressWarnings({"unchecked", "rawtypes"})
 	public void processPathEntries(final int defaultSize, final ArrayList paths,
 			final String currentPath, String customEncoding, boolean isSourceOnly,
 			boolean rejectDestinationPathOnJars) {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Options.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Options.java
index f9795cf..cee6dca 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Options.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Options.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -22,69 +22,79 @@ public final class Options {
 	private static final Set<String> ONE_ARGUMENT_OPTIONS;
 	private static final Set<String> FILE_MANAGER_OPTIONS;
 	static {
-		ZERO_ARGUMENT_OPTIONS = new HashSet<String>();
-		ZERO_ARGUMENT_OPTIONS.add("-progress");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-proceedOnError");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-time");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-v");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-version");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-showversion");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-deprecation");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-help");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-?");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-help:warn");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-?:warn");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-noExit");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-verbose");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-referenceInfo");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-inlineJSR");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-g");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-g:none");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-nowarn");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-warn:none");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-preserveAllLocals");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-enableJavadoc");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-Xemacs");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-X");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-O");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-1.3");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-1.4");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-1.5");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-5");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-5.0");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-1.6");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-6");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-6.0");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-proc:only");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-proc:none");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-XprintProcessorInfo");//$NON-NLS-1$
-		ZERO_ARGUMENT_OPTIONS.add("-XprintRounds");//$NON-NLS-1$
+		ZERO_ARGUMENT_OPTIONS = new HashSet<>();
+		Options.ZERO_ARGUMENT_OPTIONS.add("-progress");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-proceedOnError");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-proceedOnError:Fatal");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-time");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-v");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-version");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-showversion");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-deprecation");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-help");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-?");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-help:warn");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-?:warn");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-noExit");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-verbose");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-referenceInfo");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-inlineJSR");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-g");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-g:none");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-warn:none");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-preserveAllLocals");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-enableJavadoc");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-Xemacs");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-X");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-O");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.3");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.4");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.5");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-5");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-5.0");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.6");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-6");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-6.0");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.7");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-7");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-7.0");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.8");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-8");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-8.0");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-proc:only");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-proc:none");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-XprintProcessorInfo");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-XprintRounds");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-parameters");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-genericsignature");//$NON-NLS-1$
 
-		FILE_MANAGER_OPTIONS = new HashSet<String>();
-		FILE_MANAGER_OPTIONS.add("-bootclasspath");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-encoding");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-d");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-classpath");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-cp");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-sourcepath");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-extdirs");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-endorseddirs");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-s");//$NON-NLS-1$
-		FILE_MANAGER_OPTIONS.add("-processorpath");//$NON-NLS-1$
+		FILE_MANAGER_OPTIONS = new HashSet<>();
+		Options.FILE_MANAGER_OPTIONS.add("-bootclasspath");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-encoding");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-d");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-classpath");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-cp");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-sourcepath");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-extdirs");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-endorseddirs");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-s");//$NON-NLS-1$
+		Options.FILE_MANAGER_OPTIONS.add("-processorpath");//$NON-NLS-1$
 
-		ONE_ARGUMENT_OPTIONS = new HashSet<String>();
-		ONE_ARGUMENT_OPTIONS.addAll(FILE_MANAGER_OPTIONS);
-		ONE_ARGUMENT_OPTIONS.add("-log");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-repeat");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-maxProblems");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-source");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-target");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-processor");//$NON-NLS-1$
-		ONE_ARGUMENT_OPTIONS.add("-classNames");//$NON-NLS-1$
+		ONE_ARGUMENT_OPTIONS = new HashSet<>();
+		Options.ONE_ARGUMENT_OPTIONS.addAll(Options.FILE_MANAGER_OPTIONS);
+		Options.ONE_ARGUMENT_OPTIONS.add("-log");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-repeat");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-maxProblems");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-source");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-target");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-processor");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-classNames");//$NON-NLS-1$
+		Options.ONE_ARGUMENT_OPTIONS.add("-properties");//$NON-NLS-1$
+	
 	}
 	public static int processOptionsFileManager(String option) {
 		if (option == null) return -1;
-		if (FILE_MANAGER_OPTIONS.contains(option)) {
+		if (Options.FILE_MANAGER_OPTIONS.contains(option)) {
 			return 1;
 		}
 		return -1;
@@ -92,10 +102,10 @@ public final class Options {
 
 	public static int processOptions(String option) {
 		if (option == null) return -1;
-		if (ZERO_ARGUMENT_OPTIONS.contains(option)) {
+		if (Options.ZERO_ARGUMENT_OPTIONS.contains(option)) {
 			return 0;
 		}
-		if (ONE_ARGUMENT_OPTIONS.contains(option)) {
+		if (Options.ONE_ARGUMENT_OPTIONS.contains(option)) {
 			return 1;
 		}
 		if (option.startsWith("-g")) { //$NON-NLS-1$
@@ -138,86 +148,98 @@ public final class Options {
 			while (tokenizer.hasMoreTokens()) {
 				String token = tokenizer.nextToken();
 				tokenCounter++;
-				if ("constructorName".equals(token)//$NON-NLS-1$
-						|| token.equals("pkgDefaultMethod")//$NON-NLS-1$
-						|| token.equals("packageDefaultMethod")//$NON-NLS-1$
-						|| token.equals("maskedCatchBlock")//$NON-NLS-1$
-						|| token.equals("maskedCatchBlocks")//$NON-NLS-1$
-						|| token.equals("deprecation")//$NON-NLS-1$
+				if (token.equals("allDeadCode")//$NON-NLS-1$
 						|| token.equals("allDeprecation")//$NON-NLS-1$
-						|| token.equals("unusedLocal")//$NON-NLS-1$
-						|| token.equals("unusedLocals")//$NON-NLS-1$
-						|| token.equals("unusedArgument")//$NON-NLS-1$
-						|| token.equals("unusedArguments")//$NON-NLS-1$
-						|| token.equals("unusedImport")//$NON-NLS-1$
-						|| token.equals("unusedImports")//$NON-NLS-1$
-						|| token.equals("unusedPrivate")//$NON-NLS-1$
-						|| token.equals("unusedLabel")//$NON-NLS-1$
-						|| token.equals("localHiding")//$NON-NLS-1$
-						|| token.equals("fieldHiding")//$NON-NLS-1$
-						|| token.equals("specialParamHiding")//$NON-NLS-1$
+						|| token.equals("allJavadoc")//$NON-NLS-1$
+						|| token.equals("allOver-ann")//$NON-NLS-1$
+						|| token.equals("assertIdentifier")//$NON-NLS-1$
+						|| token.equals("boxing")//$NON-NLS-1$
+						|| token.equals("charConcat")//$NON-NLS-1$
+						|| token.equals("compareIdentical")//$NON-NLS-1$
 						|| token.equals("conditionAssign")//$NON-NLS-1$
-						|| token.equals("syntheticAccess")//$NON-NLS-1$
-						|| token.equals("synthetic-access")//$NON-NLS-1$
-						|| token.equals("nls")//$NON-NLS-1$
-						|| token.equals("staticReceiver")//$NON-NLS-1$
+						|| token.equals("constructorName")//$NON-NLS-1$
+						|| token.equals("deadCode")//$NON-NLS-1$
+						|| token.equals("dep-ann")//$NON-NLS-1$
+						|| token.equals("deprecation")//$NON-NLS-1$
+						|| token.equals("discouraged")//$NON-NLS-1$
+						|| token.equals("emptyBlock")//$NON-NLS-1$
+						|| token.equals("enumIdentifier")//$NON-NLS-1$
+						|| token.equals("enumSwitch")//$NON-NLS-1$
+						|| token.equals("fallthrough")//$NON-NLS-1$
+						|| token.equals("fieldHiding")//$NON-NLS-1$
+						|| token.equals("finalBound")//$NON-NLS-1$
+						|| token.equals("finally")//$NON-NLS-1$
+						|| token.equals("forbidden")//$NON-NLS-1$
+						|| token.equals("hashCode")//$NON-NLS-1$
+						|| token.equals("hiding")//$NON-NLS-1$
+						|| token.equals("includeAssertNull")//$NON-NLS-1$
+						|| token.equals("incomplete-switch")//$NON-NLS-1$
 						|| token.equals("indirectStatic")//$NON-NLS-1$
-						|| token.equals("noEffectAssign")//$NON-NLS-1$
-						|| token.equals("intfNonInherited")//$NON-NLS-1$
 						|| token.equals("interfaceNonInherited")//$NON-NLS-1$
-						|| token.equals("charConcat")//$NON-NLS-1$
+						|| token.equals("intfAnnotation")//$NON-NLS-1$
+						|| token.equals("intfNonInherited")//$NON-NLS-1$
+						|| token.equals("intfRedundant")//$NON-NLS-1$
+						|| token.equals("javadoc")//$NON-NLS-1$
+						|| token.equals("localHiding")//$NON-NLS-1$
+						|| token.equals("maskedCatchBlock")//$NON-NLS-1$
+						|| token.equals("maskedCatchBlocks")//$NON-NLS-1$
+						|| token.equals("nls")//$NON-NLS-1$
+						|| token.equals("noEffectAssign")//$NON-NLS-1$
 						|| token.equals("noImplicitStringConversion")//$NON-NLS-1$
+						|| token.equals("null")//$NON-NLS-1$
+						|| token.equals("nullDereference")//$NON-NLS-1$
+						|| token.equals("over-ann")//$NON-NLS-1$
+						|| token.equals("packageDefaultMethod")//$NON-NLS-1$
+						|| token.equals("paramAssign")//$NON-NLS-1$
+						|| token.equals("pkgDefaultMethod")//$NON-NLS-1$
+						|| token.equals("raw")//$NON-NLS-1$
 						|| token.equals("semicolon")//$NON-NLS-1$
 						|| token.equals("serial")//$NON-NLS-1$
-						|| token.equals("emptyBlock")//$NON-NLS-1$
-						|| token.equals("uselessTypeCheck")//$NON-NLS-1$
-						|| token.equals("unchecked")//$NON-NLS-1$
-						|| token.equals("unsafe")//$NON-NLS-1$
-						|| token.equals("raw")//$NON-NLS-1$
-						|| token.equals("finalBound")//$NON-NLS-1$
+						|| token.equals("specialParamHiding")//$NON-NLS-1$
+						|| token.equals("static-access")//$NON-NLS-1$
+						|| token.equals("staticReceiver")//$NON-NLS-1$
+						|| token.equals("super")//$NON-NLS-1$
 						|| token.equals("suppress")//$NON-NLS-1$
-						|| token.equals("warningToken")//$NON-NLS-1$
+						|| token.equals("syncOverride")//$NON-NLS-1$
+						|| token.equals("synthetic-access")//$NON-NLS-1$
+						|| token.equals("syntheticAccess")//$NON-NLS-1$
+						|| token.equals("typeHiding")//$NON-NLS-1$
+						|| token.equals("unchecked")//$NON-NLS-1$
 						|| token.equals("unnecessaryElse")//$NON-NLS-1$
-						|| token.equals("javadoc")//$NON-NLS-1$
-						|| token.equals("allJavadoc")//$NON-NLS-1$
-						|| token.equals("assertIdentifier")//$NON-NLS-1$
-						|| token.equals("enumIdentifier")//$NON-NLS-1$
-						|| token.equals("finally")//$NON-NLS-1$
-						|| token.equals("unusedThrown")//$NON-NLS-1$
-						|| token.equals("unqualifiedField")//$NON-NLS-1$
+						|| token.equals("unnecessaryOperator")//$NON-NLS-1$
 						|| token.equals("unqualified-field-access")//$NON-NLS-1$
-						|| token.equals("typeHiding")//$NON-NLS-1$
-						|| token.equals("varargsCast")//$NON-NLS-1$
-						|| token.equals("null")//$NON-NLS-1$
-						|| token.equals("boxing")//$NON-NLS-1$
-						|| token.equals("over-ann")//$NON-NLS-1$
-						|| token.equals("dep-ann")//$NON-NLS-1$
-						|| token.equals("intfAnnotation")//$NON-NLS-1$
-						|| token.equals("enumSwitch")//$NON-NLS-1$
-						|| token.equals("incomplete-switch")//$NON-NLS-1$
-						|| token.equals("hiding")//$NON-NLS-1$
-						|| token.equals("static-access")//$NON-NLS-1$
+						|| token.equals("unqualifiedField")//$NON-NLS-1$
+						|| token.equals("unsafe")//$NON-NLS-1$
 						|| token.equals("unused")//$NON-NLS-1$
-						|| token.equals("paramAssign")//$NON-NLS-1$
-						|| token.equals("discouraged")//$NON-NLS-1$
-						|| token.equals("forbidden")//$NON-NLS-1$
-						|| token.equals("fallthrough")) {//$NON-NLS-1$
+						|| token.equals("unusedArgument")//$NON-NLS-1$
+						|| token.equals("unusedArguments")//$NON-NLS-1$
+						|| token.equals("unusedImport")//$NON-NLS-1$
+						|| token.equals("unusedImports")//$NON-NLS-1$
+						|| token.equals("unusedLabel")//$NON-NLS-1$
+						|| token.equals("unusedLocal")//$NON-NLS-1$
+						|| token.equals("unusedLocals")//$NON-NLS-1$
+						|| token.equals("unusedPrivate")//$NON-NLS-1$
+						|| token.equals("unusedThrown")//$NON-NLS-1$
+						|| token.equals("unusedTypeArgs")//$NON-NLS-1$
+						|| token.equals("uselessTypeCheck")//$NON-NLS-1$
+						|| token.equals("varargsCast")//$NON-NLS-1$
+						|| token.equals("warningToken")) {//$NON-NLS-1$
 					continue;
-    			} else if (token.equals("tasks")) {//$NON-NLS-1$
-    				String taskTags = "";//$NON-NLS-1$
-    				int start = token.indexOf('(');
-    				int end = token.indexOf(')');
-    				if (start >= 0 && end >= 0 && start < end){
-    					taskTags = token.substring(start+1, end).trim();
-    					taskTags = taskTags.replace('|',',');
-    				}
-    				if (taskTags.length() == 0){
-    					return -1;
-    				}
-    				continue;
-    			} else {
-    				return -1;
-    			}
+				} else if (token.equals("tasks")) {//$NON-NLS-1$
+					String taskTags = "";//$NON-NLS-1$
+					int start = token.indexOf('(');
+					int end = token.indexOf(')');
+					if (start >= 0 && end >= 0 && start < end){
+						taskTags = token.substring(start+1, end).trim();
+						taskTags = taskTags.replace('|',',');
+					}
+					if (taskTags.length() == 0){
+						return -1;
+					}
+					continue;
+				} else {
+					return -1;
+				}
 			}
 			if (tokenCounter == 0) {
 				return -1;
@@ -225,6 +247,28 @@ public final class Options {
 				return 0;
 			}
 		}
+		if (option.startsWith("-nowarn")) {//$NON-NLS-1$
+			switch (option.length()) {
+				case 7:
+					return 0;
+				case 8:
+					return -1;
+				default:
+					int foldersStart = option.indexOf('[') + 1;
+					int foldersEnd = option.lastIndexOf(']');
+					if (foldersStart <= 8 || foldersEnd == -1
+							|| foldersStart > foldersEnd
+							|| foldersEnd < option.length() - 1) {
+						return -1;
+					}
+					String folders = option.substring(foldersStart, foldersEnd);
+					if (folders.length() > 0) {
+						return 0;
+					} else {
+						return -1;
+					}
+			}
+		}
 		if (option.startsWith("-J")//$NON-NLS-1$
 				|| option.startsWith("-X")//$NON-NLS-1$
 				|| option.startsWith("-A")) {//$NON-NLS-1$
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Util.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Util.java
index 2559cee..51177b2 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Util.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -38,7 +38,7 @@ public final class Util {
 			this.position = position;
 			this.length = length;
 		}
-		
+
 		public String getSource(char[] unitSource) {
 			//extra from the source the innacurate     token
 			//and "highlight" it using some underneath ^^^^^
@@ -49,7 +49,7 @@ public final class Util {
 			//sanity .....
 			int startPosition = this.position;
 			int endPosition = this.position + this.length - 1;
-			
+
 			if ((startPosition > endPosition)
 				|| ((startPosition < 0) && (endPosition < 0))
 				|| unitSource.length == 0)
@@ -57,29 +57,29 @@ public final class Util {
 
 			StringBuffer errorBuffer = new StringBuffer();
 			errorBuffer.append('\t');
-			
+
 			char c;
 			final char SPACE = ' ';
 			final char MARK = '^';
 			final char TAB = '\t';
 			//the next code tries to underline the token.....
 			//it assumes (for a good display) that token source does not
-			//contain any \r \n. This is false on statements ! 
+			//contain any \r \n. This is false on statements !
 			//(the code still works but the display is not optimal !)
 
 			// expand to line limits
-			int length = unitSource.length, begin, end;
-			for (begin = startPosition >= length ? length - 1 : startPosition; begin > 0; begin--) {
+			int sourceLength = unitSource.length, begin, end;
+			for (begin = startPosition >= sourceLength ? sourceLength - 1 : startPosition; begin > 0; begin--) {
 				if ((c = unitSource[begin - 1]) == '\n' || c == '\r') break;
 			}
-			for (end = endPosition >= length ? length - 1 : endPosition ; end+1 < length; end++) {
+			for (end = endPosition >= sourceLength ? sourceLength - 1 : endPosition ; end+1 < sourceLength; end++) {
 				if ((c = unitSource[end + 1]) == '\r' || c == '\n') break;
 			}
-			
+
 			// trim left and right spaces/tabs
 			while ((c = unitSource[begin]) == ' ' || c == '\t') begin++;
 			//while ((c = unitSource[end]) == ' ' || c == '\t') end--; TODO (philippe) should also trim right, but all tests are to be updated
-			
+
 			// copy source
 			errorBuffer.append(unitSource, begin, end-begin+1);
 			errorBuffer.append(Util.LINE_SEPARATOR).append("\t"); //$NON-NLS-1$
@@ -88,17 +88,17 @@ public final class Util {
 			for (int i = begin; i <startPosition; i++) {
 				errorBuffer.append((unitSource[i] == TAB) ? TAB : SPACE);
 			}
-			for (int i = startPosition; i <= (endPosition >= length ? length - 1 : endPosition); i++) {
+			for (int i = startPosition; i <= (endPosition >= sourceLength ? sourceLength - 1 : endPosition); i++) {
 				errorBuffer.append(MARK);
 			}
 			return errorBuffer.toString();
 		}
 	}
 	public static class EncodingErrorCollector {
-		ArrayList<EncodingError> encodingErrors = new ArrayList<EncodingError>();
+		ArrayList<EncodingError> encodingErrors = new ArrayList<>();
 		FileObject fileObject;
 		String encoding;
-		
+
 		public EncodingErrorCollector(FileObject fileObject, String encoding) {
 			this.fileObject = fileObject;
 			this.encoding = encoding;
@@ -135,7 +135,7 @@ public final class Util {
 		byteBuffer.flip();
 		return charsetDecoder.decode(byteBuffer).array();
 	}
-	
+
 	public static CharSequence getCharContents(FileObject fileObject, boolean ignoreEncodingErrors, byte[] contents, String encoding) throws IOException {
 		if (contents == null) return null;
 		Charset charset = null;
@@ -199,7 +199,7 @@ public final class Util {
 			return out;
 		}
 	}
-	
+
 	private static void reportEncodingError(EncodingErrorCollector collector, int position, int length) {
 		collector.collect(position, -length);
 	}
diff --git a/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/AllTests.java b/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/AllTests.java
index 02341dd..a2eb010 100644
--- a/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/AllTests.java
+++ b/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/AllTests.java
@@ -21,7 +21,7 @@ public class AllTests extends TestCase {
 	// run all tests
 	public static Test suite() {
 		TestSuite suite = new TestSuite();
-		suite.addTest(CompilerToolTests.suite());
+		suite.addTestSuite(CompilerToolTests.class);
 		suite.addTest(CompilerInvocationTests.suite());
 		return suite;
 	}
diff --git a/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/CompilerToolTests.java b/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/CompilerToolTests.java
index 67e7d8b..a150bc3 100644
--- a/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/CompilerToolTests.java
+++ b/org.eclipse.jdt.compiler.tool.tests/src/org/eclipse/jdt/compiler/tool/tests/CompilerToolTests.java
@@ -33,16 +33,15 @@ import javax.tools.Diagnostic;
 import javax.tools.FileObject;
 import javax.tools.ForwardingJavaFileManager;
 import javax.tools.JavaCompiler;
+import javax.tools.JavaCompiler.CompilationTask;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
+import javax.tools.JavaFileObject.Kind;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.StandardLocation;
 import javax.tools.ToolProvider;
-import javax.tools.JavaCompiler.CompilationTask;
-import javax.tools.JavaFileObject.Kind;
 
 import junit.framework.TestCase;
-import junit.framework.TestSuite;
 
 import org.eclipse.jdt.compiler.tool.tests.AbstractCompilerToolTest.CompilerInvocationDiagnosticListener;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -56,27 +55,8 @@ public class CompilerToolTests extends TestCase {
 	public CompilerToolTests(String name) {
 		super(name);
 	}
-	public static TestSuite suite() {
-		TestSuite suite = new TestSuite();
-		suite.addTest(new CompilerToolTests("testInitializeJavaCompiler"));
-		suite.addTest(new CompilerToolTests("testFileManager"));
-		suite.addTest(new CompilerToolTests("testFileManager2"));
-		suite.addTest(new CompilerToolTests("testInferBinaryName"));
-		suite.addTest(new CompilerToolTests("testCheckOptions"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithSystemCompiler"));
-//		suite.addTest(new CompilerToolTests("testCompilerOneClassWithSystemCompiler2"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler2"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler3"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler4"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler5"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler6"));
-		suite.addTest(new CompilerToolTests("testCompilerOneClassWithEclipseCompiler7"));
-		suite.addTest(new CompilerToolTests("testCleanUp"));
-		return suite;
-	}
 
-	private static JavaCompiler Compiler;
+	private JavaCompiler compiler;
 	static final String[] ONE_ARG_OPTIONS = {
 		"-cp",
 		"-classpath",
@@ -102,6 +82,9 @@ public class CompilerToolTests extends TestCase {
 		"-1.5",
 		"-1.6",
 		"-1.7",
+		"-1.8",
+		"-8",
+		"-8.0",
 		"-7",
 		"-7.0",
 		"-6",
@@ -160,31 +143,34 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		}
 	}
 
-	/*
-	 * Initialize the compiler for all the tests
-	 */
-	public void testInitializeJavaCompiler() {
+	@Override
+	protected void setUp() throws Exception {
 		ServiceLoader<JavaCompiler> javaCompilerLoader = ServiceLoader.load(JavaCompiler.class);//, EclipseCompiler.class.getClassLoader());
 		int compilerCounter = 0;
 		for (JavaCompiler javaCompiler : javaCompilerLoader) {
 			compilerCounter++;
 			if (javaCompiler instanceof EclipseCompiler) {
-				Compiler = javaCompiler;
+				compiler = javaCompiler;
 			}
 		}
 		assertEquals("Only one compiler available", 1, compilerCounter);
 	}
 
+	@Override
+	protected void tearDown() throws Exception {
+		compiler = null;
+	}
+
 	public void testCheckOptions() {
-		assertNotNull("No compiler found", Compiler);
+		assertNotNull("No compiler found", compiler);
 		for (String option : ONE_ARG_OPTIONS) {
-			assertEquals(option + " requires 1 argument", 1, Compiler.isSupportedOption(option));
+			assertEquals(option + " requires 1 argument", 1, compiler.isSupportedOption(option));
 		}
 		for (String option : ZERO_ARG_OPTIONS) {
-			assertEquals(option + " requires no argument", 0, Compiler.isSupportedOption(option));
+			assertEquals(option + " requires no argument", 0, compiler.isSupportedOption(option));
 		}
 		for (String option : FAKE_ZERO_ARG_OPTIONS) {
-			assertEquals(option + " requires no argument", 0, Compiler.isSupportedOption(option));
+			assertEquals(option + " requires no argument", 0, compiler.isSupportedOption(option));
 		}
 	}
 
@@ -218,7 +204,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		// System compiler
 		StandardJavaFileManager manager = systemCompiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
-		ForwardingJavaFileManager<StandardJavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<StandardJavaFileManager>(manager) {
+		ForwardingJavaFileManager<JavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<JavaFileManager>(manager) {
 			@Override
 			public FileObject getFileForInput(Location location, String packageName, String relativeName)
 					throws IOException {
@@ -277,7 +263,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 	 * Run the system compiler using the Eclipse java file manager
 	 * TODO need to investigate why rt.jar gets removed from the PLATFORM_CLASSPATH location
 	 */
-	public void _testCompilerOneClassWithSystemCompiler2() {
+	public void testCompilerOneClassWithSystemCompiler2() {
 		// System compiler
 		JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();
 		if (systemCompiler == null) {
@@ -305,10 +291,9 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 				}
 			}
 		}
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
-		@SuppressWarnings("resource")
-		ForwardingJavaFileManager<StandardJavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<StandardJavaFileManager>(manager) {
+		ForwardingJavaFileManager<JavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<JavaFileManager>(manager) {
 			@Override
 			public FileObject getFileForInput(Location location, String packageName, String relativeName)
 					throws IOException {
@@ -340,8 +325,29 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 				}
 				return javaFileForOutput;
 			}
+			@Override
+			public String inferBinaryName(Location location, JavaFileObject file) {
+				String binaryName = super.inferBinaryName(location, file);
+				if (DEBUG) {
+					System.out.println("binary name: " + binaryName);
+				}
+				return binaryName;
+			}
+			@Override
+			public Iterable<JavaFileObject> list(Location location, String packageName, Set<Kind> kinds, boolean recurse)
+					throws IOException {
+				Iterable<JavaFileObject> list = super.list(location, packageName, kinds, recurse);
+				if (DEBUG) {
+					System.out.println("start list: ");
+					for (JavaFileObject fileObject : list) {
+						System.out.println(fileObject.getName());
+					}
+					System.out.println("end   list: ");
+				}
+				return list;
+			}
 		};
-		// create new list containing inputfile
+		// create new list containing input file
 		List<File> files = new ArrayList<File>();
 		files.add(inputFile);
 		Iterable<? extends JavaFileObject> units = manager.getJavaFileObjectsFromFiles(files);
@@ -351,7 +357,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		List<String> options = new ArrayList<String>();
 		options.add("-d");
 		options.add(tmpFolder);
-		CompilationTask task = systemCompiler.getTask(printWriter, manager, null, options, null, units);
+		CompilationTask task = systemCompiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
 
 		if (DEBUG) {
 			System.out.println("Has location CLASS_OUPUT : " + forwardingJavaFileManager.hasLocation(StandardLocation.CLASS_OUTPUT));
@@ -392,17 +398,33 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
 		ForwardingJavaFileManager<StandardJavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<StandardJavaFileManager>(manager) {
 			@Override
+			public FileObject getFileForInput(Location location, String packageName, String relativeName)
+					throws IOException {
+				if (DEBUG) {
+					System.out.println("Create file for input : " + packageName + " " + relativeName + " in location " + location);
+				}
+				return super.getFileForInput(location, packageName, relativeName);
+			}
+			@Override
+			public JavaFileObject getJavaFileForInput(Location location, String className, Kind kind)
+					throws IOException {
+				if (DEBUG) {
+					System.out.println("Create java file for input : " + className + " in location " + location);
+				}
+				return super.getJavaFileForInput(location, className, kind);
+			}
+			@Override
 			public JavaFileObject getJavaFileForOutput(Location location,
 					String className,
 					Kind kind,
 					FileObject sibling) throws IOException {
 
 				if (DEBUG) {
-					System.out.println("EC: Create .class file for " + className + " in location " + location + " with sibling " + sibling.toUri());
+					System.out.println("Create .class file for " + className + " in location " + location + " with sibling " + sibling.toUri());
 				}
 				JavaFileObject javaFileForOutput = super.getJavaFileForOutput(location, className, kind, sibling);
 				if (DEBUG) {
@@ -411,7 +433,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 				return javaFileForOutput;
 			}
 		};
-		// create new list containing inputfile
+		// create new list containing input file
 		List<File> files = new ArrayList<File>();
 		files.add(inputFile);
 		Iterable<? extends JavaFileObject> units = manager.getJavaFileObjectsFromFiles(files);
@@ -421,7 +443,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		List<String> options = new ArrayList<String>();
 		options.add("-d");
 		options.add(tmpFolder);
- 		CompilationTask task = Compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
+ 		CompilationTask task = compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
  		// check the classpath location
  		assertTrue("Has no location CLASS_OUPUT", forwardingJavaFileManager.hasLocation(StandardLocation.CLASS_OUTPUT));
 		Boolean result = task.call();
@@ -468,7 +490,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
 		ForwardingJavaFileManager<StandardJavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<StandardJavaFileManager>(manager) {
 			@Override
@@ -498,7 +520,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		options.add("-d");
 		options.add(tmpFolder);
 		options.add("-1.5");
- 		CompilationTask task = Compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
+ 		CompilationTask task = compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
  		// check the classpath location
  		assertTrue("Has no location CLASS_OUPUT", forwardingJavaFileManager.hasLocation(StandardLocation.CLASS_OUTPUT));
 		Boolean result = task.call();
@@ -523,7 +545,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 
 		stringWriter = new StringWriter();
 		printWriter = new PrintWriter(stringWriter);
-		task = Compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
+		task = compiler.getTask(printWriter, forwardingJavaFileManager, null, options, null, units);
 		// check the classpath location
 		assertTrue("Has no location CLASS_OUPUT", forwardingJavaFileManager.hasLocation(StandardLocation.CLASS_OUTPUT));
 		result = task.call();
@@ -560,7 +582,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
 		@SuppressWarnings("resource")
 		ForwardingJavaFileManager<StandardJavaFileManager> forwardingJavaFileManager = new ForwardingJavaFileManager<StandardJavaFileManager>(manager) {
@@ -590,7 +612,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		List<String> options = new ArrayList<String>();
 		options.add("-d");
 		options.add(tmpFolder);
- 		CompilationTask task = Compiler.getTask(printWriter, manager, null, options, null, units);
+ 		CompilationTask task = compiler.getTask(printWriter, manager, null, options, null, units);
  		// check the classpath location
  		assertTrue("Has no location CLASS_OUPUT", forwardingJavaFileManager.hasLocation(StandardLocation.CLASS_OUTPUT));
 		Boolean result = task.call();
@@ -650,7 +672,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		List<String> options = new ArrayList<String>();
 		options.add("-d");
 		options.add(tmpFolder);
-		CompilationTask task = Compiler.getTask(null, null, null, options, null, units);
+		CompilationTask task = compiler.getTask(null, null, null, options, null, units);
 		// check the classpath location
 		Boolean result = task.call();
 		printWriter.flush();
@@ -687,7 +709,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 		List<File> files = new ArrayList<File>();
 		files.add(inputFile);
 		Iterable<? extends JavaFileObject> units = manager.getJavaFileObjectsFromFiles(files);
@@ -698,7 +720,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		ByteArrayOutputStream errBuffer = new ByteArrayOutputStream();
 		PrintWriter err = new PrintWriter(errBuffer);
 		CompilerInvocationDiagnosticListener compilerInvocationDiagnosticListener = new CompilerInvocationDiagnosticListener(err);
-		CompilationTask task = Compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
+		CompilationTask task = compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
 		// check the classpath location
 		Boolean result = task.call();
 		err.flush();
@@ -739,7 +761,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 		List<File> files = new ArrayList<File>();
 		files.add(inputFile);
 		Iterable<? extends JavaFileObject> units = manager.getJavaFileObjectsFromFiles(files);
@@ -759,7 +781,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 				super.report(diagnostic);
 			}
 		};
-		CompilationTask task = Compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
+		CompilationTask task = compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
 		// check the classpath location
 		Boolean result = task.call();
 		err.flush();
@@ -797,7 +819,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		// System compiler
-		StandardJavaFileManager manager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 		List<File> files = new ArrayList<File>();
 		files.add(inputFile);
 		Iterable<? extends JavaFileObject> units = manager.getJavaFileObjectsFromFiles(files);
@@ -817,7 +839,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 				super.report(diagnostic);
 			}
 		};
-		CompilationTask task = Compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
+		CompilationTask task = compiler.getTask(null, manager, compilerInvocationDiagnosticListener, options, null, units);
 		// check the classpath location
 		Boolean result = task.call();
 		err.flush();
@@ -853,7 +875,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 			}
 		}
 		try {
-			StandardJavaFileManager fileManager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+			StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 	
 			List<File> fins = new ArrayList<File>();
 			fins.add(dir);
@@ -902,7 +924,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		}
 		try {
 			//JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();
-			StandardJavaFileManager fileManager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+			StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 	
 			List<File> fins = new ArrayList<File>();
 			fins.add(dir);
@@ -987,7 +1009,7 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 		}
 		try {
 			//JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();
-			StandardJavaFileManager fileManager = Compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
+			StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 	
 			List<File> fins = new ArrayList<File>();
 			fins.add(dir);
@@ -1025,6 +1047,6 @@ static final String[] FAKE_ZERO_ARG_OPTIONS = new String[] {
 	 * Clean up the compiler
 	 */
 	public void testCleanUp() {
-		Compiler = null;
+		compiler = null;
 	}
 }
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
new file mode 100644
index 0000000..24adb24
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
@@ -0,0 +1,203 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.batch;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import javax.tools.JavaFileManager;
+import javax.tools.JavaFileObject;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+
+@SuppressWarnings({ "rawtypes", "unchecked" })
+public class ClasspathJsr199 extends ClasspathLocation {
+	private static final Set<JavaFileObject.Kind> fileTypes = new HashSet<>();
+
+	static {
+		fileTypes.add(JavaFileObject.Kind.CLASS);
+	}
+
+	private JavaFileManager fileManager;
+	private JavaFileManager.Location location;
+
+	public ClasspathJsr199(JavaFileManager file, JavaFileManager.Location location) {
+		super(null, null);
+		this.fileManager = file;
+		this.location = location;
+	}
+
+	@Override
+	public List fetchLinkedJars(FileSystem.ClasspathSectionProblemReporter problemReporter) {
+		// Assume no linked jars
+		return null;
+	}
+
+	@Override
+	public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String qualifiedBinaryFileName) {
+		return findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName, false);
+	}
+
+	@Override
+	public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String aQualifiedBinaryFileName,
+			boolean asBinaryOnly) {
+
+		String qualifiedBinaryFileName = File.separatorChar == '/'
+				? aQualifiedBinaryFileName
+				: aQualifiedBinaryFileName.replace(File.separatorChar, '/');
+
+		try {
+			int lastDot = qualifiedBinaryFileName.lastIndexOf('.');
+			String className = lastDot < 0 ? qualifiedBinaryFileName : qualifiedBinaryFileName.substring(0, lastDot);
+			JavaFileObject jfo = null;
+			try {
+				jfo = this.fileManager.getJavaFileForInput(this.location, className, JavaFileObject.Kind.CLASS);
+			} catch (IOException e) {
+				// treat as if class file is missing
+			}
+
+			if (jfo == null)
+				return null; // most common case
+	
+			try (InputStream inputStream = jfo.openInputStream()) {
+				ClassFileReader reader = ClassFileReader.read(inputStream, qualifiedBinaryFileName);
+				if (reader != null) {
+					return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName));
+				}
+			}
+		} catch (ClassFormatException e) {
+			// treat as if class file is missing
+		} catch (IOException e) {
+			// treat as if class file is missing
+		}
+		return null;
+	}
+
+	@Override
+	public char[][][] findTypeNames(String aQualifiedPackageName) {
+		String qualifiedPackageName = File.separatorChar == '/' ? aQualifiedPackageName : aQualifiedPackageName.replace(
+				File.separatorChar, '/');
+
+		Iterable<JavaFileObject> files = null;
+		try {
+			files = this.fileManager.list(this.location, qualifiedPackageName, fileTypes, false);
+		} catch (IOException e) {
+			// treat as if empty
+		}
+		if (files == null) {
+			return null;
+		}
+		ArrayList answers = new ArrayList();
+		char[][] packageName = CharOperation.splitOn(File.separatorChar, qualifiedPackageName.toCharArray());
+
+		for (JavaFileObject file : files) {
+			String fileName = file.toUri().getPath();
+
+			int last = fileName.lastIndexOf('/');
+			if (last > 0) {
+				int indexOfDot = fileName.lastIndexOf('.');
+				if (indexOfDot != -1) {
+					String typeName = fileName.substring(last + 1, indexOfDot);
+					answers.add(CharOperation.arrayConcat(packageName, typeName.toCharArray()));
+				}
+			}
+		}
+		int size = answers.size();
+		if (size != 0) {
+			char[][][] result = new char[size][][];
+			answers.toArray(result);
+			return result;
+		}
+		return null;
+	}
+
+	@Override
+	public void initialize() throws IOException {
+		// nothing to do
+	}
+
+	@Override
+	public boolean isPackage(String aQualifiedPackageName) {
+		String qualifiedPackageName = File.separatorChar == '/' ? aQualifiedPackageName : aQualifiedPackageName.replace(
+				File.separatorChar, '/');
+
+		boolean result = false;
+		try {
+			Iterable<JavaFileObject> files = this.fileManager.list(this.location, qualifiedPackageName, fileTypes, false);
+			Iterator f = files.iterator();
+			// if there is any content, assume a package
+			if (f.hasNext()) {
+				result = true;
+			} else {
+				// I hate to do this since it is expensive and will throw off garbage
+				// but can't think of an alternative now
+				files = this.fileManager.list(this.location, qualifiedPackageName, fileTypes, true);
+				f = files.iterator();
+				// if there is any content, assume a package
+				if (f.hasNext()) {
+					result = true;
+				}
+			}
+		} catch (IOException e) {
+			// treat as if missing
+		}
+		return result;
+	}
+
+	@Override
+	public void reset() {
+		try {
+			this.fileManager.flush();
+		} catch (IOException e) {
+			// ignore
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "Classpath for Jsr 199 JavaFileManager: " + this.location; //$NON-NLS-1$
+	}
+
+	@Override
+	public char[] normalizedPath() {
+		if (this.normalizedPath == null) {
+			this.normalizedPath = this.path.toCharArray();
+		}
+		return this.normalizedPath;
+	}
+
+	@Override
+	public String getPath() {
+		if (this.path == null) {
+			this.path = this.location.getName();
+		}
+		return this.path;
+	}
+
+	@Override
+	public int getMode() {
+		return BINARY;
+	}
+	
+	@Override
+	public boolean hasAnnotationFileFor(String qualifiedTypeName) {
+		return false;
+	}
+}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Archive.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Archive.java
index f5c39dd..f6094e9 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Archive.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Archive.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,8 +14,10 @@ import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.Hashtable;
+import java.util.List;
 import java.util.Set;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
@@ -30,6 +32,7 @@ public class Archive {
 	
 	ZipFile zipFile;
 	File file;
+
 	protected Hashtable<String, ArrayList<String>> packagesCache;
 	
 	private Archive() {
@@ -39,12 +42,12 @@ public class Archive {
 	public Archive(File file) throws ZipException, IOException {
 		this.file = file;
 		this.zipFile = new ZipFile(file);
-		initialize();		
+		initialize();
 	}
 
 	private void initialize() {
 		// initialize packages
-		this.packagesCache = new Hashtable<String, ArrayList<String>>();
+		this.packagesCache = new Hashtable<>();
 		nextEntry : for (Enumeration<? extends ZipEntry> e = this.zipFile.entries(); e.hasMoreElements(); ) {
 			String fileName = ((ZipEntry) e.nextElement()).getName();
 
@@ -59,7 +62,7 @@ public class Archive {
 				if (typeName.length() == 0) {
 					continue nextEntry;
 				}
-				types = new ArrayList<String>();
+				types = new ArrayList<>();
 				types.add(typeName);
 				this.packagesCache.put(packageName, types);
 			} else {
@@ -69,7 +72,7 @@ public class Archive {
 	}
 	
 	public ArchiveFileObject getArchiveFileObject(String entryName, Charset charset) {
-		return new ArchiveFileObject(this.file, this.zipFile, entryName, charset);
+		return new ArchiveFileObject(this.file, entryName, charset);
 	}
 	
 	public boolean contains(String entryName) {
@@ -83,8 +86,16 @@ public class Archive {
 		return this.packagesCache.keySet();
 	}
 	
-	public ArrayList<String> getTypes(String packageName) {
+	public List<String> getTypes(String packageName) {
 		// package name is expected to ends with '/'
+		if (this.packagesCache == null) {
+			try {
+				this.zipFile = new ZipFile(this.file);
+			} catch(IOException e) {
+				return Collections.<String>emptyList();
+			}
+			this.initialize();
+		}
 		return this.packagesCache.get(packageName);
 	}
 	
@@ -94,10 +105,17 @@ public class Archive {
 
 	public void close() {
 		try {
-			if (this.zipFile != null) this.zipFile.close();
+			if (this.zipFile != null) {
+				this.zipFile.close();
+			}
 			this.packagesCache = null;
 		} catch (IOException e) {
 			// ignore
 		}
 	}
+	
+	@Override
+	public String toString() {
+		return "Archive: " + (this.file == null ? "UNKNOWN_ARCHIVE" : this.file.getAbsolutePath()); //$NON-NLS-1$ //$NON-NLS-2$
+	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/ArchiveFileObject.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/ArchiveFileObject.java
index e07ff84..73ef27e 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/ArchiveFileObject.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/ArchiveFileObject.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2013 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,20 +34,29 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
  * Implementation of a Java file object that corresponds to an entry in a zip/jar file
  */
 public class ArchiveFileObject implements JavaFileObject {
-	private ZipEntry zipEntry;
-	private ZipFile zipFile;
 	private String entryName;
 	private File file;
+	private ZipFile zipFile;
 	private Charset charset;
-	
-	public ArchiveFileObject(File file, ZipFile zipFile, String entryName, Charset charset) {
-		this.zipFile = zipFile;
-		this.zipEntry = zipFile.getEntry(entryName);
+
+	public ArchiveFileObject(File file, String entryName, Charset charset) {
 		this.entryName = entryName;
 		this.file = file;
 		this.charset = charset;
 	}
 
+	@Override
+	protected void finalize() throws Throwable {
+		if (this.zipFile != null) {
+			try {
+				this.zipFile.close();
+			} catch (IOException e) {
+				// ignore
+			}
+		}
+		super.finalize();
+	}
+
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileObject#getAccessLevel()
 	 */
@@ -59,12 +68,15 @@ public class ArchiveFileObject implements JavaFileObject {
 		}
 		ClassFileReader reader = null;
 		try {
-			reader = ClassFileReader.read(this.zipFile, this.entryName);
+			try (ZipFile zip = new ZipFile(this.file)) {
+				reader = ClassFileReader.read(zip, this.entryName);
+			}
 		} catch (ClassFormatException e) {
 			// ignore
 		} catch (IOException e) {
 			// ignore
 		}
+
 		if (reader == null) {
 			return null;
 		}
@@ -103,32 +115,34 @@ public class ArchiveFileObject implements JavaFileObject {
 	@Override
 	public NestingKind getNestingKind() {
 		switch(getKind()) {
-			case SOURCE :
-				return NestingKind.TOP_LEVEL;
-			case CLASS :
-        		ClassFileReader reader = null;
-        		try {
-        			reader = ClassFileReader.read(this.zipFile, this.entryName);
-        		} catch (ClassFormatException e) {
-        			// ignore
-        		} catch (IOException e) {
-        			// ignore
-        		}
-        		if (reader == null) {
-        			return null;
-        		}
-        		if (reader.isAnonymous()) {
-        			return NestingKind.ANONYMOUS;
-        		}
-        		if (reader.isLocal()) {
-        			return NestingKind.LOCAL;
-        		}
-        		if (reader.isMember()) {
-        			return NestingKind.MEMBER;
-        		}
-        		return NestingKind.TOP_LEVEL;
-        	default:
-        		return null;
+		case SOURCE :
+			return NestingKind.TOP_LEVEL;
+		case CLASS :
+			ClassFileReader reader = null;
+			try {
+				try (ZipFile zip = new ZipFile(this.file)) {
+					reader = ClassFileReader.read(zip, this.entryName);
+				}
+			} catch (ClassFormatException e) {
+				// ignore
+			} catch (IOException e) {
+				// ignore
+			}
+			if (reader == null) {
+				return null;
+			}
+			if (reader.isAnonymous()) {
+				return NestingKind.ANONYMOUS;
+			}
+			if (reader.isLocal()) {
+				return NestingKind.LOCAL;
+			}
+			if (reader.isMember()) {
+				return NestingKind.MEMBER;
+			}
+			return NestingKind.TOP_LEVEL;
+		default:
+			return null;
 		}
 	}
 
@@ -137,7 +151,7 @@ public class ArchiveFileObject implements JavaFileObject {
 	 */
 	@Override
 	public boolean isNameCompatible(String simpleName, Kind kind) {
-		return this.zipEntry.getName().endsWith(simpleName + kind.extension);
+		return this.entryName.endsWith(simpleName + kind.extension);
 	}
 
 	/* (non-Javadoc)
@@ -156,7 +170,7 @@ public class ArchiveFileObject implements JavaFileObject {
 		ArchiveFileObject archiveFileObject = (ArchiveFileObject) o;
 		return archiveFileObject.toUri().equals(this.toUri());
 	}
-	
+
 	@Override
 	public int hashCode() {
 		return this.toUri().hashCode();
@@ -168,7 +182,10 @@ public class ArchiveFileObject implements JavaFileObject {
 	@Override
 	public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 		if (getKind() == Kind.SOURCE) {
-			return Util.getCharContents(this, ignoreEncodingErrors, org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(this.zipEntry, this.zipFile), this.charset.name());
+			try (ZipFile zipFile2 = new ZipFile(this.file)) {
+				ZipEntry zipEntry = zipFile2.getEntry(this.entryName);
+				return Util.getCharContents(this, ignoreEncodingErrors, org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(zipEntry, zipFile2), this.charset.name());
+			}
 		}
 		return null;
 	}
@@ -178,7 +195,13 @@ public class ArchiveFileObject implements JavaFileObject {
 	 */
 	@Override
 	public long getLastModified() {
-		return this.zipEntry.getTime(); // looks the closest from the last modification
+		try (ZipFile zip = new ZipFile(this.file)) {
+			ZipEntry zipEntry = zip.getEntry(this.entryName);
+			return zipEntry.getTime(); // looks the closest from the last modification
+		} catch(IOException e) {
+			// ignore
+		}
+		return 0;
 	}
 
 	/* (non-Javadoc)
@@ -186,7 +209,7 @@ public class ArchiveFileObject implements JavaFileObject {
 	 */
 	@Override
 	public String getName() {
-		return this.zipEntry.getName();
+		return this.entryName;
 	}
 
 	/* (non-Javadoc)
@@ -194,7 +217,11 @@ public class ArchiveFileObject implements JavaFileObject {
 	 */
 	@Override
 	public InputStream openInputStream() throws IOException {
-		return this.zipFile.getInputStream(this.zipEntry);
+		if (this.zipFile == null) {
+			this.zipFile = new ZipFile(this.file);
+		}
+		ZipEntry zipEntry = this.zipFile.getEntry(this.entryName);
+		return this.zipFile.getInputStream(zipEntry);
 	}
 
 	/* (non-Javadoc)
@@ -227,15 +254,15 @@ public class ArchiveFileObject implements JavaFileObject {
 	@Override
 	public URI toUri() {
 		try {
-			return new URI("jar:" + this.file.toURI().getPath() + "!" + this.zipEntry.getName()); //$NON-NLS-1$//$NON-NLS-2$
+			return new URI("jar:" + this.file.toURI().getPath() + "!" + this.entryName); //$NON-NLS-1$//$NON-NLS-2$
 		} catch (URISyntaxException e) {
 			return null;
 		}
 	}
-	
 
-    @Override
-    public String toString() {
-        return this.file.getAbsolutePath() + "[" + this.zipEntry.getName() + "]";//$NON-NLS-1$//$NON-NLS-2$
-    }	
+
+	@Override
+	public String toString() {
+		return this.file.getAbsolutePath() + "[" + this.entryName + "]";//$NON-NLS-1$//$NON-NLS-2$
+	}	
 }
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
index a61c4dc..3081318 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompiler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2014 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -57,7 +57,7 @@ public class EclipseCompiler implements JavaCompiler {
 	public DiagnosticListener<? super JavaFileObject> diagnosticListener;
 
 	public EclipseCompiler() {
-		this.threadCache = new WeakHashMap<Thread, EclipseCompilerImpl>();
+		this.threadCache = new WeakHashMap<>();
 	}
 	/*
 	 * (non-Javadoc)
@@ -119,7 +119,7 @@ public class EclipseCompiler implements JavaCompiler {
 		eclipseCompiler2.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
 		eclipseCompiler2.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);
 
-		ArrayList<String> allOptions = new ArrayList<String>();
+		ArrayList<String> allOptions = new ArrayList<>();
 		if (options != null) {
 			for (Iterator<String> iterator = options.iterator(); iterator.hasNext(); ) {
 				eclipseCompiler2.fileManager.handleOption(iterator.next(), iterator);
@@ -139,7 +139,11 @@ public class EclipseCompiler implements JavaCompiler {
 				if (!uri.isAbsolute()) {
 					uri = URI.create("file://" + uri.toString()); //$NON-NLS-1$
 				}
-				allOptions.add(new File(uri).getAbsolutePath());
+				if (uri.getScheme().equals("file")) { //$NON-NLS-1$
+					allOptions.add(new File(uri).getAbsolutePath());
+				} else {
+					allOptions.add(uri.toString());
+				}
 			}
 		}
 
@@ -192,7 +196,7 @@ public class EclipseCompiler implements JavaCompiler {
 			}
 			@Override
 			public void setProcessors(Iterable<? extends Processor> processors) {
-				ArrayList<Processor> temp = new ArrayList<Processor>();
+				ArrayList<Processor> temp = new ArrayList<>();
 				for (Processor processor : processors) {
 					temp.add(processor);
 				}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
index 2897d8d..d21fffc 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 IBM Corporation and others.
+ * Copyright (c) 2007, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -35,8 +35,9 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.CompilationProgress;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
-import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
 import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
+import org.eclipse.jdt.internal.compiler.IProblemFactory;
+import org.eclipse.jdt.internal.compiler.batch.ClasspathJsr199;
 import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
@@ -44,6 +45,7 @@ import org.eclipse.jdt.internal.compiler.batch.Main;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblem;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.Messages;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 
@@ -104,7 +106,7 @@ public class EclipseCompilerImpl extends Main {
 	@Override
 	public CompilationUnit[] getCompilationUnits() {
 		if (this.compilationUnits == null) return EclipseCompilerImpl.NO_UNITS;
-		ArrayList<CompilationUnit> units = new ArrayList<CompilationUnit>();
+		ArrayList<CompilationUnit> units = new ArrayList<>();
 		for (final JavaFileObject javaFileObject : this.compilationUnits) {
 			if (javaFileObject.getKind() != JavaFileObject.Kind.SOURCE) {
 				throw new IllegalArgumentException();
@@ -155,14 +157,158 @@ public class EclipseCompilerImpl extends Main {
 	}
 
 	@Override
-    public ICompilerRequestor getBatchRequestor() {
-        return new EclipseCompilerRequestor(this, this.diagnosticListener, (DefaultProblemFactory) getProblemFactory());
-	}
+	public IProblemFactory getProblemFactory() {
+		return new DefaultProblemFactory() {
+			@Override
+			public CategorizedProblem createProblem(
+					final char[] originatingFileName,
+					final int problemId,
+					final String[] problemArguments,
+					final String[] messageArguments,
+					final int severity,
+					final int startPosition,
+					final int endPosition,
+					final int lineNumber,
+					final int columnNumber) {
+
+				DiagnosticListener<? super JavaFileObject> diagListener = EclipseCompilerImpl.this.diagnosticListener;
+				if (diagListener != null) {
+					diagListener.report(new Diagnostic<JavaFileObject>() {
+						@Override
+						public String getCode() {
+							return Integer.toString(problemId);
+						}
+						@Override
+						public long getColumnNumber() {
+							return columnNumber;
+						}
+						@Override
+						public long getEndPosition() {
+							return endPosition;
+						}
+						@Override
+						public Kind getKind() {
+							if ((severity & ProblemSeverities.Error) != 0) {
+								return Diagnostic.Kind.ERROR;
+							}
+							if ((severity & ProblemSeverities.Optional) != 0) {
+								return Diagnostic.Kind.WARNING;
+							}
+							if ((severity & ProblemSeverities.Warning) != 0) {
+								return Diagnostic.Kind.MANDATORY_WARNING;
+							}
+							return Diagnostic.Kind.OTHER;
+						}
+						@Override
+						public long getLineNumber() {
+							return lineNumber;
+						}
+						@Override
+						public String getMessage(Locale locale) {
+							if (locale != null) {
+								setLocale(locale);
+							}
+							return getLocalizedMessage(problemId, problemArguments);
+						}
+						@Override
+						public long getPosition() {
+							return startPosition;
+						}
+						@Override
+						public JavaFileObject getSource() {
+							File f = new File(new String(originatingFileName));
+							if (f.exists()) {
+								return new EclipseFileObject(null, f.toURI(), JavaFileObject.Kind.SOURCE, null);
+							}
+							return null;
+						}
+						@Override
+						public long getStartPosition() {
+							return startPosition;
+						}
+					});
+				}
+				return super.createProblem(originatingFileName, problemId, problemArguments, messageArguments, severity, startPosition, endPosition, lineNumber, columnNumber);
+			}
+			@Override
+			public CategorizedProblem createProblem(
+					final char[] originatingFileName,
+					final int problemId,
+					final String[] problemArguments,
+					final int elaborationID,
+					final String[] messageArguments,
+					final int severity,
+					final int startPosition,
+					final int endPosition,
+					final int lineNumber,
+					final int columnNumber) {
 
+				DiagnosticListener<? super JavaFileObject> diagListener = EclipseCompilerImpl.this.diagnosticListener;
+				if (diagListener != null) {
+					diagListener.report(new Diagnostic<JavaFileObject>() {
+						@Override
+						public String getCode() {
+							return Integer.toString(problemId);
+						}
+						@Override
+						public long getColumnNumber() {
+							return columnNumber;
+						}
+						@Override
+						public long getEndPosition() {
+							return endPosition;
+						}
+						@Override
+						public Kind getKind() {
+							if ((severity & ProblemSeverities.Error) != 0) {
+								return Diagnostic.Kind.ERROR;
+							}
+							if ((severity & ProblemSeverities.Optional) != 0) {
+								return Diagnostic.Kind.WARNING;
+							}
+							if ((severity & ProblemSeverities.Warning) != 0) {
+								return Diagnostic.Kind.MANDATORY_WARNING;
+							}
+							return Diagnostic.Kind.OTHER;
+						}
+						@Override
+						public long getLineNumber() {
+							return lineNumber;
+						}
+						@Override
+						public String getMessage(Locale locale) {
+							if (locale != null) {
+								setLocale(locale);
+							}
+							return getLocalizedMessage(problemId, problemArguments);
+						}
+						@Override
+						public long getPosition() {
+							return startPosition;
+						}
 						@Override
+						public JavaFileObject getSource() {
+							File f = new File(new String(originatingFileName));
+							if (f.exists()) {
+								return new EclipseFileObject(null, f.toURI(), JavaFileObject.Kind.SOURCE, null);
+							}
+							return null;
+						}
+						@Override
+						public long getStartPosition() {
+							return startPosition;
+						}
+					});
+				}
+				return super.createProblem(originatingFileName, problemId, problemArguments, elaborationID, messageArguments, severity, startPosition, endPosition, lineNumber, columnNumber);
+			}
+		};
+	}
+
+	@Override
 	protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map customDefaultOptions, CompilationProgress compilationProgress) {
 		super.initialize(outWriter, errWriter, systemExit, customDefaultOptions, compilationProgress);
-		this.javaFileObjectMap = new HashMap<CompilationUnit, JavaFileObject>();
+		this.javaFileObjectMap = new HashMap<>();
 	}
 
 	@Override
@@ -209,11 +355,11 @@ public class EclipseCompilerImpl extends Main {
 				}
 				try {
 					JavaFileObject javaFileForOutput =
-					this.fileManager.getJavaFileForOutput(
-							StandardLocation.CLASS_OUTPUT,
-							new String(filename),
-							JavaFileObject.Kind.CLASS,
-							this.javaFileObjectMap.get(unitResult.compilationUnit));
+						this.fileManager.getJavaFileForOutput(
+								StandardLocation.CLASS_OUTPUT,
+								new String(filename),
+								JavaFileObject.Kind.CLASS,
+								this.javaFileObjectMap.get(unitResult.compilationUnit));
 
 					if (generateClasspathStructure) {
 						if (currentDestinationPath != null) {
@@ -234,12 +380,11 @@ public class EclipseCompilerImpl extends Main {
 						}
 					}
 
-					OutputStream openOutputStream = javaFileForOutput.openOutputStream();
-					BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(openOutputStream);
-					bufferedOutputStream.write(classFile.header, 0, classFile.headerOffset);
-					bufferedOutputStream.write(classFile.contents, 0, classFile.contentsOffset);
-					bufferedOutputStream.flush();
-					bufferedOutputStream.close();
+					try (OutputStream openOutputStream = javaFileForOutput.openOutputStream(); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(openOutputStream)) {
+						bufferedOutputStream.write(classFile.header, 0, classFile.headerOffset);
+						bufferedOutputStream.write(classFile.contents, 0, classFile.contentsOffset);
+						bufferedOutputStream.flush();
+					}
 				} catch (IOException e) {
 					this.logger.logNoClassFileCreated(currentDestinationPath, relativeStringName, e);
 				}
@@ -262,78 +407,95 @@ public class EclipseCompilerImpl extends Main {
 			ArrayList endorsedDirClasspaths,
 			String customEncoding) {
 
-		ArrayList<FileSystem.Classpath> fileSystemClasspaths = new ArrayList<FileSystem.Classpath>();
-		EclipseFileManager javaFileManager = null;
+		ArrayList<FileSystem.Classpath> fileSystemClasspaths = new ArrayList<>();
+		EclipseFileManager eclipseJavaFileManager = null;
 		StandardJavaFileManager standardJavaFileManager = null;
+		JavaFileManager javaFileManager = null;
+		boolean havePlatformPaths = false;
+		boolean haveClassPaths = false;
 		if (this.fileManager instanceof EclipseFileManager) {
-			javaFileManager = (EclipseFileManager) this.fileManager;
+			eclipseJavaFileManager = (EclipseFileManager) this.fileManager;
 		}
 		if (this.fileManager instanceof StandardJavaFileManager) {
 			standardJavaFileManager = (StandardJavaFileManager) this.fileManager;
 		}
+		javaFileManager = this.fileManager;
 
-		if (javaFileManager != null) {
-			if ((javaFileManager.flags & EclipseFileManager.HAS_ENDORSED_DIRS) == 0
-					&& (javaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {
+		if (eclipseJavaFileManager != null) {
+			if ((eclipseJavaFileManager.flags & EclipseFileManager.HAS_ENDORSED_DIRS) == 0
+					&& (eclipseJavaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {
 				fileSystemClasspaths.addAll(this.handleEndorseddirs(null));
 			}
 		}
 		Iterable<? extends File> location = null;
 		if (standardJavaFileManager != null) {
 			location = standardJavaFileManager.getLocation(StandardLocation.PLATFORM_CLASS_PATH);
-		}
-		if (location != null) {
-			for (File file : location) {
-				Classpath classpath = FileSystem.getClasspath(
-					file.getAbsolutePath(),
-					null,
-					null);
-				if (classpath != null) {
-					fileSystemClasspaths.add(classpath);
+			if (location != null) {
+				for (File file : location) {
+					Classpath classpath = FileSystem.getClasspath(
+						file.getAbsolutePath(),
+						null,
+						null);
+					if (classpath != null) {
+						fileSystemClasspaths.add(classpath);
+						havePlatformPaths = true;
+					}
 				}
 			}
+		} else if (javaFileManager != null) {
+			Classpath classpath = new ClasspathJsr199(this.fileManager, StandardLocation.PLATFORM_CLASS_PATH);
+			fileSystemClasspaths.add(classpath);
+			havePlatformPaths = true;
 		}
-		if (javaFileManager != null) {
-			if ((javaFileManager.flags & EclipseFileManager.HAS_EXT_DIRS) == 0
-					&& (javaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {
+		if (eclipseJavaFileManager != null) {
+			if ((eclipseJavaFileManager.flags & EclipseFileManager.HAS_EXT_DIRS) == 0
+					&& (eclipseJavaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {
 				fileSystemClasspaths.addAll(this.handleExtdirs(null));
 			}
 		}
 		if (standardJavaFileManager != null) {
 			location = standardJavaFileManager.getLocation(StandardLocation.SOURCE_PATH);
-		} else {
-			location = null;
-		}
-		if (location != null) {
-			for (File file : location) {
-				Classpath classpath = FileSystem.getClasspath(
+			if (location != null) {
+				for (File file : location) {
+					Classpath classpath = FileSystem.getClasspath(
+							file.getAbsolutePath(),
+							null,
+							null);
+					if (classpath != null) {
+						fileSystemClasspaths.add(classpath);
+					}
+				}
+			}
+			location = standardJavaFileManager.getLocation(StandardLocation.CLASS_PATH);
+			if (location != null) {
+				for (File file : location) {
+					Classpath classpath = FileSystem.getClasspath(
 						file.getAbsolutePath(),
 						null,
 						null);
-				if (classpath != null) {
-					fileSystemClasspaths.add(classpath);
+					if (classpath != null) {
+						fileSystemClasspaths.add(classpath);
+						haveClassPaths = true;
+					}
 				}
 			}
-		}
-		if (standardJavaFileManager != null) {
-			location = standardJavaFileManager.getLocation(StandardLocation.CLASS_PATH);
-		} else {
-			location = null;
-		}
-		if (location != null) {
-			for (File file : location) {
-				Classpath classpath = FileSystem.getClasspath(
-					file.getAbsolutePath(),
-					null,
-					null);
-				if (classpath != null) {
-					fileSystemClasspaths.add(classpath);
-				}
+		} else if (javaFileManager != null) {
+			Classpath classpath = null;
+			if (this.fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {
+				classpath = new ClasspathJsr199(this.fileManager, StandardLocation.SOURCE_PATH);
+				fileSystemClasspaths.add(classpath);
 			}
+			classpath = new ClasspathJsr199(this.fileManager, StandardLocation.CLASS_PATH);
+			fileSystemClasspaths.add(classpath);
+			haveClassPaths = true;
 		}
 		if (this.checkedClasspaths == null) {
-			fileSystemClasspaths.addAll(this.handleBootclasspath(null, null));
-			fileSystemClasspaths.addAll(this.handleClasspath(null, null));
+			// It appears to be necessary to handleBootclasspath() for IBM JVMs
+			// in order to have visibility to java.lang.String (not present in rt.jar).
+			// The jars returned by StandardFileManager.getLocation(PLATFORM_CLASS_PATH) are
+			// not sufficient to resolve all standard classes.
+			if (!havePlatformPaths) fileSystemClasspaths.addAll(this.handleBootclasspath(null, null));
+			if (!haveClassPaths) fileSystemClasspaths.addAll(this.handleClasspath(null, null));
 		}
 		fileSystemClasspaths = FileSystem.ClasspathNormalizer.normalize(fileSystemClasspaths);
 		final int size = fileSystemClasspaths.size();
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
index 59f6a04..a5bd770 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2014 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.MissingResourceException;
@@ -33,9 +34,9 @@ import java.util.zip.ZipException;
 
 import javax.tools.FileObject;
 import javax.tools.JavaFileObject;
+import javax.tools.JavaFileObject.Kind;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.StandardLocation;
-import javax.tools.JavaFileObject.Kind;
 
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem;
@@ -67,8 +68,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	public EclipseFileManager(Locale locale, Charset charset) {
 		this.locale = locale == null ? Locale.getDefault() : locale;
 		this.charset = charset == null ? Charset.defaultCharset() : charset;
-		this.locations = new HashMap<String, Iterable<? extends File>>();
-		this.archivesCache = new HashMap<File, Archive>();
+		this.locations = new HashMap<>();
+		this.archivesCache = new HashMap<>();
 		try {
 			this.setLocation(StandardLocation.PLATFORM_CLASS_PATH, getDefaultBootclasspath());
 			Iterable<? extends File> defaultClasspath = getDefaultClasspath();
@@ -84,56 +85,16 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		}
 	}
 
-	private void addFiles(File[][] jars, ArrayList<File> files) {
-		if (jars != null) {
-			for (File[] currentJars : jars) {
-				if (currentJars != null) {
-					for (File currentJar : currentJars) {
-						if (currentJar.exists()) {
-							files.add(currentJar);
-						}
-					}
-				}
-			}
-		}
-	}
-	
-	
-	private void addFilesFrom(File javaHome, String propertyName, String defaultPath, ArrayList<File> files) {
-		String extdirsStr = System.getProperty(propertyName);
-		File[] directoriesToCheck = null;
-		if (extdirsStr == null) {
-			if (javaHome != null) {
-				directoriesToCheck = new File[] { new File(javaHome, defaultPath) };
-			}
-		} else {
-			StringTokenizer tokenizer = new StringTokenizer(extdirsStr, File.pathSeparator);
-			ArrayList<String> paths = new ArrayList<String>();
-			while (tokenizer.hasMoreTokens()) {
-				paths.add(tokenizer.nextToken());
-			}
-			if (paths.size() != 0) {
-				directoriesToCheck = new File[paths.size()];
-				for (int i = 0; i < directoriesToCheck.length; i++)  {
-					directoriesToCheck[i] = new File(paths.get(i));
-				}
-			}
-		}
-		if (directoriesToCheck != null) {
-			addFiles(Main.getLibrariesFiles(directoriesToCheck), files);
-		}
-		
-	}
-	
 	/* (non-Javadoc)
 	 * @see javax.tools.JavaFileManager#close()
 	 */
 	@Override
 	public void close() throws IOException {
-		this.locations = null;
+		if (this.locations != null) this.locations.clear();
 		for (Archive archive : this.archivesCache.values()) {
 			archive.close();
 		}
+		this.archivesCache.clear();
 	}
 	
 	private void collectAllMatchingFiles(File file, String normalizedPackageName, Set<Kind> kinds, boolean recurse, ArrayList<JavaFileObject> collector) {
@@ -166,6 +127,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			}
 		} else {
 			Archive archive = this.getArchive(file);
+			if (archive == Archive.UNKNOWN_ARCHIVE) return;
 			String key = normalizedPackageName;
 			if (!normalizedPackageName.endsWith("/")) {//$NON-NLS-1$
 				key += '/';
@@ -174,7 +136,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			if (recurse) {
 				for (String packageName : archive.allPackages()) {
 					if (packageName.startsWith(key)) {
-						ArrayList<String> types = archive.getTypes(packageName);
+						List<String> types = archive.getTypes(packageName);
 						if (types != null) {
 							for (String typeName : types) {
 								final Kind kind = getKind(getExtension(typeName));
@@ -186,12 +148,12 @@ public class EclipseFileManager implements StandardJavaFileManager {
 					}
 				}
 			} else {
-				ArrayList<String> types = archive.getTypes(key);
+				List<String> types = archive.getTypes(key);
 				if (types != null) {
 					for (String typeName : types) {
-						final Kind kind = getKind(typeName);
+						final Kind kind = getKind(getExtension(typeName));
 						if (kinds.contains(kind)) {
-							collector.add(archive.getArchiveFileObject(normalizedPackageName + typeName, this.charset));
+							collector.add(archive.getArchiveFileObject(key + typeName, this.charset));
 						}
 					}
 				}
@@ -200,7 +162,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> concatFiles(Iterable<? extends File> iterable, Iterable<? extends File> iterable2) {
-		ArrayList<File> list = new ArrayList<File>();
+		ArrayList<File> list = new ArrayList<>();
 		if (iterable2 == null) return iterable;
 		for (Iterator<? extends File> iterator = iterable.iterator(); iterator.hasNext(); ) {
 			list.add(iterator.next());
@@ -225,23 +187,21 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		// check the archive (jar/zip) cache
 		Archive archive = this.archivesCache.get(f);
 		if (archive == null) {
+			archive = Archive.UNKNOWN_ARCHIVE;
 			// create a new archive
 			if (f.exists()) {
-    			try {
-    				archive = new Archive(f);
-    			} catch (ZipException e) {
-    				// ignore
-    			} catch (IOException e) {
-    				// ignore
-    			}
-    			if (archive != null) {
-    				this.archivesCache.put(f, archive);
-    			} else {
-    				this.archivesCache.put(f, Archive.UNKNOWN_ARCHIVE);
-    			}
-			} else {
-				this.archivesCache.put(f, Archive.UNKNOWN_ARCHIVE);
+				try {
+					archive = new Archive(f);
+				} catch (ZipException e) {
+					// ignore
+				} catch (IOException e) {
+					// ignore
+				}
+				if (archive != null) {
+					this.archivesCache.put(f, archive);
+				}
 			}
+			this.archivesCache.put(f, archive);
 		}
 		return archive;
 	}
@@ -256,7 +216,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			// location is unknown
 			return null;
 		}
-		ArrayList<URL> allURLs = new ArrayList<URL>();
+		ArrayList<URL> allURLs = new ArrayList<>();
 		for (File f : files) {
 			try {
 				allURLs.add(f.toURI().toURL());
@@ -270,8 +230,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getPathsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -284,7 +244,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	Iterable<? extends File> getDefaultBootclasspath() {
-		ArrayList<File> files = new ArrayList<File>();
+		List<File> files = new ArrayList<>();
 		String javaversion = System.getProperty("java.version");//$NON-NLS-1$
 		if(javaversion.length() > 3)
 			javaversion = javaversion.substring(0, 3);
@@ -294,37 +254,15 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			return null;
 		}
 
-		/*
-		 * Handle >= JDK 1.6
-		 */
-		String javaHome = System.getProperty("java.home"); //$NON-NLS-1$
-		File javaHomeFile = null;
-		if (javaHome != null) {
-			javaHomeFile = new File(javaHome);
-			if (!javaHomeFile.exists())
-				javaHomeFile = null;
-		}
-
-		addFilesFrom(javaHomeFile, "java.endorsed.dirs", "/lib/endorsed", files);//$NON-NLS-1$//$NON-NLS-2$
-		if (javaHomeFile != null) {
-			File[] directoriesToCheck = null;
-			if (System.getProperty("os.name").startsWith("Mac")) {//$NON-NLS-1$//$NON-NLS-2$
-				directoriesToCheck = new File[] { new File(javaHomeFile, "../Classes"), //$NON-NLS-1$
-				};
-			} else {
-				directoriesToCheck = new File[] { new File(javaHomeFile, "lib") //$NON-NLS-1$
-				};
-			}
-			File[][] jars = Main.getLibrariesFiles(directoriesToCheck);
-			addFiles(jars, files);
+		for (String fileName : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
+			files.add(new File(fileName));
 		}
-		addFilesFrom(javaHomeFile, "java.ext.dirs", "/lib/ext", files);//$NON-NLS-1$//$NON-NLS-2$
 		return files;
 	}
 
 	Iterable<? extends File> getDefaultClasspath() {
 		// default classpath
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<File> files = new ArrayList<>();
 		String classProp = System.getProperty("java.class.path"); //$NON-NLS-1$
 		if ((classProp == null) || (classProp.length() == 0)) {
 			return null;
@@ -343,8 +281,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getEndorsedDirsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -357,8 +295,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	}
 
 	private Iterable<? extends File> getExtdirsFrom(String path) {
-		ArrayList<FileSystem.Classpath> paths = new ArrayList<FileSystem.Classpath>();
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<FileSystem.Classpath> paths = new ArrayList<>();
+		ArrayList<File> files = new ArrayList<>();
 		try {
 			this.processPathEntries(Main.DEFAULT_SIZE_CLASSPATH, paths, path, this.charset.name(), false, false);
 		} catch (IllegalArgumentException e) {
@@ -547,7 +485,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	 */
 	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {
-		ArrayList<JavaFileObject> javaFileArrayList = new ArrayList<JavaFileObject>();
+		ArrayList<JavaFileObject> javaFileArrayList = new ArrayList<>();
 		for (File f : files) {
 			if (f.isDirectory()) {
 				throw new IllegalArgumentException("file : " + f.getAbsolutePath() + " is a directory"); //$NON-NLS-1$ //$NON-NLS-2$
@@ -562,7 +500,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	 */
 	@Override
 	public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> names) {
-		ArrayList<File> files = new ArrayList<File>();
+		ArrayList<File> files = new ArrayList<>();
 		for (String name : names) {
 			files.add(new File(name));
 		}
@@ -601,7 +539,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		if (file.exists() && !file.isDirectory()) {
 			throw new IllegalArgumentException("file : " + file.getAbsolutePath() + " is not a directory");//$NON-NLS-1$//$NON-NLS-2$
 		}
-		ArrayList<File> list = new ArrayList<File>(1);
+		ArrayList<File> list = new ArrayList<>(1);
 		list.add(file);
 		return list;
 	}
@@ -765,7 +703,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 		if (javaFileObject == null) {
 			return null;
 		}
-		return normalized(name);
+		return name.replace('/', '.');
 	}
 
 	private boolean isArchive(File f) {
@@ -803,7 +741,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			throw new IllegalArgumentException("Unknown location : " + location);//$NON-NLS-1$
 		}
 		
-		ArrayList<JavaFileObject> collector = new ArrayList<JavaFileObject>();
+		ArrayList<JavaFileObject> collector = new ArrayList<>();
 		String normalizedPackageName = normalized(packageName);
 		for (File file : allFilesInLocations) {
 			collectAllMatchingFiles(file, normalizedPackageName, kinds, recurse, collector);
@@ -828,7 +766,7 @@ public class EclipseFileManager implements StandardJavaFileManager {
 	private Iterable<? extends File> prependFiles(Iterable<? extends File> iterable,
 			Iterable<? extends File> iterable2) {
 		if (iterable2 == null) return iterable;
-		ArrayList<File> list = new ArrayList<File>();
+		ArrayList<File> list = new ArrayList<>();
 		for (Iterator<? extends File> iterator = iterable2.iterator(); iterator.hasNext(); ) {
 			list.add(iterator.next());
 		}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileObject.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileObject.java
index d3f326e..615268e 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileObject.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileObject.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,10 @@
 
 package org.eclipse.jdt.internal.compiler.tool;
 
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -164,8 +168,7 @@ public class EclipseFileObject extends SimpleJavaFileObject {
 	 */
 	@Override
 	public InputStream openInputStream() throws IOException {
-		// TODO (olivier) should use buffered input stream
-		return new FileInputStream(this.f);
+		return new BufferedInputStream(new FileInputStream(this.f));
 	}
 
 	/**
@@ -174,7 +177,7 @@ public class EclipseFileObject extends SimpleJavaFileObject {
 	@Override
 	public OutputStream openOutputStream() throws IOException {
 		ensureParentDirectoriesExist();
-		return new FileOutputStream(this.f);
+		return new BufferedOutputStream(new FileOutputStream(this.f));
 	}
 
 	/**
@@ -182,7 +185,7 @@ public class EclipseFileObject extends SimpleJavaFileObject {
 	 */
 	@Override
 	public Reader openReader(boolean ignoreEncodingErrors) throws IOException {
-		return new FileReader(this.f);
+		return new BufferedReader(new FileReader(this.f));
 	}
 
 	/**
@@ -191,7 +194,7 @@ public class EclipseFileObject extends SimpleJavaFileObject {
 	@Override
 	public Writer openWriter() throws IOException {
 		ensureParentDirectoriesExist();
-		return new FileWriter(this.f);
+		return new BufferedWriter(new FileWriter(this.f));
 	}
 	
 	@Override
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Options.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Options.java
index 4b2f1ff..173bebe 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Options.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Options.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2014 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -24,7 +24,7 @@ public final class Options {
 	private static final Set<String> ONE_ARGUMENT_OPTIONS;
 	private static final Set<String> FILE_MANAGER_OPTIONS;
 	static {
-		ZERO_ARGUMENT_OPTIONS = new HashSet<String>();
+		ZERO_ARGUMENT_OPTIONS = new HashSet<>();
 		Options.ZERO_ARGUMENT_OPTIONS.add("-progress");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-proceedOnError");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-proceedOnError:Fatal");//$NON-NLS-1$
@@ -60,6 +60,9 @@ public final class Options {
 		Options.ZERO_ARGUMENT_OPTIONS.add("-1.7");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-7");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-7.0");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-1.8");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-8");//$NON-NLS-1$
+		Options.ZERO_ARGUMENT_OPTIONS.add("-8.0");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-proc:only");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-proc:none");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-XprintProcessorInfo");//$NON-NLS-1$
@@ -67,7 +70,7 @@ public final class Options {
 		Options.ZERO_ARGUMENT_OPTIONS.add("-parameters");//$NON-NLS-1$
 		Options.ZERO_ARGUMENT_OPTIONS.add("-genericsignature");//$NON-NLS-1$
 
-		FILE_MANAGER_OPTIONS = new HashSet<String>();
+		FILE_MANAGER_OPTIONS = new HashSet<>();
 		Options.FILE_MANAGER_OPTIONS.add("-bootclasspath");//$NON-NLS-1$
 		Options.FILE_MANAGER_OPTIONS.add("-encoding");//$NON-NLS-1$
 		Options.FILE_MANAGER_OPTIONS.add("-d");//$NON-NLS-1$
@@ -79,7 +82,7 @@ public final class Options {
 		Options.FILE_MANAGER_OPTIONS.add("-s");//$NON-NLS-1$
 		Options.FILE_MANAGER_OPTIONS.add("-processorpath");//$NON-NLS-1$
 
-		ONE_ARGUMENT_OPTIONS = new HashSet<String>();
+		ONE_ARGUMENT_OPTIONS = new HashSet<>();
 		Options.ONE_ARGUMENT_OPTIONS.addAll(Options.FILE_MANAGER_OPTIONS);
 		Options.ONE_ARGUMENT_OPTIONS.add("-log");//$NON-NLS-1$
 		Options.ONE_ARGUMENT_OPTIONS.add("-repeat");//$NON-NLS-1$
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Util.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Util.java
index 88e2343..0f1c715 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Util.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -95,7 +95,7 @@ public final class Util {
 		}
 	}
 	public static class EncodingErrorCollector {
-		ArrayList<EncodingError> encodingErrors = new ArrayList<EncodingError>();
+		ArrayList<EncodingError> encodingErrors = new ArrayList<>();
 		FileObject fileObject;
 		String encoding;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 59da8ab..65f55ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -24,6 +24,7 @@ import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.StringTokenizer;
@@ -677,7 +678,7 @@ public class Util implements SuffixConstants {
 	}
 	/**
 	 * Returns the contents of the given zip entry as a byte array.
-	 * @throws IOException if a problem occured reading the zip entry.
+	 * @throws IOException if a problem occurred reading the zip entry.
 	 */
 	public static byte[] getZipEntryByteContent(ZipEntry ze, ZipFile zip)
 		throws IOException {
@@ -1086,6 +1087,15 @@ public class Util implements SuffixConstants {
 	}
 
 	public static void collectRunningVMBootclasspath(List bootclasspaths) {
+		for (String filePath : collectFilesNames()) {
+			FileSystem.Classpath currentClasspath = FileSystem.getClasspath(filePath, null, null);
+			if (currentClasspath != null) {
+				bootclasspaths.add(currentClasspath);
+			}
+		}
+	}
+
+	public static List<String> collectFilesNames() {
 		/* no bootclasspath specified
 		 * we can try to retrieve the default librairies of the VM used to run
 		 * the batch compiler
@@ -1108,15 +1118,11 @@ public class Util implements SuffixConstants {
 				bootclasspathProperty = System.getProperty("org.apache.harmony.boot.class.path"); //$NON-NLS-1$
 			}
 		}
+		List<String> filePaths = new ArrayList<>();
 		if ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {
 			StringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);
-			String token;
 			while (tokenizer.hasMoreTokens()) {
-				token = tokenizer.nextToken();
-				FileSystem.Classpath currentClasspath = FileSystem.getClasspath(token, null, null);
-				if (currentClasspath != null) {
-					bootclasspaths.add(currentClasspath);
-				}
+				filePaths.add(tokenizer.nextToken());
 			}
 		} else {
 			// try to get all jars inside the lib folder of the java home
@@ -1139,18 +1145,14 @@ public class Util implements SuffixConstants {
 						File[] current = systemLibrariesJars[i];
 						if (current != null) {
 							for (int j = 0, max2 = current.length; j < max2; j++) {
-								FileSystem.Classpath classpath =
-									FileSystem.getClasspath(current[j].getAbsolutePath(),
-										null, false, null, null);
-								if (classpath != null) {
-									bootclasspaths.add(classpath);
-								}
+								filePaths.add(current[j].getAbsolutePath());
 							}
 						}
 					}
 				}
 			}
 		}
+		return filePaths;
 	}
 	public static int getParameterCount(char[] methodSignature) {
 		try {
commit f6eeada2960412f01a4e136f42ab7ca35fa9275b
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Mar 17 21:19:21 2015 +0530

    Bug 188796 - Updating copyright with contributor details.

3	1	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
2	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
index 24adb24..e58a375 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
@@ -6,7 +6,9 @@
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     IBM Corporation - initial API and implementation
+ *     Kenneth Olson - initial API and implementation
+ *     Dennis Hendriks - initial API and implementation
+ *     IBM Corporation - Contribution for bug 188796
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
index d21fffc..666c501 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
@@ -8,6 +8,8 @@
  * Contributors:
  *    IBM Corporation - initial API and implementation
  *    IBM Corporation - fix for 342936
+ *    Kenneth Olson - Contribution for bug 188796 - [jsr199] Using JSR199 to extend ECJ
+ *    Dennis Hendriks - Contribution for bug 188796 - [jsr199] Using JSR199 to extend ECJ
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.tool;
 
