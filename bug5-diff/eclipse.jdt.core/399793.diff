commit 85d82ef92c86e257cfcb71c0ec95b6b64432a5cb
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Sat Mar 2 21:19:31 2013 +0530

    Fixed Bug 399793 - [1.8][dom ast] Add a new node type for compiler node
    LambdaExpression

172	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
52	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
46	33	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
43	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
24	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
10	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
30	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
26	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
20	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
6	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Expression.java
309	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
23	96	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index b9f5134..c5f2ac0 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -1520,4 +1520,176 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		abinding = annotation.resolveAnnotationBinding();
 		assertEquals("@Marker1()", abinding.toString());
 	}
+
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	 * 
+	 * @throws JavaModelException
+	 */
+	public void test399793a() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter18/src/test399793/X.java",
+				true/* resolve */);
+		String contents = "package test399793;"
+				+ "interface I {\n"
+				+ "	int foo(int x);\n"
+				+ "}\n" 
+				+ "public class X {\n"
+				+ " I i =  vlambda -> {return 200;};\n"
+				+"}\n";
+		CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 1);
+		FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+		Expression expression = fragment.getInitializer();
+		assertTrue(expression instanceof LambdaExpression);
+		LambdaExpression lambdaExpression = (LambdaExpression)expression;
+		assertEquals("vlambda -> {\n  return 200;\n}\n", lambdaExpression.toString());
+		assertTrue(lambdaExpression.parameters().size() == 1);
+		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+		assertEquals("public int foo(int) ", binding.toString());
+		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
+		assertTrue(variableDeclaration instanceof VariableDeclarationFragment);
+		fragment = (VariableDeclarationFragment)variableDeclaration;
+		assertEquals("vlambda", fragment.toString());		
+		IVariableBinding variableBinding = fragment.resolveBinding();		
+		ITypeBinding typeBinding = variableBinding.getType();
+		assertNotNull("Null Binding for lambda argument", typeBinding);
+		assertEquals("binding of int expected for lambda","int",typeBinding.getName());
+	}
+
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	 * 
+	 * @throws JavaModelException
+	 */
+	public void test399793b() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter18/src/test399793/X.java",
+				true/* resolve */);
+		String contents = "package test399793;"
+				+ "interface I {\n"
+				+ "	int foo(int x);\n"
+				+ "}\n" 
+				+ "public class X {\n"
+				+ " I i =  vlambda -> 200;\n"
+				+"}\n";
+		CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 1);
+		FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+		Expression expression = fragment.getInitializer();
+		assertTrue(expression instanceof LambdaExpression);
+		LambdaExpression lambdaExpression = (LambdaExpression)expression;
+		assertEquals("vlambda -> 200", lambdaExpression.toString());
+		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+		assertEquals("public int foo(int) ", binding.toString());
+		assertTrue(lambdaExpression.parameters().size() == 1);
+		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
+		assertTrue(variableDeclaration instanceof VariableDeclarationFragment);
+		fragment = (VariableDeclarationFragment)variableDeclaration;
+		assertEquals("vlambda", fragment.toString());		
+	}
+	
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	 * 
+	 * @throws JavaModelException
+	 */
+	public void test399793c() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter18/src/test399793/X.java",
+				true/* resolve */);
+		String contents = "package test399793;"
+				+ "interface I {\n"
+				+ "	Object foo(int [] ia);\n"
+				+ "}\n" 
+				+ "public class X {\n"
+				+ " I i = (int [] ia) ->{\n"
+				+ "  	return ia.clone();"
+				+ "};\n"
+				+"}\n";
+		CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 1);
+		FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+		Expression expression = fragment.getInitializer();
+		assertTrue(expression instanceof LambdaExpression);
+		LambdaExpression lambdaExpression = (LambdaExpression)expression;
+		assertEquals("(int[] ia) -> {\n  return ia.clone();\n}\n", lambdaExpression.toString());
+		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+		assertEquals("public java.lang.Object foo(int[]) ", binding.toString());
+		assertTrue(lambdaExpression.parameters().size() == 1);
+		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
+		assertTrue(variableDeclaration instanceof SingleVariableDeclaration);
+		SingleVariableDeclaration singleVariableDeclaration = (SingleVariableDeclaration)variableDeclaration;
+		assertEquals("int[] ia", singleVariableDeclaration.toString());		
+	}
+
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	 * 
+	 * @throws JavaModelException
+	 */
+	public void test399793d() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter18/src/test399793/X.java",
+				true/* resolve */);
+		String contents = "package test399793;" +
+				"interface I {\n" +
+				"	void doit();\n" +
+				"}\n" +
+				"public class X {\n" +
+				"		I i = () -> {\n" +
+				"			System.out.println(this);\n" +
+				"			I j = () -> {\n" +
+				"				System.out.println(this);\n" +
+				"				I k = () -> {\n" +
+				"					System.out.println(this);\n" +
+				"				};\n" +
+				"			};\n" +
+				"		};\n" +
+				"	}\n"; 
+		CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 1);
+		FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+		IVariableBinding variableBinding = fragment.resolveBinding();
+		assertEquals("test399793.I i", variableBinding.toString());
+		Expression expression = fragment.getInitializer();
+		assertTrue(expression instanceof LambdaExpression);
+		LambdaExpression lambdaExpression = (LambdaExpression)expression;
+		assertEquals("() -> {\n  System.out.println(this);\n  I j=() -> {\n    System.out.println(this);\n    I k=() -> {\n      System.out.println(this);\n    }\n;\n  }\n;\n}\n", lambdaExpression.toString());
+		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+		assertEquals("public void doit() ", binding.toString());
+		assertTrue(lambdaExpression.parameters().size() == 0);
+	}
+
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	 * 
+	 * @throws JavaModelException
+	 */
+	public void test399793e() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter18/src/test399793/X.java",
+				true/* resolve */);
+		String contents = "package test399793;" +
+				"interface I {\n" +
+				"  J foo();\n" +
+				"}\n" +
+				"interface J {\n" +
+				"  int foo();\n" +
+				"}\n" +
+				"public class X {\n" +
+				"    I I = () -> () -> 10;\n" +
+				"}\n";
+			
+		CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 2);
+		FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+		Expression expression = fragment.getInitializer();
+		assertTrue(expression instanceof LambdaExpression);
+		LambdaExpression lambdaExpression = (LambdaExpression)expression;
+		assertEquals("() -> () -> 10", lambdaExpression.toString());
+		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+		assertEquals("public test399793.J foo() ", binding.toString());
+		assertTrue(lambdaExpression.parameters().size() == 0);
+	}	
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
index 9d38d6d..e5fe791 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
@@ -551,6 +551,9 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		public boolean match(InstanceofExpression node, Object other) {
 			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
 		}
+		public boolean match(LambdaExpression node, Object other) {
+			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
+		}
 	}
 
 	/**
@@ -1563,4 +1566,53 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		x1.extraDimensions().add(x2);
 		basicMatch(x1);
 	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	public void testLambdaExpressions1() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		LambdaExpression x1 = this.ast.newLambdaExpression();
+		VariableDeclarationFragment x2 = this.ast.newVariableDeclarationFragment();
+		x2.setName(this.N1);
+		x1.parameters().add(x2);
+		x1.setBody(this.ast.newBlock());
+		basicMatch(x1);
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	public void testLambdaExpressions2() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		LambdaExpression x1 = this.ast.newLambdaExpression();
+		x1.setBody(this.ast.newBlock());
+		basicMatch(x1);
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	public void testLambdaExpressions3() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		LambdaExpression x1 = this.ast.newLambdaExpression();
+		x1.setBody(this.E1);
+		basicMatch(x1);
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399793
+	public void testLambdaExpressions4() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		LambdaExpression x1 = this.ast.newLambdaExpression();
+		SingleVariableDeclaration x2 = this.ast.newSingleVariableDeclaration();
+		x2.modifiers().add(this.MOD1);
+		x2.modifiers().add(this.MOD2);
+		x2.setType(this.T1);
+		x2.setName(this.N1);
+		x1.parameters().add(x2);
+		x1.setBody(this.E1);
+		basicMatch(x1);
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index cc87f32..e3c1cb1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -350,7 +350,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 85, hi); // last known one
+		assertEquals("Wrong last known type", 86, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 2a298c2..1e45f22 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -47,6 +47,7 @@ import org.eclipse.jdt.internal.compiler.parser.Parser;
 public class LambdaExpression extends FunctionalExpression {
 	public Argument [] arguments;
 	public Statement body;
+	public boolean hasParentheses;
 	MethodScope scope;
 	protected boolean voidCompatible = true;
 	protected boolean valueCompatible = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 0002634..c0b1b82 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -7865,6 +7865,11 @@ protected void consumeLambdaExpression() {
 	this.intPtr--;  // ')' position, discard for now.
 	lexp.sourceStart = this.intStack[this.intPtr--]; // '(' position or identifier position.
 	lexp.sourceEnd = body.sourceEnd;
+	lexp.hasParentheses = (this.scanner.getSource()[lexp.sourceStart] == '(');
+	if (body instanceof Expression) {
+		Expression expression = (Expression) body;
+		expression.statementEnd = body.sourceEnd;
+	}
 	pushOnExpressionStack(lexp);
 	if (!this.parsingJava8Plus) {
 		problemReporter().lambdaExpressionsNotBelow18(lexp);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 95b90ec..4dcc53c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -23,7 +23,6 @@ import java.util.Map;
 import java.util.StringTokenizer;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaProject;
@@ -1116,25 +1115,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented annotatable extra dimension node
-	 * (Supported only in JLS8 level).
-	 *
-	 * @return a new unparented annotatable extra dimension node
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 * @exception UnsupportedOperationException if this operation is used
-	 *            in a JLS2, JLS3 or JLS4 AST
-	 * @since 3.9
-	 */
-	public ExtraDimension newExtraDimension() {
-		ExtraDimension result = new ExtraDimension(this);
-		return result;
-	}
-
-	/**
 	 * Creates and returns a new unparented array type node with the given
 	 * element type and number of (additional) dimensions.
 	 * <p>
@@ -1355,19 +1335,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates a new unparented union type node owned by this AST.
-	 * By default, the union type has no types.
-	 *
-	 * @return a new unparented do statement node
-	 * @exception UnsupportedOperationException if this operation is used in
-	 * a JLS2 or JLS3 AST
-	 * @since 3.7.1
-	 */
-	public UnionType newUnionType() {
-		return new UnionType(this);
-	}
-
-	/**
 	 * Creates a new unparented do statement node owned by this AST.
 	 * By default, the expression is unspecified (but legal), and
 	 * the body statement is an empty block.
@@ -1460,6 +1427,25 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented annotatable extra dimension node
+	 * (Supported only in JLS8 level).
+	 *
+	 * @return a new unparented annotatable extra dimension node
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 * @exception UnsupportedOperationException if this operation is used
+	 *            in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	public ExtraDimension newExtraDimension() {
+		ExtraDimension result = new ExtraDimension(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented field access expression node
 	 * owned by this AST. By default, the expression and field are both
 	 * unspecified, but legal, names.
@@ -1525,6 +1511,20 @@ public final class AST {
 	}
 
 	/**
+	 * Creates an unparented lambda expression node owned by this AST.
+	 * By default, the new lambda expression contains an empty argument
+	 * list and the body is an empty block.
+	 * 
+	 * @return a new unparented lambda expression node
+	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	public LambdaExpression newLambdaExpression() {
+		LambdaExpression result = new LambdaExpression(this);
+		return result;
+	}
+
+	/**
 	 * Creates an unparented import declaration node owned by this AST.
 	 * The import declaration initially contains a single-type import
 	 * of a type with an unspecified name.
@@ -2399,6 +2399,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates a new unparented union type node owned by this AST.
+	 * By default, the union type has no types.
+	 *
+	 * @return a new unparented UnionType node
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS2 or JLS3 AST
+	 * @since 3.7.1
+	 */
+	public UnionType newUnionType() {
+		return new UnionType(this);
+	}
+
+	/**
 	 * Creates a new unparented local variable declaration expression node
 	 * owned by this AST, for the given variable declaration fragment. By
 	 * default, there are no modifiers and the base type is unspecified
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 335193d..9648bbd 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -1720,6 +1720,9 @@ class ASTConverter {
 		if (expression instanceof org.eclipse.jdt.internal.compiler.ast.TypeReference) {
 			return convert((org.eclipse.jdt.internal.compiler.ast.TypeReference) expression);
 		}
+		if (expression instanceof org.eclipse.jdt.internal.compiler.ast.LambdaExpression) {
+			return convert((org.eclipse.jdt.internal.compiler.ast.LambdaExpression) expression);
+		}
 		return null;
 	}
 
@@ -2137,6 +2140,46 @@ class ASTConverter {
 		return expr;
 	}
 
+	public LambdaExpression convert(org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambda) {
+		final LambdaExpression	lambdaExpression = new LambdaExpression(this.ast);
+		if (this.resolveBindings) {
+			recordNodes(lambdaExpression, lambda);
+		}
+		org.eclipse.jdt.internal.compiler.ast.Argument[] arguments = lambda.arguments;
+		if (arguments != null) {
+			int argumentsLength = arguments.length;
+			for (int i = 0; i < argumentsLength; i++) {
+				org.eclipse.jdt.internal.compiler.ast.Argument argument = arguments[i];
+				if (argument.type == null) {
+					VariableDeclarationFragment variableDeclarationFragment = new VariableDeclarationFragment(this.ast);
+					SimpleName simpleName = new SimpleName(this.ast);
+					simpleName.internalSetIdentifier(new String(argument.name));
+					int start = argument.sourceStart;
+					int end = argument.sourceEnd;
+					simpleName.setSourceRange(start, end - start + 1);
+					if (this.resolveBindings) {
+						recordNodes(simpleName, argument);
+						recordNodes(variableDeclarationFragment, argument);
+					}
+					variableDeclarationFragment.setName(simpleName);
+					lambdaExpression.parameters().add(variableDeclarationFragment);					
+				} else {
+					SingleVariableDeclaration singleVariableDeclaration = convert(argument);
+					lambdaExpression.parameters().add(singleVariableDeclaration);					
+				}
+			}
+		}
+		if (lambda.body instanceof org.eclipse.jdt.internal.compiler.ast.Expression) {
+			lambdaExpression.setBody(convert((org.eclipse.jdt.internal.compiler.ast.Expression) lambda.body));
+		} else {
+			lambdaExpression.setBody(convert((org.eclipse.jdt.internal.compiler.ast.Block) lambda.body));
+		}
+		int sourceStart = lambda.sourceStart;
+		lambdaExpression.setSourceRange(sourceStart, lambda.sourceEnd - sourceStart + 1);
+		lambdaExpression.setParentheses(lambda.hasParentheses);
+		return lambdaExpression;
+	}
+
 	public MarkerAnnotation convert(org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation annotation) {
 		final MarkerAnnotation markerAnnotation = new MarkerAnnotation(this.ast);
 		setTypeNameForAnnotation(annotation, markerAnnotation);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 06ba23f..a09ae34 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -957,6 +957,30 @@ public class ASTMatcher {
 	 * other object is a node of the same type with structurally isomorphic
 	 * child subtrees. Subclasses may override this method as needed.
 	 * </p>
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
+	 * @since 3.9
+	 */
+	public boolean match(LambdaExpression node, Object other) {
+		if (!(other instanceof LambdaExpression)) {
+			return false;
+		}
+		LambdaExpression o = (LambdaExpression) other;
+		return	(node.hasParentheses() == o.hasParentheses())
+				&& safeSubtreeListMatch(node.parameters(), o.parameters())
+				&& safeSubtreeMatch(node.getBody(), o.getBody());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
 	 *
 	 * @param node the node
 	 * @param other the other object, or <code>null</code>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 7b80391..f7dc90c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -843,6 +843,14 @@ public abstract class ASTNode {
 	public static final int EXTRA_DIMENSION = 85;
 
 	/**
+	 * Node type constant indicating a node of type
+	 * <code>LambdaExpression</code>.
+	 * @see LambdaExpression
+	 * @since 3.9
+	 */
+	public static final int LAMBDA_EXPRESSION = 86;
+
+	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
@@ -932,6 +940,8 @@ public abstract class ASTNode {
 				return Javadoc.class;
 			case LABELED_STATEMENT :
 				return LabeledStatement.class;
+			case LAMBDA_EXPRESSION :
+				return LambdaExpression.class;
 			case LINE_COMMENT :
 				return LineComment.class;
 			case MARKER_ANNOTATION :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index b2c0834..3da7113 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -706,6 +706,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.9
+	 */
+	public boolean visit(LambdaExpression node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 */
 	public boolean visit(IfStatement node) {
 		return true;
@@ -1991,6 +2008,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.9
+	 */
+	public void endVisit(LambdaExpression node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(IfStatement node) {
 		// default implementation: do nothing
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
index d22cb6b..71274a3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -577,6 +581,27 @@ class BindingResolver {
 	}
 
 	/**
+	 * Resolves the given Lambda Expression and returns the binding for it.
+	 * <p>
+	 * The implementation of <code>LambdaExpression.resolveMethodBinding</code>
+	 * forwards to this method. How the method resolves is often a function of
+	 * the context in which the method declaration node is embedded as well as
+	 * the method declaration subtree itself.
+	 * </p>
+	 * <p>
+	 * The default implementation of this method returns <code>null</code>.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param lambda LambdaExpression of interest
+	 * @return the binding for the given lambda expression, or
+	 *    <code>null</code> if no binding is available
+	 */
+	IMethodBinding resolveMethod(LambdaExpression lambda) {
+		return null;
+	}
+
+	/**
 	 * Resolves the given method invocation and returns the binding for it.
 	 * <p>
 	 * The implementation of <code>MethodInvocation.resolveMethodBinding</code>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 055cd85..69c393d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -894,6 +894,26 @@ class DefaultBindingResolver extends BindingResolver {
 	/*
 	 * Method declared on BindingResolver.
 	 */
+	synchronized IMethodBinding resolveMethod(LambdaExpression lambda) {
+		Object oldNode = this.newAstToOldAst.get(lambda);
+		if (oldNode instanceof org.eclipse.jdt.internal.compiler.ast.LambdaExpression) {
+			org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression = (org.eclipse.jdt.internal.compiler.ast.LambdaExpression) oldNode;
+			IMethodBinding methodBinding = getMethodBinding(lambdaExpression.binding);
+			if (methodBinding == null) {
+				return null;
+			}
+			this.bindingsToAstNodes.put(methodBinding, lambda);
+			String key = methodBinding.getKey();
+			if (key != null) {
+				this.bindingTables.bindingKeysToBindings.put(key, methodBinding);
+			}
+			return methodBinding;
+		}
+		return null;
+	}
+/*
+	 * Method declared on BindingResolver.
+	 */
 	synchronized IMethodBinding resolveMethod(MethodInvocation method) {
 		Object oldNode = this.newAstToOldAst.get(method);
 		if (oldNode instanceof MessageSend) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Expression.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Expression.java
index 2003d9a..6fd76fa 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Expression.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Expression.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -30,6 +34,7 @@ package org.eclipse.jdt.core.dom;
  *    {@link FieldAccess},
  *    {@link InfixExpression},
  *    {@link InstanceofExpression},
+ *    {@link LambdaExpression},
  *    {@link MethodInvocation},
  *    {@link Name},
  *    {@link NullLiteral},
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
new file mode 100644
index 0000000..d45d8e2
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
@@ -0,0 +1,309 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Lambda expression AST node type.
+ * <pre>
+ * LambdaExpression:
+ *    Identifier <b>-></b> Body
+ *    <b>(</b> [ Identifier { <b>,</b> Identifier } ] <b>)</b> <b>-></b> Body
+ *    <b>(</b> [ FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> <b>-></b> Body
+ * </pre>
+ * 
+ *<p> 
+ * First two forms use {@link VariableDeclarationFragment} while the third form
+ * uses {@link SingleVariableDeclaration}.</p>
+ *<p>Body can be either a {@link Block} or an {@link Expression}.</p>
+ *
+ * @since 3.9 
+ * @noinstantiate This class is not intended to be instantiated by clients 
+ */
+
+public class LambdaExpression extends Expression {
+
+	/**
+	 * The "parentheses" structural property of this node type (child type: {@link Boolean}). 
+	 */
+	public static final SimplePropertyDescriptor PARENTHESES_PROPERTY =
+		new SimplePropertyDescriptor(LambdaExpression.class, "parentheses", boolean.class, MANDATORY); //$NON-NLS-1$
+
+	/**
+	 * The "parameters" structural property of this node type (child type: {@link VariableDeclaration}).
+	 */
+	public static final ChildListPropertyDescriptor PARAMETERS_PROPERTY =
+		new ChildListPropertyDescriptor(LambdaExpression.class, "parameters", VariableDeclaration.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	
+	/**
+	 * The "body" structural property of this node type (child type: {@link ASTNode}) : can
+	 *  be either a {@link Block} or an {@link Expression}.
+	 */
+	public static final ChildPropertyDescriptor BODY_PROPERTY =
+		new ChildPropertyDescriptor(LambdaExpression.class, "body", ASTNode.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_8_0;
+	
+	static {
+		List propertyList = new ArrayList(4);
+		createPropertyList(LambdaExpression.class, propertyList);
+		addProperty(PARENTHESES_PROPERTY, propertyList);
+		addProperty(PARAMETERS_PROPERTY, propertyList);
+		addProperty(BODY_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
+	}
+	
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the AST.JLS* constants
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_8_0;
+	}
+
+	/**
+	 * Indicates the presence or absence of parentheses.
+	 * defaults to true. 
+	 */
+	private boolean hasParentheses = true;
+
+	/**
+	 * The parameter declarations
+	 * (element type: {@link VariableDeclaration}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList parameters =
+		new ASTNode.NodeList(PARAMETERS_PROPERTY);
+
+	/**
+	 * The method body.
+	 * The method body; lazily initialized, defaults to an empty Block.
+	 */
+	private ASTNode body = null;
+
+	/**
+	 * Creates a new AST node for a LambdaExpression declaration owned
+	 * by the given AST.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	LambdaExpression(AST ast) {
+		super(ast);
+		unsupportedIn2_3_4();
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final boolean internalGetSetBooleanProperty(SimplePropertyDescriptor property, boolean get, boolean value) {
+		if (property == PARENTHESES_PROPERTY) {
+			if (get) {
+				return hasParentheses();
+			} else {
+				setParentheses(value);
+				return false;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetBooleanProperty(property, get, value);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == PARAMETERS_PROPERTY) {
+			return parameters();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+	
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == BODY_PROPERTY) {
+			if (get) {
+				return getBody();
+			} else {
+				setBody( child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int getNodeType0() {
+		return LAMBDA_EXPRESSION;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	ASTNode clone0(AST target) {
+		LambdaExpression result = new LambdaExpression(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setParentheses(hasParentheses());
+		result.parameters().addAll(ASTNode.copySubtrees(target, parameters()));
+		result.setBody(ASTNode.copySubtree(target, getBody()));
+		return result;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			// visit children in normal left to right reading order
+			acceptChildren(visitor, this.parameters);
+			acceptChild(visitor, getBody());
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * @return <code>true</code> if this lambda expression has parentheses around
+	 * its parameters and <code>false</code> otherwise
+	 */
+	public boolean hasParentheses() {
+		return this.hasParentheses;
+	}
+
+	/**
+	 * Sets whether this lambda expression should have parentheses around its parameters or not.
+	 *
+	 * @param hasParentheses <code>true</code> if this lambda expression should have parentheses around its parameters
+	 *  and <code>false</code> otherwise. Note: Illegal value settings are silently ignored.
+	 */
+	public void setParentheses(boolean hasParentheses) {
+		preValueChange(PARENTHESES_PROPERTY);
+		this.hasParentheses = hasParentheses;
+		postValueChange(PARENTHESES_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of formal parameters of this lambda expression.
+	 *
+	 * @return the live list of formal parameters of this lambda expression
+	 *    (element type: {@link VariableDeclaration} 
+	 */
+	public List parameters() {
+		return this.parameters;
+	}
+
+	/**
+	 * Returns the body of this lambda expression.
+	 * <p>
+	 * defaults to an empty block if body is null.
+	 * </p>
+	 * @return the lambda expression body which can be either a {@link Block} or a {@link Expression}
+	 */
+	public ASTNode getBody() {
+		if (this.body == null) {
+			this.body = new Block(this.ast);
+		}
+		return this.body;
+	}
+
+	/**
+	 * Sets the body of this lambda expression.
+	 *
+	 * @param body a block node or an expression node
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * <li>a cycle in would be created</li>
+	 * <li> body is neither an {@link Expression} nor a {@link Block} </li>
+	 * </ul>
+	 */
+	public void setBody(ASTNode body) {
+		if (!(body instanceof Expression || body instanceof Block)) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.body;
+		preReplaceChild(oldChild, body, BODY_PROPERTY);
+		this.body = body;
+		postReplaceChild(oldChild, body, BODY_PROPERTY);
+	}
+
+	/**
+	 * Resolves and returns the binding for the lambda expression
+	 * <p>
+	 * Note that bindings are generally unavailable unless requested when the
+	 * AST is being built.
+	 * </p>
+	 *
+	 * @return the binding, or <code>null</code> if the binding cannot be
+	 *    resolved
+	 */
+	public IMethodBinding resolveMethodBinding() {
+		return this.ast.getBindingResolver().resolveMethod(this);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int memSize() {
+		return BASE_NODE_SIZE + 3 * 4;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int treeSize() {
+		return
+			memSize()
+			+ (this.parameters == null ? 0 : this.parameters.listSize())
+			+ (this.body == null ? 0 : getBody().treeSize());
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 0905d6a..aaaa96e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -17,102 +17,7 @@ package org.eclipse.jdt.internal.core.dom;
 import java.util.Iterator;
 import java.util.List;
 
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.ASTNode;
-import org.eclipse.jdt.core.dom.ASTVisitor;
-import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
-import org.eclipse.jdt.core.dom.AnnotatableType;
-import org.eclipse.jdt.core.dom.Annotation;
-import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
-import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
-import org.eclipse.jdt.core.dom.ArrayAccess;
-import org.eclipse.jdt.core.dom.ArrayCreation;
-import org.eclipse.jdt.core.dom.ArrayInitializer;
-import org.eclipse.jdt.core.dom.ArrayType;
-import org.eclipse.jdt.core.dom.AssertStatement;
-import org.eclipse.jdt.core.dom.Assignment;
-import org.eclipse.jdt.core.dom.Block;
-import org.eclipse.jdt.core.dom.BlockComment;
-import org.eclipse.jdt.core.dom.BodyDeclaration;
-import org.eclipse.jdt.core.dom.BooleanLiteral;
-import org.eclipse.jdt.core.dom.BreakStatement;
-import org.eclipse.jdt.core.dom.CastExpression;
-import org.eclipse.jdt.core.dom.CatchClause;
-import org.eclipse.jdt.core.dom.CharacterLiteral;
-import org.eclipse.jdt.core.dom.ClassInstanceCreation;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.ConditionalExpression;
-import org.eclipse.jdt.core.dom.ConstructorInvocation;
-import org.eclipse.jdt.core.dom.ContinueStatement;
-import org.eclipse.jdt.core.dom.ExtraDimension;
-import org.eclipse.jdt.core.dom.UnionType;
-import org.eclipse.jdt.core.dom.DoStatement;
-import org.eclipse.jdt.core.dom.EmptyStatement;
-import org.eclipse.jdt.core.dom.EnhancedForStatement;
-import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
-import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.Expression;
-import org.eclipse.jdt.core.dom.ExpressionStatement;
-import org.eclipse.jdt.core.dom.FieldAccess;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.ForStatement;
-import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.ImportDeclaration;
-import org.eclipse.jdt.core.dom.InfixExpression;
-import org.eclipse.jdt.core.dom.Initializer;
-import org.eclipse.jdt.core.dom.InstanceofExpression;
-import org.eclipse.jdt.core.dom.Javadoc;
-import org.eclipse.jdt.core.dom.LabeledStatement;
-import org.eclipse.jdt.core.dom.LineComment;
-import org.eclipse.jdt.core.dom.MarkerAnnotation;
-import org.eclipse.jdt.core.dom.MemberRef;
-import org.eclipse.jdt.core.dom.MemberValuePair;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.MethodInvocation;
-import org.eclipse.jdt.core.dom.MethodRef;
-import org.eclipse.jdt.core.dom.MethodRefParameter;
-import org.eclipse.jdt.core.dom.Modifier;
-import org.eclipse.jdt.core.dom.Name;
-import org.eclipse.jdt.core.dom.NormalAnnotation;
-import org.eclipse.jdt.core.dom.NullLiteral;
-import org.eclipse.jdt.core.dom.NumberLiteral;
-import org.eclipse.jdt.core.dom.PackageDeclaration;
-import org.eclipse.jdt.core.dom.ParameterizedType;
-import org.eclipse.jdt.core.dom.ParenthesizedExpression;
-import org.eclipse.jdt.core.dom.PostfixExpression;
-import org.eclipse.jdt.core.dom.PrefixExpression;
-import org.eclipse.jdt.core.dom.PrimitiveType;
-import org.eclipse.jdt.core.dom.QualifiedName;
-import org.eclipse.jdt.core.dom.QualifiedType;
-import org.eclipse.jdt.core.dom.ReturnStatement;
-import org.eclipse.jdt.core.dom.SimpleName;
-import org.eclipse.jdt.core.dom.SimpleType;
-import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
-import org.eclipse.jdt.core.dom.Statement;
-import org.eclipse.jdt.core.dom.StringLiteral;
-import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
-import org.eclipse.jdt.core.dom.SuperFieldAccess;
-import org.eclipse.jdt.core.dom.SuperMethodInvocation;
-import org.eclipse.jdt.core.dom.SwitchCase;
-import org.eclipse.jdt.core.dom.SwitchStatement;
-import org.eclipse.jdt.core.dom.SynchronizedStatement;
-import org.eclipse.jdt.core.dom.TagElement;
-import org.eclipse.jdt.core.dom.TextElement;
-import org.eclipse.jdt.core.dom.ThisExpression;
-import org.eclipse.jdt.core.dom.ThrowStatement;
-import org.eclipse.jdt.core.dom.TryStatement;
-import org.eclipse.jdt.core.dom.Type;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
-import org.eclipse.jdt.core.dom.TypeLiteral;
-import org.eclipse.jdt.core.dom.TypeParameter;
-import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
-import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
-import org.eclipse.jdt.core.dom.WhileStatement;
-import org.eclipse.jdt.core.dom.WildcardType;
+import org.eclipse.jdt.core.dom.*;
 
 /**
  * Internal AST visitor for serializing an AST in a quick and dirty fashion.
@@ -831,6 +736,28 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(LambdaExpression)
+	 */
+	public boolean visit(LambdaExpression node) {
+		boolean hasParentheses = node.hasParentheses();
+		if (hasParentheses)
+			this.buffer.append('(');
+		Iterator it = node.parameters().iterator();
+		boolean hasNext = it.hasNext();
+		while (hasNext) {
+			VariableDeclaration  variableDeclaration = (VariableDeclaration) it.next();
+			variableDeclaration.accept(this);
+			if ((hasNext = it.hasNext()) == true)
+				this.buffer.append(',');
+		}
+		if (hasParentheses) 
+			this.buffer.append(')');	
+		this.buffer.append(" -> "); //$NON-NLS-1$
+		node.getBody().accept(this);
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(IfStatement)
 	 */
 	public boolean visit(IfStatement node) {
commit f041a95e804fa0b26cd4f55b03c8572e9e742dad
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Mar 4 16:30:23 2013 +0100

    Bug 399793 - [1.8][dom ast] Add a new node type for compiler node
    LambdaExpression

14	14	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
25	24	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
26	26	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
38	18	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
21	22	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 4dcc53c..8f3e32c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1511,20 +1511,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates an unparented lambda expression node owned by this AST.
-	 * By default, the new lambda expression contains an empty argument
-	 * list and the body is an empty block.
-	 * 
-	 * @return a new unparented lambda expression node
-	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
-	 * @since 3.9
-	 */
-	public LambdaExpression newLambdaExpression() {
-		LambdaExpression result = new LambdaExpression(this);
-		return result;
-	}
-
-	/**
 	 * Creates an unparented import declaration node owned by this AST.
 	 * The import declaration initially contains a single-type import
 	 * of a type with an unspecified name.
@@ -1597,6 +1583,20 @@ public final class AST {
 	}
 
 	/**
+	 * Creates an unparented lambda expression node owned by this AST.
+	 * By default, the new lambda expression has parentheses enabled, contains an empty argument
+	 * list, and the body is an empty block.
+	 * 
+	 * @return a new unparented lambda expression node
+	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	public LambdaExpression newLambdaExpression() {
+		LambdaExpression result = new LambdaExpression(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new line comment placeholder node.
 	 * <p>
 	 * Note that this node type is used to recording the source
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index a09ae34..fa3b6f1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -957,30 +957,6 @@ public class ASTMatcher {
 	 * other object is a node of the same type with structurally isomorphic
 	 * child subtrees. Subclasses may override this method as needed.
 	 * </p>
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
-	 * @since 3.9
-	 */
-	public boolean match(LambdaExpression node, Object other) {
-		if (!(other instanceof LambdaExpression)) {
-			return false;
-		}
-		LambdaExpression o = (LambdaExpression) other;
-		return	(node.hasParentheses() == o.hasParentheses())
-				&& safeSubtreeListMatch(node.parameters(), o.parameters())
-				&& safeSubtreeMatch(node.getBody(), o.getBody());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
 	 *
 	 * @param node the node
 	 * @param other the other object, or <code>null</code>
@@ -1201,6 +1177,31 @@ public class ASTMatcher {
 	 * Returns whether the given node and the other object match.
 	 * <p>
 	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 * 
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
+	 * @since 3.9
+	 */
+	public boolean match(LambdaExpression node, Object other) {
+		if (!(other instanceof LambdaExpression)) {
+			return false;
+		}
+		LambdaExpression o = (LambdaExpression) other;
+		return	(node.hasParentheses() == o.hasParentheses())
+				&& safeSubtreeListMatch(node.parameters(), o.parameters())
+				&& safeSubtreeMatch(node.getBody(), o.getBody());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
 	 * other object is a node of the same type. Subclasses may override
 	 * this method as needed.
 	 * </p>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 3da7113..442c2d2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -706,23 +706,6 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.9
-	 */
-	public boolean visit(LambdaExpression node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
-	 * Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
 	 */
 	public boolean visit(IfStatement node) {
 		return true;
@@ -837,6 +820,23 @@ public abstract class ASTVisitor {
 	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.9
+	 */
+	public boolean visit(LambdaExpression node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
 	 * <p>Note: {@link LineComment} and {@link BlockComment} nodes are
 	 * not considered part of main structure of the AST. This method will
 	 * only be called if a client goes out of their way to visit this
@@ -2008,9 +2008,8 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.9
 	 */
-	public void endVisit(LambdaExpression node) {
+	public void endVisit(IfStatement node) {
 		// default implementation: do nothing
 	}
 
@@ -2022,7 +2021,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(IfStatement node) {
+	public void endVisit(ImportDeclaration node) {
 		// default implementation: do nothing
 	}
 
@@ -2034,7 +2033,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(ImportDeclaration node) {
+	public void endVisit(InfixExpression node) {
 		// default implementation: do nothing
 	}
 
@@ -2046,7 +2045,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(InfixExpression node) {
+	public void endVisit(InstanceofExpression node) {
 		// default implementation: do nothing
 	}
 
@@ -2058,7 +2057,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(InstanceofExpression node) {
+	public void endVisit(Initializer node) {
 		// default implementation: do nothing
 	}
 
@@ -2070,7 +2069,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(Initializer node) {
+	public void endVisit(Javadoc node) {
 		// default implementation: do nothing
 	}
 
@@ -2082,7 +2081,7 @@ public abstract class ASTVisitor {
 	 *
 	 * @param node the node to visit
 	 */
-	public void endVisit(Javadoc node) {
+	public void endVisit(LabeledStatement node) {
 		// default implementation: do nothing
 	}
 
@@ -2093,8 +2092,9 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.9
 	 */
-	public void endVisit(LabeledStatement node) {
+	public void endVisit(LambdaExpression node) {
 		// default implementation: do nothing
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
index ee51cac..9c0dcbd 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/LambdaExpression.java
@@ -27,31 +27,38 @@ import java.util.List;
  * </pre>
  * 
  *<p> 
- * First two forms use {@link VariableDeclarationFragment} while the third form
- * uses {@link SingleVariableDeclaration}.</p>
- *<p>Body can be either a {@link Block} or an {@link Expression}.</p>
+ * The first two forms use {@link VariableDeclarationFragment} for the parameter or parameters,
+ * while the third form uses {@link SingleVariableDeclaration}.</p>
+ *<p>The Body can be either a {@link Block} or an {@link Expression}.</p>
  *
  * @since 3.9 
  * @noinstantiate This class is not intended to be instantiated by clients 
  */
-
 public class LambdaExpression extends Expression {
 
 	/**
-	 * The "parentheses" structural property of this node type (child type: {@link Boolean}). 
+	 * The "parentheses" structural property of this node type (type: {@link Boolean}).
+	 * <p>
+	 * Note that parentheses are required unless {@link #parameters()} contains
+	 * just a single {@link VariableDeclarationFragment}.
+	 * ASTRewrite may ignore this property if necessary.
+	 * </p>
 	 */
 	public static final SimplePropertyDescriptor PARENTHESES_PROPERTY =
 		new SimplePropertyDescriptor(LambdaExpression.class, "parentheses", boolean.class, MANDATORY); //$NON-NLS-1$
 
 	/**
-	 * The "parameters" structural property of this node type (child type: {@link VariableDeclaration}).
+	 * The "parameters" structural property of this node type (element type: {@link VariableDeclaration}).
+	 * <p>
+	 * Note that all elements must be of the same type, either all {@link SingleVariableDeclaration} or all {@link VariableDeclarationFragment}.
+	 * </p>
 	 */
 	public static final ChildListPropertyDescriptor PARAMETERS_PROPERTY =
-		new ChildListPropertyDescriptor(LambdaExpression.class, "parameters", VariableDeclaration.class, NO_CYCLE_RISK); //$NON-NLS-1$
+		new ChildListPropertyDescriptor(LambdaExpression.class, "parameters", VariableDeclaration.class, CYCLE_RISK); //$NON-NLS-1$
 	
 	/**
-	 * The "body" structural property of this node type (child type: {@link ASTNode}) : can
-	 *  be either a {@link Block} or an {@link Expression}.
+	 * The "body" structural property of this node type (child type: {@link ASTNode},
+	 * must be either a {@link Block} or an {@link Expression}).
 	 */
 	public static final ChildPropertyDescriptor BODY_PROPERTY =
 		new ChildPropertyDescriptor(LambdaExpression.class, "body", ASTNode.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
@@ -85,8 +92,8 @@ public class LambdaExpression extends Expression {
 	}
 
 	/**
-	 * Indicates the presence or absence of parentheses.
-	 * defaults to true. 
+	 * Indicates whether parentheses are present or not.
+	 * Defaults to <code>true</code>. 
 	 */
 	private boolean hasParentheses = true;
 
@@ -211,6 +218,13 @@ public class LambdaExpression extends Expression {
 	}
 
 	/**
+	 * Returns whether parentheses around the parameters are present or not.
+	 * <p>
+	 * Note that parentheses are required unless {@link #parameters()} contains
+	 * just a single {@link VariableDeclarationFragment}.
+	 * ASTRewrite may ignore this property if necessary.
+	 * </p>
+	 * 
 	 * @return <code>true</code> if this lambda expression has parentheses around
 	 * its parameters and <code>false</code> otherwise
 	 */
@@ -220,9 +234,14 @@ public class LambdaExpression extends Expression {
 
 	/**
 	 * Sets whether this lambda expression should have parentheses around its parameters or not.
+	 * <p>
+	 * Note that parentheses are required unless {@link #parameters()} contains
+	 * just a single {@link VariableDeclarationFragment}.
+	 * ASTRewrite may ignore this property if necessary.
+	 * </p>
 	 *
 	 * @param hasParentheses <code>true</code> if this lambda expression should have parentheses around its parameters
-	 *  and <code>false</code> otherwise. Note: Illegal value settings are silently ignored.
+	 *  and <code>false</code> otherwise
 	 */
 	public void setParentheses(boolean hasParentheses) {
 		preValueChange(PARENTHESES_PROPERTY);
@@ -232,6 +251,9 @@ public class LambdaExpression extends Expression {
 
 	/**
 	 * Returns the live ordered list of formal parameters of this lambda expression.
+	 * <p>
+	 * Note that all elements must be of the same type, either all {@link SingleVariableDeclaration} or all {@link VariableDeclarationFragment}.
+	 * </p>
 	 *
 	 * @return the live list of formal parameters of this lambda expression
 	 *    (element type: {@link VariableDeclaration} 
@@ -242,10 +264,8 @@ public class LambdaExpression extends Expression {
 
 	/**
 	 * Returns the body of this lambda expression.
-	 * <p>
-	 * defaults to an empty block if body is null.
-	 * </p>
-	 * @return the lambda expression body which can be either a {@link Block} or a {@link Expression}
+	 * 
+	 * @return the lambda expression body, which can be either a {@link Block} or an {@link Expression}
 	 */
 	public ASTNode getBody() {
 		if (this.body == null) {
@@ -270,7 +290,7 @@ public class LambdaExpression extends Expression {
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * <li>a cycle in would be created</li>
-	 * <li> body is neither an {@link Expression} nor a {@link Block} </li>
+	 * <li>body is neither a {@link Block} nor an {@link Expression}</li>
 	 * </ul>
 	 */
 	public void setBody(ASTNode body) {
@@ -310,7 +330,7 @@ public class LambdaExpression extends Expression {
 	int treeSize() {
 		return
 			memSize()
-			+ (this.parameters == null ? 0 : this.parameters.listSize())
+			+ this.parameters.listSize()
 			+ (this.body == null ? 0 : getBody().treeSize());
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index aaaa96e..dcb8932 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -736,28 +736,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(LambdaExpression)
-	 */
-	public boolean visit(LambdaExpression node) {
-		boolean hasParentheses = node.hasParentheses();
-		if (hasParentheses)
-			this.buffer.append('(');
-		Iterator it = node.parameters().iterator();
-		boolean hasNext = it.hasNext();
-		while (hasNext) {
-			VariableDeclaration  variableDeclaration = (VariableDeclaration) it.next();
-			variableDeclaration.accept(this);
-			if ((hasNext = it.hasNext()) == true)
-				this.buffer.append(',');
-		}
-		if (hasParentheses) 
-			this.buffer.append(')');	
-		this.buffer.append(" -> "); //$NON-NLS-1$
-		node.getBody().accept(this);
-		return false;
-	}
-
-	/*
 	 * @see ASTVisitor#visit(IfStatement)
 	 */
 	public boolean visit(IfStatement node) {
@@ -866,6 +844,27 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(LambdaExpression)
+	 */
+	public boolean visit(LambdaExpression node) {
+		boolean hasParentheses = node.hasParentheses();
+		if (hasParentheses)
+			this.buffer.append('(');
+		for (Iterator it = node.parameters().iterator(); it.hasNext(); ) {
+			VariableDeclaration v = (VariableDeclaration) it.next();
+			v.accept(this);
+			if (it.hasNext()) {
+				this.buffer.append(",");//$NON-NLS-1$
+			}
+		}
+		if (hasParentheses)
+			this.buffer.append(')');
+		this.buffer.append(" -> "); //$NON-NLS-1$
+		node.getBody().accept(this);
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(LineComment)
 	 * @since 3.0
 	 */
