commit dc5ee42cb3e5694c60c3a1f62c20766cb3cb2274
Author: David Audel <daudel>
Date:   Fri Jan 25 11:59:26 2008 +0000

    HEAD - bug 130778

1010	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
23	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
349	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest_1_5.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
1	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTest.java
1000	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
28	10	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
1	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
62	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
191	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredAnnotation.java
69	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
21	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
61	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java
85	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredInitializer.java
55	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
122	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
141	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
59	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
-	-	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
12	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
49	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
6	1	org.eclipse.jdt.core/grammar/java.g
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
index 4530449..bfbc516 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
@@ -13,6 +13,8 @@ package org.eclipse.jdt.core.tests.compiler.parser;
 import java.util.Locale;
 import java.util.Map;
 
+import junit.framework.Test;
+
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.internal.codeassist.complete.CompletionParser;
@@ -32,13 +34,19 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 // Tests must be updated with annotation recovery improvment
 // TODO(david) update test suite
 public class AnnotationDietRecoveryTest extends AbstractCompilerTest {
+	private static final boolean CHECK_ALL_PARSE = true;
 	public static boolean optimizeStringLiterals = false;
 	public static long sourceLevel = ClassFileConstants.JDK1_3; //$NON-NLS-1$
 	
 public AnnotationDietRecoveryTest(String testName){
 	super(testName);
 }
-
+public static Test suite() {
+	return buildMinimalComplianceTestSuite(testClass(), F_1_5);
+}
+public static Class testClass() {  
+	return AnnotationDietRecoveryTest.class;
+}
 /*
  * Toggle compiler in mode -1.5
  */
@@ -59,7 +67,7 @@ public void checkParse(
 	String testName) {
 
 	/* using regular parser in DIET mode */
-	{
+	if (CHECK_ALL_PARSE){
 		Parser parser = 
 			new Parser(
 				new ProblemReporter(
@@ -119,7 +127,7 @@ public void checkParse(
 			computedUnitToString);
 	}
 	/* using regular parser in FULL mode */
-	{
+	if (CHECK_ALL_PARSE){
 		Parser parser = 
 			new Parser(
 				new ProblemReporter(
@@ -143,7 +151,7 @@ public void checkParse(
 
 	}
 	/* using source element parser in DIET mode */
-	{
+	if (CHECK_ALL_PARSE){
 		SourceElementParser parser =
 			new SourceElementParser(
 				new TestSourceElementRequestor(),
@@ -166,7 +174,7 @@ public void checkParse(
 			computedUnitToString);
 	}
 	/* using source element parser in FULL mode */
-	{
+	if (CHECK_ALL_PARSE){
 		SourceElementParser parser =
 			new SourceElementParser(
 				new TestSourceElementRequestor(),
@@ -189,7 +197,7 @@ public void checkParse(
 			computedUnitToString);
 	}	
 	/* using completion parser in DIET mode */
-	{
+	if (CHECK_ALL_PARSE){
 		CompilerOptions options = new CompilerOptions(getCompilerOptions());
 		CompletionParser parser =
 			new CompletionParser(
@@ -508,7 +516,7 @@ public void test0009() {
 	String expectedDietUnitToString = 
 		"package a;\n" + 
 		"public class X {\n" + 
-		"  List<Test> l;\n" + 
+		"  @SuppressWarnings(\"unchecked\") List<Test> l;\n" + 
 		"  public X() {\n" + 
 		"  }\n" + 
 		"}\n";
@@ -516,7 +524,7 @@ public void test0009() {
 	String expectedDietPlusBodyUnitToString = 
 		"package a;\n" + 
 		"public class X {\n" + 
-		"  List<Test> l;\n" + 
+		"  @SuppressWarnings(\"unchecked\") List<Test> l;\n" + 
 		"  public X() {\n" + 
 		"    super();\n" + 
 		"  }\n" + 
@@ -525,7 +533,12 @@ public void test0009() {
 	String expectedFullUnitToString = expectedDietUnitToString;
 	
 	String expectedCompletionDietUnitToString = 
-		expectedDietUnitToString;
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  List<Test> l;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
 	
 	String testName = "<generic type recovery>";
 	checkParse(
@@ -671,4 +684,992 @@ public void test0012() {
 		expectedCompletionDietUnitToString,	
 		testName);
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0013() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietPlusBodyUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0014() {
+
+	String s = 
+		"package a;										\n"
+			+ "#										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0015() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "public class X {							\n"
+			+ "#										\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0016() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "#										\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0017() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "#										\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0018() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name=)						\n"
+			+ "@AnAnnotation2(name2)					\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation2(name2) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0019() {
+
+	String s = 
+		"package a;										\n"
+			+ "@AnAnnotation(name)						\n"
+			+ "@AnAnnotation2(name2=)					\n"
+			+ "public class X {							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2 class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation(name) @AnAnnotation2 class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0020() {
+
+	String s = 
+		"package a;										\n"
+			+ "public class X {							\n"
+			+ "  @AnAnnotation(name) #					\n"
+			+ "  int field;								\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  @AnAnnotation(name) int field;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  @AnAnnotation(name) int field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  int field;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0021() {
+
+	String s = 
+		"package a;										\n"
+			+ "public class X {							\n"
+			+ "  @AnAnnotation(name=)					\n"
+			+ "  int field;								\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  @AnAnnotation int field;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  @AnAnnotation int field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  int field;\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0022() {
+
+	String s = 
+		"package a;										\n"
+			+ "public class X {							\n"
+			+ "  @AnAnnotation(name) #					\n"
+			+ "  void foo() {}							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @AnAnnotation(name) void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  @AnAnnotation(name) void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0023() {
+
+	String s = 
+		"package a;										\n"
+			+ "public class X {							\n"
+			+ "  @AnAnnotation(name=)					\n"
+			+ "  void foo() {}							\n"
+			+ "}										\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  @AnAnnotation void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  @AnAnnotation void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0024() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo(int param1, @AnAnnotation(name) # int param2) {}	\n"
+			+ "}															\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0025() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo(int param1, @AnAnnotation(name=) int param2) {}	\n"
+			+ "}															\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0026() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo(int param1, @AnAnnotation(@AnAnnotation1(name1=\"a\", name2=) int param2) {}	\n"
+			+ "}															\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo(int param1) {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		expectedDietUnitToString;
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0027() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(name1=\"a\", #)														\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name1 = \"a\") class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name1 = \"a\") class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0028() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(name1=\"a\", name2=@AnAnnotation2(name3=\"b\"), #)					\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name1 = \"a\",name2 = @AnAnnotation2(name3 = \"b\")) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name1 = \"a\",name2 = @AnAnnotation2(name3 = \"b\")) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0030() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(\"a\"#)																\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0031() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(\"a\", name2=@AnAnnotation2(name3=\"b\"), #)							\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") @AnAnnotation2(name3 = \"b\") class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") @AnAnnotation2(name3 = \"b\") class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0032() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(\"a\", name2=@AnAnnotation2(name3=\"b\"))								\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") @AnAnnotation2(name3 = \"b\") class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(\"a\") @AnAnnotation2(name3 = \"b\") class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0033() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(name=new Object() {})	#												\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name = new Object() {\n" + 
+		"}) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name = new Object() {\n" + 
+		"}) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0034() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(name=new Object() {},#)												\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name = new Object() {\n" + 
+		"}) class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1(name = new Object() {\n" + 
+		"}) class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0035() {
+
+	String s = 
+		"package a;																					\n"
+			+ "@AnAnnotation1(name=new Object() {#})												\n"
+			+ "public class X {																		\n"
+			+ "}																					\n"; 	
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1 class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public @AnAnnotation1 class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedFullUnitToString = 
+		expectedDietUnitToString;
+	
+	String expectedCompletionDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String testName = "<generic type recovery>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedFullUnitToString,
+		expectedCompletionDietUnitToString,	
+		testName);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
index 64f3eb8..db719bd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
@@ -41,7 +41,7 @@ public void runComplianceParserTest(
 		this.runNegativeTest(testFiles, expected13ProblemLog);
 	} else if(this.complianceLevel == ClassFileConstants.JDK1_4) {
 		this.runNegativeTest(testFiles, expected14ProblemLog);
-	} else if(this.complianceLevel > ClassFileConstants.JDK1_5) {
+	} else if(this.complianceLevel >= ClassFileConstants.JDK1_5) {
 		this.runNegativeTest(testFiles, expected15ProblemLog);
 	}
 }
@@ -1919,7 +1919,7 @@ public void test0042() {
 		"5. ERROR in X.java (at line 23)\n" + 
 		"	}\n" + 
 		"	^\n" + 
-		"Syntax error, insert \"}\" to complete MemberValueArrayInitializer\n" + 
+		"Syntax error, insert \"}\" to complete MemberValue\n" + 
 		"----------\n" + 
 		"6. ERROR in X.java (at line 23)\n" + 
 		"	}\n" + 
@@ -2212,6 +2212,16 @@ public void test0049() {
 		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
 		"	              ^^\n" + 
 		"Syntax error, insert \")\" to complete Modifier\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 6)\n" + 
+		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
+		"	              ^^\n" + 
+		"The attribute value is undefined for the annotation type MyAnn\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 6)\n" + 
+		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
+		"	                           ^^^^\n" + 
+		"The public type Test must be defined in its own file\n" + 
 		"----------\n";
 	String expected14ProblemLog =
 		expected13ProblemLog;
@@ -2220,8 +2230,18 @@ public void test0049() {
 		"----------\n" + 
 		"1. ERROR in X.java (at line 6)\n" + 
 		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
+		"	              ^^\n" + 
+		"The attribute value is undefined for the annotation type MyAnn\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
 		"	                ^\n" + 
-		"Syntax error on token \",\", / expected\n" + 
+		"Syntax error on token \",\", < expected\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 6)\n" + 
+		"	public @MyAnn(\"\",\"\") class Test {		\n" + 
+		"	                           ^^^^\n" + 
+		"The public type Test must be defined in its own file\n" + 
 		"----------\n";
 	
 	runComplianceParserTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest_1_5.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest_1_5.java
index a5e074c..f79f63b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest_1_5.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/StatementRecoveryTest_1_5.java
@@ -379,4 +379,353 @@ public void test0002() {
 		expectedFullWithStatementRecoveryUnitToString,
 		testName);
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0003() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo() {												\n"
+			+ "    @AnAnnotation(name) #									\n"
+			+ "    int var;													\n"
+			+ "  }															\n"
+			+ "}															\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    @AnAnnotation(name) int var;\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0004() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo() {												\n"
+			+ "    @AnAnnotation(name=)										\n"
+			+ "    int var;													\n"
+			+ "  }															\n"
+			+ "}															\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    @AnAnnotation(name = $missing$) int var;\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0005() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo() {												\n"
+			+ "    foo1();													\n"
+			+ "    @AnAnnotation(name) #									\n"
+			+ "    class Y {}												\n"
+			+ "    foo2();													\n"
+			+ "  }															\n"
+			+ "}															\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    @AnAnnotation(name) class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    foo1();\n" + 
+		"    @AnAnnotation(name) class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    foo2();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0006() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo() {												\n"
+			+ "    foo1();													\n"
+			+ "    @AnAnnotation(name=)										\n"
+			+ "    class Y {}												\n"
+			+ "    foo2();													\n"
+			+ "  }															\n"
+			+ "}															\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    @AnAnnotation class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    foo1();\n" + 
+		"    @AnAnnotation class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    foo2();\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778
+public void test0007() {
+
+	String s = 
+		"package a;															\n"
+			+ "public class X {												\n"
+			+ "  void foo() {												\n"
+			+ "    foo1();													\n"
+			+ "    final @AnAnnotation(name) #								\n"
+			+ "    class Y {}												\n"
+			+ "    foo2();													\n"
+			+ "  }															\n"
+			+ "}															\n";
+
+	String expectedDietUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+			
+	String expectedDietWithStatementRecoveryUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedDietPlusBodyUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    final @AnAnnotation(name) class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n";
+
+	String expectedDietPlusBodyWithStatementRecoveryUnitToString = 
+		"package a;\n" + 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  void foo() {\n" + 
+		"    foo1();\n" + 
+		"    final @AnAnnotation(name) class Y {\n" + 
+		"      Y() {\n" + 
+		"        super();\n" + 
+		"      }\n" + 
+		"    }\n" + 
+		"    foo2();\n" + 
+		"  }\n" + 
+		"}\n";
+	
+	String expectedFullUnitToString =
+		expectedDietUnitToString;
+	
+	String expectedFullWithStatementRecoveryUnitToString =
+		expectedFullUnitToString;
+	
+	String testName = "<test>";
+	checkParse(
+		s.toCharArray(),
+		expectedDietUnitToString,
+		expectedDietWithStatementRecoveryUnitToString,
+		expectedDietPlusBodyUnitToString,
+		expectedDietPlusBodyWithStatementRecoveryUnitToString,
+		expectedFullUnitToString,
+		expectedFullWithStatementRecoveryUnitToString,
+		testName);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
index 3164e33..86aafef 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
@@ -2636,7 +2636,7 @@ public void test079() {
 		"5. ERROR in Hello.java (at line 23)\n" + 
 		"	}\n" + 
 		"	^\n" + 
-		"Syntax error, insert \"}\" to complete MemberValueArrayInitializer\n" + 
+		"Syntax error, insert \"}\" to complete MemberValue\n" + 
 		"----------\n" + 
 		"6. ERROR in Hello.java (at line 23)\n" + 
 		"	}\n" + 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTest.java
index 0c97e7c..93a9443 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTest.java
@@ -537,9 +537,6 @@ public void testBug214647b() throws CoreException, IOException {
 	);
 }
 
-/*
- * https://bugs.eclipse.org/bugs/show_bug.cgi?id=215759
- */
 /**
  * @bug 215759: DOM AST regression tests should be improved
  * @test these tests test the new DOM AST test framework
@@ -652,7 +649,7 @@ public void testBug215759b() throws CoreException {
 			"4:METHOD_DECLARATION,[176,23],[165,34],,[METHOD,Lp/X;.bar()V,]\n" + 
 			"5:METHOD_DECLARATION,[201,40],,,[METHOD,Lp/X;.bar2()V,DEPRECATED]\n" + 
 			"===== Problems =====\n" + 
-			"No Problem",
+			"No problem",
 			result);
 }
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
index c163bd5..0cf9f90 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterBugsTestJLS3.java
@@ -15,6 +15,8 @@ import java.util.List;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.dom.AST;
 
 public class ASTConverterBugsTestJLS3 extends ASTConverterBugsTest {
@@ -33,4 +35,1002 @@ public static Test suite() {
 	return suite;
 }
 
+/**
+ * @bug 130778: Invalid annotation elements cause no annotation to be in the AST
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=130778"
+ */
+public void testBug130778a() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[18,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[37,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[43,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"No problem",
+			result);
+}
+public void testBug130778b() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"#\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[13,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[20,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[39,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[45,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778c() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"#\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[20,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[39,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[45,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 3)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778d() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"#\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[18,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[39,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[45,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 4)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778e() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"#\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[18,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[37,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[45,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 5)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778f() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"#\n" +
+			"class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[18,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[37,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[43,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 6)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778g() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]public[*1*]\n" +
+			"[*2*]@AnAnnotation(\"a\")[*2*]\n" +
+			"[*3*]final[*3*]\n" +
+			"[*4*]@AnAnnotation2(\"b\")[*4*]\n" +
+			"class X {\n" +
+			"  #\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]public[*1*] [*2*]@AnAnnotation(\"a\")[*2*] [*3*]final[*3*] [*4*]@AnAnnotation2(\"b\")[*4*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MODIFIER,[11,6],,,[N/A]\n" + 
+			"2:SINGLE_MEMBER_ANNOTATION,[18,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MODIFIER,[37,5],,,[N/A]\n" + 
+			"4:SINGLE_MEMBER_ANNOTATION,[43,19],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 7)\n" + 
+			"	#\n" + 
+			"	^\n" + 
+			"Syntax error on token \"Invalid Character\", delete this token\n",
+			result);
+}
+public void testBug130778h() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation(value=\"a\")[*1*]\n" +
+			"[*2*]@AnAnnotation2(value=\"b\")[*2*]\n" +
+			"[*3*]public[*3*] class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation(value=\"a\")[*1*] [*2*]@AnAnnotation2(value=\"b\")[*2*] [*3*]public[*3*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:NORMAL_ANNOTATION,[11,24],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:NORMAL_ANNOTATION,[36,25],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"3:MODIFIER,[62,6],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"No problem",
+			result);
+}
+public void testBug130778i() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation[*1*](value=)\n" +
+			"[*2*]@AnAnnotation2(value=\"b\")[*2*]\n" +
+			"[*3*]public[*3*] class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation[*1*] [*2*]@AnAnnotation2(value=\"b\")[*2*] [*3*]public[*3*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:NORMAL_ANNOTATION,[33,25],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"3:MODIFIER,[59,6],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(value=)\n" + 
+			"	                   ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778j() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation(value=\"a\")[*1*]\n" +
+			"[*2*]@AnAnnotation2[*2*](value=)\n" +
+			"[*3*]public[*3*] class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation(value=\"a\")[*1*] [*2*]@AnAnnotation2[*2*] [*3*]public[*3*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:NORMAL_ANNOTATION,[11,24],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:MARKER_ANNOTATION,[36,14],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"3:MODIFIER,[59,6],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 3)\n" + 
+			"	@AnAnnotation2(value=)\n" + 
+			"	                    ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778k() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation[*1*](value=)\n" +
+			"[*2*]@AnAnnotation2[*2*](value=)\n" +
+			"[*3*]public[*3*] class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation[*1*] [*2*]@AnAnnotation2[*2*] [*3*]public[*3*] class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:MARKER_ANNOTATION,[33,14],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"3:MODIFIER,[56,6],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(value=)\n" + 
+			"	                    ^\n" + 
+			"Syntax error on token \")\", delete this token\n" + 
+			"2. ERROR in /Converter15/src/a/X.java (at line 3)\n" + 
+			"	@AnAnnotation2(value=)\n" + 
+			"	                    ^\n" + 
+			"Syntax error on token \"=\", ) expected\n",
+			result);
+}
+public void testBug130778l() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"public class X {\n" +
+			"  public void foo(){\n" +
+			"    [*1*]@AnAnnotation[*1*](value=)\n" +
+			"    [*2*]@AnAnnotation2(value=\"b\")[*2*]\n" +
+			"    class Y {}\n" +
+			"  }\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"public class X {\n" + 
+			"  public void foo(){\n" + 
+			"[*1*]@AnAnnotation[*1*] [*2*]@AnAnnotation2(value=\"b\")[*2*] class Y {\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MARKER_ANNOTATION,[53,13],,,[ANNOTATION,La/X$115$Y;@La/AnAnnotation;,]\n" + 
+			"2:NORMAL_ANNOTATION,[79,25],,,[ANNOTATION,La/X$115$Y;@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 4)\n" + 
+			"	@AnAnnotation(value=)\n" + 
+			"	                   ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778m() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"public class X {\n" +
+			"  public void foo(){\n" +
+			"    [*1*]@AnAnnotation(value=)[*1*]\n" +
+			"    [*2*]@AnAnnotation2(value=\"b\")[*2*]\n" +
+			"    int i;\n" +
+			"  }\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"public class X {\n" + 
+			"  public void foo(){\n" + 
+			"    [*1*]@AnAnnotation(value=$missing$)[*1*] [*2*]@AnAnnotation2(value=\"b\")[*2*] int i;\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:NORMAL_ANNOTATION,[53,21],,,[ANNOTATION,La/X;.foo()V#i@La/AnAnnotation;,]\n" + 
+			"2:NORMAL_ANNOTATION,[79,25],,,[ANNOTATION,La/X;.foo()V#i@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 4)\n" + 
+			"	@AnAnnotation(value=)\n" + 
+			"	                   ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778n() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String name1();\n" +
+			"  String name2();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*][*2*]@AnAnnotation([*3*]name1=\"a\"[*3*][*2*], name2)\n" +
+			"public class X {\n" +
+			"}[*1*]\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*][*2*]@AnAnnotation([*3*]name1=\"a\"[*3*])[*2*] public class X {\n" + 
+			"}[*1*]\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:TYPE_DECLARATION,[11,50],,MALFORMED|RECOVERED,[TYPE,La/X;,]\n" + 
+			"2:NORMAL_ANNOTATION,[11,23],,RECOVERED,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:MEMBER_VALUE_PAIR,[25,9],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(name1=\"a\", name2)\n" + 
+			"	                       ^\n" + 
+			"Syntax error on token \",\", . expected\n",
+			result);
+}
+public void testBug130778o() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String name1();\n" +
+			"  String name2();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*][*2*]@AnAnnotation[*2*]([*3*]name1=[*3*])\n" +
+			"public class X {\n" +
+			"}[*1*]\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*][*2*]@AnAnnotation[*2*] public class X {\n" + 
+			"}[*1*]\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:TYPE_DECLARATION,[11,40],,MALFORMED|RECOVERED,[TYPE,La/X;,]\n" + 
+			"2:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"3:No corresponding node\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(name1=)\n" + 
+			"	                   ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778p() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  AnAnnotation2 value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation([*2*]value=[*3*]@AnAnnotation2(value=\"a\")[*3*][*2*])[*1*]\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation([*2*]value=[*3*]@AnAnnotation2(value=\"a\")[*3*][*2*])[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:NORMAL_ANNOTATION,[11,46],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:MEMBER_VALUE_PAIR,[25,31],,,[N/A]\n" + 
+			"3:NORMAL_ANNOTATION,[31,25],,,[ANNOTATION,@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"No problem",
+			result);
+}
+public void testBug130778q() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  AnAnnotation2 value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation([*2*]value=[*3*]@AnAnnotation2(value=\"a\")[*3*][*2*][*1*]\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation([*2*]value=[*3*]@AnAnnotation2(value=\"a\")[*3*][*2*])[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:NORMAL_ANNOTATION,[11,45],,RECOVERED,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:MEMBER_VALUE_PAIR,[25,31],,,[N/A]\n" + 
+			"3:NORMAL_ANNOTATION,[31,25],,RECOVERED,[ANNOTATION,@La/AnAnnotation2;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(value=@AnAnnotation2(value=\"a\")\n" + 
+			"	                                            ^\n" + 
+			"Syntax error, insert \")\" to complete Modifiers\n",
+			result);
+}
+public void testBug130778r() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  AnAnnotation2 value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*][*2*]@AnAnnotation[*2*](value=@AnAnnotation2(value=))\n" +
+			"public class X {\n" +
+			"}[*1*]\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*][*2*]@AnAnnotation[*2*] public class X {\n" + 
+			"}[*1*]\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:TYPE_DECLARATION,[11,62],,MALFORMED|RECOVERED,[TYPE,La/X;,]\n" + 
+			"2:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(value=@AnAnnotation2(value=))\n" + 
+			"	                                        ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778s() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value1();\n" +
+			"  AnAnnotation2 value2();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*][*2*]@AnAnnotation[*2*](value1=,[*3*]value=[*4*]@AnAnnotation2(value=\"b\")[*4*][*3*])\n" +
+			"public class X {\n" +
+			"}[*1*]\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*][*2*]@AnAnnotation[*2*] [*4*]@AnAnnotation2(value=\"b\")[*4*] public class X {\n" + 
+			"}[*1*]\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:TYPE_DECLARATION,[11,73],,MALFORMED|RECOVERED,[TYPE,La/X;,]\n" + 
+			"2:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"4:NORMAL_ANNOTATION,[39,25],,,[ANNOTATION,La/X;@La/AnAnnotation2;,]\n" + 
+			"3:No corresponding node\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(value1=,value=@AnAnnotation2(value=\"b\"))\n" + 
+			"	                    ^\n" + 
+			"Syntax error on token \"=\", MemberValue expected after this token\n",
+			result);
+}
+public void testBug130778t() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation(\"b\")[*1*]\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation(\"b\")[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:SINGLE_MEMBER_ANNOTATION,[11,18],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"===== Problems =====\n" + 
+			"No problem",
+			result);
+}
+public void testBug130778u() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation([*2*]\"b\"[*2*][*1*]\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation([*2*]\"b\"[*2*])[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:SINGLE_MEMBER_ANNOTATION,[11,17],,RECOVERED,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:STRING_LITERAL,[25,3],,,[N/A]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(\"b\"\n" + 
+			"	              ^^^\n" + 
+			"Syntax error, insert \")\" to complete Modifiers\n",
+			result);
+}
+public void testBug130778v() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  AnAnnotation2 value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation2.java",
+			"package a;\n" +
+			"public @interface AnAnnotation2 {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation[*1*](@AnAnnotation2(\"b\"\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:MARKER_ANNOTATION,[11,13],,,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(@AnAnnotation2(\"b\"\n" + 
+			"	                             ^^^\n" + 
+			"Syntax error, insert \")\" to complete SingleMemberAnnotation\n" + 
+			"2. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(@AnAnnotation2(\"b\"\n" + 
+			"	                             ^^^\n" + 
+			"Syntax error, insert \")\" to complete Modifiers\n",
+			result);
+}
+public void testBug130778x() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Converter15/src/a/AnAnnotation.java",
+			"package a;\n" +
+			"public @interface AnAnnotation {\n" +
+			"  String value();\n" +
+			"}\n",
+			true/*resolve*/);
+	
+	ASTResult result = this.buildMarkedAST(
+			"/Converter15/src/a/X.java",
+			"package a;\n" +
+			"[*1*]@AnAnnotation([*2*]\"a\"[*2*][*1*], [*3*]\"b\"[*3*])\n" +
+			"public class X {\n" +
+			"}\n");
+	
+	assertASTResult(
+			"===== AST =====\n" + 
+			"package a;\n" + 
+			"[*1*]@AnAnnotation([*2*]\"a\"[*2*])[*1*] public class X {\n" + 
+			"}\n" + 
+			"\n" + 
+			"===== Details =====\n" + 
+			"1:SINGLE_MEMBER_ANNOTATION,[11,17],,RECOVERED,[ANNOTATION,La/X;@La/AnAnnotation;,]\n" + 
+			"2:STRING_LITERAL,[25,3],,,[N/A]\n" + 
+			"3:No corresponding node\n" + 
+			"===== Problems =====\n" + 
+			"1. ERROR in /Converter15/src/a/X.java (at line 2)\n" + 
+			"	@AnAnnotation(\"a\", \"b\")\n" + 
+			"	                 ^\n" + 
+			"Syntax error on token \",\", < expected\n",
+			result);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
index 9727db7..6397516 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
@@ -129,7 +129,11 @@ public class AbstractASTTests extends ModifyingResourceTests implements DefaultM
 		}
 		
 		public int indexOfASTStart(int astStart) {
-			for (int i = 0, length = this.astStarts.length; i < length; i++)
+			return this.indexOfASTStart(astStart, 0);
+		}
+		
+		public int indexOfASTStart(int astStart, int fromIndex) {
+			for (int i = fromIndex, length = this.astStarts.length; i < length; i++)
 				if (this.astStarts[i] == astStart)
 					return i;
 			return -1;
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
index 1641108..1ae8cf7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
@@ -462,7 +462,8 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 	private final static String DETAILS_DELIMITER = "===== Details =====";
 	private final static String PROBLEMS_DELIMITER = "===== Problems =====";
 	
-	private final static String NO_PROBLEM = "No Problem";
+	private final static String NO_PROBLEM = "No problem";
+	private static final String NO_CORRESPONDING_NODE = "No corresponding node";
 	
 	// options
 	private boolean reportAST;
@@ -475,7 +476,8 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 	private Map markerFromNode;
 	private Map nodeFromMarker;
 	private Map markerPositonInBuffer;
-
+	
+	private boolean[] foundNodeFromMarker;
 	private StringBuffer markedNodesBuffer;
 	
 	private MarkedNodeLabelProvider labelProvider;
@@ -542,14 +544,19 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 	}
 	public void preVisit(ASTNode node) {
 		String markerName = null;
-		int index = markerInfo.indexOfASTStart(node.getStartPosition());
-		if (index != -1 && node.getStartPosition() + node.getLength() == markerInfo.astEnds[index]) {
-			markerName = String.valueOf(index + 1);
-			
-			if (this.nodeFromMarker.get(markerName) == null) {
-				this.markerFromNode.put(node, markerName);
-				this.nodeFromMarker.put(markerName, node);
-				this.markerPositonInBuffer.put(markerName, new Integer(this.buffer.length()));
+		int index = -1;
+		found : while ((index = markerInfo.indexOfASTStart(node.getStartPosition(), index + 1)) != -1) {
+			if (node.getStartPosition() + node.getLength() == markerInfo.astEnds[index]) {
+				markerName = String.valueOf(index + 1);
+				
+				if (this.nodeFromMarker.get(markerName) == null) {
+					this.markerFromNode.put(node, markerName);
+					this.nodeFromMarker.put(markerName, node);
+					this.markerPositonInBuffer.put(markerName, new Integer(this.buffer.length()));
+					this.foundNodeFromMarker[index] = true;
+				}
+				
+				break found;
 			}
 		}
 		
@@ -569,6 +576,17 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 		this.markerFromNode = new HashMap();
 		this.nodeFromMarker = new HashMap();
 		this.markerPositonInBuffer = new HashMap();
+		int length = mf.astStarts.length;
+		this.foundNodeFromMarker = new boolean[length];
 		this.unit.accept(this);
+		
+		for (int i = 0; i < length; i++) {
+			if (!this.foundNodeFromMarker[i]) {
+				this.markedNodesBuffer.append('\n');
+				this.markedNodesBuffer.append(String.valueOf(i + 1));
+				this.markedNodesBuffer.append(':');
+				this.markedNodesBuffer.append(NO_CORRESPONDING_NODE);
+			}
+		}
 	}
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 4caeb49..841c71d 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -65,7 +65,9 @@ amended accordingly; see <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=1
 </li>
 </ul>
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=122247">122247</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=130778">130778</a>
+Invalid annotation elements cause no annotation to be in the AST
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=122247">122247</a>
 [formatter] add support to handle parameter annotations
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=210524">210524</a>
 [batch][compiler][options] -warn:allDeprecation -warn:-deprecation does not behave as documented
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 4356cc5..f3c6e3f 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -80,6 +80,7 @@ public AssistParser(ProblemReporter problemReporter) {
 	
 	this.setMethodsFullRecovery(false);
 	this.setStatementsRecovery(false);
+	this.annotationRecoveryActivated = false;
 }
 public abstract char[] assistIdentifier();
 public int bodyEnd(AbstractMethodDeclaration method){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index b0948fc..c4ef100 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -28,7 +28,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	public final static int Bit3 = 0x4;					// return type (operator) | name reference kind (name ref) | implicit this (this ref)
 	public final static int Bit4 = 0x8;					// return type (operator) | first assignment to local (name ref,local decl) | undocumented empty block (block, type and method decl)
 	public final static int Bit5 = 0x10;				// value for return (expression) | has all method bodies (unit) | supertype ref (type ref) | resolved (field decl)
-	public final static int Bit6 = 0x20;				// depth (name ref, msg) | ignore need cast check (cast expression) | error in signature (method declaration/ initializer)
+	public final static int Bit6 = 0x20;				// depth (name ref, msg) | ignore need cast check (cast expression) | error in signature (method declaration/ initializer) | is recovered (annotation reference)
 	public final static int Bit7 = 0x40;				// depth (name ref, msg) | operator (operator) | need runtime checkcast (cast expression) | label used (labelStatement) | needFreeReturn (AbstractMethodDeclaration)
 	public final static int Bit8 = 0x80;				// depth (name ref, msg) | operator (operator) | unsafe cast (cast expression) | is default constructor (constructor declaration)
 	public final static int Bit9 = 0x100;				// depth (name ref, msg) | operator (operator) | is local type (type decl)
@@ -217,6 +217,9 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	// for synchronized statement
 	public static final int BlockExit = Bit30;
 	
+	// for annotation reference
+	public static final int IsRecovered = Bit6;
+	
 	// constants used when checking invocation arguments
 	public static final int INVOCATION_ARGUMENT_OK = 0;
 	public static final int INVOCATION_ARGUMENT_UNCHECKED = 1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index db0f239..196d69d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -288,7 +288,9 @@ public abstract class Annotation extends Expression {
 					}
 				}
 			}
-			if (!foundValue && (method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0) {
+			if (!foundValue &&
+					(method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0 &&
+					(this.bits & IsRecovered) == 0) {
 				scope.problemReporter().missingValueForAnnotationMember(this, selector);
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 0b19812..a88a5b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -182,11 +182,11 @@ public class Parser implements  ParserBasicInformation, TerminalTokens, Operator
 	public boolean reportOnlyOneSyntaxError = false;
 	public boolean reportSyntaxErrorIsRequired = true;
 	protected boolean restartRecovery;
+	protected boolean annotationRecoveryActivated = true;
 	
 	protected int lastPosistion;
 	
 	// statement recovery
-//	public boolean statementRecoveryEnabled = true;
 	public boolean methodRecoveryActivated = false;
 	protected boolean statementRecoveryActivated = false;
 	protected TypeDeclaration[] recoveredTypes;
@@ -888,7 +888,7 @@ public Parser(ProblemReporter problemReporter, boolean optimizeStringLiterals) {
 	this.javadocParser = createJavadocParser();
 }
 protected void annotationRecoveryCheckPoint(int start, int end) {
-	if(this.lastCheckPoint > start && this.lastCheckPoint < end) {
+	if(this.lastCheckPoint < end) {
 		this.lastCheckPoint = end + 1;
 	}
 }
@@ -1092,6 +1092,10 @@ protected void checkAndSetModifiers(int flag){
 	this.modifiers |= flag;
 			
 	if (this.modifiersSourceStart < 0) this.modifiersSourceStart = this.scanner.startPosition;
+	
+	if (currentElement != null && this.annotationRecoveryActivated) {
+		currentElement.addModifier(flag, this.modifiersSourceStart);
+	}
 }
 public void checkComment() {
 
@@ -1263,6 +1267,10 @@ protected void consumeAnnotationName() {
 		int start = this.intStack[this.intPtr];
 		int end = (int) (this.identifierPositionStack[this.identifierPtr] & 0x00000000FFFFFFFFL);
 		annotationRecoveryCheckPoint(start, end);
+	
+		if (this.annotationRecoveryActivated) {
+			this.currentElement = this.currentElement.addAnnotationName(this.identifierPtr, this.identifierLengthPtr, start, 0);
+		}
 	}
 	this.recordStringLiterals = false;
 }
@@ -3021,7 +3029,12 @@ protected void consumeEnterAnonymousClassBody() {
 	if (this.currentElement != null){ 
 		this.lastCheckPoint = anonymousType.bodyStart;		
 		this.currentElement = this.currentElement.add(anonymousType, 0);
-		this.currentToken = 0; // opening brace already taken into account
+		if (!(this.currentElement instanceof RecoveredAnnotation)) {
+			this.currentToken = 0; // opening brace already taken into account
+		} else {
+			this.ignoreNextOpeningBrace = true;
+			this.currentElement.bracketBalance++;
+		}
 		this.lastIgnoredToken = -1;
 	}	
 }
@@ -4220,6 +4233,9 @@ protected void consumeLocalVariableDeclarationStatement() {
 protected void consumeMarkerAnnotation() {
 	// MarkerAnnotation ::= '@' Name
 	MarkerAnnotation markerAnnotation = null;
+	
+	int oldIndex = this.identifierPtr;
+	
 	TypeReference typeReference = this.getAnnotationType();
 	markerAnnotation = new MarkerAnnotation(typeReference, this.intStack[this.intPtr--]);
 	markerAnnotation.declarationSourceEnd = markerAnnotation.sourceEnd;
@@ -4230,6 +4246,10 @@ protected void consumeMarkerAnnotation() {
 		this.problemReporter().invalidUsageOfAnnotation(markerAnnotation);
 	}
 	this.recordStringLiterals = true;
+	
+	if (this.currentElement != null && this.currentElement instanceof RecoveredAnnotation) {
+		this.currentElement = ((RecoveredAnnotation)this.currentElement).addAnnotation(markerAnnotation, oldIndex);
+	}
 }
 protected void consumeMemberValueArrayInitializer() {
 	// MemberValueArrayInitializer ::= '{' MemberValues ',' '}'
@@ -4250,6 +4270,12 @@ protected void consumeMemberValuePair() {
 	this.expressionLengthPtr--;
 	MemberValuePair memberValuePair = new MemberValuePair(simpleName, start, end, value);
 	pushOnAstStack(memberValuePair);
+	
+	if (this.currentElement != null && this.currentElement instanceof RecoveredAnnotation) {
+		RecoveredAnnotation recoveredAnnotation = (RecoveredAnnotation) this.currentElement;
+		
+		recoveredAnnotation.setKind(RecoveredAnnotation.NORMAL);
+	}
 }
 protected void consumeMemberValuePairs() {
 	// MemberValuePairs ::= MemberValuePairs ',' MemberValuePair
@@ -4725,6 +4751,9 @@ protected void consumeNestedType() {
 protected void consumeNormalAnnotation() {
 	// NormalAnnotation ::= '@' Name '(' MemberValuePairsopt ')'
 	NormalAnnotation normalAnnotation = null;
+	
+	int oldIndex = this.identifierPtr;
+	
 	TypeReference typeReference = this.getAnnotationType();
 	normalAnnotation = new NormalAnnotation(typeReference, this.intStack[this.intPtr--]);
 	int length;
@@ -4741,6 +4770,10 @@ protected void consumeNormalAnnotation() {
 	
 	if(this.currentElement != null) {
 		annotationRecoveryCheckPoint(normalAnnotation.sourceStart, normalAnnotation.declarationSourceEnd);
+		
+		if (currentElement instanceof RecoveredAnnotation) {
+			this.currentElement = ((RecoveredAnnotation)this.currentElement).addAnnotation(normalAnnotation, oldIndex);
+		}
 	}
 	
 	if(!this.statementRecoveryActivated &&
@@ -6738,23 +6771,27 @@ protected void consumeRule(int act) {
 		    consumeMarkerAnnotation() ;  
 			break;
  
-    case 695 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
+    case 695 : if (DEBUG) { System.out.println("SingleMemberAnnotationMemberValue ::= MemberValue"); }  //$NON-NLS-1$
+		    consumeSingleMemberAnnotationMemberValue() ;  
+			break;
+ 
+    case 696 : if (DEBUG) { System.out.println("SingleMemberAnnotation ::= AnnotationName LPAREN..."); }  //$NON-NLS-1$
 		    consumeSingleMemberAnnotation() ;  
 			break;
  
-    case 696 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
+    case 697 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt TypeParameters"); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderNameWithTypeParameters();  
 			break;
  
-    case 697 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
+    case 698 : if (DEBUG) { System.out.println("RecoveryMethodHeaderName ::= Modifiersopt Type..."); }  //$NON-NLS-1$
 		    consumeRecoveryMethodHeaderName();  
 			break;
  
-    case 698 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 699 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
-    case 699 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
+    case 700 : if (DEBUG) { System.out.println("RecoveryMethodHeader ::= RecoveryMethodHeaderName..."); }  //$NON-NLS-1$
 		    consumeMethodHeader();  
 			break;
  
@@ -6768,6 +6805,9 @@ protected void consumeSimpleAssertStatement() {
 protected void consumeSingleMemberAnnotation() {
 	// SingleMemberAnnotation ::= '@' Name '(' MemberValue ')'
 	SingleMemberAnnotation singleMemberAnnotation = null;
+	
+	int oldIndex = this.identifierPtr;
+	
 	TypeReference typeReference = this.getAnnotationType();
 	singleMemberAnnotation = new SingleMemberAnnotation(typeReference, this.intStack[this.intPtr--]);
 	singleMemberAnnotation.memberValue = this.expressionStack[this.expressionPtr--];
@@ -6778,6 +6818,10 @@ protected void consumeSingleMemberAnnotation() {
 	
 	if(this.currentElement != null) {
 		annotationRecoveryCheckPoint(singleMemberAnnotation.sourceStart, singleMemberAnnotation.declarationSourceEnd);
+		
+		if (currentElement instanceof RecoveredAnnotation) {
+			this.currentElement = ((RecoveredAnnotation)this.currentElement).addAnnotation(singleMemberAnnotation, oldIndex);
+		}
 	}
 	
 	if(!this.statementRecoveryActivated &&
@@ -6787,6 +6831,16 @@ protected void consumeSingleMemberAnnotation() {
 	}
 	this.recordStringLiterals = true;
 }
+
+protected void consumeSingleMemberAnnotationMemberValue() {
+	// this rule is used for syntax recovery only
+	if (this.currentElement != null && this.currentElement instanceof RecoveredAnnotation) {
+		RecoveredAnnotation recoveredAnnotation = (RecoveredAnnotation) this.currentElement;
+		
+		recoveredAnnotation.setKind(RecoveredAnnotation.SINGLE_MEMBER);
+	}
+
+}
 protected void consumeSingleStaticImportDeclarationName() {
 	// SingleTypeImportDeclarationName ::= 'import' 'static' Name
 	/* push an ImportRef build from the last name 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
index ee362aa..c8423bf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/ParserBasicInformation.java
@@ -16,20 +16,20 @@ public interface ParserBasicInformation {
 
 	int ERROR_SYMBOL = 110,
 		MAX_NAME_LENGTH = 41,
-		NUM_STATES = 961,
+		NUM_STATES = 969,
 
 		NT_OFFSET = 110,
 		SCOPE_UBOUND = 133,
 		SCOPE_SIZE = 134,
-		LA_STATE_OFFSET = 12766,
+		LA_STATE_OFFSET = 12828,
 		MAX_LA = 1,
-		NUM_RULES = 699,
+		NUM_RULES = 700,
 		NUM_TERMINALS = 110,
-		NUM_NON_TERMINALS = 310,
-		NUM_SYMBOLS = 420,
-		START_STATE = 730,
+		NUM_NON_TERMINALS = 311,
+		NUM_SYMBOLS = 421,
+		START_STATE = 731,
 		EOFT_SYMBOL = 68,
 		EOLT_SYMBOL = 68,
-		ACCEPT_ACTION = 12765,
-		ERROR_ACTION = 12766;
+		ACCEPT_ACTION = 12827,
+		ERROR_ACTION = 12828;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredAnnotation.java
new file mode 100644
index 0000000..3af58e0
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredAnnotation.java
@@ -0,0 +1,191 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.parser;
+
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
+import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+
+public class RecoveredAnnotation extends RecoveredElement {
+	public static final int MARKER = 0;
+	public static final int NORMAL = 1;
+	public static final int SINGLE_MEMBER = 2;
+	
+	private int kind;
+	private int identifierPtr;
+	private int identifierLengthPtr;
+	private int sourceStart;
+	public Annotation annotation;
+
+	public RecoveredAnnotation(int identifierPtr, int identifierLengthPtr, int sourceStart, RecoveredElement parent, int bracketBalance) {
+		super(parent, bracketBalance);
+		this.kind = MARKER;
+		this.identifierPtr = identifierPtr;
+		this.identifierLengthPtr = identifierLengthPtr;
+		this.sourceStart = sourceStart;
+	}
+	
+	public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue) {
+		if (annotation == null && (typeDeclaration.bits & ASTNode.IsAnonymousType) != 0){
+			// ignore anonymous type in annotations when annotation isn't fully recovered
+			return this;
+		}
+		return super.add(typeDeclaration, bracketBalanceValue);
+	}
+	
+	public RecoveredElement addAnnotationName(int identPtr, int identLengthPtr, int annotationStart, int bracketBalanceValue) {
+
+		RecoveredAnnotation element = new RecoveredAnnotation(identPtr, identLengthPtr, annotationStart, this, bracketBalanceValue);
+		
+		return element;
+	}
+	
+	public RecoveredElement addAnnotation(Annotation annot, int index) {
+		this.annotation = annot;
+		
+		if (parent != null) return parent;
+		return this;
+	}
+	
+	public void updateFromParserState() {
+		Parser parser = this.parser();
+		
+		if (annotation == null && this.identifierPtr <= parser.identifierPtr) {
+			Annotation annot = null;
+			
+			boolean needUpdateRParenPos = false;
+			
+			parser.identifierPtr = this.identifierPtr;
+			parser.identifierLengthPtr = this.identifierLengthPtr;
+			TypeReference typeReference = parser.getAnnotationType();
+			
+			switch (this.kind) {
+				case NORMAL:
+					MemberValuePair[] memberValuePairs = null;
+					if (parser.astPtr > -1 && parser.astStack[parser.astPtr] instanceof MemberValuePair) {
+						int argLength = parser.astLengthStack[parser.astLengthPtr];
+						int argStart = parser.astPtr - argLength + 1;
+						
+						if (argLength > 0) {
+							System.arraycopy(parser.astStack, argStart, memberValuePairs = new MemberValuePair[argLength], 0, argLength);
+							parser.astLengthPtr--;
+							parser.astPtr -= argLength;
+							
+							MemberValuePair lastMemberValuePair = memberValuePairs[memberValuePairs.length - 1];
+							
+							NormalAnnotation normalAnnotation = new NormalAnnotation(typeReference, this.sourceStart);
+							normalAnnotation.memberValuePairs = memberValuePairs;
+							normalAnnotation.declarationSourceEnd =
+								lastMemberValuePair.value != null
+										? lastMemberValuePair.value instanceof Annotation
+												? ((Annotation)lastMemberValuePair.value).declarationSourceEnd
+												: lastMemberValuePair.value.sourceEnd
+										: lastMemberValuePair.sourceEnd;
+							normalAnnotation.bits |= ASTNode.IsRecovered;
+							
+							annot = normalAnnotation;
+							
+							needUpdateRParenPos = true;
+						}
+					}
+					
+					
+					break;
+				case SINGLE_MEMBER:
+					if (parser.expressionPtr > -1) {
+						Expression memberValue = parser.expressionStack[parser.expressionPtr--];
+						
+						SingleMemberAnnotation singleMemberAnnotation = new SingleMemberAnnotation(typeReference, this.sourceStart);
+						singleMemberAnnotation.memberValue = memberValue;
+						singleMemberAnnotation.declarationSourceEnd = memberValue.sourceEnd;
+						singleMemberAnnotation.bits |= ASTNode.IsRecovered;
+						
+						annot = singleMemberAnnotation;
+							
+						needUpdateRParenPos = true;
+					}
+					break;
+			}
+			
+			if (!needUpdateRParenPos) {
+				MarkerAnnotation markerAnnotation = new MarkerAnnotation(typeReference, this.sourceStart);
+				markerAnnotation.declarationSourceEnd = markerAnnotation.sourceEnd;
+				markerAnnotation.bits |= ASTNode.IsRecovered;
+				
+				annot = markerAnnotation;
+			}
+			
+			parser.currentElement = this.addAnnotation(annot, this.identifierPtr);
+			parser.annotationRecoveryCheckPoint(annot.sourceStart, annot.declarationSourceEnd);
+			if (this.parent != null) {
+
+				this.parent.updateFromParserState();
+			}
+		}
+	}
+	
+	public ASTNode parseTree() {
+		return this.annotation;
+	}
+	
+	public void resetPendingModifiers() {
+		if (parent != null) this.parent.resetPendingModifiers();
+	}
+	
+	public void setKind(int kind) {
+		this.kind = kind;
+	}
+	
+	public int sourceEnd() {
+		if (annotation == null) {
+			Parser parser = parser();
+			if (this.identifierPtr < parser.identifierPositionStack.length) {
+				return (int) parser.identifierPositionStack[this.identifierPtr];
+			} else {
+				return this.sourceStart;
+			}
+		}
+		return this.annotation.declarationSourceEnd;
+	}
+	
+	public String toString(int tab) {	
+		if (annotation != null) {
+			return tabString(tab) + "Recovered annotation:\n" + annotation.print(tab + 1, new StringBuffer(10)); //$NON-NLS-1$
+		} else {
+			return tabString(tab) + "Recovered annotation: identiferPtr=" + this.identifierPtr + " identiferlengthPtr=" + this.identifierLengthPtr + "\n"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		}
+	}
+	
+	public Annotation updatedAnnotationReference() {
+		return this.annotation;
+	}
+	
+	public RecoveredElement updateOnClosingBrace(int braceStart, int braceEnd){
+		if (bracketBalance > 0){ // was an member value array initializer
+			bracketBalance--;
+			return this;
+		}
+		if (parent != null){
+			return parent.updateOnClosingBrace(braceStart, braceEnd);
+		}
+		return this;
+	}
+	
+	public void updateParseTree() {
+		this.updatedAnnotationReference();
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
index 9099652..931fae9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
@@ -30,6 +30,11 @@ public class RecoveredBlock extends RecoveredStatement implements TerminalTokens
 	public boolean preserveContent = false;
 	public RecoveredLocalVariable pendingArgument;
 	
+	int pendingModifiers;
+	int pendingModifersSourceStart = -1;
+	RecoveredAnnotation[] pendingAnnotations;
+	int pendingAnnotationCount;
+	
 public RecoveredBlock(Block block, RecoveredElement parent, int bracketBalance){
 	super(block, parent, bracketBalance);
 	this.blockDeclaration = block;
@@ -41,6 +46,7 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 	if (this.parent != null && this.parent instanceof RecoveredMethod) {
 		RecoveredMethod enclosingRecoveredMethod = (RecoveredMethod) this.parent;
 		if (enclosingRecoveredMethod.methodBody == this && enclosingRecoveredMethod.parent == null) {
+			this.resetPendingModifiers();
 			// the element cannot be added because we are in the body of a top level method
 			return this; // ignore this element
 		}
@@ -51,6 +57,7 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
  * Record a nested block declaration 
  */
 public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* do not consider a nested block starting passed the block end (if set)
 		it must be belonging to an enclosing block */
@@ -104,11 +111,21 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
 		it must be belonging to an enclosing block */
 	if (this.blockDeclaration.sourceEnd != 0 
 			&& localDeclaration.declarationSourceStart > this.blockDeclaration.sourceEnd){
+		resetPendingModifiers();
 		if (delegatedByParent) return this; //ignore
 		return this.parent.add(localDeclaration, bracketBalanceValue);
 	}
 
 	RecoveredLocalVariable element = new RecoveredLocalVariable(localDeclaration, this, bracketBalanceValue);
+	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
 
 	if (localDeclaration instanceof Argument){
 		this.pendingArgument = element;
@@ -130,6 +147,7 @@ public RecoveredElement add(Statement stmt, int bracketBalanceValue) {
  * Record a statement declaration 
  */
 public RecoveredElement add(Statement stmt, int bracketBalanceValue, boolean delegatedByParent) {
+	this.resetPendingModifiers();
 
 	/* do not consider a nested block starting passed the block end (if set)
 		it must be belonging to an enclosing block */
@@ -159,15 +177,52 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 		it must be belonging to an enclosing block */
 	if (this.blockDeclaration.sourceEnd != 0 
 			&& typeDeclaration.declarationSourceStart > this.blockDeclaration.sourceEnd){
+		resetPendingModifiers();
 		if (delegatedByParent) return this; //ignore
 		return this.parent.add(typeDeclaration, bracketBalanceValue);
 	}
 			
-	RecoveredStatement element = new RecoveredType(typeDeclaration, this, bracketBalanceValue);
+	RecoveredType element = new RecoveredType(typeDeclaration, this, bracketBalanceValue);
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
 	this.attach(element);
 	if (typeDeclaration.declarationSourceEnd == 0) return element;
 	return this;
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	if (pendingAnnotations == null) {
+		pendingAnnotations = new RecoveredAnnotation[5];
+		pendingAnnotationCount = 0;
+	} else {
+		if (pendingAnnotationCount == pendingAnnotations.length) {
+			System.arraycopy(
+				pendingAnnotations, 
+				0, 
+				(pendingAnnotations = new RecoveredAnnotation[2 * pendingAnnotationCount]), 
+				0, 
+				pendingAnnotationCount); 
+		}
+	}
+	
+	RecoveredAnnotation element = new RecoveredAnnotation(identifierPtr, identifierLengthPtr, annotationStart, this, bracketBalanceValue);
+	
+	pendingAnnotations[pendingAnnotationCount++] = element;
+	
+	return element;
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	this.pendingModifiers |= flag;
+	
+	if (this.pendingModifersSourceStart < 0) {
+		this.pendingModifersSourceStart = modifiersSourceStart;
+	}
+}
 /*
  * Attach a recovered statement
  */
@@ -188,12 +243,24 @@ void attach(RecoveredStatement recoveredStatement) {
 	}
 	this.statements[this.statementCount++] = recoveredStatement;
 }
+void attachPendingModifiers(RecoveredAnnotation[] pendingAnnots, int pendingAnnotCount, int pendingMods, int pendingModsSourceStart) {
+	this.pendingAnnotations = pendingAnnots;
+	this.pendingAnnotationCount = pendingAnnotCount;
+	this.pendingModifiers = pendingMods;
+	this.pendingModifersSourceStart = pendingModsSourceStart;
+}
 /* 
  * Answer the associated parsed structure
  */
 public ASTNode parseTree(){
 	return this.blockDeclaration;
 }
+public void resetPendingModifiers() {
+	this.pendingAnnotations = null;
+	this.pendingAnnotationCount = 0;
+	this.pendingModifiers = 0;
+	this.pendingModifersSourceStart = -1;
+}
 public String toString(int tab) {
 	StringBuffer result = new StringBuffer(tabString(tab));
 	result.append("Recovered block:\n"); //$NON-NLS-1$
@@ -377,6 +444,7 @@ public Statement updateStatement(){
  * Record a field declaration 
  */
 public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* local variables inside method can only be final and non void */
 	char[][] fieldTypeName; 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 92ef38e..d4b466d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -37,12 +37,20 @@ public RecoveredElement(RecoveredElement parent, int bracketBalance, Parser pars
 	this.bracketBalance = bracketBalance;
 	this.recoveringParser = parser;
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(annotationStart - 1));	
+	return this.parent.addAnnotationName(identifierPtr, identifierLengthPtr, annotationStart, bracketBalanceValue);
+}
 /*
  *	Record a method declaration
  */
 public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bracketBalanceValue) {
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(methodDeclaration.declarationSourceStart - 1));	
 	return this.parent.add(methodDeclaration, bracketBalanceValue);
@@ -53,6 +61,7 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(nestedBlockDeclaration.sourceStart - 1));	
 	return this.parent.add(nestedBlockDeclaration, bracketBalanceValue);
@@ -63,6 +72,7 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
 public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(fieldDeclaration.declarationSourceStart - 1));	
 	return this.parent.add(fieldDeclaration, bracketBalanceValue);
@@ -73,6 +83,7 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
 public RecoveredElement add(ImportReference importReference, int bracketBalanceValue){
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(importReference.declarationSourceStart - 1));	
 	return this.parent.add(importReference, bracketBalanceValue);
@@ -83,6 +94,7 @@ public RecoveredElement add(ImportReference importReference, int bracketBalanceV
 public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanceValue) {
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(localDeclaration.declarationSourceStart - 1));	
 	return this.parent.add(localDeclaration, bracketBalanceValue);
@@ -93,6 +105,7 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
 public RecoveredElement add(Statement statement, int bracketBalanceValue) {
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(statement.sourceStart - 1));	
 	return this.parent.add(statement, bracketBalanceValue);
@@ -103,6 +116,7 @@ public RecoveredElement add(Statement statement, int bracketBalanceValue) {
 public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue){
 
 	/* default behavior is to delegate recording to parent if any */
+	this.resetPendingModifiers();
 	if (this.parent == null) return this; // ignore
 	this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(typeDeclaration.declarationSourceStart - 1));	
 	return this.parent.add(typeDeclaration, bracketBalanceValue);
@@ -116,6 +130,9 @@ protected void addBlockStatement(RecoveredBlock recoveredBlock) {
 		}
 	}
 }
+public void addModifier(int flag, int modifiersSourceStart) {
+	// default implementation: do nothing
+}
 /*
  * Answer the depth of this element, considering the parent link.
  */
@@ -183,6 +200,10 @@ public Parser parser(){
 public ASTNode parseTree(){
 	return null;
 }
+public void resetPendingModifiers() {
+	// default implementation: do nothing
+	// recovered elements which have pending modifiers must override this method
+}
 /*
  * Iterate the enclosing blocks and tag them so as to preserve their content
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java
index e2f98e3..2e79827 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java
@@ -14,6 +14,7 @@ package org.eclipse.jdt.internal.compiler.parser;
  * Internal field structure for parsing recovery 
  */
 import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -27,6 +28,12 @@ public class RecoveredField extends RecoveredElement {
 	public FieldDeclaration fieldDeclaration;
 	boolean alreadyCompletedFieldInitialization;
 	
+	public RecoveredAnnotation[] annotations;
+	public int annotationCount;
+	
+	public int modifiers;
+	public int modifiersStart;
+	
 	public RecoveredType[] anonymousTypes;
 	public int anonymousTypeCount;
 public RecoveredField(FieldDeclaration fieldDeclaration, RecoveredElement parent, int bracketBalance){
@@ -85,6 +92,29 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 		return element;
 	}
 }
+public void attach(RecoveredAnnotation[] annots, int annotCount, int mods, int modsSourceStart) {
+	if (annotCount > 0) {
+		Annotation[] existingAnnotations = this.fieldDeclaration.annotations;
+		if (existingAnnotations != null) {
+			this.annotations = new RecoveredAnnotation[annotCount];
+			this.annotationCount = 0;
+			next : for (int i = 0; i < annotCount; i++) {
+				for (int j = 0; j < existingAnnotations.length; j++) {
+					if (annots[i].annotation == existingAnnotations[j]) continue next;
+				}
+				this.annotations[this.annotationCount++] = annots[i];
+			}
+		} else {
+			this.annotations = annots;
+			this.annotationCount = annotCount;
+		}
+	}
+	
+	if (mods != 0) {
+		this.modifiers = mods;
+		this.modifiersStart = modsSourceStart;
+	}
+}
 /* 
  * Answer the associated parsed structure
  */
@@ -101,6 +131,12 @@ public String toString(int tab){
 	StringBuffer buffer = new StringBuffer(tabString(tab));
 	buffer.append("Recovered field:\n"); //$NON-NLS-1$
 	fieldDeclaration.print(tab + 1, buffer);
+	if (this.annotations != null) {
+		for (int i = 0; i < this.annotationCount; i++) {
+			buffer.append("\n"); //$NON-NLS-1$
+			buffer.append(this.annotations[i].toString(tab + 1));
+		}
+	}
 	if (this.anonymousTypes != null) {
 		for (int i = 0; i < this.anonymousTypeCount; i++){
 			buffer.append("\n"); //$NON-NLS-1$
@@ -110,7 +146,31 @@ public String toString(int tab){
 	return buffer.toString();
 }
 public FieldDeclaration updatedFieldDeclaration(){
-
+	/* update annotations */
+	if (modifiers != 0) {
+		this.fieldDeclaration.modifiers |= modifiers;
+		if (this.modifiersStart < this.fieldDeclaration.declarationSourceStart) {
+			this.fieldDeclaration.declarationSourceStart = modifiersStart;
+		}
+	}
+	/* update annotations */
+	if (annotationCount > 0){
+		int existingCount = fieldDeclaration.annotations == null ? 0 : fieldDeclaration.annotations.length;
+		Annotation[] annotationReferences = new Annotation[existingCount + annotationCount];
+		if (existingCount > 0){
+			System.arraycopy(fieldDeclaration.annotations, 0, annotationReferences, annotationCount, existingCount);
+		}
+		for (int i = 0; i < annotationCount; i++){
+			annotationReferences[i] = annotations[i].updatedAnnotationReference();
+		}
+		fieldDeclaration.annotations = annotationReferences;
+		
+		int start = this.annotations[0].annotation.sourceStart;
+		if (start < this.fieldDeclaration.declarationSourceStart) {
+			this.fieldDeclaration.declarationSourceStart = start;
+		}
+	}
+	
 	if (this.anonymousTypes != null) {
 		if(fieldDeclaration.initialization == null) {
 			for (int i = 0; i < this.anonymousTypeCount; i++){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredInitializer.java
index 883b2c7..4af1325 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredInitializer.java
@@ -27,6 +27,11 @@ public class RecoveredInitializer extends RecoveredField implements TerminalToke
 	public int localTypeCount;
 
 	public RecoveredBlock initializerBody;	
+	
+	int pendingModifiers;
+	int pendingModifersSourceStart = -1;
+	RecoveredAnnotation[] pendingAnnotations;
+	int pendingAnnotationCount;
 
 public RecoveredInitializer(FieldDeclaration fieldDeclaration, RecoveredElement parent, int bracketBalance){
 	this(fieldDeclaration, parent, bracketBalance, null);
@@ -46,6 +51,7 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
 	*/
 	if (fieldDeclaration.declarationSourceEnd > 0
 			&& nestedBlockDeclaration.sourceStart > fieldDeclaration.declarationSourceEnd){
+		resetPendingModifiers();
 		if (this.parent == null) return this; // ignore
 		return this.parent.add(nestedBlockDeclaration, bracketBalanceValue);
 	}
@@ -62,6 +68,7 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
  * Record a field declaration (act like inside method body)
  */
 public RecoveredElement add(FieldDeclaration newFieldDeclaration, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* local variables inside initializer can only be final and non void */
 	char[][] fieldTypeName;
@@ -95,6 +102,7 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
 		it must be belonging to an enclosing type */
 	if (fieldDeclaration.declarationSourceEnd != 0 
 			&& localDeclaration.declarationSourceStart > fieldDeclaration.declarationSourceEnd){
+		resetPendingModifiers();
 		if (parent == null) return this; // ignore
 		return this.parent.add(localDeclaration, bracketBalanceValue);
 	}
@@ -102,6 +110,14 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
 	Block block = new Block(0);
 	block.sourceStart = ((Initializer)fieldDeclaration).sourceStart;
 	RecoveredElement element = this.add(block, 1);
+	if (initializerBody != null) {
+		initializerBody.attachPendingModifiers(
+				this.pendingAnnotations,
+				this.pendingAnnotationCount,
+				this.pendingModifiers,
+				this.pendingModifersSourceStart);
+	}
+	this.resetPendingModifiers();
 	return element.add(localDeclaration, bracketBalanceValue);	
 }
 /*
@@ -113,6 +129,7 @@ public RecoveredElement add(Statement statement, int bracketBalanceValue) {
 		it must be belonging to an enclosing type */
 	if (fieldDeclaration.declarationSourceEnd != 0 
 			&& statement.sourceStart > fieldDeclaration.declarationSourceEnd){
+		resetPendingModifiers();
 		if (parent == null) return this; // ignore
 		return this.parent.add(statement, bracketBalanceValue);
 	}
@@ -120,6 +137,16 @@ public RecoveredElement add(Statement statement, int bracketBalanceValue) {
 	Block block = new Block(0);
 	block.sourceStart = ((Initializer)fieldDeclaration).sourceStart;
 	RecoveredElement element = this.add(block, 1);
+	
+	if (initializerBody != null) {
+		initializerBody.attachPendingModifiers(
+				this.pendingAnnotations,
+				this.pendingAnnotationCount,
+				this.pendingModifiers,
+				this.pendingModifersSourceStart);
+	}
+	this.resetPendingModifiers();
+		
 	return element.add(statement, bracketBalanceValue);	
 }
 public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue) {
@@ -128,6 +155,7 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 		it must be belonging to an enclosing type */
 	if (fieldDeclaration.declarationSourceEnd != 0 
 			&& typeDeclaration.declarationSourceStart > fieldDeclaration.declarationSourceEnd){
+		resetPendingModifiers();
 		if (parent == null) return this; // ignore
 		return this.parent.add(typeDeclaration, bracketBalanceValue);
 	}
@@ -136,6 +164,14 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 		Block block = new Block(0);
 		block.sourceStart = ((Initializer)fieldDeclaration).sourceStart;
 		RecoveredElement element = this.add(block, 1);
+		if (initializerBody != null) {
+			initializerBody.attachPendingModifiers(
+					this.pendingAnnotations,
+					this.pendingAnnotationCount,
+					this.pendingModifiers,
+					this.pendingModifersSourceStart);
+		}
+		this.resetPendingModifiers();
 		return element.add(typeDeclaration, bracketBalanceValue);	
 	}	
 	if (localTypes == null) {
@@ -154,6 +190,15 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 	RecoveredType element = new RecoveredType(typeDeclaration, this, bracketBalanceValue);
 	localTypes[localTypeCount++] = element;
 	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
+	
 	/* consider that if the opening brace was not found, it is there */
 	if (!foundOpeningBrace){
 		foundOpeningBrace = true;
@@ -161,10 +206,50 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 	}
 	return element;
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	if (pendingAnnotations == null) {
+		pendingAnnotations = new RecoveredAnnotation[5];
+		pendingAnnotationCount = 0;
+	} else {
+		if (pendingAnnotationCount == pendingAnnotations.length) {
+			System.arraycopy(
+				pendingAnnotations, 
+				0, 
+				(pendingAnnotations = new RecoveredAnnotation[2 * pendingAnnotationCount]), 
+				0, 
+				pendingAnnotationCount); 
+		}
+	}
+	
+	RecoveredAnnotation element = new RecoveredAnnotation(identifierPtr, identifierLengthPtr, annotationStart, this, bracketBalanceValue);
+	
+	pendingAnnotations[pendingAnnotationCount++] = element;
+	
+	return element;
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	this.pendingModifiers |= flag;
+	
+	if (this.pendingModifersSourceStart < 0) {
+		this.pendingModifersSourceStart = modifiersSourceStart;
+	}
+}
+public void resetPendingModifiers() {
+	this.pendingAnnotations = null;
+	this.pendingAnnotationCount = 0;
+	this.pendingModifiers = 0;
+	this.pendingModifersSourceStart = -1;
+}
 public String toString(int tab) {
 	StringBuffer result = new StringBuffer(tabString(tab));
 	result.append("Recovered initializer:\n"); //$NON-NLS-1$
 	this.fieldDeclaration.print(tab + 1, result);
+	if (this.annotations != null) {
+		for (int i = 0; i < this.annotationCount; i++) {
+			result.append("\n"); //$NON-NLS-1$
+			result.append(this.annotations[i].toString(tab + 1));
+		}
+	}
 	if (this.initializerBody != null) {
 		result.append("\n"); //$NON-NLS-1$
 		result.append(this.initializerBody.toString(tab + 1));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
index a760898..a5bfec0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
@@ -13,6 +13,7 @@ package org.eclipse.jdt.internal.compiler.parser;
 /**
  * Internal local variable structure for parsing recovery 
  */
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -22,6 +23,12 @@ import org.eclipse.jdt.internal.compiler.ast.Statement;
 
 public class RecoveredLocalVariable extends RecoveredStatement {
 
+	public RecoveredAnnotation[] annotations;
+	public int annotationCount;
+	
+	public int modifiers;
+	public int modifiersStart;
+	
 	public LocalDeclaration localDeclaration;
 	boolean alreadyCompletedLocalInitialization;
 public RecoveredLocalVariable(LocalDeclaration localDeclaration, RecoveredElement parent, int bracketBalance){
@@ -44,6 +51,29 @@ public RecoveredElement add(Statement stmt, int bracketBalanceValue) {
 		return this;
 	}
 }
+public void attach(RecoveredAnnotation[] annots, int annotCount, int mods, int modsSourceStart) {
+	if (annotCount > 0) {
+		Annotation[] existingAnnotations = this.localDeclaration.annotations;
+		if (existingAnnotations != null) {
+			this.annotations = new RecoveredAnnotation[annotCount];
+			this.annotationCount = 0;
+			next : for (int i = 0; i < annotCount; i++) {
+				for (int j = 0; j < existingAnnotations.length; j++) {
+					if (annots[i].annotation == existingAnnotations[j]) continue next;
+				}
+				this.annotations[this.annotationCount++] = annots[i];
+			}
+		} else {
+			this.annotations = annots;
+			this.annotationCount = annotCount;
+		}
+	}
+	
+	if (mods != 0) {
+		this.modifiers = mods;
+		this.modifiersStart = modsSourceStart;
+	}
+}
 /* 
  * Answer the associated parsed structure
  */
@@ -56,10 +86,34 @@ public ASTNode parseTree(){
 public int sourceEnd(){
 	return this.localDeclaration.declarationSourceEnd;
 }
-public String toString(int tab) {
+public String toString(int tab) {	
 	return tabString(tab) + "Recovered local variable:\n" + localDeclaration.print(tab + 1, new StringBuffer(10)); //$NON-NLS-1$
 }
 public Statement updatedStatement(){
+	/* update annotations */
+	if (modifiers != 0) {
+		this.localDeclaration.modifiers |= modifiers;
+		if (this.modifiersStart < this.localDeclaration.declarationSourceStart) {
+			this.localDeclaration.declarationSourceStart = modifiersStart;
+		}
+	}
+	/* update annotations */
+	if (annotationCount > 0){
+		int existingCount = localDeclaration.annotations == null ? 0 : localDeclaration.annotations.length;
+		Annotation[] annotationReferences = new Annotation[existingCount + annotationCount];
+		if (existingCount > 0){
+			System.arraycopy(localDeclaration.annotations, 0, annotationReferences, annotationCount, existingCount);
+		}
+		for (int i = 0; i < annotationCount; i++){
+			annotationReferences[i] = annotations[i].updatedAnnotationReference();
+		}
+		localDeclaration.annotations = annotationReferences;
+		
+		int start = this.annotations[0].annotation.sourceStart;
+		if (start < this.localDeclaration.declarationSourceStart) {
+			this.localDeclaration.declarationSourceStart = start;
+		}
+	}
 	return localDeclaration;
 }
 /*
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
index 4025840..3709b75 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredMethod.java
@@ -12,6 +12,7 @@ package org.eclipse.jdt.internal.compiler.parser;
 
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Block;
@@ -37,12 +38,23 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 public class RecoveredMethod extends RecoveredElement implements TerminalTokens {
 
 	public AbstractMethodDeclaration methodDeclaration;
+	
+	public RecoveredAnnotation[] annotations;
+	public int annotationCount;
+	
+	public int modifiers;
+	public int modifiersStart;
 
 	public RecoveredType[] localTypes;
 	public int localTypeCount;
 
 	public RecoveredBlock methodBody;
 	public boolean discardBody = true;
+	
+	int pendingModifiers;
+	int pendingModifersSourceStart = -1;
+	RecoveredAnnotation[] pendingAnnotations;
+	int pendingAnnotationCount;
 
 public RecoveredMethod(AbstractMethodDeclaration methodDeclaration, RecoveredElement parent, int bracketBalance, Parser parser){
 	super(parent, bracketBalance, parser);
@@ -56,7 +68,6 @@ public RecoveredMethod(AbstractMethodDeclaration methodDeclaration, RecoveredEle
  * Record a nested block declaration
  */
 public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
-
 	/* default behavior is to delegate recording to parent if any,
 	do not consider elements passed the known end (if set)
 	it must be belonging to an enclosing element 
@@ -64,6 +75,7 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
 	if (methodDeclaration.declarationSourceEnd > 0
 		&& nestedBlockDeclaration.sourceStart
 			> methodDeclaration.declarationSourceEnd){
+				resetPendingModifiers();
 				if (this.parent == null){
 					return this; // ignore
 				} else {
@@ -84,6 +96,7 @@ public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValu
  * Record a field declaration
  */
 public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* local variables inside method can only be final and non void */
 	char[][] fieldTypeName; 
@@ -91,7 +104,6 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
 		|| (fieldDeclaration.type == null) // initializer
 		|| ((fieldTypeName = fieldDeclaration.type.getTypeName()).length == 1 // non void
 			&& CharOperation.equals(fieldTypeName[0], TypeBinding.VOID.sourceName()))){ 
-
 		if (this.parent == null){
 			return this; // ignore
 		} else {
@@ -124,6 +136,7 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
  * Record a local declaration - regular method should have been created a block body
  */
 public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* local variables inside method can only be final and non void */
 /*	
@@ -170,6 +183,7 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
  * Record a statement - regular method should have been created a block body
  */
 public RecoveredElement add(Statement statement, int bracketBalanceValue) {
+	this.resetPendingModifiers();
 
 	/* do not consider a type starting passed the type end (if set)
 		it must be belonging to an enclosing type */
@@ -214,11 +228,18 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 			block.sourceStart = methodDeclaration.bodyStart;
 			this.add(block, 1);
 		}
+		methodBody.attachPendingModifiers(
+				this.pendingAnnotations,
+				this.pendingAnnotationCount,
+				this.pendingModifiers,
+				this.pendingModifersSourceStart);
+		this.resetPendingModifiers();
 		return methodBody.add(typeDeclaration, bracketBalanceValue, true);	
 	}
 	switch (TypeDeclaration.kind(typeDeclaration.modifiers)) {
 		case TypeDeclaration.INTERFACE_DECL :
 		case TypeDeclaration.ANNOTATION_TYPE_DECL :
+			resetPendingModifiers();
 			this.updateSourceEndIfNecessary(this.previousAvailableLineEnd(typeDeclaration.declarationSourceStart - 1));
 			if (this.parent == null) {
 				return this; // ignore
@@ -242,6 +263,15 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 	RecoveredType element = new RecoveredType(typeDeclaration, this, bracketBalanceValue);
 	localTypes[localTypeCount++] = element;
 
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
+	
 	/* consider that if the opening brace was not found, it is there */
 	if (!foundOpeningBrace){
 		foundOpeningBrace = true;
@@ -258,6 +288,12 @@ public boolean bodyStartsAtHeaderEnd(){
 public ASTNode parseTree(){
 	return methodDeclaration;
 }
+public void resetPendingModifiers() {
+	this.pendingAnnotations = null;
+	this.pendingAnnotationCount = 0;
+	this.pendingModifiers = 0;
+	this.pendingModifersSourceStart = -1;
+}
 /*
  * Answer the very source end of the corresponding parse node
  */
@@ -268,6 +304,12 @@ public String toString(int tab) {
 	StringBuffer result = new StringBuffer(tabString(tab));
 	result.append("Recovered method:\n"); //$NON-NLS-1$
 	this.methodDeclaration.print(tab + 1, result);
+	if (this.annotations != null) {
+		for (int i = 0; i < this.annotationCount; i++) {
+			result.append("\n"); //$NON-NLS-1$
+			result.append(this.annotations[i].toString(tab + 1));
+		}
+	}
 	if (this.localTypes != null) {
 		for (int i = 0; i < this.localTypeCount; i++) {
 			result.append("\n"); //$NON-NLS-1$
@@ -288,7 +330,31 @@ public void updateBodyStart(int bodyStart){
 	this.methodDeclaration.bodyStart = bodyStart;
 }
 public AbstractMethodDeclaration updatedMethodDeclaration(){
-
+	/* update annotations */
+	if (modifiers != 0) {
+		this.methodDeclaration.modifiers |= modifiers;
+		if (this.modifiersStart < this.methodDeclaration.declarationSourceStart) {
+			this.methodDeclaration.declarationSourceStart = modifiersStart;
+		}
+	}
+	/* update annotations */
+	if (annotationCount > 0){
+		int existingCount = methodDeclaration.annotations == null ? 0 : methodDeclaration.annotations.length;
+		Annotation[] annotationReferences = new Annotation[existingCount + annotationCount];
+		if (existingCount > 0){
+			System.arraycopy(methodDeclaration.annotations, 0, annotationReferences, annotationCount, existingCount);
+		}
+		for (int i = 0; i < annotationCount; i++){
+			annotationReferences[i] = annotations[i].updatedAnnotationReference();
+		}
+		methodDeclaration.annotations = annotationReferences;
+		
+		int start = this.annotations[0].annotation.sourceStart;
+		if (start < this.methodDeclaration.declarationSourceStart) {
+			this.methodDeclaration.declarationSourceStart = start;
+		}
+	}
+	
 	if (methodBody != null){
 		Block block = methodBody.updatedBlock();
 		if (block != null){
@@ -452,8 +518,8 @@ public RecoveredElement updateOnClosingBrace(int braceStart, int braceEnd){
 		return this;
 	}
 	if(this.parent != null && this.parent instanceof RecoveredType) {
-		int modifiers = ((RecoveredType)this.parent).typeDeclaration.modifiers;
-		if (TypeDeclaration.kind(modifiers) == TypeDeclaration.INTERFACE_DECL) {
+		int mods = ((RecoveredType)this.parent).typeDeclaration.modifiers;
+		if (TypeDeclaration.kind(mods) == TypeDeclaration.INTERFACE_DECL) {
 			if (!this.foundOpeningBrace) {
 				this.updateSourceEndIfNecessary(braceStart - 1, braceStart - 1);
 				return this.parent.updateOnClosingBrace(braceStart, braceEnd);
@@ -502,6 +568,34 @@ public void updateSourceEndIfNecessary(int braceStart, int braceEnd){
 		}
 	}
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	if (pendingAnnotations == null) {
+		pendingAnnotations = new RecoveredAnnotation[5];
+		pendingAnnotationCount = 0;
+	} else {
+		if (pendingAnnotationCount == pendingAnnotations.length) {
+			System.arraycopy(
+				pendingAnnotations, 
+				0, 
+				(pendingAnnotations = new RecoveredAnnotation[2 * pendingAnnotationCount]), 
+				0, 
+				pendingAnnotationCount); 
+		}
+	}
+	
+	RecoveredAnnotation element = new RecoveredAnnotation(identifierPtr, identifierLengthPtr, annotationStart, this, bracketBalanceValue);
+	
+	pendingAnnotations[pendingAnnotationCount++] = element;
+	
+	return element;
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	this.pendingModifiers |= flag;
+	
+	if (this.pendingModifersSourceStart < 0) {
+		this.pendingModifersSourceStart = modifiersSourceStart;
+	}
+}
 void attach(TypeParameter[] parameters, int startPos) {
 	if(methodDeclaration.modifiers != ClassFileConstants.AccDefault) return;
 	
@@ -523,4 +617,27 @@ void attach(TypeParameter[] parameters, int startPos) {
 		this.methodDeclaration.declarationSourceStart = startPos;
 	}
 }
+public void attach(RecoveredAnnotation[] annots, int annotCount, int mods, int modsSourceStart) {
+	if (annotCount > 0) {
+		Annotation[] existingAnnotations = this.methodDeclaration.annotations;
+		if (existingAnnotations != null) {
+			this.annotations = new RecoveredAnnotation[annotCount];
+			this.annotationCount = 0;
+			next : for (int i = 0; i < annotCount; i++) {
+				for (int j = 0; j < existingAnnotations.length; j++) {
+					if (annots[i].annotation == existingAnnotations[j]) continue next;
+				}
+				this.annotations[this.annotationCount++] = annots[i];
+			}
+		} else {
+			this.annotations = annots;
+			this.annotationCount = annotCount;
+		}
+	}
+	
+	if (mods != 0) {
+		this.modifiers = mods;
+		this.modifiersStart = modsSourceStart;
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
index cebdf7b..c711e0b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java
@@ -13,6 +13,7 @@ package org.eclipse.jdt.internal.compiler.parser;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Initializer;
@@ -29,6 +30,12 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
 public class RecoveredType extends RecoveredStatement implements TerminalTokens {
 	public TypeDeclaration typeDeclaration;
+	
+	public RecoveredAnnotation[] annotations;
+	public int annotationCount;
+	
+	public int modifiers;
+	public int modifiersStart;
 
 	public RecoveredType[] memberTypes;
 	public int memberTypeCount;
@@ -45,6 +52,11 @@ public class RecoveredType extends RecoveredStatement implements TerminalTokens
 	public TypeParameter[] pendingTypeParameters;
 	public int pendingTypeParametersStart;
 	
+	int pendingModifiers;
+	int pendingModifersSourceStart = -1;
+	RecoveredAnnotation[] pendingAnnotations;
+	int pendingAnnotationCount;
+	
 public RecoveredType(TypeDeclaration typeDeclaration, RecoveredElement parent, int bracketBalance){
 	super(typeDeclaration, parent, bracketBalance);
 	this.typeDeclaration = typeDeclaration;
@@ -68,6 +80,8 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 	if (typeDeclaration.declarationSourceEnd != 0 
 		&& methodDeclaration.declarationSourceStart > typeDeclaration.declarationSourceEnd){
 		this.pendingTypeParameters = null;
+		this.resetPendingModifiers();
+		
 		return this.parent.add(methodDeclaration, bracketBalanceValue);
 	}
 
@@ -92,6 +106,15 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 		this.pendingTypeParameters = null;
 	}
 	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
+	
 	this.insideEnumConstantPart = false;
 
 	/* consider that if the opening brace was not found, it is there */
@@ -105,12 +128,13 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 }
 public RecoveredElement add(Block nestedBlockDeclaration,int bracketBalanceValue) {
 	this.pendingTypeParameters = null;
+	this.resetPendingModifiers();
 	
-	int modifiers = ClassFileConstants.AccDefault;
+	int mods = ClassFileConstants.AccDefault;
 	if(this.parser().recoveredStaticInitializerStart != 0) {
-		modifiers = ClassFileConstants.AccStatic;
+		mods = ClassFileConstants.AccStatic;
 	}
-	return this.add(new Initializer(nestedBlockDeclaration, modifiers), bracketBalanceValue);
+	return this.add(new Initializer(nestedBlockDeclaration, mods), bracketBalanceValue);
 }
 public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
 	this.pendingTypeParameters = null;
@@ -119,6 +143,9 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
 	it must be belonging to an enclosing type */
 	if (typeDeclaration.declarationSourceEnd != 0
 		&& fieldDeclaration.declarationSourceStart > typeDeclaration.declarationSourceEnd) {
+		
+		this.resetPendingModifiers();
+		
 		return this.parent.add(fieldDeclaration, bracketBalanceValue);
 	}
 	if (fields == null) {
@@ -148,6 +175,15 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
 			return this;
 	}
 	fields[fieldCount++] = element;
+	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
 
 	/* consider that if the opening brace was not found, it is there */
 	if (!foundOpeningBrace){
@@ -165,6 +201,9 @@ public RecoveredElement add(TypeDeclaration memberTypeDeclaration, int bracketBa
 		it must be belonging to an enclosing type */
 	if (typeDeclaration.declarationSourceEnd != 0 
 		&& memberTypeDeclaration.declarationSourceStart > typeDeclaration.declarationSourceEnd){
+		
+		this.resetPendingModifiers();
+		
 		return this.parent.add(memberTypeDeclaration, bracketBalanceValue);
 	}
 	
@@ -177,6 +216,9 @@ public RecoveredElement add(TypeDeclaration memberTypeDeclaration, int bracketBa
 			lastMethod.methodDeclaration.bodyEnd = 0; // reopen method
 			lastMethod.methodDeclaration.declarationSourceEnd = 0; // reopen method
 			lastMethod.bracketBalance++; // expect one closing brace
+			
+			this.resetPendingModifiers();
+			
 			return lastMethod.add(memberTypeDeclaration, bracketBalanceValue);
 		} else {
 			// ignore
@@ -199,6 +241,15 @@ public RecoveredElement add(TypeDeclaration memberTypeDeclaration, int bracketBa
 	}
 	RecoveredType element = new RecoveredType(memberTypeDeclaration, this, bracketBalanceValue);
 	memberTypes[memberTypeCount++] = element;
+	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
 
 	/* consider that if the opening brace was not found, it is there */
 	if (!foundOpeningBrace){
@@ -213,6 +264,57 @@ public void add(TypeParameter[] parameters, int startPos) {
 	this.pendingTypeParameters = parameters;
 	this.pendingTypeParametersStart = startPos;
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	if (pendingAnnotations == null) {
+		pendingAnnotations = new RecoveredAnnotation[5];
+		pendingAnnotationCount = 0;
+	} else {
+		if (pendingAnnotationCount == pendingAnnotations.length) {
+			System.arraycopy(
+				pendingAnnotations, 
+				0, 
+				(pendingAnnotations = new RecoveredAnnotation[2 * pendingAnnotationCount]), 
+				0, 
+				pendingAnnotationCount); 
+		}
+	}
+	
+	RecoveredAnnotation element = new RecoveredAnnotation(identifierPtr, identifierLengthPtr, annotationStart, this, bracketBalanceValue);
+	
+	pendingAnnotations[pendingAnnotationCount++] = element;
+	
+	return element;
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	this.pendingModifiers |= flag;
+	
+	if (this.pendingModifersSourceStart < 0) {
+		this.pendingModifersSourceStart = modifiersSourceStart;
+	}
+}
+public void attach(RecoveredAnnotation[] annots, int annotCount, int mods, int modsSourceStart) {
+	if (annotCount > 0) {
+		Annotation[] existingAnnotations = this.typeDeclaration.annotations;
+		if (existingAnnotations != null) {
+			this.annotations = new RecoveredAnnotation[annotCount];
+			this.annotationCount = 0;
+			next : for (int i = 0; i < annotCount; i++) {
+				for (int j = 0; j < existingAnnotations.length; j++) {
+					if (annots[i].annotation == existingAnnotations[j]) continue next;
+				}
+				this.annotations[this.annotationCount++] = annots[i];
+			}
+		} else {
+			this.annotations = annots;
+			this.annotationCount = annotCount;
+		}
+	}
+	
+	if (mods != 0) {
+		this.modifiers = mods;
+		this.modifiersStart = modsSourceStart;
+	}
+}
 /*
  * Answer the body end of the corresponding parse node
  */
@@ -258,6 +360,12 @@ public char[] name(){
 public ASTNode parseTree(){
 	return typeDeclaration;
 }
+public void resetPendingModifiers() {
+	this.pendingAnnotations = null;
+	this.pendingAnnotationCount = 0;
+	this.pendingModifiers = 0;
+	this.pendingModifersSourceStart = -1;
+}
 /*
  * Answer the very source end of the corresponding parse node
  */
@@ -272,6 +380,12 @@ public String toString(int tab) {
 		result.append(" "); //$NON-NLS-1$
 	}
 	typeDeclaration.print(tab + 1, result);
+	if (this.annotations != null) {
+		for (int i = 0; i < this.annotationCount; i++) {
+			result.append("\n"); //$NON-NLS-1$
+			result.append(this.annotations[i].toString(tab + 1));
+		}
+	}
 	if (this.memberTypes != null) {
 		for (int i = 0; i < this.memberTypeCount; i++) {
 			result.append("\n"); //$NON-NLS-1$
@@ -320,6 +434,30 @@ public Statement updatedStatement(){
 }
 public TypeDeclaration updatedTypeDeclaration(){
 	int lastEnd = typeDeclaration.bodyStart;
+	/* update annotations */
+	if (modifiers != 0) {
+		this.typeDeclaration.modifiers |= modifiers;
+		if (this.modifiersStart < this.typeDeclaration.declarationSourceStart) {
+			this.typeDeclaration.declarationSourceStart = modifiersStart;
+		}
+	}
+	/* update annotations */
+	if (annotationCount > 0){
+		int existingCount = typeDeclaration.annotations == null ? 0 : typeDeclaration.annotations.length;
+		Annotation[] annotationReferences = new Annotation[existingCount + annotationCount];
+		if (existingCount > 0){
+			System.arraycopy(typeDeclaration.annotations, 0, annotationReferences, annotationCount, existingCount);
+		}
+		for (int i = 0; i < annotationCount; i++){
+			annotationReferences[i] = annotations[i].updatedAnnotationReference();
+		}
+		typeDeclaration.annotations = annotationReferences;
+		
+		int start = this.annotations[0].annotation.sourceStart;
+		if (start < this.typeDeclaration.declarationSourceStart) {
+			this.typeDeclaration.declarationSourceStart = start;
+		}
+	}
 	/* update member types */
 	if (memberTypeCount > 0){
 		int existingCount = typeDeclaration.memberTypes == null ? 0 : typeDeclaration.memberTypes.length;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
index 661ec7f..c013474 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredUnit.java
@@ -30,10 +30,44 @@ public class RecoveredUnit extends RecoveredElement {
 	public int importCount;
 	public RecoveredType[] types;
 	public int typeCount;
+	
+	int pendingModifiers;
+	int pendingModifersSourceStart = -1;
+	RecoveredAnnotation[] pendingAnnotations;
+	int pendingAnnotationCount;
+	
 public RecoveredUnit(CompilationUnitDeclaration unitDeclaration, int bracketBalance, Parser parser){
 	super(null, bracketBalance, parser);
 	this.unitDeclaration = unitDeclaration;
 }
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	if (pendingAnnotations == null) {
+		pendingAnnotations = new RecoveredAnnotation[5];
+		pendingAnnotationCount = 0;
+	} else {
+		if (pendingAnnotationCount == pendingAnnotations.length) {
+			System.arraycopy(
+				pendingAnnotations, 
+				0, 
+				(pendingAnnotations = new RecoveredAnnotation[2 * pendingAnnotationCount]), 
+				0, 
+				pendingAnnotationCount); 
+		}
+	}
+	
+	RecoveredAnnotation element = new RecoveredAnnotation(identifierPtr, identifierLengthPtr, annotationStart, this, bracketBalanceValue);
+	
+	pendingAnnotations[pendingAnnotationCount++] = element;
+	
+	return element;
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	this.pendingModifiers |= flag;
+	
+	if (this.pendingModifersSourceStart < 0) {
+		this.pendingModifersSourceStart = modifiersSourceStart;
+	}
+}
 /*
  *	Record a method declaration: should be attached to last type
  */
@@ -64,6 +98,8 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 			type.add(initializer, bracketBalanceValue);
 		}
 		
+		this.resetPendingModifiers();
+		
 		return type.add(methodDeclaration, bracketBalanceValue);
 	}
 	return this; // ignore
@@ -79,11 +115,16 @@ public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanc
 		type.bodyEnd = 0; // reset position
 		type.typeDeclaration.declarationSourceEnd = 0; // reset position
 		type.typeDeclaration.bodyEnd = 0;
+		
+		this.resetPendingModifiers();
+		
 		return type.add(fieldDeclaration, bracketBalanceValue);
 	}
 	return this; // ignore
 }
 public RecoveredElement add(ImportReference importReference, int bracketBalanceValue) {
+	this.resetPendingModifiers();
+		
 	if (this.imports == null) {
 		this.imports = new RecoveredImport[5];
 		this.importCount = 0;
@@ -114,6 +155,9 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 			lastType.typeDeclaration.bodyEnd = 0; // reopen type
 			lastType.typeDeclaration.declarationSourceEnd = 0; // reopen type
 			lastType.bracketBalance++; // expect one closing brace
+			
+			this.resetPendingModifiers();
+		
 			return lastType.add(typeDeclaration, bracketBalanceValue);
 		}
 	}
@@ -132,6 +176,15 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 	}
 	RecoveredType element = new RecoveredType(typeDeclaration, this, bracketBalanceValue);
 	this.types[this.typeCount++] = element;
+	
+	if(this.pendingAnnotationCount > 0) {
+		element.attach(
+				pendingAnnotations,
+				pendingAnnotationCount,
+				pendingModifiers,
+				pendingModifersSourceStart);
+		this.resetPendingModifiers();
+	}
 
 	/* if type not finished, then type becomes current */
 	if (typeDeclaration.declarationSourceEnd == 0) return element;
@@ -143,6 +196,12 @@ public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceV
 public ASTNode parseTree(){
 	return this.unitDeclaration;
 }
+public void resetPendingModifiers() {
+	this.pendingAnnotations = null;
+	this.pendingAnnotationCount = 0;
+	this.pendingModifiers = 0;
+	this.pendingModifersSourceStart = -1;
+}
 /*
  * Answer the very source end of the corresponding parse node
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
index 9c895d1..98dc4cb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TerminalTokens.java
@@ -60,7 +60,7 @@ public interface TerminalTokens {
 		TokenNameif = 79,
 		TokenNameimplements = 106,
 		TokenNameimport = 100,
-		TokenNameinstanceof = 15,
+		TokenNameinstanceof = 12,
 		TokenNameint = 37,
 		TokenNameinterface = 95,
 		TokenNamelong = 38,
@@ -93,14 +93,14 @@ public interface TerminalTokens {
 		TokenNameDoubleLiteral = 50,
 		TokenNameCharacterLiteral = 51,
 		TokenNameStringLiteral = 52,
-		TokenNamePLUS_PLUS = 9,
-		TokenNameMINUS_MINUS = 10,
+		TokenNamePLUS_PLUS = 8,
+		TokenNameMINUS_MINUS = 9,
 		TokenNameEQUAL_EQUAL = 18,
-		TokenNameLESS_EQUAL = 16,
-		TokenNameGREATER_EQUAL = 17,
+		TokenNameLESS_EQUAL = 15,
+		TokenNameGREATER_EQUAL = 16,
 		TokenNameNOT_EQUAL = 19,
-		TokenNameLEFT_SHIFT = 13,
-		TokenNameRIGHT_SHIFT = 8,
+		TokenNameLEFT_SHIFT = 17,
+		TokenNameRIGHT_SHIFT = 10,
 		TokenNameUNSIGNED_RIGHT_SHIFT = 11,
 		TokenNamePLUS_EQUAL = 84,
 		TokenNameMINUS_EQUAL = 85,
@@ -125,7 +125,7 @@ public interface TerminalTokens {
 		TokenNameOR = 22,
 		TokenNameTWIDDLE = 67,
 		TokenNameDIVIDE = 6,
-		TokenNameGREATER = 12,
+		TokenNameGREATER = 13,
 		TokenNameLESS = 7,
 		TokenNameLPAREN = 28,
 		TokenNameRPAREN = 29,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc
index 080da2b..2980869 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser1.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc
index 163c492..a70d94a 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser14.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc
index 17fb4e0..9db6f36 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser15.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc
index 46d3c13..a63cafd 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser16.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc
index eeb8a00..90c3c23 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser17.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc
index f8b7256..58523c2 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser18.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
index 1c3f8b4..5e5050e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser19.rsc
@@ -1 +1,2 @@
-ggFFFEEhAAA!FfAeAIEJJE!EEbGG_!H!Ab!!!!55
\ No newline at end of file
+ggFFFEEhAAA!FfAeAIE
+JJE!EEbGG_!H!Ab!!!!55
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc
index 0862e26..efbc2b6 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser2.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc
index c126bac..04fc942 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser20.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc
index f8f62ef..1786402 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser21.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc
index ae6e82a..3d242f9 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser22.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc
index 7934fbb..c8ed5e8 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser24.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc
index 7280cc1..a6090e9 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser3.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc
index f8d1886..09b3f20 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser4.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc
index 8d6bae8..b236c58 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser5.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc
index 75adf54..80ab4d0 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser6.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc
index 5b7221f..2134cc4 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser7.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc
index 6aa0ddd..020cb66 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser8.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc
index a79a960..3aeeaae 100644
Binary files a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc and b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/parser9.rsc differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
index b04c168..da88fde 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/readableNames.properties
@@ -245,6 +245,7 @@ ShiftExpression=Expression
 ShiftExpression_NotName=Expression
 SimpleName=SimpleName
 SingleMemberAnnotation=SingleMemberAnnotation
+SingleMemberAnnotationMemberValue=MemberValue
 SingleStaticImportDeclaration=SingleStaticImportDeclaration
 SingleStaticImportDeclarationName=SingleStaticImportDeclarationName
 SingleTypeImportDeclaration=SingleTypeImportDeclaration
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 146efb5..df8bb11 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -4348,18 +4348,18 @@ class ASTConverter {
 
 	protected void setModifiers(AnnotationTypeDeclaration typeDecl, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
 		this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
-		this.setModifiers(typeDecl, typeDeclaration.annotations);
+		this.setModifiers(typeDecl, typeDeclaration.annotations, typeDeclaration.sourceStart);
 	}
 	
 	protected void setModifiers(AnnotationTypeMemberDeclaration annotationTypeMemberDecl, org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration annotationTypeMemberDeclaration) {
 		this.scanner.resetTo(annotationTypeMemberDeclaration.declarationSourceStart, annotationTypeMemberDeclaration.sourceStart);
-		this.setModifiers(annotationTypeMemberDecl, annotationTypeMemberDeclaration.annotations);
+		this.setModifiers(annotationTypeMemberDecl, annotationTypeMemberDeclaration.annotations, annotationTypeMemberDeclaration.sourceStart);
 	}
 
 	/**
 	 * @param bodyDeclaration
 	 */
-	protected void setModifiers(BodyDeclaration bodyDeclaration, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations) {
+	protected void setModifiers(BodyDeclaration bodyDeclaration, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
 		this.scanner.tokenizeWhiteSpace = false;
 		try {
 			int token;
@@ -4405,7 +4405,7 @@ class ASTConverter {
 						if (annotations != null && indexInAnnotations < annotations.length) {
 							org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 							modifier = convert(annotation);
-							this.scanner.resetTo(annotation.declarationSourceEnd + 1, this.compilationUnitSourceLength);
+							this.scanner.resetTo(annotation.declarationSourceEnd + 1, modifiersEnd);
 						}
 						break;
 					case TerminalTokens.TokenNameCOMMENT_BLOCK :
@@ -4413,7 +4413,8 @@ class ASTConverter {
 					case TerminalTokens.TokenNameCOMMENT_JAVADOC :
 						break;
 					default :
-						return;
+						// there is some syntax errors in source code
+						break;
 				}
 				if (modifier != null) {
 					bodyDeclaration.modifiers().add(modifier);
@@ -4426,7 +4427,7 @@ class ASTConverter {
 
 	protected void setModifiers(EnumDeclaration enumDeclaration, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration enumDeclaration2) {
 		this.scanner.resetTo(enumDeclaration2.declarationSourceStart, enumDeclaration2.sourceStart);
-		this.setModifiers(enumDeclaration, enumDeclaration2.annotations);
+		this.setModifiers(enumDeclaration, enumDeclaration2.annotations, enumDeclaration2.sourceStart);
 	}
 	
 	protected void setModifiers(EnumConstantDeclaration enumConstantDeclaration, org.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration) {
@@ -4439,7 +4440,7 @@ class ASTConverter {
 				break;
 			case AST.JLS3 :
 				this.scanner.resetTo(fieldDeclaration.declarationSourceStart, fieldDeclaration.sourceStart);
-				this.setModifiers(enumConstantDeclaration, fieldDeclaration.annotations);
+				this.setModifiers(enumConstantDeclaration, fieldDeclaration.annotations, fieldDeclaration.sourceStart);
 		}
 	}
 	
@@ -4457,7 +4458,7 @@ class ASTConverter {
 				break;
 			case AST.JLS3 :
 				this.scanner.resetTo(fieldDecl.declarationSourceStart, fieldDecl.sourceStart);
-				this.setModifiers(fieldDeclaration, fieldDecl.annotations);
+				this.setModifiers(fieldDeclaration, fieldDecl.annotations, fieldDecl.sourceStart);
 		}
 	}
 	
@@ -4475,7 +4476,7 @@ class ASTConverter {
 				break;
 			case AST.JLS3 :
 				this.scanner.resetTo(oldInitializer.declarationSourceStart, oldInitializer.bodyStart);
-				this.setModifiers(initializer, oldInitializer.annotations);
+				this.setModifiers(initializer, oldInitializer.annotations, oldInitializer.bodyStart);
 		}
 	}
 	/**
@@ -4492,7 +4493,7 @@ class ASTConverter {
 				break;
 			case AST.JLS3 :
 				this.scanner.resetTo(methodDeclaration.declarationSourceStart, methodDeclaration.sourceStart);
-				this.setModifiers(methodDecl, methodDeclaration.annotations);
+				this.setModifiers(methodDecl, methodDeclaration.annotations, methodDeclaration.sourceStart);
 		}
 	}
 
@@ -4667,7 +4668,7 @@ class ASTConverter {
 				break;
 			case AST.JLS3 :
 				this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
-				this.setModifiers(typeDecl, typeDeclaration.annotations);
+				this.setModifiers(typeDecl, typeDeclaration.annotations, typeDeclaration.sourceStart);
 		}
 	}
 	
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
index 5553e8f..aa959c3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
@@ -183,8 +183,24 @@ class ASTRecoveryPropagator extends DefaultASTVisitor {
 		
 		// is inside diet part of the ast
 		if(this.blockDepth < 1) {
-			if(this.markIncludedProblems(start, end)) {
-				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+			switch (node.getNodeType()) {
+				case ASTNode.ANNOTATION_TYPE_DECLARATION:
+				case ASTNode.COMPILATION_UNIT:
+				case ASTNode.ENUM_DECLARATION:
+				case ASTNode.FIELD_DECLARATION:
+				case ASTNode.IMPORT_DECLARATION:
+				case ASTNode.INITIALIZER:
+				case ASTNode.METHOD_DECLARATION:
+				case ASTNode.PACKAGE_DECLARATION:
+				case ASTNode.TYPE_DECLARATION:
+				case ASTNode.MARKER_ANNOTATION:
+				case ASTNode.NORMAL_ANNOTATION:
+				case ASTNode.SINGLE_MEMBER_ANNOTATION:
+				case ASTNode.BLOCK:
+					if(this.markIncludedProblems(start, end)) {
+						node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+					}
+					break;
 			}
 		} else {			
 			this.markIncludedProblems(start, end);
@@ -396,4 +412,35 @@ class ASTRecoveryPropagator extends DefaultASTVisitor {
 			}
 		}
 	}
+	
+	public void endVisit(NormalAnnotation node) {
+		endVisitNode(node);
+		// is inside diet part of the ast
+		if(this.blockDepth < 1) {
+			List values = node.values();
+			int size = values.size();
+			if (size > 0) {
+				MemberValuePair lastMemberValuePair = (MemberValuePair)values.get(size - 1);
+				
+				int annotationEnd = node.getStartPosition() + node.getLength();
+				int lastMemberValuePairEnd = lastMemberValuePair.getStartPosition() + lastMemberValuePair.getLength();
+				if (annotationEnd == lastMemberValuePairEnd) {
+					node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+				}
+			}
+		}
+	}
+	
+	public void endVisit(SingleMemberAnnotation node) {
+		endVisitNode(node);
+		// is inside diet part of the ast
+		if(this.blockDepth < 1) {
+			Expression value = node.getValue();
+			int annotationEnd = node.getStartPosition() + node.getLength();
+			int valueEnd = value.getStartPosition() + value.getLength();
+			if (annotationEnd == valueEnd) {
+				node.setFlags(node.getFlags() | ASTNode.RECOVERED);
+			}
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/grammar/java.g b/org.eclipse.jdt.core/grammar/java.g
index 5b73ab7..19389d8 100644
--- a/org.eclipse.jdt.core/grammar/java.g
+++ b/org.eclipse.jdt.core/grammar/java.g
@@ -2233,7 +2233,12 @@ MarkerAnnotation ::= AnnotationName
 /:$readableName MarkerAnnotation:/
 /:$compliance 1.5:/
 
-SingleMemberAnnotation ::= AnnotationName '(' MemberValue ')'
+SingleMemberAnnotationMemberValue ::= MemberValue
+/.$putCase consumeSingleMemberAnnotationMemberValue() ; $break ./
+/:$readableName MemberValue:/
+/:$compliance 1.5:/
+
+SingleMemberAnnotation ::= AnnotationName '(' SingleMemberAnnotationMemberValue ')'
 /.$putCase consumeSingleMemberAnnotation() ; $break ./
 /:$readableName SingleMemberAnnotation:/
 /:$compliance 1.5:/
