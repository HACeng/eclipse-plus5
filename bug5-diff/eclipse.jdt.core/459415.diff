commit 8a363fec98aa054021f5fff9915e285ca912d6f6
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Feb 23 17:42:11 2015 +0530

    BETA_JAVA9 - Bug 459415 - [1.9] Support modular run time images in JDT
    
    Change-Id: I29899e55ef32afd5b949a882fa1be0723f5a2df6

6	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
1	1	org.eclipse.jdt.core/.classpath
3	3	org.eclipse.jdt.core/.settings/org.eclipse.jdt.core.prefs
1	1	org.eclipse.jdt.core/META-INF/MANIFEST.MF
51	15	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
6	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java
7	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
19	6	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocTagConstants.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
134	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
26	15	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
5	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryDirectory.java
32	21	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
11	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
44	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
21	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
65	23	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
17	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index d47c9cc..eeb86e9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
@@ -8909,7 +8913,7 @@ public void test217_warn_options() {
 // white-box test for internal API
 public void test218_batch_classpath_apis() {
 	assertFalse("path should be absolute",
-		new ClasspathJar(new File("relative.jar"), true, null, null).
+		new ClasspathJar(new File("relative.jar"), true, null, null, false).
 		getPath().indexOf(File.separator) == -1);
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=214731
@@ -8917,7 +8921,7 @@ public void test218_batch_classpath_apis() {
 public void test219_batch_classpath_apis() {
 	assertFalse("path should be absolute",
 		CharOperation.indexOf('/',
-			new ClasspathJar(new File("relative.jar"), true, null, null).
+			new ClasspathJar(new File("relative.jar"), true, null, null, false).
 			normalizedPath()) == -1);
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=210524
diff --git a/org.eclipse.jdt.core/.classpath b/org.eclipse.jdt.core/.classpath
index 0e33229..e816e37 100644
--- a/org.eclipse.jdt.core/.classpath
+++ b/org.eclipse.jdt.core/.classpath
@@ -9,7 +9,7 @@
 	<classpathentry kind="src" path="formatter"/>
 	<classpathentry kind="src" path="model"/>
 	<classpathentry kind="src" path="search"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/org.eclipse.jdt.core/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.core/.settings/org.eclipse.jdt.core.prefs
index 46e3099..ccddd6b 100644
--- a/org.eclipse.jdt.core/.settings/org.eclipse.jdt.core.prefs
+++ b/org.eclipse.jdt.core/.settings/org.eclipse.jdt.core.prefs
@@ -24,9 +24,9 @@ org.eclipse.jdt.core.compiler.annotation.nonnullbydefault=org.eclipse.jdt.annota
 org.eclipse.jdt.core.compiler.annotation.nullable=org.eclipse.jdt.annotation.Nullable
 org.eclipse.jdt.core.compiler.annotation.nullanalysis=disabled
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.compliance=1.7
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
@@ -129,7 +129,7 @@ org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
 org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.compiler.source=1.7
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
diff --git a/org.eclipse.jdt.core/META-INF/MANIFEST.MF b/org.eclipse.jdt.core/META-INF/MANIFEST.MF
index 75da035..700eb9c 100644
--- a/org.eclipse.jdt.core/META-INF/MANIFEST.MF
+++ b/org.eclipse.jdt.core/META-INF/MANIFEST.MF
@@ -61,6 +61,6 @@ Require-Bundle: org.eclipse.core.resources;bundle-version="[3.3.0,4.0.0)",
  org.eclipse.core.filesystem;bundle-version="[1.0.0,2.0.0)",
  org.eclipse.text;bundle-version="[3.1.0,4.0.0)",
  org.eclipse.team.core;bundle-version="[3.1.0,4.0.0)";resolution:=optional
-Bundle-RequiredExecutionEnvironment: JavaSE-1.6
+Bundle-RequiredExecutionEnvironment: JavaSE-1.7
 Eclipse-ExtensibleAPI: true
 Bundle-ActivationPolicy: lazy
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index 8d56c0a..55991f0 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -16,6 +20,8 @@ package org.eclipse.jdt.internal.compiler.batch;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.file.FileVisitResult;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Hashtable;
@@ -24,6 +30,7 @@ import java.util.List;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
@@ -43,11 +50,13 @@ protected ZipFile annotationZipFile;
 protected boolean closeZipFileAtEnd;
 protected Hashtable packageCache;
 protected List<String> annotationPaths;
+protected boolean isJimage;
 
 public ClasspathJar(File file, boolean closeZipFileAtEnd,
-		AccessRuleSet accessRuleSet, String destinationPath) {
+		AccessRuleSet accessRuleSet, String destinationPath, boolean jimage) {
 	super(accessRuleSet, destinationPath);
 	this.file = file;
+	this.isJimage = jimage;
 	this.closeZipFileAtEnd = closeZipFileAtEnd;
 }
 
@@ -77,7 +86,7 @@ public List fetchLinkedJars(FileSystem.ClasspathSectionProblemReporter problemRe
 				int lastSeparator = directoryPath.lastIndexOf(File.separatorChar);
 				directoryPath = directoryPath.substring(0, lastSeparator + 1); // potentially empty (see bug 214731)
 				while (calledFilesIterator.hasNext()) {
-					result.add(new ClasspathJar(new File(directoryPath + (String) calledFilesIterator.next()), this.closeZipFileAtEnd, this.accessRuleSet, this.destinationPath));
+					result.add(new ClasspathJar(new File(directoryPath + (String) calledFilesIterator.next()), this.closeZipFileAtEnd, this.accessRuleSet, this.destinationPath, false));
 				}
 			}
 		}
@@ -102,7 +111,12 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 		return null; // most common case
 
 	try {
-		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
+		ClassFileReader reader = null;
+		if (this.isJimage) {
+			reader = ClassFileReader.readFromJimage(this.file.getPath(), qualifiedBinaryFileName);
+		} else {
+			reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
+		}
 		if (reader != null) {
 			if (this.annotationPaths != null) {
 				String qualifiedClassName = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length()-SuffixConstants.EXTENSION_CLASS.length()-1);
@@ -164,29 +178,51 @@ public char[][][] findTypeNames(String qualifiedPackageName) {
 	return null;
 }
 public void initialize() throws IOException {
-	if (this.zipFile == null) {
+	if (this.zipFile == null && !this.isJimage) {
 		this.zipFile = new ZipFile(this.file);
 	}
 }
+
+protected void addToPackageCache(String fileName, boolean endsWithSep) {
+	int last = endsWithSep ? fileName.length() : fileName.lastIndexOf('/');
+	while (last > 0) {
+		// extract the package name
+		String packageName = fileName.substring(0, last);
+		if (this.packageCache.containsKey(packageName))
+			return;
+		this.packageCache.put(packageName, packageName);
+		last = packageName.lastIndexOf('/');
+	}
+}
 public boolean isPackage(String qualifiedPackageName) {
 	if (this.packageCache != null)
 		return this.packageCache.containsKey(qualifiedPackageName);
 
 	this.packageCache = new Hashtable(41);
 	this.packageCache.put(Util.EMPTY_STRING, Util.EMPTY_STRING);
+	if (this.isJimage) {
+		try {
+			Util.walkModuleImage(this.file, new Util.JimageVisitor<java.nio.file.Path>() {
 
-	nextEntry : for (Enumeration e = this.zipFile.entries(); e.hasMoreElements(); ) {
-		String fileName = ((ZipEntry) e.nextElement()).getName();
+				@Override
+				public FileVisitResult visitPackage(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
+					addToPackageCache(dir.toString(), true);
+					return FileVisitResult.CONTINUE;
+				}
 
-		// add the package name & all of its parent packages
-		int last = fileName.lastIndexOf('/');
-		while (last > 0) {
-			// extract the package name
-			String packageName = fileName.substring(0, last);
-			if (this.packageCache.containsKey(packageName))
-				continue nextEntry;
-			this.packageCache.put(packageName, packageName);
-			last = packageName.lastIndexOf('/');
+				@Override
+				public FileVisitResult visitFile(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
+					return FileVisitResult.CONTINUE;
+				}
+
+			});
+		} catch (JavaModelException e) {
+			e.printStackTrace();
+		}
+	} else {
+		for (Enumeration e = this.zipFile.entries(); e.hasMoreElements(); ) {
+			String fileName = ((ZipEntry) e.nextElement()).getName();
+			addToPackageCache(fileName, false);
 		}
 	}
 	return this.packageCache.containsKey(qualifiedPackageName);
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java
index fc94aa1..69c479c 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2010 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -25,7 +29,7 @@ public class ClasspathSourceJar extends ClasspathJar {
 	public ClasspathSourceJar(File file, boolean closeZipFileAtEnd,
 			AccessRuleSet accessRuleSet, String encoding,
 			String destinationPath) {
-		super(file, closeZipFileAtEnd, accessRuleSet, destinationPath);
+		super(file, closeZipFileAtEnd, accessRuleSet, destinationPath, false);
 		this.encoding = encoding;
 	}
 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index bcc420b..67278fa 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -175,7 +179,8 @@ public static Classpath getClasspath(String classpathName, String encoding,
 						convertPathSeparators(destinationPath));
 		}
 	} else {
-		if (Util.isPotentialZipArchive(classpathName)) {
+		int format = Util.archiveFormat(classpathName);
+		if (format > -1) {
 			if (isSourceOnly) {
 				// source only mode
 				result = new ClasspathSourceJar(file, true, accessRuleSet,
@@ -185,7 +190,7 @@ public static Classpath getClasspath(String classpathName, String encoding,
 						convertPathSeparators(destinationPath));
 			} else if (destinationPath == null) {
 				// class file only mode
-				result = new ClasspathJar(file, true, accessRuleSet, null);
+				result = new ClasspathJar(file, true, accessRuleSet, null, (format == Util.JIMAGE_FILE));
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 5abfda0..cf7f278 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tom Tromey - Contribution for bug 125961
@@ -110,6 +114,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		private static final String CLASSPATH_FOLDER = "FOLDER"; //$NON-NLS-1$
 		private static final String CLASSPATH_ID = "id"; //$NON-NLS-1$
 		private static final String CLASSPATH_JAR = "JAR"; //$NON-NLS-1$
+		private static final String CLASSPATH_JIMAGE = "JIMAGE"; //$NON-NLS-1$
 		private static final String CLASSPATHS = "classpaths"; //$NON-NLS-1$
 		private static final String COMMAND_LINE_ARGUMENT = "argument"; //$NON-NLS-1$
 		private static final String COMMAND_LINE_ARGUMENTS = "command_line"; //$NON-NLS-1$
@@ -505,10 +510,17 @@ public class Main implements ProblemSeverities, SuffixConstants {
 						File f = new File(classpath);
 						String id = null;
 						if (f.isFile()) {
-							if (Util.isPotentialZipArchive(classpath)) {
-								id = Logger.CLASSPATH_JAR;
-							} else {
-								id = Logger.CLASSPATH_FILE;
+							int kind = Util.archiveFormat(classpath);
+							switch (kind) {
+								case Util.JIMAGE_FILE:
+									id = Logger.CLASSPATH_JIMAGE;
+									break;
+								case Util.ZIP_FILE:
+									id = Logger.CLASSPATH_JAR;
+									break;
+								default:
+									id = Logger.CLASSPATH_FILE;
+									break;
 							}
 						} else if (f.isDirectory()) {
 							id = Logger.CLASSPATH_FOLDER;
@@ -1396,7 +1408,7 @@ public static boolean compile(String[] commandLineArguments, PrintWriter outWrit
 public static File[][] getLibrariesFiles(File[] files) {
 	FilenameFilter filter = new FilenameFilter() {
 		public boolean accept(File dir, String name) {
-			return Util.isPotentialZipArchive(name);
+			return Util.archiveFormat(name) > -1;
 		}
 	};
 	final int filesLength = files.length;
@@ -1552,8 +1564,9 @@ protected void addNewEntry(ArrayList paths, String currentClasspathName,
 	if (NONE.equals(destPath)) {
 		destPath = NONE; // keep == comparison valid
 	}
+	
 	if (rejectDestinationPathOnJars && destPath != null &&
-			Util.isPotentialZipArchive(currentClasspathName)) {
+			Util.archiveFormat(currentClasspathName) > -1) {
 		throw new IllegalArgumentException(
 			this.bind("configure.unexpectedDestinationPathEntryFile", //$NON-NLS-1$
 						currentClasspathName));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 0e7bb06..c9546ba 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -114,6 +118,16 @@ public static ClassFileReader read(
 		return read(zip, filename, false);
 }
 
+public static ClassFileReader readFromJimage(
+		String jimge,
+		String filename)
+		throws ClassFormatException, java.io.IOException {
+
+		byte classFileBytes[] = Util.getClassfileContent(filename);
+		return new ClassFileReader(classFileBytes, filename.toCharArray());
+	}
+
+// TODO: Doesn't appear to be used anywhere. Revisit to remove.
 public static ClassFileReader read(
 	java.util.zip.ZipFile zip,
 	String filename,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocTagConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocTagConstants.java
index b1fde15..fd2762e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocTagConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocTagConstants.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -148,6 +152,8 @@ public interface JavadocTagConstants {
 		// since 1.7
 		{},
 		// since 1.8
+		{},
+		// since 1.9
 		{}
 	};
 	public static final char[][][] INLINE_TAGS = {
@@ -168,6 +174,8 @@ public interface JavadocTagConstants {
 		// since 1.7
 		{},
 		// since 1.8
+		{},
+		// since 1.9
 		{}
 	};
 	public final static int INLINE_TAGS_LENGTH = INLINE_TAGS.length;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
index 61b919b..c21d1e1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -15,6 +19,8 @@ public interface SuffixConstants {
 	public final static String EXTENSION_CLASS = "CLASS"; //$NON-NLS-1$
 	public final static String EXTENSION_java = "java"; //$NON-NLS-1$
 	public final static String EXTENSION_JAVA = "JAVA"; //$NON-NLS-1$
+	public final static String EXTENSION_jimage = "jimage"; //$NON-NLS-1$
+	public final static String EXTENSION_JIMAGE = "JIMAGE"; //$NON-NLS-1$
 
 	public final static String SUFFIX_STRING_class = "." + EXTENSION_class; //$NON-NLS-1$
 	public final static String SUFFIX_STRING_CLASS = "." + EXTENSION_CLASS; //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 59da8ab..015b866 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -24,12 +24,21 @@ import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.nio.file.DirectoryStream;
+import java.nio.file.FileSystems;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
+import java.nio.file.Files;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.HashSet;
 import java.util.List;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -233,6 +242,10 @@ public class Util implements SuffixConstants {
 	public static final String EMPTY_STRING = new String(CharOperation.NO_CHAR);
 	public static final int[] EMPTY_INT_ARRAY= new int[0];
 
+	private static URI JRT_URI = URI.create("jrt:/"); //$NON-NLS-1$
+
+	private static String JAVA_BASE_PATH = "java.base"; //$NON-NLS-1$
+
 	/**
 	 * Build all the directories and subdirectories corresponding to the packages names
 	 * into the directory specified in parameters.
@@ -698,6 +711,72 @@ public class Util implements SuffixConstants {
 			}
 		}
 	}
+	/**
+	 * Given the path of a modular image file, this method walks the archive content and
+	 * notifies the supplied visitor about packages and files visited.
+	 * Note: At the moment, there's no way to open any arbitrary image. Currently,
+	 * this method uses the JRT file system provider to look inside the JRE.
+	 *   
+	 * @param image a java.io.File handle to the JRT image.
+	 * @param visitor an instance of JimageVisitor to be notified of the entries in the JRT image.
+	 * @throws JavaModelException
+	 */
+	public static void walkModuleImage(File image, final JimageVisitor<java.nio.file.Path> visitor) throws JavaModelException {
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
+		Iterable<java.nio.file.Path> roots = fs.getRootDirectories();
+		java.nio.file.Path basePath = null;
+		roots: for (java.nio.file.Path path : roots) {
+			try (DirectoryStream<java.nio.file.Path> stream = Files.newDirectoryStream(path)) {
+				for (java.nio.file.Path subdir: stream) {
+					if (subdir.toString().indexOf(JAVA_BASE_PATH) != -1) {
+						basePath = subdir;
+						break roots;
+					}
+			    }
+			} catch (Exception e) {
+				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+			}
+		}
+		try {
+			if (basePath != null) {
+				final java.nio.file.Path base = basePath;
+				Files.walkFileTree(basePath, new FileVisitor<java.nio.file.Path>() {
+
+					@Override
+					public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
+						return visitor.visitPackage(base.relativize(dir), attrs);
+					}
+
+					@Override
+					public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
+						return visitor.visitFile(base.relativize(file), attrs);
+					}
+
+					@Override
+					public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
+						return FileVisitResult.CONTINUE;
+					}
+
+					@Override
+					public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc) throws IOException {
+						return FileVisitResult.CONTINUE;
+					}
+				});
+			}
+		} catch (IOException e) {
+			throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+		}
+	}
+
+	public static InputStream getContentFromJimage(String fileName) throws IOException {
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
+		return Files.newInputStream(fs.getPath(JAVA_BASE_PATH, fileName));
+	}
+
+	public static byte[] getClassfileContent(String fileName) throws IOException {
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
+		return Files.readAllBytes(fs.getPath(JAVA_BASE_PATH, fileName));
+	}
 	public static int hashCode(Object[] array) {
 		int prime = 31;
 		if (array == null) {
@@ -741,6 +820,54 @@ public class Util implements SuffixConstants {
 		}
 		return true; // it is neither a ".java" file nor a ".class" file, so this is a potential archive name
 	}
+	
+	public static final int ZIP_FILE = 0;
+	
+	public static final int JIMAGE_FILE = 1;
+	
+	/**
+	 * Returns whether the given name is potentially a zip archive file name
+	 * (it has a file extension and it is not ".java" nor ".class")
+	 */
+	public final static int archiveFormat(String name) {
+		int lastDot = name.lastIndexOf('.');
+		if (lastDot == -1)
+			return -1; // no file extension, it cannot be a zip archive name
+		if (name.lastIndexOf(File.separatorChar) > lastDot)
+			return -1; // dot was before the last file separator, it cannot be a zip archive name
+		int length = name.length();
+		int extensionLength = length - lastDot - 1;
+		
+		if (extensionLength == EXTENSION_jimage.length()) {
+			for (int i = extensionLength-1; i >=0; i--) {
+				if (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_jimage.charAt(i)) {
+					break;
+				}
+				if (i == 0) {
+					return JIMAGE_FILE;
+				}
+			}
+		}
+		if (extensionLength == EXTENSION_java.length()) {
+			for (int i = extensionLength-1; i >=0; i--) {
+				if (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_java.charAt(i)) {
+					break; // not a ".java" file, check ".class" file case below
+				}
+				if (i == 0) {
+					return -1; // it is a ".java" file, it cannot be a zip archive name
+				}
+			}
+		}
+		if (extensionLength == EXTENSION_class.length()) {
+			for (int i = extensionLength-1; i >=0; i--) {
+				if (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_class.charAt(i)) {
+					return ZIP_FILE; // not a ".class" file, so this is a potential archive name
+				}
+			}
+			return -1; // it is a ".class" file, it cannot be a zip archive name
+		}
+		return ZIP_FILE; // it is neither a ".java" file nor a ".class" file, so this is a potential archive name
+	}
 
 	/**
 	 * Returns true iff str.toLowerCase().endsWith(".class")
@@ -1621,4 +1748,11 @@ public class Util implements SuffixConstants {
 		}
 	}
 
+	public interface JimageVisitor<T> {
+
+		public FileVisitResult visitPackage(T dir, BasicFileAttributes attrs) throws IOException;
+
+		public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException;
+
+	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index f2d1208..a599fdb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -320,15 +324,11 @@ public byte[] getBytes() throws JavaModelException {
 	JavaElement pkg = (JavaElement) getParent();
 	if (pkg instanceof JarPackageFragment) {
 		JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
-		ZipFile zip = null;
 		try {
-			zip = root.getJar();
 			String entryName = Util.concatWith(((PackageFragment) pkg).names, getElementName(), '/');
-			ZipEntry ze = zip.getEntry(entryName);
-			if (ze != null) {
-				return org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
-			}
-			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));
+			return getClassFileContent(root, entryName);
+			// BETA_JAVA9 - The below exception is not thrown in new scheme of things. Could cause issues?
+//			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));
 		} catch (IOException ioe) {
 			throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
 		} catch (CoreException e) {
@@ -337,24 +337,36 @@ public byte[] getBytes() throws JavaModelException {
 			} else {
 				throw new JavaModelException(e);
 			}
-		} finally {
-			JavaModelManager.getJavaModelManager().closeZipFile(zip);
 		}
 	} else {
 		IFile file = (IFile) resource();
 		return Util.getResourceContentsAsByteArray(file);
 	}
 }
+private byte[] getClassFileContent(JarPackageFragmentRoot root, String className) throws CoreException, IOException {
+	byte[] contents = null;
+	if (root.isJimage) {
+		contents = org.eclipse.jdt.internal.compiler.util.Util.getClassfileContent(className);
+	} else {
+		ZipFile zip = root.getJar();
+		try {
+			ZipEntry ze = zip.getEntry(className);
+			if (ze != null) {
+				contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
+			}
+		} finally {
+			JavaModelManager.getJavaModelManager().closeZipFile(zip);
+		}
+	}
+	return contents;
+}
 private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyInitialize) throws CoreException, IOException, ClassFormatException {
 	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
-	ZipFile zip = null;
 	ZipFile annotationZip = null;
 	try {
-		zip = root.getJar();
 		String entryName = Util.concatWith(pkg.names, getElementName(), '/');
-		ZipEntry ze = zip.getEntry(entryName);
-		if (ze != null) {
-			byte contents[] = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
+		byte[] contents = getClassFileContent(root, entryName);
+		if (contents != null) {
 			String fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
 			ClassFileReader reader = new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
 			if (root.getKind() == IPackageFragmentRoot.K_BINARY) {
@@ -371,7 +383,6 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 			return reader;
 		}
 	} finally {
-		JavaModelManager.getJavaModelManager().closeZipFile(zip);
 		JavaModelManager.getJavaModelManager().closeZipFile(annotationZip);
 	}
 	return null;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryDirectory.java
index cb04892..de0657c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryDirectory.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
index 21af1eb..0f7112e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -30,36 +34,43 @@ import org.eclipse.jdt.internal.compiler.util.Util;
  */
 public class JarEntryFile  extends JarEntryResource {
 	private static final IJarEntryResource[] NO_CHILDREN = new IJarEntryResource[0];
-
-	public JarEntryFile(String simpleName) {
-		super(simpleName);
+	public JarEntryFile(String simpleName, boolean isJimage) {
+		super(simpleName, isJimage);
 	}
 
 	public JarEntryResource clone(Object newParent) {
-		JarEntryFile file = new JarEntryFile(this.simpleName);
+		JarEntryFile file = new JarEntryFile(this.simpleName, this.isJimage);
 		file.setParent(newParent);
 		return file;
 	}
 
 	public InputStream getContents() throws CoreException {
-		ZipFile zipFile = null;
-		try {
-			zipFile = getZipFile();
-			if (JavaModelManager.ZIP_ACCESS_VERBOSE) {
-				System.out.println("(" + Thread.currentThread() + ") [JarEntryFile.getContents()] Creating ZipFile on " +zipFile.getName()); //$NON-NLS-1$	//$NON-NLS-2$
+		if (this.isJimage) {
+			try {
+				return Util.getContentFromJimage(getEntryName());
+			} catch (IOException e) {
+				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
 			}
-			String entryName = getEntryName();
-			ZipEntry zipEntry = zipFile.getEntry(entryName);
-			if (zipEntry == null){
-				throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, entryName));
+		} else {
+			ZipFile zipFile = null;
+			try {
+				zipFile = getZipFile();
+				if (JavaModelManager.ZIP_ACCESS_VERBOSE) {
+					System.out.println("(" + Thread.currentThread() + ") [JarEntryFile.getContents()] Creating ZipFile on " +zipFile.getName()); //$NON-NLS-1$	//$NON-NLS-2$
+				}
+				String entryName = getEntryName();
+				ZipEntry zipEntry = zipFile.getEntry(entryName);
+				if (zipEntry == null){
+					throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, entryName));
+				}
+				byte[] contents = Util.getZipEntryByteContent(zipEntry, zipFile);
+				return new ByteArrayInputStream(contents);
+			} catch (IOException e){
+				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+			} finally {
+				// avoid leaking ZipFiles
+				JavaModelManager.getJavaModelManager().closeZipFile(zipFile);
 			}
-			byte[] contents = Util.getZipEntryByteContent(zipEntry, zipFile);
-			return new ByteArrayInputStream(contents);
-		} catch (IOException e){
-			throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
-		} finally {
-			// avoid leaking ZipFiles
-			JavaModelManager.getJavaModelManager().closeZipFile(zipFile);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
index 57a2775..c3d7c7f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -25,9 +29,15 @@ public abstract class JarEntryResource  extends PlatformObject implements IJarEn
 
 	protected Object parent;
 	protected String simpleName;
+	protected boolean isJimage;
 
 	public JarEntryResource(String simpleName) {
+		this(simpleName, false);
+	}
+
+	public JarEntryResource(String simpleName, boolean isJimage) {
 		this.simpleName = simpleName;
+		this.isJimage = isJimage;
 	}
 
 	public abstract JarEntryResource clone(Object newParent);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
index 9066ec0..3a937d2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
@@ -55,7 +55,7 @@ protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm,
 	fragInfo.setChildren(computeChildren(entries[0/*class files*/]));
 
 	// compute non-Java resources
-	fragInfo.setNonJavaResources(computeNonJavaResources(entries[1/*non Java resources*/]));
+	fragInfo.setNonJavaResources(computeNonJavaResources(entries[1/*non Java resources*/], root.isJimage));
 
 	newElements.put(this, fragInfo);
 	return true;
@@ -78,7 +78,7 @@ private IJavaElement[] computeChildren(ArrayList namesWithoutExtension) {
 /**
  * Compute all the non-java resources according to the given entry names.
  */
-private Object[] computeNonJavaResources(ArrayList entryNames) {
+private Object[] computeNonJavaResources(ArrayList entryNames, boolean isJimage) {
 	int length = entryNames.size();
 	if (length == 0)
 		return JavaElementInfo.NO_NON_JAVA_RESOURCES;
@@ -95,7 +95,7 @@ private Object[] computeNonJavaResources(ArrayList entryNames) {
 				// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=222665
 				continue;
 			}
-			JarEntryFile file = new JarEntryFile(filePath.lastSegment());
+			JarEntryFile file = new JarEntryFile(filePath.lastSegment(), isJimage);
 			jarEntries.put(childPath, file);
 			if (childPath.segmentCount() == 1) {
 				file.setParent(this);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 78a66b4..f0c68a5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -1,16 +1,24 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
+import java.io.IOException;
 import java.net.URL;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.*;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
@@ -49,6 +57,12 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected final IPath jarPath;
 
 	/**
+	 * Whether this represents a JIMAGE format.
+	 * TODO: Might make sense to introduce a new type of PackageFragmentRoot
+	 */
+	protected final boolean isJimage;
+
+	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
 	 * based on a JAR file that is not contained in a <code>IJavaProject</code> and
 	 * does not have an associated <code>IResource</code>.
@@ -56,6 +70,7 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected JarPackageFragmentRoot(IPath externalJarPath, JavaProject project) {
 		super(null, project);
 		this.jarPath = externalJarPath;
+		this.isJimage = JavaModelManager.isJimage(externalJarPath);
 	}
 	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
@@ -64,6 +79,7 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected JarPackageFragmentRoot(IResource resource, JavaProject project) {
 		super(resource, project);
 		this.jarPath = resource.getFullPath();
+		this.isJimage = JavaModelManager.isJimage(this.jarPath);
 	}
 
 	/**
@@ -72,23 +88,39 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	 * by the path of class files contained in the jar of this package fragment root.
 	 */
 	protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
-		HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
+		final HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
 		IJavaElement[] children;
 		ZipFile jar = null;
 		try {
 			Object file = JavaModel.getTarget(getPath(), true);
 			long level = Util.getJdkLevel(file);
-			String compliance = CompilerOptions.versionFromJdkLevel(level);
-			jar = getJar();
+			final String compliance = CompilerOptions.versionFromJdkLevel(level);
 
 			// always create the default package
 			rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });
 
-			for (Enumeration e= jar.entries(); e.hasMoreElements();) {
-				ZipEntry member= (ZipEntry) e.nextElement();
-				initRawPackageInfo(rawPackageInfo, member.getName(), member.isDirectory(), compliance);
-			}
+			if (this.isJimage) {
+				org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(getPath().toFile(),
+								new org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<Path>() {
+					@Override
+					public FileVisitResult visitPackage(Path dir, BasicFileAttributes attrs) throws IOException {
+						initRawPackageInfo(rawPackageInfo, dir.toString(), true, compliance);
+						return FileVisitResult.CONTINUE;
+					}
 
+					@Override
+					public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
+						initRawPackageInfo(rawPackageInfo, path.toString(), false, compliance);
+						return FileVisitResult.CONTINUE;
+					}
+				});
+			} else {
+				jar = getJar();
+				for (Enumeration e= jar.entries(); e.hasMoreElements();) {
+					ZipEntry member= (ZipEntry) e.nextElement();
+					initRawPackageInfo(rawPackageInfo, member.getName(), member.isDirectory(), compliance);
+				}
+			}
 			// loop through all of referenced packages, creating package fragments if necessary
 			// and cache the entry names in the rawPackageInfo table
 			children = new IJavaElement[rawPackageInfo.size()];
@@ -213,8 +245,10 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	public int hashCode() {
 		return this.jarPath.hashCode();
 	}
-	private void initRawPackageInfo(HashtableOfArrayToObject rawPackageInfo, String entryName, boolean isDirectory, String compliance) {
-		int lastSeparator = isDirectory ? entryName.length()-1 : entryName.lastIndexOf('/');
+	protected void initRawPackageInfo(HashtableOfArrayToObject rawPackageInfo, String entryName, boolean isDirectory, String compliance) {
+		if (entryName.length() == 0) return;
+		int lastSeparator = isDirectory ? (entryName.charAt(entryName.length() - 1) == '/' ? 
+						entryName.length()-1 : entryName.length() ) : entryName.lastIndexOf('/');
 		String[] pkgName = Util.splitOn('/', entryName, 0, lastSeparator);
 		String[] existing = null;
 		int length = pkgName.length;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index d7306e7..1ef42d7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Theodora Yeung (tyeung@bea.com) - ensure that JarPackageFragmentRoot make it into cache
@@ -240,6 +244,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	 */
 	public static final String MAX_COMPILED_UNITS_AT_ONCE = "maxCompiledUnitsAtOnce"; //$NON-NLS-1$
 
+	public static final String JIMAGE_EXT = "jimage"; //$NON-NLS-1$
+
 	/**
 	 * Special value used for recognizing ongoing initialization and breaking initialization cycles
 	 */
@@ -2624,7 +2630,22 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		return this.workspaceScope;
 	}
 
+	public static boolean isJimage(IPath path) {
+		if (path.getFileExtension() != null && path.getFileExtension().equalsIgnoreCase(JIMAGE_EXT)) {
+			return true;
+		}
+		return false;
+	}
+
+	public static boolean isJimage(String path) {
+		return isJimage(new Path(path));
+	}
+
 	public void verifyArchiveContent(IPath path) throws CoreException {
+		// TODO: We don't yet know how to open a jimage file given its path. So, simply don't attempt.
+		if (isJimage(path)) {
+			return;
+		}
 		if (isInvalidArchive(path)) {
 			throw new CoreException(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID, -1, Messages.status_IOException, new ZipException()));			
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index beba74d..6ec80c2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -209,7 +213,7 @@ protected boolean computeChildren(OpenableElementInfo info, IResource underlying
 }
 
 /**
- * Starting at this folder, create package fragments and add the fragments that are not exclused
+ * Starting at this folder, create package fragments and add the fragments that are not excluded
  * to the collection of children.
  *
  * @exception JavaModelException  The resource associated with this package fragment does not exist
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 1bda5fb..6d4f8b4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tal Lev-Ami - added package cache for zip files
@@ -15,7 +19,7 @@ package org.eclipse.jdt.internal.core.builder;
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.*;
-
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
@@ -23,9 +27,13 @@ import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.util.Util;
 
 import java.io.*;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.*;
 import java.util.zip.*;
 
@@ -46,6 +54,18 @@ static class PackageCacheEntry {
 
 static SimpleLookupTable PackageCache = new SimpleLookupTable();
 
+
+protected static void addToPackageSet(SimpleSet packageSet, String fileName, boolean endsWithSep) {
+	int last = endsWithSep ? fileName.length() : fileName.lastIndexOf('/');
+	while (last > 0) {
+		// extract the package name
+		String packageName = fileName.substring(0, last);
+		if (packageSet.addIfNotIncluded(packageName) == null)
+			return; // already existed
+		last = packageName.lastIndexOf('/');
+	}
+}
+
 /**
  * Calculate and cache the package list available in the zipFile.
  * @param jar The ClasspathJar to use
@@ -53,29 +73,41 @@ static SimpleLookupTable PackageCache = new SimpleLookupTable();
  */
 static SimpleSet findPackageSet(ClasspathJar jar) {
 	String zipFileName = jar.zipFilename;
-	long lastModified = jar.lastModified();
-	long fileSize = new File(zipFileName).length();
-	PackageCacheEntry cacheEntry = (PackageCacheEntry) PackageCache.get(zipFileName);
-	if (cacheEntry != null && cacheEntry.lastModified == lastModified && cacheEntry.fileSize == fileSize)
-		return cacheEntry.packageSet;
-
-	SimpleSet packageSet = new SimpleSet(41);
-	packageSet.add(""); //$NON-NLS-1$
-	nextEntry : for (Enumeration e = jar.zipFile.entries(); e.hasMoreElements(); ) {
-		String fileName = ((ZipEntry) e.nextElement()).getName();
-
-		// add the package name & all of its parent packages
-		int last = fileName.lastIndexOf('/');
-		while (last > 0) {
-			// extract the package name
-			String packageName = fileName.substring(0, last);
-			if (packageSet.addIfNotIncluded(packageName) == null)
-				continue nextEntry; // already existed
-			last = packageName.lastIndexOf('/');
+	final SimpleSet packageSet = new SimpleSet(41);
+	if (jar.isJimage) {
+		try {
+			org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(new File(jar.zipFilename), 
+					new org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<Path>() {
+
+				@Override
+				public FileVisitResult visitPackage(Path dir, BasicFileAttributes attrs) throws IOException {
+					ClasspathJar.addToPackageSet(packageSet, dir.toString(), true);
+					return FileVisitResult.CONTINUE;
+				}
+
+				@Override
+				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+					return FileVisitResult.CONTINUE;
+				}
+			});
+		} catch (JavaModelException e) {
+			e.printStackTrace();
 		}
+		// TODO: What about caching?
+	} else {
+		long lastModified = jar.lastModified();
+		long fileSize = new File(zipFileName).length();
+		PackageCacheEntry cacheEntry = (PackageCacheEntry) PackageCache.get(zipFileName);
+		if (cacheEntry != null && cacheEntry.lastModified == lastModified && cacheEntry.fileSize == fileSize)
+			return cacheEntry.packageSet;
+		packageSet.add(""); //$NON-NLS-1$
+		for (Enumeration e = jar.zipFile.entries(); e.hasMoreElements(); ) {
+			String fileName = ((ZipEntry) e.nextElement()).getName();
+			addToPackageSet(packageSet, fileName, false);
+		}
+		PackageCache.put(zipFileName, new PackageCacheEntry(lastModified, fileSize, packageSet));
 	}
 
-	PackageCache.put(zipFileName, new PackageCacheEntry(lastModified, fileSize, packageSet));
 	return packageSet;
 }
 
@@ -89,7 +121,9 @@ boolean closeZipFileAtEnd;
 SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
 String externalAnnotationPath;
+boolean isJimage;
 
+// TODO: This might need updates. At the moment, we are interested only in jimage files from JDK (which are external)
 ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.resource = resource;
 	try {
@@ -116,6 +150,7 @@ ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet,
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	this.isJimage = JavaModelManager.isJimage(zipFilename);
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
 }
@@ -165,7 +200,12 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	if (!isPackage(qualifiedPackageName)) return null; // most common case
 
 	try {
-		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
+		ClassFileReader reader = null;
+		if (this.isJimage) {
+			reader = ClassFileReader.readFromJimage(this.zipFilename, qualifiedBinaryFileName);
+		} else {
+			reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
+		}
 		if (reader != null) {
 			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
 			if (this.externalAnnotationPath != null) {
@@ -199,7 +239,9 @@ public boolean isPackage(String qualifiedPackageName) {
 		return this.knownPackageNames.includes(qualifiedPackageName);
 
 	try {
-		if (this.zipFile == null) {
+		if (this.isJimage) {
+			this.knownPackageNames = findPackageSet(this);
+		} else if (this.zipFile == null) {
 			if (org.eclipse.jdt.internal.core.JavaModelManager.ZIP_ACCESS_VERBOSE) {
 				System.out.println("(" + Thread.currentThread() + ") [ClasspathJar.isPackage(String)] Creating ZipFile on " + this.zipFilename); //$NON-NLS-1$	//$NON-NLS-2$
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
index 58a3820..fd0448f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -46,6 +50,7 @@ import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
@@ -845,13 +850,18 @@ public class Util {
 						}
 					}
 					if (path != null) {
-						jar = JavaModelManager.getJavaModelManager().getZipFile(path);
-						for (Enumeration e= jar.entries(); e.hasMoreElements();) {
-							ZipEntry member= (ZipEntry) e.nextElement();
-							String entryName= member.getName();
-							if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(entryName)) {
-								reader = ClassFileReader.read(jar, entryName);
-								break;
+						if (JavaModelManager.isJimage(path)) {
+							// TODO: Revisit: Possibly a wrong assumption depending on how things turn out in Java 9 world.
+							return ClassFileConstants.JDK1_9;
+						} else {
+							jar = JavaModelManager.getJavaModelManager().getZipFile(path);
+							for (Enumeration e= jar.entries(); e.hasMoreElements();) {
+								ZipEntry member= (ZipEntry) e.nextElement();
+								String entryName= member.getName();
+								if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(entryName)) {
+									reader = ClassFileReader.read(jar, entryName);
+									break;
+								}
 							}
 						}
 					}
commit 62ccd0ceb9247ef731ebdafebc3c6cb01343c680
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Mar 5 14:43:06 2015 +0530

    BETA_JAVA9 - Bug 459415 - Making the image visitor consider all modules,
    not just java.base.

1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
53	36	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
index 1bc40eb..1a3cbbc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
@@ -108,7 +108,7 @@ public interface ClassFileConstants {
 	int MAJOR_VERSION_1_6 = 50;
 	int MAJOR_VERSION_1_7 = 51;
 	int MAJOR_VERSION_1_8 = 52;
-	int MAJOR_VERSION_1_9 = 53; // This might change
+	int MAJOR_VERSION_1_9 = 52; // This needs change, but at the moment runtime don't support this class version.
 
 	int MINOR_VERSION_0 = 0;
 	int MINOR_VERSION_1 = 1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index a1c2a24..8860eb0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
@@ -719,10 +723,6 @@ public class CompilerOptions {
 				if (jdkLevel == ClassFileConstants.JDK1_8)
 					return VERSION_1_8;
 				break;
-			case ClassFileConstants.MAJOR_VERSION_1_9 :
-				if (jdkLevel == ClassFileConstants.JDK1_9)
-					return VERSION_1_9;
-				break;
 		}
 		return Util.EMPTY_STRING; // unknown version
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 015b866..6e19c96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -1,9 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -31,8 +35,10 @@ import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
 import java.nio.file.Files;
 import java.nio.file.attribute.BasicFileAttributes;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -246,6 +252,8 @@ public class Util implements SuffixConstants {
 
 	private static String JAVA_BASE_PATH = "java.base"; //$NON-NLS-1$
 
+	private static final Map<String, String> packageToModule = new HashMap<String, String>();
+
 	/**
 	 * Build all the directories and subdirectories corresponding to the packages names
 	 * into the directory specified in parameters.
@@ -724,58 +732,67 @@ public class Util implements SuffixConstants {
 	public static void walkModuleImage(File image, final JimageVisitor<java.nio.file.Path> visitor) throws JavaModelException {
 		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
 		Iterable<java.nio.file.Path> roots = fs.getRootDirectories();
-		java.nio.file.Path basePath = null;
-		roots: for (java.nio.file.Path path : roots) {
+		for (java.nio.file.Path path : roots) {
 			try (DirectoryStream<java.nio.file.Path> stream = Files.newDirectoryStream(path)) {
-				for (java.nio.file.Path subdir: stream) {
-					if (subdir.toString().indexOf(JAVA_BASE_PATH) != -1) {
-						basePath = subdir;
-						break roots;
-					}
+				for (final java.nio.file.Path subdir: stream) {
+					Files.walkFileTree(subdir, new FileVisitor<java.nio.file.Path>() {
+
+						@Override
+						public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
+							java.nio.file.Path relative = subdir.relativize(dir);
+							// This being a stop-gap solution, let's assume we don't have any types in a single level package
+							if (relative.getNameCount() <= 1) return FileVisitResult.CONTINUE;
+							cachePackage(relative.toString(), subdir.toString());
+							return visitor.visitPackage(relative, attrs);
+						}
+
+						@Override
+						public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
+							return visitor.visitFile(subdir.relativize(file), attrs);
+						}
+
+						@Override
+						public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
+							return FileVisitResult.CONTINUE;
+						}
+
+						@Override
+						public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc) throws IOException {
+							return FileVisitResult.CONTINUE;
+						}
+					});
 			    }
 			} catch (Exception e) {
 				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
 			}
 		}
-		try {
-			if (basePath != null) {
-				final java.nio.file.Path base = basePath;
-				Files.walkFileTree(basePath, new FileVisitor<java.nio.file.Path>() {
-
-					@Override
-					public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
-						return visitor.visitPackage(base.relativize(dir), attrs);
-					}
-
-					@Override
-					public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
-						return visitor.visitFile(base.relativize(file), attrs);
-					}
+	}
 
-					@Override
-					public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
-						return FileVisitResult.CONTINUE;
-					}
+	static void cachePackage(String packageName, String module) {
+		module = module.substring(1);
+		if (packageToModule.containsKey(packageName)) return;
+		packageToModule.put(packageName, module);
+	}
 
-					@Override
-					public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc) throws IOException {
-						return FileVisitResult.CONTINUE;
-					}
-				});
-			}
-		} catch (IOException e) {
-			throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
+	static String getModuleName(String fileName) {
+		int idx = fileName.lastIndexOf('/');
+		if (idx != -1) {
+			String module = packageToModule.get((fileName.substring(0, idx)));
+			if (module != null) return module;
 		}
+		return JAVA_BASE_PATH;
 	}
 
 	public static InputStream getContentFromJimage(String fileName) throws IOException {
 		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
-		return Files.newInputStream(fs.getPath(JAVA_BASE_PATH, fileName));
+		String module = getModuleName(fileName);
+		return Files.newInputStream(fs.getPath(module, fileName));
 	}
 
 	public static byte[] getClassfileContent(String fileName) throws IOException {
 		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
-		return Files.readAllBytes(fs.getPath(JAVA_BASE_PATH, fileName));
+		String module = getModuleName(fileName);
+		return Files.readAllBytes(fs.getPath(module, fileName));
 	}
 	public static int hashCode(Object[] array) {
 		int prime = 31;
