commit 55099d2c60113e1ad2e8ab8558e8720dd555fab8
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Aug 17 12:44:17 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after bug
    392099
    - (1): remove residue of intermediate work

14	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index e7d6c0f..9d58a6b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -15,7 +15,8 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 331649 - [compiler][null] consider null annotations for fields
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409517 - [1.8][compiler] Type annotation problems on more elaborate array references
@@ -978,32 +979,21 @@ public abstract class Annotation extends Expression {
 						break;
 					case Binding.LOCAL :
 						LocalVariableBinding variable = (LocalVariableBinding) this.recipient;
-						if ((annotationType.tagBits & TagBits.AnnotationTargetMASK) == TagBits.AnnotationForTypeUse) {
-							if (variable.type != null) {
+						if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {
+							variable.tagBits |= tagBits;
+							if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
+								scope.problemReporter().contradictoryNullAnnotations(this);
+								variable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems
+							}
+						} else if (variable.type != null) {
+							// bits not relating to null analysis go into the variable:
+							variable.tagBits |= tagBits & ~TagBits.AnnotationNullMASK;
+							// null bits go into the type:
+							long nullTagBits = tagBits & TagBits.AnnotationNullMASK;
+							if (nullTagBits != 0) {
 								if (variable.type.isBaseType()) {
 									scope.problemReporter().illegalAnnotationForBaseType(this, variable.type);
 								} else {
-									long nullTagBits = tagBits & TagBits.AnnotationNullMASK;
-									variable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);
-									if ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
-										scope.problemReporter().contradictoryNullAnnotations(this);
-										variable.type.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems
-									}
-								}
-							}
-						} else {
-							if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {
-								variable.tagBits |= tagBits;
-								if ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
-									scope.problemReporter().contradictoryNullAnnotations(this);
-									variable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems
-								}
-							} else if (variable.type != null) {
-								// bits not relating to null analysis go into the variable:
-								variable.tagBits |= tagBits & ~TagBits.AnnotationNullMASK;
-								// null bits go into the type:
-								long nullTagBits = tagBits & TagBits.AnnotationNullMASK;
-								if (nullTagBits != 0) {
 									variable.type = scope.environment().pushAnnotationIntoType(variable.type, variable.declaration.type, nullTagBits);
 									if ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
 										scope.problemReporter().contradictoryNullAnnotations(this);
commit fafb2dc68e9656aa163ddd55309d4bcb6df6ee09
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 18 19:50:02 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after
    bug 392099
    - (2) ConditionalExpression: always use unannotated() unless identical

5	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 8d21847..8666e92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -20,7 +20,8 @@
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
- *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -470,13 +471,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		
 		TypeBinding valueIfTrueType = this.originalValueIfTrueType;
 		TypeBinding valueIfFalseType = this.originalValueIfFalseType;
-		if (use18specifics && valueIfTrueType != null && valueIfFalseType != null) {
-			if (valueIfTrueType.isAnnotatedTypeWithoutArguments() != valueIfFalseType.isAnnotatedTypeWithoutArguments()) {
-				if (valueIfTrueType.isAnnotatedTypeWithoutArguments()) // FIXME(stephan) mixed scenarios: null tag bits & type arguments
-					valueIfTrueType = valueIfTrueType.original();
-				else
-					valueIfFalseType = valueIfFalseType.original();
-			}
+		if (use18specifics && valueIfTrueType != null && valueIfFalseType != null && valueIfTrueType != valueIfFalseType) {
+			valueIfTrueType = valueIfTrueType.unannotated();
+			valueIfFalseType = valueIfFalseType.unannotated();
 		}
 		if (use15specifics && valueIfTrueType != valueIfFalseType) {
 			if (valueIfTrueType.isBaseType()) {
commit 56242f2c4a4e3fdfdcffa7d9541655946a7953f8
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 18 19:57:02 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after
    bug 392099
    - (3) report detailed typing issues in ReturnExpression

23	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 4054efd..1d2a65f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -29,6 +29,7 @@
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -158,24 +159,31 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return FlowInfo.DEAD_END;
 }
 void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int nullStatus) {
+	long tagBits;
+	MethodBinding methodBinding = null;
+	boolean useTypeAnnotations = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
+	try {
+		methodBinding = scope.methodScope().referenceMethodBinding();
+		tagBits = (useTypeAnnotations) ? methodBinding.returnType.tagBits : methodBinding.tagBits;
+	} catch (NullPointerException npe) {
+		// chain of references in try-block has several potential nulls;
+		// any null means we cannot perform the following check
+		return;			
+	}
+	if (useTypeAnnotations) {
+		int severity = findNullTypeAnnotationMismatch(methodBinding.returnType, this.expression.resolvedType, nullStatus);
+		if (severity == 3) {
+			scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, severity);
+			return;
+		} else if (severity == 2) {
+			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
+			return;
+		}
+	}
 	if (nullStatus != FlowInfo.NON_NULL) {
 		// if we can't prove non-null check against declared null-ness of the enclosing method:
-		long tagBits;
-		MethodBinding methodBinding = null;
-		boolean useTypeAnnotations = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
-		try {
-			methodBinding = scope.methodScope().referenceMethodBinding();
-			tagBits = (useTypeAnnotations) ? methodBinding.returnType.tagBits : methodBinding.tagBits;
-		} catch (NullPointerException npe) {
-			// chain of references in try-block has several potential nulls;
-			// any null means we cannot perform the following check
-			return;			
-		}
 		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
-			if (useTypeAnnotations && (this.expression.resolvedType.tagBits & TagBits.AnnotationNullMASK) != 0) // TODO(stephan) more detailed checking
-				scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, 3);
-			else
-				flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
+			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
 		}
 	}
 }
commit 40f76b3d0fb01a4a7fa1aad4b09c356c31458c94
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 18 20:18:13 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after bug
    392099
    - (4) only reduced flow analysis here (only NON_NULL)

2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
12	21	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
11	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 1d2a65f..92de0cc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -172,10 +172,10 @@ void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int n
 	}
 	if (useTypeAnnotations) {
 		int severity = findNullTypeAnnotationMismatch(methodBinding.returnType, this.expression.resolvedType, nullStatus);
-		if (severity == 3) {
+		if (severity == 2) {
 			scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, severity);
 			return;
-		} else if (severity == 2) {
+		} else if (severity == 1) {
 			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
 			return;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 8dfccaf..9a70a76 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -23,6 +23,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -133,11 +134,10 @@ void analyseOneArgument18(BlockScope currentScope, FlowContext flowContext, Flow
 	int nullStatus = argument.nullStatus(flowInfo, flowContext); // slight loss of precision: should also use the null info from the receiver.
 	int severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType, nullStatus);
 	switch (severity) {
-		case 3:
+		case 2:
 			// immediate reporting:
 			currentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity);
 			break;
-		case 2:
 		case 1:
 			flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 			break;
@@ -155,10 +155,10 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 	} else {
 		lhsTagBits = var.type.tagBits & TagBits.AnnotationNullMASK;
 		int severity = findNullTypeAnnotationMismatch(var.type, providedType, nullStatus);
-		if (severity == 3) {
+		if (severity == 2) {
 			currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, var.type, severity);
 			hasReported = true;
-		} else if (severity == 2) {
+		} else if (severity == 1) {
 			flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, nullStatus);
 			hasReported = true;
 		}
@@ -172,7 +172,7 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 	}
 	return nullStatus;
 }
-// return: severity: 0 = no problem; 1 = flow related problem; 2 = unchecked wrt type detail; 3 = conflicting annotations
+//return: severity: 0 = no problem; 1 = unchecked conversion; 2 = conflicting annotations
 protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
 	int severity = 0;
 	if (requiredType instanceof ArrayBinding) {
@@ -190,13 +190,13 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 						if (i > 0)
 							nullStatus = 0; // don't use beyond the outermost dimension
 						severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
-						if (severity == 3)
+						if (severity == 2)
 							return severity;
 					}
 				}
 			} else if (providedType.id == TypeIds.T_null) {
 				if (dims > 0 && requiredDimsTagBits[0] == TagBits.AnnotationNonNull)
-					return 1;
+					return 2;
 			}
 		}
 	} else if (requiredType instanceof ParameterizedTypeBinding) {
@@ -212,24 +212,15 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
 	if (requiredBits != 0 && requiredBits != providedBits) {
 		if (providedBits != 0) {
-			return 3; // mismatching annotations
+			return 2; // mismatching annotations
 		} else {
-			if (requiredBits == TagBits.AnnotationNonNull) {
-				if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0) {
-					return 1; // @NonNull vs. inferred @Nullable
-				} else if (nullStatus == FlowInfo.NULL) {
-					return 1; // @NonNull vs. null
-				} else if (nullStatus == FlowInfo.NON_NULL) {
-					return 0;
-				} else {
-					return 2; // need unchecked conversion regarding type detail
-				}
-			} else {
-				return 2; // need unchecked conversion regarding type detail
+			if (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {
+				return 0; // OK by flow analysis
 			}
+			return 1; // need unchecked conversion regarding type detail
 		}
 	}
-	return 0;
+	return 0; // OK by tagBits
 }
 /**
  * INTERNAL USE ONLY.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index caf4ff2..58bb66c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -39,6 +39,7 @@
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -8832,7 +8833,7 @@ public void explicitlyClosedAutoCloseable(FakedTrackingVariable trackVar) {
 
 public void nullityMismatch(Expression expression, TypeBinding providedType, TypeBinding requiredType, int nullStatus, char[][] annotationName) {
 	if ((nullStatus & FlowInfo.NULL) != 0) {
-		nullityMismatchIsNull(expression, requiredType, annotationName);
+		nullityMismatchIsNull(expression, requiredType);
 		return;
 	}
 	if (expression instanceof MessageSend) {
@@ -8856,15 +8857,15 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 	if (this.options.sourceLevel < ClassFileConstants.JDK1_8)
 		nullityMismatchIsUnknown(expression, providedType, requiredType, annotationName);
 	else
-		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, 2/*unchecked*/);
+		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, 1/*unchecked*/);
 }
-public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType, char[][] annotationName) {
+public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType) {
 	int problemId = IProblem.RequiredNonNullButProvidedNull;
 	String[] arguments = new String[] {
-			annotatedTypeName(requiredType, annotationName)
+			annotatedTypeName(requiredType, this.options.nonNullAnnotationName)
 	};
 	String[] argumentsShort = new String[] {
-			shortAnnotatedTypeName(requiredType, annotationName)
+			shortAnnotatedTypeName(requiredType, this.options.nonNullAnnotationName)
 	};
 	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
 }
@@ -9365,6 +9366,10 @@ public void arrayReferencePotentialNullReference(ArrayReference arrayReference)
 }
 public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding providedType, TypeBinding requiredType, int severity) 
 {
+	if (providedType.id == TypeIds.T_null) {
+		nullityMismatchIsNull(expression, requiredType);
+		return;
+	}
 	String[] arguments = new String[] {
 		String.valueOf(requiredType.nullAnnotatedReadableName(this.options, false)),
 		String.valueOf(providedType.nullAnnotatedReadableName(this.options, false))
@@ -9373,7 +9378,7 @@ public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding
 		String.valueOf(requiredType.nullAnnotatedReadableName(this.options, true)),
 		String.valueOf(providedType.nullAnnotatedReadableName(this.options, true))
 	};
-	int problemId = severity == 2 ? IProblem.NullityUncheckedTypeAnnotationDetail : IProblem.NullityMismatchingTypeAnnotation;			
+	int problemId = severity == 1 ? IProblem.NullityUncheckedTypeAnnotationDetail : IProblem.NullityMismatchingTypeAnnotation;			
 	this.handle(
 			problemId,
 			arguments, shortArguments, expression.sourceStart, expression.sourceEnd);
commit dc2b9befa6829d8676bcaaed036d87dc45fd9d36
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Aug 19 18:42:46 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after bug
    392099
    - (7) tidy: include ArrayBinding in this treatment

3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 05d8039..ba57549 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -27,6 +27,7 @@
  *								bug 380896 - [compiler][null] Enum constants not recognised as being NonNull.
  *								bug 391376 - [1.8] check interaction of default methods with bridge methods and generics
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1536,9 +1537,9 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 					// validate null annotation:
 					this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations);
 				}
-				if (sourceLevel >= ClassFileConstants.JDK1_8 && field.type instanceof ReferenceBinding) {
+				if (sourceLevel >= ClassFileConstants.JDK1_8 && !fieldType.isBaseType()) {
 					long nullTagBits = field.tagBits & TagBits.AnnotationNullMASK;
-					if (nullTagBits != 0 && nullTagBits != (field.type.tagBits & TagBits.AnnotationNullMASK))
+					if (nullTagBits != 0 && nullTagBits != (fieldType.tagBits & TagBits.AnnotationNullMASK))
 						field.type = environment.pushAnnotationIntoType(fieldType, fieldDecl.type, nullTagBits);
 					// do not reset field.tagBits, since more fields may need to share this information ("@NonNull Object o1, o2;")
 				}
commit 1fbca275b2d7b310a4c5055e69f422227cc3afb2
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Aug 19 18:44:10 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after bug
    392099
    - (8) nullAnnotatedReadableName(): remove from RB, improve for PTB
      - incl. a fix for detecting mismatch due to enclosing

37	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
20	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
1	20	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 336f1c1..72d069d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -388,6 +388,43 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			customOptions);
 	}
 
+	// a reference to a nested type has annotations for both types, mismatch in detail of outer
+	public void test_nestedType_05() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+		customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+		runNegativeTest(
+			new String[] {
+				ELEMENT_TYPE_JAVA,
+				ELEMENT_TYPE_SOURCE,
+				CUSTOM_NULLABLE_NAME,
+				CUSTOM_NULLABLE_CONTENT_JSR308,
+				CUSTOM_NONNULL_NAME,
+				CUSTOM_NONNULL_CONTENT_JSR308,
+				"A.java",
+				  "public class A<X> {\n" +
+				  "    public abstract class I<Y> {\n" +
+				  "        public abstract X foo(Y l);\n" +
+				  "    }\n" +
+				  "}\n",
+				"B.java",
+				  "import org.foo.*;\n" +
+				  "public class B {\n" +
+				  "    public void foo(A<@NonNull Object>.@Nullable I<@NonNull String> ai1) {\n" +
+				  "		A<@Nullable Object>.@Nullable I<@NonNull String> ai2 = ai1;\n" +
+				  "    }\n" +
+				  "}\n"},
+			"----------\n" + 
+			"1. ERROR in B.java (at line 4)\n" + 
+			"	A<@Nullable Object>.@Nullable I<@NonNull String> ai2 = ai1;\n" + 
+			"	                                                       ^^^\n" + 
+			"Null type mismatch (type annotations): required \'A<@Nullable Object>.@Nullable I<@NonNull String>\' but this expression has type \'A<@NonNull Object>.@Nullable I<@NonNull String>\'\n" + 
+			"----------\n",
+			null,
+			true, /* shouldFlush*/
+			customOptions);
+	}
+
 	public void testMissingAnnotationTypes_01() {
 		runNegativeTest(
 			new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 34fdbef..2108ade 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -206,20 +206,28 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 		}
 	} else if (requiredType instanceof ParameterizedTypeBinding) {
 		long requiredBits = requiredType.tagBits & TagBits.AnnotationNullMASK;
-		if (requiredBits == TagBits.AnnotationNullable && nullStatus != -1) // at detail/recursion even nullable must be matched exactly
-			return 0; // accepting anything
-		long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
-		severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
-		if (severity < 3 && providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
-			TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
-			TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;
-			if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
-				for (int i = 0; i < requiredArguments.length; i++) {
-					severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1));
-					if (severity == 2)
-						return severity;
+		if (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...
+				|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
+		{
+			long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
+			severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
+		}
+		if (severity < 3) {
+			if (providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
+				TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
+				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;
+				if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
+					for (int i = 0; i < requiredArguments.length; i++) {
+						severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1));
+						if (severity == 2)
+							return severity;
+					}
 				}
 			}
+			TypeBinding requiredEnclosing = requiredType.enclosingType();
+			TypeBinding providedEnclosing = providedType.enclosingType();
+			if (requiredEnclosing != null && providedEnclosing != null)
+				severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1));
 		}
 	}
 	return severity;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index a663f8e..fe54a42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -18,6 +18,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -987,7 +988,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	char[] nullAnnotatedReadableName(CompilerOptions options) {
 	    StringBuffer nameBuffer = new StringBuffer(10);
 		if (isMemberType()) {
-			nameBuffer.append(enclosingType().readableName());
+			nameBuffer.append(enclosingType().nullAnnotatedReadableName(options, false));
 			nameBuffer.append('.');
 			appendNullAnnotation(nameBuffer);
 			nameBuffer.append(this.sourceName);
@@ -1022,7 +1023,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	char[] nullAnnotatedShortReadableName(CompilerOptions options) {
 	    StringBuffer nameBuffer = new StringBuffer(10);
 		if (isMemberType()) {
-			nameBuffer.append(enclosingType().shortReadableName());
+			nameBuffer.append(enclosingType().nullAnnotatedReadableName(options, true));
 			nameBuffer.append('.');
 			appendNullAnnotation(nameBuffer);
 			nameBuffer.append(this.sourceName);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 33f1e6e..8171dfc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -25,6 +25,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -37,7 +38,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 /*
@@ -1448,25 +1448,6 @@ public MethodBinding[] methods() {
 	return Binding.NO_METHODS;
 }
 
-public char[] nullAnnotatedReadableName(CompilerOptions options, boolean shortNames) /* java.lang.Object @o.e.j.a.NonNull[] */ {
-	// TODO(stephan): respect annotatable enclosing types!
-	char[] typeName = shortNames ? shortReadableName() : readableName();
-	if ((this.tagBits & TagBits.AnnotationNullMASK) == 0)
-		return typeName;
-	char[][] fqAnnotationName;
-	if ((this.tagBits & TagBits.AnnotationNonNull) != 0)
-		fqAnnotationName = options.nonNullAnnotationName;
-	else
-		fqAnnotationName = options.nullableAnnotationName;
-	char[] annotationName = shortNames
-								? fqAnnotationName[fqAnnotationName.length-1]
-								: CharOperation.concatWith(fqAnnotationName, '.');				
-	char[] prefix = new char[annotationName.length+1];
-	prefix[0] = '@';
-	System.arraycopy(annotationName, 0, prefix, 1, annotationName.length);
-	return CharOperation.concat(prefix, typeName, ' ');
-}
-
 public final ReferenceBinding outermostEnclosingType() {
 	ReferenceBinding current = this;
 	while (true) {
commit 4479368fdfa1c29f97c094bfbee396d5c4fd21ba
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Aug 20 12:49:48 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after
    bug 392099
    - (9) nullness conflict formal/actual type parameter
      - incl. fixes for annotated type variables

4	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
21	23	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
2	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
2	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
8	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
23	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 166dd4a..13bfd27 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -30,7 +30,8 @@
  *								bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -824,6 +825,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetail", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullSourceString", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1608,6 +1610,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocation", SKIP);
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetail", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 6f31bbf..58d618f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -948,9 +948,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				},
 				customOptions,
 				"");
-// FIXME(stephan): change to negative tests and fill in desired error messages
-		runConformTestWithLibs(
-//		runNegativeTestWithLibs(
+		runNegativeTestWithLibs(
 				new String[] {
 					"Y1.java",
 					"import p.X1;\n" +
@@ -963,13 +961,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"}\n"
 				}, 
 				customOptions,
-				""
-//				"----------\n" + 
-//				"1. ERROR in Y1.java (at line 5)\n" + 
-//				"	X1<@Nullable String> maybeStrings;\n" + 
-//				"	   ^^^^^^^^^^^^^^^^\n" + 
-//				"Incompatible type argument ...\n" + 
-//				"----------\n"
+				"----------\n" + 
+				"1. ERROR in Y1.java (at line 6)\n" + 
+				"	x.<@NonNull Object>foo(new Object());\n" + 
+				"	   ^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'S' which is constrained as '@Nullable'\n" + 
+				"----------\n"
 				);
 	}
 
@@ -993,9 +990,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				},
 				customOptions,
 				"");
-// FIXME(stephan): change to negative tests and fill in desired error messages
-		runConformTestWithLibs(
-//		runNegativeTestWithLibs(
+		runNegativeTestWithLibs(
 				new String[] {
 					"Y1.java",
 					"import p.X1;\n" +
@@ -1003,18 +998,17 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"public class Y1 {\n" +
 					"	X1<@Nullable String> maybeStrings;\n" + // incompatible: T is constrained to @NonNull
 					"	void test(X1<@NonNull String> x) {\n" + // OK
-					"		x.<Y1, @NonNull Object>foo(this, new Object());\n" + // incompatible: S is constrained to @Nullable
+					"		x.<Y1, @NonNull Object>foo(this, new Object());\n" + // incompatible: V is constrained to @Nullable via superclass
 					"	}\n" +
 					"}\n"
 				}, 
 				customOptions,
-				""
-//				"----------\n" + 
-//				"1. ERROR in Y1.java (at line 5)\n" + 
-//				"	X1<@Nullable String> maybeStrings;\n" + 
-//				"	   ^^^^^^^^^^^^^^^^\n" + 
-//				"Incompatible type argument ...\n" + 
-//				"----------\n"
+				"----------\n" + 
+				"1. ERROR in Y1.java (at line 6)\n" + 
+				"	x.<Y1, @NonNull Object>foo(this, new Object());\n" + 
+				"	       ^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'V' which is constrained as '@Nullable'\n" + 
+				"----------\n"
 				);
 	}
 
@@ -1040,7 +1034,6 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				},
 				customOptions,
 				"");
-// FIXME(stephan): add desired error message
 		runNegativeTestWithLibs(
 				new String[] {
 					"Y1.java",
@@ -1055,7 +1048,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				}, 
 				customOptions,
 				"----------\n" + 
-				"1. ERROR in Y1.java (at line 6)\n" + 
+				"1. ERROR in Y1.java (at line 5)\n" + 
+				"	x.<@NonNull Y1, @NonNull Object>foo(this, new Object())\n" + 
+				"	                ^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'V' which is constrained as '@Nullable'\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 6)\n" + 
 				"	.get(0).put(null, null);\n" + 
 				"	                  ^^^^\n" + 
 				"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 3eff695..731c758 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -186,6 +186,7 @@
  *									PotentialNullExpressionReference
  *									RedundantNullCheckAgainstNonNullType
  *									NullAnnotationUnsupportedLocation
+ *									NullityMismatchTypeArgument
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1694,6 +1695,8 @@ void setSourceStart(int sourceStart);
 	int RedundantNullCheckAgainstNonNullType = Internal + 959;
 	/** @since 3.9 BETA_JAVA8 */
 	int NullAnnotationUnsupportedLocation = Internal + 960;
+	/** @since 3.9 BETA_JAVA8 */
+	int NullityMismatchTypeArgument = Internal + 961;
 
 	// Java 8 work
 	/** @since 3.9 BETA_JAVA8 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 1792a88..0812d3c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -33,7 +33,8 @@
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -164,6 +165,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
+	if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
+		ParameterizedGenericMethodBinding parameterizedBinding = (ParameterizedGenericMethodBinding) this.binding;
+		for (int i = 0; i < this.typeArguments.length; i++)
+			parameterizedBinding.checkNullConstraints(currentScope, this.typeArguments[i], i);
+	}
 	ReferenceBinding[] thrownExceptions;
 	if ((thrownExceptions = this.binding.thrownExceptions) != Binding.NO_EXCEPTIONS) {
 		if ((this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index 0f40e66..d5dd8e5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -263,10 +264,7 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 					if (argType == null) {
 						argHasError = true;
 					} else {
-						if (arg.annotations != null)
-							argTypes[j] = captureTypeAnnotations(scope, qualifyingType, argType, arg.annotations[0]);
-						else
-							argTypes[j] = argType;
+						argTypes[j] = argType;
 					}
 				}
 				if (argHasError) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index b3b26f2..16751a7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -228,10 +229,7 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		     if (argType == null) {
 		         argHasError = true;
 		     } else {
-			    if (typeArgument.annotations != null)
-			    	argTypes[i] = captureTypeAnnotations(scope, enclosingType, argType, typeArgument.annotations[0]);
-			    else
-			    	argTypes[i] = argType;
+		    	 argTypes[i] = argType;
 		     }
 		}
 		if (argHasError) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index ec34352..0c445be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -15,7 +15,7 @@
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -603,7 +603,7 @@ protected void resolveAnnotations(Scope scope) {
 					}
 				} else {
 					if (tagBits != 0) {
-						if (this.resolvedType.isBaseType()) {
+						if (!this.resolvedType.isBaseType()) {
 							this.resolvedType = scope.environment().createAnnotatedType(this.resolvedType, tagBits);
 						} else {
 							// TODO(stephan) report null annotation on non-reference type
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index a9bf7ff..9cc478e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -23,6 +23,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -729,7 +730,9 @@ private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, bool
 						char[] variableName = CharOperation.subarray(typeSignature, i, colon);
 						TypeVariableBinding typeVariable = new TypeVariableBinding(variableName, this, rank, this.environment);
 						IBinaryAnnotation[] annotations = walker.toTypeParameter(isClassTypeParameter, rank++).getAnnotationsAtCursor();
-						typeVariable.tagBits  |= this.environment.typeAnnotationsToTagBits(annotations);
+						long annotationTagBits = this.environment.typeAnnotationsToTagBits(annotations);
+						if (annotationTagBits != 0)
+							typeVariable.tagBits  |= annotationTagBits | TagBits.HasNullTypeAnnotation;
 						variables.add(typeVariable);
 					}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 9ca94f4..ae21ae0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -10,9 +10,11 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
@@ -359,6 +361,17 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    this.parameterNonNullness = originalMethod.parameterNonNullness;
 	}
 
+	public void checkNullConstraints(Scope scope, TypeReference typeArgument, int rank) {
+    	TypeBinding[] variables = this.originalMethod.typeVariables();
+		if (variables != null && variables.length > rank) {
+			if (variables[rank].hasNullTypeAnnotations()) {
+				if ((typeArgument.resolvedType.tagBits & TagBits.AnnotationNullMASK) != (variables[rank].tagBits & TagBits.AnnotationNullMASK)) {
+					scope.problemReporter().nullityMismatchTypeArgument(variables[rank], typeArgument.resolvedType, typeArgument);
+				}
+	    	}
+		}
+	}
+
 	/*
 	 * parameterizedDeclaringUniqueKey dot selector originalMethodGenericSignature percent typeArguments
 	 * p.X<U> { <T> void bar(T t, U u) { new X<String>().bar(this, "") } } --> Lp/X<Ljava/lang/String;>;.bar<T:Ljava/lang/Object;>(TT;Ljava/lang/String;)V%<Lp/X;>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
index 4c6e4e6..f96f5be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
@@ -15,6 +15,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -61,7 +62,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 			for (int i = 0; i < length; i++) { // copy original type variable to relocate
 				TypeVariableBinding originalVariable = originalVariables[i];
 				substitutedVariables[i] = new TypeVariableBinding(originalVariable.sourceName, this, originalVariable.rank, parameterizedDeclaringClass.environment);
-				substitutedVariables[i].tagBits |= (originalVariable.tagBits & TagBits.AnnotationNullMASK);
+				substitutedVariables[i].tagBits |= (originalVariable.tagBits & (TagBits.AnnotationNullMASK|TagBits.HasNullTypeAnnotation));
 			}
 			this.typeVariables = substitutedVariables;
 
@@ -197,7 +198,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 							this,
 							originalVariable.rank,
 							environment);
-				substitutedVariables[i].tagBits |= (originalVariable.tagBits & TagBits.AnnotationNullMASK);
+				substitutedVariables[i].tagBits |= (originalVariable.tagBits & (TagBits.AnnotationNullMASK|TagBits.HasNullTypeAnnotation));
 			}
 			this.typeVariables = substitutedVariables;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 756abef..b45f898 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -18,6 +18,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -461,7 +462,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 			long superNullTagBits = resolveType.tagBits & TagBits.AnnotationNullMASK;
 			if (superNullTagBits != 0L) {
 				if (nullTagBits == 0L) {
-					this.tagBits |= superNullTagBits;
+					this.tagBits |= (superNullTagBits | TagBits.HasNullTypeAnnotation);
 				} else {
 //					System.err.println("TODO(stephan): report proper error: conflict binary TypeVariable vs. first bound");
 				}
@@ -478,7 +479,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 				long superNullTagBits = resolveType.tagBits & TagBits.AnnotationNullMASK;
 				if (superNullTagBits != 0L) {
 					if (nullTagBits == 0L) {
-						this.tagBits |= superNullTagBits;
+						this.tagBits |= (superNullTagBits | TagBits.HasNullTypeAnnotation);
 					} else {
 //						System.err.println("TODO(stephan): report proper error: conflict binary TypeVariable vs. bound "+i);
 					}
@@ -551,7 +552,9 @@ public class TypeVariableBinding extends ReferenceBinding {
 			Binding recipient = annotations[j].recipient;
 			if (recipient instanceof Annotation.TypeUseBinding) {
 				// FIXME(stephan): detect contradictions
-				this.tagBits |= ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;
+				long annotationsTagBits = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;
+				if (annotationsTagBits != 0)
+					this.tagBits |= annotationsTagBits | TagBits.HasNullTypeAnnotation;
 			}
 		}
 		long nullTagBits = this.tagBits & TagBits.AnnotationNullMASK;
@@ -581,6 +584,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 				interfaces[i] = resolveType;
 			}
 		}
-		this.tagBits |= nullTagBits;
+		if (nullTagBits != 0)
+			this.tagBits |= nullTagBits | TagBits.HasNullTypeAnnotation;
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 050a0df..9446927 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -372,6 +372,7 @@ public static int getIrritant(int problemID) {
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
 		case IProblem.NullityMismatchingTypeAnnotation:
+		case IProblem.NullityMismatchTypeArgument:
 		case IProblem.UninitializedNonNullField:
 		case IProblem.UninitializedNonNullFieldHintMissingDefault:
 		case IProblem.ReferenceExpressionParameterMismatchPromisedNullable:
@@ -9394,6 +9395,28 @@ public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding
 			problemId,
 			arguments, shortArguments, expression.sourceStart, expression.sourceEnd);
 }
+
+public void nullityMismatchTypeArgument(TypeBinding typeVariable, TypeBinding typeArgument, ASTNode location) {
+	long tagBits = typeVariable.tagBits & TagBits.AnnotationNullMASK;
+	char[][] annotationName = tagBits == TagBits.AnnotationNonNull ? this.options.nonNullAnnotationName : this.options.nullableAnnotationName;
+	String[] arguments = {
+		String.valueOf(typeVariable.readableName()),
+		String.valueOf(CharOperation.concatWith(annotationName, '.')),
+		String.valueOf(typeArgument.nullAnnotatedReadableName(this.options, false))
+	};
+	String[] shortArguments = {
+		String.valueOf(typeVariable.shortReadableName()),
+		String.valueOf(annotationName[annotationName.length-1]),
+		String.valueOf(typeArgument.nullAnnotatedReadableName(this.options, true))
+	};
+	this.handle(
+			IProblem.NullityMismatchTypeArgument, 
+			arguments, 
+			shortArguments, 
+			location.sourceStart, 
+			location.sourceEnd);
+}
+
 public void dereferencingNullableExpression(Expression expression) {
 	if (expression instanceof MessageSend) {
 		MessageSend send = (MessageSend) expression;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 2b8827a..8c9eb7d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -33,6 +33,7 @@
 #							bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
 #							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
 #							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+#							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -785,6 +786,7 @@
 958 = Null type safety at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
 959 = Redundant null check: comparing ''{0}'' against null
 960 = The nullness annotation ''{0}'' is not applicable at this location
+961 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
commit c49a7bd34f8c2781dba76984d24d83335183205f
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Aug 27 12:17:35 2013 +0200

    Bug 415043 - [1.8][null] Follow-up re null type annotations after bug
    392099

2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
4	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
261	27	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
9	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
44	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
13	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
17	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
16	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
0	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
13	21	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
26	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
42	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 13bfd27..9a1453c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -423,6 +423,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("CodeSnippetMissingClass", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("CodeSnippetMissingMethod", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ContradictoryNullAnnotations", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("ContradictoryNullAnnotationsOnBound", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ComparingIdentical", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ConflictingImport", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
 		expectedProblemAttributes.put("ConflictingNullAnnotations", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1220,6 +1221,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ConflictingInheritedNullAnnotations", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ConstructorReferenceNotBelow18", SKIP);
 		expectedProblemAttributes.put("ContradictoryNullAnnotations", SKIP);
+		expectedProblemAttributes.put("ContradictoryNullAnnotationsOnBound", SKIP);
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(JavaCore.COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST));
 		expectedProblemAttributes.put("CorruptedSignature", SKIP);
 		expectedProblemAttributes.put("DanglingReference", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index f91f625..26697e7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -59,10 +59,10 @@ String nullTypeSafety() {
 			? "Null type safety: "
 			: "Null type safety (type annotations): ";
 }
-String mismatch_NonNull_Null(String type) {
+String mismatch_NonNull_Null(String type7, String type8) {
 	return 	(this.complianceLevel < ClassFileConstants.JDK1_8) 
-			? "Null type mismatch: required \'@NonNull "+type+"\' but the provided value is null\n" 
-			: "Null type mismatch: required \'@NonNull "+type+"\' but the provided value is null\n";
+			? "Null type mismatch: required \'@NonNull "+type7+"\' but the provided value is null\n" 
+			: "Null type mismatch: required \'@NonNull "+type8+"\' but the provided value is null\n";
 }
 String variableMayBeNull(String var) {
 	return 	(this.complianceLevel < ClassFileConstants.JDK1_8) 
@@ -496,7 +496,7 @@ public void test_nonnull_parameter_012() {
 		"2. ERROR in X.java (at line 4)\n" + 
 		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
 		"	                                                   ^^^^\n" + 
-		mismatch_NonNull_Null("Object") +
+		mismatch_NonNull_Null("Object", "T") +
 		"----------\n"  /* compiler output */);
 }
 // a method of a local class has a non-null parameter, client passes null
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 6d4d46f..8a6b8e4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -29,7 +29,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testBug415850_01" };
+//			TESTS_NAMES = new String[] { "testBinary08" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -1030,7 +1030,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				}, 
 				customOptions,
 				"----------\n" + 
-				"1. ERROR in Y1.java (at line 6)\n" + 
+				"1. ERROR in Y1.java (at line 4)\n" + 
+				"	X1<@Nullable String> maybeStrings;\n" + 
+				"	   ^^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type \'@Nullable String\' is not a valid substitute for the type parameter \'T\' which is constrained as \'@NonNull\'\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 6)\n" + 
 				"	x.<@NonNull Object>foo(new Object());\n" + 
 				"	   ^^^^^^^^^^^^^^^\n" + 
 				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'S' which is constrained as '@Nullable'\n" + 
@@ -1043,8 +1048,28 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 		Map customOptions = getCompilerOptions();
 		customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
 		customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
-// FIXME(stephan): change to negative tests and fill in desired error messages
-//		runNegativeTestWithLibs(
+		runNegativeTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import java.util.ArrayList;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1<T extends @NonNull Object> extends ArrayList<T> {\n" +
+					"    public <U, V extends @Nullable Object> void foo(U u, V v) {}\n" +
+					"}\n",
+					"p/X2.java", 
+					"package p;\n"+
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X2<@NonNull W extends @Nullable Object> {}\n" // incompatible constraints
+				},
+				customOptions,
+				"----------\n" + 
+				"1. ERROR in p\\X2.java (at line 3)\n" + 
+				"	public class X2<@NonNull W extends @Nullable Object> {}\n" + 
+				"	                                   ^^^^^^^^^\n" + 
+				"This nullness annotation conflicts with a \'@NonNull\' annotation which is effective on the same type parameter \n" + 
+				"----------\n");
+		// fix the bug:		
 		runConformTestWithLibs(
 				new String[] {
 					"p/X1.java",
@@ -1053,8 +1078,11 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"import org.eclipse.jdt.annotation.*;\n" +
 					"public abstract class X1<T extends @NonNull Object> extends ArrayList<T> {\n" +
 					"    public <U, V extends @Nullable Object> void foo(U u, V v) {}\n" +
-					"}\n" +
-					"class X2<@NonNull W extends @Nullable Object> {}\n" // incompatible constraints
+					"}\n",
+					"p/X2.java", 
+					"package p;\n"+
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X2<@Nullable W extends Object> {}\n"
 				},
 				customOptions,
 				"");
@@ -1062,9 +1090,11 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				new String[] {
 					"Y1.java",
 					"import p.X1;\n" +
+					"import p.X2;\n" +
 					"import org.eclipse.jdt.annotation.*;\n" +
 					"public class Y1 {\n" +
-					"	X1<@Nullable String> maybeStrings;\n" + // incompatible: T is constrained to @NonNull
+					"	X1<@Nullable String> maybeStrings;\n" + // incompatible: T has a bound constrained to @NonNull
+					"   X2<@NonNull String> strings;\n" +       // incompatible: W is constrained to @Nullable
 					"	void test(X1<@NonNull String> x) {\n" + // OK
 					"		x.<Y1, @NonNull Object>foo(this, new Object());\n" + // incompatible: V is constrained to @Nullable via superclass
 					"	}\n" +
@@ -1072,7 +1102,17 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				}, 
 				customOptions,
 				"----------\n" + 
-				"1. ERROR in Y1.java (at line 6)\n" + 
+				"1. ERROR in Y1.java (at line 5)\n" + 
+				"	X1<@Nullable String> maybeStrings;\n" + 
+				"	   ^^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type \'@Nullable String\' is not a valid substitute for the type parameter \'T\' which is constrained as \'@NonNull\'\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 6)\n" + 
+				"	X2<@NonNull String> strings;\n" + 
+				"	   ^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type \'@NonNull String\' is not a valid substitute for the type parameter \'W\' which is constrained as \'@Nullable\'\n" + 
+				"----------\n" + 
+				"3. ERROR in Y1.java (at line 8)\n" + 
 				"	x.<Y1, @NonNull Object>foo(this, new Object());\n" + 
 				"	       ^^^^^^^^^^^^^^^\n" + 
 				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'V' which is constrained as '@Nullable'\n" + 
@@ -1080,6 +1120,82 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				);
 	}
 
+	// storing and decoding null-type-annotations to/from classfile: CLASS_TYPE_PARAMETER_BOUND & METHOD_TYPE_PARAMETER_BOUND
+	// variant: qualified type references
+	public void testBinary06b() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+		customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
+		runNegativeTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import java.util.ArrayList;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1<T extends java.lang.@NonNull Object> extends ArrayList<T> {\n" +
+					"    public <U, V extends java.lang.@Nullable Object> void foo(U u, V v) {}\n" +
+					"}\n",
+					"p/X2.java", 
+					"package p;\n"+
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X2<@NonNull W extends java.lang.@Nullable Object> {}\n" // incompatible constraints
+				},
+				customOptions,
+				"----------\n" + 
+				"1. ERROR in p\\X2.java (at line 3)\n" + 
+				"	public class X2<@NonNull W extends java.lang.@Nullable Object> {}\n" + 
+				"	                                             ^^^^^^^^^\n" + 
+				"This nullness annotation conflicts with a \'@NonNull\' annotation which is effective on the same type parameter \n" + 
+				"----------\n");
+		// fix the bug:		
+		runConformTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import java.util.ArrayList;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1<T extends java.lang.@NonNull Object> extends ArrayList<T> {\n" +
+					"    public <U, V extends java.lang.@Nullable Object> void foo(U u, V v) {}\n" +
+					"}\n",
+					"p/X2.java", 
+					"package p;\n"+
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X2<@Nullable W extends Object> {}\n"
+				},
+				customOptions,
+				"");
+		runNegativeTestWithLibs(
+				new String[] {
+					"Y1.java",
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class Y1 {\n" +
+					"	p.X1<java.lang.@Nullable String> maybeStrings;\n" + // incompatible: T has a bound constrained to @NonNull
+					"   p.X2<java.lang.@NonNull String> strings;\n" +       // incompatible: W is constrained to @Nullable
+					"	void test(p.X1<java.lang.@NonNull String> x) {\n" + // OK
+					"		x.<Y1, java.lang.@NonNull Object>foo(this, new Object());\n" + // incompatible: V is constrained to @Nullable via superclass
+					"	}\n" +
+					"}\n"
+				}, 
+				customOptions,
+				"----------\n" + 
+				"1. ERROR in Y1.java (at line 3)\n" + 
+				"	p.X1<java.lang.@Nullable String> maybeStrings;\n" + 
+				"	     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type \'@Nullable String\' is not a valid substitute for the type parameter \'T\' which is constrained as \'@NonNull\'\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 4)\n" + 
+				"	p.X2<java.lang.@NonNull String> strings;\n" + 
+				"	     ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type \'@NonNull String\' is not a valid substitute for the type parameter \'W\' which is constrained as \'@Nullable\'\n" + 
+				"----------\n" + 
+				"3. ERROR in Y1.java (at line 6)\n" + 
+				"	x.<Y1, java.lang.@NonNull Object>foo(this, new Object());\n" + 
+				"	       ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null constraint mismatch: The type '@NonNull Object' is not a valid substitute for the type parameter 'V' which is constrained as '@Nullable'\n" + 
+				"----------\n"
+				);
+	}
+
 	// storing and decoding null-type-annotations to/from classfile: method with all kinds of type annotations
 	public void testBinary07() {
 		Map customOptions = getCompilerOptions();
@@ -1133,6 +1249,28 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 		Map customOptions = getCompilerOptions();
 		customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
 		customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
+		runNegativeTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import java.util.*;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1 {\n" +
+					"    public class Inner {}\n" +
+					"    public Object []@NonNull[] arrays(Object @NonNull[][] oa1) { return null; }\n" +
+					"    public void nesting(@NonNull Inner i1, X1.@Nullable Inner i2) { }\n" +
+					"    public void wildcard1(List<@Nullable ? extends @NonNull X1> l) { } // contradiction\n" +
+					"    public void wildcard2(List<? super @NonNull X1> l) { }\n" +
+					"}\n"
+				},
+				customOptions,
+				"----------\n" + 
+				"1. ERROR in p\\X1.java (at line 8)\n" + 
+				"	public void wildcard1(List<@Nullable ? extends @NonNull X1> l) { } // contradiction\n" + 
+				"	                                               ^^^^^^^^\n" + 
+				"This nullness annotation conflicts with a \'@Nullable\' annotation which is effective on the same type parameter \n" + 
+				"----------\n");
+		// fix the error:
 		runConformTestWithLibs(
 				new String[] {
 					"p/X1.java",
@@ -1143,49 +1281,146 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"    public class Inner {}\n" +
 					"    public Object []@NonNull[] arrays(Object @NonNull[][] oa1) { return null; }\n" +
 					"    public void nesting(@NonNull Inner i1, X1.@Nullable Inner i2) { }\n" +
-					"    public void wildcard1(List<@Nullable ? extends @NonNull X1> l) { }\n" + // contradiction
+					"    public void wildcard1(List<@Nullable ? extends X1> l) { }\n" +
 					"    public void wildcard2(List<? super @NonNull X1> l) { }\n" +
 					"}\n"
 				},
 				customOptions,
 				"");
-// FIXME(stephan): add desired error messages:
+
 		runNegativeTestWithLibs(
 				new String[] {
 					"Y1.java",
 					"import p.X1;\n" +
 					"import org.eclipse.jdt.annotation.*;\n" +
-//					"import java.util.*;\n" +
+					"import java.util.*;\n" +
 					"public class Y1 {\n" +
 					"	void test(X1 x) {\n" +
-					"		Object @NonNull[][] a = new Object[0][];\n" + // unsafe
-					"		x.arrays(a)[0] = null;\n" + // illegal
-					"		x.nesting(null, null);\n" + // 1st null is illegal
-//					"		x.wildcard2(new ArrayList<@NonNull Object>());\n" +
+					"		Object @NonNull[][] a = new Object[0][]; // unsafe\n" +
+					"		x.arrays(a)[0] = null; // illegal\n" +
+					"		x.nesting(null, null); // 1st null is illegal\n" +
+					"		x.wildcard2(new ArrayList<@NonNull Object>());\n" +
+					"		x.wildcard2(new ArrayList<@Nullable Object>()); // incompatible(1)\n" +
+					"		x.wildcard1(new ArrayList<@NonNull X1>()); // incompatible(2)\n" +
 					"	}\n" +
 					"}\n"
 				}, 
 				customOptions,
 				"----------\n" + 
-//				"1. ERROR in Y1.java (at line 5)\n" + 
-//				"	X1<@Nullable String> maybeStrings;\n" + 
-//				"	   ^^^^^^^^^^^^^^^^\n" + 
-//				"Incompatible type argument ...\n" + 
-//				"----------\n" + 
-				"1. WARNING in Y1.java (at line 5)\n" + 
-				"	Object @NonNull[][] a = new Object[0][];\n" + 
+				"1. WARNING in Y1.java (at line 6)\n" + 
+				"	Object @NonNull[][] a = new Object[0][]; // unsafe\n" + 
 				"	                        ^^^^^^^^^^^^^^^\n" + 
 				"Null type safety (type annotations): The expression of type \'Object[][]\' needs unchecked conversion to conform to \'Object @NonNull[] []\'\n" + 
 				"----------\n" + 
-				"2. ERROR in Y1.java (at line 6)\n" + 
-				"	x.arrays(a)[0] = null;\n" + 
+				"2. ERROR in Y1.java (at line 7)\n" + 
+				"	x.arrays(a)[0] = null; // illegal\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"Null type mismatch: required \'Object @NonNull[]\' but the provided value is null\n" +
+				"----------\n" + 
+				"3. ERROR in Y1.java (at line 8)\n" + 
+				"	x.nesting(null, null); // 1st null is illegal\n" + 
+				"	          ^^^^\n" + 
+				"Null type mismatch: required \'X1.@NonNull Inner\' but the provided value is null\n" + 
+				"----------\n" + 
+				"4. ERROR in Y1.java (at line 10)\n" + 
+				"	x.wildcard2(new ArrayList<@Nullable Object>()); // incompatible(1)\n" + 
+				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\'\n" + 
+				"----------\n" + 
+				"5. ERROR in Y1.java (at line 11)\n" + 
+				"	x.wildcard1(new ArrayList<@NonNull X1>()); // incompatible(2)\n" + 
+				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\'\n" + 
+				"----------\n");
+	}
+
+	// storing and decoding null-type-annotations to/from classfile: details
+	// variant: qualified references
+	public void testBinary08b() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+		customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
+		runNegativeTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1 {\n" +
+					"    public class Inner {}\n" +
+					"    public java.lang.Object []@NonNull[] arrays(java.lang.Object @NonNull[][] oa1) { return null; }\n" +
+					"    public void nesting(@NonNull Inner i1, X1.@Nullable Inner i2) { }\n" +
+					"    public void wildcard1(java.util.List<@Nullable ? extends p.@NonNull X1> l) { } // contradiction\n" +
+					"    public void wildcard2(java.util.List<? super p.@NonNull X1> l) { }\n" +
+					"}\n"
+				},
+				customOptions,
+				"----------\n" + 
+				"1. ERROR in p\\X1.java (at line 7)\n" + 
+				"	public void wildcard1(java.util.List<@Nullable ? extends p.@NonNull X1> l) { } // contradiction\n" + 
+				"	                                                           ^^^^^^^^\n" + 
+				"This nullness annotation conflicts with a \'@Nullable\' annotation which is effective on the same type parameter \n" + 
+				"----------\n");
+		// fix the error:
+		runConformTestWithLibs(
+				new String[] {
+					"p/X1.java",
+					"package p;\n" +
+					"import java.util.*;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public abstract class X1 {\n" +
+					"    public class Inner {}\n" +
+					"    public java.lang.Object []@NonNull[] arrays(java.lang.Object @NonNull[][] oa1) { return null; }\n" +
+					"    public void nesting(@NonNull Inner i1, X1.@Nullable Inner i2) { }\n" +
+					"    public void wildcard1(List<@Nullable ? extends p.X1> l) { }\n" +
+					"    public void wildcard2(List<? super p.@NonNull X1> l) { }\n" +
+					"}\n"
+				},
+				customOptions,
+				"");
+
+		runNegativeTestWithLibs(
+				new String[] {
+					"Y1.java",
+					"import p.X1;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"import java.util.*;\n" +
+					"public class Y1 {\n" +
+					"	void test(X1 x) {\n" +
+					"		java.lang.Object @NonNull[][] a = new java.lang.Object[0][]; // unsafe\n" +
+					"		x.arrays(a)[0] = null; // illegal\n" +
+					"		x.nesting(null, null); // 1st null is illegal\n" +
+					"		x.wildcard2(new ArrayList<java.lang.@NonNull Object>());\n" +
+					"		x.wildcard2(new ArrayList<java.lang.@Nullable Object>()); // incompatible(1)\n" +
+					"		x.wildcard1(new ArrayList<p.@NonNull X1>()); // incompatible(2)\n" +
+					"	}\n" +
+					"}\n"
+				}, 
+				customOptions,
+				"----------\n" + 
+				"1. WARNING in Y1.java (at line 6)\n" + 
+				"	java.lang.Object @NonNull[][] a = new java.lang.Object[0][]; // unsafe\n" + 
+				"	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null type safety (type annotations): The expression of type \'Object[][]\' needs unchecked conversion to conform to \'Object @NonNull[] []\'\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 7)\n" + 
+				"	x.arrays(a)[0] = null; // illegal\n" + 
 				"	^^^^^^^^^^^^^^\n" + 
 				"Null type mismatch: required \'Object @NonNull[]\' but the provided value is null\n" +
 				"----------\n" + 
-				"3. ERROR in Y1.java (at line 7)\n" + 
-				"	x.nesting(null, null);\n" + 
+				"3. ERROR in Y1.java (at line 8)\n" + 
+				"	x.nesting(null, null); // 1st null is illegal\n" + 
 				"	          ^^^^\n" + 
 				"Null type mismatch: required \'X1.@NonNull Inner\' but the provided value is null\n" + 
+				"----------\n" + 
+				"4. ERROR in Y1.java (at line 10)\n" + 
+				"	x.wildcard2(new ArrayList<java.lang.@Nullable Object>()); // incompatible(1)\n" + 
+				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\'\n" + 
+				"----------\n" + 
+				"5. ERROR in Y1.java (at line 11)\n" + 
+				"	x.wildcard1(new ArrayList<p.@NonNull X1>()); // incompatible(2)\n" + 
+				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\'\n" + 
 				"----------\n");
 	}
 
@@ -1763,5 +1998,4 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			getCompilerOptions(),
 			""); 
 	}
-
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 731c758..5c18efb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -187,6 +187,7 @@
  *									RedundantNullCheckAgainstNonNullType
  *									NullAnnotationUnsupportedLocation
  *									NullityMismatchTypeArgument
+ *									ContradictoryNullAnnotationsOnBound
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1697,6 +1698,8 @@ void setSourceStart(int sourceStart);
 	int NullAnnotationUnsupportedLocation = Internal + 960;
 	/** @since 3.9 BETA_JAVA8 */
 	int NullityMismatchTypeArgument = Internal + 961;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContradictoryNullAnnotationsOnBound = Internal + 962;
 
 	// Java 8 work
 	/** @since 3.9 BETA_JAVA8 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 23599c3..88643db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -1022,10 +1022,11 @@ public abstract class Annotation extends Expression {
 								} else if (variable.declaration.type instanceof QualifiedTypeReference) {
 									scope.problemReporter().nullAnnotationUnsupportedLocation(this);
 								} else if (nullTagBits != (variable.type.tagBits & TagBits.AnnotationNullMASK)) {
-									variable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);
-									if ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
+									if (((variable.type.tagBits & TagBits.AnnotationNullMASK) | nullTagBits ) == TagBits.AnnotationNullMASK) {
 										scope.problemReporter().contradictoryNullAnnotations(this);
 										variable.type = variable.type.unannotated();
+									} else {
+										variable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);
 									}
 								}
 							}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index b05fb38..532eac5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -77,6 +77,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 public class MessageSend extends Expression implements InvocationSite {
@@ -102,7 +103,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	flowInfo = this.receiver.analyseCode(currentScope, flowContext, flowInfo, nonStatic).unconditionalInits();
 
 	// recording the closing of AutoCloseable resources:
-	boolean analyseResources = currentScope.compilerOptions().analyseResourceLeaks;
+	CompilerOptions compilerOptions = currentScope.compilerOptions();
+	boolean analyseResources = compilerOptions.analyseResourceLeaks;
 	if (analyseResources) {
 		if (nonStatic) {
 			// closeable.close()
@@ -157,10 +159,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
-	if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
-		ParameterizedGenericMethodBinding parameterizedBinding = (ParameterizedGenericMethodBinding) this.binding;
-		for (int i = 0; i < this.typeArguments.length; i++)
-			parameterizedBinding.checkNullConstraints(currentScope, this.typeArguments[i], i);
+	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+		if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
+			TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
+			for (int i = 0; i < this.typeArguments.length; i++)
+				this.typeArguments[i].checkNullConstraints(currentScope, typeVariables, i);
+		}
 	}
 	ReferenceBinding[] thrownExceptions;
 	if ((thrownExceptions = this.binding.thrownExceptions) != Binding.NO_EXCEPTIONS) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index d5dd8e5..3b7ced7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -170,6 +170,9 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		resolveAnnotations(scope);
 		TypeBinding type = internalResolveLeafType(scope, checkBounds);
 		createArrayType(scope);
+		if (this.typeArguments != null)
+			// relevant null annotations are on the inner most type:
+			checkNullConstraints(scope, this.typeArguments[this.typeArguments.length-1]); 
 		return type == null ? type : this.resolvedType;
 	}
 	private TypeBinding internalResolveLeafType(Scope scope, boolean checkBounds) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 16751a7..237f0de 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -143,6 +143,8 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		this.bits |= ASTNode.DidResolve;
 		TypeBinding type = internalResolveLeafType(scope, enclosingType, checkBounds);
 		resolveAnnotations(scope);
+		checkNullConstraints(scope, this.typeArguments);
+
 		// handle three different outcomes:
 		if (type == null) {
 			this.resolvedType = createArrayType(scope, this.resolvedType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 653dc28..552bfb5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -205,7 +205,7 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 					return 2;
 			}
 		}
-	} else if (requiredType instanceof ParameterizedTypeBinding) {
+	} else if (requiredType.hasNullTypeAnnotations() || providedType.hasNullTypeAnnotations()) {
 		long requiredBits = requiredType.tagBits & TagBits.AnnotationNullMASK;
 		if (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...
 				|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
@@ -213,8 +213,8 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 			long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
 			severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
 		}
-		if (severity < 3) {
-			if (providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
+		if (severity < 2) {
+			if (requiredType.isParameterizedType()  && providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
 				TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
 				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;
 				if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
@@ -224,6 +224,8 @@ protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBindi
 							return severity;
 					}
 				}
+			} else 	if (requiredType instanceof WildcardBinding) {
+				severity = Math.max(severity, findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus));
 			}
 			TypeBinding requiredEnclosing = requiredType.enclosingType();
 			TypeBinding providedEnclosing = providedType.enclosingType();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
index 7122fb6..1c411e9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
@@ -11,8 +11,9 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
+ *     Stephan Herrmann - Contributions for
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415543 - [1.8][compiler] Incorrect bound index in RuntimeInvisibleTypeAnnotations attribute
  *******************************************************************************/
@@ -119,7 +120,7 @@ public class TypeParameter extends AbstractVariableDeclaration {
 		if (resolutionScope != null) {
 			resolveAnnotations(resolutionScope, this.annotations, new Annotation.TypeUseBinding(Binding.TYPE_PARAMETER));
 			if (this.binding != null && this.binding.isValidBinding())
-				this.binding.evaluateNullAnnotations(this.annotations);
+				this.binding.evaluateNullAnnotations(scope, this);
 		}	
 	}
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 65eec85..c4f0344 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -28,6 +28,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationContext;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
@@ -47,6 +48,7 @@ import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 public abstract class TypeReference extends Expression {
@@ -559,7 +561,7 @@ protected void resolveAnnotations(Scope scope) {
 			long[] tagBitsPerDimension = null;
 			int dimensions = this.dimensions();
 			boolean evalNullAnnotations = scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled;
-			boolean isArrayReference = this instanceof ArrayTypeReference && dimensions > 0;
+			boolean isArrayReference = dimensions > 0;
 			if (this.annotations != null) {
 				int annotationsLevels = this.annotations.length;
 				for (int i = 0; i < annotationsLevels; i++) {
@@ -666,4 +668,45 @@ protected TypeBinding captureTypeAnnotations(Scope scope, ReferenceBinding enclo
     	return argType;
 	return scope.environment().createAnnotatedType(argType, annotationBits);
 }
+/** Check all typeArguments against null constraints on their corresponding type variables. */
+void checkNullConstraints(Scope scope, TypeReference[] typeArguments) {
+	CompilerOptions compilerOptions = scope.compilerOptions();
+	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled
+			&& compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8
+			&& typeArguments != null)
+	{
+		TypeVariableBinding[] typeVariables = this.resolvedType.original().typeVariables();
+		for (int i = 0; i < typeArguments.length; i++) {
+			TypeReference arg = typeArguments[i];
+			if (arg.resolvedType != null && arg.resolvedType.hasNullTypeAnnotations())
+				arg.checkNullConstraints(scope, typeVariables, i);
+		}
+	}
+}
+/** Check whether this type reference conforms to all null constraints defined for any of the given type variables. */
+void checkNullConstraints(Scope scope, TypeBinding[] variables, int rank) {
+	if (variables != null && variables.length > rank) {
+		if (variables[rank].hasNullTypeAnnotations()) {
+			if ((this.resolvedType.tagBits & TagBits.AnnotationNullMASK) != (variables[rank].tagBits & TagBits.AnnotationNullMASK)) {
+				scope.problemReporter().nullityMismatchTypeArgument(variables[rank], this.resolvedType, this);
+			}
+    	}
+	}
+}
+/** Retrieve the null annotation that has been translated to the given nullTagBits. */
+public Annotation findAnnotation(long nullTagBits) {
+	if (this.annotations != null) {
+		Annotation[] innerAnnotations = this.annotations[this.annotations.length-1];
+		if (innerAnnotations != null) {
+			int annId = nullTagBits == TagBits.AnnotationNonNull ? TypeIds.T_ConfiguredAnnotationNonNull : TypeIds.T_ConfiguredAnnotationNullable;
+			for (int i = 0; i < innerAnnotations.length; i++) {
+				if (innerAnnotations[i] != null 
+						&& innerAnnotations[i].resolvedType != null 
+						&& innerAnnotations[i].resolvedType.id == annId)
+					return innerAnnotations[i];
+			}
+		}
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
index 57ce687..5235cde 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415397 - [1.8][compiler] Type Annotations on wildcard type argument dropped
+ *        Stephan Herrmann - Contribution for
+ *							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -61,7 +63,6 @@ public class Wildcard extends SingleTypeReference {
 
 	private TypeBinding internalResolveType(Scope scope, ReferenceBinding genericType, int rank) {
 		TypeBinding boundType = null;
-		resolveAnnotations(scope);
 		if (this.bound != null) {
 			boundType = scope.kind == Scope.CLASS_SCOPE
 					? this.bound.resolveType((ClassScope)scope)
@@ -71,8 +72,17 @@ public class Wildcard extends SingleTypeReference {
 				return null;
 			}
 		}
-		WildcardBinding wildcard = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);
-		return this.resolvedType = wildcard;
+		this.resolvedType = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);
+		resolveAnnotations(scope);
+		if (boundType != null && boundType.hasNullTypeAnnotations() && this.resolvedType.hasNullTypeAnnotations()) {
+			if (((boundType.tagBits | this.resolvedType.tagBits) & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) { // are both set?
+				Annotation annotation = this.bound.findAnnotation(boundType.tagBits & TagBits.AnnotationNullMASK);
+				scope.problemReporter().contradictoryNullAnnotationsOnBounds(annotation, this.resolvedType.tagBits);
+				this.resolvedType = this.resolvedType.unannotated();
+				this.bound.resolvedType = ((WildcardBinding)this.resolvedType).bound = boundType.unannotated();
+			}
+		}
+		return this.resolvedType;
 	}
 
 	public StringBuffer printExpression(int indent, StringBuffer output){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index 2ad88f4..1b7b52e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -250,6 +250,23 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, this.pathPtr+2);		
 	}
 
+	/** Walk to the bound of a wildcard. */
+	public TypeAnnotationWalker toWildcardBound() {
+		long newMatches = this.matches;
+		if (newMatches == 0)
+			return EMPTY_ANNOTATION_WALKER;
+		int length = this.typeAnnotations.length;
+		for (int i = 0, mask = 1; i < length; i++, mask = mask << 1) {
+			IBinaryTypeAnnotation candidate = this.typeAnnotations[i];
+			int[] path = candidate.getTypePath();
+			if (this.pathPtr >= path.length 
+					|| path[this.pathPtr] != AnnotationTargetTypeConstants.WILDCARD_BOUND) {
+				newMatches &= ~mask;
+			}
+		}
+		return restrict(newMatches, this.pathPtr+2);		
+	}
+
 	/**
 	 * Descend down one level of array dimensions.
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index b55016e..79970d6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -22,6 +22,7 @@
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1007,7 +1008,7 @@ public TypeBinding createAnnotatedType(TypeBinding genericType, long annotationB
 	}
 	if (genericType instanceof ReferenceBinding) {
 		TypeBinding[] typeArguments = genericType.isParameterizedType() ? ((ParameterizedTypeBinding) genericType).arguments : null;
-		ParameterizedTypeBinding parameterizedType = createParameterizedType((ReferenceBinding) genericType, typeArguments, 
+		ParameterizedTypeBinding parameterizedType = createParameterizedType((ReferenceBinding) genericType.original(), typeArguments, 
 																			annotationBits, genericType.enclosingType());
 		parameterizedType.id = genericType.id; // for well-known types shared the id (only here since those types are not generic, are they?)
 		return parameterizedType;
@@ -1107,6 +1108,9 @@ public RawTypeBinding createRawType(ReferenceBinding genericType, ReferenceBindi
 }
 
 public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind) {
+	return createWildcard(genericType, rank, bound, otherBounds, boundKind, 0);
+}
+public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, long annotationTagBits) {
 	// cached info is array of already created wildcard  types for this type
 	if (genericType == null) // pseudo wildcard denoting composite bounds for lub computation
 		genericType = ReferenceBinding.LUB_GENERIC;
@@ -1121,6 +1125,7 @@ public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, Ty
 			    if (cachedType == null) break nextCachedType;
 			    if (cachedType.genericType != genericType) continue nextCachedType; // remain of unresolved type
 			    if (cachedType.rank != rank) continue nextCachedType;
+			    if ((cachedType.tagBits & TagBits.AnnotationNullMASK) != annotationTagBits) continue nextCachedType;
 			    if (cachedType.boundKind != boundKind) continue nextCachedType;
 			    if (cachedType.bound != bound) continue nextCachedType;
 			    if (cachedType.otherBounds != otherBounds) {
@@ -1147,6 +1152,8 @@ public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, Ty
 	}
 	// add new binding
 	WildcardBinding wildcard = new WildcardBinding(genericType, rank, bound, otherBounds, boundKind, this);
+	if (annotationTagBits != 0)
+		wildcard.tagBits |= annotationTagBits | TagBits.HasNullTypeAnnotation;
 	cachedInfo[index] = wildcard;
 	return wildcard;
 }
@@ -1588,17 +1595,20 @@ TypeBinding getTypeFromVariantTypeSignature(
 		case '-' :
 			// ? super aType
 			wrapper.start++;
-			TypeBinding bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker);
-			return createWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.SUPER);
+			TypeBinding bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker.toWildcardBound());
+			long tagBits = typeAnnotationsToTagBits(walker.getAnnotationsAtCursor());
+			return createWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.SUPER, tagBits);
 		case '+' :
 			// ? extends aType
 			wrapper.start++;
-			bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker);
-			return createWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.EXTENDS);
+			bound = getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker.toWildcardBound());
+			tagBits = typeAnnotationsToTagBits(walker.getAnnotationsAtCursor());
+			return createWildcard(genericType, rank, bound, null /*no extra bound*/, Wildcard.EXTENDS, tagBits);
 		case '*' :
 			// ?
 			wrapper.start++;
-			return createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);
+			tagBits = typeAnnotationsToTagBits(walker.getAnnotationsAtCursor());
+			return createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND, tagBits);
 		default :
 			return getTypeFromTypeSignature(wrapper, staticVariables, enclosingType, missingTypeNames, walker);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index d7d1835..ed6cb01 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -15,7 +15,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
@@ -362,17 +361,6 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    this.parameterNonNullness = originalMethod.parameterNonNullness;
 	}
 
-	public void checkNullConstraints(Scope scope, TypeReference typeArgument, int rank) {
-    	TypeBinding[] variables = this.originalMethod.typeVariables();
-		if (variables != null && variables.length > rank) {
-			if (variables[rank].hasNullTypeAnnotations()) {
-				if ((typeArgument.resolvedType.tagBits & TagBits.AnnotationNullMASK) != (variables[rank].tagBits & TagBits.AnnotationNullMASK)) {
-					scope.problemReporter().nullityMismatchTypeArgument(variables[rank], typeArgument.resolvedType, typeArgument);
-				}
-	    	}
-		}
-	}
-
 	/*
 	 * parameterizedDeclaringUniqueKey dot selector originalMethodGenericSignature percent typeArguments
 	 * p.X<U> { <T> void bar(T t, U u) { new X<String>().bar(this, "") } } --> Lp/X<Ljava/lang/String;>;.bar<T:Ljava/lang/Object;>(TT;Ljava/lang/String;)V%<Lp/X;>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 0e64d2d..1568ef1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -22,6 +22,7 @@
  *								Bug 412076 - [compiler] @NonNullByDefault doesn't work for varargs parameter when in generic interface
  *								Bug 403216 - [1.8][null] TypeReference#captureTypeAnnotations treats type annotations as type argument annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -337,7 +338,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	 */
 	public String debugName() {
 	    StringBuffer nameBuffer = new StringBuffer(10);
-	    appendNullAnnotation(nameBuffer);
+	    appendNullAnnotation(nameBuffer, this.environment.globalOptions);
 	    if (this.type instanceof UnresolvedReferenceBinding) {
 	    	nameBuffer.append(this.type);
 	    } else {
@@ -422,6 +423,9 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	 */
 	public char[] genericTypeSignature() {
 		if (this.genericTypeSignature == null) {
+			if (isAnnotatedTypeWithoutArguments())
+				return this.genericTypeSignature = this.type.genericTypeSignature();
+
 			if ((this.modifiers & ExtraCompilerModifiers.AccGenericSignature) == 0) {
 		    	this.genericTypeSignature = this.type.signature();
 			} else {
@@ -788,9 +792,9 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	}
 
 	public boolean isAnnotatedTypeWithoutArguments() {
-		if (this.arguments != null)
+		if (this.arguments != null || !hasNullTypeAnnotations())
 			return false;
-		if (this.enclosingType != null && this.enclosingType.isParameterizedType())
+		if (this.enclosingType != null && this.enclosingType instanceof ParameterizedTypeBinding)
 			return this.enclosingType.isAnnotatedTypeWithoutArguments();
 		return true;
 	}
@@ -807,7 +811,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 				unannotatedArguments[i] = this.arguments[i].unannotated();
 			}
 		}
-		return this.environment.createParameterizedType(this.type, unannotatedArguments, 
+		return this.environment.createParameterizedType((ReferenceBinding) this.type.unannotated(), unannotatedArguments, 
 				this.enclosingType == null ? null : (ReferenceBinding) this.enclosingType.unannotated());
 	}
 
@@ -995,7 +999,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		if (isMemberType()) {
 			nameBuffer.append(enclosingType().nullAnnotatedReadableName(options, false));
 			nameBuffer.append('.');
-			appendNullAnnotation(nameBuffer);
+			appendNullAnnotation(nameBuffer, options);
 			nameBuffer.append(this.sourceName);
 		} else if (this.type.compoundName != null) {
 			int i;
@@ -1004,11 +1008,11 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 				nameBuffer.append(this.type.compoundName[i]);
 				nameBuffer.append('.');
 			}
-		    appendNullAnnotation(nameBuffer);
+		    appendNullAnnotation(nameBuffer, options);
 			nameBuffer.append(this.type.compoundName[i]);
 		} else {
 			// case of TypeVariableBinding with nullAnnotationTagBits:
-			appendNullAnnotation(nameBuffer);
+			appendNullAnnotation(nameBuffer, options);
 			nameBuffer.append(this.type.sourceName);
 		}
 		if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
@@ -1030,10 +1034,10 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		if (isMemberType()) {
 			nameBuffer.append(enclosingType().nullAnnotatedReadableName(options, true));
 			nameBuffer.append('.');
-			appendNullAnnotation(nameBuffer);
+			appendNullAnnotation(nameBuffer, options);
 			nameBuffer.append(this.sourceName);
 		} else {
-			appendNullAnnotation(nameBuffer);
+			appendNullAnnotation(nameBuffer, options);
 			nameBuffer.append(this.type.sourceName);
 		}
 		if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
@@ -1050,18 +1054,6 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	    return shortReadableName;
 	}
 
-	private void appendNullAnnotation(StringBuffer nameBuffer) {
-		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
-			// restore applied null annotation from tagBits:
-		    if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
-		    	char[][] nonNullAnnotationName = environment().getNonNullAnnotationName();
-				nameBuffer.append('@').append(nonNullAnnotationName[nonNullAnnotationName.length-1]).append(' ');
-		    } else if ((this.tagBits & TagBits.AnnotationNullable) != 0) {
-		    	char[][] nullableAnnotationName = environment().getNullableAnnotationName();
-				nameBuffer.append('@').append(nullableAnnotationName[nullableAnnotationName.length-1]).append(' ');
-		    }
-		}
-	}
 
 	/**
 	 * @see org.eclipse.jdt.internal.compiler.lookup.TypeBinding#signature()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 8171dfc..e7f60c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -38,6 +38,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 /*
@@ -1496,6 +1497,19 @@ public char[] readableName() /*java.lang.Object,  p.X<T> */ {
 	return readableName;
 }
 
+protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options) {
+	if (options.isAnnotationBasedNullAnalysisEnabled) {
+		// restore applied null annotation from tagBits:
+	    if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
+	    	char[][] nonNullAnnotationName = options.nonNullAnnotationName;
+			nameBuffer.append('@').append(nonNullAnnotationName[nonNullAnnotationName.length-1]).append(' ');
+	    } else if ((this.tagBits & TagBits.AnnotationNullable) != 0) {
+	    	char[][] nullableAnnotationName = options.nullableAnnotationName;
+			nameBuffer.append('@').append(nullableAnnotationName[nullableAnnotationName.length-1]).append(' ');
+	    }
+	}
+}
+
 public AnnotationHolder retrieveAnnotationHolder(Binding binding, boolean forceInitialization) {
 	SimpleLookupTable store = storedAnnotations(forceInitialization);
 	return store == null ? null : (AnnotationHolder) store.get(binding);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index b45f898..088072a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -24,6 +24,8 @@ package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
@@ -546,7 +548,8 @@ public class TypeVariableBinding extends ReferenceBinding {
 		return this.superclass; // java/lang/Object
 	}
 
-	public void evaluateNullAnnotations(Annotation[] annotations) {
+	public void evaluateNullAnnotations(Scope scope, TypeParameter parameter) {
+		Annotation[] annotations = parameter.annotations;
 		int len = annotations.length;
 		for (int j=0; j<len; j++) {
 			Binding recipient = annotations[j].recipient;
@@ -564,7 +567,11 @@ public class TypeVariableBinding extends ReferenceBinding {
 				if (nullTagBits == 0L) {
 					nullTagBits |= superNullTagBits;
 				} else if (superNullTagBits != nullTagBits) {
-//					System.err.println("TODO(stephan): report proper error: conflict TypeVariable vs. first bound");
+					// not finding either bound or ann should be considered a compiler bug
+					TypeReference bound = findBound(this.firstBound, parameter);
+					Annotation ann = bound.findAnnotation(superNullTagBits);
+					scope.problemReporter().contradictoryNullAnnotationsOnBounds(ann, nullTagBits);
+					this.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
 			}
 		}	
@@ -578,7 +585,11 @@ public class TypeVariableBinding extends ReferenceBinding {
 					if (nullTagBits == 0L) {
 						nullTagBits |= superNullTagBits;
 					} else if (superNullTagBits != nullTagBits) {
-//						System.err.println("TODO(stephan): report proper error: conflict TypeVariable vs. bound "+i);
+						// not finding either bound or ann should be considered a compiler bug
+						TypeReference bound = findBound(this.firstBound, parameter);
+						Annotation ann = bound.findAnnotation(superNullTagBits);
+						scope.problemReporter().contradictoryNullAnnotationsOnBounds(ann, nullTagBits);
+						this.tagBits &= ~TagBits.AnnotationNullMASK;
 					}
 				}
 				interfaces[i] = resolveType;
@@ -587,4 +598,16 @@ public class TypeVariableBinding extends ReferenceBinding {
 		if (nullTagBits != 0)
 			this.tagBits |= nullTagBits | TagBits.HasNullTypeAnnotation;
 	}
+	private TypeReference findBound(TypeBinding bound, TypeParameter parameter) {
+		if (parameter.type != null && parameter.type.resolvedType == bound)
+			return parameter.type;
+		TypeReference[] bounds = parameter.bounds;
+		if (bounds != null) {
+			for (int i = 0; i < bounds.length; i++) {
+				if (bounds[i].resolvedType == bound)
+					return bounds[i];
+			}
+		}
+		return null;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index bdbf393..9e265a7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -23,6 +23,7 @@ import java.util.List;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 /*
  * A wildcard acts as an argument for parameterized types, allowing to
@@ -451,12 +452,12 @@ public class WildcardBinding extends ReferenceBinding {
 			this.fPackage = someGenericType.getPackage();
 		}
 		if (someBound != null) {
-			this.tagBits |= someBound.tagBits & (TagBits.HasTypeVariable | TagBits.HasMissingType | TagBits.ContainsNestedTypeReferences);
+			this.tagBits |= someBound.tagBits & (TagBits.HasTypeVariable | TagBits.HasMissingType | TagBits.ContainsNestedTypeReferences | TagBits.HasNullTypeAnnotation);
 		}
 		if (someOtherBounds != null) {
 			for (int i = 0, max = someOtherBounds.length; i < max; i++) {
 				TypeBinding someOtherBound = someOtherBounds[i];
-				this.tagBits |= someOtherBound.tagBits & TagBits.ContainsNestedTypeReferences;
+				this.tagBits |= someOtherBound.tagBits & (TagBits.ContainsNestedTypeReferences | TagBits.HasNullTypeAnnotation);
 			}
 		}
 	}
@@ -524,6 +525,32 @@ public class WildcardBinding extends ReferenceBinding {
         }
     }
 
+    public char[] nullAnnotatedReadableName(CompilerOptions options, boolean shortNames) {
+    	StringBuffer buffer = new StringBuffer(10);
+    	appendNullAnnotation(buffer, options);
+        switch (this.boundKind) {
+            case Wildcard.UNBOUND :
+                buffer.append(TypeConstants.WILDCARD_NAME);
+                break;
+            case Wildcard.EXTENDS :
+            	if (this.otherBounds == null) {
+            		buffer.append(TypeConstants.WILDCARD_NAME).append(TypeConstants.WILDCARD_EXTENDS).append(this.bound.readableName());
+            	} else {
+	            	buffer.append(this.bound.nullAnnotatedReadableName(options, shortNames));
+	            	for (int i = 0, length = this.otherBounds.length; i < length; i++) {
+	            		buffer.append('&').append(this.otherBounds[i].nullAnnotatedReadableName(options, shortNames));
+	            	}
+            	}
+            	break;
+			default: // SUPER
+			    buffer.append(TypeConstants.WILDCARD_NAME).append(TypeConstants.WILDCARD_SUPER).append(this.bound.nullAnnotatedReadableName(options, shortNames));
+        }
+        int length;
+        char[] result = new char[length = buffer.length()];
+        buffer.getChars(0, length, result, 0);
+        return result;
+    }
+
 	ReferenceBinding resolve() {
 		if ((this.tagBits & TagBits.HasUnresolvedTypeVariables) == 0)
 			return this;
@@ -709,4 +736,17 @@ public class WildcardBinding extends ReferenceBinding {
 		}
 		return this.typeVariable;
 	}
+
+	public TypeBinding unannotated() {
+		if (!hasNullTypeAnnotations())
+			return this;
+		TypeBinding boundType = this.bound.unannotated();
+		TypeBinding[] otherBoundTypes = null;
+		if (this.otherBounds != null) {
+			otherBoundTypes = new TypeBinding[this.otherBounds.length];
+			for (int i = 0; i < this.otherBounds.length; i++)
+				otherBoundTypes[i] = this.otherBounds[i].unannotated();
+		}
+		return this.environment.createWildcard(this.genericType, this.rank, boundType, otherBoundTypes, this.boundKind);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index e7a61ec..c5197a8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -9195,6 +9195,17 @@ public void contradictoryNullAnnotations(Annotation annotation) {
 	this.handle(IProblem.ContradictoryNullAnnotations, arguments, shortArguments, annotation.sourceStart, annotation.sourceEnd);
 }
 
+public void contradictoryNullAnnotationsOnBounds(Annotation annotation, long previousTagBit) {
+	char[][] annotationName = previousTagBit == TagBits.AnnotationNonNull ? this.options.nonNullAnnotationName : this.options.nullableAnnotationName;
+	String[] arguments = {
+		new String(CharOperation.concatWith(annotationName, '.')),
+	};
+	String[] shortArguments = {
+		new String(annotationName[annotationName.length-1]),
+	};
+	this.handle(IProblem.ContradictoryNullAnnotationsOnBound, arguments, shortArguments, annotation.sourceStart, annotation.sourceEnd);
+}
+
 // conflict default <-> inherited
 public void conflictingNullAnnotations(MethodBinding currentMethod, ASTNode location, MethodBinding inheritedMethod)
 {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 2bf60c3..5e504b5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -787,6 +787,7 @@
 959 = Redundant null check: comparing ''{0}'' against null
 960 = The nullness annotation ''{0}'' is not applicable at this location
 961 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
+962 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
