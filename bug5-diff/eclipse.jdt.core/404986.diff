commit 11bdf7ee83fa535bb4e922a4f202eec91a5eb529
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Fri Apr 5 13:06:20 2013 +0200

    Bug 404986: [dom ast] Add a debug option to verify proper nesting of ASTNodes

6	0	org.eclipse.jdt.core/.options
22	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
51	59	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
62	62	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
113	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
13	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
diff --git a/org.eclipse.jdt.core/.options b/org.eclipse.jdt.core/.options
index 64fe054..3a2a221 100644
--- a/org.eclipse.jdt.core/.options
+++ b/org.eclipse.jdt.core/.options
@@ -25,6 +25,12 @@ org.eclipse.jdt.core/debug/cpresolution/advanced=false
 # Reports failures during classpath variable initialization, and classpath container resolution
 org.eclipse.jdt.core/debug/cpresolution/failure=false
 
+# Reports bad node nesting in DOM AST
+org.eclipse.jdt.core/debug/dom/ast=false
+
+# Throws an exception in case of bad node nesting in DOM AST
+org.eclipse.jdt.core/debug/dom/ast/throw=false
+
 # Reports type errors when using ASTRewrite
 org.eclipse.jdt.core/debug/dom/rewrite=false
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 7e3bcfb..cbcf616 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -54,6 +54,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.core.dom.SourceRangeVerifier;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -1249,6 +1250,26 @@ class ASTConverter {
 				lookupForScopes();
 			}
 			compilationUnit.initCommentMapper(this.scanner);
+			if (SourceRangeVerifier.DEBUG) {
+				String bugs = new SourceRangeVerifier().process(compilationUnit);
+				if (bugs != null) {
+					StringBuffer message = new StringBuffer("Bad AST node structure:");  //$NON-NLS-1$
+					String lineDelimiter = Util.findLineSeparator(source);
+					if (lineDelimiter == null) lineDelimiter = System.getProperty("line.separator");//$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append(bugs.replaceAll("\n", lineDelimiter)); //$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append("----------------------------------- SOURCE BEGIN -------------------------------------"); //$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append(source);
+					message.append(lineDelimiter);
+					message.append("----------------------------------- SOURCE END -------------------------------------"); //$NON-NLS-1$
+					Util.log(new IllegalStateException("Bad AST node structure"), message.toString()); //$NON-NLS-1$
+					if (SourceRangeVerifier.DEBUG_THROW) {
+						throw new IllegalStateException(message.toString());
+					}
+				}
+			}
 			return compilationUnit;
 		} catch(IllegalArgumentException e) {
 			StringBuffer message = new StringBuffer("Exception occurred during compilation unit conversion:");  //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
index 7973867..fdb31e7 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2010 IBM Corporation and others.
+ * Copyright (c) 2004, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -52,16 +52,16 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 		internalModifiers2PropertyFactory(AnnotationTypeMemberDeclaration.class);
 
 	/**
-	 * The "name" structural property of this node type (child type: {@link SimpleName}).
+	 * The "type" structural property of this node type (child type: {@link Type}).
 	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+			new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "type" structural property of this node type (child type: {@link Type}).
+	 * The "name" structural property of this node type (child type: {@link SimpleName}).
 	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "default" structural property of this node type (child type: {@link Expression}).
@@ -81,8 +81,8 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 		createPropertyList(AnnotationTypeMemberDeclaration.class, properyList);
 		addProperty(JAVADOC_PROPERTY, properyList);
 		addProperty(MODIFIERS2_PROPERTY, properyList);
-		addProperty(NAME_PROPERTY, properyList);
 		addProperty(TYPE_PROPERTY, properyList);
+		addProperty(NAME_PROPERTY, properyList);
 		addProperty(DEFAULT_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
 	}
@@ -101,15 +101,15 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 	}
 
 	/**
-	 * The member name; lazily initialized; defaults to an unspecified,
-	 * legal Java identifier.
+	 * The member type; lazily initialized; defaults to int.
 	 */
-	private SimpleName memberName = null;
+	private Type memberType = null;
 
 	/**
-	 * The member type; lazily initialized; defaults to int.
+	 * The member name; lazily initialized; defaults to an unspecified,
+	 * legal Java identifier.
 	 */
-	private Type memberType = null;
+	private SimpleName memberName = null;
 
 	/**
 	 * The optional default expression; <code>null</code> for none; defaults to none.
@@ -153,11 +153,11 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 				return null;
 			}
 		}
-		if (property == NAME_PROPERTY) {
+		if (property == TYPE_PROPERTY) {
 			if (get) {
-				return getName();
+				return getType();
 			} else {
-				setName((SimpleName) child);
+				setType((Type) child);
 				return null;
 			}
 		}
@@ -169,14 +169,6 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 				return null;
 			}
 		}
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
 		if (property == DEFAULT_PROPERTY) {
 			if (get) {
 				return getDefault();
@@ -269,84 +261,84 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 	}
 
 	/**
-	 * Returns the name of the annotation type member declared in this declaration.
+	 * Returns the type of the annotation type member declared in this
+	 * declaration.
 	 *
-	 * @return the member name node
+	 * @return the type of the member
 	 */
-	public SimpleName getName() {
-		if (this.memberName == null) {
+	public Type getType() {
+		if (this.memberType == null) {
 			// lazy init must be thread-safe for readers
 			synchronized (this) {
-				if (this.memberName == null) {
+				if (this.memberType == null) {
 					preLazyInit();
-					this.memberName = new SimpleName(this.ast);
-					postLazyInit(this.memberName, NAME_PROPERTY);
+					this.memberType = this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.memberType, TYPE_PROPERTY);
 				}
 			}
 		}
-		return this.memberName;
+		return this.memberType;
 	}
 
 	/**
-	 * Sets the name of the annotation type member declared in this declaration to the
-	 * given name.
+	 * Sets the type of the annotation type member declared in this declaration
+	 * to the given type.
 	 *
-	 * @param memberName the new member name
+	 * @param type the new member type
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * </ul>
 	 */
-	public void setName(SimpleName memberName) {
-		if (memberName == null) {
+	public void setType(Type type) {
+		if (type == null) {
 			throw new IllegalArgumentException();
 		}
-		ASTNode oldChild = this.memberName;
-		preReplaceChild(oldChild, memberName, NAME_PROPERTY);
-		this.memberName = memberName;
-		postReplaceChild(oldChild, memberName, NAME_PROPERTY);
+		ASTNode oldChild = this.memberType;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.memberType = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
 	}
 
 	/**
-	 * Returns the type of the annotation type member declared in this
-	 * declaration.
+	 * Returns the name of the annotation type member declared in this declaration.
 	 *
-	 * @return the type of the member
+	 * @return the member name node
 	 */
-	public Type getType() {
-		if (this.memberType == null) {
+	public SimpleName getName() {
+		if (this.memberName == null) {
 			// lazy init must be thread-safe for readers
 			synchronized (this) {
-				if (this.memberType == null) {
+				if (this.memberName == null) {
 					preLazyInit();
-					this.memberType = this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.memberType, TYPE_PROPERTY);
+					this.memberName = new SimpleName(this.ast);
+					postLazyInit(this.memberName, NAME_PROPERTY);
 				}
 			}
 		}
-		return this.memberType;
+		return this.memberName;
 	}
 
 	/**
-	 * Sets the type of the annotation type member declared in this declaration
-	 * to the given type.
+	 * Sets the name of the annotation type member declared in this declaration to the
+	 * given name.
 	 *
-	 * @param type the new member type
+	 * @param memberName the new member name
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * </ul>
 	 */
-	public void setType(Type type) {
-		if (type == null) {
+	public void setName(SimpleName memberName) {
+		if (memberName == null) {
 			throw new IllegalArgumentException();
 		}
-		ASTNode oldChild = this.memberType;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.memberType = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+		ASTNode oldChild = this.memberName;
+		preReplaceChild(oldChild, memberName, NAME_PROPERTY);
+		this.memberName = memberName;
+		postReplaceChild(oldChild, memberName, NAME_PROPERTY);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
index 228d1ae..b54f3ed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -28,13 +28,6 @@ import java.util.List;
 public class DoStatement extends Statement {
 
 	/**
-	 * The "expression" structural property of this node type (child type: {@link Expression}).
-	 * @since 3.0
-	 */
-	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
-		new ChildPropertyDescriptor(DoStatement.class, "expression", Expression.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
-
-	/**
 	 * The "body" structural property of this node type (child type: {@link Statement}).
 	 * @since 3.0
 	 */
@@ -42,6 +35,13 @@ public class DoStatement extends Statement {
 		new ChildPropertyDescriptor(DoStatement.class, "body", Statement.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
+	 * The "expression" structural property of this node type (child type: {@link Expression}).
+	 * @since 3.0
+	 */
+	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
+			new ChildPropertyDescriptor(DoStatement.class, "expression", Expression.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
+	
+	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -51,8 +51,8 @@ public class DoStatement extends Statement {
 	static {
 		List properyList = new ArrayList(3);
 		createPropertyList(DoStatement.class, properyList);
-		addProperty(EXPRESSION_PROPERTY, properyList);
 		addProperty(BODY_PROPERTY, properyList);
+		addProperty(EXPRESSION_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
 	}
 
@@ -72,19 +72,19 @@ public class DoStatement extends Statement {
 	}
 
 	/**
+	 * The body statement; lazily initialized; defaults to an empty block.
+	 */
+	private Statement body = null;
+	
+	/**
 	 * The expression; lazily initialized; defaults to an unspecified, but
 	 * legal, expression.
 	 */
 	private Expression expression = null;
 
 	/**
-	 * The body statement; lazily initialized; defaults to an empty block.
-	 */
-	private Statement body = null;
-
-	/**
 	 * Creates a new unparented do statement node owned by the given
-	 * AST. By default, the expresssion is unspecified, but legal,
+	 * AST. By default, the expression is unspecified, but legal,
 	 * and the body statement is an empty block.
 	 * <p>
 	 * N.B. This constructor is package-private.
@@ -107,19 +107,19 @@ public class DoStatement extends Statement {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == EXPRESSION_PROPERTY) {
+		if (property == BODY_PROPERTY) {
 			if (get) {
-				return getExpression();
+				return getBody();
 			} else {
-				setExpression((Expression) child);
+				setBody((Statement) child);
 				return null;
 			}
 		}
-		if (property == BODY_PROPERTY) {
+		if (property == EXPRESSION_PROPERTY) {
 			if (get) {
-				return getBody();
+				return getExpression();
 			} else {
-				setBody((Statement) child);
+				setExpression((Expression) child);
 				return null;
 			}
 		}
@@ -141,8 +141,8 @@ public class DoStatement extends Statement {
 		DoStatement result = new DoStatement(target);
 		result.setSourceRange(getStartPosition(), getLength());
 		result.copyLeadingComment(this);
-		result.setExpression((Expression) getExpression().clone(target));
 		result.setBody((Statement) getBody().clone(target));
+		result.setExpression((Expression) getExpression().clone(target));
 		return result;
 	}
 
@@ -168,46 +168,6 @@ public class DoStatement extends Statement {
 	}
 
 	/**
-	 * Returns the expression of this do statement.
-	 *
-	 * @return the expression node
-	 */
-	public Expression getExpression() {
-		if (this.expression == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.expression == null) {
-					preLazyInit();
-					this.expression = new SimpleName(this.ast);
-					postLazyInit(this.expression, EXPRESSION_PROPERTY);
-				}
-			}
-		}
-		return this.expression;
-	}
-
-	/**
-	 * Sets the expression of this do statement.
-	 *
-	 * @param expression the expression node
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * <li>a cycle in would be created</li>
-	 * </ul>
-	 */
-	public void setExpression(Expression expression) {
-		if (expression == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.expression;
-		preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-		this.expression = expression;
-		postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-	}
-
-	/**
 	 * Returns the body of this do statement.
 	 *
 	 * @return the body statement node
@@ -255,6 +215,46 @@ public class DoStatement extends Statement {
 		postReplaceChild(oldChild, statement, BODY_PROPERTY);
 	}
 
+    /**
+     * Returns the expression of this do statement.
+     *
+     * @return the expression node
+     */
+    public Expression getExpression() {
+        if (this.expression == null) {
+            // lazy init must be thread-safe for readers
+            synchronized (this) {
+                if (this.expression == null) {
+                    preLazyInit();
+                    this.expression = new SimpleName(this.ast);
+                    postLazyInit(this.expression, EXPRESSION_PROPERTY);
+                }
+            }
+        }
+        return this.expression;
+    }
+
+    /**
+     * Sets the expression of this do statement.
+     *
+     * @param expression the expression node
+     * @exception IllegalArgumentException if:
+     * <ul>
+     * <li>the node belongs to a different AST</li>
+     * <li>the node already has a parent</li>
+     * <li>a cycle in would be created</li>
+     * </ul>
+     */
+    public void setExpression(Expression expression) {
+        if (expression == null) {
+            throw new IllegalArgumentException();
+        }
+        ASTNode oldChild = this.expression;
+        preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+        this.expression = expression;
+        postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+    }
+
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
new file mode 100644
index 0000000..d261a12
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
@@ -0,0 +1,113 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.dom;
+
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
+
+public class SourceRangeVerifier extends ASTVisitor {
+
+	public static boolean DEBUG = false;
+	public static boolean DEBUG_THROW = false;
+	
+	private StringBuffer bugs; 
+	
+	/**
+	 * Verifies proper node nesting as specified in {@link ASTParser#setKind(int)}:
+	 * <p>
+	 * Source ranges nest properly: the source range for a child is always
+	 * within the source range of its parent, and the source ranges of sibling
+	 * nodes never overlap.
+	 * </p>
+	 * 
+	 * @param node
+	 * @return <code>null</code> if everything is OK; a list of errors otherwise
+	 */
+	public String process(ASTNode node) {
+		StringBuffer buffer = new StringBuffer();
+		this.bugs = buffer;
+		node.accept(this);
+		this.bugs = null;
+		if (buffer.length() == 0)
+			return null;
+		return buffer.toString();
+	}
+	
+	public boolean preVisit2(ASTNode node) {
+		ASTNode previous = null;
+		
+		List properties = node.structuralPropertiesForType();
+		for (int i = 0; i < properties.size(); i++) {
+			StructuralPropertyDescriptor property = (StructuralPropertyDescriptor) properties.get(i);
+			if (property.isChildProperty()) {
+				ASTNode child = (ASTNode) node.getStructuralProperty(property);
+				if (child != null) {
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			} else if (property.isChildListProperty()) {
+				List children = (List) node.getStructuralProperty(property);
+				for (int j= 0; j < children.size(); j++) {
+					ASTNode child = (ASTNode) children.get(j);
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	private boolean checkChild(ASTNode parent, ASTNode previous, ASTNode child) {
+		if ((parent.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0
+				|| (child.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0)
+			return false; 
+		
+		int parentStart = parent.getStartPosition();
+		int parentEnd = parentStart + parent.getLength();
+		
+		int childStart = child.getStartPosition();
+		int childEnd = childStart + child.getLength();
+		
+		if (previous != null) {
+			// Turn a blind eye on a known problem ... see https://bugs.eclipse.org/391894#c4
+			if (child.getLocationInParent() == ArrayCreation.DIMENSIONS_PROPERTY)
+				return false;
+			
+			int previousStart = previous.getStartPosition();
+			int previousEnd = previousStart + previous.getLength();
+			if (childStart < previousEnd) {
+				String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   previous [" + previousStart + ", " + previousEnd + "] "  + previous.getClass().getName() + '\n'//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				this.bugs.append(bug);
+			}
+		}
+		if (!(parentStart <= childStart && childEnd <= parentEnd)) {
+			String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+					   + "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			this.bugs.append(bug);
+		}
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 711f1eb..0d1635a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -52,6 +52,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
 import org.eclipse.jdt.internal.core.JavaProjectElementInfo.ProjectCache;
 import org.eclipse.jdt.internal.core.builder.JavaBuilder;
+import org.eclipse.jdt.internal.core.dom.SourceRangeVerifier;
 import org.eclipse.jdt.internal.core.dom.rewrite.RewriteEventStore;
 import org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy;
 import org.eclipse.jdt.internal.core.search.AbstractSearchScope;
@@ -246,6 +247,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	private static final String ZIP_ACCESS_DEBUG = JavaCore.PLUGIN_ID + "/debug/zipaccess" ; //$NON-NLS-1$
 	private static final String DELTA_DEBUG =JavaCore.PLUGIN_ID + "/debug/javadelta" ; //$NON-NLS-1$
 	private static final String DELTA_DEBUG_VERBOSE =JavaCore.PLUGIN_ID + "/debug/javadelta/verbose" ; //$NON-NLS-1$
+	private static final String DOM_AST_DEBUG = JavaCore.PLUGIN_ID + "/debug/dom/ast" ; //$NON-NLS-1$
+	private static final String DOM_AST_DEBUG_THROW = JavaCore.PLUGIN_ID + "/debug/dom/ast/throw" ; //$NON-NLS-1$
 	private static final String DOM_REWRITE_DEBUG = JavaCore.PLUGIN_ID + "/debug/dom/rewrite" ; //$NON-NLS-1$
 	private static final String HIERARCHY_DEBUG = JavaCore.PLUGIN_ID + "/debug/hierarchy" ; //$NON-NLS-1$
 	private static final String POST_ACTION_DEBUG = JavaCore.PLUGIN_ID + "/debug/postaction" ; //$NON-NLS-1$
@@ -1659,9 +1662,18 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 			option = Platform.getDebugOption(DELTA_DEBUG_VERBOSE);
 			if(option != null) DeltaProcessor.VERBOSE = option.equalsIgnoreCase(TRUE) ;
 
+			option = Platform.getDebugOption(DOM_AST_DEBUG);
+			if(option != null) SourceRangeVerifier.DEBUG = option.equalsIgnoreCase(TRUE) ;
+
+			option = Platform.getDebugOption(DOM_AST_DEBUG_THROW);
+			if(option != null) {
+				SourceRangeVerifier.DEBUG_THROW = option.equalsIgnoreCase(TRUE) ;
+				SourceRangeVerifier.DEBUG |= SourceRangeVerifier.DEBUG_THROW;
+			}
+			
 			option = Platform.getDebugOption(DOM_REWRITE_DEBUG);
 			if(option != null) RewriteEventStore.DEBUG = option.equalsIgnoreCase(TRUE) ;
-
+			
 			option = Platform.getDebugOption(HIERARCHY_DEBUG);
 			if(option != null) TypeHierarchy.DEBUG = option.equalsIgnoreCase(TRUE) ;
 
commit 2c5129ccdeb3bec0116f7310eb4a5f7c456e0788
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Fri Apr 5 13:06:20 2013 +0200

    Bug 404986: [dom ast] Add a debug option to verify proper nesting of ASTNodes

6	0	org.eclipse.jdt.core/.options
21	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
51	59	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
62	62	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
113	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
13	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
diff --git a/org.eclipse.jdt.core/.options b/org.eclipse.jdt.core/.options
index 64fe054..3a2a221 100644
--- a/org.eclipse.jdt.core/.options
+++ b/org.eclipse.jdt.core/.options
@@ -25,6 +25,12 @@ org.eclipse.jdt.core/debug/cpresolution/advanced=false
 # Reports failures during classpath variable initialization, and classpath container resolution
 org.eclipse.jdt.core/debug/cpresolution/failure=false
 
+# Reports bad node nesting in DOM AST
+org.eclipse.jdt.core/debug/dom/ast=false
+
+# Throws an exception in case of bad node nesting in DOM AST
+org.eclipse.jdt.core/debug/dom/ast/throw=false
+
 # Reports type errors when using ASTRewrite
 org.eclipse.jdt.core/debug/dom/rewrite=false
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index df43987..b790622 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -59,6 +59,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.core.dom.SourceRangeVerifier;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -1369,6 +1370,26 @@ class ASTConverter {
 				lookupForScopes();
 			}
 			compilationUnit.initCommentMapper(this.scanner);
+			if (SourceRangeVerifier.DEBUG) {
+				String bugs = new SourceRangeVerifier().process(compilationUnit);
+				if (bugs != null) {
+					StringBuffer message = new StringBuffer("Bad AST node structure:");  //$NON-NLS-1$
+					String lineDelimiter = Util.findLineSeparator(source);
+					if (lineDelimiter == null) lineDelimiter = System.getProperty("line.separator");//$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append(bugs.replaceAll("\n", lineDelimiter)); //$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append("----------------------------------- SOURCE BEGIN -------------------------------------"); //$NON-NLS-1$
+					message.append(lineDelimiter);
+					message.append(source);
+					message.append(lineDelimiter);
+					message.append("----------------------------------- SOURCE END -------------------------------------"); //$NON-NLS-1$
+					Util.log(new IllegalStateException("Bad AST node structure"), message.toString()); //$NON-NLS-1$
+					if (SourceRangeVerifier.DEBUG_THROW) {
+						throw new IllegalStateException(message.toString());
+					}
+				}
+			}
 			return compilationUnit;
 		} catch(IllegalArgumentException e) {
 			StringBuffer message = new StringBuffer("Exception occurred during compilation unit conversion:");  //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
index 7973867..fdb31e7 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotationTypeMemberDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2010 IBM Corporation and others.
+ * Copyright (c) 2004, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -52,16 +52,16 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 		internalModifiers2PropertyFactory(AnnotationTypeMemberDeclaration.class);
 
 	/**
-	 * The "name" structural property of this node type (child type: {@link SimpleName}).
+	 * The "type" structural property of this node type (child type: {@link Type}).
 	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+			new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "type" structural property of this node type (child type: {@link Type}).
+	 * The "name" structural property of this node type (child type: {@link SimpleName}).
 	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(AnnotationTypeMemberDeclaration.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "default" structural property of this node type (child type: {@link Expression}).
@@ -81,8 +81,8 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 		createPropertyList(AnnotationTypeMemberDeclaration.class, properyList);
 		addProperty(JAVADOC_PROPERTY, properyList);
 		addProperty(MODIFIERS2_PROPERTY, properyList);
-		addProperty(NAME_PROPERTY, properyList);
 		addProperty(TYPE_PROPERTY, properyList);
+		addProperty(NAME_PROPERTY, properyList);
 		addProperty(DEFAULT_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
 	}
@@ -101,15 +101,15 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 	}
 
 	/**
-	 * The member name; lazily initialized; defaults to an unspecified,
-	 * legal Java identifier.
+	 * The member type; lazily initialized; defaults to int.
 	 */
-	private SimpleName memberName = null;
+	private Type memberType = null;
 
 	/**
-	 * The member type; lazily initialized; defaults to int.
+	 * The member name; lazily initialized; defaults to an unspecified,
+	 * legal Java identifier.
 	 */
-	private Type memberType = null;
+	private SimpleName memberName = null;
 
 	/**
 	 * The optional default expression; <code>null</code> for none; defaults to none.
@@ -153,11 +153,11 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 				return null;
 			}
 		}
-		if (property == NAME_PROPERTY) {
+		if (property == TYPE_PROPERTY) {
 			if (get) {
-				return getName();
+				return getType();
 			} else {
-				setName((SimpleName) child);
+				setType((Type) child);
 				return null;
 			}
 		}
@@ -169,14 +169,6 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 				return null;
 			}
 		}
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
 		if (property == DEFAULT_PROPERTY) {
 			if (get) {
 				return getDefault();
@@ -269,84 +261,84 @@ public class AnnotationTypeMemberDeclaration extends BodyDeclaration {
 	}
 
 	/**
-	 * Returns the name of the annotation type member declared in this declaration.
+	 * Returns the type of the annotation type member declared in this
+	 * declaration.
 	 *
-	 * @return the member name node
+	 * @return the type of the member
 	 */
-	public SimpleName getName() {
-		if (this.memberName == null) {
+	public Type getType() {
+		if (this.memberType == null) {
 			// lazy init must be thread-safe for readers
 			synchronized (this) {
-				if (this.memberName == null) {
+				if (this.memberType == null) {
 					preLazyInit();
-					this.memberName = new SimpleName(this.ast);
-					postLazyInit(this.memberName, NAME_PROPERTY);
+					this.memberType = this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.memberType, TYPE_PROPERTY);
 				}
 			}
 		}
-		return this.memberName;
+		return this.memberType;
 	}
 
 	/**
-	 * Sets the name of the annotation type member declared in this declaration to the
-	 * given name.
+	 * Sets the type of the annotation type member declared in this declaration
+	 * to the given type.
 	 *
-	 * @param memberName the new member name
+	 * @param type the new member type
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * </ul>
 	 */
-	public void setName(SimpleName memberName) {
-		if (memberName == null) {
+	public void setType(Type type) {
+		if (type == null) {
 			throw new IllegalArgumentException();
 		}
-		ASTNode oldChild = this.memberName;
-		preReplaceChild(oldChild, memberName, NAME_PROPERTY);
-		this.memberName = memberName;
-		postReplaceChild(oldChild, memberName, NAME_PROPERTY);
+		ASTNode oldChild = this.memberType;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.memberType = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
 	}
 
 	/**
-	 * Returns the type of the annotation type member declared in this
-	 * declaration.
+	 * Returns the name of the annotation type member declared in this declaration.
 	 *
-	 * @return the type of the member
+	 * @return the member name node
 	 */
-	public Type getType() {
-		if (this.memberType == null) {
+	public SimpleName getName() {
+		if (this.memberName == null) {
 			// lazy init must be thread-safe for readers
 			synchronized (this) {
-				if (this.memberType == null) {
+				if (this.memberName == null) {
 					preLazyInit();
-					this.memberType = this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.memberType, TYPE_PROPERTY);
+					this.memberName = new SimpleName(this.ast);
+					postLazyInit(this.memberName, NAME_PROPERTY);
 				}
 			}
 		}
-		return this.memberType;
+		return this.memberName;
 	}
 
 	/**
-	 * Sets the type of the annotation type member declared in this declaration
-	 * to the given type.
+	 * Sets the name of the annotation type member declared in this declaration to the
+	 * given name.
 	 *
-	 * @param type the new member type
+	 * @param memberName the new member name
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * </ul>
 	 */
-	public void setType(Type type) {
-		if (type == null) {
+	public void setName(SimpleName memberName) {
+		if (memberName == null) {
 			throw new IllegalArgumentException();
 		}
-		ASTNode oldChild = this.memberType;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.memberType = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+		ASTNode oldChild = this.memberName;
+		preReplaceChild(oldChild, memberName, NAME_PROPERTY);
+		this.memberName = memberName;
+		postReplaceChild(oldChild, memberName, NAME_PROPERTY);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
index 228d1ae..b54f3ed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -28,13 +28,6 @@ import java.util.List;
 public class DoStatement extends Statement {
 
 	/**
-	 * The "expression" structural property of this node type (child type: {@link Expression}).
-	 * @since 3.0
-	 */
-	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
-		new ChildPropertyDescriptor(DoStatement.class, "expression", Expression.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
-
-	/**
 	 * The "body" structural property of this node type (child type: {@link Statement}).
 	 * @since 3.0
 	 */
@@ -42,6 +35,13 @@ public class DoStatement extends Statement {
 		new ChildPropertyDescriptor(DoStatement.class, "body", Statement.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
+	 * The "expression" structural property of this node type (child type: {@link Expression}).
+	 * @since 3.0
+	 */
+	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
+			new ChildPropertyDescriptor(DoStatement.class, "expression", Expression.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
+	
+	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -51,8 +51,8 @@ public class DoStatement extends Statement {
 	static {
 		List properyList = new ArrayList(3);
 		createPropertyList(DoStatement.class, properyList);
-		addProperty(EXPRESSION_PROPERTY, properyList);
 		addProperty(BODY_PROPERTY, properyList);
+		addProperty(EXPRESSION_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
 	}
 
@@ -72,19 +72,19 @@ public class DoStatement extends Statement {
 	}
 
 	/**
+	 * The body statement; lazily initialized; defaults to an empty block.
+	 */
+	private Statement body = null;
+	
+	/**
 	 * The expression; lazily initialized; defaults to an unspecified, but
 	 * legal, expression.
 	 */
 	private Expression expression = null;
 
 	/**
-	 * The body statement; lazily initialized; defaults to an empty block.
-	 */
-	private Statement body = null;
-
-	/**
 	 * Creates a new unparented do statement node owned by the given
-	 * AST. By default, the expresssion is unspecified, but legal,
+	 * AST. By default, the expression is unspecified, but legal,
 	 * and the body statement is an empty block.
 	 * <p>
 	 * N.B. This constructor is package-private.
@@ -107,19 +107,19 @@ public class DoStatement extends Statement {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == EXPRESSION_PROPERTY) {
+		if (property == BODY_PROPERTY) {
 			if (get) {
-				return getExpression();
+				return getBody();
 			} else {
-				setExpression((Expression) child);
+				setBody((Statement) child);
 				return null;
 			}
 		}
-		if (property == BODY_PROPERTY) {
+		if (property == EXPRESSION_PROPERTY) {
 			if (get) {
-				return getBody();
+				return getExpression();
 			} else {
-				setBody((Statement) child);
+				setExpression((Expression) child);
 				return null;
 			}
 		}
@@ -141,8 +141,8 @@ public class DoStatement extends Statement {
 		DoStatement result = new DoStatement(target);
 		result.setSourceRange(getStartPosition(), getLength());
 		result.copyLeadingComment(this);
-		result.setExpression((Expression) getExpression().clone(target));
 		result.setBody((Statement) getBody().clone(target));
+		result.setExpression((Expression) getExpression().clone(target));
 		return result;
 	}
 
@@ -168,46 +168,6 @@ public class DoStatement extends Statement {
 	}
 
 	/**
-	 * Returns the expression of this do statement.
-	 *
-	 * @return the expression node
-	 */
-	public Expression getExpression() {
-		if (this.expression == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.expression == null) {
-					preLazyInit();
-					this.expression = new SimpleName(this.ast);
-					postLazyInit(this.expression, EXPRESSION_PROPERTY);
-				}
-			}
-		}
-		return this.expression;
-	}
-
-	/**
-	 * Sets the expression of this do statement.
-	 *
-	 * @param expression the expression node
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * <li>a cycle in would be created</li>
-	 * </ul>
-	 */
-	public void setExpression(Expression expression) {
-		if (expression == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.expression;
-		preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-		this.expression = expression;
-		postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-	}
-
-	/**
 	 * Returns the body of this do statement.
 	 *
 	 * @return the body statement node
@@ -255,6 +215,46 @@ public class DoStatement extends Statement {
 		postReplaceChild(oldChild, statement, BODY_PROPERTY);
 	}
 
+    /**
+     * Returns the expression of this do statement.
+     *
+     * @return the expression node
+     */
+    public Expression getExpression() {
+        if (this.expression == null) {
+            // lazy init must be thread-safe for readers
+            synchronized (this) {
+                if (this.expression == null) {
+                    preLazyInit();
+                    this.expression = new SimpleName(this.ast);
+                    postLazyInit(this.expression, EXPRESSION_PROPERTY);
+                }
+            }
+        }
+        return this.expression;
+    }
+
+    /**
+     * Sets the expression of this do statement.
+     *
+     * @param expression the expression node
+     * @exception IllegalArgumentException if:
+     * <ul>
+     * <li>the node belongs to a different AST</li>
+     * <li>the node already has a parent</li>
+     * <li>a cycle in would be created</li>
+     * </ul>
+     */
+    public void setExpression(Expression expression) {
+        if (expression == null) {
+            throw new IllegalArgumentException();
+        }
+        ASTNode oldChild = this.expression;
+        preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+        this.expression = expression;
+        postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+    }
+
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
new file mode 100644
index 0000000..d261a12
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
@@ -0,0 +1,113 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.dom;
+
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
+
+public class SourceRangeVerifier extends ASTVisitor {
+
+	public static boolean DEBUG = false;
+	public static boolean DEBUG_THROW = false;
+	
+	private StringBuffer bugs; 
+	
+	/**
+	 * Verifies proper node nesting as specified in {@link ASTParser#setKind(int)}:
+	 * <p>
+	 * Source ranges nest properly: the source range for a child is always
+	 * within the source range of its parent, and the source ranges of sibling
+	 * nodes never overlap.
+	 * </p>
+	 * 
+	 * @param node
+	 * @return <code>null</code> if everything is OK; a list of errors otherwise
+	 */
+	public String process(ASTNode node) {
+		StringBuffer buffer = new StringBuffer();
+		this.bugs = buffer;
+		node.accept(this);
+		this.bugs = null;
+		if (buffer.length() == 0)
+			return null;
+		return buffer.toString();
+	}
+	
+	public boolean preVisit2(ASTNode node) {
+		ASTNode previous = null;
+		
+		List properties = node.structuralPropertiesForType();
+		for (int i = 0; i < properties.size(); i++) {
+			StructuralPropertyDescriptor property = (StructuralPropertyDescriptor) properties.get(i);
+			if (property.isChildProperty()) {
+				ASTNode child = (ASTNode) node.getStructuralProperty(property);
+				if (child != null) {
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			} else if (property.isChildListProperty()) {
+				List children = (List) node.getStructuralProperty(property);
+				for (int j= 0; j < children.size(); j++) {
+					ASTNode child = (ASTNode) children.get(j);
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	private boolean checkChild(ASTNode parent, ASTNode previous, ASTNode child) {
+		if ((parent.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0
+				|| (child.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0)
+			return false; 
+		
+		int parentStart = parent.getStartPosition();
+		int parentEnd = parentStart + parent.getLength();
+		
+		int childStart = child.getStartPosition();
+		int childEnd = childStart + child.getLength();
+		
+		if (previous != null) {
+			// Turn a blind eye on a known problem ... see https://bugs.eclipse.org/391894#c4
+			if (child.getLocationInParent() == ArrayCreation.DIMENSIONS_PROPERTY)
+				return false;
+			
+			int previousStart = previous.getStartPosition();
+			int previousEnd = previousStart + previous.getLength();
+			if (childStart < previousEnd) {
+				String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   previous [" + previousStart + ", " + previousEnd + "] "  + previous.getClass().getName() + '\n'//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				this.bugs.append(bug);
+			}
+		}
+		if (!(parentStart <= childStart && childEnd <= parentEnd)) {
+			String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+					   + "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			this.bugs.append(bug);
+		}
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 711f1eb..0d1635a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -52,6 +52,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
 import org.eclipse.jdt.internal.core.JavaProjectElementInfo.ProjectCache;
 import org.eclipse.jdt.internal.core.builder.JavaBuilder;
+import org.eclipse.jdt.internal.core.dom.SourceRangeVerifier;
 import org.eclipse.jdt.internal.core.dom.rewrite.RewriteEventStore;
 import org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy;
 import org.eclipse.jdt.internal.core.search.AbstractSearchScope;
@@ -246,6 +247,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	private static final String ZIP_ACCESS_DEBUG = JavaCore.PLUGIN_ID + "/debug/zipaccess" ; //$NON-NLS-1$
 	private static final String DELTA_DEBUG =JavaCore.PLUGIN_ID + "/debug/javadelta" ; //$NON-NLS-1$
 	private static final String DELTA_DEBUG_VERBOSE =JavaCore.PLUGIN_ID + "/debug/javadelta/verbose" ; //$NON-NLS-1$
+	private static final String DOM_AST_DEBUG = JavaCore.PLUGIN_ID + "/debug/dom/ast" ; //$NON-NLS-1$
+	private static final String DOM_AST_DEBUG_THROW = JavaCore.PLUGIN_ID + "/debug/dom/ast/throw" ; //$NON-NLS-1$
 	private static final String DOM_REWRITE_DEBUG = JavaCore.PLUGIN_ID + "/debug/dom/rewrite" ; //$NON-NLS-1$
 	private static final String HIERARCHY_DEBUG = JavaCore.PLUGIN_ID + "/debug/hierarchy" ; //$NON-NLS-1$
 	private static final String POST_ACTION_DEBUG = JavaCore.PLUGIN_ID + "/debug/postaction" ; //$NON-NLS-1$
@@ -1659,9 +1662,18 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 			option = Platform.getDebugOption(DELTA_DEBUG_VERBOSE);
 			if(option != null) DeltaProcessor.VERBOSE = option.equalsIgnoreCase(TRUE) ;
 
+			option = Platform.getDebugOption(DOM_AST_DEBUG);
+			if(option != null) SourceRangeVerifier.DEBUG = option.equalsIgnoreCase(TRUE) ;
+
+			option = Platform.getDebugOption(DOM_AST_DEBUG_THROW);
+			if(option != null) {
+				SourceRangeVerifier.DEBUG_THROW = option.equalsIgnoreCase(TRUE) ;
+				SourceRangeVerifier.DEBUG |= SourceRangeVerifier.DEBUG_THROW;
+			}
+			
 			option = Platform.getDebugOption(DOM_REWRITE_DEBUG);
 			if(option != null) RewriteEventStore.DEBUG = option.equalsIgnoreCase(TRUE) ;
-
+			
 			option = Platform.getDebugOption(HIERARCHY_DEBUG);
 			if(option != null) TypeHierarchy.DEBUG = option.equalsIgnoreCase(TRUE) ;
 
