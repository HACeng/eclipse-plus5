commit ac33227f5aefea8ca107e0dff1e50be7a78ccf5b
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Nov 2 12:03:59 2014 +0530

    Fixed Bug 447573 [1.8][compiler] Rename IntersectionCastTypeBinding as
    IntersectionTypeBinding18

2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
11	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
0	292	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
292	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 6eb3f83..191776f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -302,7 +302,7 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 		return true;
 	}
 
-	if (castType.isIntersectionCastType()) {
+	if (castType.isIntersectionType18()) {
 		ReferenceBinding [] intersectingTypes = castType.getIntersectingTypes();
 		for (int i = 0, length = intersectingTypes.length; i < length; i++) {
 			if (!checkCastTypesCompatibility(scope, intersectingTypes[i], expressionType, expression))
@@ -382,7 +382,7 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 			if (bound == null) bound = scope.getJavaLangObject();
 			// recursively on the type variable upper bound
 			return checkCastTypesCompatibility(scope, castType, bound, expression);
-		case Binding.INTERSECTION_CAST_TYPE:
+		case Binding.INTERSECTION_TYPE18:
 			ReferenceBinding [] intersectingTypes = expressionType.getIntersectingTypes();
 			for (int i = 0, length = intersectingTypes.length; i < length; i++) {
 				if (checkCastTypesCompatibility(scope, castType, intersectingTypes[i], expression))
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 52f3ab2..1405887 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -35,7 +35,7 @@ import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
-import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
@@ -347,8 +347,8 @@ public abstract class FunctionalExpression extends Expression {
 		}
 		
 		ReferenceBinding functionalType;
-		if (this.expectedType instanceof IntersectionCastTypeBinding) {
-			functionalType = (ReferenceBinding) ((IntersectionCastTypeBinding)this.expectedType).getSAMType(this.enclosingScope);
+		if (this.expectedType instanceof IntersectionTypeBinding18) {
+			functionalType = (ReferenceBinding) ((IntersectionTypeBinding18)this.expectedType).getSAMType(this.enclosingScope);
 		} else {
 			functionalType = (ReferenceBinding) this.expectedType;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
index 3ae7952..67c21ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
@@ -20,7 +20,7 @@ import java.util.Map;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
-import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
@@ -127,7 +127,7 @@ public class IntersectionCastTypeReference extends TypeReference {
 			}
 			System.arraycopy(intersectingTypes, 0, intersectingTypes = new ReferenceBinding[typeCount], 0, typeCount);
 		}
-		IntersectionCastTypeBinding intersectionType = (IntersectionCastTypeBinding) scope.environment().createIntersectionCastType(intersectingTypes);
+		IntersectionTypeBinding18 intersectionType = (IntersectionTypeBinding18) scope.environment().createIntersectionType18(intersectingTypes);
 		// check for parameterized interface collisions (when different parameterizations occur)
 		ReferenceBinding itsSuperclass = null;
 		ReferenceBinding[] interfaces = intersectingTypes;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 51cc847..7d81920 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -69,7 +69,7 @@ import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
-import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
@@ -199,8 +199,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			codeStream.generateOuterAccess(path, this, capturedOuterLocal, currentScope);
 		}
 		signature.append(')');
-		if (this.expectedType instanceof IntersectionCastTypeBinding) {
-			signature.append(((IntersectionCastTypeBinding)this.expectedType).getSAMType(currentScope).signature());
+		if (this.expectedType instanceof IntersectionTypeBinding18) {
+			signature.append(((IntersectionTypeBinding18)this.expectedType).getSAMType(currentScope).signature());
 		} else {
 			signature.append(this.expectedType.signature());
 		}
@@ -317,8 +317,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		if (!argumentsTypeElided && !buggyArguments) {
 			ReferenceBinding groundType = null;
 			ReferenceBinding expectedSAMType = null;
-			if (this.expectedType instanceof IntersectionCastTypeBinding)
-				expectedSAMType = (ReferenceBinding) ((IntersectionCastTypeBinding) this.expectedType).getSAMType(blockScope); 
+			if (this.expectedType instanceof IntersectionTypeBinding18)
+				expectedSAMType = (ReferenceBinding) ((IntersectionTypeBinding18) this.expectedType).getSAMType(blockScope); 
 			else if (this.expectedType instanceof ReferenceBinding)
 				expectedSAMType = (ReferenceBinding) this.expectedType;
 			if (expectedSAMType != null)
@@ -427,8 +427,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		} else {
 			this.body.resolve(this.scope);
 		}
-		if (this.expectedType instanceof IntersectionCastTypeBinding) {
-			ReferenceBinding[] intersectingTypes =  ((IntersectionCastTypeBinding)this.expectedType).intersectingTypes;
+		if (this.expectedType instanceof IntersectionTypeBinding18) {
+			ReferenceBinding[] intersectingTypes =  ((IntersectionTypeBinding18)this.expectedType).intersectingTypes;
 			for (int t = 0, max = intersectingTypes.length; t < max; t++) {
 				if (intersectingTypes[t].findSuperTypeOriginatingFrom(TypeIds.T_JavaIoSerializable, false /*Serializable is not a class*/) != null) {
 					this.isSerializable = true;
@@ -794,8 +794,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		}
 
 		ReferenceBinding expectedSAMType = null;
-		if (left instanceof IntersectionCastTypeBinding)
-			expectedSAMType = (ReferenceBinding) ((IntersectionCastTypeBinding) left).getSAMType(this.enclosingScope); 
+		if (left instanceof IntersectionTypeBinding18)
+			expectedSAMType = (ReferenceBinding) ((IntersectionTypeBinding18) left).getSAMType(this.enclosingScope); 
 		else if (left instanceof ReferenceBinding)
 			expectedSAMType = (ReferenceBinding) left;
 		ReferenceBinding groundTargetType = expectedSAMType != null ? findGroundTargetType(this.enclosingScope, expectedSAMType, argumentsTypeElided()) : null;
@@ -1263,9 +1263,9 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	}
 
 	public TypeBinding[] getMarkerInterfaces() {
-		if (this.expectedType instanceof IntersectionCastTypeBinding) {
+		if (this.expectedType instanceof IntersectionTypeBinding18) {
 			Set markerBindings = new LinkedHashSet();
-			TypeBinding[] intersectionTypes = ((IntersectionCastTypeBinding)this.expectedType).intersectingTypes;
+			TypeBinding[] intersectionTypes = ((IntersectionTypeBinding18)this.expectedType).intersectingTypes;
 			for (int i = 0,max = intersectionTypes.length; i < max; i++) {
 				TypeBinding typeBinding = intersectionTypes[i];
 				MethodBinding methodBinding = typeBinding.getSingleAbstractMethod(this.scope, true);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 60a8cda..d424ffd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -58,7 +58,7 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
-import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
@@ -191,7 +191,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		// these cases are either too complicated, impossible to handle or result in significant code duplication 
 		return (this.binding.isVarargs() || 
 				(isConstructorReference() && this.receiverType.syntheticOuterLocalVariables() != null && currentScope.methodScope().isStatic) ||
-				this.expectedType instanceof IntersectionCastTypeBinding || // marker interfaces require alternate meta factory.
+				this.expectedType instanceof IntersectionTypeBinding18 || // marker interfaces require alternate meta factory.
 				this.expectedType.findSuperTypeOriginatingFrom(currentScope.getJavaIoSerializable()) != null || // serialization support.
 				this.requiresBridges()); // bridges.
 		// To fix: We should opt for direct code generation wherever possible.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index e2e4d63..ac08e31 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -2653,8 +2653,8 @@ public void generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding met
 				ConstantPool.GetFunctionalInterfaceClass, ConstantPool.GetFunctionalInterfaceClassSignature);
 		String functionalInterface = null;
 		final TypeBinding expectedType = lambdaEx.expectedType();
-		if (expectedType instanceof IntersectionCastTypeBinding) {
-			functionalInterface = new String(((IntersectionCastTypeBinding)expectedType).getSAMType(scope).constantPoolName());
+		if (expectedType instanceof IntersectionTypeBinding18) {
+			functionalInterface = new String(((IntersectionTypeBinding18)expectedType).getSAMType(scope).constantPoolName());
 		} else {
 			functionalInterface = new String(expectedType.constantPoolName());
 		}
@@ -2726,8 +2726,8 @@ public void generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding met
 			sig.append(varType.signature());
 		}
 		sig.append(")"); //$NON-NLS-1$
-		if (lambdaEx.resolvedType instanceof IntersectionCastTypeBinding) {
-			sig.append(((IntersectionCastTypeBinding)lambdaEx.resolvedType).getSAMType(scope).signature());
+		if (lambdaEx.resolvedType instanceof IntersectionTypeBinding18) {
+			sig.append(((IntersectionTypeBinding18)lambdaEx.resolvedType).getSAMType(scope).signature());
 		} else {
 			sig.append(lambdaEx.resolvedType.signature());
 		}
@@ -3376,7 +3376,7 @@ public static TypeBinding getConstantPoolDeclaringClass(Scope currentScope, Meth
 						&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(isImplicitThisReceiver && codegenBinding.isStatic()))
 						&& codegenBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object methods
 					|| !codegenBinding.declaringClass.canBeSeenBy(currentScope)) {
-				if (!actualReceiverType.isIntersectionCastType()) // no constant pool representation. FIXME, visibility issue not handled.
+				if (!actualReceiverType.isIntersectionType18()) // no constant pool representation. FIXME, visibility issue not handled.
 					constantPoolDeclaringClass = actualReceiverType.erasure();
 			}
 		}				
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
index fc0bc74..14489de 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
@@ -229,7 +229,7 @@ public class AnnotatableTypeSystem extends TypeSystem {
 			case Binding.TYPE_PARAMETER:
 			case Binding.WILDCARD_TYPE:
 			case Binding.INTERSECTION_TYPE:
-			case Binding.INTERSECTION_CAST_TYPE:
+			case Binding.INTERSECTION_TYPE18:
 				/* Taking the binding of QTR as an example, there could be different annotatable components, but we come in a with a single binding, e.g: 
 				   @T Z;                                      type => Z  annotations => [[@T]]
 				   @T Y.@T Z                                  type => Z  annotations => [[@T][@T]]
@@ -314,7 +314,7 @@ public class AnnotatableTypeSystem extends TypeSystem {
 						case Binding.ARRAY_TYPE:
 						case Binding.RAW_TYPE:
 						case Binding.WILDCARD_TYPE:
-						case Binding.INTERSECTION_CAST_TYPE:
+						case Binding.INTERSECTION_TYPE18:
 						case Binding.INTERSECTION_TYPE:
 							continue;
 					}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index 08abc3e..46203de 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -38,7 +38,7 @@ public abstract class Binding {
 	public static final int INTERSECTION_TYPE = TYPE | ASTNode.Bit14;
 	// jsr 308
 	public static final int TYPE_USE = TYPE | ASTNode.Bit15;
-	public static final int INTERSECTION_CAST_TYPE = TYPE | ASTNode.Bit16;
+	public static final int INTERSECTION_TYPE18 = TYPE | ASTNode.Bit16;
 	public static final int POLY_TYPE = TYPE | ASTNode.Bit17;
 	
 	// In the unlikely event you add a new type binding, remember to update TypeBindingVisitor and Scope.substitute methods. 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 9860d08..28666f5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -656,7 +656,7 @@ class BoundSet {
 										ReferenceBinding[] allBounds = new ReferenceBinding[n];
 										allBounds[0] = (ReferenceBinding) bi1; // TODO is this safe?
 										System.arraycopy(otherBounds, 0, allBounds, 1, n-1);
-										bi = context.environment.createIntersectionCastType(allBounds);
+										bi = context.environment.createIntersectionType18(allBounds);
 									}
 									addTypeBoundsFromWildcardBound(context, theta, wildcardBinding.boundKind, t, r, bi);
 									//										if (otherBounds != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java
index 29718e5..9bd9374 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java
@@ -90,7 +90,7 @@ public class CaptureBinding18 extends CaptureBinding {
 			}
 			if (!multipleErasures)
 				return erasures[0];
-			return this.environment.createIntersectionCastType(erasures);
+			return this.environment.createIntersectionType18(erasures);
 		}
 		return super.erasure();
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 3680cd1..0ce5421 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -810,7 +810,7 @@ private ReferenceBinding typeToRecord(TypeBinding type) {
 		case Binding.TYPE_PARAMETER :
 		case Binding.WILDCARD_TYPE :
 		case Binding.INTERSECTION_TYPE :
-		case Binding.INTERSECTION_CAST_TYPE: // constituents would have been recorded.
+		case Binding.INTERSECTION_TYPE18: // constituents would have been recorded.
 		case Binding.POLY_TYPE: // not a real type, will mutate into one, hopefully soon.
 			return null;
 		case Binding.PARAMETERIZED_TYPE :
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
index 4e7994a..485c80d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
@@ -307,8 +307,8 @@ class ConstraintTypeFormula extends ConstraintFormula {
 			case Binding.INTERSECTION_TYPE:
 				superCandidate = ((WildcardBinding) superCandidate).allBounds();
 				//$FALL-THROUGH$
-			case Binding.INTERSECTION_CAST_TYPE:
-				TypeBinding[] intersectingTypes = ((IntersectionCastTypeBinding) superCandidate).intersectingTypes;
+			case Binding.INTERSECTION_TYPE18:
+				TypeBinding[] intersectingTypes = ((IntersectionTypeBinding18) superCandidate).intersectingTypes;
 				ConstraintFormula[] result = new ConstraintFormula[intersectingTypes.length];
 				for (int i = 0; i < intersectingTypes.length; i++) {
 					result[i] = ConstraintTypeFormula.create(subCandidate, intersectingTypes[i], SUBTYPE, this.isSoft);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index 41ba454..975f67c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -678,8 +678,8 @@ public class InferenceContext18 {
 				// "... none of the following is true:" 
 				if (siSuperI(si, funcI) || siSubI(si, funcI))
 					return null;
-				if (si instanceof IntersectionCastTypeBinding) {
-					TypeBinding[] elements = ((IntersectionCastTypeBinding)si).intersectingTypes;
+				if (si instanceof IntersectionTypeBinding18) {
+					TypeBinding[] elements = ((IntersectionTypeBinding18)si).intersectingTypes;
 					checkSuper: {
 						for (int i = 0; i < elements.length; i++)
 							if (!siSuperI(elements[i], funcI))
@@ -945,7 +945,7 @@ public class InferenceContext18 {
 											} else if (glbs.length == 1) {
 												glb = glbs[0];
 											} else {
-												IntersectionCastTypeBinding intersection = (IntersectionCastTypeBinding) this.environment.createIntersectionCastType(glbs);
+												IntersectionTypeBinding18 intersection = (IntersectionTypeBinding18) this.environment.createIntersectionType18(glbs);
 												if (!ReferenceBinding.isConsistentIntersection(intersection.intersectingTypes)) {
 													tmpBoundSet = prevBoundSet; // clean up
 													break variables; // and start over
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
deleted file mode 100644
index 0df8c19..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
- *							Bug 426676 - [1.8][compiler] Wrong generic method type inferred from lambda expression
- *							Bug 426542 - [1.8] Most specific method not picked when one method has intersection type as type parameter
- *							Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
- *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
- *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
- *******************************************************************************/
-
-package org.eclipse.jdt.internal.compiler.lookup;
-
-import java.util.Set;
-
-import org.eclipse.jdt.internal.compiler.ast.Wildcard;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-
-public class IntersectionCastTypeBinding extends ReferenceBinding {
-
-	public ReferenceBinding [] intersectingTypes;
-	private ReferenceBinding javaLangObject;
-	int length;
-	
-	public IntersectionCastTypeBinding(ReferenceBinding[] intersectingTypes, LookupEnvironment environment) {
-		this.intersectingTypes = intersectingTypes;
-		this.length = intersectingTypes.length;
-		if (!intersectingTypes[0].isClass()) {
-			this.javaLangObject = environment.getResolvedType(TypeConstants.JAVA_LANG_OBJECT, null);
-			this.modifiers |= ClassFileConstants.AccInterface;
-		}
-	}
-	
-	private IntersectionCastTypeBinding(IntersectionCastTypeBinding prototype) {
-		this.intersectingTypes = prototype.intersectingTypes;
-		this.length = prototype.length;
-		if (!this.intersectingTypes[0].isClass()) {
-			this.javaLangObject = prototype.javaLangObject;
-			this.modifiers |= ClassFileConstants.AccInterface;
-		}
-	}
-	
-	@Override
-	public TypeBinding clone(TypeBinding enclosingType) {
-		return new IntersectionCastTypeBinding(this);
-	}
-	
-	public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
-		int index = replaceWildcards ? 0 : 1;
-		if (this.singleAbstractMethod != null) {
-			if (this.singleAbstractMethod[index] != null)
-			return this.singleAbstractMethod[index];
-		} else {
-			this.singleAbstractMethod = new MethodBinding[2];
-		}
-		MethodBinding sam = samProblemBinding;  // guilty unless proven innocent !
-		for (int i = 0; i < this.length; i++) {
-			MethodBinding method = this.intersectingTypes[i].getSingleAbstractMethod(scope, replaceWildcards);
-			if (method != null) {
-				if (method.isValidBinding()) {
-					if (sam.isValidBinding())
-						return this.singleAbstractMethod[index] = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.IntersectionHasMultipleFunctionalInterfaces);
-					else
-						sam = method;
-				}
-			}
-		}
-		return this.singleAbstractMethod[index] = sam; // I don't see a value in building the notional interface described in 9.8 - it appears just pedantic/normative - perhaps it plays a role in wildcard parameterized types ?
-	}
-
-	public boolean hasTypeBit(int bit) { // Stephan ??
-		for (int i = 0; i < this.length; i++) {		
-			if (this.intersectingTypes[i].hasTypeBit(bit))
-				return true;
-		}
-		return false;
-	}
-
-	public boolean canBeInstantiated() {
-		return false;
-	}
-	
-	public boolean canBeSeenBy(PackageBinding invocationPackage) {
-		for (int i = 0; i < this.length; i++) {
-			if (!this.intersectingTypes[i].canBeSeenBy(invocationPackage))
-				return false;
-		}
-		return true;
-	}
-	
-	public boolean canBeSeenBy(Scope scope) {
-		for (int i = 0; i < this.length; i++) {
-			if (!this.intersectingTypes[i].canBeSeenBy(scope))
-				return false;
-		}
-		return true;
-	}
-	
-	public boolean canBeSeenBy(ReferenceBinding receiverType, ReferenceBinding invocationType) {
-		for (int i = 0; i < this.length; i++) {
-			if (!this.intersectingTypes[i].canBeSeenBy(receiverType, invocationType))
-				return false;
-		}
-		return true;
-	}
-	
-	
-	public char[] constantPoolName() {
-		return this.intersectingTypes[0].constantPoolName();
-	}
-
-	public PackageBinding getPackage() {
-		throw new UnsupportedOperationException(); // cannot be referred to
-	}
-	
-	public ReferenceBinding[] getIntersectingTypes() {
-		return this.intersectingTypes;
-	}
-
-	public ReferenceBinding superclass() {
-		return this.intersectingTypes[0].isClass() ? this.intersectingTypes[0] : this.javaLangObject; 
-	}
-	
-	public ReferenceBinding [] superInterfaces() {
-		if (this.intersectingTypes[0].isClass()) {
-			ReferenceBinding [] superInterfaces = new ReferenceBinding[this.length - 1];
-			System.arraycopy(this.intersectingTypes, 1, superInterfaces, 0, this.length - 1);
-			return superInterfaces;
-		}
-		return this.intersectingTypes;
-	}
-	
-	@Override
-	public boolean isBoxedPrimitiveType() {
-		return this.intersectingTypes[0].isBoxedPrimitiveType();
-	}
-	
-	/* Answer true if the receiver type can be assigned to the argument type (right)
-	 */
-	public boolean isCompatibleWith(TypeBinding right, Scope scope) {
-
-		// easy way out?
-		if (TypeBinding.equalsEquals(this, right))
-			return true;
-
-		// need to compare two intersection types?
-		int rightKind = right.kind();
-		TypeBinding[] rightIntersectingTypes = null;
-		if (rightKind == INTERSECTION_TYPE && right.boundKind() == Wildcard.EXTENDS) {
-			TypeBinding allRightBounds = ((WildcardBinding) right).allBounds();
-			if (allRightBounds instanceof IntersectionCastTypeBinding)
-				rightIntersectingTypes = ((IntersectionCastTypeBinding) allRightBounds).intersectingTypes;
-		} else if (rightKind == INTERSECTION_CAST_TYPE) {
-			rightIntersectingTypes = ((IntersectionCastTypeBinding) right).intersectingTypes;
-		}
-		if (rightIntersectingTypes != null) {
-			int numRequired = rightIntersectingTypes.length;
-			TypeBinding[] required = new TypeBinding[numRequired];
-			System.arraycopy(rightIntersectingTypes, 0, required, 0, numRequired);
-			for (int i = 0; i < this.length; i++) {
-				TypeBinding provided = this.intersectingTypes[i];
-				for (int j = 0; j < required.length; j++) {
-					if (required[j] == null) continue;
-					if (provided.isCompatibleWith(required[j], scope)) {
-						required[j] = null;
-						if (--numRequired == 0)
-							return true;
-						break;
-					}
-				}
-			}
-			return false;
-		}
-
-		// normal case:
-		for (int i = 0; i < this.length; i++) {		
-			if (this.intersectingTypes[i].isCompatibleWith(right, scope))
-				return true;
-		}
-		return false;
-	}
-	
-	@Override
-	public boolean isSubtypeOf(TypeBinding other) {
-		if (TypeBinding.equalsEquals(this, other))
-			return true;
-		for (int i = 0; i < this.intersectingTypes.length; i++) {
-			if (this.intersectingTypes[i].isSubtypeOf(other))
-				return true;
-		}
-		return false;
-	}
-
-	public char[] qualifiedSourceName() {
-		StringBuffer qualifiedSourceName = new StringBuffer(16);
-		for (int i = 0; i < this.length; i++) {		
-				qualifiedSourceName.append(this.intersectingTypes[i].qualifiedSourceName());
-				if (i != this.length - 1)
-					qualifiedSourceName.append(" & "); //$NON-NLS-1$
-		}
-		return qualifiedSourceName.toString().toCharArray();
-	}
-
-	public char[] sourceName() {
-		StringBuffer srcName = new StringBuffer(16);
-		for (int i = 0; i < this.length; i++) {		
-				srcName.append(this.intersectingTypes[i].sourceName());
-				if (i != this.length - 1)
-					srcName.append(" & "); //$NON-NLS-1$
-		}
-		return srcName.toString().toCharArray();
-	}
-
-	public char[] readableName() {
-		StringBuffer readableName = new StringBuffer(16);
-		for (int i = 0; i < this.length; i++) {		
-				readableName.append(this.intersectingTypes[i].readableName());
-				if (i != this.length - 1)
-					readableName.append(" & "); //$NON-NLS-1$
-		}
-		return readableName.toString().toCharArray();
-	}
-	public char[] shortReadableName() {
-		StringBuffer shortReadableName = new StringBuffer(16);
-		for (int i = 0; i < this.length; i++) {		
-				shortReadableName.append(this.intersectingTypes[i].shortReadableName());
-				if (i != this.length - 1)
-					shortReadableName.append(" & "); //$NON-NLS-1$
-		}
-		return shortReadableName.toString().toCharArray();
-	}
-	public boolean isIntersectionCastType() {
-		return true;
-	}
-	public int kind() {
-		return Binding.INTERSECTION_CAST_TYPE;
-	}
-	public String debugName() {
-		StringBuffer debugName = new StringBuffer(16);
-		for (int i = 0; i < this.length; i++) {		
-				debugName.append(this.intersectingTypes[i].debugName());
-				if (i != this.length - 1)
-					debugName.append(" & "); //$NON-NLS-1$
-		}
-		return debugName.toString();
-	}
-	public String toString() {
-	    return debugName();
-	}
-
-	public TypeBinding getSAMType(Scope scope) {
-		TypeBinding samType = null;
-		for (int i = 0, max = this.intersectingTypes.length; i < max; i++) {
-			TypeBinding typeBinding = this.intersectingTypes[i];
-			MethodBinding methodBinding = typeBinding.getSingleAbstractMethod(scope, true);
-			// Why doesn't getSingleAbstractMethod do as the javadoc says, and return null
-			// when it is not a SAM type
-			if (methodBinding instanceof ProblemMethodBinding && ((ProblemMethodBinding) methodBinding).problemId()==ProblemReasons.NoSuchSingleAbstractMethod) {
-				continue;
-			}
-			if (samType != null) {
-				return null; // There is more than one (!), so we don't know which
-			}
-			samType = typeBinding;
-		}
-		return samType;
-	}
-
-	@Override
-	void collectInferenceVariables(Set<InferenceVariable> variables) {
-		for (int i = 0; i < this.intersectingTypes.length; i++)
-			this.intersectingTypes[i].collectInferenceVariables(variables);
-	}
-	
-	@Override
-	public boolean mentionsAny(TypeBinding[] parameters, int idx) {
-		if (super.mentionsAny(parameters, idx))
-			return true;
-		for (int i = 0; i < this.intersectingTypes.length; i++) {
-			if (this.intersectingTypes[i].mentionsAny(parameters, -1))
-				return true;
-		}
-		return false;
-	}
-}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
new file mode 100644
index 0000000..538c0ec
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
@@ -0,0 +1,292 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
+ *							Bug 426676 - [1.8][compiler] Wrong generic method type inferred from lambda expression
+ *							Bug 426542 - [1.8] Most specific method not picked when one method has intersection type as type parameter
+ *							Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.compiler.lookup;
+
+import java.util.Set;
+
+import org.eclipse.jdt.internal.compiler.ast.Wildcard;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+
+public class IntersectionTypeBinding18 extends ReferenceBinding { // abstraction used for intersection casts in Java 8 + type inference at 1.8+
+
+	public ReferenceBinding [] intersectingTypes;
+	private ReferenceBinding javaLangObject;
+	int length;
+	
+	public IntersectionTypeBinding18(ReferenceBinding[] intersectingTypes, LookupEnvironment environment) {
+		this.intersectingTypes = intersectingTypes;
+		this.length = intersectingTypes.length;
+		if (!intersectingTypes[0].isClass()) {
+			this.javaLangObject = environment.getResolvedType(TypeConstants.JAVA_LANG_OBJECT, null);
+			this.modifiers |= ClassFileConstants.AccInterface;
+		}
+	}
+	
+	private IntersectionTypeBinding18(IntersectionTypeBinding18 prototype) {
+		this.intersectingTypes = prototype.intersectingTypes;
+		this.length = prototype.length;
+		if (!this.intersectingTypes[0].isClass()) {
+			this.javaLangObject = prototype.javaLangObject;
+			this.modifiers |= ClassFileConstants.AccInterface;
+		}
+	}
+	
+	@Override
+	public TypeBinding clone(TypeBinding enclosingType) {
+		return new IntersectionTypeBinding18(this);
+	}
+	
+	public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
+		int index = replaceWildcards ? 0 : 1;
+		if (this.singleAbstractMethod != null) {
+			if (this.singleAbstractMethod[index] != null)
+			return this.singleAbstractMethod[index];
+		} else {
+			this.singleAbstractMethod = new MethodBinding[2];
+		}
+		MethodBinding sam = samProblemBinding;  // guilty unless proven innocent !
+		for (int i = 0; i < this.length; i++) {
+			MethodBinding method = this.intersectingTypes[i].getSingleAbstractMethod(scope, replaceWildcards);
+			if (method != null) {
+				if (method.isValidBinding()) {
+					if (sam.isValidBinding())
+						return this.singleAbstractMethod[index] = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.IntersectionHasMultipleFunctionalInterfaces);
+					else
+						sam = method;
+				}
+			}
+		}
+		return this.singleAbstractMethod[index] = sam; // I don't see a value in building the notional interface described in 9.8 - it appears just pedantic/normative - perhaps it plays a role in wildcard parameterized types ?
+	}
+
+	public boolean hasTypeBit(int bit) { // Stephan ??
+		for (int i = 0; i < this.length; i++) {		
+			if (this.intersectingTypes[i].hasTypeBit(bit))
+				return true;
+		}
+		return false;
+	}
+
+	public boolean canBeInstantiated() {
+		return false;
+	}
+	
+	public boolean canBeSeenBy(PackageBinding invocationPackage) {
+		for (int i = 0; i < this.length; i++) {
+			if (!this.intersectingTypes[i].canBeSeenBy(invocationPackage))
+				return false;
+		}
+		return true;
+	}
+	
+	public boolean canBeSeenBy(Scope scope) {
+		for (int i = 0; i < this.length; i++) {
+			if (!this.intersectingTypes[i].canBeSeenBy(scope))
+				return false;
+		}
+		return true;
+	}
+	
+	public boolean canBeSeenBy(ReferenceBinding receiverType, ReferenceBinding invocationType) {
+		for (int i = 0; i < this.length; i++) {
+			if (!this.intersectingTypes[i].canBeSeenBy(receiverType, invocationType))
+				return false;
+		}
+		return true;
+	}
+	
+	
+	public char[] constantPoolName() {
+		return this.intersectingTypes[0].constantPoolName();
+	}
+
+	public PackageBinding getPackage() {
+		throw new UnsupportedOperationException(); // cannot be referred to
+	}
+	
+	public ReferenceBinding[] getIntersectingTypes() {
+		return this.intersectingTypes;
+	}
+
+	public ReferenceBinding superclass() {
+		return this.intersectingTypes[0].isClass() ? this.intersectingTypes[0] : this.javaLangObject; 
+	}
+	
+	public ReferenceBinding [] superInterfaces() {
+		if (this.intersectingTypes[0].isClass()) {
+			ReferenceBinding [] superInterfaces = new ReferenceBinding[this.length - 1];
+			System.arraycopy(this.intersectingTypes, 1, superInterfaces, 0, this.length - 1);
+			return superInterfaces;
+		}
+		return this.intersectingTypes;
+	}
+	
+	@Override
+	public boolean isBoxedPrimitiveType() {
+		return this.intersectingTypes[0].isBoxedPrimitiveType();
+	}
+	
+	/* Answer true if the receiver type can be assigned to the argument type (right)
+	 */
+	public boolean isCompatibleWith(TypeBinding right, Scope scope) {
+
+		// easy way out?
+		if (TypeBinding.equalsEquals(this, right))
+			return true;
+
+		// need to compare two intersection types?
+		int rightKind = right.kind();
+		TypeBinding[] rightIntersectingTypes = null;
+		if (rightKind == INTERSECTION_TYPE && right.boundKind() == Wildcard.EXTENDS) {
+			TypeBinding allRightBounds = ((WildcardBinding) right).allBounds();
+			if (allRightBounds instanceof IntersectionTypeBinding18)
+				rightIntersectingTypes = ((IntersectionTypeBinding18) allRightBounds).intersectingTypes;
+		} else if (rightKind == INTERSECTION_TYPE18) {
+			rightIntersectingTypes = ((IntersectionTypeBinding18) right).intersectingTypes;
+		}
+		if (rightIntersectingTypes != null) {
+			int numRequired = rightIntersectingTypes.length;
+			TypeBinding[] required = new TypeBinding[numRequired];
+			System.arraycopy(rightIntersectingTypes, 0, required, 0, numRequired);
+			for (int i = 0; i < this.length; i++) {
+				TypeBinding provided = this.intersectingTypes[i];
+				for (int j = 0; j < required.length; j++) {
+					if (required[j] == null) continue;
+					if (provided.isCompatibleWith(required[j], scope)) {
+						required[j] = null;
+						if (--numRequired == 0)
+							return true;
+						break;
+					}
+				}
+			}
+			return false;
+		}
+
+		// normal case:
+		for (int i = 0; i < this.length; i++) {		
+			if (this.intersectingTypes[i].isCompatibleWith(right, scope))
+				return true;
+		}
+		return false;
+	}
+	
+	@Override
+	public boolean isSubtypeOf(TypeBinding other) {
+		if (TypeBinding.equalsEquals(this, other))
+			return true;
+		for (int i = 0; i < this.intersectingTypes.length; i++) {
+			if (this.intersectingTypes[i].isSubtypeOf(other))
+				return true;
+		}
+		return false;
+	}
+
+	public char[] qualifiedSourceName() {
+		StringBuffer qualifiedSourceName = new StringBuffer(16);
+		for (int i = 0; i < this.length; i++) {		
+				qualifiedSourceName.append(this.intersectingTypes[i].qualifiedSourceName());
+				if (i != this.length - 1)
+					qualifiedSourceName.append(" & "); //$NON-NLS-1$
+		}
+		return qualifiedSourceName.toString().toCharArray();
+	}
+
+	public char[] sourceName() {
+		StringBuffer srcName = new StringBuffer(16);
+		for (int i = 0; i < this.length; i++) {		
+				srcName.append(this.intersectingTypes[i].sourceName());
+				if (i != this.length - 1)
+					srcName.append(" & "); //$NON-NLS-1$
+		}
+		return srcName.toString().toCharArray();
+	}
+
+	public char[] readableName() {
+		StringBuffer readableName = new StringBuffer(16);
+		for (int i = 0; i < this.length; i++) {		
+				readableName.append(this.intersectingTypes[i].readableName());
+				if (i != this.length - 1)
+					readableName.append(" & "); //$NON-NLS-1$
+		}
+		return readableName.toString().toCharArray();
+	}
+	public char[] shortReadableName() {
+		StringBuffer shortReadableName = new StringBuffer(16);
+		for (int i = 0; i < this.length; i++) {		
+				shortReadableName.append(this.intersectingTypes[i].shortReadableName());
+				if (i != this.length - 1)
+					shortReadableName.append(" & "); //$NON-NLS-1$
+		}
+		return shortReadableName.toString().toCharArray();
+	}
+	public boolean isIntersectionType18() {
+		return true;
+	}
+	public int kind() {
+		return Binding.INTERSECTION_TYPE18;
+	}
+	public String debugName() {
+		StringBuffer debugName = new StringBuffer(16);
+		for (int i = 0; i < this.length; i++) {		
+				debugName.append(this.intersectingTypes[i].debugName());
+				if (i != this.length - 1)
+					debugName.append(" & "); //$NON-NLS-1$
+		}
+		return debugName.toString();
+	}
+	public String toString() {
+	    return debugName();
+	}
+
+	public TypeBinding getSAMType(Scope scope) {
+		TypeBinding samType = null;
+		for (int i = 0, max = this.intersectingTypes.length; i < max; i++) {
+			TypeBinding typeBinding = this.intersectingTypes[i];
+			MethodBinding methodBinding = typeBinding.getSingleAbstractMethod(scope, true);
+			// Why doesn't getSingleAbstractMethod do as the javadoc says, and return null
+			// when it is not a SAM type
+			if (methodBinding instanceof ProblemMethodBinding && ((ProblemMethodBinding) methodBinding).problemId()==ProblemReasons.NoSuchSingleAbstractMethod) {
+				continue;
+			}
+			if (samType != null) {
+				return null; // There is more than one (!), so we don't know which
+			}
+			samType = typeBinding;
+		}
+		return samType;
+	}
+
+	@Override
+	void collectInferenceVariables(Set<InferenceVariable> variables) {
+		for (int i = 0; i < this.intersectingTypes.length; i++)
+			this.intersectingTypes[i].collectInferenceVariables(variables);
+	}
+	
+	@Override
+	public boolean mentionsAny(TypeBinding[] parameters, int idx) {
+		if (super.mentionsAny(parameters, idx))
+			return true;
+		for (int i = 0; i < this.intersectingTypes.length; i++) {
+			if (this.intersectingTypes[i].mentionsAny(parameters, -1))
+				return true;
+		}
+		return false;
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 4928704..087adab 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -437,7 +437,7 @@ public TypeBinding computeBoxingType(TypeBinding type) {
 			break;
 		case Binding.POLY_TYPE:
 			return ((PolyTypeBinding) type).computeBoxingType();
-		case Binding.INTERSECTION_CAST_TYPE:
+		case Binding.INTERSECTION_TYPE18:
 			return computeBoxingType(type.getIntersectingTypes()[0]);
 	}
 	return type;
@@ -674,8 +674,8 @@ public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimension
 	return this.typeSystem.getArrayType(leafComponentType, dimensionCount, annotations);
 }
 
-public TypeBinding createIntersectionCastType(ReferenceBinding[] intersectingTypes) {
-	return this.typeSystem.getIntersectionCastType(intersectingTypes);
+public TypeBinding createIntersectionType18(ReferenceBinding[] intersectingTypes) {
+	return this.typeSystem.getIntersectionType18(intersectingTypes);
 }	
 
 public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index ef8bb58..489ad06 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -1486,7 +1486,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 							try {
 								ReferenceBinding[] refs = new ReferenceBinding[glb.length];
 								System.arraycopy(glb, 0, refs, 0, glb.length); // TODO: if an array type plus more types get here, we get ArrayStoreException!
-								types[i] = this.environment.createIntersectionCastType(refs);
+								types[i] = this.environment.createIntersectionType18(refs);
 							} catch (ArrayStoreException ase) {
 								scope.problemReporter().genericInferenceError("Cannot compute glb of "+Arrays.toString(glb), null); //$NON-NLS-1$
 								return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index e0c1902..2d0c8ea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -442,9 +442,9 @@ public TypeBinding findSuperTypeOriginatingFrom(TypeBinding otherType) {
 				}
 			}
 			break;
-		case Binding.INTERSECTION_CAST_TYPE:
-			IntersectionCastTypeBinding ictb = (IntersectionCastTypeBinding) this;
-			ReferenceBinding[] intersectingTypes = ictb.getIntersectingTypes();
+		case Binding.INTERSECTION_TYPE18:
+			IntersectionTypeBinding18 itb18 = (IntersectionTypeBinding18) this;
+			ReferenceBinding[] intersectingTypes = itb18.getIntersectingTypes();
 			for (int i = 0, length = intersectingTypes.length; i < length; i++) {
 				TypeBinding superType = intersectingTypes[i].findSuperTypeOriginatingFrom(otherType);
 				if (superType != null)
@@ -740,7 +740,7 @@ public boolean acceptsNonNullDefault() {
 	return false;
 }
 
-public boolean isIntersectionCastType() {
+public boolean isIntersectionType18() {
 	return false;
 }
 
@@ -1262,8 +1262,8 @@ public boolean isTypeArgumentContainedBy(TypeBinding otherType) {
 			TypeBinding otherBound = otherWildcard.bound;
 			switch (otherWildcard.boundKind) {
 				case Wildcard.EXTENDS:
-					if (otherBound instanceof IntersectionCastTypeBinding) {
-						TypeBinding [] intersectingTypes = ((IntersectionCastTypeBinding) otherBound).intersectingTypes;
+					if (otherBound instanceof IntersectionTypeBinding18) {
+						TypeBinding [] intersectingTypes = ((IntersectionTypeBinding18) otherBound).intersectingTypes;
 						for (int i = 0, length = intersectingTypes.length; i < length; i++)
 							if (TypeBinding.equalsEquals(intersectingTypes[i], this))
 								return true;
@@ -1280,8 +1280,8 @@ public boolean isTypeArgumentContainedBy(TypeBinding otherType) {
 					return upperBound.isCompatibleWith(otherBound);
 
 				case Wildcard.SUPER:
-					if (otherBound instanceof IntersectionCastTypeBinding) {
-						TypeBinding [] intersectingTypes = ((IntersectionCastTypeBinding) otherBound).intersectingTypes;
+					if (otherBound instanceof IntersectionTypeBinding18) {
+						TypeBinding [] intersectingTypes = ((IntersectionTypeBinding18) otherBound).intersectingTypes;
 						for (int i = 0, length = intersectingTypes.length; i < length; i++)
 							if (TypeBinding.equalsEquals(intersectingTypes[i], this))
 								return true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
index bc94079..a77994e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
@@ -42,7 +42,7 @@ public class TypeBindingVisitor {
 		return true;  // continue traversal.
 	}
 	
-	public boolean visit(IntersectionCastTypeBinding intersectionCastTypeBinding) {
+	public boolean visit(IntersectionTypeBinding18 intersectionTypeBinding18) {
 		return true;  // continue traversal.
 	}
 	
@@ -128,10 +128,10 @@ public class TypeBindingVisitor {
 				}
 				break;
 			
-			case Binding.INTERSECTION_CAST_TYPE:
-				IntersectionCastTypeBinding intersectionCastTypeBinding = (IntersectionCastTypeBinding) type;
-				if (visitor.visit(intersectionCastTypeBinding))
-					visit(visitor, intersectionCastTypeBinding.intersectingTypes);
+			case Binding.INTERSECTION_TYPE18:
+				IntersectionTypeBinding18 intersectionTypeBinding18 = (IntersectionTypeBinding18) type;
+				if (visitor.visit(intersectionTypeBinding18))
+					visit(visitor, intersectionTypeBinding18.intersectingTypes);
 				break;
 				
 			case Binding.POLY_TYPE:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
index e9bd89d..0bf8ad1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
@@ -492,7 +492,7 @@ public class TypeSystem {
 		}
 	}
 
-	public final TypeBinding getIntersectionCastType(ReferenceBinding[] intersectingTypes) {
+	public final TypeBinding getIntersectionType18(ReferenceBinding[] intersectingTypes) {
 		int intersectingTypesLength = intersectingTypes == null ? 0 : intersectingTypes.length;
 		if (intersectingTypesLength == 0)
 			return null;
@@ -507,7 +507,7 @@ public class TypeSystem {
 			TypeBinding derivedType = derivedTypes[i];
 			if (derivedType == null) 
 				break;
-			if (!derivedType.isIntersectionCastType())
+			if (!derivedType.isIntersectionType18())
 				continue;
 			ReferenceBinding [] priorIntersectingTypes = derivedType.getIntersectingTypes();
 			if (priorIntersectingTypes.length != intersectingTypesLength)
@@ -518,7 +518,7 @@ public class TypeSystem {
 			}	
 			return derivedType;
 		}
-		return cacheDerivedType(keyType, new IntersectionCastTypeBinding(intersectingTypes, this.environment));
+		return cacheDerivedType(keyType, new IntersectionTypeBinding18(intersectingTypes, this.environment));
 	}
 	
 	/**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index 6031f63..3ff895c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -87,7 +87,7 @@ public class WildcardBinding extends ReferenceBinding {
 		} catch (ArrayStoreException ase) {
 			return this.bound;
 		}
-		return this.environment.createIntersectionCastType(allBounds);
+		return this.environment.createIntersectionType18(allBounds);
 	}
 
 	public ReferenceBinding actualType() {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index c463371..3e11909 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -24,7 +24,7 @@ import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
-import org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
@@ -685,9 +685,9 @@ class TypeBinding implements ITypeBinding {
 				buffer.append(brackets);
 				return String.valueOf(buffer);
 
-			case Binding.INTERSECTION_CAST_TYPE :
-				// just use the first bound for now (same kludge as in IntersectionCastTypeBinding#constantPoolName())
-				return new String(((IntersectionCastTypeBinding) this.binding).getIntersectingTypes()[0].sourceName());
+			case Binding.INTERSECTION_TYPE18 :
+				// just use the first bound for now (same kludge as in IntersectionTypeBinding18#constantPoolName())
+				return new String(((IntersectionTypeBinding18) this.binding).getIntersectingTypes()[0].sourceName());
 
 			default :
 				if (isPrimitive() || isNullType()) {
@@ -711,7 +711,7 @@ class TypeBinding implements ITypeBinding {
 			case Binding.TYPE_PARAMETER : // includes capture scenario
 			case Binding.WILDCARD_TYPE :
 			case Binding.INTERSECTION_TYPE:
-			case Binding.INTERSECTION_CAST_TYPE:
+			case Binding.INTERSECTION_TYPE18:
 				return null;
 		}
 		ReferenceBinding referenceBinding = (ReferenceBinding) this.binding;
@@ -808,7 +808,7 @@ class TypeBinding implements ITypeBinding {
 				}
 				return String.valueOf(buffer);
 			default :
-				if (isAnonymous() || this.binding.isLocalType() || this.binding.isIntersectionCastType()) {
+				if (isAnonymous() || this.binding.isLocalType() || this.binding.isIntersectionType18()) {
 					return NO_NAME;
 				}
 				if (isPrimitive() || isNullType()) {
