commit e9d42bfbf494b3bd89965c526aaae07d7189c12c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Feb 25 23:53:48 2014 +0100

    Bug 416190 - [1.8][null] detect incompatible overrides due to null type
    annotations
    - fix for NullTypeAnnotationTest#testBug416174()

38	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
86	10	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
11	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
19	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
12	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 0b900ec..b962cbe 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1288,6 +1288,7 @@ public void test_parameter_specification_inheritance_014() {
 			"}\n",
 		},
 		customOptions,
+		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
 		"----------\n" +
 		"1. ERROR in p1\\Y.java (at line 2)\n" +
 		"	public class Y extends X implements IY {\n" +
@@ -1308,7 +1309,29 @@ public void test_parameter_specification_inheritance_014() {
 		"	public class Y extends X implements IY {\n" +
 		"	             ^\n" +
 		"The method getString3(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
-		"----------\n");
+		"----------\n"
+		: // at 1.8 we show null type annotations in the message:
+		"----------\n" + 
+		"1. ERROR in p1\\Y.java (at line 2)\n" + 
+		"	public class Y extends X implements IY {\n" + 
+		"	             ^\n" + 
+		"The method @Nullable String getString1(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" + 
+		"----------\n" + 
+		"2. ERROR in p1\\Y.java (at line 2)\n" + 
+		"	public class Y extends X implements IY {\n" + 
+		"	             ^\n" + 
+		"The method String getString2(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" + 
+		"----------\n" + 
+		"3. ERROR in p1\\Y.java (at line 2)\n" + 
+		"	public class Y extends X implements IY {\n" + 
+		"	             ^\n" + 
+		"The method getString5(@NonNull String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" + 
+		"----------\n" + 
+		"4. ERROR in p1\\Y.java (at line 2)\n" + 
+		"	public class Y extends X implements IY {\n" + 
+		"	             ^\n" + 
+		"The method getString3(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" + 
+		"----------\n"));
 }
 // a method relaxes the parameter null specification from @NonNull to un-annotated
 // see https://bugs.eclipse.org/381443
@@ -5859,6 +5882,7 @@ public void testBug388281_06() {
 																  // whereas I2A cancels that same default
 			"}\n"
 		},
+		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
 		"----------\n" + 
 		"1. ERROR in ctest\\C.java (at line 2)\n" + 
 		"	public class C extends c.C2 implements i2.I2A {\n" + 
@@ -5869,7 +5893,19 @@ public void testBug388281_06() {
 		"	public class C extends c.C2 implements i2.I2A {\n" + 
 		"	             ^\n" + 
 		"The method m1(Object) from C2 cannot implement the corresponding method from I2A due to incompatible nullness constraints\n" + 
-		"----------\n",
+		"----------\n"
+		: // at 1.8 we show null type annotations:
+		"----------\n" + 
+		"1. ERROR in ctest\\C.java (at line 2)\n" + 
+		"	public class C extends c.C2 implements i2.I2A {\n" + 
+		"	             ^\n" + 
+		"The method m2(@NonNull Object) from C2 cannot implement the corresponding method from I2A due to incompatible nullness constraints\n" + 
+		"----------\n" + 
+		"2. ERROR in ctest\\C.java (at line 2)\n" + 
+		"	public class C extends c.C2 implements i2.I2A {\n" + 
+		"	             ^\n" + 
+		"The method m1(@NonNull Object) from C2 cannot implement the corresponding method from I2A due to incompatible nullness constraints\n" + 
+		"----------\n"),
 		libs,		
 		true /* shouldFlush*/,
 		options);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 8397360..f2b497e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -2853,31 +2853,107 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
     		"----------\n");
     }
 	
+	// incompatible null constraints on parameters 
 	public void testBug416174() {
-		// FIXME(stephan): should report null spec violation
-		runConformTestWithLibs(
+		Map options = getCompilerOptions();
+		options.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.IGNORE);
+		runNegativeTestWithLibs(
 			new String[] {
 				"X.java",
 				"import java.util.List;\n" + 
 				"\n" + 
-				"import org.eclipse.jdt.annotation.NonNull;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
 				"\n" + 
 				"public class X {\n" + 
-				"	void  foo(List<X> lx) {\n" + 
-				"	}\n" + 
+				"	void  foo1(List<X> lx) {}\n" +
+				"	void  foo2(List<@NonNull X> lx) {}\n" +
+				"	void  foo3(List<@Nullable X> lx) {}\n" +
+				"	void  foo4(@NonNull List<@Nullable X> lx) {}\n" +
 				"}\n" + 
 				"\n" + 
 				"class Z extends X {\n" + 
-				"	void  foo(List<@NonNull X> xy) {\n" + 
+				"	@Override void foo1(List<@NonNull X> xy) {}\n" + 
+				"	@Override void foo2(List<X> lx) {}\n" +
+				"	@Override void foo3(List<X> lx) {}\n" +
+				"	@Override void foo4(List<@Nullable X> lx) {}\n" + // omitting annotation at toplevel can be tolerated (via option)
+				"}\n"
+			},
+			options,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 12)\n" + 
+			"	class Z extends X {\n" + 
+			"	      ^\n" + 
+			"The method foo1(List<@NonNull X>) from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 12)\n" + 
+			"	class Z extends X {\n" + 
+			"	      ^\n" + 
+			"The method foo2(List<X>) from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 12)\n" + 
+			"	class Z extends X {\n" + 
+			"	      ^\n" + 
+			"The method foo3(List<X>) from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
+			"----------\n");
+	}
+
+	// incompatibility at return type, which should be shown here in the error message
+	public void testBug416174b() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import java.util.*;\n" + 
+				"\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"public abstract class X {\n" + 
+				"	List<X> foo1() {\n" + 
+				"		return null;\n" + 
+				"	}\n" + 
+				"	List<@Nullable X> foo2() {\n" + 
+				"		return null;\n" + 
+				"	}\n" + 
+				"	abstract @NonNull List<@NonNull X> foo3();\n" + 
+				"	List<@Nullable X> foo4() {\n" + 
+				"		return null;\n" + 
+				"	}\n" + 
+				"}\n" + 
+				"\n" + 
+				"abstract class Z extends X {\n" + 
+				"	@Override\n" +
+				"	List<@NonNull X> foo1() {\n" +
+				"		return null;\n" + 
+				"	}\n" + 
+				"	@Override\n" +
+				"	List<@NonNull X> foo2() {\n" +
+				"		return null;\n" + 
+				"	}\n" + 
+				"	@Override\n" +
+				"	@NonNull List<X> foo3() {\n" + 
+				"		return new ArrayList<>();\n" + 
+				"	}\n" + 
+				"	@Override\n" +
+				"	@NonNull List<@Nullable X> foo4() {\n" + // OK
+				"		return new ArrayList<>();\n" + 
 				"	}\n" + 
 				"}\n"
 			},
 			getCompilerOptions(),
 			"----------\n" + 
-			"1. WARNING in X.java (at line 11)\n" + 
-			"	void  foo(List<@NonNull X> xy) {\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The method foo(List<X>) of type Z should be tagged with @Override since it actually overrides a superclass method\n" + 
+			"1. ERROR in X.java (at line 18)\n" + 
+			"	abstract class Z extends X {\n" + 
+			"	               ^\n" + 
+			"The method List<@NonNull X> foo1() from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 18)\n" + 
+			"	abstract class Z extends X {\n" + 
+			"	               ^\n" + 
+			"The method List<@NonNull X> foo2() from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 18)\n" + 
+			"	abstract class Z extends X {\n" + 
+			"	               ^\n" + 
+			"The method @NonNull List<X> foo3() from Z cannot implement the corresponding method from X due to incompatible nullness constraints\n" + 
 			"----------\n");
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index 87ac635..3d884b2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -110,6 +110,10 @@ public class NullAnnotationMatching {
 	 * @return a status object representing the severity of mismatching plus optionally a supertype hint
 	 */
 	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
+		return analyse(requiredType, providedType, nullStatus, false);
+	}
+	// additional parameter strict: if true we do not tolerate incompatibly missing annotations on type parameters (for overriding analysis)
+	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, int nullStatus, boolean strict) {
 		int severity = 0;
 		TypeBinding superTypeHint = null;
 		if (requiredType instanceof ArrayBinding) {
@@ -126,7 +130,7 @@ public class NullAnnotationMatching {
 							long providedBits = validNullTagBits(providedDimsTagBits[i]);
 							if (i > 0)
 								nullStatus = -1; // don't use beyond the outermost dimension
-							severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
+							severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus, strict));
 							if (severity == 2)
 								return NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;
 						}
@@ -142,7 +146,7 @@ public class NullAnnotationMatching {
 					|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
 			{
 				long providedBits = validNullTagBits(providedType.tagBits);
-				severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
+				severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, strict && nullStatus == -1);
 			}
 			if (severity < 2) {
 				TypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);
@@ -153,7 +157,7 @@ public class NullAnnotationMatching {
 					TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedSuper).arguments;
 					if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
 						for (int i = 0; i < requiredArguments.length; i++) {
-							NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], -1);
+							NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], -1, strict);
 							severity = Math.max(severity, status.severity);
 							if (severity == 2)
 								return new NullAnnotationMatching(severity, superTypeHint);
@@ -162,7 +166,7 @@ public class NullAnnotationMatching {
 				} else 	if (requiredType instanceof WildcardBinding) {
 					WildcardBinding wildcardBinding = (WildcardBinding) requiredType;
 					if (wildcardBinding.bound != null) {
-						NullAnnotationMatching status = analyse(wildcardBinding.bound, providedType, nullStatus);
+						NullAnnotationMatching status = analyse(wildcardBinding.bound, providedType, nullStatus, strict);
 						severity = Math.max(severity, status.severity);
 					}
 					// TODO(stephan): what about otherBounds? Do we accept "? extends @NonNull I1 & @Nullable I2" in the first place??
@@ -170,7 +174,7 @@ public class NullAnnotationMatching {
 				TypeBinding requiredEnclosing = requiredType.enclosingType();
 				TypeBinding providedEnclosing = providedType.enclosingType();
 				if (requiredEnclosing != null && providedEnclosing != null) {
-					NullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, -1);
+					NullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, -1, strict);
 					severity = Math.max(severity, status.severity);
 				}
 			}
@@ -206,8 +210,8 @@ public class NullAnnotationMatching {
 		return one;
 	}
 
-	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
-		if (requiredBits != 0 && requiredBits != providedBits) {
+	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, boolean strict) {
+		if ((requiredBits != 0 || strict) && requiredBits != providedBits) {
 			if (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {
 				return 0; // OK by flow analysis
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index f7922f2..5215eab 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012, 2013 GK Software AG, IBM Corporation and others.
+ * Copyright (c) 2012, 2014 GK Software AG, IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -274,8 +274,15 @@ public class ImplicitNullAnnotationVerifier {
 					if (srcMethod != null) {
 						scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
 																	this.environment.getNonNullAnnotationName());
+						break returnType;
 					} else {
-						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod, useTypeAnnotations);
+						return;
+					}
+				}
+				if (useTypeAnnotations) {
+					if (NullAnnotationMatching.analyse(inheritedMethod.returnType, currentMethod.returnType, 0, true).isAnyMismatch()) {
+						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod, useTypeAnnotations);
 						return;
 					}
 				}
@@ -355,8 +362,9 @@ public class ImplicitNullAnnotationVerifier {
 								inheritedMethod.declaringClass,
 								(inheritedNonNullNess == null) ? null : this.environment.getNullableAnnotationName());
 					} else {
-						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod, false);
 					}
+					continue;
 				} else if (currentNonNullNess == null) 
 				{
 					// unannotated strictly conflicts only with inherited @Nullable
@@ -367,14 +375,21 @@ public class ImplicitNullAnnotationVerifier {
 									inheritedMethod.declaringClass,
 									annotationName);
 						} else {
-							scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+							scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod, false);
 						}
+						continue;
 					} else if (inheritedNonNullNess == Boolean.TRUE) {
 						// not strictly a conflict, but a configurable warning is given anyway:
 						scope.problemReporter().parameterLackingNonnullAnnotation(
 								currentArgument,
 								inheritedMethod.declaringClass,
 								annotationName);
+						continue;
+					}
+				} 
+				if (useTypeAnnotations) {
+					if (NullAnnotationMatching.analyse(currentMethod.parameters[i], inheritedMethod.parameters[i], 0, true).isAnyMismatch()) {
+						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod, false);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 937a73e..d0a3a4c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -26,6 +26,7 @@
  *								Bug 416183 - [1.8][compiler][null] Overload resolution fails with null annotations
  *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *								Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 4402fe9..661855c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -49,6 +49,7 @@
  *								Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
  *								Bug 428294 - [1.8][compiler] Type mismatch: cannot convert from List<Object> to Collection<Object[]>
  *								Bug 428366 - [1.8] [compiler] The method valueAt(ObservableList<Object>, int) is ambiguous for the type Bindings
+ *								Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -9339,19 +9340,27 @@ public void expressionPotentialNullReference(ASTNode location) {
 		location.sourceEnd);
 }
 
-public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod, boolean showReturn) {
 	int sourceStart = 0, sourceEnd = 0;
 	if (this.referenceContext instanceof TypeDeclaration) {
 		sourceStart = ((TypeDeclaration) this.referenceContext).sourceStart;
 		sourceEnd =   ((TypeDeclaration) this.referenceContext).sourceEnd;
 	}
 	String[] problemArguments = {
-			new String(currentMethod.readableName()),
+			showReturn 
+				? new String(currentMethod.returnType.nullAnnotatedReadableName(this.options, false))+' '
+				: "", //$NON-NLS-1$
+			new String(currentMethod.selector),
+			typesAsString(currentMethod, false, true),
 			new String(currentMethod.declaringClass.readableName()),
 			new String(inheritedMethod.declaringClass.readableName())
 		};
 	String[] messageArguments = {
-			new String(currentMethod.shortReadableName()),
+			showReturn 
+				? new String(currentMethod.returnType.nullAnnotatedReadableName(this.options, true))+' '
+				: "", //$NON-NLS-1$
+			new String(currentMethod.selector),
+			typesAsString(currentMethod, true, true),
 			new String(currentMethod.declaringClass.shortReadableName()),
 			new String(inheritedMethod.declaringClass.shortReadableName())
 		};
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 92a4c2c..7879f34 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -39,6 +39,7 @@
 #							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
 #							Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
 #							Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
+#							Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -777,7 +778,7 @@
 918 = Missing nullable annotation: inherited method from {0} specifies this parameter as @{1}
 919 = Potential null pointer access: The method {0} may return null
 920 = Redundant null check: The method {0} cannot return null
-921 = The method {0} from {1} cannot implement the corresponding method from {2} due to incompatible nullness constraints
+921 = The method {0}{1}({2}) from {3} cannot implement the corresponding method from {4} due to incompatible nullness constraints
 922 = The nullness annotation is redundant with a default that applies to this location
 923 = The nullness annotation @{0} is not applicable for the primitive type {1}
 924 = Potential null pointer access: The field {0} is specified as @{1}
commit c14c8093a10c10363866e505a62237c9c62b679e
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Feb 27 12:20:11 2014 +0100

    Bug 416190 - [1.8][null] detect incompatible overrides due to null type
    annotations
    - prevent duplicate null annotations

20	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index d0a3a4c..d3c68a0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -964,6 +964,26 @@ public TypeBinding createAnnotatedType(TypeBinding type, AnnotationBinding[] new
 		System.arraycopy(newbies, 0, newbies = new AnnotationBinding[newLength + oldLength], 0, newLength);
 		System.arraycopy(oldies, 0, newbies, newLength, oldLength);
 	}
+	if (this.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+		// filter duplicate null annotations
+		// (do we want to filter other annotations as well? only if not repeatable?)
+		long tagBitsSeen = 0;
+		AnnotationBinding[] filtered = new AnnotationBinding[newbies.length];
+		int count = 0;
+		for (int i = 0; i < newbies.length; i++) {
+			long tagBits = 0;
+			switch (newbies[i].type.id) {
+				case TypeIds.T_ConfiguredAnnotationNonNull  : tagBits = TagBits.AnnotationNonNull; break;
+				case TypeIds.T_ConfiguredAnnotationNullable : tagBits = TagBits.AnnotationNullable; break;
+			}
+			if ((tagBitsSeen & tagBits) == 0) {
+				tagBitsSeen |= tagBits;
+				filtered[count++] = newbies[i];
+			}
+		}
+		if (count < newbies.length)
+			System.arraycopy(filtered, 0, newbies = new AnnotationBinding[count], 0, count);
+	}
 	return this.typeSystem.getAnnotatedType(type, new AnnotationBinding [][] { newbies });
 }
 
commit bc58ceae1b3691095e4db8bfcb9f2192eeaf077d
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Feb 27 12:27:56 2014 +0100

    Bug 416190 - [1.8][null] detect incompatible overrides due to null type
    annotations
    - refactoring in preparation for comment 3

21	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
9	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index dfa9258..d1b1cdc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -244,6 +244,12 @@ class BoundSet {
 					boundTypes[i] = environment.createAnnotatedType(boundTypes[i], annot);
 			}
 		}
+		public void setInstantiation(TypeBinding type, LookupEnvironment environment) {
+			if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				// TODO check for existing instantiation and compare null annotations
+			}
+			this.instantiation = type;
+		}
 	}
 	// main storage of type bounds:
 	HashMap<InferenceVariable, ThreeSets> boundsPerVariable = new HashMap<InferenceVariable, ThreeSets>();
@@ -270,9 +276,9 @@ class BoundSet {
 			TypeBound[] someBounds = typeParameter.getTypeBounds(variable, context);
 			boolean hasProperBound = false;
 			if (someBounds.length > 0)
-				hasProperBound = addBounds(someBounds);
+				hasProperBound = addBounds(someBounds, context.environment);
 			if (!hasProperBound)
-				addBound(new TypeBound(variable, context.object, ReductionResult.SUBTYPE));
+				addBound(new TypeBound(variable, context.object, ReductionResult.SUBTYPE), context.environment);
 		}
 	}
 
@@ -307,7 +313,7 @@ class BoundSet {
 		return copy;
 	}
 
-	public void addBound(TypeBound bound) {
+	public void addBound(TypeBound bound, LookupEnvironment environment) {
 		ThreeSets three = this.boundsPerVariable.get(bound.left);
 		if (three == null)
 			this.boundsPerVariable.put(bound.left, (three = new ThreeSets()));
@@ -315,7 +321,7 @@ class BoundSet {
 		// check if this makes the inference variable instantiated:
 		TypeBinding typeBinding = bound.right;
 		if (bound.relation == ReductionResult.SAME && typeBinding.isProperType(true))
-			three.instantiation = typeBinding;
+			three.setInstantiation(typeBinding, environment);
 		if (bound.right instanceof InferenceVariable) {
 			// for a dependency between two IVs make a note about the inverse bound.
 			// this should be needed to determine IV dependencies independent of direction.
@@ -330,10 +336,10 @@ class BoundSet {
 		}
 	}
 
-	private boolean addBounds(TypeBound[] newBounds) {
+	private boolean addBounds(TypeBound[] newBounds, LookupEnvironment environment) {
 		boolean hasProperBound = false;
 		for (int i = 0; i < newBounds.length; i++) {
-			addBound(newBounds[i]);
+			addBound(newBounds[i], environment);
 			hasProperBound |= newBounds[i].isBound();
 		}
 		return hasProperBound;
@@ -346,10 +352,13 @@ class BoundSet {
 		return false;
 	}
 
-	public TypeBinding getInstantiation(InferenceVariable inferenceVariable) {
+	public TypeBinding getInstantiation(InferenceVariable inferenceVariable, LookupEnvironment environment) {
 		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
-		if (three != null)
-			return three.instantiation;
+		if (three != null) {
+			TypeBinding instantiation = three.instantiation;
+			// TODO consider null annotations if enabled
+			return instantiation;
+		}
 		return null;
 	}
 
@@ -464,7 +473,7 @@ class BoundSet {
 					// A set of bounds on α1, ..., αn, constructed from the declared bounds of P1, ..., Pn as described in 18.1.3, is immediately implied.
 					TypeVariableBinding pi = parameters[i];
 					InferenceVariable alpha = (InferenceVariable) gAlpha.arguments[i];
-					addBounds(pi.getTypeBounds(alpha, context));
+					addBounds(pi.getTypeBounds(alpha, context), context.environment);
 
 					TypeBinding ai = gA.arguments[i];
 					if (ai instanceof WildcardBinding) {
@@ -529,7 +538,7 @@ class BoundSet {
 							}
 						}
 					} else {
-						addBound(new TypeBound(alpha, ai, ReductionResult.SAME));
+						addBound(new TypeBound(alpha, ai, ReductionResult.SAME), context.environment);
 					}
 				}
 			}
@@ -704,7 +713,7 @@ class BoundSet {
 					if (!reduceOneConstraint(context, resultArray[i]))
 						return false;
 			} else {
-				this.addBound((TypeBound)result);
+				addBound((TypeBound)result, context.environment);
 			}
 		}
 		return true; // no FALSE encountered
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 6264f65..dce7ccf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -399,7 +399,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				}
 				if (toResolve) {
 					BoundSet solution = inferenceContext.solve(); // TODO: minimal resolving for only α
-					TypeBinding u = solution.getInstantiation(alpha).capture(inferenceContext.scope, invocationSite.sourceStart()); // TODO make position unique?
+					TypeBinding u = solution.getInstantiation(alpha, null).capture(inferenceContext.scope, invocationSite.sourceStart()); // TODO make position unique?
 					ConstraintTypeFormula newConstraint = new ConstraintTypeFormula(u, targetType, COMPATIBLE);
 					return inferenceContext.reduceAndIncorporate(newConstraint);
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
index 8a729f5..a39165e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
@@ -69,7 +69,7 @@ abstract class ConstraintFormula extends ReductionResult {
 	public boolean applySubstitution(BoundSet solutionSet, InferenceVariable[] variables) {
 		for (int i=0; i<variables.length; i++) {
 			InferenceVariable variable = variables[i];
-			TypeBinding instantiation = solutionSet.getInstantiation(variables[i]);
+			TypeBinding instantiation = solutionSet.getInstantiation(variables[i], null);
 			if (instantiation == null)
 				return false;
 			this.right = this.right.substituteInferenceVariable(variable, instantiation);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
index e6d18b0..851806a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
@@ -340,7 +340,7 @@ class ConstraintTypeFormula extends ConstraintFormula {
 		super.applySubstitution(solutionSet, variables);
 		for (int i=0; i<variables.length; i++) {
 			InferenceVariable variable = variables[i];
-			TypeBinding instantiation = solutionSet.getInstantiation(variables[i]);
+			TypeBinding instantiation = solutionSet.getInstantiation(variables[i], null);
 			if (instantiation == null)
 				return false;
 			this.left = this.left.substituteInferenceVariable(variable, instantiation);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index c63f862..08cd76f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -649,7 +649,7 @@ public class InferenceContext18 {
 			} else {
 				bound = new TypeBound(alpha[i], a[i], ReductionResult.SAME);
 			}
-			this.currentBounds.addBound(bound);
+			this.currentBounds.addBound(bound, this.environment);
 		}
 		TypeBinding falpha = substitute(functionalInterface);
 		return falpha.getSingleAbstractMethod(this.scope, true).parameters;
@@ -888,7 +888,7 @@ public class InferenceContext18 {
 			for (int j = 0; j < this.inferenceVariables.length; j++) {
 				InferenceVariable variable = this.inferenceVariables[j];
 				if (variable.site == site && TypeBinding.equalsEquals(variable.typeParameter, typeParameters[i])) {
-					substitutions[i] = boundSet.getInstantiation(variable);
+					substitutions[i] = boundSet.getInstantiation(variable, this.environment);
 					break;
 				}
 			}
@@ -934,13 +934,13 @@ public class InferenceContext18 {
 								TypeBinding lub = this.scope.lowerUpperBound(lowerBounds);
 								if (lub == TypeBinding.VOID || lub == null)
 									return null;
-								tmpBoundSet.addBound(new TypeBound(variable, lub, ReductionResult.SAME));
+								tmpBoundSet.addBound(new TypeBound(variable, lub, ReductionResult.SAME), this.environment);
 							} else {
 								TypeBinding[] upperBounds = tmpBoundSet.upperBounds(variable, true/*onlyProper*/);
 								// check exception bounds:
 								if (tmpBoundSet.inThrows.contains(variable) && tmpBoundSet.hasOnlyTrivialExceptionBounds(variable, upperBounds)) {
 									TypeBinding runtimeException = this.scope.getType(TypeConstants.JAVA_LANG_RUNTIMEEXCEPTION, 3);
-									tmpBoundSet.addBound(new TypeBound(variable, runtimeException, ReductionResult.SAME));
+									tmpBoundSet.addBound(new TypeBound(variable, runtimeException, ReductionResult.SAME), this.environment);
 								} else {
 									// try upper bounds:
 									TypeBinding glb = this.object;
@@ -957,7 +957,7 @@ public class InferenceContext18 {
 												glb = new IntersectionCastTypeBinding(glbs, this.environment);
 										}
 									}
-									tmpBoundSet.addBound(new TypeBound(variable, glb, ReductionResult.SAME));
+									tmpBoundSet.addBound(new TypeBound(variable, glb, ReductionResult.SAME), this.environment);
 								}
 							}
 						}
@@ -1019,7 +1019,7 @@ public class InferenceContext18 {
 						captureKeys = toRemove.iterator();
 						while (captureKeys.hasNext())
 							tmpBoundSet.captures.remove(captureKeys.next());
-						tmpBoundSet.addBound(new TypeBound(variable, zsj, ReductionResult.SAME));
+						tmpBoundSet.addBound(new TypeBound(variable, zsj, ReductionResult.SAME), this.environment);
 					}
 					if (tmpBoundSet.incorporate(this)) {
 						if (tmpBoundSet.numUninstantiatedVariables(this.inferenceVariables) == oldNumUninstantiated)
@@ -1500,7 +1500,7 @@ public class InferenceContext18 {
 			}
 			public TypeBinding substitute(TypeVariableBinding typeVariable) {
 				if (typeVariable instanceof InferenceVariable) {
-					return result.getInstantiation((InferenceVariable) typeVariable);
+					return result.getInstantiation((InferenceVariable) typeVariable, InferenceContext18.this.environment);
 				}
 				return typeVariable;
 			}
@@ -1572,7 +1572,7 @@ public class InferenceContext18 {
 			for (int i = 0; i < this.inferenceVariables.length; i++) {
 				buf.append('\t').append(this.inferenceVariables[i].sourceName).append("\t:\t"); //$NON-NLS-1$
 				if (this.currentBounds != null && this.currentBounds.isInstantiated(this.inferenceVariables[i]))
-					buf.append(this.currentBounds.getInstantiation(this.inferenceVariables[i]).readableName());
+					buf.append(this.currentBounds.getInstantiation(this.inferenceVariables[i], this.environment).readableName());
 				else
 					buf.append("NOT INSTANTIATED"); //$NON-NLS-1$
 				buf.append('\n');
@@ -1617,7 +1617,7 @@ public class InferenceContext18 {
 		TypeBinding[] aprime = new TypeBinding[m];
 		for (int i = 0; i < this.inferenceVariables.length; i++) {
 			InferenceVariable alphai = this.inferenceVariables[i];
-			TypeBinding t = this.currentBounds.getInstantiation(alphai);
+			TypeBinding t = this.currentBounds.getInstantiation(alphai, this.environment);
 			if (t != null)
 				aprime[i] = t;
 			else
commit df9c3a401cd78995716c690f400af3a4d95f0187
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Feb 27 12:29:53 2014 +0100

    Bug 416190 - [1.8][null] detect incompatible overrides due to null type
    annotations
    - test & fix for comment 3

31	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
44	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index f2b497e..e5adb2e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -2679,6 +2679,37 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// conflicting annotations from type variable application and type variable substitution
+	public void testNullTypeInference3c() { 
+		runNegativeTestWithLibs(
+			new String[] {
+				"Generics.java",
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"import java.util.*;\n" + 
+				"\n" + 
+				"interface Function<I,O> { }\n" + 
+				"abstract class MyFunc implements Function<@NonNull Object, @Nullable String> { }\n" + 
+				"  \n" + 
+				"public class Generics {\n" + 
+				"  <@NonNull I,@Nullable O> \n" + 
+				"  Collection<O> map1(Collection<I> in, Function<I, O> f) { return null; }\n" +
+				"  <@Nullable I,@NonNull O> \n" + 
+				"  Collection<O> map2(Collection<I> in, Function<I, O> f) { return null; }\n" +
+				"	void test(@NonNull List<Object> inList, MyFunc f) {\n" +
+				"		Collection<@Nullable String> result = map1(inList, f);\n" + 
+				"		map2(inList, f);\n" + 
+				"	}\n" +
+				"}\n"
+			},
+			getCompilerOptions(),
+			"----------\n" + 
+			"1. ERROR in Generics.java (at line 14)\n" + 
+			"	map2(inList, f);\n" + 
+			"	^^^^^^^^^^^^^^^\n" + 
+			"Contradictory null annotations: method was inferred as \'Collection<@NonNull @Nullable String> map2(Collection<@NonNull @Nullable Object>, Function<@NonNull @Nullable Object,@NonNull @Nullable String>)\', but only one of \'@NonNull\' and \'@Nullable\' can be effective at any location\n" + 
+			"----------\n");
+	}
+
 	// missing return type should not cause NPE
 	public void testBug415850_01() {
 		runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index d1b1cdc..96f5043 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -244,9 +244,49 @@ class BoundSet {
 					boundTypes[i] = environment.createAnnotatedType(boundTypes[i], annot);
 			}
 		}
+		TypeBinding combineAndUseNullHints(TypeBinding type, long nullHints, LookupEnvironment environment) {
+			// precondition: only called when null annotations are enabled.
+			// TODO(optimization): may want to collect all nullHints in the ThreeSets, which, however,
+			// needs a reference TypeBound->ThreeSets to propagate the bits as they are added.
+			if (this.sameBounds != null) {
+				Iterator<TypeBound> it = this.sameBounds.iterator();
+				while(it.hasNext())
+					nullHints |= it.next().nullHints;
+			}
+			if (this.superBounds != null) {
+				Iterator<TypeBound> it = this.superBounds.iterator();
+				while(it.hasNext())
+					nullHints |= it.next().nullHints;
+			}
+			if (this.subBounds != null) {
+				Iterator<TypeBound> it = this.subBounds.iterator();
+				while(it.hasNext())
+					nullHints |= it.next().nullHints;
+			}
+			AnnotationBinding[] annot = environment.nullAnnotationsFromTagBits(nullHints);
+			if (annot != null)
+				// only get here if exactly one of @NonNull or @Nullable was hinted; now apply this hint:
+				return environment.createAnnotatedType(type, annot);
+			return type;
+		}
 		public void setInstantiation(TypeBinding type, LookupEnvironment environment) {
 			if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
-				// TODO check for existing instantiation and compare null annotations
+				if (this.instantiation != null) {
+					// sanity check:
+					if (!TypeBinding.equalsEquals(this.instantiation, type)) {
+						this.instantiation = null;
+						return; // incorporation should find the conflict and fail the inference
+					}
+					long oldBits = this.instantiation.tagBits & TagBits.AnnotationNullMASK;
+					if (oldBits != 0) {
+						long newBits = type.tagBits & TagBits.AnnotationNullMASK;
+						if (newBits == oldBits || newBits == 0)
+							return; // no update
+						AnnotationBinding[] annot = environment.nullAnnotationsFromTagBits(newBits);
+						if (annot != null)
+							type = environment.createAnnotatedType(this.instantiation, annot);
+					}
+				}
 			}
 			this.instantiation = type;
 		}
@@ -356,7 +396,9 @@ class BoundSet {
 		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
 		if (three != null) {
 			TypeBinding instantiation = three.instantiation;
-			// TODO consider null annotations if enabled
+			if (environment != null && environment.globalOptions.isAnnotationBasedNullAnalysisEnabled 
+					&& instantiation != null && (instantiation.tagBits & TagBits.AnnotationNullMASK) == 0)
+				return three.combineAndUseNullHints(instantiation, inferenceVariable.nullHints, environment);
 			return instantiation;
 		}
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index 08cd76f..32cc29b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -33,6 +33,7 @@ import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
@@ -532,6 +533,8 @@ public class InferenceContext18 {
 				TypeBinding[] solutions = getSolutions(original.typeVariables(), invocation, result);
 				if (solutions != null) {
 					finalMethod = this.environment.createParameterizedGenericMethod(original, solutions);
+					if (this.scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled)
+						finalMethod = NullAnnotationMatching.checkForContraditions(finalMethod, invocation, this.scope);
 					invocation.registerInferenceContext(finalMethod, this);
 					this.solutionsPerTargetType.put(targetType, new Solution(finalMethod, result));
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 247312c..598d2b4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -157,14 +157,14 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 						if (solutions != null) {
 							
 							methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
-							if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
-								methodSubstitute = NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
 							if (hasReturnProblem) { // illegally working from the provisional result?
 								MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
 								if (problemMethod instanceof ProblemMethodBinding)
 									return problemMethod;
 							}
 							if (invocationTypeInferred) {
+								if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
+									methodSubstitute = NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
 								infCtx18.rebindInnerPolies(result, methodSubstitute.parameters);
 								return methodSubstitute.boundCheck18(scope, arguments);
 							} else {
