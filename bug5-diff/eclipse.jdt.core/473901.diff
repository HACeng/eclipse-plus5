commit 19d831578c7752138307147c2a19ddfc6ea54777
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Sep 22 11:09:00 2015 +0530

    Bug 473901 - [1.9] Restructure Java Model for Jimage

3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Jimage.java
3	3	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Jimage.java
59	24	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
271	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JimageUtil.java
3	219	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
9	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
17	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
0	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
20	20	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
5	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
7	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
75	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
119	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePackageFragmentRoot.java
7	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
4	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
19	29	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
1	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
10	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Jimage.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Jimage.java
index bd84ced..4c951c7 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Jimage.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/Jimage.java
@@ -172,7 +172,7 @@ public class Jimage extends Archive {
 		protected ClassFileReader getClassReader() {
 			ClassFileReader reader = null;
 			try {
-				reader = ClassFileReader.readFromJimage(this.file.toPath().toString(), this.entryName, this.module);
+				reader = ClassFileReader.readFromJimage(this.file, this.entryName, this.module);
 			} catch (ClassFormatException e) {
 				e.printStackTrace();
 			} catch (IOException e) {
@@ -188,7 +188,7 @@ public class Jimage extends Archive {
 		@Override
 		public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 			return Util.getCharContents(this, ignoreEncodingErrors,
-					org.eclipse.jdt.internal.compiler.util.Util.getClassfileContent(this.entryName, this.module),
+					org.eclipse.jdt.internal.compiler.util.JimageUtil.getClassfileContent(this.file, this.entryName, this.module),
 					this.charset.name());
 		}
 
@@ -213,7 +213,7 @@ public class Jimage extends Archive {
 		 */
 		@Override
 		public InputStream openInputStream() throws IOException {
-			return org.eclipse.jdt.internal.compiler.util.Util.getContentFromJimage(this.entryName, null);
+			return org.eclipse.jdt.internal.compiler.util.JimageUtil.getContentFromJimage(this.file, this.entryName, null);
 		}
 
 		/* (non-Javadoc)
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Jimage.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Jimage.java
index 2230e45..eb7c366 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Jimage.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/Jimage.java
@@ -173,7 +173,7 @@ public class Jimage extends Archive {
 		protected ClassFileReader getClassReader() {
 			ClassFileReader reader = null;
 			try {
-				reader = ClassFileReader.readFromJimage(this.file.toPath().toString(), this.entryName, this.module);
+				reader = ClassFileReader.readFromJimage(this.file, this.entryName, this.module);
 			} catch (ClassFormatException e) {
 				e.printStackTrace();
 			} catch (IOException e) {
@@ -189,7 +189,7 @@ public class Jimage extends Archive {
 		@Override
 		public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 			return Util.getCharContents(this, ignoreEncodingErrors,
-					org.eclipse.jdt.internal.compiler.util.Util.getClassfileContent(this.entryName, this.module),
+					org.eclipse.jdt.internal.compiler.util.JimageUtil.getClassfileContent(this.file, this.entryName, this.module),
 					this.charset.name());
 		}
 
@@ -214,7 +214,7 @@ public class Jimage extends Archive {
 		 */
 		@Override
 		public InputStream openInputStream() throws IOException {
-			return org.eclipse.jdt.internal.compiler.util.Util.getContentFromJimage(this.entryName, null);
+			return org.eclipse.jdt.internal.compiler.util.JimageUtil.getContentFromJimage(this.file, this.entryName, null);
 		}
 
 		/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index a255c3d..9889402 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -36,6 +36,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.compiler.util.Util;
@@ -113,7 +114,7 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 	try {
 		ClassFileReader reader = null;
 		if (this.isJimage) {
-			reader = ClassFileReader.readFromJimage(this.file.getPath(), qualifiedBinaryFileName);
+			reader = ClassFileReader.readFromJimage(this.file, qualifiedBinaryFileName);
 		} else {
 			reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		}
@@ -141,32 +142,65 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 }
 @Override
 public boolean hasAnnotationFileFor(String qualifiedTypeName) {
-	if (this.isJimage) return false; // For now;
+	if (this.isJimage) return false; // TODO: Revisit
 	return this.zipFile.getEntry(qualifiedTypeName+'.'+ExternalAnnotationProvider.ANNOTION_FILE_EXTENSION) != null; 
 }
-public char[][][] findTypeNames(String qualifiedPackageName) {
+public char[][][] findTypeNames(final String qualifiedPackageName) {
 	if (!isPackage(qualifiedPackageName))
 		return null; // most common case
 
-	ArrayList answers = new ArrayList();
-	nextEntry : for (Enumeration e = this.zipFile.entries(); e.hasMoreElements(); ) {
-		String fileName = ((ZipEntry) e.nextElement()).getName();
+	final ArrayList answers = new ArrayList();
+	if (this.isJimage) {
+		try {
+			JimageUtil.walkModuleImage(this.file, new JimageUtil.JimageVisitor<java.nio.file.Path>() {
+
+				@Override
+				public FileVisitResult visitPackage(java.nio.file.Path dir, java.nio.file.Path mod, BasicFileAttributes attrs) throws IOException {
+					if (!dir.toString().equals(qualifiedPackageName)) {
+						return FileVisitResult.SKIP_SUBTREE;
+					}
+					return FileVisitResult.CONTINUE;
+				}
+
+				@Override
+				public FileVisitResult visitFile(java.nio.file.Path dir, java.nio.file.Path mod, BasicFileAttributes attrs) throws IOException {
+					char[] packageArray = qualifiedPackageName.toCharArray();
+					answers.add(
+							CharOperation.arrayConcat(
+								CharOperation.splitOn('/', packageArray),
+								dir.toString().toCharArray()));
+					return FileVisitResult.CONTINUE;
+				}
 
-		// add the package name & all of its parent packages
-		int last = fileName.lastIndexOf('/');
-		while (last > 0) {
-			// extract the package name
-			String packageName = fileName.substring(0, last);
-			if (!qualifiedPackageName.equals(packageName))
-				continue nextEntry;
-			int indexOfDot = fileName.lastIndexOf('.');
-			if (indexOfDot != -1) {
-				String typeName = fileName.substring(last + 1, indexOfDot);
-				char[] packageArray = packageName.toCharArray();
-				answers.add(
-					CharOperation.arrayConcat(
-						CharOperation.splitOn('/', packageArray),
-						typeName.toCharArray()));
+				@Override
+				public FileVisitResult visitModule(java.nio.file.Path mod) throws IOException {
+					return FileVisitResult.CONTINUE;
+				}
+
+			});
+		} catch (IOException e) {
+			// Ignore and move on
+		}
+	} else {
+		nextEntry : for (Enumeration e = this.zipFile.entries(); e.hasMoreElements(); ) {
+			String fileName = ((ZipEntry) e.nextElement()).getName();
+
+			// add the package name & all of its parent packages
+			int last = fileName.lastIndexOf('/');
+			while (last > 0) {
+				// extract the package name
+				String packageName = fileName.substring(0, last);
+				if (!qualifiedPackageName.equals(packageName))
+					continue nextEntry;
+				int indexOfDot = fileName.lastIndexOf('.');
+				if (indexOfDot != -1) {
+					String typeName = fileName.substring(last + 1, indexOfDot);
+					char[] packageArray = packageName.toCharArray();
+					answers.add(
+						CharOperation.arrayConcat(
+							CharOperation.splitOn('/', packageArray),
+							typeName.toCharArray()));
+				}
 			}
 		}
 	}
@@ -195,7 +229,7 @@ protected void addToPackageCache(String fileName, boolean endsWithSep) {
 		last = packageName.lastIndexOf('/');
 	}
 }
-public boolean isPackage(String qualifiedPackageName) {
+public synchronized boolean isPackage(String qualifiedPackageName) {
 	if (this.packageCache != null)
 		return this.packageCache.containsKey(qualifiedPackageName);
 
@@ -203,7 +237,7 @@ public boolean isPackage(String qualifiedPackageName) {
 	this.packageCache.put(Util.EMPTY_STRING, Util.EMPTY_STRING);
 	if (this.isJimage) {
 		try {
-			Util.walkModuleImage(this.file, new Util.JimageVisitor<java.nio.file.Path>() {
+			JimageUtil.walkModuleImage(this.file, new JimageUtil.JimageVisitor<java.nio.file.Path>() {
 
 				@Override
 				public FileVisitResult visitPackage(java.nio.file.Path dir, java.nio.file.Path mod, BasicFileAttributes attrs) throws IOException {
@@ -252,7 +286,8 @@ public void reset() {
 			this.annotationZipFile = null;
 		}
 	}
-	this.packageCache = null;
+	if (!this.isJimage)
+		this.packageCache = null;
 }
 public String toString() {
 	return "Classpath for jar file " + this.file.getPath(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index b9e8ede..d0024e9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -37,6 +37,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ClassFileReader extends ClassFileStruct implements IBinaryType {
@@ -119,24 +120,23 @@ public static ClassFileReader read(
 }
 
 public static ClassFileReader readFromJimage(
-		String jimge,
+		File jimage,
 		String filename)
 		throws ClassFormatException, java.io.IOException {
 
-		byte classFileBytes[] = Util.getClassfileContent(filename, null /* no track of modules here */);
-		return new ClassFileReader(classFileBytes, filename.toCharArray());
+		return readFromJimage(jimage, filename, null);
 	}
 public static ClassFileReader readFromJimage(
-		String jimge,
+		File jimage,
 		String filename,
 		String module)
 
 		throws ClassFormatException, java.io.IOException {
-		byte classFileBytes[] = Util.getClassfileContent(filename, module);
+		byte classFileBytes[] = JimageUtil.getClassfileContent(jimage, filename, module);
+		if (classFileBytes == null) return null;
 		return new ClassFileReader(classFileBytes, filename.toCharArray());
 	}
 
-// TODO: Doesn't appear to be used anywhere. Revisit to remove.
 public static ClassFileReader read(
 	java.util.zip.ZipFile zip,
 	String filename,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JimageUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JimageUtil.java
new file mode 100644
index 0000000..0ef39e4
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JimageUtil.java
@@ -0,0 +1,271 @@
+package org.eclipse.jdt.internal.compiler.util;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.nio.file.DirectoryStream;
+import java.nio.file.FileSystems;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class JimageUtil {
+
+	public static final String JAVA_BASE = "java.base"; //$NON-NLS-1$
+	static final String MODULES_SUBDIR = "/modules"; //$NON-NLS-1$
+	static final String[] DEFAULT_MODULE = new String[]{JAVA_BASE};
+	static final String[] NO_MODULE = new String[0];
+	static final String MULTIPLE = "MU"; //$NON-NLS-1$
+	static final String DEFAULT_PACKAGE = ""; //$NON-NLS-1$
+	static final String MODULES_ON_DEMAND = System.getProperty("modules"); //$NON-NLS-1$
+	static URI JRT_URI = URI.create("jrt:/"); //$NON-NLS-1$
+
+	private static Map<File, JimageFileSystem> images = null;
+
+	public interface JimageVisitor<T> {
+
+		public FileVisitResult visitPackage(T dir, T mod, BasicFileAttributes attrs) throws IOException;
+
+		public FileVisitResult visitFile(T file, T mod, BasicFileAttributes attrs) throws IOException;
+		/**
+		 * Invoked when a root directory of a module being visited. The element returned 
+		 * contains only the module name segment - e.g. "java.base". Clients can use this to control
+		 * how the Jimage needs to be processed, for e.g., clients can skip a particular module
+		 * by returning FileVisitResult.SKIP_SUBTREE
+		 */
+		public FileVisitResult visitModule(T mod) throws IOException;
+	}
+
+	static abstract class AbstractFileVisitor<T> implements FileVisitor<T> {
+		@Override
+		public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException {
+			return FileVisitResult.CONTINUE;
+		}
+	
+		@Override
+		public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException {
+			return FileVisitResult.CONTINUE;
+		}
+	
+		@Override
+		public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException {
+			return FileVisitResult.CONTINUE;
+		}
+	
+		@Override
+		public FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException {
+			return FileVisitResult.CONTINUE;
+		}
+	}
+
+	public static JimageFileSystem getJimageSystem(File image) {
+		JimageFileSystem system = null;
+		if (images == null) {
+			images = new HashMap<>();
+			images.put(image, system = new JimageFileSystem(image));
+			return system;
+		}
+		system = images.get(image);
+		if (system == null) {
+			images.put(image, system = new JimageFileSystem(image));
+		}
+		return system;
+	}
+
+	/**
+	 * Given the path of a modular image file, this method walks the archive content and
+	 * notifies the supplied visitor about packages and files visited.
+	 * Note: At the moment, there's no way to open any arbitrary image. Currently,
+	 * this method uses the JRT file system provider to look inside the JRE.
+	 *
+	 * The file system contains the following top level directories:
+	 *  /modules/$MODULE/$PATH
+	 *  /packages/$PACKAGE/$MODULE 
+	 *  The latter provides quick look up of the module that contains a particular package. However,
+	 *  this method only notifies its clients of the entries within the modules sub-directory.
+	 *  
+	 * @param image a java.io.File handle to the JRT image.
+	 * @param visitor an instance of JimageVisitor to be notified of the entries in the JRT image.
+	 * @throws IOException
+	 */
+	public static void walkModuleImage(File image, final JimageUtil.JimageVisitor<java.nio.file.Path> visitor) throws IOException {
+		getJimageSystem(image).walkModuleImage(visitor, false);
+	}
+
+	public static InputStream getContentFromJimage(File jimage, String fileName, String module) throws IOException {
+		return getJimageSystem(jimage).getContentFromJimage(fileName, module);
+	}
+
+	public static byte[] getClassfileContent(File jimage, String fileName, String module) throws IOException {
+		return getJimageSystem(jimage).getClassfileContent(fileName, module);
+	}
+}
+class JimageFileSystem {
+	private final Map<String, String> packageToModule = new HashMap<String, String>();
+
+	private final Map<String, List<String>> packageToModules = new HashMap<String, List<String>>();
+	
+	private final Set<String> notFound = new HashSet<>();
+
+	/**
+	 * As of now, the passed reference to the jimage file is not being used. Perhaps eventually
+	 * when we know how to read a particular jimage, we will make use of this.
+	 *
+	 * @param image
+	 */
+	public JimageFileSystem(File image) {
+		initialize(image);
+	}
+	void initialize(File image) {
+		try {
+			walkModuleImage(null, true);
+		} catch (IOException e) {
+			// Continue to exist as a dummy file system?
+		}
+	}
+
+	public String[] getModules(String fileName) {
+		int idx = fileName.lastIndexOf('/');
+		String pack = null;
+		if (idx != -1) {
+			pack = fileName.substring(0, idx);
+		} else {
+			pack = JimageUtil.DEFAULT_PACKAGE;
+		}
+		String module = this.packageToModule.get(pack);
+		if (module != null) {
+			if (module == JimageUtil.MULTIPLE) {
+				List<String> list = this.packageToModules.get(pack);
+				return list.toArray(new String[list.size()]);
+			} else {
+				return new String[]{module};
+			}
+		}
+		return JimageUtil.DEFAULT_MODULE;
+	}
+
+	public InputStream getContentFromJimage(String fileName, String module) throws IOException {
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JimageUtil.JRT_URI);
+		if (module != null) {
+			return Files.newInputStream(fs.getPath(JimageUtil.MODULES_SUBDIR, module, fileName));
+		}
+		String[] modules = getModules(fileName);
+		for (String mod : modules) {
+			return Files.newInputStream(fs.getPath(JimageUtil.MODULES_SUBDIR, mod, fileName));
+		}
+		return null;
+	}
+
+	public byte[] getClassfileContent(String fileName, String module) throws IOException {
+		if (this.notFound.contains(fileName)) 
+			return null;
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JimageUtil.JRT_URI);
+		if (module != null) {
+			return Files.readAllBytes(fs.getPath(JimageUtil.MODULES_SUBDIR, module, fileName));
+		}
+		String[] modules = getModules(fileName);
+		for (String string : modules) {
+			try {
+				byte[] bytes = Files.readAllBytes(fs.getPath(JimageUtil.MODULES_SUBDIR, string, fileName));
+				if (bytes != null) return bytes;
+			} catch(NoSuchFileException e) {
+				continue;
+			}
+		}
+		this.notFound.add(fileName);
+		return null;
+	}
+
+	void walkModuleImage(final JimageUtil.JimageVisitor<java.nio.file.Path> visitor, boolean visitPackageMapping) throws IOException {
+		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JimageUtil.JRT_URI);
+		Iterable<java.nio.file.Path> roots = fs.getRootDirectories();
+		for (java.nio.file.Path path : roots) {
+			try (DirectoryStream<java.nio.file.Path> stream = Files.newDirectoryStream(path)) {
+				for (final java.nio.file.Path subdir: stream) {
+					if (subdir.toString().equals(JimageUtil.MODULES_SUBDIR)) {
+						if (visitPackageMapping) continue;
+						Files.walkFileTree(subdir, new JimageUtil.AbstractFileVisitor<java.nio.file.Path>() {
+							@Override
+							public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
+								int count = dir.getNameCount();
+								if (count == 2) {
+									java.nio.file.Path mod = dir.getName(1);
+									if (JimageUtil.MODULES_ON_DEMAND != null && JimageUtil.MODULES_ON_DEMAND.indexOf(mod.toString()) == -1) {
+										return FileVisitResult.SKIP_SUBTREE;
+									}
+									return visitor.visitModule(mod);
+								}
+								if (dir == subdir || count < 3) return FileVisitResult.CONTINUE;
+								return visitor.visitPackage(dir.subpath(2, count), dir.getName(1), attrs);
+							}
+
+							@Override
+							public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
+								int count = file.getNameCount();
+								// This happens when a file in a default package is present. E.g. /modules/some.module/file.name
+								if (count == 3) {
+									cachePackage(JimageUtil.DEFAULT_PACKAGE, file.getName(1).toString());
+								}
+								return visitor.visitFile(file.subpath(2, file.getNameCount()), file.getName(1), attrs);
+							}
+						});
+					} else if (visitPackageMapping) {
+						Files.walkFileTree(subdir, new JimageUtil.AbstractFileVisitor<java.nio.file.Path>() {
+							@Override
+							public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
+								java.nio.file.Path relative = subdir.relativize(file);
+								cachePackage(relative.getParent().toString(), relative.getFileName().toString());
+								return FileVisitResult.CONTINUE;
+							}
+						});
+					}
+			    }
+			} catch (Exception e) {
+				throw new IOException(e.getMessage());
+			}
+		}
+	}
+
+	void cachePackage(String packageName, String module) {
+		packageName = packageName.intern();
+		module = module.intern();
+		packageName = packageName.replace('.', '/');
+		Object current = this.packageToModule.get(packageName);
+		if (current == null) {
+			this.packageToModule.put(packageName, module);
+		} else if(current == module || current.equals(module)) {
+			return;
+		} else if (current == JimageUtil.MULTIPLE) {
+			List<String> list = this.packageToModules.get(packageName);
+			if (!list.contains(module)) {
+				if (JimageUtil.JAVA_BASE == module || JimageUtil.JAVA_BASE.equals(module)) {
+					list.add(0, JimageUtil.JAVA_BASE);
+				} else {
+					list.add(module);
+				}
+			}
+		} else {
+			String first = (String) current;
+			this.packageToModule.put(packageName, JimageUtil.MULTIPLE);
+			List<String> list = new ArrayList<String>();
+			// Just do this as comparator might be overkill
+			if (JimageUtil.JAVA_BASE == current || JimageUtil.JAVA_BASE.equals(current)) {
+				list.add(first);
+				list.add(module);
+			} else {
+				list.add(module);
+				list.add(first);
+			}
+			this.packageToModules.put(packageName, list);
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 9b17415..c083afa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -28,19 +28,9 @@ import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.nio.file.DirectoryStream;
-import java.nio.file.FileSystems;
-import java.nio.file.FileVisitResult;
-import java.nio.file.FileVisitor;
-import java.nio.file.Files;
-import java.nio.file.NoSuchFileException;
-import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -248,20 +238,6 @@ public class Util implements SuffixConstants {
 	public static final String EMPTY_STRING = new String(CharOperation.NO_CHAR);
 	public static final int[] EMPTY_INT_ARRAY= new int[0];
 
-	private static URI JRT_URI = URI.create("jrt:/"); //$NON-NLS-1$
-
-	public static final String JAVA_BASE = "java.base"; //$NON-NLS-1$
-	private static final String MODULES_SUBDIR = "/modules"; //$NON-NLS-1$
-	private static final String[] SINGLE_MODULE_ARRAY = new String[]{null};
-	private static final String[] DEFAULT_MODULE = new String[]{JAVA_BASE};
-	private static final String MULTIPLE = "MU"; //$NON-NLS-1$
-	private static final String DEFAULT_PACKAGE = ""; //$NON-NLS-1$
-	static final String MODULES_ON_DEMAND = System.getProperty("modules"); //$NON-NLS-1$
-
-	private static final Map<String, String> packageToModule = new HashMap<String, String>();
-
-	private static final Map<String, List<String>> packageToModules = new HashMap<String, List<String>>();
-
 	/**
 	 * Build all the directories and subdirectories corresponding to the packages names
 	 * into the directory specified in parameters.
@@ -727,183 +703,6 @@ public class Util implements SuffixConstants {
 			}
 		}
 	}
-	/**
-	 * Given the path of a modular image file, this method walks the archive content and
-	 * notifies the supplied visitor about packages and files visited.
-	 * Note: At the moment, there's no way to open any arbitrary image. Currently,
-	 * this method uses the JRT file system provider to look inside the JRE.
-	 *
-	 * The file system contains the following top level directories:
-	 *  /modules/$MODULE/$PATH
-	 *  /packages/$PACKAGE/$MODULE 
-	 *  The latter provides quick look up of the module that contains a particular package.
-	 *  
-	 * @param image a java.io.File handle to the JRT image.
-	 * @param visitor an instance of JimageVisitor to be notified of the entries in the JRT image.
-	 * @throws IOException
-	 */
-	public static void walkModuleImage(File image, final JimageVisitor<java.nio.file.Path> visitor) throws IOException {
-		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
-		Iterable<java.nio.file.Path> roots = fs.getRootDirectories();
-		for (java.nio.file.Path path : roots) {
-			try (DirectoryStream<java.nio.file.Path> stream = Files.newDirectoryStream(path)) {
-				for (final java.nio.file.Path subdir: stream) {
-					if (!subdir.toString().equals(MODULES_SUBDIR)) {
-						Files.walkFileTree(subdir, new AbstractFileVisitor<java.nio.file.Path>() {
-							@Override
-							public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
-								java.nio.file.Path relative = subdir.relativize(file);
-								cachePackage(relative.getParent().toString(), relative.getFileName().toString());
-								return FileVisitResult.CONTINUE;
-							}
-						});
-					} else {
-						Files.walkFileTree(subdir, new AbstractFileVisitor<java.nio.file.Path>() {
-							@Override
-							public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
-								int count = dir.getNameCount();
-								if (count == 2) {
-									java.nio.file.Path mod = dir.getName(1);
-									if (MODULES_ON_DEMAND != null && MODULES_ON_DEMAND.indexOf(mod.toString()) == -1) {
-										return FileVisitResult.SKIP_SUBTREE;
-									}
-									return visitor.visitModule(mod);
-								}
-								if (dir == subdir || count < 3) return FileVisitResult.CONTINUE;
-								return visitor.visitPackage(dir.subpath(2, count), dir.getName(1), attrs);
-							}
-
-							@Override
-							public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
-								int count = file.getNameCount();
-								// This happens when a file in a default package is present. E.g. /modules/some.module/file.name
-								if (count == 3) {
-									cachePackage(DEFAULT_PACKAGE, file.getName(1).toString());
-								}
-								return visitor.visitFile(file.subpath(2, file.getNameCount()), file.getName(1), attrs);
-							}
-						});
-					}
-			    }
-			} catch (Exception e) {
-				throw new IOException(e.getMessage());
-			}
-		}
-	}
-
-	static abstract class AbstractFileVisitor<T> implements FileVisitor<T> {
-		@Override
-		public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException {
-			return FileVisitResult.CONTINUE;
-		}
-
-		@Override
-		public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException {
-			return FileVisitResult.CONTINUE;
-		}
-
-		@Override
-		public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException {
-			return FileVisitResult.CONTINUE;
-		}
-
-		@Override
-		public FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException {
-			return FileVisitResult.CONTINUE;
-		}
-	}
-
-	static void cachePackage(String packageName, String module) {
-		packageName = packageName.intern();
-		module = module.intern();
-		packageName = packageName.replace('.', '/');
-		Object current = packageToModule.get(packageName);
-		if (current == null) {
-			packageToModule.put(packageName, module);
-		} else if(current == module || current.equals(module)) {
-			return;
-		} else if (current == MULTIPLE) {
-			List<String> list = packageToModules.get(packageName);
-			if (!list.contains(module)) {
-				if (JAVA_BASE == module || JAVA_BASE.equals(module)) {
-					list.add(0, JAVA_BASE);
-				} else {
-					list.add(module);
-				}
-			}
-		} else {
-			String first = (String) current;
-			packageToModule.put(packageName, MULTIPLE);
-			List<String> list = new ArrayList<String>();
-			// Just do this as comparator might be overkill
-			if (JAVA_BASE == current || JAVA_BASE.equals(current)) {
-				list.add(first);
-				list.add(module);
-			} else {
-				list.add(module);
-				list.add(first);
-			}
-			packageToModules.put(packageName, list);
-		}
-	}
-
-	private static String[] getModules(String fileName) {
-		int idx = fileName.lastIndexOf('/');
-		String pack = null;
-		if (idx != -1) {
-			pack = fileName.substring(0, idx);
-		} else {
-			pack = DEFAULT_PACKAGE;
-		}
-		String module = packageToModule.get(pack);
-		if (module != null) {
-			if (module == MULTIPLE) {
-				List<String> list = packageToModules.get(pack);
-				return list.toArray(new String[list.size()]);
-			} else {
-				SINGLE_MODULE_ARRAY[0] = module;
-				return SINGLE_MODULE_ARRAY;
-			}
-		}
-		return DEFAULT_MODULE;
-	}
-
-	public static InputStream getContentFromJimage(String fileName) throws IOException {
-		return getContentFromJimage(fileName, null);
-	}
-
-	public static InputStream getContentFromJimage(String fileName, String module) throws IOException {
-		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
-		if (module != null) {
-			return Files.newInputStream(fs.getPath(MODULES_SUBDIR, module, fileName));
-		}
-		String[] modules = getModules(fileName);
-		for (String mod : modules) {
-			return Files.newInputStream(fs.getPath(MODULES_SUBDIR, mod, fileName));
-		}
-		return null;
-	}
-
-	public static byte[] getClassfileContent(String fileName) throws IOException {
-		return getClassfileContent(fileName, null);
-	}
-
-	public static byte[] getClassfileContent(String fileName, String module) throws IOException {
-		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
-		if (module != null) {
-			return Files.readAllBytes(fs.getPath(MODULES_SUBDIR, module, fileName));
-		}
-		String[] modules = getModules(fileName);
-		for (String string : modules) {
-			try {
-				byte[] bytes = Files.readAllBytes(fs.getPath(MODULES_SUBDIR, string, fileName));
-				if (bytes != null) return bytes;
-			} catch(NoSuchFileException e) {
-				continue;
-			}
-		}
-		return null;
-	}
 	public static int hashCode(Object[] array) {
 		int prime = 31;
 		if (array == null) {
@@ -1383,7 +1182,7 @@ public class Util implements SuffixConstants {
 			StringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);
 			while (tokenizer.hasMoreTokens()) {
 				filePaths.add(tokenizer.nextToken());
-				}
+			}
 		} else {
 			// try to get all jars inside the lib folder of the java home
 			final File javaHome = getJavaHome();
@@ -1406,14 +1205,14 @@ public class Util implements SuffixConstants {
 						if (current != null) {
 							for (int j = 0, max2 = current.length; j < max2; j++) {
 								filePaths.add(current[j].getAbsolutePath());
-								}
 							}
 						}
 					}
 				}
 			}
-		return filePaths;
 		}
+		return filePaths;
+	}
 	public static int getParameterCount(char[] methodSignature) {
 		try {
 			int count = 0;
@@ -1882,19 +1681,4 @@ public class Util implements SuffixConstants {
 				}
 		}
 	}
-
-	public interface JimageVisitor<T> {
-
-		public FileVisitResult visitPackage(T dir, T mod, BasicFileAttributes attrs) throws IOException;
-
-		public FileVisitResult visitFile(T file, T mod, BasicFileAttributes attrs) throws IOException;
-		/**
-		 * Invoked when a root directory of a module being visited. The element returned 
-		 * contains only the module name segment - e.g. "java.base". Clients can use this to control
-		 * how the Jimage needs to be processed, for e.g., clients can skip a particular module
-		 * by returning FileVisitResult.SKIP_SUBTREE
-		 */
-		public FileVisitResult visitModule(T mod) throws IOException;
-
-	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
index c1ed588..c9daac2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
@@ -361,6 +361,15 @@ public interface IPackageFragmentRoot
 	public boolean isArchive();
 
 	/**
+	 * Returns whether this package fragment root represents a Java module
+	 * or not. The module could either be a source or a binary coming from
+	 * the jimage. Note: This needs more work.
+	 *
+	 * @since 3.12 BETA_JAVA9
+	 */
+	public boolean isModule();
+
+	/**
 	 * Returns whether this package fragment root is external
 	 * to the workbench (that is, a local file), and has no
 	 * underlying resource.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index c89e1b6..399faba 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -18,6 +18,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
+import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
@@ -347,8 +348,11 @@ public byte[] getBytes() throws JavaModelException {
 }
 private byte[] getClassFileContent(JarPackageFragmentRoot root, String className) throws CoreException, IOException {
 	byte[] contents = null;
-	if (root.isJimage) {
-		contents = org.eclipse.jdt.internal.compiler.util.Util.getClassfileContent(className);
+	if (root.isModule()) {
+			contents = org.eclipse.jdt.internal.compiler.util.JimageUtil.getClassfileContent(
+					new File(root.getPath().toOSString()),
+					className,
+					root.getElementName());
 	} else {
 		ZipFile zip = root.getJar();
 		try {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
index 0f7112e..afd5fcd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.internal.core;
 
 import java.io.ByteArrayInputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.zip.ZipEntry;
@@ -22,9 +23,12 @@ import java.util.zip.ZipFile;
 
 import org.eclipse.core.resources.IStorage;
 import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.IJarEntryResource;
 import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
@@ -34,23 +38,31 @@ import org.eclipse.jdt.internal.compiler.util.Util;
  */
 public class JarEntryFile  extends JarEntryResource {
 	private static final IJarEntryResource[] NO_CHILDREN = new IJarEntryResource[0];
-	public JarEntryFile(String simpleName, boolean isJimage) {
-		super(simpleName, isJimage);
+	public JarEntryFile(String simpleName) {
+		super(simpleName);
 	}
 
 	public JarEntryResource clone(Object newParent) {
-		JarEntryFile file = new JarEntryFile(this.simpleName, this.isJimage);
+		JarEntryFile file = new JarEntryFile(this.simpleName);
 		file.setParent(newParent);
 		return file;
 	}
 
 	public InputStream getContents() throws CoreException {
-		if (this.isJimage) {
+		IPackageFragmentRoot root = getPackageFragmentRoot();
+		if (root.isModule()) {
 			try {
-				return Util.getContentFromJimage(getEntryName());
+				if (this.parent instanceof JarPackageFragmentRoot) {
+					IPath rootPath = ((JarPackageFragmentRoot) this.parent).getPath();
+					Object target = JavaModel.getTarget(rootPath, false);
+					if (target != null && target instanceof File) {
+						return JimageUtil.getContentFromJimage((File) target, getEntryName(), root.getElementName());
+					}
+				}
 			} catch (IOException e) {
 				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
 			}
+			return null;
 		} else {
 			ZipFile zipFile = null;
 			try {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
index c3d7c7f..50773f6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryResource.java
@@ -29,15 +29,9 @@ public abstract class JarEntryResource  extends PlatformObject implements IJarEn
 
 	protected Object parent;
 	protected String simpleName;
-	protected boolean isJimage;
 
 	public JarEntryResource(String simpleName) {
-		this(simpleName, false);
-	}
-
-	public JarEntryResource(String simpleName, boolean isJimage) {
 		this.simpleName = simpleName;
-		this.isJimage = isJimage;
 	}
 
 	public abstract JarEntryResource clone(Object newParent);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
index 3a937d2..9066ec0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java
@@ -55,7 +55,7 @@ protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm,
 	fragInfo.setChildren(computeChildren(entries[0/*class files*/]));
 
 	// compute non-Java resources
-	fragInfo.setNonJavaResources(computeNonJavaResources(entries[1/*non Java resources*/], root.isJimage));
+	fragInfo.setNonJavaResources(computeNonJavaResources(entries[1/*non Java resources*/]));
 
 	newElements.put(this, fragInfo);
 	return true;
@@ -78,7 +78,7 @@ private IJavaElement[] computeChildren(ArrayList namesWithoutExtension) {
 /**
  * Compute all the non-java resources according to the given entry names.
  */
-private Object[] computeNonJavaResources(ArrayList entryNames, boolean isJimage) {
+private Object[] computeNonJavaResources(ArrayList entryNames) {
 	int length = entryNames.size();
 	if (length == 0)
 		return JavaElementInfo.NO_NON_JAVA_RESOURCES;
@@ -95,7 +95,7 @@ private Object[] computeNonJavaResources(ArrayList entryNames, boolean isJimage)
 				// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=222665
 				continue;
 			}
-			JarEntryFile file = new JarEntryFile(filePath.lastSegment(), isJimage);
+			JarEntryFile file = new JarEntryFile(filePath.lastSegment());
 			jarEntries.put(childPath, file);
 			if (childPath.segmentCount() == 1) {
 				file.setParent(this);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 3a97dd6..fdc4163 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -47,7 +47,7 @@ import org.eclipse.jdt.internal.core.util.Util;
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class JarPackageFragmentRoot extends PackageFragmentRoot {
 
-	private final static ArrayList EMPTY_LIST = new ArrayList();
+	protected final static ArrayList EMPTY_LIST = new ArrayList();
 
 	/**
 	 * The path to the jar file
@@ -57,12 +57,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected final IPath jarPath;
 
 	/**
-	 * Whether this represents a JIMAGE format.
-	 * TODO: Might make sense to introduce a new type of PackageFragmentRoot
-	 */
-	protected final boolean isJimage;
-
-	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
 	 * based on a JAR file that is not contained in a <code>IJavaProject</code> and
 	 * does not have an associated <code>IResource</code>.
@@ -70,7 +64,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected JarPackageFragmentRoot(IPath externalJarPath, JavaProject project) {
 		super(null, project);
 		this.jarPath = externalJarPath;
-		this.isJimage = JavaModelManager.isJimage(externalJarPath);
 	}
 	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
@@ -79,7 +72,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected JarPackageFragmentRoot(IResource resource, JavaProject project) {
 		super(resource, project);
 		this.jarPath = resource.getFullPath();
-		this.isJimage = JavaModelManager.isJimage(this.jarPath);
 	}
 
 	/**
@@ -99,10 +91,10 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 			// always create the default package
 			rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });
 
-			if (this.isJimage) {
+			if (this.isModule()) {
 				try {
-					org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(getPath().toFile(),
-									new org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<Path>() {
+					org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(getPath().toFile(),
+									new org.eclipse.jdt.internal.compiler.util.JimageUtil.JimageVisitor<Path>() {
 						@Override
 						public FileVisitResult visitPackage(Path dir, Path mod, BasicFileAttributes attrs) throws IOException {
 							initRawPackageInfo(rawPackageInfo, dir.toString(), true, compliance);
@@ -157,6 +149,19 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		((JarPackageFragmentRootInfo) info).rawPackageInfo = rawPackageInfo;
 		return true;
 	}
+	protected IJavaElement[] createChildren(final HashtableOfArrayToObject rawPackageInfo) {
+		IJavaElement[] children;
+		// loop through all of referenced packages, creating package fragments if necessary
+		// and cache the entry names in the rawPackageInfo table
+		children = new IJavaElement[rawPackageInfo.size()];
+		int index = 0;
+		for (int i = 0, length = rawPackageInfo.keyTable.length; i < length; i++) {
+			String[] pkgName = (String[]) rawPackageInfo.keyTable[i];
+			if (pkgName == null) continue;
+			children[index++] = getPackageFragment(pkgName);
+		}
+		return children;
+	}
 	/**
 	 * Returns a new element info for this element.
 	 */
@@ -224,6 +229,9 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	public PackageFragment getPackageFragment(String[] pkgName) {
 		return new JarPackageFragment(this, pkgName);
 	}
+	public PackageFragment getPackageFragment(String[] pkgName, String mod) {
+		return new JarPackageFragment(this, pkgName); // Overridden in JImageModuleFragmentBridge
+	}
 	public IPath internalPath() {
 		if (isExternal()) {
 			return this.jarPath;
@@ -318,14 +326,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		return true;
 	}
 	/**
-	 * return true if jimage
-	 */
-	public boolean isJimage() {
-		return this.isJimage;
-	}
-
-
-	/**
 	 * Returns whether the corresponding resource or associated file exists
 	 */
 	protected boolean resourceExists(IResource underlyingResource) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
index 8e8a746..8f50572 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -361,6 +361,10 @@ public static boolean isFile(Object target) {
 	return false;
 }
 
+public static boolean isJimage(File file) {
+	return JavaModelManager.isJimage(file.getPath());
+}
+
 /**
  * Returns whether the provided path is an external file, checking and updating the
  * JavaModelManager's external file cache.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index da27f37..5f430bf 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -59,6 +59,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
+import org.eclipse.jdt.internal.compiler.util.ObjectVector;
 import org.eclipse.jdt.internal.core.JavaProjectElementInfo.ProjectCache;
 import org.eclipse.jdt.internal.core.builder.JavaBuilder;
 import org.eclipse.jdt.internal.core.dom.SourceRangeVerifier;
@@ -1153,6 +1154,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		public Map rootPathToRawEntries; // reverse map from a package fragment root's path to the raw entry
 		public Map rootPathToResolvedEntries; // map from a package fragment root's path to the resolved entry
 		public IPath outputLocation;
+		public Map<IPath, ObjectVector> jimageRoots; // A map between a Jimage classpath entry (as a string) and the package fragment roots found in it.
 
 		public IEclipsePreferences preferences;
 		public Hashtable options;
@@ -1262,6 +1264,11 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 			return setClasspath(this.rawClasspath, referencedEntries, this.outputLocation, this.rawClasspathStatus, newResolvedClasspath, newRootPathToRawEntries, newRootPathToResolvedEntries, newUnresolvedEntryStatus, addClasspathChange);
 		}
 
+		public synchronized void setJimagePackageRoots(IPath jimagePath, ObjectVector roots) {
+			if (this.jimageRoots == null) this.jimageRoots = new HashMap<>();
+			this.jimageRoots.put(jimagePath, roots);
+		}
+
 		/**
 		 * Reads the classpath and caches the entries. Returns a two-dimensional array, where the number of elements in the row is fixed to 2.
 		 * The first element is an array of raw classpath entries and the second element is an array of referenced entries that may have been stored
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index 13cfffb..2525f3c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -15,6 +15,8 @@ package org.eclipse.jdt.internal.core;
 
 import java.io.*;
 import java.net.URI;
+import java.nio.file.FileVisitResult;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -69,6 +71,7 @@ import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.eval.IEvaluationContext;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.ObjectVector;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.JavaModelManager.PerProjectInfo;
@@ -616,7 +619,20 @@ public class JavaProject
 				} else if (target instanceof File) {
 					// external target
 					if (JavaModel.isFile(target)) {
-						root = new JarPackageFragmentRoot(entryPath, this);
+						if (JavaModel.isJimage((File) target)) {
+							PerProjectInfo info = getPerProjectInfo();
+							if (info.jimageRoots == null || !info.jimageRoots.containsKey(entryPath)) {
+								ObjectVector imageRoots = new ObjectVector();
+								loadModulesInJimage(entryPath, imageRoots, rootToResolvedEntries, resolvedEntry, referringEntry);
+								info.setJimagePackageRoots(entryPath, imageRoots);
+								accumulatedRoots.addAll(imageRoots);
+								rootIDs.add(rootID);
+							} else {
+								accumulatedRoots.addAll(info.jimageRoots.get(entryPath));
+							}
+						} else {
+							root = new JarPackageFragmentRoot(entryPath, this);
+						}
 					} else if (((File) target).isDirectory()) {
 						root = new ExternalPackageFragmentRoot(entryPath, this);
 					}
@@ -654,6 +670,60 @@ public class JavaProject
 	}
 
 	/**
+	 * This bogus package fragment root acts as placeholder plus bridge for the
+	 * real one until the module name becomes available. It is useful in certain
+	 * scenarios like creating package roots from delta processors, search etc.
+	 */
+	class JImageModuleFragmentBridge extends JarPackageFragmentRoot {
+
+		protected JImageModuleFragmentBridge(IPath externalJarPath) {
+			super(externalJarPath, JavaProject.this);
+		}
+		public PackageFragment getPackageFragment(String[] pkgName) {
+			return getPackageFragment(pkgName, null);
+		}
+		public PackageFragment getPackageFragment(String[] pkgName, String mod) {
+			PackageFragmentRoot realRoot = new ModulePackageFragmentRoot(this.jarPath,
+												mod == null ?  JimageUtil.JAVA_BASE : mod,
+														JavaProject.this);
+			return new JarPackageFragment(realRoot, pkgName);
+		}
+		protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
+			// Do nothing, idea is to avoid this being read in JarPackageFragmentRoot as a Jar.
+			return true;
+		}
+	}
+
+	private void loadModulesInJimage(final IPath imagePath, final ObjectVector roots, final Map rootToResolvedEntries, 
+				final IClasspathEntry resolvedEntry, final IClasspathEntry referringEntry) {
+		try {
+			org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(imagePath.toFile(),
+					new org.eclipse.jdt.internal.compiler.util.JimageUtil.JimageVisitor<java.nio.file.Path>() {
+				@Override
+				public FileVisitResult visitPackage(java.nio.file.Path dir, java.nio.file.Path mod, BasicFileAttributes attrs) throws IOException {
+					return FileVisitResult.SKIP_SIBLINGS;
+				}
+
+				@Override
+				public FileVisitResult visitFile(java.nio.file.Path path, java.nio.file.Path mod, BasicFileAttributes attrs) throws IOException {
+					return FileVisitResult.SKIP_SIBLINGS;
+				}
+
+				@Override
+				public FileVisitResult visitModule(java.nio.file.Path mod) throws IOException {
+					ModulePackageFragmentRoot root = new ModulePackageFragmentRoot(imagePath, mod.toString(), JavaProject.this);
+					roots.add(root);
+					if (rootToResolvedEntries != null) 
+						rootToResolvedEntries.put(root, ((ClasspathEntry)resolvedEntry).combineWith((ClasspathEntry) referringEntry));
+					return FileVisitResult.SKIP_SUBTREE;
+				}
+			});
+		} catch (IOException e) {
+			Util.log(IStatus.ERROR, "Error reading modules from " + imagePath.toOSString()); //$NON-NLS-1$
+		}
+	}
+
+	/**
 	 * Returns (local/all) the package fragment roots identified by the given project's classpath.
 	 * Note: this follows project classpath references to find required project contributions,
 	 * eliminating duplicates silently.
@@ -1231,7 +1301,7 @@ public class JavaProject
 		}
 		for (int i= 0; i < allRoots.length; i++) {
 			IPackageFragmentRoot classpathRoot= allRoots[i];
-			if (classpathRoot.getPath().equals(path)) {
+			if (classpathRoot.getPath() != null && classpathRoot.getPath().equals(path)) {
 				return classpathRoot;
 			}
 		}
@@ -1833,6 +1903,9 @@ public class JavaProject
 		IFolder linkedFolder = JavaModelManager.getExternalManager().getFolder(externalLibraryPath);
 		if (linkedFolder != null)
 			return new ExternalPackageFragmentRoot(linkedFolder, externalLibraryPath, this);
+		if (JavaModelManager.isJimage(externalLibraryPath)) {
+			return this.new JImageModuleFragmentBridge(externalLibraryPath);
+		}
 		return new JarPackageFragmentRoot(externalLibraryPath, this);
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePackageFragmentRoot.java
new file mode 100644
index 0000000..8ddd1a0
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePackageFragmentRoot.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (c) 2015 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.io.IOException;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
+import org.eclipse.jdt.internal.core.util.Util;
+
+/**
+ * A package fragment root that corresponds to a .jimage
+ *
+ * @see org.eclipse.jdt.core.IPackageFragmentRoot
+ * @see org.eclipse.jdt.internal.core.JarPackageFragmentRootInfo
+ */
+public class ModulePackageFragmentRoot extends JarPackageFragmentRoot {
+
+	String moduleName;
+	
+	/**
+	 * Constructs a package fragment root which represents a module
+	 * contained in a Jimage.
+	 */
+	protected ModulePackageFragmentRoot(IPath jimagePath, String moduleName, JavaProject project) {
+		super(jimagePath, project);
+		this.moduleName = moduleName;
+	}
+
+	protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
+		final HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
+		final String compliance = CompilerOptions.VERSION_1_8; // TODO: Revisit
+
+		// always create the default package
+		rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });
+
+		try {
+			org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(this.jarPath.toFile(),
+					new org.eclipse.jdt.internal.compiler.util.JimageUtil.JimageVisitor<Path>() {
+				@Override
+				public FileVisitResult visitPackage(Path dir, Path mod, BasicFileAttributes attrs) throws IOException {
+					initRawPackageInfo(rawPackageInfo, dir.toString(), true, compliance);
+					return FileVisitResult.CONTINUE;
+				}
+
+				@Override
+				public FileVisitResult visitFile(Path path, Path mod, BasicFileAttributes attrs) throws IOException {
+					initRawPackageInfo(rawPackageInfo, path.toString(), false, compliance);
+					return FileVisitResult.CONTINUE;
+				}
+
+				@Override
+				public FileVisitResult visitModule(Path mod) throws IOException {
+					if (!ModulePackageFragmentRoot.this.moduleName.equals(mod.toString())) {
+						return FileVisitResult.SKIP_SUBTREE;
+					}
+					return FileVisitResult.CONTINUE;
+				}
+			});
+		} catch (IOException e) {
+			Util.log(IStatus.ERROR, "Error reading modules" + toStringWithAncestors()); //$NON-NLS-1$
+		}
+
+		info.setChildren(createChildren(rawPackageInfo));
+		((JarPackageFragmentRootInfo) info).rawPackageInfo = rawPackageInfo;
+		return true;
+	}
+	public boolean equals(Object o) {
+		if (this == o)
+			return true;
+		if (o instanceof ModulePackageFragmentRoot) {
+			ModulePackageFragmentRoot other= (ModulePackageFragmentRoot) o;
+			return this.moduleName.equals(other.moduleName);
+		}
+		return false;
+	}
+	public String getElementName() {
+		return this.moduleName;
+	}
+	public PackageFragment getPackageFragment(String[] pkgName) {
+		// NOTE: Do we need a different kind of package fragment?
+		return new JarPackageFragment(this, pkgName);
+	}
+	public int hashCode() {
+		return this.parent.hashCode() + this.moduleName.hashCode();
+	}
+	protected void toStringInfo(int tab, StringBuffer buffer, Object info, boolean showResolvedInfo) {
+		buffer.append(tabString(tab));
+		buffer.append("<module:").append(this.moduleName).append(">"); //$NON-NLS-1$ //$NON-NLS-2$
+		if (info == null) {
+			buffer.append(" (not open)"); //$NON-NLS-1$
+		}
+	}
+	@Override
+	public boolean isModule() {
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 6ec80c2..9677d03 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -521,6 +521,9 @@ public IPackageFragment getPackageFragment(String packageName) {
 public PackageFragment getPackageFragment(String[] pkgName) {
 	return new PackageFragment(this, pkgName);
 }
+public PackageFragment getPackageFragment(String[] pkgName, String mod) {
+	return new PackageFragment(this, pkgName); // Overridden in JImageModuleFragmentBridge
+}
 /**
  * Returns the package name for the given folder
  * (which is a decendent of this root).
@@ -828,4 +831,8 @@ protected void verifyAttachSource(IPath sourcePath) throws JavaModelException {
 	}
 }
 
+@Override
+public boolean isModule() {
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
index 10079df..851a21a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
@@ -67,9 +67,9 @@ import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.compiler.util.Util;
-import org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor;
 import org.eclipse.jdt.internal.core.util.ReferenceInfoAdapter;
 
 /**
@@ -461,7 +461,7 @@ public class SourceMapper
 		return -1;
 	}
 
-	class JimagePackageNamesAdderVisitor implements JimageVisitor<java.nio.file.Path> {
+	class JimagePackageNamesAdderVisitor implements JimageUtil.JimageVisitor<java.nio.file.Path> {
 
 		public final HashSet firstLevelPackageNames;
 		final IPackageFragmentRoot root;
@@ -535,13 +535,11 @@ public class SourceMapper
 
 		String sourceLevel = null;
 		String complianceLevel = null;
-		boolean isJimage = root instanceof JarPackageFragmentRoot ?
-				((JarPackageFragmentRoot) root).isJimage() : false;
-		if (isJimage) {
+		if (root.isModule()) {
 			try {
 				JimagePackageNamesAdderVisitor jimagePackageNamesAdderVisitor = new JimagePackageNamesAdderVisitor(firstLevelPackageNames, 
 						sourceLevel, complianceLevel, containsADefaultPackage, containsJavaSource, root);
-				org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(new File(root.toString()), jimagePackageNamesAdderVisitor);
+				org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(new File(root.toString()), jimagePackageNamesAdderVisitor);
 				sourceLevel = jimagePackageNamesAdderVisitor.sourceLevel;
 				complianceLevel = jimagePackageNamesAdderVisitor.complianceLevel;
 				containsADefaultPackage = jimagePackageNamesAdderVisitor.containsADefaultPackage;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 376fd8f..8de80b4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -72,11 +72,17 @@ protected static void addToPackageSet(SimpleSet packageSet, String fileName, boo
  */
 static SimpleSet findPackageSet(ClasspathJar jar) {
 	String zipFileName = jar.zipFilename;
+	PackageCacheEntry cacheEntry = (PackageCacheEntry) PackageCache.get(zipFileName);
+	long lastModified = jar.lastModified();
+	long fileSize = new File(zipFileName).length();
+	if (cacheEntry != null && cacheEntry.lastModified == lastModified && cacheEntry.fileSize == fileSize)
+		return cacheEntry.packageSet;
 	final SimpleSet packageSet = new SimpleSet(41);
+	packageSet.add(""); //$NON-NLS-1$
 	if (jar.isJimage) {
 		try {
-			org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(new File(jar.zipFilename), 
-					new org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<Path>() {
+			org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(new File(zipFileName), 
+					new org.eclipse.jdt.internal.compiler.util.JimageUtil.JimageVisitor<Path>() {
 
 				@Override
 				public FileVisitResult visitPackage(Path dir, Path mod, BasicFileAttributes attrs) throws IOException {
@@ -95,15 +101,10 @@ static SimpleSet findPackageSet(ClasspathJar jar) {
 				}
 			});
 		} catch (IOException e) {
-			// Move on
+			// TODO: Should report better
 		}
-		// TODO: What about caching?
+		PackageCache.put(zipFileName, new PackageCacheEntry(0, 0, packageSet));
 	} else {
-		long lastModified = jar.lastModified();
-		long fileSize = new File(zipFileName).length();
-		PackageCacheEntry cacheEntry = (PackageCacheEntry) PackageCache.get(zipFileName);
-		if (cacheEntry != null && cacheEntry.lastModified == lastModified && cacheEntry.fileSize == fileSize)
-			return cacheEntry.packageSet;
 		packageSet.add(""); //$NON-NLS-1$
 		for (Enumeration e = jar.zipFile.entries(); e.hasMoreElements(); ) {
 			String fileName = ((ZipEntry) e.nextElement()).getName();
@@ -111,7 +112,6 @@ static SimpleSet findPackageSet(ClasspathJar jar) {
 		}
 		PackageCache.put(zipFileName, new PackageCacheEntry(lastModified, fileSize, packageSet));
 	}
-
 	return packageSet;
 }
 
@@ -126,7 +126,6 @@ SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
 String externalAnnotationPath;
 boolean isJimage;
-static ClasspathJar jimage; // This assumes there will ever only be one jimage in the system.
 
 ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.resource = resource;
@@ -165,26 +164,13 @@ public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath external
 }
 
 public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
-	this.zipFilename = fileName;
-	this.closeZipFileAtEnd = false;
-	this.knownPackageNames = null;
-	this.accessRuleSet = accessRuleSet;
+	this(fileName, 0, accessRuleSet, externalAnnotationPath);
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
 	this.isJimage = JavaModelManager.isJimage(fileName);
 
 }
 
-public static ClasspathJar getClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
-	if (JavaModelManager.isJimage(zipFilename)) {
-		if (jimage == null) {
-			jimage = new ClasspathJar(zipFilename, lastModified, accessRuleSet, externalAnnotationPath);
-		}
-		return jimage;
-	}
-	return new ClasspathJar(zipFilename, lastModified, accessRuleSet, externalAnnotationPath);
-}
-
 public void cleanup() {
 	if (this.closeZipFileAtEnd) {
 		if (this.zipFile != null) {
@@ -208,8 +194,8 @@ public void cleanup() {
 public boolean equals(Object o) {
 	if (this == o) return true;
 	if (!(o instanceof ClasspathJar)) return false;
-
 	ClasspathJar jar = (ClasspathJar) o;
+	if (this.isJimage && jar.isJimage) return this.zipFilename.endsWith(jar.zipFilename);
 	if (this.accessRuleSet != jar.accessRuleSet)
 		if (this.accessRuleSet == null || !this.accessRuleSet.equals(jar.accessRuleSet))
 			return false;
@@ -222,7 +208,7 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	try {
 		ClassFileReader reader = null;
 		if (this.isJimage) {
-			reader = ClassFileReader.readFromJimage(this.zipFilename, qualifiedBinaryFileName);
+			reader = ClassFileReader.readFromJimage(new File(this.zipFilename), qualifiedBinaryFileName);
 		} else {
 			reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		}
@@ -259,8 +245,12 @@ public boolean isPackage(String qualifiedPackageName) {
 		return this.knownPackageNames.includes(qualifiedPackageName);
 
 	try {
-		if (this.isJimage && this.knownPackageNames == null) {
-			this.knownPackageNames = findPackageSet(this);
+		if (this.isJimage) {
+			synchronized (this) {
+				if (this.knownPackageNames == null) {
+					this.knownPackageNames = findPackageSet(this);
+				}
+			}
 		} else if (this.zipFile == null) {
 			if (org.eclipse.jdt.internal.core.JavaModelManager.ZIP_ACCESS_VERBOSE) {
 				System.out.println("(" + Thread.currentThread() + ") [ClasspathJar.isPackage(String)] Creating ZipFile on " + this.zipFilename); //$NON-NLS-1$	//$NON-NLS-2$
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index 78d0915..343abc0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -33,7 +29,7 @@ public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean
 }
 
 static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet, IPath annotationsPath) {
-	return ClasspathJar.getClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath);
+	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath);
 }
 
 static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
index 81a74da..0b2122b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -172,7 +172,7 @@ private IType createTypeFromJar(String resourcePath, int separatorIndex) throws
 	}
 	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
 	if (pkgFragment == null) {
-		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);
+		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName, null);
 		// filter org.apache.commons.lang.enum package for projects above 1.5 
 		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=317264
 		if (length == 5 && pkgName[4].equals("enum")) { //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
index 8485387..b5b64c1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
@@ -32,6 +32,7 @@ import org.eclipse.jdt.core.search.SearchParticipant;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.compiler.util.Util;
@@ -90,7 +91,7 @@ public class AddJimageFileToIndex extends IndexRequest {
 		return -1;
 	}
 	
-	private class JimageTraverser implements org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<java.nio.file.Path> {
+	private class JimageTraverser implements org.eclipse.jdt.internal.compiler.util.JimageUtil.JimageVisitor<java.nio.file.Path> {
 		
 		SimpleLookupTable indexedFileNames;
 		public JimageTraverser() {
@@ -127,8 +128,10 @@ public class AddJimageFileToIndex extends IndexRequest {
 		final IndexManager indexManager;
 		final IPath container;
 		final Index index;
+		final File jimage;
 
-		public JimageIndexer(SearchParticipant participant, Index index, IPath container, IndexManager indexManager) {
+		public JimageIndexer(File jimage, SearchParticipant participant, Index index, IPath container, IndexManager indexManager) {
+			this.jimage = jimage;
 			this.participant = (participant != null) ? participant : SearchEngine.getDefaultSearchParticipant();
 			this.index = index;
 			IndexLocation indexLocation = index.getIndexLocation();
@@ -144,7 +147,7 @@ public class AddJimageFileToIndex extends IndexRequest {
 					isValidPackageNameForClass(name)) {
 				try {
 					String fullPath = path.toString();
-					final byte[] classFileBytes = Util.getClassfileContent(fullPath, mod.toString());
+					final byte[] classFileBytes = JimageUtil.getClassfileContent(this.jimage, fullPath, mod.toString());
 					String docFullPath =  this.container.toString() + JAR_SEPARATOR + fullPath;
 					JavaSearchDocument entryDocument = new JavaSearchDocument(docFullPath, classFileBytes, this.participant);
 					this.indexManager.indexDocument(entryDocument, this.participant, this.index, this.indexPath);
@@ -238,7 +241,7 @@ public class AddJimageFileToIndex extends IndexRequest {
 					for (int i = 0; i < max; i++)
 						indexedFileNames.put(paths[i], FILE_INDEX_STATE.DELETED);
 					
-					org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(new File(fileName), 
+					org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(new File(fileName), 
 							new JimageTraverser(indexedFileNames));
 
 					boolean needToReindex = indexedFileNames.elementSize != max; // a new file was added
@@ -269,9 +272,9 @@ public class AddJimageFileToIndex extends IndexRequest {
 					return false;
 				}
 				
-				
-				org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(new File(fileName), 
-						new JimageIndexer(SearchEngine.getDefaultSearchParticipant(), index, container, this.manager));
+				File jimage = new File(fileName);
+				org.eclipse.jdt.internal.compiler.util.JimageUtil.walkModuleImage(jimage, 
+						new JimageIndexer(jimage, SearchEngine.getDefaultSearchParticipant(), index, container, this.manager));
 
 				if(this.forceIndexUpdate) {
 					this.manager.savePreBuiltIndex(index);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index e956102..23aa6ad 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -16,6 +16,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.matching;
 
+import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -257,7 +258,7 @@ public static ClassFileReader classFileReader(IType type) {
 		if (org.eclipse.jdt.internal.compiler.util.Util.archiveFormat(rootPath) == org.eclipse.jdt.internal.compiler.util.Util.JIMAGE_FILE) {
 			String classFileName = classFile.getElementName();
 			String path = Util.concatWith(pkg.names, classFileName, '/');
-			return ClassFileReader.readFromJimage(rootPath, path);
+			return ClassFileReader.readFromJimage(new File(rootPath), rootPath, path);
 		} else {
 			ZipFile zipFile = null;
 			try {
commit 34f77b81d2ca13f7239cc4e93d13f95d804f08f3
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Sep 22 22:05:33 2015 +0530

    Bug 473901 - Fix bug in opening non Java resources from Jimage

4	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
index afd5fcd..a56a0bf 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarEntryFile.java
@@ -52,12 +52,10 @@ public class JarEntryFile  extends JarEntryResource {
 		IPackageFragmentRoot root = getPackageFragmentRoot();
 		if (root.isModule()) {
 			try {
-				if (this.parent instanceof JarPackageFragmentRoot) {
-					IPath rootPath = ((JarPackageFragmentRoot) this.parent).getPath();
-					Object target = JavaModel.getTarget(rootPath, false);
-					if (target != null && target instanceof File) {
-						return JimageUtil.getContentFromJimage((File) target, getEntryName(), root.getElementName());
-					}
+				IPath rootPath = root.getPath();
+				Object target = JavaModel.getTarget(rootPath, false);
+				if (target != null && target instanceof File) {
+					return JimageUtil.getContentFromJimage((File) target, getEntryName(), root.getElementName());
 				}
 			} catch (IOException e) {
 				throw new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);
