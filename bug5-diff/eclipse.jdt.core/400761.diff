commit 42a66623ce2a3ec71a2f28506ffd67d2c8d2cf8c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Feb 18 22:04:48 2013 +0100

    Bug 400761 - [compiler][null] null may be return as boolean without a
    diagnostic

10	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
23	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
191	50	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
39	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index ca9139e..88fbfed 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2012 IBM Corporation and others.
+ * Copyright (c) 2006, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,6 +19,7 @@
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -754,10 +755,12 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullSourceString", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NumericValueOutOfRange", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ObjectCannotBeGeneric", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ObjectCannotHaveSuperTypes", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -798,7 +801,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullExpressionReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
@@ -1472,10 +1477,12 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleMethod", SKIP);
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
+		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullSourceString", SKIP);
+		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NumericValueOutOfRange", SKIP);
 		expectedProblemAttributes.put("ObjectCannotBeGeneric", SKIP);
 		expectedProblemAttributes.put("ObjectCannotHaveSuperTypes", SKIP);
@@ -1515,7 +1522,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PotentialHeapPollutionFromVararg", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
+		expectedProblemAttributes.put("PotentialNullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
+		expectedProblemAttributes.put("PotentialNullUnboxing", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", SKIP);
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index fa5df8b..77908b2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -53,7 +53,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "test_nullable_field_10e" };
+//		TESTS_NAMES = new String[] { "test_conditional_expression" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -6105,4 +6105,26 @@ public void testBug382069_k() {
 			"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
 			"----------\n");
 }
+//https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test_conditional_expression_1() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	boolean badFunction5(int i) {\n" + 
+			"		// expected a potential null problem:\n" + 
+			"		return i > 0 ? true : getBoolean();\n" + 
+			"	}\n" +
+			"	private @Nullable Boolean getBoolean() {\n" + 
+			"		return null;\n" + 
+			"	}\n" +
+			"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return i > 0 ? true : getBoolean();\n" + 
+		"	                      ^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 20f8574..5346099 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -29,6 +29,7 @@
  *							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *							bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -57,9 +58,9 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "testBug345305_14" };
+//		TESTS_NAMES = new String[] { "test0037_conditional_expression" };
 //		TESTS_NAMES = new String[] { "test0515_try_finally" };
-//		TESTS_NAMES = new String[] { "testBug376263" };
+//		TESTS_NAMES = new String[] { "testBug319201c" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -888,6 +889,141 @@ public void test0036_conditional_expression() {
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
 
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_1() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction(int i) {\n" + 
+			"		return i > 0 ? true : null;\n" + 
+			"	}\n" +
+			"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return i > 0 ? true : null;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS, JavaCore.ENABLED);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	int badFunction(int i) {\n" +
+			"		return i > 0 ? null : Integer.MIN_VALUE;\n" +
+			"	}\n" +
+			"	@SuppressWarnings(\"null\")\n" +
+			"	int silent(int i) {\n" +
+			"		return i > 0 ? null : Integer.MIN_VALUE;\n" +
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return i > 0 ? null : Integer.MIN_VALUE;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+//https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_3() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction3(int i) {\n" + 
+			"		//expected a potential null problem:\n" + 
+			"		return i > 0 ? true : (Boolean) null;\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	return i > 0 ? true : (Boolean) null;\n" + 
+		"	                      ^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+// if-then-else instead of conditional expression
+public void test0037_conditional_expression_4() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	options.put(JavaCore.COMPILER_PB_UNNECESSARY_ELSE, JavaCore.IGNORE);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction4(int i) {\n" + 
+			"	if (i > 0)\n" + 
+			"		return true;\n" + 
+			"	else\n" + 
+			"		// expected a null problem:\n" + 
+			"		return (Boolean) null;\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	return (Boolean) null;\n" + 
+		"	       ^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+// pot-null cond-expr in receiver position
+public void test0037_conditional_expression_5() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	String badFunction3(int i) {\n" + 
+			"		return (i > 0 ? this : null).toString();\n" + 
+			"	}\n" +
+			"	String badFunction4(int i) {\n" +
+			"		Object o = null;\n" + 
+			"		return (i > 0 ? o : null).toString();\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return (i > 0 ? this : null).toString();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression may be null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	return (i > 0 ? o : null).toString();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression can only be null\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
@@ -904,7 +1040,7 @@ public void test0040_autoboxing_compound_assignment() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	i += 1;\n" +
 			"	^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -927,7 +1063,7 @@ public void test0041_autoboxing_increment_operator() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	i++;\n" +
 			"	^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -976,7 +1112,7 @@ public void test0043_autoboxing_literal() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	System.out.println(i + 4);\n" +
 			"	                   ^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -11624,12 +11760,12 @@ public void testBug253896a() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 7)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 9)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11670,12 +11806,12 @@ public void testBug253896b() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	if(i1 == 1)\n" +
 			"	   ^^\n" +
-			"Null pointer access: The variable i1 can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" +
 			"2. ERROR in X.java (at line 7)\n" +
 			"	if(i1 == 0) {}\n" +
 			"	   ^^\n" +
-			"Potential null pointer access: The variable i1 may be null at this location\n" +
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" +
 			"----------\n");
 	}
 }
@@ -11713,12 +11849,12 @@ public void testBug253896c() {
 			"1. ERROR in X.java (at line 7)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 10)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 12)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11738,12 +11874,12 @@ public void testBug253896c() {
 			"6. ERROR in X.java (at line 17)\n" + 
 			"	if(a == 1) {}\n" + 
 			"	   ^\n" + 
-			"Null pointer access: The variable a can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"7. ERROR in X.java (at line 18)\n" + 
 			"	if(outer2 == 1) {}\n" + 
 			"	   ^^^^^^\n" + 
-			"Potential null pointer access: The variable outer2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
 			"----------\n");
 	}
 }
@@ -11781,12 +11917,12 @@ public void testBug253896d() {
 			"1. ERROR in X.java (at line 8)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 11)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 13)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11806,12 +11942,12 @@ public void testBug253896d() {
 			"6. ERROR in X.java (at line 18)\n" + 
 			"	if(outer == 1) {}\n" + 
 			"	   ^^^^^\n" + 
-			"Null pointer access: The variable outer can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"7. ERROR in X.java (at line 19)\n" + 
 			"	if(param == 1) {}\n" + 
 			"	   ^^^^^\n" + 
-			"Potential null pointer access: The variable param may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" +
 			"----------\n");
 	}
 }
@@ -12164,7 +12300,7 @@ public void testBug319201() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	int j = i;\n" + 
 			"	        ^\n" + 
-			"Null pointer access: The variable i can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12188,7 +12324,7 @@ public void testBug319201a() {
 			"1. ERROR in X.java (at line 5)\n" + 
 			"	j = i;\n" + 
 			"	    ^\n" + 
-			"Potential null pointer access: The variable i may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12212,7 +12348,7 @@ public void testBug319201b() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	bar(bo);\n" + 
 			"	    ^^\n" + 
-			"Null pointer access: The variable bo can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12285,72 +12421,77 @@ public void testBug319201c() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	super(b2 == null, b2);\n" + 
 			"	                  ^^\n" + 
-			"Potential null pointer access: The variable b2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 9)\n" + 
+			"	boolean fB = (Boolean)null;\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 12)\n" + 
+			"3. ERROR in X.java (at line 12)\n" + 
 			"	X x = new X(b1, null);\n" + 
 			"	            ^^\n" + 
-			"Null pointer access: The variable b1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"3. ERROR in X.java (at line 14)\n" + 
+			"4. ERROR in X.java (at line 14)\n" + 
 			"	boolean dontcare = b2 && inB;\n" + 
 			"	                   ^^\n" + 
-			"Null pointer access: The variable b2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"4. ERROR in X.java (at line 16)\n" + 
+			"5. ERROR in X.java (at line 16)\n" + 
 			"	dontcare = inB || b3;\n" + 
 			"	                  ^^\n" + 
-			"Null pointer access: The variable b3 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"5. ERROR in X.java (at line 18)\n" + 
+			"6. ERROR in X.java (at line 18)\n" + 
 			"	char[] cs = new char[dims];\n" + 
 			"	                     ^^^^\n" + 
-			"Null pointer access: The variable dims can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"6. ERROR in X.java (at line 22)\n" + 
+			"7. ERROR in X.java (at line 22)\n" + 
 			"	for (int i=0;b4; i++);\n" + 
 			"	             ^^\n" + 
-			"Null pointer access: The variable b4 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"7. ERROR in X.java (at line 23)\n" + 
+			"8. ERROR in X.java (at line 23)\n" + 
 			"	} while (b5);\n" + 
 			"	         ^^\n" + 
-			"Null pointer access: The variable b5 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"8. ERROR in X.java (at line 25)\n" + 
+			"9. ERROR in X.java (at line 25)\n" + 
 			"	if (b6) { }\n" + 
 			"	    ^^\n" + 
-			"Null pointer access: The variable b6 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"9. ERROR in X.java (at line 27)\n" + 
+			"10. ERROR in X.java (at line 27)\n" + 
 			"	Z z = this.new Z(b7);\n" + 
 			"	                 ^^\n" + 
-			"Null pointer access: The variable b7 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"10. ERROR in X.java (at line 29)\n" + 
+			"11. ERROR in X.java (at line 29)\n" + 
 			"	switch(sel) {\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable sel can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"11. ERROR in X.java (at line 34)\n" + 
+			"12. ERROR in X.java (at line 34)\n" + 
 			"	while (b8) {}\n" + 
 			"	       ^^\n" + 
-			"Null pointer access: The variable b8 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"12. ERROR in X.java (at line 36)\n" + 
+			"13. ERROR in X.java (at line 36)\n" + 
 			"	dontcare = (boolean)b9;\n" + 
 			"	                    ^^\n" + 
-			"Null pointer access: The variable b9 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"13. ERROR in X.java (at line 38)\n" + 
+			"14. ERROR in X.java (at line 38)\n" + 
 			"	assert b10 : \"shouldn\'t happen, but will\";\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable b10 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"14. ERROR in X.java (at line 40)\n" + 
+			"15. ERROR in X.java (at line 40)\n" + 
 			"	return b11;\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable b11 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12413,17 +12554,17 @@ public void testBug319201d() {
 			"1. ERROR in X.java (at line 12)\n" + 
 			"	} while (b2);\n" + 
 			"	         ^^\n" + 
-			"Potential null pointer access: The variable b2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 15)\n" + 
 			"	} while (b3);\n" + 
 			"	         ^^\n" + 
-			"Null pointer access: The variable b3 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 42)\n" + 
 			"	} while (b7);\n" + 
 			"	         ^^\n" + 
-			"Potential null pointer access: The variable b7 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
 			"----------\n",
 			null/*classLibraries*/,
 			true/*shouldFlushOutputDirectory*/,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index a9da5db..2884f7e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -160,6 +160,10 @@
  *									ConflictingNullAnnotations
  *									ConflictingInheritedNullAnnotations
  *									UnsafeElementTypeConversion
+ *									PotentialNullUnboxing
+ *									NullUnboxing
+ *									NullExpressionReference
+ *									PotentialNullExpressionReference
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -900,6 +904,10 @@ void setSourceStart(int sourceStart);
 	int RedundantNullCheckOnNonNullLocalVariable = Internal + 457;
 	/** @since 3.3 */
 	int NonNullLocalVariableComparisonYieldsFalse = Internal + 458;
+	/** @since 3.9 */
+	int PotentialNullUnboxing = Internal + 459;
+	/** @since 3.9 */
+	int NullUnboxing = Internal + 461;
 
 	// block
 	/** @since 3.0 */
@@ -1319,6 +1327,10 @@ void setSourceStart(int sourceStart);
 	int NonNullExpressionComparisonYieldsFalse = Internal + 670;
 	/** @since 3.9 */
 	int RedundantNullCheckOnNonNullExpression = Internal + 671;
+	/** @since 3.9 */
+	int NullExpressionReference = Internal + 672;
+	/** @since 3.9 */
+	int PotentialNullExpressionReference = Internal + 673;
 
 	/**
 	 * Corrupted binaries
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index 5b12d51..b8be769 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -14,6 +14,7 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 401017 - [compiler][null] casted reference to @Nullable field lacks a warning
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -57,9 +58,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	FlowInfo result = this.expression
 		.analyseCode(currentScope, flowContext, flowInfo)
 		.unconditionalInits();
-	if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.expression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	// account for pot. CCE:
 	flowContext.recordAbruptExit();
 	return result;
@@ -248,6 +247,7 @@ public static void checkNeedForArgumentCasts(BlockScope scope, int operator, int
 }
 
 public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	checkNPEbyUnboxing(scope, flowContext, flowInfo);
 	return this.expression.checkNPE(scope, flowContext, flowInfo);
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 8a58a10..05a237e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -75,6 +76,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		}
 		this.trueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);
 		trueFlowInfo = this.valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);
+		this.valueIfTrue.checkNPEbyUnboxing(currentScope, flowContext, trueFlowInfo);
 
 		// may need to fetch this null status before expireNullCheckedFieldInfo():
 		int preComputedTrueNullStatus = -1;
@@ -96,6 +98,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		}
 		this.falseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseFlowInfo);
 		falseFlowInfo = this.valueIfFalse.analyseCode(currentScope, flowContext, falseFlowInfo);
+		this.valueIfFalse.checkNPEbyUnboxing(currentScope, flowContext, falseFlowInfo);
 
 		flowContext.conditionalLevel--;
 		
@@ -166,6 +169,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return mergedInfo;
 	}
 
+	public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+		if ((this.nullStatus & FlowInfo.NULL) != 0)
+			scope.problemReporter().expressionNullReference(this);
+		else if ((this.nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+			scope.problemReporter().expressionPotentialNullReference(this);
+		return true; // all checking done
+	}
+
 	private void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {
 		// given that the condition cannot be optimized to a constant 
 		// we now merge the nullStatus from both branches:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 3d336da..37f3bd3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -12,6 +12,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -558,6 +559,17 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 	return false; // not checked
 }
 
+/** If this expression requires unboxing check if that operation can throw NPE. */
+protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if ((this.implicitConversion & UNBOXING) != 0) {
+		int status = nullStatus(flowInfo, flowContext);
+		if ((status & FlowInfo.NULL) != 0)
+			scope.problemReporter().nullUnboxing(this, this.resolvedType);
+		else if ((status & FlowInfo.POTENTIALLY_NULL) != 0)
+			scope.problemReporter().potentialNullUnboxing(this, this.resolvedType);
+	}
+}
+
 public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {
 	if (match == castType) {
 		if (!isNarrowing) tagAsUnnecessaryCast(scope, castType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index 0c7eec1..0223916 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -87,6 +88,7 @@ public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowCon
 				initializationScope.problemReporter().nullityMismatch(this.initialization, this.initialization.resolvedType, this.binding.type, nullStatus, annotationName);
 			}
 		}
+		this.initialization.checkNPEbyUnboxing(initializationScope, flowContext, flowInfo);
 	}
 	return flowInfo;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 942ee02..75d8a62 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -20,6 +20,7 @@
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *     Jesper S Moller - Contributions for
  *							Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -55,9 +56,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.initialization == null) {
 		return flowInfo;
 	}
-	if ((this.initialization.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.initialization.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.initialization.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	
 	FlowInfo preInitInfo = null;
 	boolean shouldAnalyseResource = this.binding != null 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 319ec57..c6f1d5d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -22,6 +22,7 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -52,9 +53,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	MethodScope methodScope = currentScope.methodScope();
 	if (this.expression != null) {
 		flowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);
-		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.expression.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		if (flowInfo.reachMode() == FlowInfo.REACHABLE)
 			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo, flowContext));
 		if (currentScope.compilerOptions().analyseResourceLeaks) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index b4a62a5..2fc4775 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -25,6 +25,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *								bug 376590 - Private fields with @Inject are ignored by unused field validation
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -306,10 +307,14 @@ public static int getIrritant(int problemID) {
 
 		case IProblem.NullLocalVariableReference:
 		case IProblem.NullableFieldReference:
+		case IProblem.NullExpressionReference:
+		case IProblem.NullUnboxing:
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
 		case IProblem.PotentialNullMessageSendReference:
+		case IProblem.PotentialNullExpressionReference:
+		case IProblem.PotentialNullUnboxing:
 			return CompilerOptions.PotentialNullReference;
 
 		case IProblem.RedundantLocalVariableNullAssignment:
@@ -5277,6 +5282,10 @@ public void localVariableNullInstanceof(LocalVariableBinding local, ASTNode loca
 }
 
 public void localVariableNullReference(LocalVariableBinding local, ASTNode location) {
+	if (location instanceof Expression && (((Expression)location).implicitConversion & TypeIds.UNBOXING) != 0) {
+		nullUnboxing(location, local.type);
+		return;
+	}
 	int severity = computeSeverity(IProblem.NullLocalVariableReference);
 	if (severity == ProblemSeverities.Ignore) return;
 	String[] arguments = new String[] {new String(local.name)  };
@@ -5290,6 +5299,10 @@ public void localVariableNullReference(LocalVariableBinding local, ASTNode locat
 }
 
 public void localVariablePotentialNullReference(LocalVariableBinding local, ASTNode location) {
+	if (location instanceof Expression && (((Expression)location).implicitConversion & TypeIds.UNBOXING) != 0) {
+		potentialNullUnboxing(location, local.type);
+		return;
+	}
 	int severity = computeSeverity(IProblem.PotentialNullLocalVariableReference);
 	if (severity == ProblemSeverities.Ignore) return;
 	String[] arguments = new String[] {new String(local.name)};
@@ -5301,7 +5314,16 @@ public void localVariablePotentialNullReference(LocalVariableBinding local, ASTN
 		nodeSourceStart(local, location),
 		nodeSourceEnd(local, location));
 }
-
+public void potentialNullUnboxing(ASTNode expression, TypeBinding boxType) {
+	String[] arguments = new String[] { String.valueOf(boxType.readableName()) };
+	String[] argumentsShort = new String[] { String.valueOf(boxType.shortReadableName()) };
+	this.handle(IProblem.PotentialNullUnboxing, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
+public void nullUnboxing(ASTNode expression, TypeBinding boxType) {
+	String[] arguments = new String[] { String.valueOf(boxType.readableName()) };
+	String[] argumentsShort = new String[] { String.valueOf(boxType.shortReadableName()) };
+	this.handle(IProblem.NullUnboxing, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
 public void nullableFieldDereference(VariableBinding variable, long position) {
 	String[] arguments = new String[] {new String(variable.name)};
 	char[][] nullableName = this.options.nullableAnnotationName;
@@ -8534,6 +8556,22 @@ public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode loc
 		location.sourceStart,
 		location.sourceEnd);
 }
+public void expressionNullReference(ASTNode location) {
+	this.handle(
+		IProblem.NullExpressionReference,
+		NoArgument,
+		NoArgument,
+		location.sourceStart,
+		location.sourceEnd);
+}
+public void expressionPotentialNullReference(ASTNode location) {
+	this.handle(
+		IProblem.PotentialNullExpressionReference,
+		NoArgument,
+		NoArgument,
+		location.sourceStart,
+		location.sourceEnd);
+}
 
 public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	int sourceStart = 0, sourceEnd = 0;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index d95f900..31ded9d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -21,6 +21,7 @@
 #							bug 393719 - [compiler] inconsistent warnings on iteration variables
 #							bug 331649 - [compiler][null] consider null annotations for fields
 #							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
+#							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -404,7 +405,8 @@
 456 = instanceof always yields false: The variable {0} can only be null at this location
 457 = Redundant null check: The variable {0} cannot be null at this location
 458 = Null comparison always yields false: The variable {0} cannot be null at this location
-
+459 = Potential null pointer access: This expression of type {0} may be null but requires auto-unboxing
+461 = Null pointer access: This expression of type {0} is null but requires auto-unboxing
 460 = Empty block should be documented
 
 ### DOC
@@ -598,6 +600,8 @@
 ### NULL ANALYSIS FOR OTHER EXPRESSIONS
 670 = Null comparison always yields false: this expression cannot be null
 671 = Redundant null check: this expression cannot be null
+672 = Null pointer access: This expression can only be null
+673 = Potential null pointer access: This expression may be null
 
 ### CORRUPTED BINARIES
 700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}
commit da7a5227e034c2b6c8a4762e61c3ccf43066f02e
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Apr 3 11:50:19 2013 +0530

    Bug 400761 - [compiler][null] null may be return as boolean without a
    diagnostic

9	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
22	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
191	50	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
15	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
39	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 62feff1..f782c4a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -29,6 +29,7 @@
  *								bug 402028 - [1.8][compiler] null analysis for reference expressions 
  *								bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -813,12 +814,14 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationUnchecked", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullSourceString", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NumericValueOutOfRange", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ObjectCannotBeGeneric", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ObjectCannotHaveSuperTypes", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -860,7 +863,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullExpressionReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
@@ -1593,10 +1598,12 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationUnchecked", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
+		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullSourceString", SKIP);
+		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NumericValueOutOfRange", SKIP);
 		expectedProblemAttributes.put("ObjectCannotBeGeneric", SKIP);
 		expectedProblemAttributes.put("ObjectCannotHaveSuperTypes", SKIP);
@@ -1637,7 +1644,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PotentialHeapPollutionFromVararg", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
+		expectedProblemAttributes.put("PotentialNullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
+		expectedProblemAttributes.put("PotentialNullUnboxing", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", SKIP);
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index e045881..a90c01d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -5978,4 +5978,26 @@ public void testBug382069_k() {
 			"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
 			"----------\n");
 }
+//https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test_conditional_expression_1() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	boolean badFunction5(int i) {\n" + 
+			"		// expected a potential null problem:\n" + 
+			"		return i > 0 ? true : getBoolean();\n" + 
+			"	}\n" +
+			"	private @Nullable Boolean getBoolean() {\n" + 
+			"		return null;\n" + 
+			"	}\n" +
+			"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return i > 0 ? true : getBoolean();\n" + 
+		"	                      ^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 20f8574..5346099 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -29,6 +29,7 @@
  *							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *							bug 401088 - [compiler][null] Wrong warning "Redundant null check" inside nested try statement
  *							bug 401092 - [compiler][null] Wrong warning "Redundant null check" in outer catch of nested try
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -57,9 +58,9 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "testBug345305_14" };
+//		TESTS_NAMES = new String[] { "test0037_conditional_expression" };
 //		TESTS_NAMES = new String[] { "test0515_try_finally" };
-//		TESTS_NAMES = new String[] { "testBug376263" };
+//		TESTS_NAMES = new String[] { "testBug319201c" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -888,6 +889,141 @@ public void test0036_conditional_expression() {
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
 
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_1() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction(int i) {\n" + 
+			"		return i > 0 ? true : null;\n" + 
+			"	}\n" +
+			"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return i > 0 ? true : null;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_2() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS, JavaCore.ENABLED);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	int badFunction(int i) {\n" +
+			"		return i > 0 ? null : Integer.MIN_VALUE;\n" +
+			"	}\n" +
+			"	@SuppressWarnings(\"null\")\n" +
+			"	int silent(int i) {\n" +
+			"		return i > 0 ? null : Integer.MIN_VALUE;\n" +
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return i > 0 ? null : Integer.MIN_VALUE;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+//https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+public void test0037_conditional_expression_3() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction3(int i) {\n" + 
+			"		//expected a potential null problem:\n" + 
+			"		return i > 0 ? true : (Boolean) null;\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	return i > 0 ? true : (Boolean) null;\n" + 
+		"	                      ^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+// if-then-else instead of conditional expression
+public void test0037_conditional_expression_4() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // needs autoboxing
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	options.put(JavaCore.COMPILER_PB_UNNECESSARY_ELSE, JavaCore.IGNORE);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	boolean badFunction4(int i) {\n" + 
+			"	if (i > 0)\n" + 
+			"		return true;\n" + 
+			"	else\n" + 
+			"		// expected a null problem:\n" + 
+			"		return (Boolean) null;\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	return (Boolean) null;\n" + 
+		"	       ^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// https://bugs.eclipse.org/400761: [compiler][null] null may be return as boolean without a diagnostic
+// pot-null cond-expr in receiver position
+public void test0037_conditional_expression_5() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	runNegativeTest(
+		true,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	String badFunction3(int i) {\n" + 
+			"		return (i > 0 ? this : null).toString();\n" + 
+			"	}\n" +
+			"	String badFunction4(int i) {\n" +
+			"		Object o = null;\n" + 
+			"		return (i > 0 ? o : null).toString();\n" + 
+			"	}\n" +
+			"}\n"},
+		null,
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return (i > 0 ? this : null).toString();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null pointer access: This expression may be null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	return (i > 0 ? o : null).toString();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^\n" + 
+		"Null pointer access: This expression can only be null\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 // null analysis -- autoboxing
 public void test0040_autoboxing_compound_assignment() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
@@ -904,7 +1040,7 @@ public void test0040_autoboxing_compound_assignment() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	i += 1;\n" +
 			"	^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -927,7 +1063,7 @@ public void test0041_autoboxing_increment_operator() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	i++;\n" +
 			"	^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -976,7 +1112,7 @@ public void test0043_autoboxing_literal() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	System.out.println(i + 4);\n" +
 			"	                   ^\n" +
-			"Null pointer access: The variable i can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -11624,12 +11760,12 @@ public void testBug253896a() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 7)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 9)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11670,12 +11806,12 @@ public void testBug253896b() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	if(i1 == 1)\n" +
 			"	   ^^\n" +
-			"Null pointer access: The variable i1 can only be null at this location\n" +
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" +
 			"2. ERROR in X.java (at line 7)\n" +
 			"	if(i1 == 0) {}\n" +
 			"	   ^^\n" +
-			"Potential null pointer access: The variable i1 may be null at this location\n" +
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" +
 			"----------\n");
 	}
 }
@@ -11713,12 +11849,12 @@ public void testBug253896c() {
 			"1. ERROR in X.java (at line 7)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 10)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 12)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11738,12 +11874,12 @@ public void testBug253896c() {
 			"6. ERROR in X.java (at line 17)\n" + 
 			"	if(a == 1) {}\n" + 
 			"	   ^\n" + 
-			"Null pointer access: The variable a can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"7. ERROR in X.java (at line 18)\n" + 
 			"	if(outer2 == 1) {}\n" + 
 			"	   ^^^^^^\n" + 
-			"Potential null pointer access: The variable outer2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
 			"----------\n");
 	}
 }
@@ -11781,12 +11917,12 @@ public void testBug253896d() {
 			"1. ERROR in X.java (at line 8)\n" + 
 			"	if(f1 == 1)\n" + 
 			"	   ^^\n" + 
-			"Null pointer access: The variable f1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"2. ERROR in X.java (at line 11)\n" + 
 			"	int abc = (f2 != 1)? 1 : 0;\n" + 
 			"	           ^^\n" + 
-			"Null pointer access: The variable f2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"3. ERROR in X.java (at line 13)\n" + 
 			"	if(f3 == null)\n" + 
@@ -11806,12 +11942,12 @@ public void testBug253896d() {
 			"6. ERROR in X.java (at line 18)\n" + 
 			"	if(outer == 1) {}\n" + 
 			"	   ^^^^^\n" + 
-			"Null pointer access: The variable outer can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" +
 			"----------\n" + 
 			"7. ERROR in X.java (at line 19)\n" + 
 			"	if(param == 1) {}\n" + 
 			"	   ^^^^^\n" + 
-			"Potential null pointer access: The variable param may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" +
 			"----------\n");
 	}
 }
@@ -12164,7 +12300,7 @@ public void testBug319201() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	int j = i;\n" + 
 			"	        ^\n" + 
-			"Null pointer access: The variable i can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12188,7 +12324,7 @@ public void testBug319201a() {
 			"1. ERROR in X.java (at line 5)\n" + 
 			"	j = i;\n" + 
 			"	    ^\n" + 
-			"Potential null pointer access: The variable i may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Integer may be null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12212,7 +12348,7 @@ public void testBug319201b() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	bar(bo);\n" + 
 			"	    ^^\n" + 
-			"Null pointer access: The variable bo can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12285,72 +12421,77 @@ public void testBug319201c() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	super(b2 == null, b2);\n" + 
 			"	                  ^^\n" + 
-			"Potential null pointer access: The variable b2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 9)\n" + 
+			"	boolean fB = (Boolean)null;\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 12)\n" + 
+			"3. ERROR in X.java (at line 12)\n" + 
 			"	X x = new X(b1, null);\n" + 
 			"	            ^^\n" + 
-			"Null pointer access: The variable b1 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"3. ERROR in X.java (at line 14)\n" + 
+			"4. ERROR in X.java (at line 14)\n" + 
 			"	boolean dontcare = b2 && inB;\n" + 
 			"	                   ^^\n" + 
-			"Null pointer access: The variable b2 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"4. ERROR in X.java (at line 16)\n" + 
+			"5. ERROR in X.java (at line 16)\n" + 
 			"	dontcare = inB || b3;\n" + 
 			"	                  ^^\n" + 
-			"Null pointer access: The variable b3 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"5. ERROR in X.java (at line 18)\n" + 
+			"6. ERROR in X.java (at line 18)\n" + 
 			"	char[] cs = new char[dims];\n" + 
 			"	                     ^^^^\n" + 
-			"Null pointer access: The variable dims can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"6. ERROR in X.java (at line 22)\n" + 
+			"7. ERROR in X.java (at line 22)\n" + 
 			"	for (int i=0;b4; i++);\n" + 
 			"	             ^^\n" + 
-			"Null pointer access: The variable b4 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"7. ERROR in X.java (at line 23)\n" + 
+			"8. ERROR in X.java (at line 23)\n" + 
 			"	} while (b5);\n" + 
 			"	         ^^\n" + 
-			"Null pointer access: The variable b5 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"8. ERROR in X.java (at line 25)\n" + 
+			"9. ERROR in X.java (at line 25)\n" + 
 			"	if (b6) { }\n" + 
 			"	    ^^\n" + 
-			"Null pointer access: The variable b6 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"9. ERROR in X.java (at line 27)\n" + 
+			"10. ERROR in X.java (at line 27)\n" + 
 			"	Z z = this.new Z(b7);\n" + 
 			"	                 ^^\n" + 
-			"Null pointer access: The variable b7 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"10. ERROR in X.java (at line 29)\n" + 
+			"11. ERROR in X.java (at line 29)\n" + 
 			"	switch(sel) {\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable sel can only be null at this location\n" + 
+			"Null pointer access: This expression of type Integer is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"11. ERROR in X.java (at line 34)\n" + 
+			"12. ERROR in X.java (at line 34)\n" + 
 			"	while (b8) {}\n" + 
 			"	       ^^\n" + 
-			"Null pointer access: The variable b8 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"12. ERROR in X.java (at line 36)\n" + 
+			"13. ERROR in X.java (at line 36)\n" + 
 			"	dontcare = (boolean)b9;\n" + 
 			"	                    ^^\n" + 
-			"Null pointer access: The variable b9 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"13. ERROR in X.java (at line 38)\n" + 
+			"14. ERROR in X.java (at line 38)\n" + 
 			"	assert b10 : \"shouldn\'t happen, but will\";\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable b10 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
-			"14. ERROR in X.java (at line 40)\n" + 
+			"15. ERROR in X.java (at line 40)\n" + 
 			"	return b11;\n" + 
 			"	       ^^^\n" + 
-			"Null pointer access: The variable b11 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -12413,17 +12554,17 @@ public void testBug319201d() {
 			"1. ERROR in X.java (at line 12)\n" + 
 			"	} while (b2);\n" + 
 			"	         ^^\n" + 
-			"Potential null pointer access: The variable b2 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 15)\n" + 
 			"	} while (b3);\n" + 
 			"	         ^^\n" + 
-			"Null pointer access: The variable b3 can only be null at this location\n" + 
+			"Null pointer access: This expression of type Boolean is null but requires auto-unboxing\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 42)\n" + 
 			"	} while (b7);\n" + 
 			"	         ^^\n" + 
-			"Potential null pointer access: The variable b7 may be null at this location\n" + 
+			"Potential null pointer access: This expression of type Boolean may be null but requires auto-unboxing\n" + 
 			"----------\n",
 			null/*classLibraries*/,
 			true/*shouldFlushOutputDirectory*/,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 02ecd71..6fac35d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -177,6 +177,13 @@
  *									DuplicateInheritedDefaultMethods
  *									SuperAccessCannotBypassDirectSuper
  *									SuperCallCannotBypassOverride
+ *									ConflictingNullAnnotations
+ *									ConflictingInheritedNullAnnotations
+ *									UnsafeElementTypeConversion
+ *									PotentialNullUnboxing
+ *									NullUnboxing
+ *									NullExpressionReference
+ *									PotentialNullExpressionReference
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -942,6 +949,10 @@ void setSourceStart(int sourceStart);
 	int RedundantNullCheckOnNonNullLocalVariable = Internal + 457;
 	/** @since 3.3 */
 	int NonNullLocalVariableComparisonYieldsFalse = Internal + 458;
+	/** @since 3.9 */
+	int PotentialNullUnboxing = Internal + 459;
+	/** @since 3.9 */
+	int NullUnboxing = Internal + 461;
 
 	// block
 	/** @since 3.0 */
@@ -1413,6 +1424,10 @@ void setSourceStart(int sourceStart);
 	int NonNullExpressionComparisonYieldsFalse = Internal + 670;
 	/** @since 3.9 */
 	int RedundantNullCheckOnNonNullExpression = Internal + 671;
+	/** @since 3.9 */
+	int NullExpressionReference = Internal + 672;
+	/** @since 3.9 */
+	int PotentialNullExpressionReference = Internal + 673;
 
 	/**
 	 * Corrupted binaries
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index 8f9b0e0..3ee6000 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -18,6 +18,7 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 401017 - [compiler][null] casted reference to @Nullable field lacks a warning
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -62,9 +63,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	FlowInfo result = this.expression
 		.analyseCode(currentScope, flowContext, flowInfo)
 		.unconditionalInits();
-	if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.expression.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	// account for pot. CCE:
 	flowContext.recordAbruptExit();
 	return result;
@@ -253,6 +252,7 @@ public static void checkNeedForArgumentCasts(BlockScope scope, int operator, int
 }
 
 public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	checkNPEbyUnboxing(scope, flowContext, flowInfo);
 	return this.expression.checkNPE(scope, flowContext, flowInfo);
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 224ae40..c892b9d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -19,6 +19,7 @@
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -84,6 +85,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		}
 		this.trueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);
 		trueFlowInfo = this.valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);
+		this.valueIfTrue.checkNPEbyUnboxing(currentScope, flowContext, trueFlowInfo);
 
 		// may need to fetch this null status before expireNullCheckedFieldInfo():
 		int preComputedTrueNullStatus = -1;
@@ -105,6 +107,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		}
 		this.falseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseFlowInfo);
 		falseFlowInfo = this.valueIfFalse.analyseCode(currentScope, flowContext, falseFlowInfo);
+		this.valueIfFalse.checkNPEbyUnboxing(currentScope, flowContext, falseFlowInfo);
 
 		flowContext.conditionalLevel--;
 		
@@ -175,6 +178,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return mergedInfo;
 	}
 
+	public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+		if ((this.nullStatus & FlowInfo.NULL) != 0)
+			scope.problemReporter().expressionNullReference(this);
+		else if ((this.nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+			scope.problemReporter().expressionPotentialNullReference(this);
+		return true; // all checking done
+	}
+
 	private void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {
 		// given that the condition cannot be optimized to a constant 
 		// we now merge the nullStatus from both branches:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index c875856..3fe5c71 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -17,6 +17,7 @@
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -588,6 +589,17 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 	return false; // not checked
 }
 
+/** If this expression requires unboxing check if that operation can throw NPE. */
+protected void checkNPEbyUnboxing(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if ((this.implicitConversion & UNBOXING) != 0) {
+		int status = nullStatus(flowInfo, flowContext);
+		if ((status & FlowInfo.NULL) != 0)
+			scope.problemReporter().nullUnboxing(this, this.resolvedType);
+		else if ((status & FlowInfo.POTENTIALLY_NULL) != 0)
+			scope.problemReporter().potentialNullUnboxing(this, this.resolvedType);
+	}
+}
+
 public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {
 	if (match == castType) {
 		if (!isNarrowing) tagAsUnnecessaryCast(scope, castType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index 037504e..b82f850 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -94,6 +95,7 @@ public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowCon
 				initializationScope.problemReporter().nullityMismatch(this.initialization, this.initialization.resolvedType, this.binding.type, nullStatus, annotationName);
 			}
 		}
+		this.initialization.checkNPEbyUnboxing(initializationScope, flowContext, flowInfo);
 	}
 	return flowInfo;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 0393635..4da91f5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -24,6 +24,7 @@
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *     Jesper S Moller - Contributions for
  *							Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -62,9 +63,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.initialization == null) {
 		return flowInfo;
 	}
-	if ((this.initialization.implicitConversion & TypeIds.UNBOXING) != 0) {
-		this.initialization.checkNPE(currentScope, flowContext, flowInfo);
-	}
+	this.initialization.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 	
 	FlowInfo preInitInfo = null;
 	boolean shouldAnalyseResource = this.binding != null 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index eeb67e6..8145e39 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -26,6 +26,7 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods. 
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
@@ -65,9 +66,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	MethodScope methodScope = currentScope.methodScope();
 	if (this.expression != null) {
 		flowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);
-		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
-			this.expression.checkNPE(currentScope, flowContext, flowInfo);
-		}
+		this.expression.checkNPEbyUnboxing(currentScope, flowContext, flowInfo);
 		if (flowInfo.reachMode() == FlowInfo.REACHABLE)
 			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo, flowContext));
 		if (currentScope.compilerOptions().analyseResourceLeaks) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index fb8ccc3..f0a703b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -33,6 +33,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *								bug 376590 - Private fields with @Inject are ignored by unused field validation
+ *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 402028 - [1.8][compiler] null analysis for reference expressions 
  *								bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
@@ -326,12 +327,16 @@ public static int getIrritant(int problemID) {
 
 		case IProblem.NullLocalVariableReference:
 		case IProblem.NullableFieldReference:
+		case IProblem.NullExpressionReference:
+		case IProblem.NullUnboxing:
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
 		case IProblem.PotentialNullMessageSendReference:
 		case IProblem.ArrayReferencePotentialNullReference:
 		case IProblem.DereferencingNullableExpression:
+		case IProblem.PotentialNullExpressionReference:
+		case IProblem.PotentialNullUnboxing:
 			return CompilerOptions.PotentialNullReference;
 
 		case IProblem.RedundantLocalVariableNullAssignment:
@@ -5573,6 +5578,10 @@ public void localVariableNullInstanceof(LocalVariableBinding local, ASTNode loca
 }
 
 public void localVariableNullReference(LocalVariableBinding local, ASTNode location) {
+	if (location instanceof Expression && (((Expression)location).implicitConversion & TypeIds.UNBOXING) != 0) {
+		nullUnboxing(location, local.type);
+		return;
+	}
 	int severity = computeSeverity(IProblem.NullLocalVariableReference);
 	if (severity == ProblemSeverities.Ignore) return;
 	String[] arguments = new String[] {new String(local.name)  };
@@ -5586,6 +5595,10 @@ public void localVariableNullReference(LocalVariableBinding local, ASTNode locat
 }
 
 public void localVariablePotentialNullReference(LocalVariableBinding local, ASTNode location) {
+	if (location instanceof Expression && (((Expression)location).implicitConversion & TypeIds.UNBOXING) != 0) {
+		potentialNullUnboxing(location, local.type);
+		return;
+	}
 	int severity = computeSeverity(IProblem.PotentialNullLocalVariableReference);
 	if (severity == ProblemSeverities.Ignore) return;
 	String[] arguments = new String[] {new String(local.name)};
@@ -5597,7 +5610,16 @@ public void localVariablePotentialNullReference(LocalVariableBinding local, ASTN
 		nodeSourceStart(local, location),
 		nodeSourceEnd(local, location));
 }
-
+public void potentialNullUnboxing(ASTNode expression, TypeBinding boxType) {
+	String[] arguments = new String[] { String.valueOf(boxType.readableName()) };
+	String[] argumentsShort = new String[] { String.valueOf(boxType.shortReadableName()) };
+	this.handle(IProblem.PotentialNullUnboxing, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
+public void nullUnboxing(ASTNode expression, TypeBinding boxType) {
+	String[] arguments = new String[] { String.valueOf(boxType.readableName()) };
+	String[] argumentsShort = new String[] { String.valueOf(boxType.shortReadableName()) };
+	this.handle(IProblem.NullUnboxing, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
 public void nullableFieldDereference(VariableBinding variable, long position) {
 	String[] arguments = new String[] {new String(variable.name)};
 	char[][] nullableName = this.options.nullableAnnotationName;
@@ -8953,6 +8975,22 @@ public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode loc
 		location.sourceStart,
 		location.sourceEnd);
 }
+public void expressionNullReference(ASTNode location) {
+	this.handle(
+		IProblem.NullExpressionReference,
+		NoArgument,
+		NoArgument,
+		location.sourceStart,
+		location.sourceEnd);
+}
+public void expressionPotentialNullReference(ASTNode location) {
+	this.handle(
+		IProblem.PotentialNullExpressionReference,
+		NoArgument,
+		NoArgument,
+		location.sourceStart,
+		location.sourceEnd);
+}
 
 public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	int sourceStart = 0, sourceEnd = 0;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 8274a0f..88c5c2a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -28,6 +28,7 @@
 #							bug 393719 - [compiler] inconsistent warnings on iteration variables
 #							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
 #							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
+#							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
 #							bug 402028 - [1.8][compiler] null analysis for reference expressions
 #							bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
 #							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
@@ -426,7 +427,8 @@
 456 = instanceof always yields false: The variable {0} can only be null at this location
 457 = Redundant null check: The variable {0} cannot be null at this location
 458 = Null comparison always yields false: The variable {0} cannot be null at this location
-
+459 = Potential null pointer access: This expression of type {0} may be null but requires auto-unboxing
+461 = Null pointer access: This expression of type {0} is null but requires auto-unboxing
 460 = Empty block should be documented
 
 ### DOC
@@ -645,6 +647,8 @@
 ### NULL ANALYSIS FOR OTHER EXPRESSIONS
 670 = Null comparison always yields false: this expression cannot be null
 671 = Redundant null check: this expression cannot be null
+672 = Null pointer access: This expression can only be null
+673 = Potential null pointer access: This expression may be null
 
 ### CORRUPTED BINARIES
 700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}
