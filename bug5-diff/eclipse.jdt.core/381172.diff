commit 46bdd6036153580a7889ceb7993a8f8a6300be85
Author: Ayushman Jain <ajain>
Date:   Thu Jul 5 14:41:47 2012 +0530

    Fixed bug 381172: VerifyError "Inconsistent stackmap frames" for switch
    nested within try-catch

3	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
11	11	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
6	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
12	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
121	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
17	20	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
32	44	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
7	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
7	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
0	40	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
index 0b0e640..2f45746 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
@@ -127,8 +127,7 @@ public void test005() throws Exception {
 		"    4  putstatic X.X : java.lang.Object[] [9]\n" +
 		"    7  return\n" +
 		"      Line numbers:\n" +
-		"        [pc: 0, line: 2]\n" +
-		"        [pc: 7, line: 1]\n";
+		"        [pc: 0, line: 2]\n";
 
 	int index = actualOutput.indexOf(expectedOutput);
 	if (index == -1 || expectedOutput.length() == 0) {
@@ -284,12 +283,12 @@ public void test011() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 4]\n" +
 			"        [pc: 5, line: 5]\n" +
-			"        [pc: 15, line: 6]\n" +
+			"        [pc: 12, line: 6]\n" +
 			"        [pc: 16, line: 7]\n" +
 			"        [pc: 24, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 25] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 5, pc: 15] local: all index: 1 type: java.lang.Object[][]\n" +
+			"        [pc: 5, pc: 12] local: all index: 1 type: java.lang.Object[][]\n" +
 			"        [pc: 16, pc: 24] local: e index: 1 type: java.lang.ArrayStoreException\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
index 2d73cd3..e03d0a7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
@@ -1885,7 +1885,7 @@ public class ClassFileReaderTest_1_4 extends AbstractRegressionTest {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 6]\n" +
 			"        [pc: 9, line: 7]\n" +
-			"        [pc: 14, line: 8]\n" +
+			"        [pc: 11, line: 8]\n" +
 			"        [pc: 18, line: 10]\n" +
 			"        [pc: 20, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 621a0f2..9e8d033 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -35479,13 +35479,13 @@ public void test1058() throws Exception {
 		"        [pc: 0, line: 4]\n" +
 		"        [pc: 2, line: 5]\n" +
 		"        [pc: 5, line: 6]\n" +
-		"        [pc: 32, line: 7]\n" +
+		"        [pc: 29, line: 7]\n" +
 		"        [pc: 33, line: 8]\n" +
 		"        [pc: 41, line: 10]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 42] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 2, pc: 32] local: foo index: 1 type: int\n" +
-		"        [pc: 5, pc: 32] local: bar index: 2 type: java.lang.String\n" +
+		"        [pc: 2, pc: 29] local: foo index: 1 type: int\n" +
+		"        [pc: 5, pc: 29] local: bar index: 2 type: java.lang.String\n" +
 		"        [pc: 33, pc: 41] local: e index: 1 type: java.lang.NullPointerException\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -36018,16 +36018,16 @@ public void test1066() throws Exception {
 				"        [pc: 27, line: 8]\n" +
 				"        [pc: 30, line: 9]\n" +
 				"        [pc: 36, line: 11]\n" +
-				"        [pc: 79, line: 12]\n" +
+				"        [pc: 76, line: 12]\n" +
 				"        [pc: 81, line: 13]\n" +
 				"        [pc: 115, line: 16]\n" +
-				"        [pc: 158, line: 17]\n" +
+				"        [pc: 155, line: 17]\n" +
 				"        [pc: 160, line: 18]\n" +
 				"        [pc: 194, line: 21]\n" +
-				"        [pc: 240, line: 22]\n" +
+				"        [pc: 237, line: 22]\n" +
 				"        [pc: 242, line: 23]\n" +
 				"        [pc: 276, line: 26]\n" +
-				"        [pc: 322, line: 27]\n" +
+				"        [pc: 319, line: 27]\n" +
 				"        [pc: 324, line: 28]\n" +
 				"        [pc: 358, line: 30]\n" +
 				"      Local variable table:\n" +
@@ -36200,16 +36200,16 @@ public void test1066() throws Exception {
 				"        [pc: 27, line: 8]\n" +
 				"        [pc: 30, line: 9]\n" +
 				"        [pc: 36, line: 11]\n" +
-				"        [pc: 79, line: 12]\n" +
+				"        [pc: 76, line: 12]\n" +
 				"        [pc: 81, line: 13]\n" +
 				"        [pc: 115, line: 16]\n" +
-				"        [pc: 158, line: 17]\n" +
+				"        [pc: 155, line: 17]\n" +
 				"        [pc: 160, line: 18]\n" +
 				"        [pc: 194, line: 21]\n" +
-				"        [pc: 240, line: 22]\n" +
+				"        [pc: 237, line: 22]\n" +
 				"        [pc: 242, line: 23]\n" +
 				"        [pc: 276, line: 26]\n" +
-				"        [pc: 322, line: 27]\n" +
+				"        [pc: 319, line: 27]\n" +
 				"        [pc: 324, line: 28]\n" +
 				"        [pc: 358, line: 30]\n" +
 				"      Local variable table:\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
index 4355bd3..7afa765 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
@@ -105,12 +105,12 @@ public void test001() throws Exception {
 		"        [pc: 33, line: 15]\n" +
 		"        [pc: 36, line: 16]\n" +
 		"        [pc: 39, line: 17]\n" +
-		"        [pc: 46, line: 18]\n" +
+		"        [pc: 43, line: 18]\n" +
 		"        [pc: 47, line: 19]\n" +
 		"        [pc: 55, line: 21]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 56] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 23, pc: 46] local: x index: 1 type: X\n" +
+		"        [pc: 23, pc: 43] local: x index: 1 type: X\n" +
 		"        [pc: 47, pc: 55] local: e index: 1 type: java.lang.NullPointerException\n";
 	int index = actualOutput.indexOf(expectedOutput);
 	if (index == -1 || expectedOutput.length() == 0) {
@@ -196,7 +196,7 @@ public void test002() throws Exception {
 		"        [pc: 13, line: 23]\n" +
 		"        [pc: 16, line: 24]\n" +
 		"        [pc: 19, line: 25]\n" +
-		"        [pc: 26, line: 26]\n" +
+		"        [pc: 23, line: 26]\n" +
 		"        [pc: 27, line: 27]\n" +
 		"        [pc: 35, line: 29]\n" +
 		"      Local variable table:\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 4cb768e..c2e389f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -11877,9 +11877,11 @@ public void testBug303448a() throws Exception {
 				"        [pc: 4, line: 7]\n" + 
 				"        [pc: 26, line: 8]\n" + 
 				"        [pc: 30, line: 9]\n" + 
+				"        [pc: 38, line: 10]\n" + 
 				"        [pc: 41, line: 11]\n" + 
 				"        [pc: 49, line: 13]\n" + 
 				"        [pc: 53, line: 14]\n" + 
+				"        [pc: 61, line: 15]\n" + 
 				"        [pc: 64, line: 16]\n" + 
 				"        [pc: 72, line: 19]\n" + 
 				"      Local variable table:\n" + 
@@ -11929,9 +11931,11 @@ public void testBug303448a() throws Exception {
 						"        [pc: 4, line: 7]\n" + 
 						"        [pc: 26, line: 8]\n" + 
 						"        [pc: 30, line: 9]\n" + 
+						"        [pc: 38, line: 10]\n" + 
 						"        [pc: 41, line: 11]\n" + 
 						"        [pc: 49, line: 13]\n" + 
 						"        [pc: 53, line: 14]\n" + 
+						"        [pc: 61, line: 15]\n" + 
 						"        [pc: 64, line: 16]\n" + 
 						"        [pc: 72, line: 19]\n" + 
 						"      Local variable table:\n" + 
@@ -11980,9 +11984,11 @@ public void testBug303448a() throws Exception {
 						"        [pc: 4, line: 7]\n" + 
 						"        [pc: 26, line: 8]\n" + 
 						"        [pc: 30, line: 9]\n" + 
+						"        [pc: 38, line: 10]\n" + 
 						"        [pc: 41, line: 11]\n" + 
 						"        [pc: 49, line: 13]\n" + 
 						"        [pc: 53, line: 14]\n" + 
+						"        [pc: 61, line: 15]\n" + 
 						"        [pc: 64, line: 16]\n" + 
 						"        [pc: 72, line: 19]\n" + 
 						"      Local variable table:\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
index aa95982..35d56a5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
@@ -112,7 +112,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Line numbers:\n" +
 				"        [pc: 0, line: 4]\n" +
 				"        [pc: 21, line: 6]\n" +
-				"        [pc: 32, line: 7]\n" +
+				"        [pc: 29, line: 7]\n" +
 				"        [pc: 33, line: 8]\n" +
 				"        [pc: 37, line: 10]\n" +
 				"      Local variable table:\n" +
@@ -293,7 +293,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 23, line: 11]\n" +
 				"        [pc: 26, line: 13]\n" +
 				"        [pc: 32, line: 15]\n" +
-				"        [pc: 40, line: 16]\n" +
+				"        [pc: 37, line: 16]\n" +
 				"        [pc: 42, line: 17]\n" +
 				"        [pc: 46, line: 19]\n" +
 				"        [pc: 51, line: 18]\n" +
@@ -310,7 +310,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 2, pc: 40] local: i index: 3 type: double\n" +
 				"        [pc: 46, pc: 51] local: i index: 3 type: double\n" +
 				"        [pc: 55, pc: 81] local: i index: 3 type: double\n" +
-				"        [pc: 12, pc: 40] local: j index: 5 type: int\n" +
+				"        [pc: 12, pc: 37] local: j index: 5 type: int\n" +
 				"        [pc: 19, pc: 32] local: d1 index: 6 type: double\n" +
 				"        [pc: 42, pc: 46] local: e index: 5 type: java.lang.NullPointerException\n" +
 				"        [pc: 66, pc: 81] local: j index: 5 type: long\n" +
@@ -412,7 +412,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 10, line: 6]\n" +
 				"        [pc: 13, line: 7]\n" +
 				"        [pc: 17, line: 8]\n" +
-				"        [pc: 24, line: 9]\n" +
+				"        [pc: 21, line: 9]\n" +
 				"        [pc: 25, line: 10]\n" +
 				"        [pc: 29, line: 12]\n" +
 				"        [pc: 40, line: 11]\n" +
@@ -423,7 +423,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Local variable table:\n" +
 				"        [pc: 0, pc: 60] local: b index: 0 type: boolean\n" +
 				"        [pc: 2, pc: 60] local: i index: 1 type: int\n" +
-				"        [pc: 17, pc: 24] local: j index: 2 type: int\n" +
+				"        [pc: 17, pc: 21] local: j index: 2 type: int\n" +
 				"        [pc: 25, pc: 29] local: e index: 2 type: java.lang.NullPointerException\n" +
 				"      Stack map table: number of frames 4\n" +
 				"        [pc: 24, full, stack: {java.lang.NullPointerException}, locals: {int, int}]\n" +
@@ -498,6 +498,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Line numbers:\n" +
 				"        [pc: 0, line: 4]\n" +
 				"        [pc: 4, line: 5]\n" +
+				"        [pc: 12, line: 6]\n" +
 				"        [pc: 15, line: 7]\n" +
 				"        [pc: 23, line: 9]\n" +
 				"        [pc: 29, line: 10]\n" +
@@ -945,6 +946,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 4, line: 4]\n" +
 				"        [pc: 6, line: 5]\n" +
 				"        [pc: 13, line: 6]\n" +
+				"        [pc: 21, line: 7]\n" +
 				"        [pc: 24, line: 8]\n" +
 				"        [pc: 32, line: 10]\n" +
 				"        [pc: 54, line: 11]\n" +
@@ -1138,6 +1140,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 11, line: 8]\n" +
 				"        [pc: 19, line: 9]\n" +
 				"        [pc: 24, line: 10]\n" +
+				"        [pc: 35, line: 11]\n" +
 				"        [pc: 38, line: 12]\n" +
 				"        [pc: 44, line: 14]\n" +
 				"        [pc: 64, line: 16]\n" +
@@ -1275,6 +1278,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 11, line: 7]\n" +
 				"        [pc: 19, line: 8]\n" +
 				"        [pc: 24, line: 9]\n" +
+				"        [pc: 32, line: 10]\n" +
 				"        [pc: 35, line: 11]\n" +
 				"        [pc: 37, line: 13]\n" +
 				"        [pc: 56, line: 15]\n" +
@@ -1371,7 +1375,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 			"        [pc: 0, line: 4]\n" +
 			"        [pc: 4, line: 5]\n" +
 			"        [pc: 6, line: 7]\n" +
-			"        [pc: 14, line: 8]\n" +
+			"        [pc: 11, line: 8]\n" +
 			"        [pc: 15, line: 4]\n" +
 			"        [pc: 23, line: 11]\n" +
 			"      Local variable table:\n" +
@@ -6473,8 +6477,10 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 			"    30  return\n" + 
 			"      Line numbers:\n" + 
 			"        [pc: 0, line: 5]\n" + 
+			"        [pc: 3, line: 4]\n" + 
 			"        [pc: 6, line: 6]\n" + 
 			"        [pc: 11, line: 7]\n" + 
+			"        [pc: 19, line: 8]\n" + 
 			"        [pc: 22, line: 9]\n" + 
 			"        [pc: 30, line: 11]\n" + 
 			"      Local variable table:\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
index a0678a8..518be2d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
@@ -365,14 +365,13 @@ public void test012() throws Exception {
 		"        [pc: 4, line: 6]\n" +
 		"        [pc: 28, line: 8]\n" +
 		"        [pc: 31, line: 10]\n" +
-		"        [pc: 33, line: 12]\n" +
-		"        [pc: 36, line: 13]\n" +
+		"        [pc: 33, line: 13]\n" +
 		"        [pc: 37, line: 15]\n" +
 		"        [pc: 45, line: 16]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 46] local: args index: 0 type: java.lang.String[]\n" +
 		"        [pc: 2, pc: 46] local: x index: 1 type: boolean\n" +
-		"        [pc: 4, pc: 36] local: i index: 2 type: int\n";
+		"        [pc: 4, pc: 33] local: i index: 2 type: int\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
 	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
@@ -484,6 +483,7 @@ public void test013() throws Exception {
 			"        [pc: 13, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
 			"        [pc: 26, line: 10]\n" +
+			"        [pc: 34, line: 11]\n" +
 			"        [pc: 37, line: 12]\n" +
 			"        [pc: 39, line: 14]\n" +
 			"        [pc: 60, line: 16]\n" +
@@ -559,6 +559,7 @@ public void test013() throws Exception {
 			"        [pc: 13, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
 			"        [pc: 26, line: 10]\n" +
+			"        [pc: 34, line: 11]\n" +
 			"        [pc: 37, line: 12]\n" +
 			"        [pc: 39, line: 14]\n" +
 			"        [pc: 60, line: 16]\n" +
@@ -2396,6 +2397,123 @@ public void testBug380927g() {
 			"The local variable b may not have been initialized\n" + 
 			"----------\n");	
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383629
+// To check that code gen is ok
+public void testBug383629() throws Exception {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	  public static void main(String[] args) {\n" +           
+			"	    char  chc;         \n" +
+			"	     do {      \n" +                   
+			"	        if (args == null) {      \n" +                                       
+			"	           switch ('a') {     \n" +                                        
+			"	           case '\\n':      \n" +            
+			"	                 chc = 'b';\n" +
+			"	           }               \n" +
+			"	        } else {            \n" +   
+			"	           switch ('a') {       \n" +           
+			"	              case '\\r':\n" +
+			"	           }          \n" +     
+			"	        }\n" +
+			"	     } while (false);\n" +
+			"	     System.out.println(\"Done\");\n" +
+			"	  }\n" +
+			"}",
+		}); // custom requestor
+	
+	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_6 ?
+			"      Local variable table:\n" + 
+			"        [pc: 0, pc: 61] local: args index: 0 type: java.lang.String[]\n":
+				"      Local variable table:\n" + 
+				"        [pc: 0, pc: 61] local: args index: 0 type: java.lang.String[]\n" + 
+				"      Stack map table: number of frames 4\n" + 
+				"        [pc: 24, same]\n" + 
+				"        [pc: 27, same]\n" + 
+				"        [pc: 30, same]\n" + 
+				"        [pc: 52, same]\n";
+	
+	File f = new File(OUTPUT_DIR + File.separator + "X.class");
+	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
+	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
+	int index = result.indexOf(expectedOutput);
+	if (index == -1 || expectedOutput.length() == 0) {
+		System.out.println(Util.displayString(result, 3));
+	}
+	if (index == -1) {
+		assertEquals("Wrong contents", expectedOutput, result);
+	}
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=381172
+// To check that code gen is ok
+public void testBug381172() throws Exception {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"    public static void main(String[] args){\n" + 
+			"        System.out.println(\"Test\");\n" + 
+			"    }\n" + 
+			"    public void method() {\n" + 
+			"        try {\n" + 
+			"            int rc;\n" + 
+			"            switch ( 0 )\n" + 
+			"            {\n" + 
+			"                case 0:\n" + 
+			"                    rc = 0;\n" + 
+			"                    setRC( rc );\n" + 
+			"                    break;\n" + 
+			"                case 1:\n" + 
+			"                    rc = 1;\n" + 
+			"                    setRC( 0 );\n" + 
+			"                    break;\n" + 
+			"                case 2:\n" + 
+			"                    rc = 2;\n" + 
+			"                    setRC( 0 );\n" + 
+			"                    break;\n" + 
+			"                default:\n" + 
+			"                    break;\n" + 
+			"            }\n" + 
+			"        }\n" + 
+			"        catch ( final Exception ex ) {}\n" + 
+			"    }\n" + 
+			"    private void setRC(int rc) {}\n" + 
+			"}",
+		}); // custom requestor
+	
+	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_6 ?
+			"      Local variable table:\n" + 
+			"        [pc: 0, pc: 1] local: this index: 0 type: X\n" + 
+			"        [pc: 0, pc: 1] local: rc index: 1 type: int\n":
+				"      Local variable table:\n" + 
+				"        [pc: 0, pc: 63] local: this index: 0 type: X\n" + 
+				"        [pc: 30, pc: 38] local: rc index: 1 type: int\n" + 
+				"        [pc: 40, pc: 48] local: rc index: 1 type: int\n" + 
+				"        [pc: 50, pc: 58] local: rc index: 1 type: int\n" + 
+				"      Stack map table: number of frames 6\n" + 
+				"        [pc: 28, same]\n" + 
+				"        [pc: 38, same]\n" + 
+				"        [pc: 48, same]\n" + 
+				"        [pc: 58, same]\n" + 
+				"        [pc: 61, same_locals_1_stack_item, stack: {java.lang.Exception}]\n" + 
+				"        [pc: 62, same]\n";
+	
+	File f = new File(OUTPUT_DIR + File.separator + "X.class");
+	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
+	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
+	int index = result.indexOf(expectedOutput);
+	if (index == -1 || expectedOutput.length() == 0) {
+		System.out.println(Util.displayString(result, 3));
+	}
+	if (index == -1) {
+		assertEquals("Wrong contents", expectedOutput, result);
+	}
+}
 public static Class testClass() {
 	return SwitchTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
index 49dced1..6f61716 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
@@ -904,7 +904,7 @@ public void test026() throws Exception {
 
 	String expectedOutput =
 		"      Local variable table:\n" +
-		"        [pc: 6, pc: 21] local: i index: 0 type: int\n" +
+		"        [pc: 6, pc: 20] local: i index: 0 type: int\n" +
 		"        [pc: 16, pc: 20] local: e index: 1 type: java.lang.Throwable\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -956,7 +956,6 @@ public void test027() throws Exception {
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 20] local: this index: 0 type: X\n" +
 		"        [pc: 0, pc: 20] local: b index: 1 type: boolean\n" +
-		"        [pc: 6, pc: 9] local: i index: 2 type: int\n" +
 		"        [pc: 10, pc: 14] local: e index: 2 type: java.lang.Exception\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -3681,7 +3680,7 @@ public void test048() throws Exception {
 				"        [pc: 0, line: 50]\n" +
 				"        [pc: 7, line: 51]\n" +
 				"        [pc: 28, line: 52]\n" +
-				"        [pc: 29, line: 53]\n" +
+				"        [pc: 29, line: 55]\n" +
 				"        [pc: 32, line: 56]\n" +
 				"        [pc: 37, line: 58]\n" +
 				"      Local variable table:\n" +
@@ -3828,7 +3827,7 @@ public void test048() throws Exception {
 			"        [pc: 0, line: 50]\n" +
 			"        [pc: 7, line: 51]\n" +
 			"        [pc: 28, line: 52]\n" +
-			"        [pc: 29, line: 53]\n" +
+			"        [pc: 29, line: 55]\n" +
 			"        [pc: 32, line: 56]\n" +
 			"        [pc: 37, line: 58]\n" +
 			"      Local variable table:\n" +
@@ -4056,7 +4055,7 @@ public void test049() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 36, line: 49]\n" +
+			"        [pc: 36, line: 51]\n" +
 			"        [pc: 39, line: 52]\n" +
 			"        [pc: 44, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4217,7 +4216,7 @@ public void test049() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 36, line: 49]\n" +
+			"        [pc: 36, line: 51]\n" +
 			"        [pc: 39, line: 52]\n" +
 			"        [pc: 44, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4415,7 +4414,7 @@ public void test050() throws Exception {
 				"        [pc: 0, line: 46]\n" +
 				"        [pc: 7, line: 47]\n" +
 				"        [pc: 28, line: 48]\n" +
-				"        [pc: 31, line: 49]\n" +
+				"        [pc: 31, line: 51]\n" +
 				"        [pc: 34, line: 52]\n" +
 				"        [pc: 39, line: 54]\n" +
 				"      Local variable table:\n" +
@@ -4545,7 +4544,7 @@ public void test050() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 31, line: 49]\n" +
+			"        [pc: 31, line: 51]\n" +
 			"        [pc: 34, line: 52]\n" +
 			"        [pc: 39, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4618,8 +4617,7 @@ public void test051() throws Exception {
 			"        [pc: 2, line: 8]\n" +
 			"        [pc: 4, line: 9]\n" +
 			"        [pc: 7, line: 10]\n" +
-			"        [pc: 16, line: 11]\n" +
-			"        [pc: 19, line: 13]\n" +
+			"        [pc: 16, line: 13]\n" +
 			"        [pc: 20, line: 15]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 2, pc: 22] local: count index: 0 type: int\n" +
@@ -4648,8 +4646,7 @@ public void test051() throws Exception {
 			"        [pc: 2, line: 8]\n" +
 			"        [pc: 4, line: 9]\n" +
 			"        [pc: 7, line: 10]\n" +
-			"        [pc: 16, line: 11]\n" +
-			"        [pc: 19, line: 13]\n" +
+			"        [pc: 16, line: 13]\n" +
 			"        [pc: 20, line: 15]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 2, pc: 22] local: count index: 0 type: int\n" +
@@ -4784,11 +4781,11 @@ public void test053() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
 			"        [pc: 7, line: 6]\n" +
-			"        [pc: 17, line: 7]\n" +
+			"        [pc: 14, line: 7]\n" +
 			"        [pc: 18, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 19] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 3, pc: 17] local: val index: 1 type: int\n"
+			"        [pc: 3, pc: 14] local: val index: 1 type: int\n"
 		:
 			"  // Method descriptor #15 ([Ljava/lang/String;)V\n" +
 			"  // Stack: 2, Locals: 2\n" +
@@ -4808,11 +4805,11 @@ public void test053() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
 			"        [pc: 7, line: 6]\n" +
-			"        [pc: 17, line: 7]\n" +
+			"        [pc: 14, line: 7]\n" +
 			"        [pc: 18, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 19] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 3, pc: 17] local: val index: 1 type: int\n" +
+			"        [pc: 3, pc: 14] local: val index: 1 type: int\n" +
 			"      Stack map table: number of frames 3\n" +
 			"        [pc: 7, append: {int}]\n" +
 			"        [pc: 17, full, stack: {java.lang.Exception}, locals: {java.lang.String[]}]\n" +
@@ -5275,12 +5272,12 @@ public void test058() throws Exception {
 			"        [pc: 53, pc: 56] -> 34 when : any\n" +
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
-			"        [pc: 11, line: 6]\n" +
+			"        [pc: 8, line: 6]\n" +
 			"        [pc: 15, line: 8]\n" +
 			"        [pc: 17, line: 6]\n" +
 			"        [pc: 18, line: 7]\n" +
 			"        [pc: 26, line: 8]\n" +
-			"        [pc: 34, line: 9]\n" +
+			"        [pc: 31, line: 9]\n" +
 			"        [pc: 39, line: 11]\n" +
 			"        [pc: 42, line: 9]\n" +
 			"        [pc: 43, line: 10]\n" +
@@ -5321,11 +5318,11 @@ public void test058() throws Exception {
 			"        [pc: 0, pc: 33] -> 33 when : any\n" +
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
-			"        [pc: 11, line: 6]\n" +
+			"        [pc: 8, line: 6]\n" +
 			"        [pc: 12, line: 7]\n" +
 			"        [pc: 20, line: 8]\n" +
 			"        [pc: 22, line: 7]\n" +
-			"        [pc: 33, line: 9]\n" +
+			"        [pc: 30, line: 9]\n" +
 			"        [pc: 34, line: 10]\n" +
 			"        [pc: 42, line: 11]\n" +
 			"        [pc: 44, line: 10]\n" +
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
index ce3da94..254d50f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
@@ -103,7 +103,6 @@ public class AND_AND_Expression extends BinaryExpression {
 				codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			codeStream.recordPositionsFrom(pc, this.sourceStart);
 			return;
 		}
@@ -147,11 +146,9 @@ public class AND_AND_Expression extends BinaryExpression {
 		if (valueRequired) {
 			if (leftIsConst && !leftIsTrue) {
 				codeStream.iconst_0();
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			} else {
 				if (rightIsConst && !rightIsTrue) {
 					codeStream.iconst_0();
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 				} else {
 					codeStream.iconst_1();
 				}
@@ -173,7 +170,7 @@ public class AND_AND_Expression extends BinaryExpression {
 				}
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 		} else {
 			falseLabel.place();
 		}
@@ -229,7 +226,7 @@ public class AND_AND_Expression extends BinaryExpression {
 							valueRequired && !rightIsConst);
 					if (valueRequired && rightIsConst && rightIsTrue) {
 						codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 					}
 					internalFalseLabel.place();
 				}
@@ -238,9 +235,12 @@ public class AND_AND_Expression extends BinaryExpression {
 				if (trueLabel == null) {
 					this.left.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, !leftIsConst);
 					// need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
+					int pc = codeStream.position;
 					if (leftIsConst && !leftIsTrue) {
-						if (valueRequired) codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						if (valueRequired) {
+							codeStream.goto_(falseLabel);
+						}
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 						break generateOperands; // no need to generate right operand
 					}
 					if (this.rightInitStateIndex != -1) {
@@ -250,7 +250,7 @@ public class AND_AND_Expression extends BinaryExpression {
 					this.right.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, valueRequired && !rightIsConst);
 					if (valueRequired && rightIsConst && !rightIsTrue) {
 						codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 					}
 				} else {
 					// no implicit fall through TRUE/FALSE --> should never occur
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
index 98af10a..92200be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
@@ -669,7 +669,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x > 0
@@ -691,7 +691,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -719,7 +719,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 						codeStream.ifgt(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -742,7 +742,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 						codeStream.ifle(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -777,7 +777,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x >= 0
@@ -799,7 +799,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -827,7 +827,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 						codeStream.ifge(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -850,7 +850,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 						codeStream.iflt(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -884,7 +884,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 					}
 				}
 			}
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x < 0
@@ -905,7 +905,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 					}
 				}
 			}
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -932,7 +932,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 						codeStream.dcmpg();
 						codeStream.iflt(trueLabel);
 				}
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -954,7 +954,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 						codeStream.dcmpg();
 						codeStream.ifge(falseLabel);
 				}
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -989,7 +989,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x <= 0
@@ -1011,7 +1011,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -1039,7 +1039,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 						codeStream.ifle(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -1062,7 +1062,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 						codeStream.ifgt(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -1090,7 +1090,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 					codeStream.iconst_0();
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1107,7 +1107,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 					codeStream.iconst_0();
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1118,8 +1118,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 	if (valueRequired) {
 		codeStream.iand();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1136,8 +1135,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 				if (valueRequired) {
 					codeStream.iconst_1();
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// <something equivalent to false> | x
 				this.left.generateCode(currentScope, codeStream, false);
@@ -1153,8 +1151,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 				if (valueRequired) {
 					codeStream.iconst_1();
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// x | <something equivalent to false>
 				this.left.generateCode(currentScope, codeStream, valueRequired);
@@ -1169,8 +1166,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 	if (valueRequired) {
 		codeStream.ior();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1189,7 +1185,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 				this.right.generateCode(currentScope, codeStream, valueRequired);
 				if (valueRequired) {
 					codeStream.ixor(); // negate
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				}
 			} else {
 				// <something equivalent to false> ^ x
@@ -1206,7 +1202,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 				if (valueRequired) {
 					codeStream.iconst_1();
 					codeStream.ixor(); // negate
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				}
 			} else {
 				// x ^ <something equivalent to false>
@@ -1222,8 +1218,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 	if (valueRequired) {
 		codeStream.ixor();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1267,8 +1262,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 						codeStream.goto_(falseLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1309,8 +1303,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 						codeStream.goto_(falseLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1334,8 +1327,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1366,8 +1358,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 						codeStream.goto_(trueLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// <something equivalent to false> | x
 				this.left.generateOptimizedBoolean(
@@ -1407,8 +1398,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 						codeStream.goto_(trueLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// x | <something equivalent to false>
 				this.left.generateOptimizedBoolean(
@@ -1446,8 +1436,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1540,8 +1529,7 @@ public void generateOptimizedLogicalXor(BlockScope currentScope, CodeStream code
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 public void generateOptimizedStringConcatenation(BlockScope blockScope, CodeStream codeStream, int typeID) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
index 2dd5580..47e5c9f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
@@ -21,7 +21,6 @@ import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.InitializationFlowContext;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
@@ -187,7 +186,7 @@ public class Clinit extends AbstractMethodDeclaration {
 		}
 		// generate static fields/initializers/enum constants
 		final FieldDeclaration[] fieldDeclarations = declaringType.fields;
-		BlockScope lastInitializerScope = null;
+		int sourcePosition = -1;
 		int remainingFieldCount = 0;
 		if (TypeDeclaration.kind(declaringType.modifiers) == TypeDeclaration.ENUM_DECL) {
 			int enumCount = declaringType.enumConstantsCounter;
@@ -263,7 +262,7 @@ public class Clinit extends AbstractMethodDeclaration {
 								break;
 							}
 							remainingFieldCount--;
-							lastInitializerScope = ((Initializer) fieldDecl).block.scope;
+							sourcePosition = ((Initializer) fieldDecl).block.sourceEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 						case AbstractVariableDeclaration.FIELD :
@@ -271,7 +270,7 @@ public class Clinit extends AbstractMethodDeclaration {
 								break;
 							}
 							remainingFieldCount--;
-							lastInitializerScope = null;
+							sourcePosition = fieldDecl.declarationEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 					}
@@ -285,13 +284,13 @@ public class Clinit extends AbstractMethodDeclaration {
 						case AbstractVariableDeclaration.INITIALIZER :
 							if (!fieldDecl.isStatic())
 								break;
-							lastInitializerScope = ((Initializer) fieldDecl).block.scope;
+							sourcePosition = ((Initializer) fieldDecl).block.sourceEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 						case AbstractVariableDeclaration.FIELD :
 							if (!fieldDecl.binding.isStatic())
 								break;
-							lastInitializerScope = null;
+							sourcePosition = fieldDecl.declarationEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 					}
@@ -311,9 +310,9 @@ public class Clinit extends AbstractMethodDeclaration {
 			if ((this.bits & ASTNode.NeedFreeReturn) != 0) {
 				int before = codeStream.position;
 				codeStream.return_();
-				if (lastInitializerScope != null) {
+				if (sourcePosition != -1) {
 					// expand the last initializer variables to include the trailing return
-					codeStream.updateLastRecordedEndPC(lastInitializerScope, before);
+					codeStream.recordPositionsFrom(before, sourcePosition);
 				}
 			}
 			// Record the end of the clinit: point to the declaration of the class
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 5907c61..75dce2a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -229,7 +229,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				// Jump over the else part
 				int position = codeStream.position;
 				codeStream.goto_(endifLabel);
-				codeStream.updateLastRecordedEndPC(currentScope, position);
+				codeStream.recordPositionsFrom(position, this.valueIfTrue.sourceEnd);
 				// Tune codestream stack size
 				if (valueRequired) {
 					switch(this.resolvedType.id) {
@@ -285,6 +285,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		BranchLabel falseLabel,
 		boolean valueRequired) {
 
+		int pc = codeStream.position;
+
 		if ((this.constant != Constant.NotAConstant) && (this.constant.typeID() == T_boolean) // constant
 			|| ((this.valueIfTrue.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) != T_boolean) { // non boolean values
 			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
@@ -342,7 +344,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 					}
 					int position = codeStream.position;
 					codeStream.goto_(endifLabel);
-					codeStream.updateLastRecordedEndPC(currentScope, position);
+					codeStream.recordPositionsFrom(position, this.valueIfTrue.sourceEnd);
 				}
 				// No need to decrement codestream stack size
 				// since valueIfTrue was already consumed by branch bytecode
@@ -364,7 +366,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 		}
 		// no implicit conversion for boolean values
-		codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 
 	public int nullStatus(FlowInfo flowInfo) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 0a1d870..6e4a013 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -376,6 +376,7 @@ public class EqualExpression extends BinaryExpression {
 		// default case
 		this.left.generateCode(currentScope, codeStream, valueRequired);
 		this.right.generateCode(currentScope, codeStream, valueRequired);
+		int pc = codeStream.position;
 		if (valueRequired) {
 			if (falseLabel == null) {
 				if (trueLabel != null) {
@@ -391,8 +392,7 @@ public class EqualExpression extends BinaryExpression {
 				}
 			}
 		}
-		// reposition the endPC
-		codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 	/**
 	 * Boolean generation for == with non-boolean operands
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index f04641e..e585a58 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -704,8 +704,7 @@ public void generateOptimizedBoolean(BlockScope currentScope, CodeStream codeStr
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, position);
+	codeStream.recordPositionsFrom(position, this.sourceEnd);
 }
 
 /* Optimized (java) code generation for string concatenations that involve StringBuffer
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 5545720..8fc6094 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -193,8 +193,8 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 				this.thenStatement.branchChainTo(endifLabel);
 				int position = codeStream.position;
 				codeStream.goto_(endifLabel);
-				//goto is tagged as part of the thenAction block
-				codeStream.updateLastRecordedEndPC((this.thenStatement instanceof Block) ? ((Block) this.thenStatement).scope : currentScope, position);
+				//goto is pointing to the last line of the thenStatement
+				codeStream.recordPositionsFrom(position, this.thenStatement.sourceEnd);
 				// generate else statement
 			}
 			// May loose some local variable initializations : affecting the local variable attributes
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 4b3fca4..443391d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -108,7 +108,6 @@ public class OR_OR_Expression extends BinaryExpression {
 				codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			codeStream.recordPositionsFrom(pc, this.sourceStart);
 			return;
 		}
@@ -152,11 +151,11 @@ public class OR_OR_Expression extends BinaryExpression {
 		if (valueRequired) {
 			if (leftIsConst && leftIsTrue) {
 				codeStream.iconst_1();
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 			} else {
 				if (rightIsConst && rightIsTrue) {
 					codeStream.iconst_1();
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 				} else {
 					codeStream.iconst_0();
 				}
@@ -178,7 +177,7 @@ public class OR_OR_Expression extends BinaryExpression {
 				}
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 		} else {
 			trueLabel.place();
 		}
@@ -222,7 +221,7 @@ public class OR_OR_Expression extends BinaryExpression {
 					// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
 					if (leftIsTrue) {
 						if (valueRequired) codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 						break generateOperands; // no need to generate right operand
 					}
 					if (this.rightInitStateIndex != -1) {
@@ -231,7 +230,7 @@ public class OR_OR_Expression extends BinaryExpression {
 					this.right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, valueRequired && !rightIsConst);
 					if (valueRequired && rightIsTrue) {
 						codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 					}
 				}
 			} else {
@@ -249,9 +248,10 @@ public class OR_OR_Expression extends BinaryExpression {
 								.addDefinitelyAssignedVariables(currentScope, this.rightInitStateIndex);
 					}
 					this.right.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, valueRequired && !rightIsConst);
+					int pc = codeStream.position;
 					if (valueRequired && rightIsConst && !rightIsTrue) {
 						codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 					}
 					internalTrueLabel.place();
 				} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index 0a2f27e..eaede3c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -381,7 +381,7 @@ public class SwitchStatement extends Statement {
 				} else {
 					codeStream.lookupswitch(defaultLabel, this.constants, sortedIndexes, caseLabels);
 				}
-				codeStream.updateLastRecordedEndPC(this.scope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.expression.sourceEnd);
 			} else if (valueRequired) {
 				codeStream.pop();
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 7a3401b..0648e5b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -670,7 +670,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 					codeStream.goto_(this.subRoutineStartLabel);
 					break;
 			}
-			codeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);
+			codeStream.recordPositionsFrom(position, this.tryBlock.sourceEnd);
 			//goto is tagged as part of the try block
 		}
 		/* generate sequence of handler, all starting by storing the TOS (exception
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 402d644..ac7bbe9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -6652,46 +6652,6 @@ public String toString() {
 	buffer.append(")"); //$NON-NLS-1$
 	return buffer.toString();
 }
-
-/**
- * Note: it will walk the locals table and extend the end range for all matching ones, no matter if
- * visible or not.
- * {  int i = 0;
- *    {  int j = 1; }
- * }   <== would process both 'i' and 'j'
- * Processing non-visible ones is mandated in some cases (include goto instruction after if-then block)
- */
-public void updateLastRecordedEndPC(Scope scope, int pos) {
-
-	/* Tune positions in the table, this is due to some
-	 * extra bytecodes being
-	 * added to some user code (jumps). */
-	/** OLD CODE
-		if (!generateLineNumberAttributes)
-			return;
-		pcToSourceMap[pcToSourceMapSize - 1][1] = position;
-		// need to update the initialization endPC in case of generation of local variable attributes.
-		updateLocalVariablesAttribute(pos);
-	*/
-
-	if ((this.generateAttributes & ClassFileConstants.ATTR_LINES) != 0) {
-		this.lastEntryPC = pos;
-	}
-	// need to update the initialization endPC in case of generation of local variable attributes.
-	if ((this.generateAttributes & (ClassFileConstants.ATTR_VARS
-			| ClassFileConstants.ATTR_STACK_MAP_TABLE
-			| ClassFileConstants.ATTR_STACK_MAP)) != 0) {
-		for (int i = 0, max = this.locals.length; i < max; i++) {
-			LocalVariableBinding local = this.locals[i];
-			if (local != null && local.declaringScope == scope && local.initializationCount > 0) {
-				if (local.initializationPCs[((local.initializationCount - 1) << 1) + 1] == pos) {
-					local.initializationPCs[((local.initializationCount - 1) << 1) + 1] = this.position;
-				}
-			}
-		}
-	}
-}
-
 protected void writePosition(BranchLabel label) {
 	int offset = label.position - this.position + 1;
 	if (Math.abs(offset) > 0x7FFF && !this.wideMode) {
commit 04423947d8d7bb07b422b48e36dce13f3a6590fc
Author: Ayushman Jain <ajain>
Date:   Thu Jul 5 14:41:47 2012 +0530

    Fixed bug 381172: VerifyError "Inconsistent stackmap frames" for switch
    nested within try-catch

3	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
11	11	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
6	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
12	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
121	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
17	20	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
32	44	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
7	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
7	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
0	40	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
index 0b0e640..2f45746 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ArrayTest.java
@@ -127,8 +127,7 @@ public void test005() throws Exception {
 		"    4  putstatic X.X : java.lang.Object[] [9]\n" +
 		"    7  return\n" +
 		"      Line numbers:\n" +
-		"        [pc: 0, line: 2]\n" +
-		"        [pc: 7, line: 1]\n";
+		"        [pc: 0, line: 2]\n";
 
 	int index = actualOutput.indexOf(expectedOutput);
 	if (index == -1 || expectedOutput.length() == 0) {
@@ -284,12 +283,12 @@ public void test011() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 4]\n" +
 			"        [pc: 5, line: 5]\n" +
-			"        [pc: 15, line: 6]\n" +
+			"        [pc: 12, line: 6]\n" +
 			"        [pc: 16, line: 7]\n" +
 			"        [pc: 24, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 25] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 5, pc: 15] local: all index: 1 type: java.lang.Object[][]\n" +
+			"        [pc: 5, pc: 12] local: all index: 1 type: java.lang.Object[][]\n" +
 			"        [pc: 16, pc: 24] local: e index: 1 type: java.lang.ArrayStoreException\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
index 2d73cd3..e03d0a7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_4.java
@@ -1885,7 +1885,7 @@ public class ClassFileReaderTest_1_4 extends AbstractRegressionTest {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 6]\n" +
 			"        [pc: 9, line: 7]\n" +
-			"        [pc: 14, line: 8]\n" +
+			"        [pc: 11, line: 8]\n" +
 			"        [pc: 18, line: 10]\n" +
 			"        [pc: 20, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 1f1da1c..5c8749a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -35484,13 +35484,13 @@ public void test1058() throws Exception {
 		"        [pc: 0, line: 4]\n" +
 		"        [pc: 2, line: 5]\n" +
 		"        [pc: 5, line: 6]\n" +
-		"        [pc: 32, line: 7]\n" +
+		"        [pc: 29, line: 7]\n" +
 		"        [pc: 33, line: 8]\n" +
 		"        [pc: 41, line: 10]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 42] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 2, pc: 32] local: foo index: 1 type: int\n" +
-		"        [pc: 5, pc: 32] local: bar index: 2 type: java.lang.String\n" +
+		"        [pc: 2, pc: 29] local: foo index: 1 type: int\n" +
+		"        [pc: 5, pc: 29] local: bar index: 2 type: java.lang.String\n" +
 		"        [pc: 33, pc: 41] local: e index: 1 type: java.lang.NullPointerException\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -36023,16 +36023,16 @@ public void test1066() throws Exception {
 				"        [pc: 27, line: 8]\n" +
 				"        [pc: 30, line: 9]\n" +
 				"        [pc: 36, line: 11]\n" +
-				"        [pc: 79, line: 12]\n" +
+				"        [pc: 76, line: 12]\n" +
 				"        [pc: 81, line: 13]\n" +
 				"        [pc: 115, line: 16]\n" +
-				"        [pc: 158, line: 17]\n" +
+				"        [pc: 155, line: 17]\n" +
 				"        [pc: 160, line: 18]\n" +
 				"        [pc: 194, line: 21]\n" +
-				"        [pc: 240, line: 22]\n" +
+				"        [pc: 237, line: 22]\n" +
 				"        [pc: 242, line: 23]\n" +
 				"        [pc: 276, line: 26]\n" +
-				"        [pc: 322, line: 27]\n" +
+				"        [pc: 319, line: 27]\n" +
 				"        [pc: 324, line: 28]\n" +
 				"        [pc: 358, line: 30]\n" +
 				"      Local variable table:\n" +
@@ -36205,16 +36205,16 @@ public void test1066() throws Exception {
 				"        [pc: 27, line: 8]\n" +
 				"        [pc: 30, line: 9]\n" +
 				"        [pc: 36, line: 11]\n" +
-				"        [pc: 79, line: 12]\n" +
+				"        [pc: 76, line: 12]\n" +
 				"        [pc: 81, line: 13]\n" +
 				"        [pc: 115, line: 16]\n" +
-				"        [pc: 158, line: 17]\n" +
+				"        [pc: 155, line: 17]\n" +
 				"        [pc: 160, line: 18]\n" +
 				"        [pc: 194, line: 21]\n" +
-				"        [pc: 240, line: 22]\n" +
+				"        [pc: 237, line: 22]\n" +
 				"        [pc: 242, line: 23]\n" +
 				"        [pc: 276, line: 26]\n" +
-				"        [pc: 322, line: 27]\n" +
+				"        [pc: 319, line: 27]\n" +
 				"        [pc: 324, line: 28]\n" +
 				"        [pc: 358, line: 30]\n" +
 				"      Local variable table:\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
index 4355bd3..7afa765 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LineNumberAttributeTest.java
@@ -105,12 +105,12 @@ public void test001() throws Exception {
 		"        [pc: 33, line: 15]\n" +
 		"        [pc: 36, line: 16]\n" +
 		"        [pc: 39, line: 17]\n" +
-		"        [pc: 46, line: 18]\n" +
+		"        [pc: 43, line: 18]\n" +
 		"        [pc: 47, line: 19]\n" +
 		"        [pc: 55, line: 21]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 56] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 23, pc: 46] local: x index: 1 type: X\n" +
+		"        [pc: 23, pc: 43] local: x index: 1 type: X\n" +
 		"        [pc: 47, pc: 55] local: e index: 1 type: java.lang.NullPointerException\n";
 	int index = actualOutput.indexOf(expectedOutput);
 	if (index == -1 || expectedOutput.length() == 0) {
@@ -196,7 +196,7 @@ public void test002() throws Exception {
 		"        [pc: 13, line: 23]\n" +
 		"        [pc: 16, line: 24]\n" +
 		"        [pc: 19, line: 25]\n" +
-		"        [pc: 26, line: 26]\n" +
+		"        [pc: 23, line: 26]\n" +
 		"        [pc: 27, line: 27]\n" +
 		"        [pc: 35, line: 29]\n" +
 		"      Local variable table:\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 4cb768e..c2e389f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -11877,9 +11877,11 @@ public void testBug303448a() throws Exception {
 				"        [pc: 4, line: 7]\n" + 
 				"        [pc: 26, line: 8]\n" + 
 				"        [pc: 30, line: 9]\n" + 
+				"        [pc: 38, line: 10]\n" + 
 				"        [pc: 41, line: 11]\n" + 
 				"        [pc: 49, line: 13]\n" + 
 				"        [pc: 53, line: 14]\n" + 
+				"        [pc: 61, line: 15]\n" + 
 				"        [pc: 64, line: 16]\n" + 
 				"        [pc: 72, line: 19]\n" + 
 				"      Local variable table:\n" + 
@@ -11929,9 +11931,11 @@ public void testBug303448a() throws Exception {
 						"        [pc: 4, line: 7]\n" + 
 						"        [pc: 26, line: 8]\n" + 
 						"        [pc: 30, line: 9]\n" + 
+						"        [pc: 38, line: 10]\n" + 
 						"        [pc: 41, line: 11]\n" + 
 						"        [pc: 49, line: 13]\n" + 
 						"        [pc: 53, line: 14]\n" + 
+						"        [pc: 61, line: 15]\n" + 
 						"        [pc: 64, line: 16]\n" + 
 						"        [pc: 72, line: 19]\n" + 
 						"      Local variable table:\n" + 
@@ -11980,9 +11984,11 @@ public void testBug303448a() throws Exception {
 						"        [pc: 4, line: 7]\n" + 
 						"        [pc: 26, line: 8]\n" + 
 						"        [pc: 30, line: 9]\n" + 
+						"        [pc: 38, line: 10]\n" + 
 						"        [pc: 41, line: 11]\n" + 
 						"        [pc: 49, line: 13]\n" + 
 						"        [pc: 53, line: 14]\n" + 
+						"        [pc: 61, line: 15]\n" + 
 						"        [pc: 64, line: 16]\n" + 
 						"        [pc: 72, line: 19]\n" + 
 						"      Local variable table:\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
index aa95982..35d56a5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StackMapAttributeTest.java
@@ -112,7 +112,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Line numbers:\n" +
 				"        [pc: 0, line: 4]\n" +
 				"        [pc: 21, line: 6]\n" +
-				"        [pc: 32, line: 7]\n" +
+				"        [pc: 29, line: 7]\n" +
 				"        [pc: 33, line: 8]\n" +
 				"        [pc: 37, line: 10]\n" +
 				"      Local variable table:\n" +
@@ -293,7 +293,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 23, line: 11]\n" +
 				"        [pc: 26, line: 13]\n" +
 				"        [pc: 32, line: 15]\n" +
-				"        [pc: 40, line: 16]\n" +
+				"        [pc: 37, line: 16]\n" +
 				"        [pc: 42, line: 17]\n" +
 				"        [pc: 46, line: 19]\n" +
 				"        [pc: 51, line: 18]\n" +
@@ -310,7 +310,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 2, pc: 40] local: i index: 3 type: double\n" +
 				"        [pc: 46, pc: 51] local: i index: 3 type: double\n" +
 				"        [pc: 55, pc: 81] local: i index: 3 type: double\n" +
-				"        [pc: 12, pc: 40] local: j index: 5 type: int\n" +
+				"        [pc: 12, pc: 37] local: j index: 5 type: int\n" +
 				"        [pc: 19, pc: 32] local: d1 index: 6 type: double\n" +
 				"        [pc: 42, pc: 46] local: e index: 5 type: java.lang.NullPointerException\n" +
 				"        [pc: 66, pc: 81] local: j index: 5 type: long\n" +
@@ -412,7 +412,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 10, line: 6]\n" +
 				"        [pc: 13, line: 7]\n" +
 				"        [pc: 17, line: 8]\n" +
-				"        [pc: 24, line: 9]\n" +
+				"        [pc: 21, line: 9]\n" +
 				"        [pc: 25, line: 10]\n" +
 				"        [pc: 29, line: 12]\n" +
 				"        [pc: 40, line: 11]\n" +
@@ -423,7 +423,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Local variable table:\n" +
 				"        [pc: 0, pc: 60] local: b index: 0 type: boolean\n" +
 				"        [pc: 2, pc: 60] local: i index: 1 type: int\n" +
-				"        [pc: 17, pc: 24] local: j index: 2 type: int\n" +
+				"        [pc: 17, pc: 21] local: j index: 2 type: int\n" +
 				"        [pc: 25, pc: 29] local: e index: 2 type: java.lang.NullPointerException\n" +
 				"      Stack map table: number of frames 4\n" +
 				"        [pc: 24, full, stack: {java.lang.NullPointerException}, locals: {int, int}]\n" +
@@ -498,6 +498,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"      Line numbers:\n" +
 				"        [pc: 0, line: 4]\n" +
 				"        [pc: 4, line: 5]\n" +
+				"        [pc: 12, line: 6]\n" +
 				"        [pc: 15, line: 7]\n" +
 				"        [pc: 23, line: 9]\n" +
 				"        [pc: 29, line: 10]\n" +
@@ -945,6 +946,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 4, line: 4]\n" +
 				"        [pc: 6, line: 5]\n" +
 				"        [pc: 13, line: 6]\n" +
+				"        [pc: 21, line: 7]\n" +
 				"        [pc: 24, line: 8]\n" +
 				"        [pc: 32, line: 10]\n" +
 				"        [pc: 54, line: 11]\n" +
@@ -1138,6 +1140,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 11, line: 8]\n" +
 				"        [pc: 19, line: 9]\n" +
 				"        [pc: 24, line: 10]\n" +
+				"        [pc: 35, line: 11]\n" +
 				"        [pc: 38, line: 12]\n" +
 				"        [pc: 44, line: 14]\n" +
 				"        [pc: 64, line: 16]\n" +
@@ -1275,6 +1278,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 				"        [pc: 11, line: 7]\n" +
 				"        [pc: 19, line: 8]\n" +
 				"        [pc: 24, line: 9]\n" +
+				"        [pc: 32, line: 10]\n" +
 				"        [pc: 35, line: 11]\n" +
 				"        [pc: 37, line: 13]\n" +
 				"        [pc: 56, line: 15]\n" +
@@ -1371,7 +1375,7 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 			"        [pc: 0, line: 4]\n" +
 			"        [pc: 4, line: 5]\n" +
 			"        [pc: 6, line: 7]\n" +
-			"        [pc: 14, line: 8]\n" +
+			"        [pc: 11, line: 8]\n" +
 			"        [pc: 15, line: 4]\n" +
 			"        [pc: 23, line: 11]\n" +
 			"      Local variable table:\n" +
@@ -6473,8 +6477,10 @@ public class StackMapAttributeTest extends AbstractRegressionTest {
 			"    30  return\n" + 
 			"      Line numbers:\n" + 
 			"        [pc: 0, line: 5]\n" + 
+			"        [pc: 3, line: 4]\n" + 
 			"        [pc: 6, line: 6]\n" + 
 			"        [pc: 11, line: 7]\n" + 
+			"        [pc: 19, line: 8]\n" + 
 			"        [pc: 22, line: 9]\n" + 
 			"        [pc: 30, line: 11]\n" + 
 			"      Local variable table:\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
index a0678a8..518be2d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
@@ -365,14 +365,13 @@ public void test012() throws Exception {
 		"        [pc: 4, line: 6]\n" +
 		"        [pc: 28, line: 8]\n" +
 		"        [pc: 31, line: 10]\n" +
-		"        [pc: 33, line: 12]\n" +
-		"        [pc: 36, line: 13]\n" +
+		"        [pc: 33, line: 13]\n" +
 		"        [pc: 37, line: 15]\n" +
 		"        [pc: 45, line: 16]\n" +
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 46] local: args index: 0 type: java.lang.String[]\n" +
 		"        [pc: 2, pc: 46] local: x index: 1 type: boolean\n" +
-		"        [pc: 4, pc: 36] local: i index: 2 type: int\n";
+		"        [pc: 4, pc: 33] local: i index: 2 type: int\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
 	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
@@ -484,6 +483,7 @@ public void test013() throws Exception {
 			"        [pc: 13, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
 			"        [pc: 26, line: 10]\n" +
+			"        [pc: 34, line: 11]\n" +
 			"        [pc: 37, line: 12]\n" +
 			"        [pc: 39, line: 14]\n" +
 			"        [pc: 60, line: 16]\n" +
@@ -559,6 +559,7 @@ public void test013() throws Exception {
 			"        [pc: 13, line: 8]\n" +
 			"        [pc: 21, line: 9]\n" +
 			"        [pc: 26, line: 10]\n" +
+			"        [pc: 34, line: 11]\n" +
 			"        [pc: 37, line: 12]\n" +
 			"        [pc: 39, line: 14]\n" +
 			"        [pc: 60, line: 16]\n" +
@@ -2396,6 +2397,123 @@ public void testBug380927g() {
 			"The local variable b may not have been initialized\n" + 
 			"----------\n");	
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383629
+// To check that code gen is ok
+public void testBug383629() throws Exception {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	  public static void main(String[] args) {\n" +           
+			"	    char  chc;         \n" +
+			"	     do {      \n" +                   
+			"	        if (args == null) {      \n" +                                       
+			"	           switch ('a') {     \n" +                                        
+			"	           case '\\n':      \n" +            
+			"	                 chc = 'b';\n" +
+			"	           }               \n" +
+			"	        } else {            \n" +   
+			"	           switch ('a') {       \n" +           
+			"	              case '\\r':\n" +
+			"	           }          \n" +     
+			"	        }\n" +
+			"	     } while (false);\n" +
+			"	     System.out.println(\"Done\");\n" +
+			"	  }\n" +
+			"}",
+		}); // custom requestor
+	
+	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_6 ?
+			"      Local variable table:\n" + 
+			"        [pc: 0, pc: 61] local: args index: 0 type: java.lang.String[]\n":
+				"      Local variable table:\n" + 
+				"        [pc: 0, pc: 61] local: args index: 0 type: java.lang.String[]\n" + 
+				"      Stack map table: number of frames 4\n" + 
+				"        [pc: 24, same]\n" + 
+				"        [pc: 27, same]\n" + 
+				"        [pc: 30, same]\n" + 
+				"        [pc: 52, same]\n";
+	
+	File f = new File(OUTPUT_DIR + File.separator + "X.class");
+	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
+	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
+	int index = result.indexOf(expectedOutput);
+	if (index == -1 || expectedOutput.length() == 0) {
+		System.out.println(Util.displayString(result, 3));
+	}
+	if (index == -1) {
+		assertEquals("Wrong contents", expectedOutput, result);
+	}
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=381172
+// To check that code gen is ok
+public void testBug381172() throws Exception {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"    public static void main(String[] args){\n" + 
+			"        System.out.println(\"Test\");\n" + 
+			"    }\n" + 
+			"    public void method() {\n" + 
+			"        try {\n" + 
+			"            int rc;\n" + 
+			"            switch ( 0 )\n" + 
+			"            {\n" + 
+			"                case 0:\n" + 
+			"                    rc = 0;\n" + 
+			"                    setRC( rc );\n" + 
+			"                    break;\n" + 
+			"                case 1:\n" + 
+			"                    rc = 1;\n" + 
+			"                    setRC( 0 );\n" + 
+			"                    break;\n" + 
+			"                case 2:\n" + 
+			"                    rc = 2;\n" + 
+			"                    setRC( 0 );\n" + 
+			"                    break;\n" + 
+			"                default:\n" + 
+			"                    break;\n" + 
+			"            }\n" + 
+			"        }\n" + 
+			"        catch ( final Exception ex ) {}\n" + 
+			"    }\n" + 
+			"    private void setRC(int rc) {}\n" + 
+			"}",
+		}); // custom requestor
+	
+	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_6 ?
+			"      Local variable table:\n" + 
+			"        [pc: 0, pc: 1] local: this index: 0 type: X\n" + 
+			"        [pc: 0, pc: 1] local: rc index: 1 type: int\n":
+				"      Local variable table:\n" + 
+				"        [pc: 0, pc: 63] local: this index: 0 type: X\n" + 
+				"        [pc: 30, pc: 38] local: rc index: 1 type: int\n" + 
+				"        [pc: 40, pc: 48] local: rc index: 1 type: int\n" + 
+				"        [pc: 50, pc: 58] local: rc index: 1 type: int\n" + 
+				"      Stack map table: number of frames 6\n" + 
+				"        [pc: 28, same]\n" + 
+				"        [pc: 38, same]\n" + 
+				"        [pc: 48, same]\n" + 
+				"        [pc: 58, same]\n" + 
+				"        [pc: 61, same_locals_1_stack_item, stack: {java.lang.Exception}]\n" + 
+				"        [pc: 62, same]\n";
+	
+	File f = new File(OUTPUT_DIR + File.separator + "X.class");
+	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
+	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
+	int index = result.indexOf(expectedOutput);
+	if (index == -1 || expectedOutput.length() == 0) {
+		System.out.println(Util.displayString(result, 3));
+	}
+	if (index == -1) {
+		assertEquals("Wrong contents", expectedOutput, result);
+	}
+}
 public static Class testClass() {
 	return SwitchTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
index 49dced1..6f61716 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryStatementTest.java
@@ -904,7 +904,7 @@ public void test026() throws Exception {
 
 	String expectedOutput =
 		"      Local variable table:\n" +
-		"        [pc: 6, pc: 21] local: i index: 0 type: int\n" +
+		"        [pc: 6, pc: 20] local: i index: 0 type: int\n" +
 		"        [pc: 16, pc: 20] local: e index: 1 type: java.lang.Throwable\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -956,7 +956,6 @@ public void test027() throws Exception {
 		"      Local variable table:\n" +
 		"        [pc: 0, pc: 20] local: this index: 0 type: X\n" +
 		"        [pc: 0, pc: 20] local: b index: 1 type: boolean\n" +
-		"        [pc: 6, pc: 9] local: i index: 2 type: int\n" +
 		"        [pc: 10, pc: 14] local: e index: 2 type: java.lang.Exception\n";
 
 	File f = new File(OUTPUT_DIR + File.separator + "X.class");
@@ -3681,7 +3680,7 @@ public void test048() throws Exception {
 				"        [pc: 0, line: 50]\n" +
 				"        [pc: 7, line: 51]\n" +
 				"        [pc: 28, line: 52]\n" +
-				"        [pc: 29, line: 53]\n" +
+				"        [pc: 29, line: 55]\n" +
 				"        [pc: 32, line: 56]\n" +
 				"        [pc: 37, line: 58]\n" +
 				"      Local variable table:\n" +
@@ -3828,7 +3827,7 @@ public void test048() throws Exception {
 			"        [pc: 0, line: 50]\n" +
 			"        [pc: 7, line: 51]\n" +
 			"        [pc: 28, line: 52]\n" +
-			"        [pc: 29, line: 53]\n" +
+			"        [pc: 29, line: 55]\n" +
 			"        [pc: 32, line: 56]\n" +
 			"        [pc: 37, line: 58]\n" +
 			"      Local variable table:\n" +
@@ -4056,7 +4055,7 @@ public void test049() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 36, line: 49]\n" +
+			"        [pc: 36, line: 51]\n" +
 			"        [pc: 39, line: 52]\n" +
 			"        [pc: 44, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4217,7 +4216,7 @@ public void test049() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 36, line: 49]\n" +
+			"        [pc: 36, line: 51]\n" +
 			"        [pc: 39, line: 52]\n" +
 			"        [pc: 44, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4415,7 +4414,7 @@ public void test050() throws Exception {
 				"        [pc: 0, line: 46]\n" +
 				"        [pc: 7, line: 47]\n" +
 				"        [pc: 28, line: 48]\n" +
-				"        [pc: 31, line: 49]\n" +
+				"        [pc: 31, line: 51]\n" +
 				"        [pc: 34, line: 52]\n" +
 				"        [pc: 39, line: 54]\n" +
 				"      Local variable table:\n" +
@@ -4545,7 +4544,7 @@ public void test050() throws Exception {
 			"        [pc: 0, line: 46]\n" +
 			"        [pc: 7, line: 47]\n" +
 			"        [pc: 28, line: 48]\n" +
-			"        [pc: 31, line: 49]\n" +
+			"        [pc: 31, line: 51]\n" +
 			"        [pc: 34, line: 52]\n" +
 			"        [pc: 39, line: 54]\n" +
 			"      Local variable table:\n" +
@@ -4618,8 +4617,7 @@ public void test051() throws Exception {
 			"        [pc: 2, line: 8]\n" +
 			"        [pc: 4, line: 9]\n" +
 			"        [pc: 7, line: 10]\n" +
-			"        [pc: 16, line: 11]\n" +
-			"        [pc: 19, line: 13]\n" +
+			"        [pc: 16, line: 13]\n" +
 			"        [pc: 20, line: 15]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 2, pc: 22] local: count index: 0 type: int\n" +
@@ -4648,8 +4646,7 @@ public void test051() throws Exception {
 			"        [pc: 2, line: 8]\n" +
 			"        [pc: 4, line: 9]\n" +
 			"        [pc: 7, line: 10]\n" +
-			"        [pc: 16, line: 11]\n" +
-			"        [pc: 19, line: 13]\n" +
+			"        [pc: 16, line: 13]\n" +
 			"        [pc: 20, line: 15]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 2, pc: 22] local: count index: 0 type: int\n" +
@@ -4784,11 +4781,11 @@ public void test053() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
 			"        [pc: 7, line: 6]\n" +
-			"        [pc: 17, line: 7]\n" +
+			"        [pc: 14, line: 7]\n" +
 			"        [pc: 18, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 19] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 3, pc: 17] local: val index: 1 type: int\n"
+			"        [pc: 3, pc: 14] local: val index: 1 type: int\n"
 		:
 			"  // Method descriptor #15 ([Ljava/lang/String;)V\n" +
 			"  // Stack: 2, Locals: 2\n" +
@@ -4808,11 +4805,11 @@ public void test053() throws Exception {
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
 			"        [pc: 7, line: 6]\n" +
-			"        [pc: 17, line: 7]\n" +
+			"        [pc: 14, line: 7]\n" +
 			"        [pc: 18, line: 9]\n" +
 			"      Local variable table:\n" +
 			"        [pc: 0, pc: 19] local: args index: 0 type: java.lang.String[]\n" +
-			"        [pc: 3, pc: 17] local: val index: 1 type: int\n" +
+			"        [pc: 3, pc: 14] local: val index: 1 type: int\n" +
 			"      Stack map table: number of frames 3\n" +
 			"        [pc: 7, append: {int}]\n" +
 			"        [pc: 17, full, stack: {java.lang.Exception}, locals: {java.lang.String[]}]\n" +
@@ -5275,12 +5272,12 @@ public void test058() throws Exception {
 			"        [pc: 53, pc: 56] -> 34 when : any\n" +
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
-			"        [pc: 11, line: 6]\n" +
+			"        [pc: 8, line: 6]\n" +
 			"        [pc: 15, line: 8]\n" +
 			"        [pc: 17, line: 6]\n" +
 			"        [pc: 18, line: 7]\n" +
 			"        [pc: 26, line: 8]\n" +
-			"        [pc: 34, line: 9]\n" +
+			"        [pc: 31, line: 9]\n" +
 			"        [pc: 39, line: 11]\n" +
 			"        [pc: 42, line: 9]\n" +
 			"        [pc: 43, line: 10]\n" +
@@ -5321,11 +5318,11 @@ public void test058() throws Exception {
 			"        [pc: 0, pc: 33] -> 33 when : any\n" +
 			"      Line numbers:\n" +
 			"        [pc: 0, line: 5]\n" +
-			"        [pc: 11, line: 6]\n" +
+			"        [pc: 8, line: 6]\n" +
 			"        [pc: 12, line: 7]\n" +
 			"        [pc: 20, line: 8]\n" +
 			"        [pc: 22, line: 7]\n" +
-			"        [pc: 33, line: 9]\n" +
+			"        [pc: 30, line: 9]\n" +
 			"        [pc: 34, line: 10]\n" +
 			"        [pc: 42, line: 11]\n" +
 			"        [pc: 44, line: 10]\n" +
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
index ce3da94..254d50f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java
@@ -103,7 +103,6 @@ public class AND_AND_Expression extends BinaryExpression {
 				codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			codeStream.recordPositionsFrom(pc, this.sourceStart);
 			return;
 		}
@@ -147,11 +146,9 @@ public class AND_AND_Expression extends BinaryExpression {
 		if (valueRequired) {
 			if (leftIsConst && !leftIsTrue) {
 				codeStream.iconst_0();
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			} else {
 				if (rightIsConst && !rightIsTrue) {
 					codeStream.iconst_0();
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 				} else {
 					codeStream.iconst_1();
 				}
@@ -173,7 +170,7 @@ public class AND_AND_Expression extends BinaryExpression {
 				}
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 		} else {
 			falseLabel.place();
 		}
@@ -229,7 +226,7 @@ public class AND_AND_Expression extends BinaryExpression {
 							valueRequired && !rightIsConst);
 					if (valueRequired && rightIsConst && rightIsTrue) {
 						codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 					}
 					internalFalseLabel.place();
 				}
@@ -238,9 +235,12 @@ public class AND_AND_Expression extends BinaryExpression {
 				if (trueLabel == null) {
 					this.left.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, !leftIsConst);
 					// need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
+					int pc = codeStream.position;
 					if (leftIsConst && !leftIsTrue) {
-						if (valueRequired) codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						if (valueRequired) {
+							codeStream.goto_(falseLabel);
+						}
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 						break generateOperands; // no need to generate right operand
 					}
 					if (this.rightInitStateIndex != -1) {
@@ -250,7 +250,7 @@ public class AND_AND_Expression extends BinaryExpression {
 					this.right.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, valueRequired && !rightIsConst);
 					if (valueRequired && rightIsConst && !rightIsTrue) {
 						codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 					}
 				} else {
 					// no implicit fall through TRUE/FALSE --> should never occur
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
index 98af10a..92200be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
@@ -669,7 +669,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x > 0
@@ -691,7 +691,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -719,7 +719,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 						codeStream.ifgt(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -742,7 +742,7 @@ public void generateOptimizedGreaterThan(BlockScope currentScope, CodeStream cod
 						codeStream.ifle(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -777,7 +777,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x >= 0
@@ -799,7 +799,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -827,7 +827,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 						codeStream.ifge(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -850,7 +850,7 @@ public void generateOptimizedGreaterThanOrEqual(BlockScope currentScope, CodeStr
 						codeStream.iflt(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -884,7 +884,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 					}
 				}
 			}
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x < 0
@@ -905,7 +905,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 					}
 				}
 			}
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -932,7 +932,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 						codeStream.dcmpg();
 						codeStream.iflt(trueLabel);
 				}
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -954,7 +954,7 @@ public void generateOptimizedLessThan(BlockScope currentScope, CodeStream codeSt
 						codeStream.dcmpg();
 						codeStream.ifge(falseLabel);
 				}
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -989,7 +989,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 		// x <= 0
@@ -1011,7 +1011,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 				}
 			}
 			// reposition the endPC
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			return;
 		}
 	}
@@ -1039,7 +1039,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 						codeStream.ifle(trueLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			}
 		} else {
@@ -1062,7 +1062,7 @@ public void generateOptimizedLessThanOrEqual(BlockScope currentScope, CodeStream
 						codeStream.ifgt(falseLabel);
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				return;
 			} else {
 				// no implicit fall through TRUE/FALSE --> should never occur
@@ -1090,7 +1090,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 					codeStream.iconst_0();
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1107,7 +1107,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 					codeStream.iconst_0();
 				}
 				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1118,8 +1118,7 @@ public void generateLogicalAnd(BlockScope currentScope, CodeStream codeStream, b
 	if (valueRequired) {
 		codeStream.iand();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1136,8 +1135,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 				if (valueRequired) {
 					codeStream.iconst_1();
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// <something equivalent to false> | x
 				this.left.generateCode(currentScope, codeStream, false);
@@ -1153,8 +1151,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 				if (valueRequired) {
 					codeStream.iconst_1();
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// x | <something equivalent to false>
 				this.left.generateCode(currentScope, codeStream, valueRequired);
@@ -1169,8 +1166,7 @@ public void generateLogicalOr(BlockScope currentScope, CodeStream codeStream, bo
 	if (valueRequired) {
 		codeStream.ior();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1189,7 +1185,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 				this.right.generateCode(currentScope, codeStream, valueRequired);
 				if (valueRequired) {
 					codeStream.ixor(); // negate
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				}
 			} else {
 				// <something equivalent to false> ^ x
@@ -1206,7 +1202,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 				if (valueRequired) {
 					codeStream.iconst_1();
 					codeStream.ixor(); // negate
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 				}
 			} else {
 				// x ^ <something equivalent to false>
@@ -1222,8 +1218,7 @@ public void generateLogicalXor(BlockScope currentScope,	CodeStream codeStream, b
 	if (valueRequired) {
 		codeStream.ixor();
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1267,8 +1262,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 						codeStream.goto_(falseLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1309,8 +1303,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 						codeStream.goto_(falseLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			}
 			return;
 		}
@@ -1334,8 +1327,7 @@ public void generateOptimizedLogicalAnd(BlockScope currentScope, CodeStream code
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1366,8 +1358,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 						codeStream.goto_(trueLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// <something equivalent to false> | x
 				this.left.generateOptimizedBoolean(
@@ -1407,8 +1398,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 						codeStream.goto_(trueLabel);
 					}
 				}
-				// reposition the endPC
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 			} else {
 				// x | <something equivalent to false>
 				this.left.generateOptimizedBoolean(
@@ -1446,8 +1436,7 @@ public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeS
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 /**
@@ -1540,8 +1529,7 @@ public void generateOptimizedLogicalXor(BlockScope currentScope, CodeStream code
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+	codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 }
 
 public void generateOptimizedStringConcatenation(BlockScope blockScope, CodeStream codeStream, int typeID) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
index 2dd5580..47e5c9f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
@@ -21,7 +21,6 @@ import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.InitializationFlowContext;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
@@ -187,7 +186,7 @@ public class Clinit extends AbstractMethodDeclaration {
 		}
 		// generate static fields/initializers/enum constants
 		final FieldDeclaration[] fieldDeclarations = declaringType.fields;
-		BlockScope lastInitializerScope = null;
+		int sourcePosition = -1;
 		int remainingFieldCount = 0;
 		if (TypeDeclaration.kind(declaringType.modifiers) == TypeDeclaration.ENUM_DECL) {
 			int enumCount = declaringType.enumConstantsCounter;
@@ -263,7 +262,7 @@ public class Clinit extends AbstractMethodDeclaration {
 								break;
 							}
 							remainingFieldCount--;
-							lastInitializerScope = ((Initializer) fieldDecl).block.scope;
+							sourcePosition = ((Initializer) fieldDecl).block.sourceEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 						case AbstractVariableDeclaration.FIELD :
@@ -271,7 +270,7 @@ public class Clinit extends AbstractMethodDeclaration {
 								break;
 							}
 							remainingFieldCount--;
-							lastInitializerScope = null;
+							sourcePosition = fieldDecl.declarationEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 					}
@@ -285,13 +284,13 @@ public class Clinit extends AbstractMethodDeclaration {
 						case AbstractVariableDeclaration.INITIALIZER :
 							if (!fieldDecl.isStatic())
 								break;
-							lastInitializerScope = ((Initializer) fieldDecl).block.scope;
+							sourcePosition = ((Initializer) fieldDecl).block.sourceEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 						case AbstractVariableDeclaration.FIELD :
 							if (!fieldDecl.binding.isStatic())
 								break;
-							lastInitializerScope = null;
+							sourcePosition = fieldDecl.declarationEnd;
 							fieldDecl.generateCode(staticInitializerScope, codeStream);
 							break;
 					}
@@ -311,9 +310,9 @@ public class Clinit extends AbstractMethodDeclaration {
 			if ((this.bits & ASTNode.NeedFreeReturn) != 0) {
 				int before = codeStream.position;
 				codeStream.return_();
-				if (lastInitializerScope != null) {
+				if (sourcePosition != -1) {
 					// expand the last initializer variables to include the trailing return
-					codeStream.updateLastRecordedEndPC(lastInitializerScope, before);
+					codeStream.recordPositionsFrom(before, sourcePosition);
 				}
 			}
 			// Record the end of the clinit: point to the declaration of the class
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 5907c61..75dce2a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -229,7 +229,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				// Jump over the else part
 				int position = codeStream.position;
 				codeStream.goto_(endifLabel);
-				codeStream.updateLastRecordedEndPC(currentScope, position);
+				codeStream.recordPositionsFrom(position, this.valueIfTrue.sourceEnd);
 				// Tune codestream stack size
 				if (valueRequired) {
 					switch(this.resolvedType.id) {
@@ -285,6 +285,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		BranchLabel falseLabel,
 		boolean valueRequired) {
 
+		int pc = codeStream.position;
+
 		if ((this.constant != Constant.NotAConstant) && (this.constant.typeID() == T_boolean) // constant
 			|| ((this.valueIfTrue.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) != T_boolean) { // non boolean values
 			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
@@ -342,7 +344,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 					}
 					int position = codeStream.position;
 					codeStream.goto_(endifLabel);
-					codeStream.updateLastRecordedEndPC(currentScope, position);
+					codeStream.recordPositionsFrom(position, this.valueIfTrue.sourceEnd);
 				}
 				// No need to decrement codestream stack size
 				// since valueIfTrue was already consumed by branch bytecode
@@ -364,7 +366,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 		}
 		// no implicit conversion for boolean values
-		codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 
 	public int nullStatus(FlowInfo flowInfo) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 0a1d870..6e4a013 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -376,6 +376,7 @@ public class EqualExpression extends BinaryExpression {
 		// default case
 		this.left.generateCode(currentScope, codeStream, valueRequired);
 		this.right.generateCode(currentScope, codeStream, valueRequired);
+		int pc = codeStream.position;
 		if (valueRequired) {
 			if (falseLabel == null) {
 				if (trueLabel != null) {
@@ -391,8 +392,7 @@ public class EqualExpression extends BinaryExpression {
 				}
 			}
 		}
-		// reposition the endPC
-		codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 	/**
 	 * Boolean generation for == with non-boolean operands
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index f04641e..e585a58 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -704,8 +704,7 @@ public void generateOptimizedBoolean(BlockScope currentScope, CodeStream codeStr
 			}
 		}
 	}
-	// reposition the endPC
-	codeStream.updateLastRecordedEndPC(currentScope, position);
+	codeStream.recordPositionsFrom(position, this.sourceEnd);
 }
 
 /* Optimized (java) code generation for string concatenations that involve StringBuffer
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 5545720..8fc6094 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -193,8 +193,8 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 				this.thenStatement.branchChainTo(endifLabel);
 				int position = codeStream.position;
 				codeStream.goto_(endifLabel);
-				//goto is tagged as part of the thenAction block
-				codeStream.updateLastRecordedEndPC((this.thenStatement instanceof Block) ? ((Block) this.thenStatement).scope : currentScope, position);
+				//goto is pointing to the last line of the thenStatement
+				codeStream.recordPositionsFrom(position, this.thenStatement.sourceEnd);
 				// generate else statement
 			}
 			// May loose some local variable initializations : affecting the local variable attributes
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 4b3fca4..443391d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -108,7 +108,6 @@ public class OR_OR_Expression extends BinaryExpression {
 				codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
 			codeStream.recordPositionsFrom(pc, this.sourceStart);
 			return;
 		}
@@ -152,11 +151,11 @@ public class OR_OR_Expression extends BinaryExpression {
 		if (valueRequired) {
 			if (leftIsConst && leftIsTrue) {
 				codeStream.iconst_1();
-				codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 			} else {
 				if (rightIsConst && rightIsTrue) {
 					codeStream.iconst_1();
-					codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+					codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 				} else {
 					codeStream.iconst_0();
 				}
@@ -178,7 +177,7 @@ public class OR_OR_Expression extends BinaryExpression {
 				}
 			}
 			codeStream.generateImplicitConversion(this.implicitConversion);
-			codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+			codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 		} else {
 			trueLabel.place();
 		}
@@ -222,7 +221,7 @@ public class OR_OR_Expression extends BinaryExpression {
 					// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
 					if (leftIsTrue) {
 						if (valueRequired) codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.left.sourceEnd);
 						break generateOperands; // no need to generate right operand
 					}
 					if (this.rightInitStateIndex != -1) {
@@ -231,7 +230,7 @@ public class OR_OR_Expression extends BinaryExpression {
 					this.right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, valueRequired && !rightIsConst);
 					if (valueRequired && rightIsTrue) {
 						codeStream.goto_(trueLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(codeStream.position, this.sourceEnd);
 					}
 				}
 			} else {
@@ -249,9 +248,10 @@ public class OR_OR_Expression extends BinaryExpression {
 								.addDefinitelyAssignedVariables(currentScope, this.rightInitStateIndex);
 					}
 					this.right.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, valueRequired && !rightIsConst);
+					int pc = codeStream.position;
 					if (valueRequired && rightIsConst && !rightIsTrue) {
 						codeStream.goto_(falseLabel);
-						codeStream.updateLastRecordedEndPC(currentScope, codeStream.position);
+						codeStream.recordPositionsFrom(pc, this.sourceEnd);
 					}
 					internalTrueLabel.place();
 				} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index 0a2f27e..eaede3c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -381,7 +381,7 @@ public class SwitchStatement extends Statement {
 				} else {
 					codeStream.lookupswitch(defaultLabel, this.constants, sortedIndexes, caseLabels);
 				}
-				codeStream.updateLastRecordedEndPC(this.scope, codeStream.position);
+				codeStream.recordPositionsFrom(codeStream.position, this.expression.sourceEnd);
 			} else if (valueRequired) {
 				codeStream.pop();
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 7a3401b..0648e5b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -670,7 +670,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 					codeStream.goto_(this.subRoutineStartLabel);
 					break;
 			}
-			codeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);
+			codeStream.recordPositionsFrom(position, this.tryBlock.sourceEnd);
 			//goto is tagged as part of the try block
 		}
 		/* generate sequence of handler, all starting by storing the TOS (exception
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 402d644..ac7bbe9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -6652,46 +6652,6 @@ public String toString() {
 	buffer.append(")"); //$NON-NLS-1$
 	return buffer.toString();
 }
-
-/**
- * Note: it will walk the locals table and extend the end range for all matching ones, no matter if
- * visible or not.
- * {  int i = 0;
- *    {  int j = 1; }
- * }   <== would process both 'i' and 'j'
- * Processing non-visible ones is mandated in some cases (include goto instruction after if-then block)
- */
-public void updateLastRecordedEndPC(Scope scope, int pos) {
-
-	/* Tune positions in the table, this is due to some
-	 * extra bytecodes being
-	 * added to some user code (jumps). */
-	/** OLD CODE
-		if (!generateLineNumberAttributes)
-			return;
-		pcToSourceMap[pcToSourceMapSize - 1][1] = position;
-		// need to update the initialization endPC in case of generation of local variable attributes.
-		updateLocalVariablesAttribute(pos);
-	*/
-
-	if ((this.generateAttributes & ClassFileConstants.ATTR_LINES) != 0) {
-		this.lastEntryPC = pos;
-	}
-	// need to update the initialization endPC in case of generation of local variable attributes.
-	if ((this.generateAttributes & (ClassFileConstants.ATTR_VARS
-			| ClassFileConstants.ATTR_STACK_MAP_TABLE
-			| ClassFileConstants.ATTR_STACK_MAP)) != 0) {
-		for (int i = 0, max = this.locals.length; i < max; i++) {
-			LocalVariableBinding local = this.locals[i];
-			if (local != null && local.declaringScope == scope && local.initializationCount > 0) {
-				if (local.initializationPCs[((local.initializationCount - 1) << 1) + 1] == pos) {
-					local.initializationPCs[((local.initializationCount - 1) << 1) + 1] = this.position;
-				}
-			}
-		}
-	}
-}
-
 protected void writePosition(BranchLabel label) {
 	int offset = label.position - this.position + 1;
 	if (Math.abs(offset) > 0x7FFF && !this.wideMode) {
