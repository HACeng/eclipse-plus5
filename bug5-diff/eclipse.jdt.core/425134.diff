commit aacce274176303cc524a6360232ca1201922c452
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Mon Mar 3 19:57:56 2014 +0530

    Fixed Bug 425134 - [1.8][model] Implement IJavaElements for lambda
    expression

3	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
6	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
45	45	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
7	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
20	20	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
6	13	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
7	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
141	286	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
153	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
0	107	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaTypeElementInfo.java
6	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java
20	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
68	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
11	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
0	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMethod.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
12	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
index 55c3979..24e2c84 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java
@@ -27,6 +27,7 @@ import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.internal.compiler.ExtraFlags;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
+import org.eclipse.jdt.internal.core.LambdaExpression;
 import org.eclipse.jdt.internal.core.Member;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.SourceRefElement;
@@ -529,10 +530,10 @@ public class AbstractJavaSearchTests extends ModifyingResourceTests implements I
 			} else {
 				this.line.append(typeName);
 			}
-			if (isLocal) {
+			if (isLocal && !(type instanceof LambdaExpression)) { // don't want occurrence counts for lambdas. it can be confusing at best, as not all are built.
 				this.line.append("#");
 				this.line.append(((SourceRefElement)type).occurrenceCount);
-			}
+			} 
 		}
 		protected IJavaElement getElement(SearchMatch searchMatch) {
 			return (IJavaElement) searchMatch.getElement();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
index e1574a2..245be7e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/HierarchyOnWorkingCopiesTests.java
@@ -345,12 +345,12 @@ public void test400905b() throws CoreException, IOException {
 			ITypeHierarchy h = type.newTypeHierarchy(null);  // no working copies explicitly passed, should still honor primary working copies.
 
 			assertHierarchyEquals(
-					"Focus: I [in [Working copy] A.java [in x.y [in src [in P]]]]\n" + 
-					"Super types:\n" + 
-					"Sub types:\n" + 
-					"  <lambda> [in i [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-					"  <lambda>#2 [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
-					"  <lambda>#3 [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
+							"Focus: I [in [Working copy] A.java [in x.y [in src [in P]]]]\n" + 
+							"Super types:\n" + 
+							"Sub types:\n" + 
+							"  Lambda(I) [in i [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n" + 
+							"  Lambda(I) [in main(String[]) [in X [in [Working copy] A.java [in x.y [in src [in P]]]]]]\n",
 				h);
 		} finally {
 			primaryCu.discardWorkingCopy();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
index 0720d32..133a889 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
@@ -2444,8 +2444,8 @@ public void testBug400905_0001() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/X.java int b400905.I.foo() [foo] EXACT_MATCH\n" +
-			"src/b400905/X.java int void b400905.X.main(String[]):<lambda>#1.lambda$1() [() ->] EXACT_MATCH\n" +			
-			"src/b400905/X.java int void b400905.X.doit():<lambda>#2.lambda$2() [() ->] EXACT_MATCH");	
+			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [() ->] EXACT_MATCH\n" +			
+			"src/b400905/X.java int void b400905.X.doit():Lambda(I).foo() [() ->] EXACT_MATCH");	
 }
 /**
  * @bug 400905
@@ -2485,10 +2485,10 @@ public void testBug400905_0002() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/I.java int b400905.I.foo() [foo] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):<lambda>#1.lambda$1() [() ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):<lambda>#2.lambda$2() [()  ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int void b400905.X.main(String[]):<lambda>#3.lambda$3() [()->] EXACT_MATCH\n" + 
-			"src/b400905/X.java int I b400905.X.bar():<lambda>#4.lambda$4() [() ->] EXACT_MATCH");	
+			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [() ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [()  ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int void b400905.X.main(String[]):Lambda(I).foo() [()->] EXACT_MATCH\n" + 
+			"src/b400905/X.java int I b400905.X.bar():Lambda(I).foo() [() ->] EXACT_MATCH");	
 }
 /**
  * @bug 400905
@@ -2522,9 +2522,9 @@ public void testBug400905_0003() throws CoreException {
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
 			"src/b400905/I.java boolean b400905.I.foo(Y) [foo] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda>#1.lambda$1(b400905/Y) [y->] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda>#2.lambda$2(b400905/Y) [y ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java boolean void b400905.X.main(String[]):<lambda>#3.lambda$3(b400905/Y) [y  ->] EXACT_MATCH"
+			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905/Y) [y->] EXACT_MATCH\n" + 
+			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905/Y) [y ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java boolean void b400905.X.main(String[]):Lambda(I).foo(b400905/Y) [y  ->] EXACT_MATCH"
 	);	
 }
 /**
@@ -2558,11 +2558,11 @@ public void testBug400905_0004() throws CoreException {
 	IMethod method = type.getMethod("foo", new String[] {});
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-			"src/b400905/I.java T b400905.I.foo() [foo] EXACT_MATCH\n" + 
-			"src/b400905/X.java b400905/Y void b400905.X.main(String[]):<lambda>#1.lambda$1() [() /* foo */ ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java b400905/Y void b400905.X.main(String[]):<lambda>#3.lambda$3() [() /* true */->] EXACT_MATCH\n" + 
-			"src/b400905/X.java b400905/Y void b400905.X.main(String[]):<lambda>#4.lambda$4() [() /* false */ ->] EXACT_MATCH\n" + 
-			"src/b400905/X.java java/lang/Object void b400905.X.main(String[]):<lambda>#5.lambda$5() [() /* cast */ ->] EXACT_MATCH"
+					"src/b400905/I.java T b400905.I.foo() [foo] EXACT_MATCH\n" + 
+					"src/b400905/X.java b400905/Y void b400905.X.main(String[]):Lambda(I).foo() [() /* foo */ ->] EXACT_MATCH\n" + 
+					"src/b400905/X.java b400905/Y void b400905.X.main(String[]):Lambda(I).foo() [() /* true */->] EXACT_MATCH\n" + 
+					"src/b400905/X.java b400905/Y void b400905.X.main(String[]):Lambda(I).foo() [() /* false */ ->] EXACT_MATCH\n" + 
+					"src/b400905/X.java java/lang/Object void b400905.X.main(String[]):Lambda(I).foo() [() /* cast */ ->] EXACT_MATCH"
 	);	
 }
 /**
@@ -2595,8 +2595,8 @@ public void testBug400905_0005() throws CoreException {
 	IMethod method = type.getMethod("bar", new String[] {});
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-			"src/b400905/X.java void b400905/Y void b400905.X.main(String[]):<lambda>#1.lambda$1():<lambda>#2.lambda$2() [() /* bar */ ->] EXACT_MATCH\n" + 
-			"src/b400905/Y.java void b400905.Y.bar() [bar] EXACT_MATCH"
+					"src/b400905/X.java void b400905/Y void b400905.X.main(String[]):Lambda(I).foo():Lambda(Y).bar() [() /* bar */ ->] EXACT_MATCH\n" + 
+					"src/b400905/Y.java void b400905.Y.bar() [bar] EXACT_MATCH"
 	);	
 }
 /**
@@ -2633,8 +2633,8 @@ public void testBug400905_0006() throws CoreException {
 		IMethod method = getCompilationUnit("/P/src/I.java").getType("I").getMethod("foo", new String[0]);
 		search(method, DECLARATIONS, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
 		assertSearchResults(
-				"src/I.java void I.foo() [foo] EXACT_MATCH\n" + 
-				"src/X.java void void X.main(String[]):<lambda>#1.lambda$1() [()->] EXACT_MATCH"
+						"src/I.java void I.foo() [foo] EXACT_MATCH\n" + 
+						"src/X.java void void X.main(String[]):Lambda(I).foo() [()->] EXACT_MATCH"
 		);
 	}
 	finally {
@@ -2876,7 +2876,7 @@ public void testBug400905_0012() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java void I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java void X.i:<lambda>#1.lambda$1() [() ->] EXACT_MATCH\n" + 
+				"src/X.java void X.i:Lambda(I).doit() [() ->] EXACT_MATCH\n" + 
 				"src/X.java void X.i2:<anonymous>#1.doit() [doit] EXACT_MATCH");
 	}
 	finally {
@@ -2911,7 +2911,7 @@ public void testBug400905_0013() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1() [() ->] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit() [() ->] EXACT_MATCH\n" + 
 				"src/X.java int void X.zoo():<anonymous>#1.doit() [doit] EXACT_MATCH");
 	}
 	finally {
@@ -2945,8 +2945,8 @@ public void testBug400905_0013a() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[0]);
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit() [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1() [() /*1*/->] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():<lambda>#1.lambda$1():<lambda>#2.lambda$2() [() /*2*/->] EXACT_MATCH");
+				"src/X.java int void X.zoo():Lambda(I).doit() [() /*1*/->] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():Lambda(I).doit():Lambda(I).doit() [() /*2*/->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -2977,8 +2977,8 @@ public void testBug400905_0013b() throws CoreException {
 		
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
-		assertSearchResults("src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+		assertSearchResults("src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3009,8 +3009,8 @@ public void testBug400905_0013c() throws CoreException {
 		
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {type}), this.resultCollector);
-		assertSearchResults("src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+		assertSearchResults("src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3042,8 +3042,8 @@ public void testBug400905_0013d() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3078,9 +3078,9 @@ public void testBug400905_0013e() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X):Q#1.x [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3116,10 +3116,10 @@ public void testBug400905_0013f() throws CoreException {
 		IType type = getCompilationUnit("/P/src/X.java").getType("X");
 		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X):Q#1.x [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+				"src/X.java int int void X.zoo():Lambda(I).doit(X):Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():Lambda(I).doit(X) [X] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3152,7 +3152,7 @@ public void testBug400905_0014() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[] {"I"});
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(int) [doit] EXACT_MATCH\n" + 
-							"src/X.java int void X.zoo():<lambda>#1.lambda$1(int) [(x) ->] EXACT_MATCH");
+							"src/X.java int void X.zoo():Lambda(I).doit(int) [(x) ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3231,7 +3231,7 @@ public void testBug400905_0016() throws CoreException {
 		IMethod method = type.getMethod("doit", new String[] {"I"});
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/I.java int I.doit(int) [doit] EXACT_MATCH\n" + 
-				"src/X.java int void X.zoo():<lambda>#2.lambda$2(int) [(x) ->] EXACT_MATCH");
+				"src/X.java int void X.zoo():Lambda(I).doit(int) [(x) ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3259,7 +3259,7 @@ public void testBug400905_0017() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/Function.java R Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/Y.java java/lang/Object Function<I,R> Collectors.castingIdentity():<lambda>#1.lambda$1(java/lang/Object) [i ->] EXACT_MATCH");
+				"src/Y.java java/lang/Object Function<I,R> Collectors.castingIdentity():Lambda(Function).apply(java/lang/Object) [i ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3287,7 +3287,7 @@ public void testBug400905_0018() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/Function.java R Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/Y.java java/lang/String Function<String,String> Collectors.castingIdentity():<lambda>#1.lambda$1(java/lang/String) [i ->] EXACT_MATCH");
+				"src/Y.java java/lang/String Function<String,String> Collectors.castingIdentity():Lambda(Function).apply(java/lang/String) [i ->] EXACT_MATCH");
 	}
 	finally {
 		deleteProject("P");
@@ -3361,7 +3361,7 @@ public void testBug400905_0021() throws CoreException {
 		IMethod method = type.getMethods()[0];
 		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
 		assertSearchResults("src/p400905/Function.java R p400905.Function.apply(T) [apply] EXACT_MATCH\n" + 
-				"src/p400905/Collectors.java java/lang/Object Function<I,R> p400905.Collectors.castingIdentity():<lambda>#1.lambda$1(java/lang/Object) [i ->] EXACT_MATCH");
+				"src/p400905/Collectors.java java/lang/Object Function<I,R> p400905.Collectors.castingIdentity():Lambda(Function).apply(java/lang/Object) [i ->] EXACT_MATCH");
 	} finally { 
 		deleteFolder(path);
 	}
@@ -3385,7 +3385,7 @@ public void testBug400905_0022() throws CoreException {
 	search("thrice", METHOD, DECLARATIONS, ERASURE_RULE, getJavaSearchScope(), this.resultCollector);
 	assertSearchResults(
 			"src/test/Test.java int test.FunctionalInterface.thrice(int) [thrice] EXACT_MATCH\n" + 
-			"src/test/Test.java int test.X.i:<lambda>#1.lambda$1(int) [(x) ->] EXACT_MATCH"
+			"src/test/Test.java int test.X.i:Lambda(FunctionalInterface).thrice(int) [(x) ->] EXACT_MATCH"
 	);
 }
 public void testBug400905_0023() throws CoreException {
@@ -3419,10 +3419,10 @@ public void testBug400905_0023() throws CoreException {
 	);
 	search("thrice", METHOD, DECLARATIONS, ERASURE_RULE, getJavaSearchScope(), this.resultCollector);
 	assertSearchResults(
-			"src/test/Test.java int test.I.thrice(int) [thrice] EXACT_MATCH\n" + 
-			"src/test/Test.java int test.X.i:<lambda>#1.lambda$1(int) [(x) /* field */ ->] EXACT_MATCH\n" + 
-			"src/test/Test.java int void test.X.main(String[]):<lambda>#2.lambda$2(int) [(x) /*call*/ ->] EXACT_MATCH\n" + 
-			"src/test/Test.java int void test.X.main(String[]):<lambda>#3.lambda$3(int) [(x) /* local */ ->] EXACT_MATCH"
+					"src/test/Test.java int test.I.thrice(int) [thrice] EXACT_MATCH\n" + 
+					"src/test/Test.java int test.X.i:Lambda(I).thrice(int) [(x) /* field */ ->] EXACT_MATCH\n" + 
+					"src/test/Test.java int void test.X.main(String[]):Lambda(I).thrice(int) [(x) /*call*/ ->] EXACT_MATCH\n" + 
+					"src/test/Test.java int void test.X.main(String[]):Lambda(I).thrice(int) [(x) /* local */ ->] EXACT_MATCH"
 	);
 }
 public void testBug400905_0024() throws CoreException {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
index 3222bb9..136cd73 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -251,7 +255,7 @@ public void testBinaryMethodMemento4() throws JavaModelException {
 	IType type = getClassFile("/P/lib/p/X.class").getType();
 	IMethod method = type.getMethod("foo", new String[] {"Ljava.util.Collection<*>;"});
 	assertMemento(
-		"=P/lib<p(X.class[X~foo~Ljava.util.Collection\\<*>;",
+		"=P/lib<p(X.class[X~foo~Ljava.util.Collection\\<\\*\\>;",
 		method);
 }
 
@@ -382,7 +386,7 @@ public void testImportDeclarationMemento() {
 
 	importDecl = getCompilationUnit("/P/src/p/X.java").getImport("java.util.*");
 	assertMemento(
-		"=P/src<p{X.java#java.util.*",
+		"=P/src<p{X.java#java.util.\\*",
 		importDecl);
 }
 /*
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
index e8c3451..378067d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
@@ -718,7 +718,7 @@ public void test0024() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"xyz [in foo(int) [in Lambda(I) [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -743,7 +743,7 @@ public void test0025() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"abc [in foo(int) [in Lambda(I) [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -766,7 +766,7 @@ public void test0026() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"abc [in foo(int) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -794,7 +794,7 @@ public void test0027() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"abc [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"abc [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
 		elements
 	);
 }
@@ -822,7 +822,7 @@ public void test0028() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"xyz [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -888,7 +888,7 @@ public void test0030() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"zyx [in fx [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"zyx [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in fx [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -921,7 +921,7 @@ public void test0031() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"xyz [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"xyz [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -956,7 +956,7 @@ public void test0032() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"hij [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"hij [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -992,7 +992,7 @@ public void test0033() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"hij [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"hij [in doit(I) [in Lambda(I) [in doit(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1431,7 +1431,7 @@ public void testFieldInit() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"first [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"first [in foo(int, int) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1454,7 +1454,7 @@ public void test422468() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"first [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"first [in foo(X, java/lang/Object) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1477,7 +1477,7 @@ public void test422468a() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"second [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"second [in foo(X, java/lang/Object) [in Lambda(I) [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1503,7 +1503,7 @@ public void test422468b() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"y [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"y [in foo(I) [in Lambda(I) [in foo(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1529,7 +1529,7 @@ public void test422468c() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"y [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"y [in foo(I) [in Lambda(I) [in foo(I) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]",
 		elements
 	);
 }
@@ -1593,7 +1593,7 @@ public void test422468e() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"q [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"q [in foo(java/lang/String, int) [in Lambda(K) [in foo(java/lang/String, java/lang/String) [in Lambda(J) [in foo(java/lang/String, java/lang/String) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]]]]]",
 		elements
 	);
 }
@@ -1628,7 +1628,7 @@ public void testParser() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"x [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"x [in foo(java/lang/String, java/lang/Integer) [in Lambda(I) [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements
 	);
 }
@@ -1787,7 +1787,7 @@ public void test424198() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"v1 [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"v1 [in apply(java/lang/String) [in Lambda(Function) [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1852,7 +1852,7 @@ public void test424198a() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"v2 [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"v2 [in apply(java/lang/String) [in Lambda(Function) [in processJar(Path) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1917,7 +1917,7 @@ public void test424198b() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"s1 [in withWildcard(Stream<? extends String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"s1 [in accept(java/lang/String) [in Lambda(Consumer) [in withWildcard(Stream<? extends String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
@@ -1982,7 +1982,7 @@ public void test424198c() throws JavaModelException {
 	IJavaElement[] elements = this.wc.codeSelect(start, length);
 	assertElementsEqual(
 		"Unexpected elements",
-		"s2 [in withoutWildcard(Stream<String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		"s2 [in accept(java/lang/String) [in Lambda(Consumer) [in withoutWildcard(Stream<String>) [in InsistentCapture [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]]]",
 		elements,
 		true
 	);
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index c769f11..d4252b3 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -977,7 +977,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 									System.out.println(e.binding.toString());
 								}
 								// if null then we found a problem in the selection node
-								selectFrom(e.binding, parsedUnit, e.isDeclaration);
+								selectFrom(e.binding, parsedUnit, sourceUnit, e.isDeclaration);
 							}
 						}
 					}
@@ -1082,6 +1082,9 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 	}
 
 	private void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, boolean isDeclaration) {
+		selectFrom(binding, parsedUnit, null, isDeclaration);
+	}
+	private void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, ICompilationUnit unit, boolean isDeclaration) {
 		if(binding instanceof TypeVariableBinding) {
 			TypeVariableBinding typeVariableBinding = (TypeVariableBinding) binding;
 			Binding enclosingElement = typeVariableBinding.declaringElement;
@@ -1262,7 +1265,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 			}
 		} else if (binding instanceof LocalVariableBinding) {
 			if (this.requestor instanceof SelectionRequestor) {
-				((SelectionRequestor)this.requestor).acceptLocalVariable((LocalVariableBinding)binding);
+				((SelectionRequestor)this.requestor).acceptLocalVariable((LocalVariableBinding)binding, unit);
 				this.acceptedAnswer = true;
 			} else {
 				// open on the type of the variable
@@ -1381,15 +1384,6 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				typeName = Signature.toCharArray(typeSig);
 			}
 
-			// find the outer most type
-			IType outerType = context;
-			IType parent = context.getDeclaringType();
-			while (parent != null) {
-				outerType = parent;
-				parent = parent.getDeclaringType();
-			}
-
-			// compute parse tree for this most outer type
 			CompilationUnitDeclaration parsedUnit = null;
 			TypeDeclaration typeDeclaration = null;
 			org.eclipse.jdt.core.ICompilationUnit cu = context.getCompilationUnit();
@@ -1400,8 +1394,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 			 	for (int i = 0; i < length; i++) {
 					topLevelInfos[i] = (SourceTypeElementInfo) ((SourceType)topLevelTypes[i]).getElementInfo();
 				}
-				ISourceType outerTypeInfo = (ISourceType) ((SourceType) outerType).getElementInfo();
-				CompilationResult result = new CompilationResult(outerTypeInfo.getFileName(), 1, 1, this.compilerOptions.maxProblemsPerUnit);
+				CompilationResult result = new CompilationResult((org.eclipse.jdt.internal.compiler.env.ICompilationUnit) cu, 1, 1, this.compilerOptions.maxProblemsPerUnit);
 				int flags = SourceTypeConverter.FIELD_AND_METHOD | SourceTypeConverter.MEMBER_TYPE;
 				if (context.isAnonymous() || context.isLocal())
 					flags |= SourceTypeConverter.LOCAL_TYPE;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 14ff33f..03497b6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -95,7 +95,7 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 public class LambdaExpression extends FunctionalExpression implements ReferenceContext, ProblemSeverities {
 	public Argument [] arguments;
 	private TypeBinding [] argumentTypes;
-	private int arrowPosition;
+	public int arrowPosition;
 	public Statement body;
 	public boolean hasParentheses;
 	public MethodScope scope;
@@ -1231,6 +1231,10 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			public ReferenceBinding[] superInterfaces() {
 				return new ReferenceBinding[] { (ReferenceBinding) LambdaExpression.this.resolvedType };
 			}
+			@Override
+			public char[] computeUniqueKey() {
+				return LambdaExpression.this.descriptor.declaringClass.computeUniqueKey();
+			}
 			public String toString() {
 				StringBuffer output = new StringBuffer("()->{} implements "); //$NON-NLS-1$
 				output.append(LambdaExpression.this.descriptor.declaringClass.sourceName());
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
index 6987c00..a2e82a2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java
@@ -69,6 +69,10 @@ public abstract class JavaElement extends PlatformObject implements IJavaElement
 	public static final char JEM_LOCALVARIABLE = '@';
 	public static final char JEM_TYPE_PARAMETER = ']';
 	public static final char JEM_ANNOTATION = '}';
+	public static final char JEM_LAMBDA_EXPRESSION = '>';
+	public static final char JEM_LAMBDA_METHOD = '*';
+	public static final char JEM_STRING = '"';
+	
 
 	/**
 	 * This element's parent, or <code>null</code> if this
@@ -149,6 +153,9 @@ public abstract class JavaElement extends PlatformObject implements IJavaElement
 				case JEM_LOCALVARIABLE:
 				case JEM_TYPE_PARAMETER:
 				case JEM_ANNOTATION:
+				case JEM_LAMBDA_EXPRESSION:
+				case JEM_LAMBDA_METHOD:
+				case JEM_STRING:
 					buffer.append(JEM_ESCAPE);
 			}
 			buffer.append(character);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
index c061d0a..367bcde 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java
@@ -15,329 +15,184 @@
 package org.eclipse.jdt.internal.core;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jdt.core.IAnnotation;
-import org.eclipse.jdt.core.IField;
-import org.eclipse.jdt.core.IInitializer;
 import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.ILocalVariable;
 import org.eclipse.jdt.core.IMethod;
-import org.eclipse.jdt.core.ISourceRange;
-import org.eclipse.jdt.core.IType;
-import org.eclipse.jdt.core.ITypeParameter;
 import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.SourceRange;
 import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.core.util.MementoTokenizer;
+import org.eclipse.jdt.internal.core.util.Util;
 
 public class LambdaExpression extends SourceType {
 
-	org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression;
-	SourceMethod lambdaMethod;
+	SourceTypeElementInfo elementInfo;
+	LambdaMethod lambdaMethod;
 	
+	// These fields could be materialized from elementInfo, but for ease of use stashed here 
+	protected int sourceStart;
+	protected int sourceEnd;
+	protected int arrowPosition;
+	protected String interphase;
+	
+	
+	// Construction from AST node
 	public LambdaExpression(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
-		super(parent, new String("<lambda>")); //$NON-NLS-1$
-		this.lambdaExpression = lambdaExpression;
-		this.occurrenceCount = lambdaExpression.ordinal;
+		super(parent, new String("Lambda(") + new String(lambdaExpression.descriptor.declaringClass.sourceName()) + ')'); //$NON-NLS-1$
+		this.sourceStart = lambdaExpression.sourceStart;
+		this.sourceEnd = lambdaExpression.sourceEnd;
+		this.arrowPosition = lambdaExpression.arrowPosition;
+		this.interphase = new String(lambdaExpression.descriptor.declaringClass.sourceName());
+		this.elementInfo = makeTypeElementInfo(this, this.interphase, this.sourceStart, this.sourceEnd, this.arrowPosition); 
+		this.lambdaMethod = LambdaMethod.make(this, lambdaExpression);
+		this.elementInfo.children = new IJavaElement[] { this.lambdaMethod };
 	}
 	
-	@Override
-	public String[] getCategories() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this)); // TODO: what the heck is this supposed to be ? 
-	}
-
-	@Override
-	public int getFlags() throws JavaModelException {
-		return this.lambdaExpression.binding.modifiers; // TODO
-	}
-
-	@Override
-	public ISourceRange getJavadocRange() throws JavaModelException {
-		return null;
-	}
-
-	@Override
-	public boolean isBinary() {
-		return false;
-	}
-
-	@Override
-	public Object getElementInfo() throws JavaModelException {
-		return new LambdaTypeElementInfo(this);
+	// Construction from memento
+	public LambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+		super(parent, name);
+		this.sourceStart = sourceStart;
+		this.sourceEnd = sourceEnd;
+		this.arrowPosition = arrowPosition;
+		this.interphase = interphase;
+		this.elementInfo = makeTypeElementInfo(this, interphase, this.sourceStart = sourceStart, sourceEnd, arrowPosition);
+		// Method is in the process of being fabricated, will be attached shortly.
 	}
 	
-	@Override
-	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
-		return new LambdaTypeElementInfo(this);
+	// Construction from subtypes.
+	public LambdaExpression(JavaElement parent, String name, String interphase, int sourceStart, int sourceEnd, int arrowPosition, LambdaMethod lambdaMethod) {
+		super(parent, name);
+		this.sourceStart = sourceStart;
+		this.sourceEnd = sourceEnd;
+		this.arrowPosition = arrowPosition;
+		this.interphase = interphase;
+		this.elementInfo = makeTypeElementInfo(this, interphase, this.sourceStart = sourceStart, sourceEnd, arrowPosition);
+		this.elementInfo.children = new IJavaElement[] { this.lambdaMethod = lambdaMethod };
 	}
 	
-	@Override
-	public boolean exists() {
-		return true;
-	}
-
-	@Override
-	public int getElementType() {
-		return TYPE;
-	}
-
-	@Override
-	public String getHandleIdentifier() {
-		return null; // TODO
-	}
-
-	@Override
-	public boolean isReadOnly() {
-		return true;
-	}
-
-	@Override
-	public boolean isStructureKnown() throws JavaModelException {
-		return true;
-	}
-
-	@Override
-	public String getSource() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public ISourceRange getSourceRange() throws JavaModelException {
-		return new SourceRange(this.lambdaExpression.sourceStart, this.lambdaExpression.sourceEnd - this.lambdaExpression.sourceStart + 1);
-	}
-
-	@Override
-	public ISourceRange getNameRange() throws JavaModelException {
-		return new SourceRange(this.lambdaExpression.sourceStart, this.lambdaExpression.arrowPosition() - this.lambdaExpression.sourceStart + 1);
-	}
-
-	@Override
-	public void copy(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
-			IProgressMonitor monitor) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public void delete(boolean force, IProgressMonitor monitor) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public void move(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
-			IProgressMonitor monitor) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public void rename(String newName, boolean replace, IProgressMonitor monitor) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IJavaElement[] getChildren() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public boolean hasChildren() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IAnnotation getAnnotation(String annotationName) {
-		return null;
-	}
-
-	@Override
-	public IAnnotation[] getAnnotations() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IField createField(String contents, IJavaElement sibling, boolean force, IProgressMonitor monitor)
-			throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IInitializer createInitializer(String contents, IJavaElement sibling, IProgressMonitor monitor)
-			throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IMethod createMethod(String contents, IJavaElement sibling, boolean force, IProgressMonitor monitor)
-			throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IType createType(String contents, IJavaElement sibling, boolean force, IProgressMonitor monitor)
-			throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public IMethod[] findMethods(IMethod method) {
-		return null;
-	}
-
-	@Override
-	public IJavaElement[] getChildrenForCategory(String category) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public String getElementName() {
-		return new String("<lambda>"); //$NON-NLS-1$
-	}
-
-	@Override
-	public IField getField(String fieldName) {
-		return null;
-	}
-
-	@Override
-	public IField[] getFields() throws JavaModelException {
-		return new IField[0];
-	}
-
-	@Override
-	public IInitializer getInitializer(int okkurrenceCount) {
-		return null;
-	}
-
-	@Override
-	public IInitializer[] getInitializers() throws JavaModelException {
-		return new IInitializer[0];
+	// Lambda expression is not backed by model, fabricate element information structure and stash it.
+	static private SourceTypeElementInfo makeTypeElementInfo (LambdaExpression handle, String interphase, int sourceStart, int sourceEnd, int arrowPosition) {
+		
+		SourceTypeElementInfo elementInfo = new SourceTypeElementInfo();
+		
+		elementInfo.setFlags(0);
+		elementInfo.setHandle(handle);
+		elementInfo.setSourceRangeStart(sourceStart);
+		elementInfo.setSourceRangeEnd(sourceEnd);
+		
+		elementInfo.setNameSourceStart(sourceStart);
+		elementInfo.setNameSourceEnd(arrowPosition);
+		elementInfo.setSuperclassName(null);
+		elementInfo.addCategories(handle, null);
+		
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		char[][] superinterfaces = new char [][] { manager.intern(interphase.toCharArray()) }; // drops marker interfaces - to fix.
+		elementInfo.setSuperInterfaceNames(superinterfaces);
+		return elementInfo;
 	}
-
-	@Override
-	public IMethod getMethod(String selector, String[] parameterTypeSignatures) {
-		return new SourceMethod(this, selector, parameterTypeSignatures);
+	
+	protected void closing(Object info) throws JavaModelException {
+		// nothing to do, not backed by model ATM.
 	}
 	
-	public SourceMethod getMethod() {
-		if (this.lambdaMethod != null)
-			return this.lambdaMethod;
-		
-		TypeBinding [] argv = this.lambdaExpression.argumentsTypeElided() ? this.lambdaExpression.descriptor.parameters : this.lambdaExpression.argumentTypes(); 
-		int argc = argv.length;
-		String[] parameterTypeSignatures = new String[argc];
-		for (int i = 0; i < argc; i++) {
-			parameterTypeSignatures[i] = new String(argv[i].signature());
+	public boolean equals(Object o) {
+		if (this == o)
+			return true;
+		/* I see cases where equal lambdas are dismissed as unequal on account of working copy owner.
+		   This results in spurious failures. See JavaSearchBugs8Tests.testBug400905_0021()
+		   For now exclude the working copy owner and compare
+		*/
+		if (o instanceof LambdaExpression) {
+			LambdaExpression that = (LambdaExpression) o;
+			if (this.sourceStart != that.sourceStart)
+				return false;
+			CompilationUnit thisCU = (CompilationUnit) this.getCompilationUnit();
+			CompilationUnit thatCU = (CompilationUnit) that.getCompilationUnit();
+			return thisCU.getElementName().equals(thatCU.getElementName()) && thisCU.parent.equals(thatCU.parent);
 		}
-		return this.lambdaMethod = new SourceMethod(this, new String(this.lambdaExpression.binding.selector), parameterTypeSignatures); 
-	}
-
-	@Override
-	public IMethod[] getMethods() throws JavaModelException {
-		return new IMethod[] { getMethod() };
-	}
-
-	@Override
-	public String getSuperclassName() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public String getSuperclassTypeSignature() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public String[] getSuperInterfaceTypeSignatures() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public String[] getSuperInterfaceNames() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public String[] getTypeParameterSignatures() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
-	}
-
-	@Override
-	public ITypeParameter[] getTypeParameters() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
+		return false;
 	}
-
-	@Override
-	public IType getType(String typeName) {
-		return null;
+	
+	public int hashCode() {
+		return Util.combineHashCodes(super.hashCode(), this.sourceStart);
 	}
-
-	@Override
-	public ITypeParameter getTypeParameter(String typeParameterName) {
-		return null;
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return this.elementInfo;
 	}
 
-	@Override
-	public String getTypeQualifiedName() {
-		return null;
+	protected char getHandleMementoDelimiter() {
+		return JavaElement.JEM_LAMBDA_EXPRESSION;
 	}
-
-	@Override
-	public IType[] getTypes() throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
+	
+	/*
+	 * @see JavaElement#getHandleMemento(StringBuffer)
+	 */
+	protected void getHandleMemento(StringBuffer buff) {
+		((JavaElement)getParent()).getHandleMemento(buff);
+		buff.append(getHandleMementoDelimiter());
+		escapeMementoName(buff, this.name);
+		buff.append(JEM_STRING);
+		escapeMementoName(buff, this.interphase);
+		buff.append(JEM_COUNT);
+		buff.append(this.sourceStart);
+		buff.append(JEM_COUNT);
+		buff.append(this.sourceEnd);
+		buff.append(JEM_COUNT);
+		buff.append(this.arrowPosition);
 	}
+	
+	public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner workingCopyOwner) {
 
-	@Override
-	public boolean isAnonymous() {
-		return true;
+		if (token.charAt(0) != JEM_LAMBDA_METHOD)
+			return null;
+		
+		// ----
+		if (!memento.hasMoreTokens()) return this;
+		String selector = memento.nextToken();
+		if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_COUNT) return this;
+		if (!memento.hasMoreTokens()) return this;
+		int length = Integer.parseInt(memento.nextToken());
+		String [] parameterTypes = new String[length];
+		String [] parameterNames = new String[length];
+		for (int i = 0; i < length; i++) {
+			if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;
+			parameterTypes[i] = memento.nextToken();
+			if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;
+			parameterNames[i] = memento.nextToken();
+		}
+		if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;
+		String returnType = memento.nextToken();
+		if (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;
+		String key = memento.nextToken();
+		this.lambdaMethod = LambdaMethod.make(this, selector, key, this.sourceStart, this.sourceEnd, this.arrowPosition, parameterTypes, parameterNames, returnType);
+		ILocalVariable [] parameters = new ILocalVariable[length];
+		for (int i = 0; i < length; i++) {
+			parameters[i] = (ILocalVariable) this.lambdaMethod.getHandleFromMemento(memento, workingCopyOwner);
+		}
+		this.lambdaMethod.elementInfo.arguments  = parameters;
+		this.elementInfo.children = new IJavaElement[] { this.lambdaMethod };
+		return this.lambdaMethod;
 	}
-
-	@Override
-	public boolean isClass() throws JavaModelException {
+	
+	public boolean isReadOnly() {
 		return true;
 	}
 
-	@Override
-	public boolean isEnum() throws JavaModelException {
-		return false;
-	}
-
-	@Override
-	public boolean isInterface() throws JavaModelException {
-		return false;
-	}
-
-	@Override
-	public boolean isAnnotation() throws JavaModelException {
-		return false;
+	public IJavaElement[] getChildren() throws JavaModelException {
+		return new IJavaElement[] { this.lambdaMethod };
 	}
 
-	@Override
 	public boolean isLocal() {
 		return true;
 	}
-
-	@Override
-	public boolean isMember()  {
-		return false;
-	}
-
-	@Override
-	public JavaElement resolved(Binding binding) {
-		return this;
-	}
 	
-	@Override
-	public boolean isResolved() {
-		return true;
-	}
-
-	@Override
-	public String[][] resolveType(String typeName) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
+	public JavaElement resolved(Binding binding) {
+		ResolvedLambdaExpression resolvedHandle = new ResolvedLambdaExpression(this.parent, this, new String(binding.computeUniqueKey()));
+		return resolvedHandle;
 	}
 
-	@Override
-	public String[][] resolveType(String typeName, WorkingCopyOwner owner) throws JavaModelException {
-		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.READ_ONLY, this));
+	public IMethod getMethod() {
+		return this.lambdaMethod;
 	}
-
-}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
new file mode 100644
index 0000000..9684ba6
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaMethod.java
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.ILocalVariable;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.core.util.Util;
+
+public class LambdaMethod extends SourceMethod {
+
+	private int sourceStart; // cached for ease of use in hashcode/equals.
+	private String [] parameterNameStrings;
+	private String returnTypeString;
+	SourceMethodElementInfo elementInfo;
+	private String key;
+	
+	public LambdaMethod(JavaElement parent, String name, String key, int sourceStart, String [] parameterTypes, String [] parameterNames, String returnType, SourceMethodElementInfo elementInfo) {
+		super(parent, name, parameterTypes);
+		this.sourceStart = sourceStart;
+		this.parameterNameStrings = parameterNames;
+		this.returnTypeString = returnType;
+		this.elementInfo = elementInfo;
+		this.key = key;
+	}
+	
+	public static LambdaMethod make(JavaElement parent, org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression) {
+		int length;
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		String [] parameterTypes = new String[length = lambdaExpression.descriptor.parameters.length];
+		for (int i = 0; i < length; i++)
+			parameterTypes[i] = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));
+		String [] parameterNames = new String[length];
+		for (int i = 0; i < length; i++)
+			parameterNames[i] = manager.intern(new String(lambdaExpression.arguments[i].name));
+		String returnType = manager.intern(new String(Signature.toCharArray(lambdaExpression.descriptor.returnType.signature())));
+		String selector = manager.intern(new String(lambdaExpression.descriptor.selector));
+		String key = new String(lambdaExpression.descriptor.computeUniqueKey());
+		LambdaMethod lambdaMethod = make(parent, selector, key, lambdaExpression.sourceStart, lambdaExpression.sourceEnd, lambdaExpression.arrowPosition, parameterTypes, parameterNames, returnType);
+		ILocalVariable [] parameters = new ILocalVariable[length = lambdaExpression.arguments.length];
+		for (int i = 0; i < length; i++) {
+			Argument argument = lambdaExpression.arguments[i];
+			String signature = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));
+			parameters[i] = new LocalVariable(
+					lambdaMethod,
+					new String(argument.name),
+					argument.declarationSourceStart,
+					argument.declarationSourceEnd,
+					argument.sourceStart,
+					argument.sourceEnd,
+					signature,
+					null, // we are not hooking up argument.annotations ATM,
+					argument.modifiers,
+					true);
+		}
+		lambdaMethod.elementInfo.arguments = parameters;
+		return lambdaMethod;
+	}
+	
+	public static LambdaMethod make(JavaElement parent, String selector, String key, int sourceStart, int sourceEnd, int arrowPosition, String [] parameterTypes, String [] parameterNames, String returnType) {
+		SourceMethodInfo info = new SourceMethodInfo();
+		info.setSourceRangeStart(sourceStart);
+		info.setSourceRangeEnd(sourceEnd);
+		info.setFlags(0);
+		info.setNameSourceStart(sourceStart);
+		info.setNameSourceEnd(arrowPosition);
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		int length;
+		char[][] argumentNames = new char[length = parameterNames.length][];
+		for (int i = 0; i < length; i++)
+			argumentNames[i] = manager.intern(parameterNames[i].toCharArray());
+		info.setArgumentNames(argumentNames);
+		info.setReturnType(manager.intern(returnType.toCharArray()));
+		info.setExceptionTypeNames(CharOperation.NO_CHAR_CHAR);
+		info.arguments = null; // will be updated shortly, parent has to come into existence first.
+		return new LambdaMethod(parent, selector, key, sourceStart, parameterTypes, parameterNames, returnType, info);
+	}
+
+	protected void closing(Object info) {
+		// nothing to do.
+	}
+	
+	public boolean equals(Object o) {
+		if (!(o instanceof LambdaMethod)) return false;
+		LambdaMethod that = (LambdaMethod) o;
+		return super.equals(o) && this.sourceStart == that.sourceStart;
+	}
+
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return this.elementInfo;
+	}
+	
+	public void getHandleMemento(StringBuffer buff) {
+		((JavaElement) getParent()).getHandleMemento(buff);
+		char delimiter = getHandleMementoDelimiter();
+		buff.append(delimiter);
+		escapeMementoName(buff, getElementName());
+		buff.append(JEM_COUNT);
+		buff.append(this.parameterTypes.length);
+		for (int i = 0, length = this.parameterTypes.length; i < length; i++) {
+			buff.append(JEM_STRING);
+			buff.append(this.parameterTypes[i]);
+			buff.append(JEM_STRING);
+			buff.append(this.parameterNameStrings[i]);
+		}
+		buff.append(JEM_STRING);
+		buff.append(this.returnTypeString);
+		buff.append(JEM_STRING);
+		buff.append(this.key);
+		ILocalVariable[] arguments = this.elementInfo.arguments;
+		for (int i = 0, length = arguments.length; i < length; i++) {
+			LocalVariable local = (LocalVariable) arguments[i];
+			local.getHandleMemento(buff, false);
+		}
+	}
+	
+	protected char getHandleMementoDelimiter() {
+		return JavaElement.JEM_LAMBDA_METHOD;
+	}
+	
+	public String getKey() {
+		return this.key;
+	}
+	
+	public int hashCode() {
+	   return Util.combineHashCodes(super.hashCode(), this.sourceStart);
+	}
+	
+	public boolean isResolved() {
+		return true;  // we maintain enough information so as not to need another layer of abstraction.
+	}
+	
+	public JavaElement resolved(Binding binding) {
+		return this;
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaTypeElementInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaTypeElementInfo.java
deleted file mode 100644
index 786a08b..0000000
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaTypeElementInfo.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core;
-
-import org.eclipse.jdt.core.*;
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.env.ISourceField;
-import org.eclipse.jdt.internal.compiler.env.ISourceMethod;
-import org.eclipse.jdt.internal.compiler.env.ISourceType;
-
-/**
- * Element info for an LambdaExpression element that originated from source.
- */
-public class LambdaTypeElementInfo extends SourceTypeElementInfo {
-
-	protected LambdaExpression lambdaHandle = null;
-	
-	public LambdaTypeElementInfo(LambdaExpression handle) {
-		this.lambdaHandle = handle;
-		setSourceRangeStart(handle.lambdaExpression.sourceStart);
-		setSourceRangeEnd(handle.lambdaExpression.sourceEnd);
-	}
-
-	public IJavaElement[] getChildren() {
-		return new IJavaElement [] { this.lambdaHandle.getMethod() };
-	}
-
-	public ISourceType getEnclosingType() { // FIXME
-		IJavaElement parent= this.lambdaHandle.getParent();
-		if (parent != null && parent.getElementType() == IJavaElement.TYPE) {
-			try {
-				return (ISourceType)((JavaElement)parent).getElementInfo();
-			} catch (JavaModelException e) {
-				return null;
-			}
-		} else {
-			return null;
-		}
-	}
-
-	public ISourceField[] getFields() {
-		return new ISourceField[0];
-	}
-
-	public char[] getFileName() {
-		return this.lambdaHandle.getPath().toString().toCharArray();
-	}
-
-	public char[][] getInterfaceNames() {
-		return new char[][] { this.lambdaHandle.lambdaExpression.descriptor.declaringClass.sourceName() };
-	}
-
-	public ISourceType[] getMemberTypes() {
-		return new ISourceType[0];
-	}
-
-	public ISourceMethod[] getMethods() {
-		ISourceMethod [] methods = new ISourceMethod[1];
-		SourceMethod sourceMethod = this.lambdaHandle.getMethod();
-		try {
-			methods[0] = (ISourceMethod) sourceMethod.getElementInfo();
-		} catch (JavaModelException e) {
-			// ignore
-		}
-		return methods;
-	}
-	
-	public char[] getName() {
-		return this.lambdaHandle.getElementName().toCharArray();
-	}
-
-	public char[] getSuperclassName() {
-		return "Object".toCharArray(); //$NON-NLS-1$
-	}
-
-	public char[][][] getTypeParameterBounds() {
-		return new char[0][][];
-	}
-
-	public char[][] getTypeParameterNames() {
-		return CharOperation.NO_CHAR_CHAR;
-	}
-
-	public boolean isBinaryType() {
-		return false;
-	}
-
-	public String toString() {
-		return "Info for " + this.lambdaHandle.toString(); //$NON-NLS-1$
-	}
-
-	public IType getHandle() {
-		return this.lambdaHandle;
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java
index b320ad0..c4de685 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java
@@ -268,7 +268,12 @@ public class LocalVariable extends SourceRefElement implements ILocalVariable {
 	 * @see JavaElement#getHandleMemento(StringBuffer)
 	 */
 	protected void getHandleMemento(StringBuffer buff) {
-		((JavaElement)getParent()).getHandleMemento(buff);
+		getHandleMemento(buff, true);
+	}
+	
+	protected void getHandleMemento(StringBuffer buff, boolean memoizeParent) {
+		if (memoizeParent) 
+			((JavaElement)getParent()).getHandleMemento(buff);
 		buff.append(getHandleMementoDelimiter());
 		buff.append(this.name);
 		buff.append(JEM_COUNT);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
index c3a2159..da6d883 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
@@ -166,8 +166,6 @@ public IType getDeclaringType() {
  * @see IMember
  */
 public int getFlags() throws JavaModelException {
-	if (this.parent instanceof LambdaExpression)
-		return 0;
 	MemberElementInfo info = (MemberElementInfo) getElementInfo();
 	return info.getModifiers();
 }
@@ -178,6 +176,26 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 	switch (token.charAt(0)) {
 		case JEM_COUNT:
 			return getHandleUpdatingCountFromMemento(memento, workingCopyOwner);
+		case JEM_LAMBDA_EXPRESSION:
+			if (!memento.hasMoreTokens()) return this;
+			String name = memento.nextToken();
+			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.STRING)
+				return this;
+			if (!memento.hasMoreTokens()) return this;
+			String interphase = memento.nextToken();
+			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) 
+				return this;
+			int sourceStart = Integer.parseInt(memento.nextToken());
+			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) 
+				return this;
+			int sourceEnd = Integer.parseInt(memento.nextToken());
+			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) 
+				return this;
+			int arrowPosition = Integer.parseInt(memento.nextToken());
+			if (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.LAMBDA_METHOD) 
+				return this;
+			LambdaExpression expression = new LambdaExpression(this, name, interphase, sourceStart, sourceEnd, arrowPosition);
+			return expression.getHandleFromMemento(token, memento, workingCopyOwner);
 		case JEM_TYPE:
 			String typeName;
 			if (memento.hasMoreTokens()) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
new file mode 100644
index 0000000..11345cb
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedLambdaExpression.java
@@ -0,0 +1,68 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.jdt.core.JavaModelException;
+
+public class ResolvedLambdaExpression extends LambdaExpression {
+
+	private String uniqueKey;
+	LambdaExpression unresolved;
+
+	public ResolvedLambdaExpression(JavaElement parent, LambdaExpression unresolved, String uniqueKey) {
+		super(parent, unresolved.name, unresolved.interphase, unresolved.sourceStart, unresolved.sourceEnd, unresolved.arrowPosition, unresolved.lambdaMethod);
+		this.uniqueKey = uniqueKey;
+		this.unresolved = unresolved;
+	}
+
+	public String getFullyQualifiedParameterizedName() throws JavaModelException {
+		return getFullyQualifiedParameterizedName(getFullyQualifiedName('.'), this.uniqueKey);
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.internal.core.SourceType#getKey()
+	 */
+	public String getKey() {
+		return this.uniqueKey;
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		return this.unresolved.equals(o);
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.internal.core.SourceType#isResolved()
+	 */
+	public boolean isResolved() {
+		return true;
+	}
+
+	/**
+	 * @private Debugging purposes
+	 */
+	protected void toStringInfo(int tab, StringBuffer buffer, Object info, boolean showResolvedInfo) {
+		super.toStringInfo(tab, buffer, info, showResolvedInfo);
+		if (showResolvedInfo) {
+			buffer.append(" {key="); //$NON-NLS-1$
+			buffer.append(this.getKey());
+			buffer.append("}"); //$NON-NLS-1$
+		}
+	}
+
+	public JavaElement unresolved() {
+		return this.unresolved;
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
index f224668..de3966c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
@@ -15,6 +15,8 @@
 package org.eclipse.jdt.internal.core;
 
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.ICompilationUnit;
@@ -444,9 +446,16 @@ public void acceptLocalMethodTypeParameter(TypeVariableBinding typeVariableBindi
 		}
 	}
 }
-public void acceptLocalVariable(LocalVariableBinding binding) {
+public void acceptLocalVariable(LocalVariableBinding binding, org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit) {
 	LocalDeclaration local = binding.declaration;
-	IJavaElement parent = findLocalElement(local.sourceStart); // findLocalElement() cannot find local variable
+	IJavaElement parent = null;
+	if (binding.declaringScope.isLambdaSubscope() && unit instanceof ICompilationUnit) {
+		HashSet existingElements = new HashSet();
+		HashMap knownScopes = new HashMap();
+		parent = this.handleFactory.createElement(binding.declaringScope, local.sourceStart, (ICompilationUnit) unit, existingElements, knownScopes);
+	} else {		
+		parent = findLocalElement(local.sourceStart); // findLocalElement() cannot find local variable
+	}
 	LocalVariable localVar = null;
 	if(parent != null) {
 		localVar = new LocalVariable(
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMethod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMethod.java
index d42a21b..00026ab 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMethod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMethod.java
@@ -185,10 +185,6 @@ public String[] getRawParameterNames() throws JavaModelException {
  * @see IMethod
  */
 public String getReturnType() throws JavaModelException {
-	if (this.parent instanceof LambdaExpression) {
-		LambdaExpression le = (LambdaExpression) this.parent;
-		return new String(le.lambdaExpression.descriptor.returnType.signature());
-	}
 	SourceMethodElementInfo info = (SourceMethodElementInfo) getElementInfo();
 	return Signature.createTypeSignature(info.getReturnTypeName(), false);
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
index 2af5a0c..7947315 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
@@ -336,6 +336,7 @@ public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento,
 			params.toArray(parameters);
 			JavaElement method = (JavaElement)getMethod(selector, parameters);
 			switch (token.charAt(0)) {
+				case JEM_LAMBDA_EXPRESSION:
 				case JEM_TYPE:
 				case JEM_TYPE_PARAMETER:
 				case JEM_LOCALVARIABLE:
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
index 5a1089f..17b60ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
@@ -173,7 +173,7 @@ public class HandleFactory {
 	/**
 	 * Create handle by adding child to parent obtained by recursing into parent scopes.
 	 */
-	private IJavaElement createElement(Scope scope, int elementPosition, ICompilationUnit unit, HashSet existingElements, HashMap knownScopes) {
+	public IJavaElement createElement(Scope scope, int elementPosition, ICompilationUnit unit, HashSet existingElements, HashMap knownScopes) {
 		IJavaElement newElement = (IJavaElement)knownScopes.get(scope);
 		if (newElement != null) return newElement;
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
index 86f96f2..529c65f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MementoTokenizer.java
@@ -28,6 +28,9 @@ public class MementoTokenizer {
 	public static final String LOCALVARIABLE = Character.toString(JavaElement.JEM_LOCALVARIABLE);
 	public static final String TYPE_PARAMETER = Character.toString(JavaElement.JEM_TYPE_PARAMETER);
 	public static final String ANNOTATION = Character.toString(JavaElement.JEM_ANNOTATION);
+	public static final String LAMBDA_EXPRESSION = Character.toString(JavaElement.JEM_LAMBDA_EXPRESSION);
+	public static final String LAMBDA_METHOD = Character.toString(JavaElement.JEM_LAMBDA_METHOD);
+	public static final String STRING = Character.toString(JavaElement.JEM_STRING);
 
 	private final char[] memento;
 	private final int length;
@@ -75,6 +78,12 @@ public class MementoTokenizer {
 				return PACKAGEDECLARATION;
 			case JavaElement.JEM_IMPORTDECLARATION:
 				return IMPORTDECLARATION;
+			case JavaElement.JEM_LAMBDA_EXPRESSION:
+				return LAMBDA_EXPRESSION;
+			case JavaElement.JEM_LAMBDA_METHOD:
+				return LAMBDA_METHOD;
+			case JavaElement.JEM_STRING:
+				return STRING;
 			case JavaElement.JEM_LOCALVARIABLE:
 				return LOCALVARIABLE;
 			case JavaElement.JEM_TYPE_PARAMETER:
@@ -102,6 +111,9 @@ public class MementoTokenizer {
 				case JavaElement.JEM_PACKAGEDECLARATION:
 				case JavaElement.JEM_IMPORTDECLARATION:
 				case JavaElement.JEM_LOCALVARIABLE:
+				case JavaElement.JEM_LAMBDA_EXPRESSION:
+				case JavaElement.JEM_LAMBDA_METHOD:	
+				case JavaElement.JEM_STRING:
 				case JavaElement.JEM_TYPE_PARAMETER:
 				case JavaElement.JEM_ANNOTATION:
 					break loop;
