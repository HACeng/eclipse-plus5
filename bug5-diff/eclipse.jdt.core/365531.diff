commit 4817a4bde9db799e7a793068d64037f59bfa521f
Author: Stephan Herrmann <sherrmann>
Date:   Tue Feb 14 19:25:41 2012 +0100

    HEAD - Fixed bug 365531: [compiler][null] investigate alternative
    strategy for internally encoding nullness defaults

5	13	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
8	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
1	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
1	37	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
79	38	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
2	54	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
4	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
4	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
1	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
37	53	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
1	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
2	19	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 1b1d69c..24606cb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1877,15 +1877,14 @@ public void test_annotation_import_006() {
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
-// using nullness defaulting to nonnull, missing annotation types
+// using nullness defaulting to nonnull, missing annotation types, no longer a problem
 public void test_annotation_import_007() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
 	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
 	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
 	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
-	runNegativeTest(
-		true/*shouldFlushOutputDirectory*/,
+	runConformTestWithLibs(
 		new String[] {
 			"Lib.java",
 			"public class Lib {\n" +
@@ -1898,15 +1897,8 @@ public void test_annotation_import_007() {
 			"    }\n" +
 			"}\n"
 		},
-		this.LIBS,
 		customOptions,
-		"----------\n" +
-		"1. ERROR in Lib.java (at line 1)\n" +
-		"	public class Lib {\n" +
-		"	^\n" +
-		"Buildpath problem: the type org.foo.MustNotBeNull, which is configured as a null annotation type, cannot be resolved\n" +
-		"----------\n",
-		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+		"");
 }
 
 // a null annotation is illegally used on a class:
@@ -2162,7 +2154,7 @@ public void test_default_nullness_003() {
 		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
 		"----------\n");
 }
-// package level default is consumed from package-info.class
+// package level default is consumed from package-info.class, similarly for type level default
 public void test_default_nullness_003a() {
 	Map customOptions = getCompilerOptions();
 //	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
@@ -2219,7 +2211,7 @@ public void test_default_nullness_003a() {
 		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
 		"----------\n");
 }
-//same as test_default_nullness_003b, but default-induced annotations are combined with explicit ones (not null related)
+// same as test_default_nullness_003a, but default-induced annotations are combined with explicit ones (not null related)
 public void test_default_nullness_003b() {
 	Map customOptions = getCompilerOptions();
 	runConformTestWithLibs(
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
index d38f045..934916d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -161,7 +161,8 @@ public class NullAnnotationModelTests extends ReconcilerTests {
     	}
     }
 
-	public void testMissingAnnotation1() throws CoreException {
+	// DISABLED: no longer a problem since bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+	public void _testMissingAnnotation1() throws CoreException {
     	try {
 			// Resources creation
 			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
@@ -197,7 +198,8 @@ public class NullAnnotationModelTests extends ReconcilerTests {
     	}
 	}
 
-	public void testMissingAnnotation2() throws CoreException {
+	// DISABLED: no longer a problem since bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+	public void _testMissingAnnotation2() throws CoreException {
 		Hashtable javaOptions = JavaCore.getOptions();
     	try {
 			// Resources creation
@@ -241,7 +243,8 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 	// Bug 363858 - [dom] early throwing of AbortCompilation causes NPE in CompilationUnitResolver
 	// currently not actually challenging the NPE, because we no longer report
 	// "Cannot use the unqualified name \'invalid\' as an annotation name for null specification"
-	public void testMissingAnnotation3() throws CoreException {
+	// DISABLED: no longer a problem since bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+	public void _testMissingAnnotation3() throws CoreException {
     	try {
 			// Resources creation
 			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
@@ -357,7 +360,8 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 	// - triggered from resolveTypesFor(MethodBinding)
 	// - default is defined in package-info.java:
 	// must detect missing non-null annotation and report against the project
-	public void testMissingAnnotation5() throws CoreException, InterruptedException {
+	// DISABLED: no longer a problem since bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+	public void _testMissingAnnotation5() throws CoreException, InterruptedException {
     	try {
 			// Resources creation
 			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 0560ce8..329ebeb 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.8.0 - %date% - 3.8.0 M6
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=370639">370639</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=365531">365531</a>
+[compiler][null] investigate alternative strategy for internally encoding nullness defaults
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=370639">370639</a>
 [compiler][resource] restore the default for resource leak warnings
 
 <a name="v_C34"></a>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 8a0d434..ac0797c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -125,7 +125,6 @@
  * 								    RequiredNonNullButProvidedNull
  * 									RequiredNonNullButProvidedPotentialNull
  * 									RequiredNonNullButProvidedUnknown
- * 									MissingNullAnnotationType
  * 									NullAnnotationNameMustBeQualified
  * 									IllegalReturnNullityRedefinition
  * 									IllegalRedefinitionToNonNullParameter
@@ -1463,8 +1462,7 @@ void setSourceStart(int sourceStart);
 	int RequiredNonNullButProvidedPotentialNull = TypeRelated + 911;
 	/** @since 3.8 */
 	int RequiredNonNullButProvidedUnknown = TypeRelated + 912;
-	/** @since 3.8 */
-	int MissingNullAnnotationType = ImportRelated + 913;
+	// removed during 3.8 M6: ImportRelated + 913 
 	/** @since 3.8 */
 	int IllegalReturnNullityRedefinition = MethodRelated + 914;
 	/** @since 3.8 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index a996cff..d4f065e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -11,11 +11,10 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 367203 - [compiler][null] detect assigning null to nonnull argument
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
-import java.util.Arrays;
-
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.compiler.*;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
@@ -75,41 +74,6 @@ public abstract class AbstractMethodDeclaration
 	}
 
 	/**
-	 * Materialize a non-null annotation that has been added from the current default,
-	 * in order to ensure that this annotation will be generated into the .class file, too.
-	 */
-	public void addNonNullAnnotation(ReferenceBinding annotationBinding) {
-		this.annotations = addAnnotation(this, this.annotations, annotationBinding);
-	}
-
-	/**
-	 * Materialize a non-null parameter annotation that has been added from the current default,
-	 * in order to ensure that this annotation will be generated into the .class file, too.
-	 */
-	public void addParameterNonNullAnnotation(Argument argument, ReferenceBinding annotationBinding) {
-		if (argument.type != null) // null happens for constructors of anonymous classes
-			argument.annotations = addAnnotation(argument.type, argument.annotations, annotationBinding);
-	}
-
-	private Annotation[] addAnnotation(ASTNode location, Annotation[] oldAnnotations, ReferenceBinding annotationBinding) {
-		long pos = ((long)location.sourceStart<<32) + location.sourceEnd;
-		long[] poss = new long[annotationBinding.compoundName.length];
-		Arrays.fill(poss, pos);
-		MarkerAnnotation annotation = new MarkerAnnotation(new QualifiedTypeReference(annotationBinding.compoundName, poss), location.sourceStart);
-		annotation.declarationSourceEnd = location.sourceEnd;
-		annotation.resolvedType = annotationBinding;
-		annotation.bits = IsSynthetic;
-		if (oldAnnotations == null) {
-			oldAnnotations = new Annotation[] {annotation};
-		} else {
-			int len = oldAnnotations.length;
-			System.arraycopy(oldAnnotations, 0, oldAnnotations=new Annotation[len+1], 1, len);
-			oldAnnotations[0] = annotation;
-		}
-		return oldAnnotations;
-	}
-
-	/**
 	 * When a method is accessed via SourceTypeBinding.resolveTypesFor(MethodBinding)
 	 * we create the argument binding and resolve annotations in order to compute null annotation tagbits.
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 802192b..3f40018 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -13,6 +13,7 @@
  *								bug 364890 - BinaryTypeBinding should use char constants from Util
  *								bug 365387 - [compiler][null] bug 186342: Issues to follow up post review and verification.
  *								bug 358903 - Filter practically unimportant resource leak warnings
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -369,6 +370,11 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			}
 		}
 
+		// need type annotations before processing methods (for @NonNullByDefault)
+		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+			scanTypeForNullDefaultAnnotation(binaryType);
+		}
+
 		if (needFieldsAndMethods) {
 			createFields(binaryType.getFields(), sourceLevel, missingTypeNames);
 			createMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);
@@ -390,14 +396,6 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		}
 		if (this.environment.globalOptions.storeAnnotations)
 			setAnnotations(createAnnotations(binaryType.getAnnotations(), this.environment, missingTypeNames));
-
-		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled
-				&& CharOperation.equals(TypeConstants.PACKAGE_INFO_NAME, binaryType.getSourceName())) 
-		{
-			// only for package-info.java can type-level null-annotations (i.e., @NonNullByDefault) 
-			// on a binary type influence the compilation
-			scanPackageInfoForNullDefaultAnnotation(binaryType);
-		}
 	} finally {
 		// protect against incorrect use of the needFieldsAndMethods flag, see 48459
 		if (this.fields == null)
@@ -1165,65 +1163,93 @@ void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBindi
 		return;
 	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
 	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
-	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
+	if (nullableAnnotationName == null || nonNullAnnotationName == null || nonNullByDefaultAnnotationName == null)
 		return; // not well-configured to use null annotations
 
+	int currentDefault = NO_NULL_DEFAULT;
+	if ((this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+		currentDefault = NONNULL_BY_DEFAULT;
+	} else if ((this.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
+		currentDefault = NULL_UNSPECIFIED_BY_DEFAULT;
+	}
+
 	// return:
 	IBinaryAnnotation[] annotations = method.getAnnotations();
+	boolean explicitNullness = false;
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
 			char[] annotationTypeName = annotations[i].getTypeName();
 			if (annotationTypeName[0] != Util.C_RESOLVED)
 				continue;
 			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
-			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
+				methodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
+				currentDefault = NONNULL_BY_DEFAULT;
+			}
+			if (!explicitNullness && CharOperation.equals(typeName, nonNullAnnotationName)) {
 				methodBinding.tagBits |= TagBits.AnnotationNonNull;
-				break;
+				explicitNullness = true;
 			}
-			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+			if (!explicitNullness && CharOperation.equals(typeName, nullableAnnotationName)) {
 				methodBinding.tagBits |= TagBits.AnnotationNullable;
-				break;
+				explicitNullness = true;
 			}
 		}
 	}
+	if (!explicitNullness && currentDefault == NONNULL_BY_DEFAULT) {
+		methodBinding.tagBits |= TagBits.AnnotationNonNull;
+	}
 
 	// parameters:
 	TypeBinding[] parameters = methodBinding.parameters;
 	int numVisibleParams = parameters.length;
 	int numParamAnnotations = method.getAnnotatedParametersCount();
-	if (numParamAnnotations > 0) {
-		int startIndex = numParamAnnotations - numVisibleParams;
+	if (numParamAnnotations > 0 || currentDefault == NONNULL_BY_DEFAULT) {
 		for (int j = 0; j < numVisibleParams; j++) {
-			IBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);
-			if (paramAnnotations != null) {
-				for (int i = 0; i < paramAnnotations.length; i++) {
-					char[] annotationTypeName = paramAnnotations[i].getTypeName();
-					if (annotationTypeName[0] != Util.C_RESOLVED)
-						continue;
-					char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
-					if (CharOperation.equals(typeName, nonNullAnnotationName)) {
-						if (methodBinding.parameterNonNullness == null)
-							methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
-						methodBinding.parameterNonNullness[j] = Boolean.TRUE;
-						break;
-					} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
-						if (methodBinding.parameterNonNullness == null)
-							methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
-						methodBinding.parameterNonNullness[j] = Boolean.FALSE;
-						break;
+			explicitNullness = false;
+			if (numParamAnnotations > 0) {
+				int startIndex = numParamAnnotations - numVisibleParams;
+				IBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);
+				if (paramAnnotations != null) {
+					for (int i = 0; i < paramAnnotations.length; i++) {
+						char[] annotationTypeName = paramAnnotations[i].getTypeName();
+						if (annotationTypeName[0] != Util.C_RESOLVED)
+							continue;
+						char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+						if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+							if (methodBinding.parameterNonNullness == null)
+								methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
+							methodBinding.parameterNonNullness[j] = Boolean.TRUE;
+							explicitNullness = true;
+							break;
+						} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
+							if (methodBinding.parameterNonNullness == null)
+								methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
+							methodBinding.parameterNonNullness[j] = Boolean.FALSE;
+							explicitNullness = true;
+							break;
+						}
 					}
 				}
 			}
+			if (!explicitNullness && currentDefault == NONNULL_BY_DEFAULT) {
+				if (methodBinding.parameterNonNullness == null)
+					methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
+				methodBinding.parameterNonNullness[j] = Boolean.TRUE;
+			}
 		}
 	}
 }
-void scanPackageInfoForNullDefaultAnnotation(IBinaryType binaryType) {
+void scanTypeForNullDefaultAnnotation(IBinaryType binaryType) {
 	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
 	if (nonNullByDefaultAnnotationName == null)
 		return; // not well-configured to use null annotations
 
 	IBinaryAnnotation[] annotations = binaryType.getAnnotations();
 	if (annotations != null) {
+		long annotationBit = 0L;
+		int nullness = NO_NULL_DEFAULT;
 		int length = annotations.length;
 		for (int i = 0; i < length; i++) {
 			char[] annotationTypeName = annotations[i].getTypeName();
@@ -1238,13 +1264,28 @@ void scanPackageInfoForNullDefaultAnnotation(IBinaryType binaryType) {
 						&& !((BooleanConstant)value).booleanValue())
 					{
 						// parameter is 'false': this means we cancel defaults from outer scopes:
-						this.getPackage().nullnessDefaultAnnotation = ReferenceBinding.NULL_UNSPECIFIED;
-						return;
+						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
+						nullness = NULL_UNSPECIFIED_BY_DEFAULT;
+						break;
 					}
 				}
-				this.getPackage().nullnessDefaultAnnotation = 
-						this.environment.getNullAnnotationBinding(TagBits.AnnotationNonNull, false/*resolve*/);
-				return;
+				annotationBit = TagBits.AnnotationNonNullByDefault;
+				nullness = NONNULL_BY_DEFAULT;
+				break;
+			}
+		}
+		if (annotationBit != 0L) {
+			this.tagBits |= annotationBit;
+			if (CharOperation.equals(this.sourceName(), TypeConstants.PACKAGE_INFO_NAME))
+				this.getPackage().defaultNullness = nullness;
+		} else {
+			switch (this.getPackage().defaultNullness) {
+				case NONNULL_BY_DEFAULT : 
+					this.tagBits |= TagBits.AnnotationNonNullByDefault;
+					break;
+				case NULL_UNSPECIFIED_BY_DEFAULT :
+					this.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+					break;
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index d0e769e..5725ea3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -48,6 +50,11 @@ public abstract class Binding {
 	public static final MethodBinding[] UNINITIALIZED_METHODS = new MethodBinding[0];
 	public static final ReferenceBinding[] UNINITIALIZED_REFERENCE_TYPES = new ReferenceBinding[0];
 
+	// Nullness defaults:
+	public static final int NO_NULL_DEFAULT = 0;
+	public static final int NULL_UNSPECIFIED_BY_DEFAULT = 1;
+	public static final int NONNULL_BY_DEFAULT = 2;
+
 	/*
 	* Answer the receiver's binding type from Binding.BindingID.
 	*/
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 0b48bbb..7489fbc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - contributions for
  *     							bug 337868 - [compiler][model] incomplete support for package-info.java when using SearchableEnvironment
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1092,59 +1093,6 @@ public char[][] getNonNullByDefaultAnnotationName() {
 	return this.globalOptions.nonNullByDefaultAnnotationName;
 }
 
-/**
- * Answer the type binding representing the null-annotation identified by the given tag bits.
- * @param annotationTagBit tag bits potentially denoting a null-annotation
- * @param resolve should the resulting type binding be resolved?
- * @return the corresponding annotation type binding
- * 		or <code>null</code> if no annotation bits are contained in the given tag bits.
- */
-public TypeBinding getNullAnnotationBinding(long annotationTagBit, boolean resolve) {
-	char[][] name = null;
-	if (annotationTagBit == TagBits.AnnotationNonNull)
-		name = getNonNullAnnotationName();
-	else if (annotationTagBit == TagBits.AnnotationNullable)
-		name = getNullableAnnotationName();
-	else
-		return null;
-	if (resolve)
-		return getType(name);
-	else
-		return getTypeFromCompoundName(name, false, false);
-}
-
-/**
- * Inspect the given tag bits and answer a corresponding null annotation type binding
- * @param defaultTagBit tag bits representing the default applicable at the current code location
- * @param resolve should the resulting type binding be resolved?
- * @return the corresponding concrete annotation type binding (<code>@NonNull</code> or <code>@Nullable</code>)
- * 		or <code>null</code> if no bits of a default-annotation are contained in the given tag bits.
- */
-public TypeBinding getNullAnnotationBindingFromDefault(long defaultTagBit, boolean resolve) {
-	if ((defaultTagBit & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
-		return ReferenceBinding.NULL_UNSPECIFIED;
-	if ((defaultTagBit & TagBits.AnnotationNonNullByDefault) != 0)
-		return getNullAnnotationBinding(TagBits.AnnotationNonNull, resolve);
-	return null;
-}
-
-TypeBinding getNullAnnotationResolved(TypeBinding nullAnnotation, Scope scope) {
-	// avoid unspecific error "The type in.valid cannot be resolved. It is indirectly referenced from required .class files"
-	boolean tolerateMissing = this.mayTolerateMissingType;
-	this.mayTolerateMissingType = true;
-	try {
-		nullAnnotation = BinaryTypeBinding.resolveType(nullAnnotation, this, false);
-	} finally {
-		this.mayTolerateMissingType = tolerateMissing;
-	}
-	if (nullAnnotation instanceof MissingTypeBinding) {
-		// convert error into a specific one:
-		scope.problemReporter().missingNullAnnotationType(((MissingTypeBinding)nullAnnotation).compoundName);
-		return null;
-	}
-	return nullAnnotation;
-}
-
 /* Answer the top level package named name if it exists in the cache.
 * Answer theNotFoundPackage if it could not be resolved the first time
 * it was looked up, otherwise answer null.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index c32fd9e..ce25e57 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -12,6 +12,7 @@
  *								bug 367203 - [compiler][null] detect assigning null to nonnull argument
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -448,10 +449,9 @@ public final char[] constantPoolName() {
 }
 
 /**
- * After method verifier has finished, fill in missing nullness values from the applicable default.
- * @param annotationBinding the null annotation specified to be the default at the current code location.
+ * After method verifier has finished, fill in missing @NonNull specification from the applicable default.
  */
-protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
+protected void fillInDefaultNonNullness() {
 	if (this.parameterNonNullness == null)
 		this.parameterNonNullness = new Boolean[this.parameters.length];
 	AbstractMethodDeclaration sourceMethod = sourceMethod();
@@ -464,9 +464,7 @@ protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
 			added = true;
 			this.parameterNonNullness[i] = Boolean.TRUE;
 			if (sourceMethod != null) {
-				Argument argument = sourceMethod.arguments[i];
-				sourceMethod.addParameterNonNullAnnotation(argument, (ReferenceBinding)annotationBinding);
-				argument.binding.tagBits |= TagBits.AnnotationNonNull;
+				sourceMethod.arguments[i].binding.tagBits |= TagBits.AnnotationNonNull;
 			}
 		} else if (this.parameterNonNullness[i].booleanValue()) {
 			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
@@ -479,8 +477,6 @@ protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
 		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
 	{
 		this.tagBits |= TagBits.AnnotationNonNull;
-		if (sourceMethod != null)
-			sourceMethod.addNonNullAnnotation((ReferenceBinding)annotationBinding);
 	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
 		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 0a5394c..f139509 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -26,8 +27,9 @@ public class PackageBinding extends Binding implements TypeConstants {
 	HashtableOfType knownTypes;
 	HashtableOfPackage knownPackages;
 
-	// annotation type binding representing the default that has been defined for this package (using @NonNullByDefault)
-	protected TypeBinding nullnessDefaultAnnotation;
+	// code representing the default that has been defined for this package (using @NonNullByDefault)
+	// one of Binding.{NO_NULL_DEFAULT,NULL_UNSPECIFIED_BY_DEFAULT,NONNULL_BY_DEFAULT}
+	protected int defaultNullness = NO_NULL_DEFAULT;
 
 protected PackageBinding() {
 	// for creating problem package
@@ -286,12 +288,6 @@ void checkIfNullAnnotationType(ReferenceBinding type) {
 	}
 }
 
-public TypeBinding getNullnessDefaultAnnotation(Scope scope) {
-	if (this.nullnessDefaultAnnotation instanceof UnresolvedReferenceBinding)
-		return this.nullnessDefaultAnnotation = this.environment.getNullAnnotationResolved(this.nullnessDefaultAnnotation, scope);
-	return this.nullnessDefaultAnnotation;
-}
-
 public char[] readableName() /*java.lang*/ {
 	return CharOperation.concatWith(this.compoundName, '.');
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 3a2aea2..ca96657 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -12,6 +12,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 358903 - Filter practically unimportant resource leak warnings
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -52,14 +53,6 @@ abstract public class ReferenceBinding extends TypeBinding {
 		public boolean hasTypeBit(int bit) { return false; }
 	};
 
-	/**
-	 * This faked annotation type binding marks types with unspecified nullness.
-	 * For use in {@link PackageBinding#nullnessDefaultAnnotation} and SourceTypeBinding#nullnessDefaultAnnotation
-	 */
-	final static ReferenceBinding NULL_UNSPECIFIED = new ReferenceBinding() { /* faked type binding */
-		public boolean hasTypeBit(int bit) { return false; }
-	};
-
 	private static final Comparator FIELD_COMPARATOR = new Comparator() {
 		public int compare(Object o1, Object o2) {
 			char[] n1 = ((FieldBinding) o1).name;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 4ee7aaa..5fa8001 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -14,6 +14,7 @@
  *								bug 365836 - [compiler][null] Incomplete propagation of null defaults.
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -62,7 +63,7 @@ public class SourceTypeBinding extends ReferenceBinding {
 
 	private SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
-	private TypeBinding nullnessDefaultAnnotation;
+	private int defaultNullness;
 	private int nullnessDefaultInitialized = 0; // 0: nothing; 1: type; 2: package
 
 public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassScope scope) {
@@ -1626,9 +1627,9 @@ private void createArgumentBindings(MethodBinding method) {
 	if (methodDecl != null) {
 		if (method.parameters != Binding.NO_PARAMETERS)
 			methodDecl.createArgumentBindings();
-		TypeBinding annotationBinding = findDefaultNullness(methodDecl.scope, methodDecl.scope.environment());
-		if (annotationBinding != null && annotationBinding.id == TypeIds.T_ConfiguredAnnotationNonNull)
-			method.fillInDefaultNonNullness(annotationBinding);
+		if ((findNonNullDefault(methodDecl.scope, methodDecl.scope.environment()) == NONNULL_BY_DEFAULT)) {
+			method.fillInDefaultNonNullness();
+		}
 	}
 }
 private void evaluateNullAnnotations(long annotationTagBits) {
@@ -1636,18 +1637,21 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 		return;
 	this.nullnessDefaultInitialized = 1;
 	// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
-	TypeBinding defaultAnnotation = getPackage().environment
-						.getNullAnnotationBindingFromDefault(annotationTagBits, false/*resolve*/);
-	if (defaultAnnotation != null) {
+	int newDefaultNullness = NO_NULL_DEFAULT;
+	if ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+		newDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+	else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)
+		newDefaultNullness = NONNULL_BY_DEFAULT;
+	if (newDefaultNullness != NO_NULL_DEFAULT) {
 		if (CharOperation.equals(this.sourceName, TypeConstants.PACKAGE_INFO_NAME)) {
-			getPackage().nullnessDefaultAnnotation = defaultAnnotation;
+			getPackage().defaultNullness = newDefaultNullness;
 			long globalDefault = this.scope.compilerOptions().defaultNonNullness;
 			if (globalDefault == TagBits.AnnotationNonNull && (annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0) {
 				TypeDeclaration typeDecl = this.scope.referenceContext;
 				this.scope.problemReporter().nullDefaultAnnotationIsRedundant(typeDecl, typeDecl.annotations, null);
 			}
 		} else {
-			this.nullnessDefaultAnnotation = defaultAnnotation;
+			this.defaultNullness = newDefaultNullness;
 			TypeDeclaration typeDecl = this.scope.referenceContext;
 			long nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);
 			checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits);
@@ -1656,8 +1660,8 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 }
 
 protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long annotationTagBits) {
-	if (this.fPackage.nullnessDefaultAnnotation != null) {
-		if ((this.fPackage.nullnessDefaultAnnotation.id == TypeIds.T_ConfiguredAnnotationNonNull
+	if (this.fPackage.defaultNullness != NO_NULL_DEFAULT) {
+		if ((this.fPackage.defaultNullness == NONNULL_BY_DEFAULT
 				&& ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0))) {
 			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this.fPackage);
 		}
@@ -1671,10 +1675,9 @@ protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation
 
 // return: should caller continue searching?
 protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[] annotations, long annotationTagBits) {
-	TypeBinding thisDefault = this.nullnessDefaultAnnotation;
-	if (thisDefault != null) {
-		if (thisDefault.id == TypeIds.T_ConfiguredAnnotationNonNull
-			&& ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)) {
+	int thisDefault = this.defaultNullness;
+	if (thisDefault == NONNULL_BY_DEFAULT) {
+		if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0) {
 			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this);
 		}
 		return false; // different default means inner default is not redundant -> we're done
@@ -1682,42 +1685,35 @@ protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[
 	return true;
 }
 
-private TypeBinding getNullnessDefaultAnnotation() {
-	if (this.nullnessDefaultAnnotation instanceof UnresolvedReferenceBinding)
-		this.nullnessDefaultAnnotation = this.scope.environment().getNullAnnotationResolved(this.nullnessDefaultAnnotation, this.scope);
-	return this.nullnessDefaultAnnotation;
-}
 /**
  * Answer the nullness default applicable at the given method binding.
- * Possible values:<ul>
- * <li>the type binding for @NonNulByDefault</li>
- * <li>the synthetic type {@link ReferenceBinding#NULL_UNSPECIFIED} if a default from outer scope has been canceled</li>
- * <li>null if no default has been defined</li>
- * </ul>
+ * Possible values: {@link Binding#NO_NULL_DEFAULT}, {@link Binding#NULL_UNSPECIFIED_BY_DEFAULT}, {@link Binding#NONNULL_BY_DEFAULT}.
  * @param currentScope where to start search for lexically enclosing default
- * @param environment gateway to options and configured annotation types
+ * @param environment gateway to options
  */
-private TypeBinding findDefaultNullness(Scope currentScope, LookupEnvironment environment) {
+private int findNonNullDefault(Scope currentScope, LookupEnvironment environment) {
 	// find the applicable default inside->out:
 
 	SourceTypeBinding currentType = null;
-	TypeBinding annotationBinding;
 	while (currentScope != null) {
 		switch (currentScope.kind) {
 			case Scope.METHOD_SCOPE:
 				AbstractMethodDeclaration referenceMethod = ((MethodScope)currentScope).referenceMethod();
 				if (referenceMethod != null && referenceMethod.binding != null) {
-					annotationBinding = environment.getNullAnnotationBindingFromDefault(referenceMethod.binding.tagBits, true/*resolve*/);
-					if (annotationBinding != null)
-						return annotationBinding;
+					long methodTagBits = referenceMethod.binding.tagBits;
+					if ((methodTagBits & TagBits.AnnotationNonNullByDefault) != 0)
+						return NONNULL_BY_DEFAULT;
+					if ((methodTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+						return NULL_UNSPECIFIED_BY_DEFAULT;
 				}
 				break;
 			case Scope.CLASS_SCOPE:
 				currentType = ((ClassScope)currentScope).referenceContext.binding;
 				if (currentType != null) {
-					annotationBinding = currentType.getNullnessDefaultAnnotation();
-					if (annotationBinding != null)
-						return annotationBinding;
+					int foundDefaultNullness = currentType.defaultNullness;
+					if (foundDefaultNullness != NO_NULL_DEFAULT) {
+						return foundDefaultNullness;
+					}
 				}
 				break;
 		}
@@ -1726,28 +1722,16 @@ private TypeBinding findDefaultNullness(Scope currentScope, LookupEnvironment en
 
 	// package
 	if (currentType != null) {
-		annotationBinding = currentType.getPackage().getNullnessDefaultAnnotation(this.scope);
-		if (annotationBinding != null)
-			return annotationBinding;
+		int foundDefaultNullness = currentType.getPackage().defaultNullness;
+		if (foundDefaultNullness != NO_NULL_DEFAULT) {
+			return foundDefaultNullness;
+		}
 	}
 
 	// global
-	long defaultNullness = environment.globalOptions.defaultNonNullness;
-	if (defaultNullness != 0) {
-		// we have a default, so we need an annotation type to record this during compile and in the byte code
-		annotationBinding = environment.getNullAnnotationBinding(defaultNullness, true/*resolve*/);
-		if (annotationBinding != null)
-			return annotationBinding;
-
-		// on this branch default was not defined using an annotation, thus annotation type can still be missing
-		if (defaultNullness == TagBits.AnnotationNonNull)
-			this.scope.problemReporter().missingNullAnnotationType(environment.getNonNullAnnotationName());
-		else
-			this.scope.problemReporter().abortDueToInternalError("Illegal default nullness value: "+defaultNullness); //$NON-NLS-1$
-		// reset default to avoid duplicate errors:
-		environment.globalOptions.defaultNonNullness = 0;
-	}
-	return null;
+	if (environment.globalOptions.defaultNonNullness == TagBits.AnnotationNonNull)
+		return NONNULL_BY_DEFAULT;
+	return NO_NULL_DEFAULT;
 }
 
 public AnnotationHolder retrieveAnnotationHolder(Binding binding, boolean forceInitialization) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 3c4014b..a6c69f6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -15,6 +15,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -593,7 +594,6 @@ public static int getProblemCategory(int severity, int problemID) {
 	switch (problemID) {
 		case IProblem.IsClassPathCorrect :
 		case IProblem.CorruptedSignature :
-		case IProblem.MissingNullAnnotationType :
 			return CategorizedProblem.CAT_BUILDPATH;
 
 		default :
@@ -8275,11 +8275,6 @@ public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode loc
 		location.sourceEnd);
 }
 
-public void missingNullAnnotationType(char[][] nullAnnotationName) {
-	String[] args = { new String(CharOperation.concatWith(nullAnnotationName, '.')) };
-	this.handle(IProblem.MissingNullAnnotationType, args, args, 0, 0);
-}
-
 public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	int sourceStart = 0, sourceEnd = 0;
 	if (this.referenceContext instanceof TypeDeclaration) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 94cccee..bb5ac8a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -13,6 +13,7 @@
 #							bug 349326 - [1.7] new warning for missing try-with-resources
 #							bug 186342 - [compiler][null] Using annotations for null checking
 #							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+#							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -671,7 +672,7 @@
 910 = Type mismatch: required ''@{0} {1}'' but the provided value is null
 911 = Type mismatch: required ''@{0} {1}'' but the provided value can be null
 912 = Potential type mismatch: required ''@{0} {1}'' but nullness of the provided value is unknown
-913 = Buildpath problem: the type {0}, which is configured as a null annotation type, cannot be resolved
+#913 removed
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
 916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index a2d1924..b72a6fb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -4361,7 +4361,6 @@ class ASTConverter {
 			int indexInAnnotations = 0;
 			while ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
 				IExtendedModifier modifier = null;
-				switchToken:
 				switch(token) {
 					case TerminalTokens.TokenNameabstract:
 						modifier = createModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
@@ -4399,13 +4398,7 @@ class ASTConverter {
 					case TerminalTokens.TokenNameAT :
 						// we have an annotation
 						if (annotations != null && indexInAnnotations < annotations.length) {
-							// method may have synthetic annotations, skip them:
-							org.eclipse.jdt.internal.compiler.ast.Annotation annotation;
-							do {
-								if (indexInAnnotations == annotations.length)
-									break switchToken;
-								annotation = annotations[indexInAnnotations++];
-							} while ((annotation.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsSynthetic) != 0);
+							org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 							modifier = convert(annotation);
 							this.scanner.resetTo(annotation.declarationSourceEnd + 1, modifiersEnd);
 						}
@@ -4519,7 +4512,6 @@ class ASTConverter {
 					int token;
 					while ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
 						IExtendedModifier modifier = null;
-						switchToken:
 						switch(token) {
 							case TerminalTokens.TokenNameabstract:
 								modifier = createModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
@@ -4557,13 +4549,7 @@ class ASTConverter {
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
 								if (annotations != null && indexInAnnotations < annotations.length) {
-									// argument may have synthetic annotations, skip them:
-									org.eclipse.jdt.internal.compiler.ast.Annotation annotation;
-									do {
-										if (indexInAnnotations == annotations.length)
-											break switchToken;
-										annotation = annotations[indexInAnnotations++];
-									} while ((annotation.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsSynthetic) != 0);
+									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 									modifier = convert(annotation);
 									this.scanner.resetTo(annotation.declarationSourceEnd + 1, this.compilationUnitSourceLength);
 								}
@@ -4637,7 +4623,6 @@ class ASTConverter {
 							break;
 						case TerminalTokens.TokenNameAT :
 							// we have an annotation
-							// (local variable has no synthetic annotations, no need to skip them)
 							if (annotations != null && indexInAnnotations < annotations.length) {
 								org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 								modifier = convert(annotation);
@@ -4740,7 +4725,6 @@ class ASTConverter {
 								break;
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
-								// (local variable has no synthetic annotations, no need to skip them)
 								if (annotations != null && indexInAnnotations < annotations.length) {
 									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 									modifier = convert(annotation);
@@ -4822,7 +4806,6 @@ class ASTConverter {
 								break;
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
-								// (local variable has no synthetic annotations, no need to skip them)
 								if (annotations != null && indexInAnnotations < annotations.length) {
 									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 									modifier = convert(annotation);
