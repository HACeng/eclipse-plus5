commit 416292d2f4be39d514e933551cdaebb7c7ebd8a7
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Nov 6 09:53:55 2014 +0530

    Fixed Bug 447579 - [1.8][compiler] Poly expressions APIs need
    unification.

1	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
3	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
4	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
64	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
10	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
70	71	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpression.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpression.java
index 27425ac..5cce2d3 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpression.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnReferenceExpression.java
@@ -25,7 +25,7 @@ public class SelectionOnReferenceExpression extends ReferenceExpression {
 	@Override
 	public TypeBinding resolveType(BlockScope scope) {
 		TypeBinding resolveType = super.resolveType(scope);
-		if (this.expectedType != null && !this.trialResolution)
+		if (this.expectedType != null && this.original == this)
 			throw new SelectionNodeFound(this.descriptor);
 		return resolveType;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 26995c9..fd5ea25 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -62,7 +62,7 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
-public class AllocationExpression extends Expression implements Invocation {
+public class AllocationExpression extends Expression implements IPolyExpression, Invocation {
 
 	public TypeReference type;
 	public Expression[] arguments;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 423e118..bc9d83b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -36,7 +36,7 @@ import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
-public class ConditionalExpression extends OperatorExpression {
+public class ConditionalExpression extends OperatorExpression implements IPolyExpression {
 
 	public Expression condition, valueIfTrue, valueIfFalse;
 	public Constant optimizedBooleanConstant;
@@ -58,10 +58,8 @@ public class ConditionalExpression extends OperatorExpression {
 	private TypeBinding originalValueIfTrueType;
 	private TypeBinding originalValueIfFalseType;
 	private boolean use18specifics;
-	public ConditionalExpression(
-		Expression condition,
-		Expression valueIfTrue,
-		Expression valueIfFalse) {
+
+	public ConditionalExpression(Expression condition, Expression valueIfTrue, Expression valueIfFalse) {
 		this.condition = condition;
 		this.valueIfTrue = valueIfTrue;
 		this.valueIfFalse = valueIfFalse;
@@ -801,11 +799,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				this.valueIfTrue.sIsMoreSpecific(s, t, scope) && this.valueIfFalse.sIsMoreSpecific(s, t, scope):
 				false;
 	}
-	
-	public void tagAsEllipsisArgument() {
-		this.valueIfTrue.tagAsEllipsisArgument();
-		this.valueIfFalse.tagAsEllipsisArgument();
-	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
 		if (visitor.visit(this, scope)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 489f339..2e2c81c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1064,6 +1064,10 @@ public TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTy
 	return expressionType;
 }
 
+public Expression resolveExpressionExpecting(TypeBinding targetType, Scope scope) {
+	return this; // subclasses should implement for a better resolved expression if required.
+}
+
 /**
  * Returns true if the receiver is forced to be of raw type either to satisfy the contract imposed
  * by a super type or because it *is* raw and the current type has no control over it (i.e the rawness
@@ -1163,10 +1167,6 @@ public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t, Scope scope) {
 	return s.isCompatibleWith(t, scope);
 }
 
-public void tagAsEllipsisArgument() {
-	// don't care. Subclasses that are poly expressions in specific contexts should listen in and make note.
-}
-
 public boolean isExactMethodReference() {
 	return false;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 6bf0935..9fa5139 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -32,7 +32,6 @@ import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
-import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
 import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
@@ -57,10 +56,8 @@ public abstract class FunctionalExpression extends Expression {
 	protected MethodBinding actualMethodBinding;  // void of synthetics.
 	boolean ignoreFurtherInvestigation;
 	protected ExpressionContext expressionContext = VANILLA_CONTEXT;
-	protected Expression [] resultExpressions = NO_EXPRESSIONS;
 	public CompilationResult compilationResult;
 	public BlockScope enclosingScope;
-	protected boolean ellipsisArgument;
 	public int bootstrapMethodNumber = -1;
 	protected static IErrorHandlingPolicy silentErrorHandlingPolicy = DefaultErrorHandlingPolicies.ignoreAllProblems();
 	private boolean hasReportedSamProblem = false;
@@ -85,19 +82,19 @@ public abstract class FunctionalExpression extends Expression {
 	public MethodBinding getMethodBinding() {
 		return null;
 	}
+
 	public void setExpectedType(TypeBinding expectedType) {
-		this.expectedType = this.ellipsisArgument ? ((ArrayBinding) expectedType).elementsType() : expectedType;
+		this.expectedType = expectedType;
 	}
 	
 	public void setExpressionContext(ExpressionContext context) {
 		this.expressionContext = context;
 	}
+
 	public ExpressionContext getExpressionContext() {
 		return this.expressionContext;
 	}
-	public void tagAsEllipsisArgument() {
-		this.ellipsisArgument = true;
-	}
+
 	public boolean isPolyExpression(MethodBinding candidate) {
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
new file mode 100644
index 0000000..309cdf5
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+
+/**
+ 	Contract to be implemented by all poly expressions and potential poly expressions for uniform integration into overload resolution and type inference.
+	Additional contracts may be imposed by {@link Invocation} and {@link InvocationSite}. For most contracts "default" implementations are furnished by 
+	{@link Expression} or {@link Statement} or by {@link ASTNode} and the poly expression should suitably override where required.
+	
+	@see PolyTypeBinding
+	@see ExpressionContext
+*/
+public interface IPolyExpression {
+
+	// Expression context manipulation
+	public void setExpressionContext(ExpressionContext context);
+	public ExpressionContext getExpressionContext();
+	
+	// Target type injection.
+	public void setExpectedType(TypeBinding targetType);
+	public TypeBinding invocationTargetType();
+	
+	// Compatibility checks.
+	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope);
+	public boolean isCompatibleWith(TypeBinding targetType, final Scope scope);
+	public boolean isBoxingCompatibleWith(TypeBinding targetType, Scope scope);
+	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t, Scope skope);	
+	
+	// Pertinence checks.
+	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method);
+	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method);
+
+	// Polyness checks
+	public boolean isPolyExpression(MethodBinding candidate);
+	public boolean isPolyExpression();
+	public boolean isFunctionalType();
+	public Expression[] getPolyExpressions();
+	
+	
+	/* Resolution: A poly expression must be prepared to be resolved multiple times and should manage matters in a side effect free fashion.
+	   Typically, in invocation contexts, there is an initial resolution, multiple tentative resolutions and then a final resolution against
+	   the ultimate target type.
+	*/
+	public TypeBinding resolveType(BlockScope blockScope);
+	// Resolve expression tentatively - should have no lingering side-effects that may impact final resolution ! 
+	public Expression resolveExpressionExpecting(TypeBinding targetType, Scope scope);
+	
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 078e763..52f34f3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -96,7 +96,7 @@ import org.eclipse.jdt.internal.compiler.problem.AbortType;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 @SuppressWarnings({"rawtypes", "unchecked"})
-public class LambdaExpression extends FunctionalExpression implements ReferenceContext, ProblemSeverities {
+public class LambdaExpression extends FunctionalExpression implements IPolyExpression, ReferenceContext, ProblemSeverities {
 	public Argument [] arguments;
 	private TypeBinding [] argumentTypes;
 	public int arrowPosition;
@@ -875,7 +875,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		return true;
 	}
 
-	private HashMap<TypeBinding, LambdaExpression> resolvedCopies;
+	private HashMap<TypeBinding, LambdaExpression> copiesPerTargetType;
+	protected Expression [] resultExpressions = NO_EXPRESSIONS;
 	
 	/**
 	 * Get a resolved copy of this lambda for use by type inference, as to avoid spilling any premature
@@ -884,18 +885,18 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	 * @param targetType the target functional type against which inference is attempted, must be a non-null valid functional type 
 	 * @return a resolved copy of 'this' or null if significant errors where encountered
 	 */
-	public LambdaExpression getResolvedCopyForInferenceTargeting(TypeBinding targetType) {
-		LambdaExpression lambda = this.resolvedCopies != null ? this.resolvedCopies.get(targetType) : null;
+	public LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope) {
+		LambdaExpression lambda = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;
 		if (lambda == null) {
-			lambda = getResolvedCopyForInferenceTargeting0(targetType);
-			if (this.resolvedCopies == null)
-				this.resolvedCopies = new HashMap<TypeBinding, LambdaExpression>();
-			this.resolvedCopies.put(targetType, lambda);
+			lambda = getResolvedCopyForInferenceTargeting(targetType);
+			if (this.copiesPerTargetType == null)
+				this.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();
+			this.copiesPerTargetType.put(targetType, lambda);
 		}
 		return lambda;
 	}
 	
-	public LambdaExpression getResolvedCopyForInferenceTargeting0(TypeBinding targetType) {
+	private LambdaExpression getResolvedCopyForInferenceTargeting(TypeBinding targetType) {
 		// note: this is essentially a simplified extract from isCompatibleWith(TypeBinding,Scope).
 		if (this.shapeAnalysisComplete && this.binding != null)
 			return this;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 044f3c7..500343f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -100,7 +100,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
-public class MessageSend extends Expression implements Invocation {
+public class MessageSend extends Expression implements IPolyExpression, Invocation {
 
 	public Expression receiver;
 	public char[] selector;
@@ -598,7 +598,7 @@ public StringBuffer printExpression(int indent, StringBuffer output){
 }
 
 public TypeBinding resolveType(BlockScope scope) {
-	// Answer the signature return type, answers PolyTypeBinding if there is at least one generic overloaded candidate that encoded type variables in return type and there is no target type  
+	// Answer the signature return type, answers PolyTypeBinding if a poly expression and there is no target type  
 	// Base type promotion
 	if (this.constant != Constant.NotAConstant) {
 		this.constant = Constant.NotAConstant;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 43f638d..6833b2d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -48,6 +48,7 @@ import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
@@ -76,7 +77,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 
-public class ReferenceExpression extends FunctionalExpression implements InvocationSite {
+public class ReferenceExpression extends FunctionalExpression implements IPolyExpression, InvocationSite {
 	
 	public Expression lhs;
 	public TypeReference [] typeArguments;
@@ -94,13 +95,16 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	private MethodBinding exactMethodBinding; // != null ==> exact method reference.
 	private boolean receiverPrecedesParameters = false;
 	private TypeBinding[] freeParameters; // descriptor parameters as used for method lookup - may or may not include the receiver
-	public boolean trialResolution = false;
-	public int inferenceKind; // TODO: define life-cycle: when to re-initialize? How long to keep value?
+	public int inferenceKind;
 	private boolean checkingPotentialCompatibility;
 	private MethodBinding[] potentialMethods = Binding.NO_METHODS;
+	protected ReferenceExpression original;
+	private HashMap<TypeBinding, ReferenceExpression> copiesPerTargetType;
+	public char[] text; // source representation of the expression.
 	
 	public ReferenceExpression() {
 		super();
+		this.original = this;
 	}
 	
 	public void initialize(CompilationResult result, Expression expression, TypeReference [] optionalTypeArguments, char [] identifierOrNew, int sourceEndPosition) {
@@ -111,13 +115,22 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		this.sourceStart = expression.sourceStart;
 		this.sourceEnd = sourceEndPosition;
 	}
+	
+	private ReferenceExpression copy() {
+		final Parser parser = new Parser(this.enclosingScope.problemReporter(), false);
+		final ICompilationUnit compilationUnit = this.compilationResult.getCompilationUnit();
+		final char[] source = compilationUnit != null ? compilationUnit.getContents() : this.text;
+		ReferenceExpression copy =  (ReferenceExpression) parser.parseExpression(source, compilationUnit != null ? this.sourceStart : 0, this.sourceEnd - this.sourceStart + 1, 
+										this.enclosingScope.referenceCompilationUnit(), false /* record line separators */);
+		copy.original = this;
+		copy.sourceStart = this.sourceStart;
+		copy.sourceEnd = this.sourceEnd;
+		return copy;
+	}
  
 	public void generateImplicitLambda(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
 		
-		final Parser parser = new Parser(this.enclosingScope.problemReporter(), false);
-		final char[] source = this.compilationResult.getCompilationUnit().getContents();
-		ReferenceExpression copy =  (ReferenceExpression) parser.parseExpression(source, this.sourceStart, this.sourceEnd - this.sourceStart + 1, 
-										this.enclosingScope.referenceCompilationUnit(), false /* record line separators */);
+		ReferenceExpression copy = copy();
 		
 		int argc = this.descriptor.parameters.length;
 		
@@ -370,7 +383,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	
 	public TypeBinding resolveType(BlockScope scope) {
 		
-		if (this.expectedType != null && !this.trialResolution) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
+		if (this.expectedType != null && this.original == this) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
 			recordFunctionalType(scope);
 		}
 		
@@ -424,7 +437,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 				this.receiverType = lhsType.capture(scope, this.sourceStart, this.sourceEnd);
 
 			if (!lhsType.isRawType()) // RawType::m and RawType::new are not exact method references
-	    		this.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);
+	    		this.binding = this.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);
 
     		if (isConstructorReference() && !lhsType.canBeInstantiated()) {
     			scope.problemReporter().cannotInstantiate(this.lhs, lhsType);
@@ -500,8 +513,11 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         final boolean isMethodReference = isMethodReference();
         this.depth = 0;
         this.freeParameters = descriptorParameters;
+        this.inferenceKind = InferenceContext18.CHECK_UNKNOWN;
         MethodBinding someMethod = isMethodReference ? scope.getMethod(this.receiverType, this.selector, descriptorParameters, this) :
         											       scope.getConstructor((ReferenceBinding) this.receiverType, descriptorParameters, this);
+        int someMethodInfereceKind = this.inferenceKind;
+        int anotherMethodInferenceKind = this.inferenceKind = InferenceContext18.CHECK_UNKNOWN;
         int someMethodDepth = this.depth, anotherMethodDepth = 0;
     	if (someMethod != null && someMethod.isValidBinding()) {
     		if (someMethod.isStatic() && (this.haveReceiver || this.receiverType.isParameterizedTypeWithActualArguments())) {
@@ -533,6 +549,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         		this.depth = 0;
         		this.freeParameters = parameters;
         		anotherMethod = scope.getMethod(typeToSearch, this.selector, parameters, this);
+        		anotherMethodInferenceKind = this.inferenceKind;
         		anotherMethodDepth = this.depth;
         		this.depth = 0;
         	}
@@ -545,6 +562,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         
         if (someMethod != null && someMethod.isValidBinding() && (anotherMethod == null || !anotherMethod.isValidBinding() || anotherMethod.isStatic())) {
         	this.binding = someMethod;
+        	this.inferenceKind = someMethodInfereceKind;
         	this.bits &= ~ASTNode.DepthMASK;
         	if (someMethodDepth > 0) {
         		this.bits |= (someMethodDepth & 0xFF) << ASTNode.DepthSHIFT;
@@ -557,6 +575,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         	} 
         } else if (anotherMethod != null && anotherMethod.isValidBinding() && (someMethod == null || !someMethod.isValidBinding() || !someMethod.isStatic())) {
         	this.binding = anotherMethod;
+        	this.inferenceKind = anotherMethodInferenceKind;
         	this.receiverPrecedesParameters = true; // 0 is receiver, real parameters start at 1
         	this.bits &= ~ASTNode.DepthMASK;
         	if (anotherMethodDepth > 0) {
@@ -568,6 +587,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         	}
         } else {
         	this.binding = null;
+        	this.inferenceKind = InferenceContext18.CHECK_UNKNOWN;
         	this.bits &= ~ASTNode.DepthMASK;
         }
 
@@ -705,62 +725,46 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		return this.descriptor.parameters;
 	}
 
-	private HashMap<TypeBinding, MethodBinding> declarationPerTargetType;
-
-	/** During inference: Try to find an applicable method binding without causing undesired side-effects. */
-	public MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope) {
-		if (this.exactMethodBinding != null) {
+	public ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope) {
+	
+		if (this.exactMethodBinding != null) { // We may see inference variables in target type.
 			MethodBinding functionType = targetType.getSingleAbstractMethod(scope, true);
 			if (functionType == null)
 				return null;
 			int n = functionType.parameters.length;
 			int k = this.exactMethodBinding.parameters.length;
-			return (n == k || n == k + 1) ? this.exactMethodBinding : null;
-		}
-		MethodBinding targetMethod = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(targetType) : null;
-		if (targetMethod == null) {
-			targetMethod = internalResolveTentatively(targetType, scope);
-			registerResult(targetType, targetMethod);
+			return (n == k || n == k + 1) ? this : null;
 		}
-		if (targetMethod == null || !targetMethod.isValidBinding())
-			return null;
-		return targetMethod;
-	}
-
-	// Cache compile time declaration against various target types, so repeat overload resolution and possibly type inference could be avoided.
-	private void registerResult(TypeBinding targetType, MethodBinding declaration) {
-		if (this.declarationPerTargetType == null)
-			this.declarationPerTargetType = new HashMap<TypeBinding, MethodBinding>();
-		this.declarationPerTargetType.put(targetType, declaration);
-	}
-
-	MethodBinding internalResolveTentatively(TypeBinding targetType, Scope scope) {
-		// FIXME: could enclosingScope still be null here??
+		
+		// We are guaranteed here that we will not see inference variables in descriptor parameters.
+		ReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;
+		if (copy != null)
+			return copy;
+		
 		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
-		ExpressionContext previousContext = this.expressionContext;
-		MethodBinding previousBinding = this.binding;
-		MethodBinding previousDescriptor = this.descriptor;
-		TypeBinding previousResolvedType = this.resolvedType;
-		TypeBinding previousExpectedType = this.expectedType;
 		try {
-			setExpressionContext(INVOCATION_CONTEXT);
-			setExpectedType(targetType);
-			this.binding = null;
-			this.trialResolution = true;
-			resolveType(this.enclosingScope);
-			return this.binding;
+			copy = copy();
+			if (copy == null) { // should never happen even for code assist.
+				return null;
+			}
+			copy.setExpressionContext(this.expressionContext);
+			copy.setExpectedType(targetType);
+			copy.resolveType(this.enclosingScope);
+			registerCopy(targetType, copy);
+			return copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding() ? copy : null;
 		} finally {
 			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
-			// remove *any relevant* traces of this 'inofficial' resolving:
-			this.binding = previousBinding;
-			this.descriptor = previousDescriptor;
-			this.resolvedType = previousResolvedType;
-			setExpressionContext(previousContext);
-			this.expectedType = previousExpectedType;
-			this.trialResolution = false;
 		}
 	}
 
+	// Cache resolved copies against various target types, so repeat overload resolution and possibly type inference could be avoided.
+	private ReferenceExpression registerCopy(TypeBinding targetType, ReferenceExpression copy) {
+		if (this.copiesPerTargetType == null)
+			this.copiesPerTargetType = new HashMap<TypeBinding, ReferenceExpression>();
+		this.copiesPerTargetType.put(targetType, copy);
+		return copy;
+	}
+
 	public boolean isConstructorReference() {
 		return CharOperation.equals(this.selector,  ConstantPool.Init);
 	}
@@ -959,34 +963,29 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         return false;
 	}
 	
-	public boolean isCompatibleWith(TypeBinding left, Scope scope) {
-		if (this.binding != null && this.binding.isValidBinding() // binding indicates if full resolution has already happened
-				&& this.resolvedType != null && this.resolvedType.isValidBinding()) {
-			return this.resolvedType.isCompatibleWith(left, scope);
-		}
+	public boolean isCompatibleWith(TypeBinding targetType, Scope scope) {
+		ReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;
+		if (copy != null)
+			return copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();
+		
 		// 15.13.2
-		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);
+		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sam == null || !sam.isValidBinding())
 			return false;
-		boolean isCompatible;
-		setExpectedType(left);
 		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
 		try {
-			this.binding = null;
-			this.trialResolution = true;
-			this.binding = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(left) : null;
-			if (this.binding == null) {
-				resolveType(this.enclosingScope);
-				registerResult(left, this.binding);
+			copy = copy();
+			if (copy == null) { // should never happen even for code assist.
+				return false;
 			}
+			copy.setExpressionContext(this.expressionContext);
+			copy.setExpectedType(targetType);
+			copy.resolveType(this.enclosingScope);
+			registerCopy(targetType, copy);
+			return copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();
 		} finally {
 			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
-			isCompatible = this.binding != null && this.binding.isValidBinding();
-			this.binding = null;
-			setExpectedType(null);
-			this.trialResolution = false;
 		}
-		return isCompatible;
 	}
 	
 	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t, Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
index 00bf725..ef47dae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
@@ -79,14 +79,14 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 		
 		TypeBinding[] ePrime = null;
 		if (this.left instanceof LambdaExpression) {
-			LambdaExpression lambda = ((LambdaExpression) this.left).getResolvedCopyForInferenceTargeting(this.right);
+			LambdaExpression lambda = ((LambdaExpression) this.left).resolveExpressionExpecting(this.right, inferenceContext.scope);
 			if (lambda == null)
 				return TRUE; // cannot make use of this buggy constraint
 			Set<TypeBinding> ePrimeSet = lambda.getThrownExceptions();
 			ePrime = ePrimeSet.toArray(new TypeBinding[ePrimeSet.size()]);
 		} else {
-			ReferenceExpression referenceExpression = (ReferenceExpression)this.left;
-			MethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);
+			ReferenceExpression referenceExpression = ((ReferenceExpression) this.left).resolveExpressionExpecting(this.right, scope);
+			MethodBinding method = referenceExpression != null ? referenceExpression.binding : null;
 			if (method != null)
 				ePrime = method.thrownExceptions;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index acd4755..858fea8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -155,7 +155,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					for (int i = 0; i < parameters.length; i++)
 						if (!parameters[i].isProperType(true))
 							return FALSE;
-				lambda = lambda.getResolvedCopyForInferenceTargeting(t);
+				lambda = lambda.resolveExpressionExpecting(t, inferenceContext.scope);
 				if (lambda == null)
 					return FALSE; // not strictly unreduceable, but proceeding with TRUE would likely produce secondary errors
 				if (functionType.returnType == TypeBinding.VOID) {
@@ -238,7 +238,8 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		if (functionType == null)
 			return FALSE;
 		// potentially-applicable method for the method reference when targeting T (15.13.1),
-		MethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope);
+		reference = reference.resolveExpressionExpecting(t, inferenceContext.scope);
+		MethodBinding potentiallyApplicable = reference != null ? reference.binding : null;
 		if (potentiallyApplicable == null)
 			return FALSE;
 		if (reference.isExactMethodReference()) {
@@ -433,7 +434,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				if (sam.returnType != TypeBinding.VOID) {
 					// ii)
 					final TypeBinding r = sam.returnType;
-					LambdaExpression resolved = lambda.getResolvedCopyForInferenceTargeting(this.right);
+					LambdaExpression resolved = lambda.resolveExpressionExpecting(this.right, context.scope);
 					Expression[] resultExpressions = resolved != null ? resolved.resultExpressions() : null;
 					for (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {
 						variables.addAll(new ConstraintExpressionFormula(resultExpressions[i], r, COMPATIBLE).inputVariables(context));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index d2a1be5..601d1aa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -456,7 +456,7 @@ public class InferenceContext18 {
 						t = ConstraintExpressionFormula.findGroundTargetType(this, skope, lambda, withWildCards);
 					}
 					MethodBinding functionType;
-					if (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.getResolvedCopyForInferenceTargeting(t)) != null) {
+					if (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.resolveExpressionExpecting(t, this.scope)) != null) {
 						TypeBinding r = functionType.returnType;
 						Expression[] resultExpressions = lambda.resultExpressions();
 						for (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
index fdbd2f1..da0a97f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
@@ -43,6 +43,11 @@ public class PolyTypeBinding extends TypeBinding {
 	}
 	
 	@Override
+	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope) {
+		return this.expression.isPotentiallyCompatibleWith(targetType, scope);
+	}
+	
+	@Override
 	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
 		return this.expression.isPertinentToApplicability(typeVariable, method);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 5bb673f..60e1b70 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -622,6 +622,10 @@ public boolean isCompatibleWith(TypeBinding right) {
 // version that allows to capture a type bound using 'scope':
 public abstract boolean isCompatibleWith(TypeBinding right, /*@Nullable*/ Scope scope);
 
+public boolean isPotentiallyCompatibleWith(TypeBinding right, /*@Nullable*/ Scope scope) {
+	return isCompatibleWith(right, scope);
+}
+
 /* Answer true if the receiver type can be assigned to the argument type (right) with boxing/unboxing applied.
  */
 public boolean isBoxingCompatibleWith(TypeBinding right, /*@NonNull */ Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index e814ddc..2168ec1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -8249,6 +8249,11 @@ protected void consumeReferenceExpression(ReferenceExpression referenceExpressio
 	if (!this.parsingJava8Plus) {
 		problemReporter().referenceExpressionsNotBelow18(referenceExpression);
 	}
+	if (referenceExpression.compilationResult.getCompilationUnit() == null) {
+		// unit built out of model. Stash a textual representation to enable RE.copy().
+		int length = referenceExpression.sourceEnd - referenceExpression.sourceStart + 1;
+		System.arraycopy(this.scanner.getSource(), referenceExpression.sourceStart, referenceExpression.text = new char [length], 0, length); 
+	}
 	this.referenceContext.compilationResult().hasFunctionalTypes = true;
 	markEnclosingMemberWithLocalOrFunctionalType(LocalTypeKind.METHOD_REFERENCE);
 }
commit a6829de4e3db7f328203e4f515f45bdc76ef3eb6
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Nov 6 11:20:02 2014 +0530

    Batch 2 of changes for Bug 447579 - [1.8][compiler] Poly expressions
    APIs need unification

2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
14	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
24	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index bc9d83b..bae3701 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -464,7 +464,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			if (conditionType == null || this.originalValueIfTrueType == null || this.originalValueIfFalseType == null)
 				return null;
 		} else {
-
 			if (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE)
 				this.originalValueIfTrueType = this.valueIfTrue.resolveType(scope);
 			if (this.originalValueIfFalseType.kind() == Binding.POLY_TYPE)
@@ -477,10 +476,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		}
 		if (isPolyExpression()) {
 			if (this.expectedType == null) {
-				return new PolyTypeBinding(this);
+				return this.resolvedType = new PolyTypeBinding(this);
 			}
 			return this.resolvedType = computeConversions(scope, this.expectedType) ? this.expectedType : null;
 		}
+
 		TypeBinding valueIfTrueType = this.originalValueIfTrueType;
 		TypeBinding valueIfFalseType = this.originalValueIfFalseType;
 		if (use15specifics && TypeBinding.notEquals(valueIfTrueType, valueIfFalseType)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 52f34f3..f3428af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -228,22 +228,23 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 	 */
 	public TypeBinding resolveType(BlockScope blockScope) {
 		
-		if (this.expectedType != null && this.original == this) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
-			this.ordinal = recordFunctionalType(blockScope);
-		}
-		
-		this.constant = Constant.NotAConstant;
-		this.enclosingScope = blockScope;
-		
 		boolean argumentsTypeElided = argumentsTypeElided();
 		int length = this.arguments == null ? 0 : this.arguments.length;
-		if (!argumentsTypeElided) {
-			for (int i = 0; i < length; i++)
-				this.argumentTypes[i] = this.arguments[i].type.resolveType(blockScope, true /* check bounds*/);
+		
+		if (this.constant != Constant.NotAConstant) {
+			this.constant = Constant.NotAConstant;
+			this.enclosingScope = blockScope;
+			if (this.original == this)
+				this.ordinal = recordFunctionalType(blockScope);
+			
+			if (!argumentsTypeElided) {
+				for (int i = 0; i < length; i++)
+					this.argumentTypes[i] = this.arguments[i].type.resolveType(blockScope, true /* check bounds*/);
+			}
+			if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
+				return this.resolvedType = new PolyTypeBinding(this);
+			} 
 		}
-		if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
-			return this.resolvedType = new PolyTypeBinding(this);
-		} 
 		
 		MethodScope methodScope = blockScope.methodScope();
 		this.scope = new MethodScope(blockScope, this, methodScope.isStatic, methodScope.lastVisibleFieldID);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 6833b2d..9f19e60 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -383,17 +383,15 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
 	
 	public TypeBinding resolveType(BlockScope scope) {
 		
-		if (this.expectedType != null && this.original == this) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
-			recordFunctionalType(scope);
-		}
-		
 		final CompilerOptions compilerOptions = scope.compilerOptions();
 		TypeBinding lhsType;
     	if (this.constant != Constant.NotAConstant) {
     		this.constant = Constant.NotAConstant;
     		this.enclosingScope = scope;
-    		this.lhs.bits |= ASTNode.IgnoreRawTypeCheck;
+    		if (this.original == this)
+    			recordFunctionalType(scope);
 
+    		this.lhs.bits |= ASTNode.IgnoreRawTypeCheck;
     		lhsType = this.lhs.resolveType(scope);
     		this.lhs.computeConversion(scope, lhsType, lhsType);
     		if (this.typeArguments != null) {
@@ -448,9 +446,23 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
     			scope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);
     		}
 
+    		if (isConstructorReference() && lhsType.isArrayType()) {
+	        	final TypeBinding leafComponentType = lhsType.leafComponentType();
+				if (!leafComponentType.isReifiable()) {
+	        		scope.problemReporter().illegalGenericArray(leafComponentType, this);
+	        		return this.resolvedType = null;
+	        	}
+				if (this.typeArguments != null) {
+	                scope.problemReporter().invalidTypeArguments(this.typeArguments);
+	                return this.resolvedType = null;
+	            }
+	        	this.binding = this.exactMethodBinding = scope.getExactConstructor(lhsType, this);
+	        }
+
 	    	if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
 	    		return this.resolvedType = new PolyTypeBinding(this);
 			}
+
     	} else {
     		lhsType = this.lhs.resolvedType;
     		if (this.typeArgumentsHaveErrors || lhsType == null)
@@ -458,7 +470,13 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
     	}
 
     	super.resolveType(scope);
-		
+
+		/* For Reference expressions unlike other call sites, we always have a receiver _type_ since LHS of :: cannot be empty. 
+		   LHS's resolved type == actual receiver type. All code below only when a valid descriptor is available.
+		*/
+    	if (this.descriptor == null || !this.descriptor.isValidBinding())
+    		return this.resolvedType =  null;
+     
     	// Convert parameters into argument expressions for look up.
 		TypeBinding[] descriptorParameters = descriptorParametersAsArgumentExpressions();
 		
@@ -480,11 +498,6 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
 		// handle the special case of array construction first.
 		final int parametersLength = descriptorParameters.length;
         if (isConstructorReference() && lhsType.isArrayType()) {
-        	final TypeBinding leafComponentType = lhsType.leafComponentType();
-			if (!leafComponentType.isReifiable()) {
-        		scope.problemReporter().illegalGenericArray(leafComponentType, this);
-        		return this.resolvedType = null;
-        	}
         	if (parametersLength != 1 || scope.parameterCompatibilityLevel(descriptorParameters[0], TypeBinding.INT) == Scope.NOT_COMPATIBLE) {
         		scope.problemReporter().invalidArrayConstructorReference(this, lhsType, descriptorParameters);
         		return this.resolvedType = null;
@@ -493,22 +506,9 @@ public class ReferenceExpression extends FunctionalExpression implements IPolyEx
         		scope.problemReporter().constructedArrayIncompatible(this, lhsType, this.descriptor.returnType);
         		return this.resolvedType = null;
         	}
-
-            if (this.typeArguments != null) {
-                scope.problemReporter().invalidTypeArguments(this.typeArguments);
-                return this.resolvedType = null;
-            }
-
-        	this.binding = this.exactMethodBinding = scope.getExactConstructor(lhsType, this);
         	return this.resolvedType;
         }
 
-		/* For Reference expressions unlike other call sites, we always have a receiver _type_ since LHS of :: cannot be empty. 
-		   LHS's resolved type == actual receiver type. All code below only when a valid descriptor is available.
-		 */
-        if (this.descriptor == null || !this.descriptor.isValidBinding())
-        	return this.resolvedType =  null;
-        
         // 15.13.1
         final boolean isMethodReference = isMethodReference();
         this.depth = 0;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 858fea8..35a6811 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -169,7 +169,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				if (!lambda.argumentsTypeElided()) {
 					Argument[] arguments = lambda.arguments();
 					for (int i = 0; i < parameters.length; i++)
-						result.add(ConstraintTypeFormula.create(parameters[i], arguments[i].type.resolveType(lambda.enclosingScope), SAME));
+						result.add(ConstraintTypeFormula.create(parameters[i], arguments[i].type.resolvedType, SAME));
 					// in addition, ⟨T' <: T⟩:
 					if (lambda.resolvedType != null)
 						result.add(ConstraintTypeFormula.create(lambda.resolvedType, this.right, SUBTYPE));
