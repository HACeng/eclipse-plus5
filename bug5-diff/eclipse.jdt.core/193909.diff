commit 3d9ca5323b31c8907d129d4437482cfc3b641c64
Author: David Audel <daudel>
Date:   Thu Oct 25 11:06:17 2007 +0000

    HEAD - bug 193909

4	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/FieldAccessCompletionTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/NameReferenceCompletionTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceTypeCompletionTest.java
1285	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
28	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
849	245	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
123	39	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
39	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
1	0	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
210	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/FieldAccessCompletionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/FieldAccessCompletionTest.java
index 69dd671..e8664c7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/FieldAccessCompletionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/FieldAccessCompletionTest.java
@@ -1289,7 +1289,8 @@ public void testIfThenStatement() {
 		"  Bar() {\n" + 
 		"  }\n" + 
 		"  void foo() {\n" + 
-		"    <CompleteOnMemberAccess:fred().x>;\n" + 
+		"    if (true)\n" + 
+		"        <CompleteOnMemberAccess:fred().x>;\n" + 
 		"  }\n" + 
 		"}\n",
 		// expectedCompletionIdentifier:
@@ -1325,7 +1326,8 @@ public void testIfThenStatementElse() {
 		"  Bar() {\n" + 
 		"  }\n" + 
 		"  void foo() {\n" + 
-		"    <CompleteOnMemberAccess:fred().x>;\n" + 
+		"    if (true)\n" + 
+		"        <CompleteOnMemberAccess:fred().x>;\n" + 
 		"  }\n" + 
 		"}\n",
 		// expectedCompletionIdentifier:
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/NameReferenceCompletionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/NameReferenceCompletionTest.java
index cccdeea..6128eba 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/NameReferenceCompletionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/NameReferenceCompletionTest.java
@@ -495,7 +495,8 @@ public void testInIfThenStatement() {
 		"  Bar() {\n" + 
 		"  }\n" + 
 		"  void foo() {\n" +
-		"    <CompleteOnName:>;\n" +
+		"    if (bar())\n" + 
+		"        <CompleteOnName:>;\n" +
 		"  }\n" + 
 		"}\n",
 		// expectedCompletionIdentifier:
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceTypeCompletionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceTypeCompletionTest.java
index d8be1fa..82dffda 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceTypeCompletionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ReferenceTypeCompletionTest.java
@@ -855,7 +855,8 @@ public void testDeepReference() {
 		"  void foo() {\n" +
 		"    {\n" +
 		"      {\n" +
-		"        <CompleteOnName:X>;\n" +
+		"        if ((1 == fgh))\n" + 
+		"            <CompleteOnName:X>;\n" +
 		"      }\n" +
 		"    }\n" +
 		"  }\n" +
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index a466661..bed3304 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -1562,6 +1562,1291 @@ public void testCompletionAfterCase4() throws JavaModelException {
 			"ZZZ1[FIELD_REF]{ZZZ1, Ltest.TestConstants;, I, ZZZ1, null, " + (R_DEFAULT + R_RESOLVED + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_CASE + R_QUALIFIED+ R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof02_01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	void bar(){\n" +
+		"		if (this.a instanceof CompletionAfterInstanceOf) {\n" +
+		"			this.a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("this.a.equal");
+	int end2 = start2 + "this.a.equal".length();
+	int start3 = str.lastIndexOf("this.a.");
+	int end3 = start3 + "this.a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)this.a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof02_02() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	void bar(){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			this.a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("this.a.equal");
+	int end2 = start2 + "this.a.equal".length();
+	int start3 = str.lastIndexOf("this.a.");
+	int end3 = start3 + "this.a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)this.a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof02_03() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	void bar(){\n" +
+		"		if (this.a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof02_04() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	void bar(){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof03_01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf)\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof03_02() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf)\n" +
+		"			bar(a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof03_03() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		while (true) {\n" +
+		"			if (a instanceof CompletionAfterInstanceOf)\n" +
+		"				bar(a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof03_04() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (true) {\n" +
+		"			if (a instanceof CompletionAfterInstanceOf)\n" +
+		"				bar(a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof03_05() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) \n" +
+		"			while (true)\n" +
+		"				a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof03_06() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) \n" +
+		"			while (a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof04() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			bar(null);\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof05() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			class Z {}\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof06_01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			while (true) {\n" +
+		"				a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof06_02() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			while (true) \n" +
+		"				a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof07() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			if (b instanceof CompletionAfterInstanceOf2) {\n" +
+		"				a.equal\n" +
+		"	}\n" +
+		"}\n" +
+		"class CompletionAfterInstanceOf2 {\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof08() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (b instanceof CompletionAfterInstanceOf2) {\n" +
+		"			if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"				a.equal\n" +
+		"	}\n" +
+		"}\n" +
+		"class CompletionAfterInstanceOf2 {\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof09() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (!(a instanceof CompletionAfterInstanceOf)) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof10() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a, boolean b){\n" +
+		"		if (b && (a instanceof CompletionAfterInstanceOf)) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof11() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a, boolean b){\n" +
+		"		if (b || (a instanceof CompletionAfterInstanceOf)) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof12() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			#\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof13() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		#\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof14() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			(a).equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof15() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a, Object b){\n" +
+		"		if (b instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof16() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	public CompletionAfterInstanceOf b;\n" +
+		"	void bar(Object a){\n" +
+		"		if (b.a instanceof CompletionAfterInstanceOf) {\n" +
+		"			b.a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// unsupported case
+public void testCompletionAfterInstanceof17() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public Object a;\n" +
+		"	public CompletionAfterInstanceOf b;\n" +
+		"	void bar(Object a){\n" +
+		"		if (b.a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof18_01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			bar(a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof18_02() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			new CompletionAfterInstanceOf(){}.bar(a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof18_03() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a, Object b){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			bar(new CompletionAfterInstanceOf(){}, a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof19() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a /* comment 1 */\n" +
+		"				/* comment 2 */ . /* comment 3 */\n" +
+		"					/* comment 4 */ equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a /* comment 1 */");
+	int end2 = start2 + "a /* comment 1 */\n\t\t\t\t/* comment 2 */ . /* comment 3 */\n\t\t\t\t\t/* comment 4 */ equal".length();
+	int start3 = str.lastIndexOf("a /* comment 1 */");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a) /* comment 1 */\n\t\t\t\t/* comment 2 */ . /* comment 3 */\n\t\t\t\t\t/* comment 4 */ equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof20() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		#\n" +
+		"		bar(null);\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo(), Ltest.CompletionAfterInstanceOf;, ()V, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof21() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf)\n" +
+		"			bar(null);\n" +
+		"		a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof22_01() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			bar(null);\n" +
+		"		} else {\n" +
+		"			a.equal\n" +
+		"		}\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof22_02() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf)\n" +
+		"			bar(null);\n" +
+		"		else {\n" +
+		"			a.equal\n" +
+		"		}\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof22_03() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			bar(null);\n" +
+		"		} else\n" +
+		"			a.equal\n" +
+		"		\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// should not return proposals related to instanceof
+public void testCompletionAfterInstanceof22_04() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public void equalsFoo(){}\n" +
+		"	public void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf)\n" +
+		"			bar(null);\n" +
+		"		else\n" +
+		"			a.equal\n" +
+		"		\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof23() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public int equalsFoo;\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf) {\n" +
+		"			a.equal\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "equal";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("equal") + "".length();
+	int end1 = start1 + "equal".length();
+	int start2 = str.lastIndexOf("a.equal");
+	int end2 = start2 + "a.equal".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"equalsFoo[FIELD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).equalsFoo, Ltest.CompletionAfterInstanceOf;, I, Ltest.CompletionAfterInstanceOf;, equalsFoo, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof24_1() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public int equalsFoo;\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf[]) {\n" +
+		"			a.le\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "a.le";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("le");
+	int end1 = start1 + "le".length();
+	int start2 = str.lastIndexOf("a.le");
+	int end2 = start2 + "a.le".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"length[FIELD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).length, [Ltest.CompletionAfterInstanceOf;, I, [Ltest.CompletionAfterInstanceOf;, length, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193909
+// supported case
+public void testCompletionAfterInstanceof24_2() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/CompletionAfterInstanceOf.java",
+		"package test;\n" +
+		"public class CompletionAfterInstanceOf {\n" +
+		"	public int equalsFoo;\n" +
+		"	void bar(Object a){\n" +
+		"		if (a instanceof CompletionAfterInstanceOf[]) {\n" +
+		"			a.cl\n" +
+		"	}\n" +
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, true, true, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "a.cl";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("cl") + "".length();
+	int end1 = start1 + "cl".length();
+	int start2 = str.lastIndexOf("a.cl");
+	int end2 = start2 + "a.cl".length();
+	int start3 = str.lastIndexOf("a.");
+	int end3 = start3 + "a".length();
+	assertResults(
+			"clone[METHOD_REF]{clone(), Ljava.lang.Object;, ()Ljava.lang.Object;, clone, null, replace["+start1+", "+end1+"], token["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"clone[METHOD_REF_WITH_CASTED_RECEIVER]{((CompletionAfterInstanceOf)a).clone(), [Ltest.CompletionAfterInstanceOf;, ()Ljava.lang.Object;, [Ltest.CompletionAfterInstanceOf;, clone, null, replace["+start2+", "+end2+"], token["+start1+", "+end1+"], receiver["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
 public void testCompletionAfterSupercall1() throws JavaModelException {
 	this.workingCopies = new ICompilationUnit[1];
 	this.workingCopies[0] = getWorkingCopy(
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
index d54af4c..b101f45 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
@@ -82,7 +82,7 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	
 	public void allowAllRequiredProposals() {
 		for (int i = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; i <= CompletionProposal.TYPE_IMPORT; i++) {
-			for (int j = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; j <= CompletionProposal.TYPE_IMPORT; j++) {
+			for (int j = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; j <= CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER; j++) {
 				this.setAllowsRequiredProposals(i, j, true);
 			}
 		}
@@ -242,6 +242,9 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.FIELD_REF :
 				buffer.append("FIELD_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("FIELD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				break;
 			case CompletionProposal.KEYWORD :
 				buffer.append("KEYWORD"); //$NON-NLS-1$
 				break;
@@ -263,6 +266,12 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 					buffer.append("<CONSTRUCTOR>"); //$NON-NLS-1$
 				}
 				break;
+			case CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("METHOD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				if(proposal.isConstructor()) {
+					buffer.append("<CONSTRUCTOR>"); //$NON-NLS-1$
+				}
+				break;
 			case CompletionProposal.PACKAGE_REF :
 				buffer.append("PACKAGE_REF"); //$NON-NLS-1$
 				break;
@@ -322,6 +331,13 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 		buffer.append(proposal.getDeclarationSignature() == null ? NULL_LITERAL : proposal.getDeclarationSignature());  
 		buffer.append(", ");
 		buffer.append(proposal.getSignature() == null ? NULL_LITERAL : proposal.getSignature());
+		
+		char[] receiverSignature = proposal.getReceiverSignature();
+		if (receiverSignature != null) {
+			buffer.append(", ");
+			buffer.append(receiverSignature);
+		}
+		
 		if(this.showUniqueKeys) {
 			buffer.append(", ");
 			buffer.append(proposal.getDeclarationKey() == null ? NULL_LITERAL : proposal.getDeclarationKey());
@@ -347,7 +363,7 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 		
 		if(this.showPositions) {
 			buffer.append(", ");
-			if(this.showTokenPositions) buffer.append("replace");
+			if(this.showTokenPositions || receiverSignature != null) buffer.append("replace");
 			buffer.append("[");
 			buffer.append(proposal.getReplaceStart());
 			buffer.append(", ");
@@ -361,6 +377,13 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			buffer.append(proposal.getTokenEnd());
 			buffer.append("]");
 		}
+		if(this.showPositions && receiverSignature != null) {
+			buffer.append(", receiver[");
+			buffer.append(proposal.getReceiverStart());
+			buffer.append(", ");
+			buffer.append(proposal.getReceiverEnd());
+			buffer.append("]");
+		}
 		buffer.append(", ");
 		buffer.append(proposal.getRelevance());
 		buffer.append('}');
@@ -448,10 +471,12 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.JAVADOC_TYPE_REF :
 				return new String(Signature.getSignatureSimpleName(proposal.getSignature()));
 			case CompletionProposal.FIELD_REF :
+			case CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER :
 			case CompletionProposal.KEYWORD:
 			case CompletionProposal.LABEL_REF:
 			case CompletionProposal.LOCAL_VARIABLE_REF:
 			case CompletionProposal.METHOD_REF:
+			case CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER:
 			case CompletionProposal.METHOD_DECLARATION:
 			case CompletionProposal.VARIABLE_DECLARATION:
 			case CompletionProposal.POTENTIAL_METHOD_DECLARATION:
@@ -467,7 +492,7 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.METHOD_IMPORT :
 				return new String(proposal.getName());
 			case CompletionProposal.PACKAGE_REF:
-				return new String(proposal.getDeclarationSignature());	
+				return new String(proposal.getDeclarationSignature());
 		}
 		return "";
 	}
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index d505dfa..7d6d556 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -102,7 +102,9 @@ public interface IJavaElementDelta {
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=207299">207299</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=193909">193909</a>
+improve content assist after 'instanceof'
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=207299">207299</a>
 [1.5][compiler] StackOverflow when eliminating type variables
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=207418">207418</a>
 Need API on CompletionRequestor to ignore all proposals
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 5a0c3b6..70f6500 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -242,6 +242,8 @@ public final class CompletionEngine
 	private final static char[] EXTENDS = "extends".toCharArray();  //$NON-NLS-1$
 	private final static char[] SUPER = "super".toCharArray();  //$NON-NLS-1$
 	
+	private final static char[] DOT = ".".toCharArray();  //$NON-NLS-1$
+	
 	private final static char[] VARARGS = "...".toCharArray();  //$NON-NLS-1$
 	
 	private final static char[] IMPORT = "import".toCharArray();  //$NON-NLS-1$
@@ -917,7 +919,7 @@ public final class CompletionEngine
 		this.requestor.acceptContext(context);
 	}
 	
-	private boolean complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
+	private boolean complete(ASTNode astNode, ASTNode astNodeParent, ASTNode enclosingNode, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
 
 		setSourceAndTokenRange(astNode.sourceStart, astNode.sourceEnd);
 
@@ -946,7 +948,28 @@ public final class CompletionEngine
 				SourceTypeBinding enclosingType = scope.enclosingSourceType();
 				if (!enclosingType.isAnnotationType()) {
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
-						findMethods(this.completionToken,null,null,enclosingType,scope,new ObjectVector(),false,false,true,null,null,false,false,true,null, null, null, false);
+						findMethods(
+								this.completionToken,
+								null,
+								null,
+								enclosingType,
+								scope,
+								new ObjectVector(),
+								false,
+								false,
+								true,
+								null,
+								null,
+								false,
+								false,
+								true,
+								null,
+								null,
+								null,
+								false,
+								null,
+								-1,
+								-1);
 					}
 					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
 						proposeNewMethod(this.completionToken, enclosingType);
@@ -968,7 +991,27 @@ public final class CompletionEngine
 				SourceTypeBinding enclosingType = scope.enclosingSourceType();
 				if (!enclosingType.isAnnotationType()) {
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
-						findMethods(this.completionToken,null,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true,null, null, null, false);
+						findMethods(
+								this.completionToken,
+								null,null,
+								scope.enclosingSourceType(),
+								scope,
+								new ObjectVector(),
+								false,
+								false,
+								true,
+								null,
+								null,
+								false,
+								false,
+								true,
+								null,
+								null,
+								null,
+								false,
+								null,
+								-1,
+								-1);
 					}
 					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
 						proposeNewMethod(this.completionToken, scope.enclosingSourceType());
@@ -1114,7 +1157,37 @@ public final class CompletionEngine
 				setSourceAndTokenRange((int) (completionPosition >>> 32), (int) completionPosition);
 				TypeBinding receiverType = ((VariableBinding) qualifiedBinding).type;
 				if (receiverType != null) {
-					findFieldsAndMethods(this.completionToken, receiverType.capture(scope, ref.sourceEnd), scope, ref, scope,false,false, null, null, null, false);
+					ObjectVector fieldsFound = new ObjectVector();
+					ObjectVector methodsFound = new ObjectVector();
+					
+					findFieldsAndMethods(
+							this.completionToken,
+							receiverType.capture(scope, ref.sourceEnd),
+							scope,
+							fieldsFound,
+							methodsFound,
+							ref,
+							scope,
+							false,
+							false,
+							null,
+							null,
+							null,
+							false,
+							null,
+							-1,
+							-1);
+					
+					findFieldsAndMethodsFromCastedReceiver(
+							enclosingNode,
+							qualifiedBinding,
+							scope,
+							fieldsFound,
+							methodsFound,
+							ref,
+							scope,
+							ref);
+					
 				} else if (this.assistNodeInJavadoc == 0 &&
 						(this.requestor.isAllowingRequiredProposals(CompletionProposal.FIELD_REF, CompletionProposal.TYPE_REF) ||
 								this.requestor.isAllowingRequiredProposals(CompletionProposal.METHOD_REF, CompletionProposal.TYPE_REF))) {
@@ -1249,18 +1322,40 @@ public final class CompletionEngine
 						findKeywords(this.completionToken, new char[][]{Keywords.NEW}, false, false);
 					}
 					
+					ObjectVector fieldsFound = new ObjectVector();
+					ObjectVector methodsFound = new ObjectVector();
+					
+					boolean superCall = access.receiver instanceof SuperReference;
+					
 					findFieldsAndMethods(
 						this.completionToken,
 						((TypeBinding) qualifiedBinding).capture(scope, access.receiver.sourceEnd),
 						scope,
+						fieldsFound,
+						methodsFound,
 						access,
 						scope,
 						false,
-						access.receiver instanceof SuperReference,
+						superCall,
 						null,
 						null,
 						null,
-						false);
+						false,
+						null,
+						-1,
+						-1);
+					
+					if (!superCall) {
+						findFieldsAndMethodsFromCastedReceiver(
+								enclosingNode,
+								qualifiedBinding,
+								scope,
+								fieldsFound,
+								methodsFound,
+								access,
+								scope,
+								access.receiver);
+					}
 				}
 			}
 
@@ -1293,7 +1388,10 @@ public final class CompletionEngine
 					null,
 					null,
 					null,
-					false);
+					false,
+					null,
+					-1,
+					-1);
 			}
 		} else if (astNode instanceof CompletionOnExplicitConstructorCall) {
 			if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
@@ -1580,7 +1678,10 @@ public final class CompletionEngine
 								null,
 								null,
 								null,
-								false);
+								false,
+								null,
+								-1,
+								-1);
 					}
 				}
 			}
@@ -1670,12 +1771,16 @@ public final class CompletionEngine
 							null,
 							null,
 							null,
-							false);
+							false,
+							null,
+							-1,
+							-1);
 					}
 
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)
 							|| !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
-						findMethods(this.completionToken,
+						findMethods(
+							this.completionToken,
 							null,
 							null,
 							receiverType,
@@ -1692,7 +1797,10 @@ public final class CompletionEngine
 							null,
 							null,
 							null,
-							false);
+							false,
+							null,
+							-1,
+							-1);
 						if (fieldRef.receiverType instanceof ReferenceBinding) {
 							ReferenceBinding refBinding = (ReferenceBinding)fieldRef.receiverType;
 							if (this.completionToken == null
@@ -1744,7 +1852,10 @@ public final class CompletionEngine
 						null,
 						null,
 						null,
-						false);
+						false,
+						null,
+						-1,
+						-1);
 				}
 			} else if (astNode instanceof CompletionOnJavadocAllocationExpression) {
 //				setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
@@ -1789,6 +1900,149 @@ public final class CompletionEngine
 		return true;
 	}
 
+	private void findFieldsAndMethodsFromCastedReceiver(
+			ASTNode enclosingNode,
+			Binding qualifiedBinding,
+			Scope scope,
+			ObjectVector fieldsFound,
+			ObjectVector methodsFound,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			Expression receiver) {
+		
+		if (enclosingNode == null || !(enclosingNode instanceof IfStatement)) return;
+		
+		IfStatement ifStatement = (IfStatement)enclosingNode;
+		
+		if (!(ifStatement.condition instanceof InstanceOfExpression)) return;
+		
+		InstanceOfExpression instanceOfExpression = (InstanceOfExpression) ifStatement.condition;
+		
+		TypeReference instanceOfType = instanceOfExpression.type;
+		
+		if (instanceOfType.resolvedType == null) return;
+		
+		boolean findFromAnotherReceiver = false;
+		
+		char[][] receiverName = null;
+		int receiverStart = -1;
+		int receiverEnd = -1;
+		
+		if (receiver instanceof QualifiedNameReference) {
+			QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) receiver;
+			
+			receiverName = qualifiedNameReference.tokens;
+			
+			if (receiverName.length != 1) return;
+			
+			receiverStart = (int) (qualifiedNameReference.sourcePositions[0] >>> 32);
+			receiverEnd = (int) qualifiedNameReference.sourcePositions[qualifiedNameReference.tokens.length - 1] + 1;
+		
+			// if (local instanceof X) local.|
+			// if (field instanceof X) field.|
+			if (instanceOfExpression.expression instanceof SingleNameReference &&
+					((SingleNameReference)instanceOfExpression.expression).binding == qualifiedBinding &&
+					(qualifiedBinding instanceof LocalVariableBinding || qualifiedBinding instanceof FieldBinding)) {
+				findFromAnotherReceiver = true;
+			}
+			
+			// if (this.field instanceof X) field.|
+			if (instanceOfExpression.expression instanceof FieldReference) {
+				FieldReference fieldReference = (FieldReference)instanceOfExpression.expression;
+				
+				if (fieldReference.receiver instanceof ThisReference &&
+						qualifiedBinding instanceof FieldBinding &&
+						fieldReference.binding == qualifiedBinding) {
+							findFromAnotherReceiver = true;
+				}
+			}
+		} else if (receiver instanceof FieldReference) {
+			FieldReference fieldReference1 = (FieldReference) receiver;
+			
+			receiverStart = fieldReference1.sourceStart;
+			receiverEnd = fieldReference1.sourceEnd + 1;
+			
+			if (fieldReference1.receiver instanceof ThisReference) {
+				
+				receiverName = new char[][] {THIS, fieldReference1.token};
+				
+				// if (field instanceof X) this.field.|
+				if (instanceOfExpression.expression instanceof SingleNameReference &&
+						((SingleNameReference)instanceOfExpression.expression).binding == fieldReference1.binding) {
+					findFromAnotherReceiver = true;
+				}
+				
+				// if (this.field instanceof X) this.field.|
+				if (instanceOfExpression.expression instanceof FieldReference) {
+					FieldReference fieldReference2 = (FieldReference)instanceOfExpression.expression;
+					
+					if (fieldReference2.receiver instanceof ThisReference &&
+							fieldReference2.binding == fieldReference1.binding) {
+								findFromAnotherReceiver = true;
+					}
+				}
+			}
+		}
+		
+		if (findFromAnotherReceiver) {
+			TypeBinding receiverTypeBinding = instanceOfType.resolvedType;
+			char[] castedReceiver = null;
+			
+			char[] castedTypeChars = CharOperation.concatWith(instanceOfType.getTypeName(), '.');
+			if(this.source != null) {
+				int memberRefStart = this.startPosition;
+				
+				char[] receiverChars = CharOperation.subarray(this.source, receiverStart, receiverEnd);
+				char[] dotChars = CharOperation.subarray(this.source, receiverEnd, memberRefStart);
+				
+				castedReceiver =
+					CharOperation.concat(
+						CharOperation.concat(
+							'(',
+							CharOperation.concat(
+								CharOperation.concat('(', castedTypeChars, ')'),
+								receiverChars), 
+							')'),
+						dotChars);
+			} else {
+				castedReceiver =
+					CharOperation.concat(
+						CharOperation.concat(
+							'(',
+							CharOperation.concat(
+								CharOperation.concat('(', castedTypeChars, ')'),
+								CharOperation.concatWith(receiverName, '.')), 
+							')'),
+						DOT);
+			}
+			
+			if (castedReceiver == null) return;
+			
+			int oldStartPosition = this.startPosition;
+			this.startPosition = receiverStart;
+			
+			findFieldsAndMethods(
+					this.completionToken,
+					receiverTypeBinding,
+					scope,
+					fieldsFound,
+					methodsFound,
+					invocationSite,
+					invocationScope,
+					false,
+					false,
+					null,
+					null,
+					null,
+					false,
+					castedReceiver,
+					receiverStart,
+					receiverEnd);
+			
+			this.startPosition = oldStartPosition;
+		}
+	}
+
 	public void complete(IType type, char[] snippet, int position, char[][] localVariableTypeNames, char[][] localVariableNames, int[] localVariableModifiers, boolean isStatic){	
 		if(this.requestor != null){
 			this.requestor.beginReporting();
@@ -1859,7 +2113,14 @@ public final class CompletionEngine
 						//					completionNodeFound = true;
 						if (e.astNode != null) {
 							// if null then we found a problem in the completion node
-							contextAccepted = complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope, e.insideTypeAnnotation);
+							contextAccepted =
+								complete(
+									e.astNode,
+									this.parser.assistNodeParent,
+									this.parser.enclosingNode,
+									e.qualifiedBinding,
+									e.scope,
+									e.insideTypeAnnotation);
 						}
 					}
 				}
@@ -2099,7 +2360,14 @@ public final class CompletionEngine
 								}
 							}
 							// if null then we found a problem in the completion node
-							contextAccepted = complete(e.astNode, this.parser.assistNodeParent, e.qualifiedBinding, e.scope, e.insideTypeAnnotation);
+							contextAccepted =
+								complete(
+									e.astNode,
+									this.parser.assistNodeParent,
+									this.parser.enclosingNode,
+									e.qualifiedBinding,
+									e.scope,
+									e.insideTypeAnnotation);
 						}
 					}
 				}
@@ -2984,7 +3252,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementsStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		ObjectVector newFieldsFound = new ObjectVector();
 		// Inherited fields which are hidden by subclasses are filtered out
@@ -3064,6 +3335,11 @@ public final class CompletionEngine
 				char[] prefix = computePrefix(scope.enclosingSourceType(), invocationScope.enclosingSourceType(), field.isStatic());
 				completion = CharOperation.concat(prefix,completion,'.');
 			}
+			
+			
+			if (castedReceiver != null) {
+				completion = CharOperation.concat(castedReceiver, completion);
+			}
 
 			// Special case for javadoc completion
 			if (this.assistNodeInJavadoc > 0) {
@@ -3101,79 +3377,115 @@ public final class CompletionEngine
 			}
 			
 			this.noProposal = false;
-			// Standard proposal
-			if (!this.isIgnored(CompletionProposal.FIELD_REF, missingElements != null) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(getSignature(field.declaringClass));
-				proposal.setSignature(getSignature(field.type));
-				proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
-				proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
-				proposal.setPackageName(field.type.qualifiedPackageName());
-				proposal.setTypeName(field.type.qualifiedSourceName()); 
-				proposal.setName(field.name);
-				if (missingElements != null) {
-					CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
-					for (int i = 0; i < missingElements.length; i++) {
-						subProposals[i] =
-							createRequiredTypeProposal(
-									missingElements[i],
-									missingElementsStarts[i],
-									missingElementsEnds[i],
-									relevance);
+			if (castedReceiver == null) {
+				// Standard proposal
+				if (!this.isIgnored(CompletionProposal.FIELD_REF, missingElements != null) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(field.declaringClass));
+					proposal.setSignature(getSignature(field.type));
+					proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					proposal.setPackageName(field.type.qualifiedPackageName());
+					proposal.setTypeName(field.type.qualifiedSourceName()); 
+					proposal.setName(field.name);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}
+					proposal.setCompletion(completion);
+					proposal.setFlags(field.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
 					}
-					proposal.setRequiredProposals(subProposals);
-				}
-				proposal.setCompletion(completion);
-				proposal.setFlags(field.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-				proposal.setRelevance(relevance);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
 				}
-			}
-
-			// Javadoc completions
-			if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_FIELD_REF)) {
-				char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
-				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_FIELD_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(getSignature(field.declaringClass));
-				proposal.setSignature(getSignature(field.type));
-				proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
-				proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
-				proposal.setPackageName(field.type.qualifiedPackageName());
-				proposal.setTypeName(field.type.qualifiedSourceName()); 
-				proposal.setName(field.name);
-				proposal.setCompletion(javadocCompletion);
-				proposal.setFlags(field.modifiers);
-				int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
-				proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
-				proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-				proposal.setRelevance(relevance+R_INLINE_TAG);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
+	
+				// Javadoc completions
+				if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_FIELD_REF)) {
+					char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
+					CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_FIELD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(field.declaringClass));
+					proposal.setSignature(getSignature(field.type));
+					proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					proposal.setPackageName(field.type.qualifiedPackageName());
+					proposal.setTypeName(field.type.qualifiedSourceName()); 
+					proposal.setName(field.name);
+					proposal.setCompletion(javadocCompletion);
+					proposal.setFlags(field.modifiers);
+					int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+					proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance+R_INLINE_TAG);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
+					// Javadoc value completion for static fields
+					if (field.isStatic() && !this.requestor.isIgnored(CompletionProposal.JAVADOC_VALUE_REF)) {
+						javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_VALUE);
+						CompletionProposal valueProposal = this.createProposal(CompletionProposal.JAVADOC_VALUE_REF, this.actualCompletionPosition);
+						valueProposal.setDeclarationSignature(getSignature(field.declaringClass));
+						valueProposal.setSignature(getSignature(field.type));
+						valueProposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+						valueProposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+						valueProposal.setPackageName(field.type.qualifiedPackageName());
+						valueProposal.setTypeName(field.type.qualifiedSourceName()); 
+						valueProposal.setName(field.name);
+						valueProposal.setCompletion(javadocCompletion);
+						valueProposal.setFlags(field.modifiers);
+						valueProposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+						valueProposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+						valueProposal.setRelevance(relevance+R_VALUE_TAG);
+						this.requestor.accept(valueProposal);
+						if(DEBUG) {
+							this.printDebug(valueProposal);
+						}
+					}
 				}
-				// Javadoc value completion for static fields
-				if (field.isStatic() && !this.requestor.isIgnored(CompletionProposal.JAVADOC_VALUE_REF)) {
-					javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_VALUE);
-					CompletionProposal valueProposal = this.createProposal(CompletionProposal.JAVADOC_VALUE_REF, this.actualCompletionPosition);
-					valueProposal.setDeclarationSignature(getSignature(field.declaringClass));
-					valueProposal.setSignature(getSignature(field.type));
-					valueProposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
-					valueProposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
-					valueProposal.setPackageName(field.type.qualifiedPackageName());
-					valueProposal.setTypeName(field.type.qualifiedSourceName()); 
-					valueProposal.setName(field.name);
-					valueProposal.setCompletion(javadocCompletion);
-					valueProposal.setFlags(field.modifiers);
-					valueProposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
-					valueProposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-					valueProposal.setRelevance(relevance+R_VALUE_TAG);
-					this.requestor.accept(valueProposal);
+			} else {
+				if(!this.isIgnored(CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER, missingElements != null)) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(field.declaringClass));
+					proposal.setSignature(getSignature(field.type));
+					proposal.setReceiverSignature(getSignature(receiverType));
+					proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					proposal.setPackageName(field.type.qualifiedPackageName());
+					proposal.setTypeName(field.type.qualifiedSourceName()); 
+					proposal.setName(field.name);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}
+					proposal.setCompletion(completion);
+					proposal.setFlags(field.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setReceiverRange(receiverStart - this.offset, receiverEnd - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance);
+					this.requestor.accept(proposal);
 					if(DEBUG) {
-						this.printDebug(valueProposal);
+						this.printDebug(proposal);
 					}
 				}
 			}
@@ -3196,7 +3508,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementsStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
 		if (fieldName == null && notInJavadoc)
@@ -3241,7 +3556,10 @@ public final class CompletionEngine
 					missingElements,
 					missingElementsStarts,
 					missingElementsEnds,
-					missingElementsHaveProblems);
+					missingElementsHaveProblems,
+					castedReceiver,
+					receiverStart,
+					receiverEnd);
 			}
 			currentType = currentType.superclass();
 		} while (notInJavadoc && currentType != null);
@@ -3266,7 +3584,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						missingElementsHaveProblems);
+						missingElementsHaveProblems,
+						castedReceiver,
+						receiverStart,
+						receiverEnd);
 				}
 
 				ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
@@ -3285,10 +3606,88 @@ public final class CompletionEngine
 		}
 	}
 
+	protected void findFieldsAndMethodsFromAnotherReceiver(
+			char[] token,
+			TypeReference receiverType,
+			Scope scope,
+			ObjectVector fieldsFound,
+			ObjectVector methodsFound,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean implicitCall,
+			boolean superCall,
+			Binding[] missingElements,
+			int[] missingElementsStarts,
+			int[] missingElementsEnds,
+			boolean missingElementsHaveProblems,
+			char[][] receiverName,
+			int receiverStart,
+			int receiverEnd) {
+		
+		if (receiverType.resolvedType == null) return;
+		
+		TypeBinding receiverTypeBinding = receiverType.resolvedType;
+		char[] castedReceiver = null;
+		
+		char[] castedTypeChars = CharOperation.concatWith(receiverType.getTypeName(), '.');
+		if(this.source != null) {
+			int memberRefStart = this.startPosition;
+			
+			char[] receiverChars = CharOperation.subarray(this.source, receiverStart, receiverEnd);
+			char[] dotChars = CharOperation.subarray(this.source, receiverEnd, memberRefStart);
+			
+			castedReceiver =
+				CharOperation.concat(
+					CharOperation.concat(
+						'(',
+						CharOperation.concat(
+							CharOperation.concat('(', castedTypeChars, ')'),
+							receiverChars), 
+						')'),
+					dotChars);
+		} else {
+			castedReceiver =
+				CharOperation.concat(
+					CharOperation.concat(
+						'(',
+						CharOperation.concat(
+							CharOperation.concat('(', castedTypeChars, ')'),
+							CharOperation.concatWith(receiverName, '.')), 
+						')'),
+					DOT);
+		}
+		
+		if (castedReceiver == null) return;
+		
+		int oldStartPosition = this.startPosition;
+		this.startPosition = receiverStart;
+		
+		findFieldsAndMethods(
+				token,
+				receiverTypeBinding,
+				scope,
+				fieldsFound,
+				methodsFound,
+				invocationSite,
+				invocationScope,
+				implicitCall,
+				superCall,
+				missingElements,
+				missingElementsStarts,
+				missingElementsEnds,
+				missingElementsHaveProblems,
+				castedReceiver,
+				receiverStart,
+				receiverEnd);
+		
+		this.startPosition = oldStartPosition;
+	}
 	protected void findFieldsAndMethods(
 		char[] token,
 		TypeBinding receiverType,
 		Scope scope,
+		ObjectVector fieldsFound,
+		ObjectVector methodsFound,
 		InvocationSite invocationSite,
 		Scope invocationScope,
 		boolean implicitCall,
@@ -3296,7 +3695,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementsStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		if (token == null)
 			return;
@@ -3304,10 +3706,14 @@ public final class CompletionEngine
 		if (receiverType.isBaseType())
 			return; // nothing else is possible with base types
 		
-		boolean proposeField = !this.isIgnored(CompletionProposal.FIELD_REF, missingElements != null);
-		boolean proposeMethod = !this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null);
-		
-		ObjectVector methodsFound = new ObjectVector();
+		boolean proposeField =
+			castedReceiver == null ?
+					!this.isIgnored(CompletionProposal.FIELD_REF, missingElements != null) :
+					!this.isIgnored(CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER, missingElements != null) ;
+		boolean proposeMethod = 
+			castedReceiver == null ?
+					!this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null) :
+					!this.isIgnored(CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER, missingElements != null);
 		
 		if (receiverType.isArrayType()) {
 			if (proposeField
@@ -3325,35 +3731,67 @@ public final class CompletionEngine
 					relevance += computeRelevanceForMissingElements(missingElementsHaveProblems);
 				}
 				this.noProposal = false;
-				if(!isIgnored(CompletionProposal.FIELD_REF, missingElements != null)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(getSignature(receiverType));
-					proposal.setSignature(INT_SIGNATURE);
-					//proposal.setDeclarationPackageName(null);
-					//proposal.setDeclarationTypeName(null);
-					//proposal.setPackageName(null);
-					proposal.setTypeName(INT);
-					proposal.setName(lengthField);
-					if (missingElements != null) {
-						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
-						for (int i = 0; i < missingElements.length; i++) {
-							subProposals[i] =
-								createRequiredTypeProposal(
-										missingElements[i],
-										missingElementsStarts[i],
-										missingElementsEnds[i],
-										relevance);
+				if (castedReceiver == null) {
+					if(!isIgnored(CompletionProposal.FIELD_REF, missingElements != null)) {
+						CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(receiverType));
+						proposal.setSignature(INT_SIGNATURE);
+						proposal.setTypeName(INT);
+						proposal.setName(lengthField);
+						if (missingElements != null) {
+							CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+							for (int i = 0; i < missingElements.length; i++) {
+								subProposals[i] =
+									createRequiredTypeProposal(
+											missingElements[i],
+											missingElementsStarts[i],
+											missingElementsEnds[i],
+											relevance);
+							}
+							proposal.setRequiredProposals(subProposals);
+						}
+						proposal.setCompletion(lengthField);
+						proposal.setFlags(Flags.AccPublic);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+						proposal.setRelevance(relevance);
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
 						}
-						proposal.setRequiredProposals(subProposals);
 					}
-					proposal.setCompletion(lengthField);
-					proposal.setFlags(Flags.AccPublic);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-					proposal.setRelevance(relevance);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
+				} else {
+					char[] completion = CharOperation.concat(castedReceiver, lengthField);
+					
+					if(!this.isIgnored(CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER, missingElements != null)) {
+						CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(receiverType));
+						proposal.setSignature(INT_SIGNATURE);
+						proposal.setReceiverSignature(getSignature(receiverType));
+						proposal.setTypeName(INT);
+						proposal.setName(lengthField);
+						if (missingElements != null) {
+							CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+							for (int i = 0; i < missingElements.length; i++) {
+								subProposals[i] =
+									createRequiredTypeProposal(
+											missingElements[i],
+											missingElementsStarts[i],
+											missingElementsEnds[i],
+											relevance);
+							}
+							proposal.setRequiredProposals(subProposals);
+						}
+						proposal.setCompletion(completion);
+						proposal.setFlags(Flags.AccPublic);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setReceiverRange(receiverStart - this.offset, receiverEnd - this.offset);
+						proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+						proposal.setRelevance(relevance);
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
+						}
 					}
 				}
 			}
@@ -3382,52 +3820,101 @@ public final class CompletionEngine
 					} else {
 					completion = CharOperation.concat(cloneMethod, new char[] { '(', ')' });
 				}
+				
+				if (castedReceiver != null) {
+					completion = CharOperation.concat(castedReceiver, completion);
+				}
+				
 				this.noProposal = false;
-				if (!this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(getSignature(receiverType));
-					proposal.setSignature(
-							this.compilerOptions.sourceLevel > ClassFileConstants.JDK1_4 && receiverType.isArrayType() ?
-									createMethodSignature(
-											CharOperation.NO_CHAR_CHAR,
-											CharOperation.NO_CHAR_CHAR,
-											getSignature(receiverType)) :
-									createMethodSignature(
-											CharOperation.NO_CHAR_CHAR,
-											CharOperation.NO_CHAR_CHAR,
-											CharOperation.concatWith(JAVA_LANG, '.'),
-											OBJECT));
-					//proposal.setOriginalSignature(null);
-					//proposal.setDeclarationPackageName(null);
-					//proposal.setDeclarationTypeName(null);
-					//proposal.setParameterPackageNames(null);
-					//proposal.setParameterTypeNames(null);
-					proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
-					proposal.setTypeName(OBJECT);
-					proposal.setName(cloneMethod);
-					if (missingElements != null) {
-						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
-						for (int i = 0; i < missingElements.length; i++) {
-							subProposals[i] =
-								createRequiredTypeProposal(
-										missingElements[i],
-										missingElementsStarts[i],
-										missingElementsEnds[i],
-										relevance);
+				if (castedReceiver == null) {
+					if (!this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null)) {
+						CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(receiverType));
+						proposal.setSignature(
+								this.compilerOptions.sourceLevel > ClassFileConstants.JDK1_4 && receiverType.isArrayType() ?
+										createMethodSignature(
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.NO_CHAR_CHAR,
+												getSignature(receiverType)) :
+										createMethodSignature(
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.concatWith(JAVA_LANG, '.'),
+												OBJECT));
+						//proposal.setOriginalSignature(null);
+						//proposal.setDeclarationPackageName(null);
+						//proposal.setDeclarationTypeName(null);
+						//proposal.setParameterPackageNames(null);
+						//proposal.setParameterTypeNames(null);
+						proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
+						proposal.setTypeName(OBJECT);
+						proposal.setName(cloneMethod);
+						if (missingElements != null) {
+							CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+							for (int i = 0; i < missingElements.length; i++) {
+								subProposals[i] =
+									createRequiredTypeProposal(
+											missingElements[i],
+											missingElementsStarts[i],
+											missingElementsEnds[i],
+											relevance);
+							}
+							proposal.setRequiredProposals(subProposals);
+						}
+						proposal.setCompletion(completion);
+						proposal.setFlags(Flags.AccPublic);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+						proposal.setRelevance(relevance);
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
 						}
-						proposal.setRequiredProposals(subProposals);
 					}
-					proposal.setCompletion(completion);
-					proposal.setFlags(Flags.AccPublic);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-					proposal.setRelevance(relevance);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
+					methodsFound.add(new Object[]{objectRef.getMethods(cloneMethod)[0], objectRef});
+				} else {
+					if(!this.isIgnored(CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER, missingElements != null)) {
+						CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(receiverType));
+						proposal.setSignature(
+								this.compilerOptions.sourceLevel > ClassFileConstants.JDK1_4 && receiverType.isArrayType() ?
+										createMethodSignature(
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.NO_CHAR_CHAR,
+												getSignature(receiverType)) :
+										createMethodSignature(
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.concatWith(JAVA_LANG, '.'),
+												OBJECT));
+						proposal.setReceiverSignature(getSignature(receiverType));
+						proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
+						proposal.setTypeName(OBJECT);
+						proposal.setName(cloneMethod);
+						if (missingElements != null) {
+							CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+							for (int i = 0; i < missingElements.length; i++) {
+								subProposals[i] =
+									createRequiredTypeProposal(
+											missingElements[i],
+											missingElementsStarts[i],
+											missingElementsEnds[i],
+											relevance);
+							}
+							proposal.setRequiredProposals(subProposals);
+						}
+						proposal.setCompletion(completion);
+						proposal.setFlags(Flags.AccPublic);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setReceiverRange(receiverStart - this.offset, receiverEnd - this.offset);
+						proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+						proposal.setRelevance(relevance);
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
+						}
 					}
 				}
-				methodsFound.add(new Object[]{objectRef.getMethods(cloneMethod)[0], objectRef});
 			}
 			
 			receiverType = scope.getJavaLangObject();
@@ -3438,7 +3925,7 @@ public final class CompletionEngine
 				token,
 				(ReferenceBinding) receiverType,
 				scope,
-				new ObjectVector(),
+				fieldsFound,
 				new ObjectVector(),
 				false,
 				invocationSite,
@@ -3448,7 +3935,10 @@ public final class CompletionEngine
 				missingElements,
 				missingElementsStarts,
 				missingElementsEnds,
-				missingElementsHaveProblems);
+				missingElementsHaveProblems,
+				castedReceiver,
+				receiverStart,
+				receiverEnd);
 		}
 
 		if(proposeMethod) {
@@ -3470,7 +3960,10 @@ public final class CompletionEngine
 				missingElements,
 				missingElementsStarts,
 				missingElementsEnds,
-				missingElementsHaveProblems);
+				missingElementsHaveProblems,
+				castedReceiver,
+				receiverStart,
+				receiverEnd);
 		}
 	}
 	
@@ -3706,6 +4199,8 @@ public final class CompletionEngine
 						CompletionEngine.this.completionToken,
 						guessedType,
 						scope,
+						new ObjectVector(),
+						new ObjectVector(),
 						invocationSite, 
 						invocationScope, 
 						false,
@@ -3713,7 +4208,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						hasProblems);
+						hasProblems,
+						null,
+						-1,
+						-1);
 					
 				}
 			};
@@ -4401,7 +4899,10 @@ public final class CompletionEngine
 				missingElements,
 				missingElementsStarts,
 				missingElementsEnds,
-				missingElementsHaveProblems);
+				missingElementsHaveProblems,
+				null,
+				-1,
+				-1);
 		}
 
 		if (!isInsideAnnotationAttribute && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
@@ -4423,7 +4924,10 @@ public final class CompletionEngine
 				missingElements,
 				missingElementsStarts,
 				missingElementsEnds,
-				missingElementsHaveProblems);
+				missingElementsHaveProblems,
+				null,
+				-1,
+				-1);
 		}
 	}
 	
@@ -4886,7 +5390,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementssStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		if (selector == null)
 			return;
@@ -4926,7 +5433,10 @@ public final class CompletionEngine
 							missingElements,
 							missingElementssStarts,
 							missingElementsEnds,
-							missingElementsHaveProblems);
+							missingElementsHaveProblems,
+							castedReceiver,
+							receiverStart,
+							receiverEnd);
 					}
 				}
 
@@ -4991,7 +5501,10 @@ public final class CompletionEngine
 						null,
 						null,
 						null,
-						false);
+						false,
+						null,
+						-1,
+						-1);
 					staticsOnly |= enclosingType.isStatic();
 					break;
 
@@ -5021,7 +5534,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementsStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		ObjectVector newMethodsFound =  new ObjectVector();
 		// Inherited methods which are hidden by subclasses are filtered out
@@ -5204,6 +5720,10 @@ public final class CompletionEngine
 						completion = method.selector;
 					else
 						completion = CharOperation.concat(method.selector, new char[] { '(', ')' });
+					
+					if (castedReceiver != null) {
+						completion = CharOperation.concat(castedReceiver, completion);
+					}
 				} else {
 					if(prefixRequired && (this.source != null)) {
 						completion = CharOperation.subarray(this.source, this.startPosition, this.endPosition);
@@ -5235,73 +5755,117 @@ public final class CompletionEngine
 			}
 			
 			this.noProposal = false;
-			// Standard proposal
-			if(!this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(getSignature(method.declaringClass));
-				proposal.setSignature(getSignature(method));
-				MethodBinding original = method.original();
-				if(original != method) {
-					proposal.setOriginalSignature(getSignature(original));
-				}
-				proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
-				proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
-				proposal.setParameterPackageNames(parameterPackageNames);
-				proposal.setParameterTypeNames(parameterTypeNames);
-				proposal.setPackageName(method.returnType.qualifiedPackageName());
-				proposal.setTypeName(method.returnType.qualifiedSourceName());
-				proposal.setName(method.selector);
-				if (missingElements != null) {
-					CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
-					for (int i = 0; i < missingElements.length; i++) {
-						subProposals[i] =
-							createRequiredTypeProposal(
-									missingElements[i],
-									missingElementsStarts[i],
-									missingElementsEnds[i],
-									relevance);
+			
+			if (castedReceiver == null) {
+				// Standard proposal
+				if(!this.isIgnored(CompletionProposal.METHOD_REF, missingElements != null) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(method.declaringClass));
+					proposal.setSignature(getSignature(method));
+					MethodBinding original = method.original();
+					if(original != method) {
+						proposal.setOriginalSignature(getSignature(original));
+					}
+					proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+					proposal.setParameterPackageNames(parameterPackageNames);
+					proposal.setParameterTypeNames(parameterTypeNames);
+					proposal.setPackageName(method.returnType.qualifiedPackageName());
+					proposal.setTypeName(method.returnType.qualifiedSourceName());
+					proposal.setName(method.selector);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}	
+					proposal.setCompletion(completion);
+					proposal.setFlags(method.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance);
+					if(parameterNames != null) proposal.setParameterNames(parameterNames);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
 					}
-					proposal.setRequiredProposals(subProposals);
-				}
-				proposal.setCompletion(completion);
-				proposal.setFlags(method.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-				proposal.setRelevance(relevance);
-				if(parameterNames != null) proposal.setParameterNames(parameterNames);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
 				}
-			}
-
-			// Javadoc proposal
-			if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
-				char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
-				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_METHOD_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(getSignature(method.declaringClass));
-				proposal.setSignature(getSignature(method));
-				MethodBinding original = method.original();
-				if(original != method) {
-					proposal.setOriginalSignature(getSignature(original));
+	
+				// Javadoc proposal
+				if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
+					char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
+					CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_METHOD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(method.declaringClass));
+					proposal.setSignature(getSignature(method));
+					MethodBinding original = method.original();
+					if(original != method) {
+						proposal.setOriginalSignature(getSignature(original));
+					}
+					proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+					proposal.setParameterPackageNames(parameterPackageNames);
+					proposal.setParameterTypeNames(parameterTypeNames);
+					proposal.setPackageName(method.returnType.qualifiedPackageName());
+					proposal.setTypeName(method.returnType.qualifiedSourceName());
+					proposal.setName(method.selector);
+					proposal.setCompletion(javadocCompletion);
+					proposal.setFlags(method.modifiers);
+					int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+					proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance+R_INLINE_TAG);
+					if(parameterNames != null) proposal.setParameterNames(parameterNames);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
 				}
-				proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
-				proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
-				proposal.setParameterPackageNames(parameterPackageNames);
-				proposal.setParameterTypeNames(parameterTypeNames);
-				proposal.setPackageName(method.returnType.qualifiedPackageName());
-				proposal.setTypeName(method.returnType.qualifiedSourceName());
-				proposal.setName(method.selector);
-				proposal.setCompletion(javadocCompletion);
-				proposal.setFlags(method.modifiers);
-				int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
-				proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
-				proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
-				proposal.setRelevance(relevance+R_INLINE_TAG);
-				if(parameterNames != null) proposal.setParameterNames(parameterNames);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
+			} else {
+				if(!this.isIgnored(CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER, missingElements != null)) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(method.declaringClass));
+					proposal.setSignature(getSignature(method));
+					MethodBinding original = method.original();
+					if(original != method) {
+						proposal.setOriginalSignature(getSignature(original));
+					}
+					proposal.setReceiverSignature(getSignature(receiverType));
+					proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+					proposal.setParameterPackageNames(parameterPackageNames);
+					proposal.setParameterTypeNames(parameterTypeNames);
+					proposal.setPackageName(method.returnType.qualifiedPackageName());
+					proposal.setTypeName(method.returnType.qualifiedSourceName());
+					proposal.setName(method.selector);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}
+					proposal.setCompletion(completion);
+					proposal.setFlags(method.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setReceiverRange(receiverStart - this.offset, receiverEnd - this.offset);
+					proposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);
+					proposal.setRelevance(relevance);
+					if(parameterNames != null) proposal.setParameterNames(parameterNames);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
 				}
 			}
 			this.startPosition = previousStartPosition;
@@ -6280,7 +6844,10 @@ public final class CompletionEngine
 		Binding[] missingElements,
 		int[] missingElementsStarts,
 		int[] missingElementsEnds,
-		boolean missingElementsHaveProblems) {
+		boolean missingElementsHaveProblems,
+		char[] castedReceiver,
+		int receiverStart,
+		int receiverEnd) {
 
 		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
 		if (selector == null && notInJavadoc) {
@@ -6321,7 +6888,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						missingElementsHaveProblems);
+						missingElementsHaveProblems,
+						castedReceiver,
+						receiverStart,
+						receiverEnd);
 				} else {
 					findInterfacesMethods(
 						selector,
@@ -6342,7 +6912,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						missingElementsHaveProblems);
+						missingElementsHaveProblems,
+						castedReceiver,
+						receiverStart,
+						receiverEnd);
 				}
 				
 				currentType = scope.getJavaLangObject();
@@ -6367,7 +6940,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						missingElementsHaveProblems);
+						missingElementsHaveProblems,
+						castedReceiver,
+						receiverStart,
+						receiverEnd);
 					
 					currentType = receiverType.superclass();
 				}
@@ -6405,7 +6981,10 @@ public final class CompletionEngine
 						missingElements,
 						missingElementsStarts,
 						missingElementsEnds,
-						missingElementsHaveProblems);
+						missingElementsHaveProblems,
+						castedReceiver,
+						receiverStart,
+						receiverEnd);
 				}
 			}
 			
@@ -6442,7 +7021,10 @@ public final class CompletionEngine
 					missingElements,
 					missingElementsStarts,
 					missingElementsEnds,
-					missingElementsHaveProblems);
+					missingElementsHaveProblems,
+					castedReceiver,
+					receiverStart,
+					receiverEnd);
 			} else {
 				hasPotentialDefaultAbstractMethods = false;
 			}
@@ -7407,7 +7989,10 @@ public final class CompletionEngine
 									null,
 									null,
 									null,
-									false);
+									false,
+									null,
+									-1,
+									-1);
 							}
 							if(proposeMethod && !insideAnnotationAttribute) {
 								findMethods(
@@ -7428,7 +8013,10 @@ public final class CompletionEngine
 									null,
 									null,
 									null,
-									false);
+									false,
+									null,
+									-1,
+									-1);
 							}
 						}
 						staticsOnly |= enclosingType.isStatic();
@@ -7466,7 +8054,10 @@ public final class CompletionEngine
 										null,
 										null,
 										null,
-										false);
+										false,
+										null,
+										-1,
+										-1);
 								}
 								if(proposeMethod && !insideAnnotationAttribute) {
 									findMethods(
@@ -7487,7 +8078,10 @@ public final class CompletionEngine
 										null,
 										null,
 										null,
-										false);
+										false,
+										null,
+										-1,
+										-1);
 								}
 							}
 						} else {
@@ -7508,7 +8102,10 @@ public final class CompletionEngine
 												null,
 												null,
 												null,
-												false);
+												false,
+												null,
+												-1,
+												-1);
 								}
 							} else if ((binding.kind() & Binding.METHOD) != 0) {
 								if(proposeMethod && !insideAnnotationAttribute) {
@@ -8047,6 +8644,7 @@ public final class CompletionEngine
 			this.tokenEnd = end + 1;
 		}
 	}
+	
 	private char[][] computeAlreadyDefinedName(
 			BlockScope scope,
 			InvocationSite invocationSite) {
@@ -9113,6 +9711,9 @@ public final class CompletionEngine
 			case CompletionProposal.FIELD_REF :
 				buffer.append("FIELD_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("FIELD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				break;
 			case CompletionProposal.KEYWORD :
 				buffer.append("KEYWORD"); //$NON-NLS-1$
 				break;
@@ -9128,6 +9729,9 @@ public final class CompletionEngine
 			case CompletionProposal.METHOD_REF :
 				buffer.append("METHOD_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("METHOD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				break;
 			case CompletionProposal.PACKAGE_REF :
 				buffer.append("PACKAGE_REF"); //$NON-NLS-1$
 				break;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 6d04a9b..189f26e 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -73,6 +73,7 @@ public class CompletionParser extends AssistParser {
 	protected static final int K_INSIDE_CONTINUE_STATEMENT = COMPLETION_PARSER + 35;
 	protected static final int K_LABEL = COMPLETION_PARSER + 36;
 	protected static final int K_MEMBER_VALUE_ARRAY_INITIALIZER = COMPLETION_PARSER + 37;
+	protected static final int K_CONTROL_STATEMENT_DELIMITER = COMPLETION_PARSER + 38;
 
 	public final static char[] FAKE_TYPE_NAME = new char[]{' '};
 	public final static char[] FAKE_METHOD_NAME = new char[]{' '};
@@ -83,6 +84,8 @@ public class CompletionParser extends AssistParser {
 
 	public int cursorLocation;
 	public ASTNode assistNodeParent; // the parent node of assist node
+	public ASTNode enclosingNode; // an enclosing node used by proposals inference
+	
 	/* the following fields are internal flags */
 
 	// block kind
@@ -939,23 +942,55 @@ private void buildMoreCompletionContext(Expression expression) {
 		}
 	}
 	if(assistNodeParent != null) {
-		currentElement = currentElement.add((Statement)assistNodeParent, 0);
+		currentElement = currentElement.add(buildMoreCompletionEnclosingContext((Statement)assistNodeParent), 0);
 	} else {
 		if(currentElement instanceof RecoveredField && !(currentElement instanceof RecoveredInitializer)
 			&& ((RecoveredField) currentElement).fieldDeclaration.initialization == null) {
 
 			assistNodeParent = ((RecoveredField) currentElement).fieldDeclaration;
-			currentElement = currentElement.add(statement, 0);
+			currentElement = currentElement.add(buildMoreCompletionEnclosingContext(statement), 0);
 		} else if(currentElement instanceof RecoveredLocalVariable
 			&& ((RecoveredLocalVariable) currentElement).localDeclaration.initialization == null) {
 
 			assistNodeParent = ((RecoveredLocalVariable) currentElement).localDeclaration;
-			currentElement = currentElement.add(statement, 0);
+			currentElement = currentElement.add(buildMoreCompletionEnclosingContext(statement), 0);
 		} else {
-			currentElement = currentElement.add(expression, 0);
+			currentElement = currentElement.add(buildMoreCompletionEnclosingContext(expression), 0);
 		}
 	}
 }
+private Statement buildMoreCompletionEnclosingContext(Statement statement) {
+	
+	int blockIndex = this.lastIndexOfElement(K_BLOCK_DELIMITER);
+	int controlIndex = this.lastIndexOfElement(K_CONTROL_STATEMENT_DELIMITER);
+	if (blockIndex != -1 && controlIndex < blockIndex) {
+		if (this.elementInfoStack[blockIndex] == IF && this.elementObjectInfoStack[blockIndex] != null) {
+			Expression condition = (Expression)this.elementObjectInfoStack[blockIndex];
+			IfStatement ifStatement =
+				new IfStatement(
+					condition, 
+					statement, 
+					condition.sourceStart, 
+					statement.sourceEnd);
+			this.enclosingNode = ifStatement;
+			return ifStatement;
+		}
+	} else if (controlIndex != -1) {
+		if (this.elementInfoStack[controlIndex] == IF && this.elementObjectInfoStack[controlIndex] != null) {
+			Expression condition = (Expression)this.elementObjectInfoStack[controlIndex];
+			IfStatement ifStatement =
+				new IfStatement(
+					condition, 
+					statement, 
+					condition.sourceStart, 
+					statement.sourceEnd);
+			this.enclosingNode = ifStatement;
+			return ifStatement;
+		}
+	}
+	
+	return statement;
+}
 private void buildMoreGenericsCompletionContext(ASTNode node, boolean consumeTypeArguments) {
 	int kind = topKnownElementKind(COMPLETION_OR_ASSIST_PARSER);
 	if(kind != 0) {
@@ -2062,6 +2097,13 @@ protected void consumeDimWithOrWithOutExpr() {
 	// DimWithOrWithOutExpr ::= '[' ']'
 	pushOnExpressionStack(null);
 }
+protected void consumeEnhancedForStatement() {
+	super.consumeEnhancedForStatement();
+	
+	if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+		popElement(K_CONTROL_STATEMENT_DELIMITER);
+	}
+}
 protected void consumeEnhancedForStatementHeaderInit(boolean hasModifiers) {
 	super.consumeEnhancedForStatementHeaderInit(hasModifiers);
 	if (this.pendingAnnotation != null) {
@@ -2281,6 +2323,27 @@ protected void consumeFormalParameter(boolean isVarArgs) {
 		listLength++;
 	}
 }
+protected void consumeStatementFor() {
+	super.consumeStatementFor();
+	
+	if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+		popElement(K_CONTROL_STATEMENT_DELIMITER);
+	}
+}
+protected void consumeStatementIfNoElse() {
+	super.consumeStatementIfNoElse();
+	
+	if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+		popElement(K_CONTROL_STATEMENT_DELIMITER);
+	}
+}
+protected void consumeStatementIfWithElse() {
+	super.consumeStatementIfWithElse();
+	
+	if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+		popElement(K_CONTROL_STATEMENT_DELIMITER);
+	}
+}
 protected void consumeInsideCastExpression() {
 	int end = intStack[intPtr--];
 	boolean isParameterized =(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_PARAMETERIZED_CAST);
@@ -2803,6 +2866,12 @@ protected void consumeStatementSwitch() {
 		popElement(K_BLOCK_DELIMITER);
 	}
 }
+protected void consumeStatementWhile() {
+	super.consumeStatementWhile();
+	if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+		popElement(K_CONTROL_STATEMENT_DELIMITER);
+	}
+}
 protected void consumeStaticImportOnDemandDeclarationName() {
 	super.consumeStaticImportOnDemandDeclarationName();
 	this.pendingAnnotation = null; // the pending annotation cannot be attached to next nodes
@@ -3062,41 +3131,42 @@ protected void consumeToken(int token) {
 				} else if (kind == K_BETWEEN_ANNOTATION_NAME_AND_RPAREN) {
 					pushOnElementStack(K_MEMBER_VALUE_ARRAY_INITIALIZER, endPosition);
 				} else {
-					switch(previous) {
-						case TokenNameRPAREN :
-							switch(previousKind) {
-								case K_BETWEEN_IF_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, IF);
-									break;
-								case K_BETWEEN_CATCH_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, CATCH);
-									break;
-								case K_BETWEEN_WHILE_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, WHILE);
-									break;
-								case K_BETWEEN_SWITCH_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, SWITCH);
-									break;
-								case K_BETWEEN_FOR_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, FOR);
-									break;
-								case K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN :
-									pushOnElementStack(K_BLOCK_DELIMITER, SYNCHRONIZED);
-									break;
-								default :
-									pushOnElementStack(K_BLOCK_DELIMITER);
-									break;
-							}
-							break;
-						case TokenNametry :
-							pushOnElementStack(K_BLOCK_DELIMITER, TRY);
-							break;
-						case TokenNamedo:
-							pushOnElementStack(K_BLOCK_DELIMITER, DO);
-							break;
-						default :
-							pushOnElementStack(K_BLOCK_DELIMITER);
-							break;
+					if (kind == K_CONTROL_STATEMENT_DELIMITER) {
+						int info = topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER);
+						popElement(K_CONTROL_STATEMENT_DELIMITER);
+						if (info == IF) {
+							pushOnElementStack(K_BLOCK_DELIMITER, IF, this.expressionStack[this.expressionPtr]);
+						} else {
+							pushOnElementStack(K_BLOCK_DELIMITER, info);
+						}
+					} else {
+						switch(previous) {
+							case TokenNameRPAREN :
+								switch(previousKind) {
+									case K_BETWEEN_CATCH_AND_RIGHT_PAREN :
+										pushOnElementStack(K_BLOCK_DELIMITER, CATCH);
+										break;
+									case K_BETWEEN_SWITCH_AND_RIGHT_PAREN :
+										pushOnElementStack(K_BLOCK_DELIMITER, SWITCH);
+										break;
+									case K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN :
+										pushOnElementStack(K_BLOCK_DELIMITER, SYNCHRONIZED);
+										break;
+									default :
+										pushOnElementStack(K_BLOCK_DELIMITER);
+										break;
+								}
+								break;
+							case TokenNametry :
+								pushOnElementStack(K_BLOCK_DELIMITER, TRY);
+								break;
+							case TokenNamedo:
+								pushOnElementStack(K_BLOCK_DELIMITER, DO);
+								break;
+							default :
+								pushOnElementStack(K_BLOCK_DELIMITER);
+								break;
+						}
 					}
 				}
 				break;
@@ -3125,16 +3195,19 @@ protected void consumeToken(int token) {
 					case K_BETWEEN_IF_AND_RIGHT_PAREN :
 						if(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {
 							popElement(K_BETWEEN_IF_AND_RIGHT_PAREN);
+							pushOnElementStack(K_CONTROL_STATEMENT_DELIMITER, IF, this.expressionStack[this.expressionPtr]);
 						}
 						break;
 					case K_BETWEEN_WHILE_AND_RIGHT_PAREN :
 						if(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {
 							popElement(K_BETWEEN_WHILE_AND_RIGHT_PAREN);
+							pushOnElementStack(K_CONTROL_STATEMENT_DELIMITER, WHILE);
 						}
 						break;
 					case K_BETWEEN_FOR_AND_RIGHT_PAREN :
 						if(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {
 							popElement(K_BETWEEN_FOR_AND_RIGHT_PAREN);
+							pushOnElementStack(K_CONTROL_STATEMENT_DELIMITER, FOR);
 						}
 						break;
 					case K_BETWEEN_SWITCH_AND_RIGHT_PAREN :
@@ -3285,6 +3358,11 @@ protected void consumeToken(int token) {
 			case TokenNameif:
 				pushOnElementStack(K_BETWEEN_IF_AND_RIGHT_PAREN, bracketDepth);
 				break;
+			case TokenNameelse:
+				if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_CONTROL_STATEMENT_DELIMITER) {
+					popElement(K_CONTROL_STATEMENT_DELIMITER);
+				}
+				break;
 			case TokenNamewhile:
 				pushOnElementStack(K_BETWEEN_WHILE_AND_RIGHT_PAREN, bracketDepth);
 				break;
@@ -4093,6 +4171,12 @@ protected void popUntilCompletedAnnotationIfNecessary() {
 	if(i >= 0) {
 		previousKind = elementKindStack[i];
 		previousInfo = elementInfoStack[i];
+		previousObjectInfo = elementObjectInfoStack[i];
+		
+		for (int j = i; j <= elementPtr; j++) {
+			elementObjectInfoStack[j] = null;
+		}
+		
 		elementPtr = i - 1;	
 	}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index e886465..4356cc5 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -48,8 +48,10 @@ public abstract class AssistParser extends Parser {
 	protected int elementPtr;
 	protected int[] elementKindStack = new int[ElementStackIncrement];
 	protected int[] elementInfoStack = new int[ElementStackIncrement];
+	protected Object[] elementObjectInfoStack = new Object[ElementStackIncrement];
 	protected int previousKind;
 	protected int previousInfo;
+	protected Object previousObjectInfo;
 	
 	// OWNER
 	protected static final int ASSIST_PARSER = 512;
@@ -832,9 +834,14 @@ public void flushAssistState(){
 	this.setAssistIdentifier(null);
 }
 protected void flushElementStack() {
+	for (int j = 0; j <= elementPtr; j++) {
+		elementObjectInfoStack[j] = null;
+	}
+	
 	this.elementPtr = -1;
 	this.previousKind = 0;
 	this.previousInfo = 0;
+	this.previousObjectInfo = null;
 }
 /*
  * Build specific type reference nodes in case the cursor is located inside the type reference
@@ -1381,6 +1388,9 @@ protected void popElement(int kind){
 	
 	previousKind = elementKindStack[elementPtr];
 	previousInfo = elementInfoStack[elementPtr];
+	previousObjectInfo = elementObjectInfoStack[elementPtr];
+	
+	elementObjectInfoStack[elementPtr] = null;
 	
 	switch (kind) {
 		default :
@@ -1398,6 +1408,11 @@ protected void popUntilElement(int kind){
 		if(i < elementPtr) {
 			previousKind = elementKindStack[i+1];
 			previousInfo = elementInfoStack[i+1];
+			previousObjectInfo = elementObjectInfoStack[i+1];
+			
+			for (int j = i + 1; j <= elementPtr; j++) {
+				elementObjectInfoStack[j] = null;
+			}
 		}
 		elementPtr = i;	
 	}
@@ -1439,13 +1454,17 @@ protected void prepareForHeaders() {
 	}
 }
 protected void pushOnElementStack(int kind){
-	this.pushOnElementStack(kind, 0);
+	this.pushOnElementStack(kind, 0, null);
 }
 protected void pushOnElementStack(int kind, int info){
+	this.pushOnElementStack(kind, info, null);
+}
+protected void pushOnElementStack(int kind, int info, Object objectInfo){
 	if (this.elementPtr < -1) return;
 	
 	this.previousKind = 0;
 	this.previousInfo = 0;
+	this.previousObjectInfo = null;
 	
 	int stackLength = this.elementKindStack.length;
 	if (++this.elementPtr >= stackLength) {
@@ -1457,9 +1476,14 @@ protected void pushOnElementStack(int kind, int info){
 			this.elementInfoStack, 0,
 			this.elementInfoStack = new int[stackLength + StackIncrement], 0,
 			stackLength);
+		System.arraycopy(
+			this.elementObjectInfoStack, 0,
+			this.elementObjectInfoStack = new Object[stackLength + StackIncrement], 0,
+			stackLength);
 	}
 	this.elementKindStack[this.elementPtr] = kind;
 	this.elementInfoStack[this.elementPtr] = info;
+	this.elementObjectInfoStack[this.elementPtr] = objectInfo;
 }
 public void recoveryExitFromVariable() {
 	if(currentElement != null && currentElement instanceof RecoveredField
@@ -1609,6 +1633,20 @@ protected int topKnownElementKind(int owner, int offSet) {
 	}
 	return 0;
 }
+protected Object topKnownElementObjectInfo(int owner, int offSet) {
+	int i = elementPtr;
+	while(i > -1) {
+		if((elementKindStack[i] & owner) != 0) {
+			if(offSet <= 0) return elementObjectInfoStack[i];
+			offSet--;
+		}
+		i--;
+	}
+	return null;
+}
+protected Object topKnownElementObjectInfo(int owner) {
+	return topKnownElementObjectInfo(owner, 0);
+}
 /**
  * If the given ast node is inside an explicit constructor call
  * then wrap it with a fake constructor call.
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
index 97c847d..bcea1db 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
@@ -171,6 +171,7 @@ public CompletionRequestor getCompletionRequestor(final CompletionRequestor orig
 					break;
 				case CompletionProposal.METHOD_REF:
 				case CompletionProposal.METHOD_DECLARATION:
+				case CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER:
 					// Remove completion on generated method
 					char[] declaringTypePackageName = Signature.getSignatureQualifier(proposal.getDeclarationSignature());
 					char[] declaringTypeName = Signature.getSignatureSimpleName(proposal.getDeclarationSignature());
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
index 48782bb..f67c3a7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
@@ -726,6 +726,75 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	public static final int TYPE_IMPORT = 23;
 	
 	/**
+	 * Completion is a reference to a method with a casted receiver.
+	 * This kind of completion might occur in a context like
+	 * <code>"receiver.fo^();"</code> and complete it to
+	 * <code>""((X)receiver).foo();"</code>.
+	 * <p>
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * <ul>
+	 * <li>{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the method that is referenced
+	 * </li>
+	 * <li>{@link #getFlags()} -
+	 * the modifiers flags of the method that is referenced
+	 * </li>
+	 * <li>{@link #getName()} -
+	 * the simple name of the method that is referenced
+	 * </li>
+	 * <li>{@link #getReceiverSignature()} -
+	 * the type signature of the receiver type. It's the type of the cast expression.
+	 * </li>
+	 * <li>{@link #getSignature()} -
+	 * the method signature of the method that is referenced
+	 * </li>
+	 * </ul>
+	 * </p>
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.4
+	 */
+	public static final int METHOD_REF_WITH_CASTED_RECEIVER = 24;
+	
+	/**
+	 * Completion is a reference to a field with a casted receiver.
+	 * This kind of completion might occur in a context like
+	 * <code>"recevier.ref^ = 0;"</code> and complete it to
+	 * <code>"((X)receiver).refcount = 0;"</code>.
+	 * <p>
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * <ul>
+	 * <li>{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the field that is referenced
+	 * </li>
+	 * <li>{@link #getFlags()} -
+	 * the modifiers flags (including ACC_ENUM) of the field that is referenced
+	 * </li>
+	 * <li>{@link #getName()} -
+	 * the simple name of the field that is referenced
+	 * </li>
+	 * <li>{@link #getReceiverSignature()} -
+	 * the type signature of the receiver type. It's the type of the cast expression.
+	 * </li>
+	 * <li>{@link #getSignature()} -
+	 * the type signature of the field's type (as opposed to the
+	 * signature of the type in which the referenced field
+	 * is declared)
+	 * </li>
+	 * 
+	 * </ul>
+	 * </p>
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.4
+	 */
+	public static final int FIELD_REF_WITH_CASTED_RECEIVER = 25;
+	
+	/**
 	 * First valid completion kind.
 	 * 
 	 * @since 3.1
@@ -737,7 +806,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * 
 	 * @since 3.1
 	 */
-	protected static final int LAST_KIND = TYPE_IMPORT;
+	protected static final int LAST_KIND = FIELD_REF_WITH_CASTED_RECEIVER;
 	
 	/**
 	 * Kind of completion request.
@@ -1213,10 +1282,14 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * of the type that declares the field that is imported</li>
 	 *  <li><code>FIELD_REF</code> - type signature
 	 * of the type that declares the field that is referenced</li>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code> - type signature
+	 * of the type that declares the field that is referenced</li>
 	 * 	<li><code>METHOD_IMPORT</code> - type signature
 	 * of the type that declares the method that is imported</li>
 	 *  <li><code>METHOD_REF</code> - type signature
 	 * of the type that declares the method that is referenced</li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code> - type signature
+	 * of the type that declares the method that is referenced</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - type signature
 	 * of the type that declares the method that is being
 	 * implemented or overridden</li>
@@ -1316,11 +1389,13 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 *  <li><code>ANNOTATION_ATTRIBUT_REF</code> - the name of the attribute</li>
 	 * 	<li><code>FIELD_IMPORT</code> - the name of the field</li>
 	 *  <li><code>FIELD_REF</code> - the name of the field</li>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code> - the name of the field</li>
 	 * 	<li><code>KEYWORD</code> - the keyword</li>
 	 * 	<li><code>LABEL_REF</code> - the name of the label</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - the name of the local variable</li>
 	 * 	<li><code>METHOD_IMPORT</code> - the name of the method</li>
 	 *  <li><code>METHOD_REF</code> - the name of the method (the type simple name for constructor)</li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code> - the name of the method</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - the name of the method (the type simple name for constructor)</li>
 	 * 	<li><code>VARIABLE_DECLARATION</code> - the name of the variable</li>
 	 *  <li><code>POTENTIAL_METHOD_DECLARATION</code> - the name of the method</li>
@@ -1372,12 +1447,16 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * of the referenced field's type</li>
 	 *  <li><code>FIELD_REF</code> - the type signature
 	 * of the referenced field's type</li>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code> - the type signature
+	 * of the referenced field's type</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - the type signature
 	 * of the referenced local variable's type</li>
 	 * 	<li><code>METHOD_IMPORT</code> - method signature
 	 * of the method that is imported</li>
 	 *  <li><code>METHOD_REF</code> - method signature
 	 * of the method that is referenced</li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code> - method signature
+	 * of the method that is referenced</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - method signature
 	 * of the method that is being implemented or overridden</li>
 	 * 	<li><code>TYPE_IMPORT</code> - type signature
@@ -1685,6 +1764,9 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * <code>Flags.AccEnum</code> can be used to recognize
 	 * references to enum constants
 	 * </li>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code> - modifier flags
+	 * of the field that is referenced.
+	 * </li>
 	 * 	<li><code>KEYWORD</code> - modifier flag
 	 * corresponding to the modifier keyword</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - modifier flags
@@ -1697,6 +1779,9 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * <code>Flags.AccAnnotation</code> can be used to recognize
 	 * references to annotation type members
 	 * </li>
+	 * <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code> - modifier flags
+	 * of the method that is referenced.
+	 * </li>
 	 * <li><code>METHOD_DECLARATION</code> - modifier flags
 	 * for the method that is being implemented or overridden</li>
 	 * <li><code>TYPE_IMPORT</code> - modifier flags
@@ -1852,6 +1937,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 					}
 					break;
 				case METHOD_REF:
+				case METHOD_REF_WITH_CASTED_RECEIVER:
 					try {
 						this.parameterNames = this.findMethodParameterNames(
 								this.declarationPackageName,
@@ -1953,6 +2039,123 @@ public final class CompletionProposal extends InternalCompletionProposal {
 		return this.isConstructor;
 	}
 	
+	private int receiverStart;
+	private int receiverEnd;
+	private char[] receiverSignature;
+	
+	/**
+	 * Returns the type signature or package name of the relevant
+	 * receiver in the context, or <code>null</code> if none.
+	 * <p>
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * <ul>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code> - type signature
+	 * of the type that cast the receiver of the field that is referenced</li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code> - type signature
+	 * of the type that cast the receiver of the method that is referenced</li>
+	 * </ul>
+	 * For kinds of completion proposals, this method returns
+	 * <code>null</code>. Clients must not modify the array
+	 * returned.
+	 * </p>
+	 * 
+	 * @return a type signature or a package name (depending
+	 * on the kind of completion), or <code>null</code> if none
+	 * @see Signature
+	 * 
+	 * @since 3.4
+	 */
+	public char[] getReceiverSignature() {
+		return receiverSignature;
+	}
+	
+	/**
+	 * Returns the character index of the start of the
+	 * subrange in the source file buffer containing the
+	 * relevant receiver of the member being completed. This
+	 * receiver is an expression.
+	 * 
+	 * <p>
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * <ul>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code></li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code></li>
+	 * </ul>
+	 * For kinds of completion proposals, this method returns <code>0</code>.
+	 * </p>
+	 * 
+	 * @return character index of receiver start position (inclusive)
+	 * 
+	 * @since 3.4
+	 */
+	public int getReceiverStart() {
+		return receiverStart;
+	}
+	
+	/**
+	 * Returns the character index of the end (exclusive) of the subrange
+	 * in the source file buffer containing the
+	 * relevant receiver of the member being completed.
+	 * 
+	 * * <p>
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * <ul>
+	 *  <li><code>FIELD_REF_WITH_CASTED_RECEIVER</code></li>
+	 *  <li><code>METHOD_REF_WITH_CASTED_RECEIVER</code></li>
+	 * </ul>
+	 * For kinds of completion proposals, this method returns <code>0</code>.
+	 * </p>
+	 * 
+	 * @return character index of receiver end position (exclusive)
+	 * 
+	 * @since 3.4
+	 */
+	public int getReceiverEnd() {
+		return receiverEnd;
+	}
+	
+	/**
+	 * Sets the type or package signature of the relevant
+	 * receiver in the context, or <code>null</code> if none.
+	 * <p>
+	 * If not set, defaults to none.
+	 * </p>
+	 * <p>
+	 * The completion engine creates instances of this class and sets
+	 * its properties; this method is not intended to be used by other clients.
+	 * </p>
+	 * 
+	 * @param signature the type or package signature, or
+	 * <code>null</code> if none
+	 * 
+	 * @since 3.4
+	 */
+	public void setReceiverSignature(char[] signature) {
+		this.receiverSignature = signature;
+	}
+	
+	/**
+	 * Sets the character indices of the subrange in the
+	 * source file buffer containing the relevant receiver 
+	 * of the member being completed.
+	 * 
+	 * <p>
+	 * If not set, defaults to empty subrange at [0,0).
+	 * </p>
+	 * 
+	 * @param startIndex character index of receiver start position (inclusive)
+	 * @param endIndex character index of receiver end position (exclusive)
+	 * 
+	 * @since 3.4
+	 */
+	public void setReceiverRange(int startIndex, int endIndex) {
+		this.receiverStart = startIndex;
+		this.receiverEnd = endIndex;
+	}
+	
 	public String toString() {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append('[');
@@ -2032,6 +2235,12 @@ public final class CompletionProposal extends InternalCompletionProposal {
 			case CompletionProposal.TYPE_IMPORT :
 				buffer.append("TYPE_IMPORT"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.METHOD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("METHOD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.FIELD_REF_WITH_CASTED_RECEIVER :
+				buffer.append("FIELD_REF_WITH_CASTED_RECEIVER"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
