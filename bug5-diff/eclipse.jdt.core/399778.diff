commit 677bf3763b6e383c756f5ca8cbbd80c6dec30c1f
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Feb 19 22:41:36 2013 -0500

    Fixed Bug 399778 - [1.8][compiler] Conditional operator expressions
    should propagate target types

84	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
0	509	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CastingContextTest.java
636	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
8	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractVariableDeclaration.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
34	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
9	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
66	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExpressionContext.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
9	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
22	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
7	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
6	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
6	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
index f945833..7546e09 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
@@ -85,6 +85,28 @@ public void runComplianceParserTest(
 			this.runNegativeTest(testFiles, expected17ProblemLog);
 		}
 	}
+public void runComplianceParserTest(
+		String[] testFiles,
+		String expected13ProblemLog,
+		String expected14ProblemLog,
+		String expected15ProblemLog,
+		String expected16ProblemLog,
+		String expected17ProblemLog,
+		String expected18ProblemLog){
+		if (this.complianceLevel == ClassFileConstants.JDK1_3) {
+			this.runNegativeTest(testFiles, expected13ProblemLog);
+		} else if(this.complianceLevel == ClassFileConstants.JDK1_4) {
+			this.runNegativeTest(testFiles, expected14ProblemLog);
+		} else if(this.complianceLevel == ClassFileConstants.JDK1_5) {
+			this.runNegativeTest(testFiles, expected15ProblemLog);
+		} else if(this.complianceLevel == ClassFileConstants.JDK1_6) {
+			this.runNegativeTest(testFiles, expected16ProblemLog);
+		} else if(this.complianceLevel < ClassFileConstants.JDK1_8) {
+			this.runNegativeTest(testFiles, expected17ProblemLog);
+		} else {
+			this.runNegativeTest(testFiles, expected18ProblemLog);
+		}
+	}
 public void test0001() {
 	String[] testFiles = new String[] {
 		"X.java",
@@ -3035,4 +3057,66 @@ public void testBug399773() {
 		expectedProblemLog
 	);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778,  [1.8][compiler] Conditional operator expressions should propagate target types
+public void testBug399778() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	String[] testFiles = new String[] {
+		"X.java",
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"public class X  {\n" +
+		"		List<String> l = null == null ? Arrays.asList() : Arrays.asList(\"Hello\",\"world\");\n" +
+		"}\n",
+	};
+
+	String expectedProblemLog =
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	List<String> l = null == null ? Arrays.asList() : Arrays.asList(\"Hello\",\"world\");\n" + 
+			"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type mismatch: cannot convert from List<capture#1-of ? extends Object> to List<String>\n" + 
+			"----------\n";
+
+	runComplianceParserTest(
+		testFiles,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		""   // 1.8 should compile this fine.
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778,  [1.8][compiler] Conditional operator expressions should propagate target types
+public void testBug399778a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	String[] testFiles = new String[] {
+		"X.java",
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"public class X  {\n" +
+		"		List<String> l = (List<String>) (null == null ? Arrays.asList() : Arrays.asList(\"Hello\",\"world\"));\n" +
+		"}\n",
+	};
+
+	String expectedProblemLog =
+			"----------\n" + 
+			"1. WARNING in X.java (at line 4)\n" + 
+			"	List<String> l = (List<String>) (null == null ? Arrays.asList() : Arrays.asList(\"Hello\",\"world\"));\n" + 
+			"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked cast from List<capture#1-of ? extends Object> to List<String>\n" + 
+			"----------\n";
+
+	runComplianceParserTest(
+		testFiles,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog   // 1.8 also issue type safety warning.
+	);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CastingContextTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CastingContextTest.java
deleted file mode 100644
index 785752d..0000000
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CastingContextTest.java
+++ /dev/null
@@ -1,509 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     Jesper S Moller - realigned with bug 399695
- *******************************************************************************/
-
-package org.eclipse.jdt.core.tests.compiler.regression;
-
-import java.util.Map;
-
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import junit.framework.Test;
-
-public class CastingContextTest extends AbstractRegressionTest {
-
-static {
-	//	TESTS_NAMES = new String[] { "test380112e"};
-	//	TESTS_NUMBERS = new int[] { 50 };
-	//	TESTS_RANGE = new int[] { 11, -1 };
-}
-
-public CastingContextTest(String name) {
-	super(name);
-}
-
-public static Test suite() {
-	return buildMinimalComplianceTestSuite(testClass(), F_1_8);
-}
-
-protected Map getCompilerOptions() {
-	Map defaultOptions = super.getCompilerOptions();
-	defaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.WARNING);
-	defaultOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
-	defaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.WARNING);
-	return defaultOptions;
-}
-
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test001() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object o = () -> {};\n" +
-				"	Object p = (I) () -> {};\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 6)\n" + 
-			"	Object o = () -> {};\n" + 
-			"	           ^^^^^^^^\n" + 
-			"The target type of this expression must be a functional interface\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test002() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (I & J) () -> {};\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (I & J) () -> {};\n" + 
-			"	                   ^^^^^^^^\n" + 
-			"The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test003() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (int & I & J) () -> {};\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (int & I & J) () -> {};\n" + 
-			"	            ^^^\n" + 
-			"Base types are not allowed in intersection cast operator\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (int & I & J) () -> {};\n" + 
-			"	                         ^^^^^^^^\n" + 
-			"The target type of this expression must be a functional interface\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test004() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" + 
-			"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Arrays are not allowed in intersection cast operator\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" + 
-			"	                  ^^^^^^^^^^^^\n" + 
-			"Serializable cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test005() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (I & X) () -> {};\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (I & X) () -> {};\n" + 
-			"	                ^\n" + 
-			"The type X is not an interface; it cannot be specified as a bounded parameter\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (I & X) () -> {};\n" + 
-			"	                   ^^^^^^^^\n" + 
-			"The target type of this expression must be a functional interface\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test006() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (I & J & I) () -> {};\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (I & J & I) () -> {};\n" + 
-			"	                    ^\n" + 
-			"Duplicate type in intersection cast operator\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (I & J & I) () -> {};\n" + 
-			"	                       ^^^^^^^^\n" + 
-			"The target type of this expression must be a functional interface\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test007() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.util.List;\n" +
-				"interface I<T> {\n" +
-				"	void doit(List<T> x);\n" +
-				"	default void doitalso () {}\n" +
-				"	boolean equals(Object o);\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	I<String> i = (List<String> p) -> {};\n" +
-				"	I<X> i2 = (List<String> p) -> {};\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 9)\n" + 
-			"	I<X> i2 = (List<String> p) -> {};\n" + 
-			"	           ^^^^\n" + 
-			"Lambda expression\'s parameter p is expected to be of type List<X>\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test008() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"interface J {\n" +
-				"	void doit();\n" +
-				"	default void doitalso () {}\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" +
-				"}\n" ,
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
-			"	            ^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
-			"	                                ^^^^^^^^\n" + 
-			"Readonly cannot be resolved to a type\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 10)\n" + 
-			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
-			"	                                                         ^^^^^^^^\n" + 
-			"The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test009() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.util.List;\n" +
-				"import java.util.Map;\n" +
-				"interface I<T> {\n" +
-				"	void doit(List<T> x);\n" +
-				"	boolean equals(Object o);\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	I<String> i = (List<String> p) -> {};\n" +
-				"	I<X> i2 = (Map<String, String> & I<X>) null;\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. WARNING in X.java (at line 9)\n" + 
-			"	I<X> i2 = (Map<String, String> & I<X>) null;\n" + 
-			"	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Unnecessary cast from null to Map<String,String> & I<X>\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test010() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.util.List;\n" +
-				"import java.util.Map;\n" +
-				"interface I<T> {\n" +
-				"	void doit(List<T> x);\n" +
-				"	boolean equals(Object o);\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	I<String> i = (List<String> p) -> {};\n" +
-				"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 9)\n" + 
-			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
-			"	           ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The member type Map<String,String>.Entry cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 9)\n" + 
-			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
-			"	                                              ^^^^^^^^^^^^\n" + 
-			"Serializable cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test011() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	X X = (X & J & K) new Y();\n" +
-				"}\n" +
-				"class Y {\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 8)\n" + 
-			"	X X = (X & J & K) new Y();\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
-			"Cannot cast from Y to X & J & K\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test012() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	X X = (X & J & K) new Y();\n" +
-				"}\n" +
-				"class Y extends X implements Zork {\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. WARNING in X.java (at line 8)\n" + 
-			"	X X = (X & J & K) new Y();\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
-			"Unnecessary cast from Y to X & J & K\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	class Y extends X implements Zork {\n" + 
-			"	                             ^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test013() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	X X = (X & J & K) new Y();\n" +
-				"}\n" +
-				"final class Y extends X {\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 8)\n" + 
-			"	X X = (X & J & K) new Y();\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
-			"Cannot cast from Y to X & J & K\n" + 
-			"----------\n" + 
-			"2. WARNING in X.java (at line 8)\n" + 
-			"	X X = (X & J & K) new Y();\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
-			"Unnecessary cast from Y to X & J & K\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test014() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"   I i = null;\n" +
-				"	X X = (X & J & K) i;\n" +
-				"}\n" +
-				"final class Y extends P {\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 11)\n" + 
-			"	final class Y extends P {\n" + 
-			"	                      ^\n" + 
-			"P cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test015() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"final public class X {\n" +
-				"   I i = null;\n" +
-				"	X X = (X & J & K) i;\n" +
-				"   Zork z;\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 9)\n" + 
-			"	X X = (X & J & K) i;\n" + 
-			"	      ^^^^^^^^^^^^^\n" + 
-			"Cannot cast from I to X & J & K\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test016() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"final public class X implements I {\n" +
-				"   I i = null;\n" +
-				"	X X = (X & J & K) i;\n" +
-				"   Zork z;\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n");
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
-public void test017() {
-	this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"interface I {\n" +
-				"}\n" +
-				"interface J {\n" +
-				"}\n" +
-				"interface K {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"   I i = null;\n" +
-				"	X X = (X & J & K) (X & K & J) i;\n" +
-				"   Zork z;\n" +
-				"}\n",
-			},
-			"----------\n" + 
-			"1. WARNING in X.java (at line 9)\n" + 
-			"	X X = (X & J & K) (X & K & J) i;\n" + 
-			"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Unnecessary cast from X & K & J to X & J & K\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n");
-}
-public static Class testClass() {
-	return CastingContextTest.class;
-}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
new file mode 100644
index 0000000..b66a07a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
@@ -0,0 +1,636 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - realigned with bug 399695
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.util.Map;
+
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import junit.framework.Test;
+
+public class ExpressionContextTests extends AbstractRegressionTest {
+
+static {
+	//	TESTS_NAMES = new String[] { "test380112e"};
+	//	TESTS_NUMBERS = new int[] { 50 };
+	//	TESTS_RANGE = new int[] { 11, -1 };
+}
+
+public ExpressionContextTests(String name) {
+	super(name);
+}
+
+public static Test suite() {
+	return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+}
+
+protected Map getCompilerOptions() {
+	Map defaultOptions = super.getCompilerOptions();
+	defaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.WARNING);
+	defaultOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
+	defaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.WARNING);
+	return defaultOptions;
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test001() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object o = () -> {};\n" +
+				"	Object p = (I) () -> {};\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 6)\n" + 
+			"	Object o = () -> {};\n" + 
+			"	           ^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test002() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (I & J) () -> {};\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (I & J) () -> {};\n" + 
+			"	                   ^^^^^^^^\n" + 
+			"The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test003() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (int & I & J) () -> {};\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (int & I & J) () -> {};\n" + 
+			"	            ^^^\n" + 
+			"Base types are not allowed in intersection cast operator\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (int & I & J) () -> {};\n" + 
+			"	                         ^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test004() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" + 
+			"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Arrays are not allowed in intersection cast operator\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (X[] & Serializable & Cloneable) new X[0];\n" + 
+			"	                  ^^^^^^^^^^^^\n" + 
+			"Serializable cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test005() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (I & X) () -> {};\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (I & X) () -> {};\n" + 
+			"	                ^\n" + 
+			"The type X is not an interface; it cannot be specified as a bounded parameter\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (I & X) () -> {};\n" + 
+			"	                   ^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test006() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (I & J & I) () -> {};\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (I & J & I) () -> {};\n" + 
+			"	                    ^\n" + 
+			"Duplicate type in intersection cast operator\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (I & J & I) () -> {};\n" + 
+			"	                       ^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test007() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.util.List;\n" +
+				"interface I<T> {\n" +
+				"	void doit(List<T> x);\n" +
+				"	default void doitalso () {}\n" +
+				"	boolean equals(Object o);\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	I<String> i = (List<String> p) -> {};\n" +
+				"	I<X> i2 = (List<String> p) -> {};\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 9)\n" + 
+			"	I<X> i2 = (List<String> p) -> {};\n" + 
+			"	           ^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<X>\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test008() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	void doit();\n" +
+				"	default void doitalso () {}\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" +
+				"}\n" ,
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
+			"	            ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
+			"	                                ^^^^^^^^\n" + 
+			"Readonly cannot be resolved to a type\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 10)\n" + 
+			"	Object p = (@Marker java.lang. @Readonly String & I & J) () -> {};\n" + 
+			"	                                                         ^^^^^^^^\n" + 
+			"The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test009() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.util.List;\n" +
+				"import java.util.Map;\n" +
+				"interface I<T> {\n" +
+				"	void doit(List<T> x);\n" +
+				"	boolean equals(Object o);\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	I<String> i = (List<String> p) -> {};\n" +
+				"	I<X> i2 = (Map<String, String> & I<X>) null;\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 9)\n" + 
+			"	I<X> i2 = (Map<String, String> & I<X>) null;\n" + 
+			"	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Unnecessary cast from null to Map<String,String> & I<X>\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test010() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.util.List;\n" +
+				"import java.util.Map;\n" +
+				"interface I<T> {\n" +
+				"	void doit(List<T> x);\n" +
+				"	boolean equals(Object o);\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	I<String> i = (List<String> p) -> {};\n" +
+				"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 9)\n" + 
+			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
+			"	           ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The member type Map<String,String>.Entry cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 9)\n" + 
+			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
+			"	                                              ^^^^^^^^^^^^\n" + 
+			"Serializable cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test011() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	X X = (X & J & K) new Y();\n" +
+				"}\n" +
+				"class Y {\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 8)\n" + 
+			"	X X = (X & J & K) new Y();\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
+			"Cannot cast from Y to X & J & K\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test012() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	X X = (X & J & K) new Y();\n" +
+				"}\n" +
+				"class Y extends X implements Zork {\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 8)\n" + 
+			"	X X = (X & J & K) new Y();\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
+			"Unnecessary cast from Y to X & J & K\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	class Y extends X implements Zork {\n" + 
+			"	                             ^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test013() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	X X = (X & J & K) new Y();\n" +
+				"}\n" +
+				"final class Y extends X {\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 8)\n" + 
+			"	X X = (X & J & K) new Y();\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
+			"Cannot cast from Y to X & J & K\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 8)\n" + 
+			"	X X = (X & J & K) new Y();\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^\n" + 
+			"Unnecessary cast from Y to X & J & K\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test014() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"   I i = null;\n" +
+				"	X X = (X & J & K) i;\n" +
+				"}\n" +
+				"final class Y extends P {\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	final class Y extends P {\n" + 
+			"	                      ^\n" + 
+			"P cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test015() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"final public class X {\n" +
+				"   I i = null;\n" +
+				"	X X = (X & J & K) i;\n" +
+				"   Zork z;\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 9)\n" + 
+			"	X X = (X & J & K) i;\n" + 
+			"	      ^^^^^^^^^^^^^\n" + 
+			"Cannot cast from I to X & J & K\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test016() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"final public class X implements I {\n" +
+				"   I i = null;\n" +
+				"	X X = (X & J & K) i;\n" +
+				"   Zork z;\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399773, [1.8][compiler] Cast expression should allow for additional bounds to form intersection types
+public void test017() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"}\n" +
+				"interface J {\n" +
+				"}\n" +
+				"interface K {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"   I i = null;\n" +
+				"	X X = (X & J & K) (X & K & J) i;\n" +
+				"   Zork z;\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 9)\n" + 
+			"	X X = (X & J & K) (X & K & J) i;\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Unnecessary cast from X & K & J to X & J & K\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778, [1.8][compiler] Conditional operator expressions should propagate target types
+public void test018() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"}\n" +
+				"class X {\n" +
+				"	Object o = (I) () -> {};\n" +
+				"	I k = (()->{});\n" +
+				"	I i = 1 == 2 ? () -> {} : () -> {};\n" +
+				"	I j = () -> {};\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 7)\n" + 
+			"	I i = 1 == 2 ? () -> {} : () -> {};\n" + 
+			"	               ^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778, [1.8][compiler] Conditional operator expressions should propagate target types
+public void test019() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"}\n" +
+				"class X {\n" +
+				"	I [] k = {(()->{}), ()->{}, 1 == 2 ? () -> {} : ()->{}};\n" +
+				"	I [][] i = {{()->{}}};\n" +
+				"	void foo() {\n" +
+				"       I i = () -> {};\n" +
+			    "   }\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 5)\n" + 
+			"	I [] k = {(()->{}), ()->{}, 1 == 2 ? () -> {} : ()->{}};\n" + 
+			"	                                     ^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 8)\n" + 
+			"	I i = () -> {};\n" + 
+			"	  ^\n" + 
+			"The local variable i is hiding a field from type X\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778, [1.8][compiler] Conditional operator expressions should propagate target types
+public void test020() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	J doit(int x);\n" +
+				"}\n" +
+				"interface J {\n" +
+				"	K doit();\n" +
+				"}\n" +
+				"interface K {\n" +
+				"   I doit();\n" +
+				"}" +
+				"class X {\n" +
+				"	I foo() {\n" +
+				"       return x -> { return () -> () -> \"Hello\"; };\n" +
+			    "   }\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	return x -> { return () -> () -> \"Hello\"; };\n" + 
+			"	                                 ^^^^^^^\n" + 
+			"Type mismatch: cannot convert from String to I\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778, [1.8][compiler] Conditional operator expressions should propagate target types
+public void test021() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"	void doit();\n" +
+				"}\n" +
+				"class X {\n" +
+				"	I foo() {\n" +
+				"       return \"Hello\" + () -> {};\n" +
+			    "   }\n" +
+			    "	I goo() {\n" +
+				"       return \"Hello\" + (I)(() -> {});\n" +
+			    "   }\n" +
+			    "	I zoo() {\n" +
+				"       return 10 + (() -> {});\n" +
+			    "   }\n" +
+			    "	I boo() {\n" +
+				"       return 10 + (I) (() -> {});\n" +
+			    "   }\n" +
+				"}\n",
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 6)\n" + 
+			"	return \"Hello\" + () -> {};\n" + 
+			"	                 ^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 9)\n" + 
+			"	return \"Hello\" + (I)(() -> {});\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type mismatch: cannot convert from String to I\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 9)\n" + 
+			"	return \"Hello\" + (I)(() -> {});\n" + 
+			"	                 ^^^^^^^^^^^^^\n" + 
+			"Unnecessary cast from I to I\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 12)\n" + 
+			"	return 10 + (() -> {});\n" + 
+			"	            ^^^^^^^^^^\n" + 
+			"The target type of this expression must be a functional interface\n" + 
+			"----------\n" + 
+			"5. ERROR in X.java (at line 15)\n" + 
+			"	return 10 + (I) (() -> {});\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^\n" + 
+			"The operator + is undefined for the argument type(s) int, I\n" + 
+			"----------\n");
+}
+public static Class testClass() {
+	return ExpressionContextTests.class;
+}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index bd861b5..fc7c6b2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -37856,12 +37856,19 @@ public void test1109() {
 			"  }\n" +
 			"}\n",
 		},
+		this.complianceLevel < ClassFileConstants.JDK1_8 ? 
 		"----------\n" +
 		"1. ERROR in X.java (at line 4)\n" +
 		"	return true ? Z.bar() : null;\n" +
 		"	       ^^^^^^^^^^^^^^^^^^^^^\n" +
 		"Type mismatch: cannot convert from Y<Object> to Y<String>\n" +
-		"----------\n");
+		"----------\n" :
+			"----------\n" + 
+			"1. WARNING in X.java (at line 4)\n" + 
+			"	return true ? Z.bar() : null;\n" + 
+			"	                        ^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=176591
 //variant
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 3b085e3..a2bc6d8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -127,7 +127,7 @@ public static Test suite() {
 	since_1_8.add(NegativeTypeAnnotationTest.class);
 	since_1_8.add(NullTypeAnnotationTest.class);
 	since_1_8.add(NegativeLambdaExpressionsTest.class);
-	since_1_8.add(CastingContextTest.class);
+	since_1_8.add(ExpressionContextTests.class);
 	since_1_8.add(DefaultMethodsTest.class);
 	since_1_8.add(GrammarCoverageTests308.class);
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
index 53ad26d..dde00a7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
@@ -29,7 +29,7 @@ import org.eclipse.jdt.core.tests.compiler.parser.ComplianceDiagnoseTest;
 import org.eclipse.jdt.core.tests.compiler.parser.LambdaExpressionSyntaxTest;
 import org.eclipse.jdt.core.tests.compiler.parser.ReferenceExpressionSyntaxTest;
 import org.eclipse.jdt.core.tests.compiler.parser.TypeAnnotationSyntaxTest;
-import org.eclipse.jdt.core.tests.compiler.regression.CastingContextTest;
+import org.eclipse.jdt.core.tests.compiler.regression.ExpressionContextTests;
 import org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests;
 import org.eclipse.jdt.core.tests.compiler.regression.DefaultMethodsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.GrammarCoverageTests308;
@@ -61,7 +61,7 @@ public class RunAllJava8Tests extends TestCase {
 			GrammarCoverageTests308.class,
 			NullTypeAnnotationTest.class,
 			CompilerInvocationTests.class,
-			CastingContextTest.class,
+			ExpressionContextTests.class,
 		};
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractVariableDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractVariableDeclaration.java
index 71e11ac..813b44a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractVariableDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractVariableDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,7 +21,7 @@ import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
-public abstract class AbstractVariableDeclaration extends Statement implements InvocationSite {
+public abstract class AbstractVariableDeclaration extends Statement implements InvocationSite, ExpressionContext {
 	public int declarationEnd;
 	/**
 	 * For local declarations (outside of for statement initialization) and field declarations,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 06064b8..1a6166b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -47,6 +47,7 @@ public class AllocationExpression extends Expression implements InvocationSite {
 	public boolean inferredReturnType;
 
 	public FakedTrackingVariable closeTracker;	// when allocation a Closeable store a pre-liminary tracking variable here
+	private ExpressionContext expressionContext = VANILLA_CONTEXT;
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	// check captured variables are initialized in current context (26134)
@@ -355,6 +356,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
 				argsContainCast = true;
 			}
+			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
 				argHasError = true;
 			}
@@ -521,6 +523,16 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 public void setExpectedType(TypeBinding expectedType) {
 	this.typeExpected = expectedType;
 }
+
+public void setExpressionContext(ExpressionContext context) {
+	this.expressionContext = context;
+}
+
+public boolean isPolyExpression() {
+	return (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) &&
+			this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.lookup.InvocationSite#expectedType()
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index f35b7b1..f9780d0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for 
@@ -162,6 +166,7 @@ public class ArrayInitializer extends Expression {
 			TypeBinding elementType = this.binding.elementsType();
 			for (int i = 0, length = this.expressions.length; i < length; i++) {
 				Expression expression = this.expressions[i];
+				expression.setExpressionContext(ASSIGNMENT_CONTEXT);
 				expression.setExpectedType(elementType);
 				TypeBinding expressionType = expression instanceof ArrayInitializer
 						? expression.resolveTypeExpecting(scope, elementType)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index a368ff9..30c4ee3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -191,6 +191,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		return null;
 	}
 	TypeBinding lhsType = this.lhs.resolveType(scope);
+	this.expression.setExpressionContext(ASSIGNMENT_CONTEXT);
 	this.expression.setExpectedType(lhsType); // needed in case of generic method invocation
 	if (lhsType != null) {
 		this.resolvedType = lhsType.capture(scope, this.sourceEnd);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index a516e1b..2cb0ab0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -494,7 +494,8 @@ public TypeBinding resolveType(BlockScope scope) {
 
 	TypeBinding castType = this.resolvedType = this.type.resolveType(scope);
 	if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
-		if (this.expression.isPolyExpressionInCastingContext()) {
+		this.expression.setExpressionContext(CASTING_CONTEXT);
+		if (this.expression.isPolyExpression()) {
 			this.expression.setExpectedType(this.resolvedType);
 			this.bits |= ASTNode.DisableUnnecessaryCastCheck;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 8a58a10..aea320c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephen Herrmann <stephan@cs.tu-berlin.de> -  Contributions for
@@ -39,6 +43,8 @@ public class ConditionalExpression extends OperatorExpression {
 	
 	// we compute and store the null status during analyseCode (https://bugs.eclipse.org/324178):
 	private int nullStatus = FlowInfo.UNKNOWN;
+	private TypeBinding expectedType;
+	private ExpressionContext expressionContext = VANILLA_CONTEXT;
 
 	public ConditionalExpression(
 		Expression condition,
@@ -409,11 +415,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		// JLS3 15.25
 		this.constant = Constant.NotAConstant;
 		LookupEnvironment env = scope.environment();
-		boolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
+		final long sourceLevel = scope.compilerOptions().sourceLevel;
+		boolean use15specifics = sourceLevel >= ClassFileConstants.JDK1_5;
+		boolean use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;
 		TypeBinding conditionType = this.condition.resolveTypeExpecting(scope, TypeBinding.BOOLEAN);
 		this.condition.computeConversion(scope, TypeBinding.BOOLEAN, conditionType);
 
 		if (this.valueIfTrue instanceof CastExpression) this.valueIfTrue.bits |= DisableUnnecessaryCastCheck; // will check later on
+		
+		if (use18specifics) { 
+			if (this.valueIfTrue.isPolyExpression()) // context propagated already.
+				this.valueIfTrue.setExpectedType(this.expectedType);
+			if (this.valueIfFalse.isPolyExpression())
+				this.valueIfFalse.setExpectedType(this.expectedType);
+		}
+		
 		TypeBinding originalValueIfTrueType = this.valueIfTrue.resolveType(scope);
 
 		if (this.valueIfFalse instanceof CastExpression) this.valueIfFalse.bits |= DisableUnnecessaryCastCheck; // will check later on
@@ -593,6 +609,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return null;
 	}
 
+	public void setExpectedType(TypeBinding expectedType) {
+		this.expectedType = expectedType;
+	}
+	
+	public void setExpressionContext(ExpressionContext context) {
+		this.expressionContext = context;
+		this.valueIfTrue.setExpressionContext(context);
+		this.valueIfFalse.setExpressionContext(context);
+	}
+	
+	public boolean isPolyExpression() {
+		return (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) &&
+				this.valueIfTrue.isPolyExpression() && this.valueIfFalse.isPolyExpression();
+	}
+
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
 		if (visitor.visit(this, scope)) {
 			this.condition.traverse(visitor, scope);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 9e8de3f..6705d9b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -39,7 +39,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 
-public class ExplicitConstructorCall extends Statement implements InvocationSite {
+public class ExplicitConstructorCall extends Statement implements InvocationSite, ExpressionContext {
 
 	public Expression[] arguments;
 	public Expression qualification;
@@ -368,6 +368,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 						argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
 						argsContainCast = true;
 					}
+					argument.setExpressionContext(INVOCATION_CONTEXT);
 					if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
 						argHasError = true;
 					}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 1d8c945..e93c53f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -50,7 +50,7 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.problem.ShouldNotImplement;
 import org.eclipse.jdt.internal.compiler.util.Messages;
 
-public abstract class Expression extends Statement {
+public abstract class Expression extends Statement implements ExpressionContext {
 
 	public Constant constant;
 
@@ -1105,6 +1105,14 @@ public void setExpectedType(TypeBinding expectedType) {
     // do nothing by default
 }
 
+public void setExpressionContext(ExpressionContext context) {
+	// don't care. Subclasses that are poly expressions in specific contexts should listen in and make note.
+}
+
+public boolean isPolyExpression() {
+	return false; // Subclasses that are poly expressions should answer appropriately based on the context they feature in.
+}
+
 public void tagAsNeedCheckCast() {
     // do nothing by default
 }
@@ -1162,8 +1170,4 @@ public boolean statementExpression() {
 public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
 	return null;
 }
-
-public boolean isPolyExpressionInCastingContext() {
-	return false;
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExpressionContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExpressionContext.java
new file mode 100644
index 0000000..b539fa0
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExpressionContext.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.ast;
+
+public interface ExpressionContext {
+	
+	/* Assignment context: potential poly-expressions are: method invocations, lambdas, reference expressions, 
+	   conditional expressions and allocation expressions. This is the only Java 7 context where target type
+	   influenced evaluation of some expression.
+	   
+	   Context induced by: ReturnStatement, ArrayInitializer, Assignment, FieldDeclaration and LocalDeclaration. 
+	*/
+	public static final ExpressionContext ASSIGNMENT_CONTEXT = 
+								new ExpressionContext() {
+									public String toString() {
+										return "assignment context"; //$NON-NLS-1$
+									}
+								};
+	
+	/* Invocation context: potential poly-expressions are: method invocations, lambdas, reference expressions, 
+	   conditional expressions and allocation expressions. At this point, we don't distinguish between strict 
+	   and loose invocation contexts.
+	   
+	   Context induced by: AllocationExpression, QualifiedAllocationExpression, ExplicitConstructorCall, MessageSend
+	   CodeSnippetAllocationExpression and CodeSnippetMessageSend.
+	*/
+	public static final ExpressionContext INVOCATION_CONTEXT = 
+								new ExpressionContext() {
+									public String toString() {
+										return "invocation context"; //$NON-NLS-1$
+									}
+								};
+	
+	/* Casting context: potential poly-expressions are: lambdas and reference expressions
+	   Context induced by: CastExpression.
+	*/
+	public static final ExpressionContext CASTING_CONTEXT = 
+								new ExpressionContext() {
+									public String toString() {
+										return "casting context"; //$NON-NLS-1$
+									}
+								};
+	
+	/* Vanilla context (string, numeric): potential poly-expressions are: NONE. This is the nonpoly context in which 
+	   expressions get evaluated, unless they feature in one of the above contexts. 
+	*/
+	public static final ExpressionContext VANILLA_CONTEXT = 
+								new ExpressionContext() {
+									public String toString() {
+										return "vanilla context"; //$NON-NLS-1$
+									}
+								};
+		
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index c7898ee..037504e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -238,6 +238,7 @@ public void resolve(MethodScope initializationScope) {
 
 			TypeBinding fieldType = this.binding.type;
 			TypeBinding initializationType;
+			this.initialization.setExpressionContext(ASSIGNMENT_CONTEXT);
 			this.initialization.setExpectedType(fieldType); // needed in case of generic method invocation
 			if (this.initialization instanceof ArrayInitializer) {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index f2b6ef4..0cf6ca6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -34,6 +34,7 @@ public abstract class FunctionalExpression extends Expression {
 	TypeBinding expectedType;
 	MethodBinding descriptor;
 	MethodBinding binding;
+	private ExpressionContext expressionContext = VANILLA_CONTEXT;
 	
 	public FunctionalExpression() {
 		super();
@@ -42,15 +43,19 @@ public abstract class FunctionalExpression extends Expression {
 	public void setExpectedType(TypeBinding expectedType) {
 		this.expectedType = expectedType;
 	}
+	
+	public void setExpressionContext(ExpressionContext context) {
+		this.expressionContext = context;
+	}
+	
+	public boolean isPolyExpression() {
+		return this.expressionContext != VANILLA_CONTEXT;
+	}
 
 	public TypeBinding expectedType() {
 		return this.expectedType;
 	}
 	
-	public boolean isPolyExpressionInCastingContext() {
-		return true;
-	}
-	
 	public TypeBinding resolveType(BlockScope blockScope) {
 		this.constant = Constant.NotAConstant;
 		MethodBinding sam = this.expectedType == null ? null : this.expectedType.getSingleAbstractMethod(blockScope);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index f2d9e92..8dd6c14 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -270,7 +270,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					this.initialization.computeConversion(scope, variableType, initializationType);
 				}
 			} else {
-			    this.initialization.setExpectedType(variableType);
+				this.initialization.setExpressionContext(ASSIGNMENT_CONTEXT);
+				this.initialization.setExpectedType(variableType);
 				TypeBinding initializationType = this.initialization.resolveType(scope);
 				if (initializationType != null) {
 					if (variableType != initializationType) // must call before computeConversion() and typeMismatchError()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
index 53c7b16..21871fe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -79,7 +79,7 @@ public class MemberValuePair extends ASTNode {
 			return;
 		}
 
-		this.value.setExpectedType(requiredType); // needed in case of generic method invocation
+		this.value.setExpectedType(requiredType); // needed in case of generic method invocation - looks suspect, generic method invocation here ???
 		TypeBinding valueType;
 		if (this.value instanceof ArrayInitializer) {
 			ArrayInitializer initializer = (ArrayInitializer) this.value;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 10eb2c9..4c99c45 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -78,6 +78,7 @@ public class MessageSend extends Expression implements InvocationSite {
 	public TypeBinding valueCast; // extra reference type cast to perform on method returned value
 	public TypeReference[] typeArguments;
 	public TypeBinding[] genericTypeArguments;
+	private ExpressionContext expressionContext = VANILLA_CONTEXT;
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	boolean nonStatic = !this.binding.isStatic();
@@ -481,6 +482,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
 				argsContainCast = true;
 			}
+			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if ((argumentTypes[i] = argument.resolveType(scope)) == null){
 				argHasError = true;
 			}
@@ -688,6 +690,26 @@ public void setDepth(int depth) {
 public void setExpectedType(TypeBinding expectedType) {
     this.expectedType = expectedType;
 }
+
+public void setExpressionContext(ExpressionContext context) {
+	this.expressionContext = context;
+}
+
+public boolean isPolyExpression() {
+	
+	/* 15.12 has four requirements: (1) The invocation appears in an assignment context or an invocation context
+       (2) The invocation elides NonWildTypeArguments (3) the method to be invoked is a generic method (8.4.4).
+       (4) The return type of the method to be invoked mentions at least one of the method's type parameters.
+    
+       We are in no position to ascertain the last two now - until the method call is fully resolved, there is no
+       way to know this. Instead, we simply claim we are a poly expression if the first two stipulations are met, 
+       grab the expected type with the proviso that we will not touch it until the two conditions we are unable to
+       verify right now are seen to indeed hold.
+ */
+	return (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) &&
+			(this.typeArguments == null || this.typeArguments.length == 0);		
+}
+
 public void setFieldIndex(int depth) {
 	// ignore for here
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 462688d..efe496b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -373,6 +377,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
 					argsContainCast = true;
 				}
+				argument.setExpressionContext(INVOCATION_CONTEXT);
 				if ((argumentTypes[i] = argument.resolveType(scope)) == null){
 					hasError = true;
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index 242719a..38e7041 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -195,7 +195,7 @@ static void reportOnlyUselesslyReadLocal(BlockScope currentScope, LocalVariableB
 	if (localBinding.declaration instanceof Argument) {
 		// check compiler options to report against unused arguments
 		MethodScope methodScope = currentScope.methodScope();
-		if (methodScope != null) {
+		if (methodScope != null && !methodScope.isLambdaScope()) { // lambda must be congruent with the descriptor.
 			MethodBinding method = ((AbstractMethodDeclaration)methodScope.referenceContext()).binding;
 			
 			boolean shouldReport = !method.isMain();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index d90aec5..ffdc3cc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -37,7 +37,7 @@ import org.eclipse.jdt.internal.compiler.flow.*;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
-public class ReturnStatement extends Statement {
+public class ReturnStatement extends Statement implements ExpressionContext {
 
 	public Expression expression;
 	public SubRoutineStatement[] subroutines;
@@ -279,6 +279,12 @@ public void resolve(BlockScope scope) {
 				: methodBinding.returnType)
 			: TypeBinding.VOID;
 	TypeBinding expressionType;
+	
+	if (this.expression != null) {
+		this.expression.setExpressionContext(ASSIGNMENT_CONTEXT);
+		this.expression.setExpectedType(methodType);
+	}
+	
 	if (methodType == TypeBinding.VOID) {
 		// the expression should be null
 		if (this.expression == null)
@@ -294,7 +300,6 @@ public void resolve(BlockScope scope) {
 		if (methodType != null) scope.problemReporter().shouldReturn(methodType, this);
 		return;
 	}
-	this.expression.setExpectedType(methodType); // needed in case of generic method invocation
 	if ((expressionType = this.expression.resolveType(scope)) == null) return;
 	if (expressionType == TypeBinding.VOID) {
 		scope.problemReporter().attemptToReturnVoidValue(this);
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
index 55d47f4..0d9a77e 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
@@ -1,9 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -185,6 +189,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
 				argsContainCast = true;
 			}
+			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
 				argHasError = true;
 			}
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
index fa30c00..a434b92 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -225,6 +229,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
 				argsContainCast = true;
 			}
+			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if ((argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)
 				argHasError = true;
 		}
