commit f103afa2b75b8198880ca7616628c69d234642fd
Author: Stephan Herrmann <sherrmann>
Date:   Sat Oct 8 22:25:32 2011 +0200

    HEAD - Fixed bug 360328: [compiler][null] detect null problems in nested
    code (local class inside a loop)

273	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
14	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
10	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 5ea3543..21a0d02 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -20,6 +20,7 @@
  * 							bug 354554 - [null] conditional with redundant condition yields weak error message
  * 							bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
  * 							bug 349326 - [1.7] new warning for missing try-with-resources
+ * 							bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -47,7 +48,7 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "test358827" };
+//		TESTS_NAMES = new String[] { "testBug360328" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -15124,4 +15125,275 @@ public void testBug256796a() {
 			true,
 			compilerOptions);
 }
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+public void testBug360328() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+	runNegativeTest(
+		true, /* flushOutputDir */
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void print4() {\n" +
+			"        final String s1 = \"\";\n" +
+			"        for (int i=0; i<4; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     if (s1 != null)\n" +
+			"                         s1.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"    void print16(boolean b) {\n" +
+			"        final String s3 = b ? null : \"\";\n" +
+			"        for (int i=0; i<16; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     s3.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"    void print23() {\n" +
+			"        final String s23 = null;\n" +
+			"        for (int i=0; i<23; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     s23.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		null, /* classLibs */
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	if (s1 != null)\n" +
+		"	    ^^\n" +
+		"Redundant null check: The variable s1 cannot be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 17)\n" +
+		"	s3.toString();\n" +
+		"	^^\n" +
+		"Potential null pointer access: The variable s3 may be null at this location\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 26)\n" +
+		"	s23.toString();\n" +
+		"	^^^\n" +
+		"Null pointer access: The variable s23 can only be null at this location\n" +
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+// constructors
+public void testBug360328b() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+	runNegativeTest(
+		true, /* flushOutputDir */
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void print4() {\n" +
+			"        final String s1 = \"\";\n" +
+			"        for (int i=0; i<4; i++) {\n" +
+			"            class R {\n" +
+			"                public R() {\n" +
+			"                     if (s1 != null)\n" +
+			"                         s1.toString();\n" +
+			"                }\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print16(boolean b) {\n" +
+			"        final String s3 = b ? null : \"\";\n" +
+			"        int i=0; while (i++<16) {\n" +
+			"            class R {\n" +
+			"                public R() {\n" +
+			"                     s3.toString();\n" +
+			"                }\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        };\n" +
+			"    }\n" +
+			"    void print23() {\n" +
+			"        final String s23 = null;\n" +
+			"        for (int i=0; i<23; i++) {\n" +
+			"            class R {\n" +
+			"                public R() {\n" +
+			"                     s23.toString();\n" +
+			"                }\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        };\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		null, /* classLibs */
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	if (s1 != null)\n" +
+		"	    ^^\n" +
+		"Redundant null check: The variable s1 cannot be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 19)\n" +
+		"	s3.toString();\n" +
+		"	^^\n" +
+		"Potential null pointer access: The variable s3 may be null at this location\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 30)\n" +
+		"	s23.toString();\n" +
+		"	^^^\n" +
+		"Null pointer access: The variable s23 can only be null at this location\n" +
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+// initializers
+public void testBug360328c() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	runNegativeTest(
+		true, /* flushOutputDir */
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void print4() {\n" +
+			"        final String s1 = \"\";\n" +
+			"        for (int i=0; i<4; i++) {\n" +
+			"            class R {\n" +
+			"                String s1R;\n" +
+			"                {\n" +
+			"                    if (s1 != null)\n" +
+			"                         s1R = s1;\n" +
+			"                }\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print16(boolean b) {\n" +
+			"        final String s3 = b ? null : \"\";\n" +
+			"        for (int i=0; i<16; i++) {\n" +
+			"            class R {\n" +
+			"                String s3R = s3.toString();\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        };\n" +
+			"    }\n" +
+			"    void print23() {\n" +
+			"        final String s23 = null;\n" +
+			"        for (int i=0; i<23; i++) {\n" +
+			"            class R {\n" +
+			"                String s23R;\n" +
+			"                {\n" +
+			"                     s23R = s23.toString();\n" +
+			"                }\n" +
+			"            };\n" +
+			"            new R();\n" +
+			"        };\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		null, /* classLibs */
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 8)\n" +
+		"	if (s1 != null)\n" +
+		"	    ^^\n" +
+		"Redundant null check: The variable s1 cannot be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 19)\n" +
+		"	String s3R = s3.toString();\n" +
+		"	             ^^\n" +
+		"Potential null pointer access: The variable s3 may be null at this location\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 30)\n" +
+		"	s23R = s23.toString();\n" +
+		"	       ^^^\n" +
+		"Null pointer access: The variable s23 can only be null at this location\n" +
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+// try-finally instead of loop
+public void testBug360328d() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+	runNegativeTest(
+		true, /* flushOutputDir */
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void print4() {\n" +
+			"        final String s1 = \"\";\n" +
+			"        try { } finally {\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     if (s1 != null)\n" +
+			"                         s1.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print16(boolean b) {\n" +
+			"        final String s3 = b ? null : \"\";\n" +
+			"        try { } finally {\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     s3.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print23() {\n" +
+			"        final String s23 = null;\n" +
+			"        try { } finally {\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     s23.toString();\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		null, /* classLibs */
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	if (s1 != null)\n" +
+		"	    ^^\n" +
+		"Redundant null check: The variable s1 cannot be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 18)\n" +
+		"	s3.toString();\n" +
+		"	^^\n" +
+		"Potential null pointer access: The variable s3 may be null at this location\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 28)\n" +
+		"	s23.toString();\n" +
+		"	^^^\n" +
+		"Null pointer access: The variable s23 can only be null at this location\n" +
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 989471e..8903d13 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -15,7 +15,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Compiler for Java(TM)
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.C14, 3.8.0 M3
+compiler.version = 0.C15, 3.8.0 M3
 compiler.copyright = Copyright IBM Corp 2000, 2011. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 98aa27f..835e43d 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -42,11 +42,24 @@
 	</td>
   </tr>
 </table>
+<a name="v_C15"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java development tools core</h1>
+Eclipse SDK 3.8.0 - %date% - 3.8.0 M3
+<br>Project org.eclipse.jdt.core v_C15
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C15">cvs</a>).
+<h2>What's new in this drop</h2>
+
+<h3>Problem Reports Fixed</h3>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=360328">360328</a>
+[compiler][null] detect null problems in nested code (local class inside a loop)
+
 <a name="v_C14"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java development tools core</h1>
-Eclipse SDK 3.8.0 - October 5, 2011 - 3.8.0 M3
+Eclipse SDK 3.8.0 - October 5, 2011
 <br>Project org.eclipse.jdt.core v_C14
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C14">cvs</a>).
 <h2>What's new in this drop</h2>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 228e6e8..995b093 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -12,8 +12,6 @@ package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.compiler.*;
-import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
-import org.eclipse.jdt.internal.compiler.flow.InitializationFlowContext;
 import org.eclipse.jdt.internal.compiler.impl.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
@@ -69,8 +67,6 @@ public abstract class AbstractMethodDeclaration
 		}
 	}
 
-	public abstract void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo info);
-
 	/**
 	 * Bind and add argument's binding into the scope of the method
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5b60ba3..5a5c24c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -16,8 +16,8 @@ import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
+import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
-import org.eclipse.jdt.internal.compiler.flow.InitializationFlowContext;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
@@ -44,7 +44,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 		super(compilationResult);
 	}
 
-	public void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo) {
+	public void analyseCode(ClassScope classScope, FlowContext flowContext, FlowInfo flowInfo) {
 		// starting of the code analysis for methods
 		if (this.ignoreFurtherInvestigation)
 			return;
@@ -72,7 +72,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 
 			ExceptionHandlingFlowContext methodContext =
 				new ExceptionHandlingFlowContext(
-					initializationContext,
+					flowContext,
 					this,
 					this.binding.thrownExceptions,
 					null,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index b475932..f5d41ea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -625,7 +626,11 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 			this.scope.problemReporter().unusedPrivateType(this);
 		}
 	}
-	InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, flowInfo, flowContext, this.initializerScope);
+	// for local classes we use the flowContext as our parent, but never use an initialization context for this purpose
+	// see Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+	FlowContext parentContext = (flowContext instanceof InitializationFlowContext) ? null : flowContext;
+	InitializationFlowContext initializerContext = new InitializationFlowContext(parentContext, this, flowInfo, flowContext, this.initializerScope);
+	// no static initializer in local classes, thus no need to set parent:
 	InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, flowInfo, flowContext, this.staticInitializerScope);
 	FlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();
 	FlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();
@@ -684,8 +689,9 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 			if (method.ignoreFurtherInvestigation)
 				continue;
 			if (method.isInitializationMethod()) {
+				// pass down the appropriate initializerContext:
 				if (method.isStatic()) { // <clinit>
-					method.analyseCode(
+					((Clinit)method).analyseCode(
 						this.scope,
 						staticInitializerContext,
 						staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
@@ -693,7 +699,8 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 					((ConstructorDeclaration)method).analyseCode(this.scope, initializerContext, constructorInfo.copy(), flowInfo.reachMode());
 				}
 			} else { // regular method
-				method.analyseCode(this.scope, null, flowInfo.copy());
+				// pass down the parentContext (NOT an initializer context, see above):
+				((MethodDeclaration)method).analyseCode(this.scope, parentContext, flowInfo.copy());
 			}
 		}
 	}
commit 2d0b70991183be97a67695fa28c23b0cb3fbbdbf
Author: Stephan Herrmann <sherrmann>
Date:   Sun Oct 9 17:24:47 2011 +0200

    HEAD - Fixed bug 360328: [compiler][null] detect null problems in nested
    code (local class inside a loop)

31	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
8	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
index 5c83d04..3d7afcd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
  *      						bug 349326 - [1.7] new warning for missing try-with-resources
+ *      						bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -30,6 +31,7 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 public class FlowAnalysisTest extends AbstractRegressionTest {
 static {
+//	TESTS_NAMES = new String[] { "testLocalClassInInitializer1" };
 //	TESTS_NUMBERS = new int[] { 69 };
 }
 public FlowAnalysisTest(String name) {
@@ -2408,6 +2410,35 @@ public void testCloseable2() {
 			}, 
 			"");	
 }
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+// return/break/continue inside anonymous class inside try-catch inside initializer
+public void testLocalClassInInitializer1() {
+	this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"    static {\n" +
+				"        final int i=4;\n" +
+				"        try {\n" +
+				"            Runnable runner = new Runnable() {\n" +
+				"                public void run() {\n" +
+				"                    switch (i) {" +
+				"                        case 4: break;\n" +
+				"                    }\n" +
+				"                    int j = i;\n" +
+				"                    while (j++ < 10) {\n" +
+				"                        if (j == 2) continue;\n" +
+				"                        if (j == 4) break;\n" +
+				"                        if (j == 6) return;\n" +
+				"                    }\n" +
+				"                }\n" +
+				"            };\n" +
+				"        } catch (RuntimeException re) {}\n" +
+				"    }\n" +
+				"}\n"
+			}, 
+			"");	
+}
 public static Class testClass() {
 	return FlowAnalysisTest.class;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index ca1e277..f2b6010 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for 
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *     							bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -37,6 +38,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 
 	// lookup the label, this should answer the returnContext
 
+	MethodScope methodScope = currentScope.methodScope();
+	AbstractMethodDeclaration referenceMethod = methodScope.referenceMethod();
 	if (this.expression != null) {
 		flowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);
 		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
@@ -44,7 +47,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		FakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression);
 		if (trackingVariable != null) {
-			if (currentScope.methodScope() != trackingVariable.methodScope)
+			if (methodScope != trackingVariable.methodScope)
 				trackingVariable.markClosedInNestedMethod();
 			// don't report issues concerning this local, since by returning
 			// the method passes the responsibility to the caller:
@@ -52,7 +55,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 	}
 	this.initStateIndex =
-		currentScope.methodScope().recordInitializationStates(flowInfo);
+		methodScope.recordInitializationStates(flowInfo);
 	// compute the return sequence (running the finally blocks)
 	FlowContext traversedContext = flowContext;
 	int subCount = 0;
@@ -89,13 +92,15 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					}
 					saveValueNeeded = true;
 					this.initStateIndex =
-						currentScope.methodScope().recordInitializationStates(flowInfo);
+						methodScope.recordInitializationStates(flowInfo);
 				}
 			}
 		} else if (traversedContext instanceof InitializationFlowContext) {
 				currentScope.problemReporter().cannotReturnInInitializer(this);
 				return FlowInfo.DEAD_END;
 		}
+		if (traversedContext.associatedNode == referenceMethod)
+			break; // don't traverse beyond the enclosing method (see https://bugs.eclipse.org/360328).
 	} while ((traversedContext = traversedContext.parent) != null);
 
 	// resize subroutines
commit 1adff7e346cbd79e4672d3b7b0f319fb8170d9e9
Author: Stephan Herrmann <sherrmann>
Date:   Thu Oct 13 21:01:15 2011 +0200

    HEAD - Fixed bug 360328: [compiler][null] detect null problems in nested
    code (local class inside a loop)

52	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
21	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LabelFlowContext.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
index 3d7afcd..f197e7d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest.java
@@ -2437,7 +2437,58 @@ public void testLocalClassInInitializer1() {
 				"    }\n" +
 				"}\n"
 			}, 
-			"");	
+			"");
+}
+// Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+// break/continue illegally inside anonymous class inside loop (loop is out of scope for break/continue)
+public void testLocalClassInInitializer2() {
+	this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"    void f () {\n" +
+				"        while (true) {\n" +
+				"            class Inner1 {\n" +
+				"                { if (true) break; }\n" +
+				"            }\n" +
+				"            new Inner1();\n" +
+				"        }\n" +
+				"    } \n" +
+				"    void g () {\n" +
+				"        outer: for (int i=1;true;i++) {\n" +
+				"            class Inner2 {\n" +
+				"                int j = 3;\n" +
+				"                void foo () {\n" +
+				"                  if (2 == j) continue outer;\n" +
+				"                  else continue;\n" +
+				"                }\n" +
+				"            }\n" +
+				"            new Inner2().foo();\n" +
+				"        }\n" +
+				"    } \n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 5)\n" + 
+			"	{ if (true) break; }\n" + 
+			"	            ^^^^^^\n" + 
+			"break cannot be used outside of a loop or a switch\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 11)\n" + 
+			"	outer: for (int i=1;true;i++) {\n" + 
+			"	^^^^^\n" + 
+			"The label outer is never explicitly referenced\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 15)\n" + 
+			"	if (2 == j) continue outer;\n" + 
+			"	            ^^^^^^^^^^^^^^^\n" + 
+			"The label outer is missing\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 16)\n" + 
+			"	else continue;\n" + 
+			"	     ^^^^^^^^^\n" + 
+			"continue cannot be used outside of a loop\n" + 
+			"----------\n");
 }
 public static Class testClass() {
 	return FlowAnalysisTest.class;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
index 3c59918..cc390d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -72,7 +72,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			targetContext.recordBreakFrom(flowInfo);
 			break;
 		}
-	} while ((traversedContext = traversedContext.parent) != null);
+	} while ((traversedContext = traversedContext.getLocalParent()) != null);
 
 	// resize subroutines
 	if (subCount != this.subroutines.length) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
index 1641bc5..475fef2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -75,7 +75,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			targetContext.recordContinueFrom(flowContext, flowInfo);
 			break;
 		}
-	} while ((traversedContext = traversedContext.parent) != null);
+	} while ((traversedContext = traversedContext.getLocalParent()) != null);
 
 	// resize subroutines
 	if (subCount != this.subroutines.length) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index f2b6010..520cf38 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -39,7 +39,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	// lookup the label, this should answer the returnContext
 
 	MethodScope methodScope = currentScope.methodScope();
-	AbstractMethodDeclaration referenceMethod = methodScope.referenceMethod();
 	if (this.expression != null) {
 		flowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);
 		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
@@ -99,9 +98,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				currentScope.problemReporter().cannotReturnInInitializer(this);
 				return FlowInfo.DEAD_END;
 		}
-		if (traversedContext.associatedNode == referenceMethod)
-			break; // don't traverse beyond the enclosing method (see https://bugs.eclipse.org/360328).
-	} while ((traversedContext = traversedContext.parent) != null);
+	} while ((traversedContext = traversedContext.getLocalParent()) != null);
 
 	// resize subroutines
 	if ((this.subroutines != null) && (subCount != this.subroutines.length)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 0590583..7f7638d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -70,12 +70,12 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 		// any reference reported at this level is removed from the parent context
 		// where it could also be reported again
 		if (complained) {
-			FlowContext currentContext = this.parent;
+			FlowContext currentContext = this.getLocalParent();
 			while (currentContext != null) {
 				//if (currentContext.isSubRoutine()) {
 				currentContext.removeFinalAssignmentIfAny(this.finalAssignments[i]);
 				//}
-				currentContext = currentContext.parent;
+				currentContext = currentContext.getLocalParent();
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 036b824..ccb5fb6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -12,9 +12,10 @@
 package org.eclipse.jdt.internal.compiler.flow;
 
 import java.util.ArrayList;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.LabeledStatement;
 import org.eclipse.jdt.internal.compiler.ast.Reference;
@@ -207,7 +208,7 @@ public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location
 				}
 			}
 		}
-		traversedContext = traversedContext.parent;
+		traversedContext = traversedContext.getLocalParent();
 	}
 	// if reaches this point, then there are some remaining unhandled exception types.
 	if (isExceptionOnAutoClose) {
@@ -353,7 +354,7 @@ public void checkExceptionHandlers(TypeBinding[] raisedExceptions, ASTNode locat
 				flowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits
 			}
 		}
-		traversedContext = traversedContext.parent;
+		traversedContext = traversedContext.getLocalParent();
 	}
 	// if reaches this point, then there are some remaining unhandled exception types.
 	nextReport: for (int i = 0; i < raisedCount; i++) {
@@ -385,9 +386,9 @@ public FlowInfo getInitsForFinalBlankInitializationCheck(TypeBinding declaringTy
 			current = initializationContext.initializationParent;
 		} else if (current instanceof ExceptionHandlingFlowContext) {
 			ExceptionHandlingFlowContext exceptionContext = (ExceptionHandlingFlowContext) current;
-			current = exceptionContext.initializationParent == null ? exceptionContext.parent : exceptionContext.initializationParent;
+			current = exceptionContext.initializationParent == null ? exceptionContext.getLocalParent() : exceptionContext.initializationParent;
 		} else {
-			current = current.parent;
+			current = current.getLocalParent();
 		}
 	} while (current != null);
 	// not found
@@ -411,7 +412,7 @@ public FlowContext getTargetContextForBreakLabel(char[] labelName) {
 				return current;
 			return lastNonReturningSubRoutine;
 		}
-		current = current.parent;
+		current = current.getLocalParent();
 	}
 	// not found
 	return null;
@@ -448,7 +449,7 @@ public FlowContext getTargetContextForContinueLabel(char[] labelName) {
 			// label is found, but not a continuable location
 			return FlowContext.NotContinuableContext;
 		}
-		current = current.parent;
+		current = current.getLocalParent();
 	}
 	// not found
 	return null;
@@ -467,7 +468,7 @@ public FlowContext getTargetContextForDefaultBreak() {
 			if (lastNonReturningSubRoutine == null) return current;
 			return lastNonReturningSubRoutine;
 		}
-		current = current.parent;
+		current = current.getLocalParent();
 	}
 	// not found
 	return null;
@@ -487,12 +488,22 @@ public FlowContext getTargetContextForDefaultContinue() {
 				return current;
 			return lastNonReturningSubRoutine;
 		}
-		current = current.parent;
+		current = current.getLocalParent();
 	}
 	// not found
 	return null;
 }
 
+/** 
+ * Answer the parent flow context but be careful not to cross the boundary of a nested type,
+ * or null if no such parent exists. 
+ */
+public FlowContext getLocalParent() {
+	if (this.associatedNode instanceof AbstractMethodDeclaration || this.associatedNode instanceof TypeDeclaration)
+		return null;
+	return this.parent;
+}
+
 public String individualToString() {
 	return "Flow context"; //$NON-NLS-1$
 }
@@ -570,7 +581,7 @@ public void recordSettingFinal(VariableBinding variable, Reference finalReferenc
 		if (!context.recordFinalAssignment(variable, finalReference)) {
 			break; // no need to keep going
 		}
-		context = context.parent;
+		context = context.getLocalParent();
 	}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LabelFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LabelFlowContext.java
index 3374313..88ca4e7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LabelFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LabelFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -31,14 +31,14 @@ public LabelFlowContext(FlowContext parent, ASTNode associatedNode, char[] label
 
 void checkLabelValidity(BlockScope scope) {
 	// check if label was already defined above
-	FlowContext current = this.parent;
+	FlowContext current = this.getLocalParent();
 	while (current != null) {
 		char[] currentLabelName;
 		if (((currentLabelName = current.labelName()) != null)
 			&& CharOperation.equals(currentLabelName, this.labelName)) {
 			scope.problemReporter().alreadyDefinedLabel(this.labelName, this.associatedNode);
 		}
-		current = current.parent;
+		current = current.getLocalParent();
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 886fea6..919bb4c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -112,10 +112,10 @@ public void complainOnDeferredFinalChecks(BlockScope scope, FlowInfo flowInfo) {
 		// any reference reported at this level is removed from the parent context where it
 		// could also be reported again
 		if (complained) {
-			FlowContext context = this.parent;
+			FlowContext context = this.getLocalParent();
 			while (context != null) {
 				context.removeFinalAssignmentIfAny(this.finalAssignments[i]);
-				context = context.parent;
+				context = context.getLocalParent();
 			}
 		}
 	}
@@ -396,6 +396,7 @@ public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo)
 		FlowContext inner = innerFlowContext;
 		while (inner != this && !(inner instanceof LoopingFlowContext)) {
 			inner = inner.parent;
+			// we know that inner is reachable from this without crossing a type boundary 
 		}
 		if (inner == this) {
 			this.upstreamNullFlowInfo.
commit 86113d82738e778f8e0f07729ab352d227a867ad
Author: Stephan Herrmann <sherrmann>
Date:   Tue Oct 18 12:33:51 2011 +0200

    HEAD - Doc-update: Fixed typo in JavaCore + updated buildnotes for:
    - Bug 360328: [compiler][null] detect null problems in nested code
    (local class inside a loop)
    - Bug 349326: [1.7] new warning for missing try-with-resources
    See also bug 359727: [1.7][doc] Update doc for new resource leak
    warnings

1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
85	3	org.eclipse.jdt.core/buildnotes_jdt-core.html
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index f359b25..d65919c 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -15,7 +15,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Compiler for Java(TM)
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.C16, 3.8.0 M3
+compiler.version = 0.C17, 3.8.0 M3
 compiler.copyright = Copyright IBM Corp 2000, 2011. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 0c6f504..9b14036 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -42,11 +42,24 @@
 	</td>
   </tr>
 </table>
+<a name="v_C17"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java development tools core</h1>
+Eclipse SDK 3.8.0 - %date% - 3.8.0 M3
+<br>Project org.eclipse.jdt.core v_C17
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C17">cvs</a>).
+<h2>What's new in this drop</h2>
+
+<h3>Problem Reports Fixed</h3>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=359727">359727</a>
+[1.7][doc] Update doc for new resource leak warnings
+
 <a name="v_C16"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java development tools core</h1>
-Eclipse SDK 3.8.0 - October 18, 2011 - 3.8.0 M3
+Eclipse SDK 3.8.0 - October 18, 2011
 <br>Project org.eclipse.jdt.core v_C16
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C16">cvs</a>).
 <h2>What's new in this drop</h2>
@@ -201,6 +214,8 @@ invokedynamic in generated class file is not correctly recognized by the eclipse
 Scope.isDefinedInSameUnit(ReferenceBinding) fails for a ParameterizedTypeBinding
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=358762">358762</a>
 NPE in JDT compiler
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=360328">360328</a>
+[compiler][null] detect null problems in nested code (local class inside a loop)
 
 <a name="v_C15"></a>
 <hr><h1>
@@ -216,8 +231,6 @@ Eclipse SDK 3.8.0 - October 11, 2011
 ASTRewrite destroys formatting on CatchClause#setBody(copyTarget)
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=353474">353474</a>
 type converters should include more annotations
-<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=360328">360328</a>
-[compiler][null] detect null problems in nested code (local class inside a loop)
 
 <a name="v_C14"></a>
 <hr><h1>
@@ -242,6 +255,75 @@ Eclipse SDK 3.8.0 - October 3, 2011
 <br>Project org.eclipse.jdt.core v_C13
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C13">cvs</a>).
 <h2>What's new in this drop</h2>
+<ul>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE to raise a warning or error
+  when a resource of type Closeable or AutoCloseable is not closed locally.  
+(see details in bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=349326">349326</a>):
+<pre>
+	/**
+	 * Compiler option ID: Reporting a resource that is not closed properly.
+	 *
+	 * When enabled, the compiler will issue an error or a warning if
+	 * a local variable holds a value of type <code>java.lang.AutoCloseable</code> (compliance>=1.7) 
+	 * or a value of type <code>java.io.Closeable</code> (compliance<=1.6) and if
+	 * flow analysis shows that the method <code>close()</code> is not invoked locally on that value.
+	 * 
+	 * Option id: <code>"org.eclipse.jdt.core.compiler.problem.reportUnclosedCloseable"</code>
+	 * Possible values: <code>{ "error", "warning", "ignore" }</code>
+	 * Default: <code>"warning"</code>
+	 *
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_UNCLOSED_CLOSEABLE = PLUGIN_ID + ".compiler.problem.unclosedCloseable"; //$NON-NLS-1$
+</pre>
+</li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE to raise a warning or error
+  when a resource of type Closeable or AutoCloseable is not definitely closed locally.
+(see details in bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=349326">349326</a>):
+<pre>
+	/**
+	 * Compiler option ID: Reporting a resource that may not be closed properly.
+	 * 
+	 * When enabled, the compiler will issue an error or a warning if
+	 * a local variable holds a value of type <code>java.lang.AutoCloseable</code> (compliance>=1.7) 
+	 * or a value of type <code>java.io.Closeable</code> (compliance<=1.6) and if
+	 * flow analysis shows that the method <code>close()</code> is 
+	 * not invoked locally on that value for all execution paths.
+	 * 
+	 * Option id: <code>"org.eclipse.jdt.core.compiler.problem.reportPotentiallyUnclosedCloseable"</code>
+	 * Possible values: <code>{ "error", "warning", "ignore" }</code>
+	 * Default: <code>"ignore"</code>
+	 * 
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE = PLUGIN_ID + ".compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
+</pre>
+</li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE to raise a warning or error
+  when a resource of type AutoCloseable is closed explicitly rather than using a try-with-resources block.
+(see details in bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=349326">349326</a>):
+<pre>
+	/**
+	 * Compiler option ID: Reporting a resource that is not managed by try-with-resources.
+	 * 
+	 * When enabled, the compiler will issue an error or a warning if a local variable 
+	 * holds a value of type <code>java.lang.AutoCloseable</code>, and if the method
+	 * <code>close()</code> is explicitly invoked on that resource, but the resource is
+	 * not managed by a try-with-resources block.
+	 * 
+	 * Option id: <code>"org.eclipse.jdt.core.compiler.problem.reportPotentiallyUnclosedCloseable"</code>
+	 * Possible values: <code>{ "error", "warning", "ignore" }</code>
+	 * Default: <code>"ignore"</code>
+	 * 
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE = PLUGIN_ID + ".compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+</pre>
+</li>
+</ul>
 
 <h3>Problem Reports Fixed</h3>
 <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=359495">359495</a>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index eb37a96..d1ab9d5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1362,7 +1362,7 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_POTENTIALLY_MISSING_STATIC_ON_METHOD = PLUGIN_ID + ".compiler.problem.reportMethodCanBePotentiallyStatic"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting a resource that is not closed properly.
-	 * <p>When enabled, that compiler will issue an error or a warning if
+	 * <p>When enabled, the compiler will issue an error or a warning if
 	 *    a local variable holds a value of type <code>java.lang.AutoCloseable</code> (compliance>=1.7) 
 	 *    or a value of type <code>java.io.Closeable</code> (compliance<=1.6) and if
 	 *    flow analysis shows that the method <code>close()</code> is not invoked locally on that value.
@@ -1377,7 +1377,7 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_UNCLOSED_CLOSEABLE = PLUGIN_ID + ".compiler.problem.unclosedCloseable"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting a resource that may not be closed properly.
-	 * <p>When enabled, that compiler will issue an error or a warning if
+	 * <p>When enabled, the compiler will issue an error or a warning if
 	 *    a local variable holds a value of type <code>java.lang.AutoCloseable</code> (compliance>=1.7) 
 	 *    or a value of type <code>java.io.Closeable</code> (compliance<=1.6) and if
 	 *    flow analysis shows that the method <code>close()</code> is 
@@ -1393,7 +1393,7 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE = PLUGIN_ID + ".compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting a resource that is not managed by try-with-resources.
-	 * <p>When enabled, that compiler will issue an error or a warning if a local variable 
+	 * <p>When enabled, the compiler will issue an error or a warning if a local variable 
 	 * 	  holds a value of type <code>java.lang.AutoCloseable</code>, and if the method
 	 *    <code>close()</code> is explicitly invoked on that resource, but the resource is
 	 *    not managed by a try-with-resources block.
