commit 2c4adf2736a9a7ce066a42070aabd3f4b1ddf5af
Author: Andrew Clement <aclement@gopivotal.com>
Date:   Thu Aug 8 08:58:07 2013 +0200

    Bug 407191 - [1.8] Binary access support for type annotations
    
    Signed-off-by: Andrew Clement <aclement@gopivotal.com>
    Bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=407191

513	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_8.java
5	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
43	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
87	44	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
11	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithAnnotation.java
54	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithTypeAnnotation.java
38	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
51	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
242	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryField.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
78	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryTypeAnnotation.java
14	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
10	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_8.java
new file mode 100644
index 0000000..7aca6c9
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest_1_8.java
@@ -0,0 +1,513 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *		Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *			Bug 407191 - [1.8] Binary access support for type annotations
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryField;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+
+public class ClassFileReaderTest_1_8 extends AbstractRegressionTest {
+	static {
+	}
+
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+	}
+	public static Class testClass() {
+		return ClassFileReaderTest_1_8.class;
+	}
+
+	public ClassFileReaderTest_1_8(String name) {
+		super(name);
+	}
+	
+	// Needed to run tests individually from JUnit
+	protected void setUp() throws Exception {
+		super.setUp();
+		this.complianceLevel = ClassFileConstants.JDK1_8;
+	}
+	
+	public void test001_classTypeParameter() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X<@Foo T1,@Bar(iii=99) T2> {}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int iii() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryTypeAnnotation[] typeAnnotations = classFileReader.getTypeAnnotations();
+		assertEquals(2,typeAnnotations.length);
+		
+		assertEquals("@LFoo; CLASS_TYPE_PARAMETER(type_parameter_index=0)", printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(iii=(int)99) CLASS_TYPE_PARAMETER(type_parameter_index=1)", printTypeAnnotation(typeAnnotations[1]));
+	}
+	
+	public void test001a_classTypeParameterDifferingRetentions() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X<@Foo T1,@Bar(iii=99) T2> {}\n" +
+			"@Retention(RetentionPolicy.RUNTIME)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int iii() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryTypeAnnotation[] typeAnnotations = classFileReader.getTypeAnnotations();
+		assertEquals(2,typeAnnotations.length);
+		
+		assertEquals("@LBar;(iii=(int)99) CLASS_TYPE_PARAMETER(type_parameter_index=1)", printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LFoo; CLASS_TYPE_PARAMETER(type_parameter_index=0)", printTypeAnnotation(typeAnnotations[1]));
+	}
+	
+	public void test002_methodTypeParameter() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X {\n" +
+			"	<@Foo T1, @Bar(3) T2> void foo(T1 t1,T2 t2) {}\n" + 
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(2,typeAnnotations.length);
+		assertEquals("@LFoo; METHOD_TYPE_PARAMETER(type_parameter_index=0)",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(value=(int)3) METHOD_TYPE_PARAMETER(type_parameter_index=1)",printTypeAnnotation(typeAnnotations[1]));
+	}
+	
+	public void test003_classExtends() throws Exception {
+		this.complianceLevel = ClassFileConstants.JDK1_8;
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X extends @Foo @Bar(iii=34) Object implements java.io.@Bar(iii=1) Serializable {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int iii() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryTypeAnnotation[] typeAnnotations = classFileReader.getTypeAnnotations();
+		assertEquals(3,typeAnnotations.length);
+		assertEquals("@LFoo; CLASS_EXTENDS(type_index=-1)", printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(iii=(int)34) CLASS_EXTENDS(type_index=-1)", printTypeAnnotation(typeAnnotations[1]));
+		assertEquals("@LBar;(iii=(int)1) CLASS_EXTENDS(type_index=0)", printTypeAnnotation(typeAnnotations[2]));
+	}
+
+	public void test004_classExtends() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X extends Y<@Foo String,@Bar Integer> implements I<@Foo String> {\n" +
+			"}\n" +
+			"class Y<T1, T2> {}\n" +
+			"interface I<T1> {}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int iii() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryTypeAnnotation[] typeAnnotations = classFileReader.getTypeAnnotations();
+		assertEquals(3,typeAnnotations.length);
+		assertEquals("@LFoo; CLASS_EXTENDS(type_index=-1), location=[TYPE_ARGUMENT(0)]", printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar; CLASS_EXTENDS(type_index=-1), location=[TYPE_ARGUMENT(1)]", printTypeAnnotation(typeAnnotations[1]));
+		assertEquals("@LFoo; CLASS_EXTENDS(type_index=0), location=[TYPE_ARGUMENT(0)]", printTypeAnnotation(typeAnnotations[2]));
+	}
+	
+	public void test005_classTypeParameterBound() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X<U, T extends Y<@Foo String @Bar(1)[][]@Bar(2)[]> & @Bar(3) Cloneable> {}\n" +
+			"class Y<T> {}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = getInternalClassFile("", "X", "X", source);
+		
+		IBinaryTypeAnnotation[] typeAnnotations = classFileReader.getTypeAnnotations();
+		assertEquals(4,typeAnnotations.length);
+		assertEquals("@LFoo; CLASS_TYPE_PARAMETER_BOUND(type_parameter_index=1, bound_index=0), location=[TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(value=(int)1) CLASS_TYPE_PARAMETER_BOUND(type_parameter_index=1, bound_index=0), location=[TYPE_ARGUMENT(0)]", printTypeAnnotation(typeAnnotations[1]));
+		assertEquals("@LBar;(value=(int)2) CLASS_TYPE_PARAMETER_BOUND(type_parameter_index=1, bound_index=0), location=[TYPE_ARGUMENT(0), ARRAY, ARRAY]", printTypeAnnotation(typeAnnotations[2]));
+		assertEquals("@LBar;(value=(int)3) CLASS_TYPE_PARAMETER_BOUND(type_parameter_index=1, bound_index=1)", printTypeAnnotation(typeAnnotations[3]));
+	}
+	
+	public void test006_methodTypeParameterBound() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"public class X{\n" +
+			"	<T extends Y<@Foo Z @Bar(1)[][]@Bar(2)[]> & @Bar(3) Cloneable> void foo(T t) {}\n" +
+			"}\n" +
+			"class Y<T> {}\n" +
+			"class Z {}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(4,typeAnnotations.length);
+		assertEquals("@LFoo; METHOD_TYPE_PARAMETER_BOUND(type_parameter_index=0, bound_index=0), location=[TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(value=(int)1) METHOD_TYPE_PARAMETER_BOUND(type_parameter_index=0, bound_index=0), location=[TYPE_ARGUMENT(0)]", printTypeAnnotation(typeAnnotations[1]));
+		assertEquals("@LBar;(value=(int)2) METHOD_TYPE_PARAMETER_BOUND(type_parameter_index=0, bound_index=0), location=[TYPE_ARGUMENT(0), ARRAY, ARRAY]", printTypeAnnotation(typeAnnotations[2]));
+		assertEquals("@LBar;(value=(int)3) METHOD_TYPE_PARAMETER_BOUND(type_parameter_index=0, bound_index=1)", printTypeAnnotation(typeAnnotations[3]));
+	}
+	
+	public void test007_field() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"import java.util.Map;\n" +
+			"public class X{\n" +
+			"	@Foo Map<@Bar(1) String, @Bar(2) String @Bar(3)[] @Bar(4)[] @Bar(5)[]> field3;\n" +
+			"}\n" +
+			"class Y<T> {}\n" +
+			"class Z {}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryField field = getField(cfr,"field3");
+		assertNotNull(field);
+		IBinaryTypeAnnotation[] typeAnnotations = field.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(6,typeAnnotations.length);
+		assertEquals("@LFoo; FIELD",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(value=(int)1) FIELD, location=[TYPE_ARGUMENT(0)]", printTypeAnnotation(typeAnnotations[1]));
+		assertEquals("@LBar;(value=(int)2) FIELD, location=[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", printTypeAnnotation(typeAnnotations[2]));
+		assertEquals("@LBar;(value=(int)3) FIELD, location=[TYPE_ARGUMENT(1)]", printTypeAnnotation(typeAnnotations[3]));
+		assertEquals("@LBar;(value=(int)4) FIELD, location=[TYPE_ARGUMENT(1), ARRAY]", printTypeAnnotation(typeAnnotations[4]));
+		assertEquals("@LBar;(value=(int)5) FIELD, location=[TYPE_ARGUMENT(1), ARRAY, ARRAY]", printTypeAnnotation(typeAnnotations[5]));
+	}
+	
+	public void test008_methodReturn() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"import java.util.Map;\n" +
+			"public class X{\n" +
+			"	@Bar(3) @Foo int foo() {\n" +
+			"		return 1;\n" +
+			"	}\n" + 
+			"	@Bar(3) int @Foo [] foo2() {\n" +
+			"		return null;\n" +
+			"	}\n" + 
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(2,typeAnnotations.length);
+		assertEquals("@LBar;(value=(int)3) METHOD_RETURN",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LFoo; METHOD_RETURN", printTypeAnnotation(typeAnnotations[1]));
+		
+		method = getMethod(cfr,"foo2");
+		assertNotNull(method);
+		typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(2,typeAnnotations.length);
+		assertEquals("@LBar;(value=(int)3) METHOD_RETURN, location=[ARRAY]",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LFoo; METHOD_RETURN", printTypeAnnotation(typeAnnotations[1]));
+	}
+	
+	public void test009_methodReceiver() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"import java.util.Map;\n" +
+			"public class X{\n" +
+			"	void foo(@Bar(3) X this) {}\n" + 
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(1,typeAnnotations.length);
+		assertEquals("@LBar;(value=(int)3) METHOD_RECEIVER", printTypeAnnotation(typeAnnotations[0]));
+	}
+	
+	public void test010_methodFormalParameter() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"import java.util.Map;\n" +
+			"public class X{\n" +
+			"	void foo(@Bar(3) String s, @Foo int i) {}\n" + 
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(2,typeAnnotations.length);
+		assertEquals("@LBar;(value=(int)3) METHOD_FORMAL_PARAMETER(method_formal_parameter_index=0)",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LFoo; METHOD_FORMAL_PARAMETER(method_formal_parameter_index=1)",printTypeAnnotation(typeAnnotations[1]));
+	}
+	
+	public void test011_throws() throws Exception {
+		String source =
+			"import java.lang.annotation.*;\n" +
+			"import java.util.Map;\n" +
+			"public class X{\n" +
+			"	void foo() throws @Foo Exception, @Bar(1) Throwable {}\n" + 
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Foo {\n" +
+			"}\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target(ElementType.TYPE_USE)\n" +
+			"@interface Bar {\n" +
+			"        int value() default -1;\n" +
+			"}";
+
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader cfr = getInternalClassFile("", "X", "X", source);
+
+		IBinaryMethod method = getMethod(cfr,"foo");
+		assertNotNull(method);
+		IBinaryTypeAnnotation[] typeAnnotations = method.getTypeAnnotations();
+		assertNotNull(typeAnnotations);
+		assertEquals(2,typeAnnotations.length);
+		assertEquals("@LFoo; THROWS(throws_type_index=0)",printTypeAnnotation(typeAnnotations[0]));
+		assertEquals("@LBar;(value=(int)1) THROWS(throws_type_index=1)",printTypeAnnotation(typeAnnotations[1]));
+	}
+
+	/**
+	 * Produce a nicely formatted type annotation for testing. Exercises the API for type annotations.
+	 * Output examples:<br>
+	 * <tt>@Foo(id=34) CLASS_EXTENDS, type_index=-1, location=[ARRAY, INNER_TYPE, TYPE_ARGUMENT(0)]</tt><br>
+	 */
+	private String printTypeAnnotation(IBinaryTypeAnnotation typeAnnotation) {
+		StringBuffer sb = new StringBuffer();
+		// The annotation:
+		IBinaryAnnotation annotation = typeAnnotation.getAnnotation();
+		sb.append('@').append(annotation.getTypeName());
+		IBinaryElementValuePair[] pairs = annotation.getElementValuePairs();
+		if (pairs.length != 0) {
+			sb.append('(');
+			for (int i = 0; i < pairs.length; i++) {
+				if (i > 0) {
+					sb.append(',');
+				}
+				sb.append(pairs[i].getName()).append('=').append(pairs[i].getValue());
+			}
+			sb.append(')');
+		}
+		sb.append(' ');
+		
+		// target type
+		int targetType = typeAnnotation.getTargetType();
+		switch (targetType) {
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER:
+				sb.append("CLASS_TYPE_PARAMETER(type_parameter_index=").append(typeAnnotation.getTypeParameterIndex()).append(')');
+				break;
+			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER:
+				sb.append("METHOD_TYPE_PARAMETER(type_parameter_index=").append(typeAnnotation.getTypeParameterIndex()).append(')');
+				break;
+			case AnnotationTargetTypeConstants.CLASS_EXTENDS:
+				sb.append("CLASS_EXTENDS(type_index=").append((short)typeAnnotation.getSupertypeIndex()).append(')');
+				break;
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND:
+				sb.append("CLASS_TYPE_PARAMETER_BOUND(type_parameter_index=").
+					append(typeAnnotation.getTypeParameterIndex()).
+					append(", bound_index=").append(typeAnnotation.getBoundIndex()).
+					append(')');
+				break;
+			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND:
+				sb.append("METHOD_TYPE_PARAMETER_BOUND(type_parameter_index=").
+					append(typeAnnotation.getTypeParameterIndex()).
+					append(", bound_index=").append(typeAnnotation.getBoundIndex()).
+					append(')');
+				break;
+			case AnnotationTargetTypeConstants.FIELD:
+				sb.append("FIELD");
+				break;
+			case AnnotationTargetTypeConstants.METHOD_RETURN:
+				sb.append("METHOD_RETURN");
+				break;
+			case AnnotationTargetTypeConstants.METHOD_RECEIVER:
+				sb.append("METHOD_RECEIVER");
+				break;
+			case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+				sb.append("METHOD_FORMAL_PARAMETER(method_formal_parameter_index=").
+					append(typeAnnotation.getMethodFormalParameterIndex()).append(')');
+				break;
+			case AnnotationTargetTypeConstants.THROWS :
+				sb.append("THROWS(throws_type_index=").
+					append(typeAnnotation.getThrowsTypeIndex()).append(')');
+				break;
+			default: throw new IllegalStateException("nyi "+targetType);
+		}
+		
+		// location
+		int[] typepath = typeAnnotation.getTypePath();
+		
+		if (typepath != IBinaryTypeAnnotation.NO_TYPE_PATH) {
+			sb.append(", location=["); //$NON-NLS-1$
+			for (int i = 0, max = typepath.length; i < max; i += 2) {
+				if (i > 0) {
+					sb.append(", "); //$NON-NLS-1$
+				}
+				switch (typepath[i]) {
+					case 0:
+						sb.append("ARRAY"); //$NON-NLS-1$
+						break;
+					case 1:
+						sb.append("INNER_TYPE"); //$NON-NLS-1$
+						break;
+					case 2:
+						sb.append("WILDCARD"); //$NON-NLS-1$
+						break;
+					case 3:
+						sb.append("TYPE_ARGUMENT(").append(typepath[i+1]).append(')'); //$NON-NLS-1$
+						break;
+				}
+			}
+			sb.append(']');
+		}
+		return sb.toString();
+	}
+
+	private IBinaryMethod getMethod(ClassFileReader cfr,String methodname) {
+		IBinaryMethod[] methods = cfr.getMethods();
+		if (methods == null) {
+			return null;
+		}
+		char[] methodnameAsCharArray = methodname.toCharArray();
+		for (int i = 0, max = methods.length; i < max; i++) {
+			if (CharOperation.equals(methods[i].getSelector(),methodnameAsCharArray)) {
+				return methods[i];
+			}
+		}
+		return null;
+	}
+
+	private IBinaryField getField(ClassFileReader cfr,String fieldname) {
+		IBinaryField[] fields = cfr.getFields();
+		if (fields == null) {
+			return null;
+		}
+		char[] fieldnameAsCharArray = fieldname.toCharArray();
+		for (int i = 0, max = fields.length; i < max; i++) {
+			if (CharOperation.equals(fields[i].getName(),fieldnameAsCharArray)) {
+				return fields[i];
+			}
+		}
+		return null;
+	}
+	
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 0c57269..f4386c6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -14,10 +14,11 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 358903 - Filter practically unimportant resource leak warnings
- *        Andy Clement - Contributions for
- *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *     		                Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *                          bug 407191 - [1.8] Binary access support for type annotations
  *       Jesper Steen Moeller - Contributions for:
- *                          Bug 406973 - [compiler] Parse MethodParameters attribute
+ *		                        Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -218,6 +219,7 @@ public static Test suite() {
 		tests_1_8.addAll(since_1_6);
 		tests_1_8.addAll(since_1_7);
 		tests_1_8.addAll(since_1_8);
+		tests_1_8.add(ClassFileReaderTest_1_8.class);
 		// Reset forgotten subsets tests
 		TestCase.TESTS_PREFIX = null;
 		TestCase.TESTS_NAMES = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index fa2fb0f..f63de5d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -1,13 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -32,6 +38,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private int classNameIndex;
 	private int constantPoolCount;
 	private AnnotationInfo[] annotations;
+	private TypeAnnotationInfo[] typeAnnotations;
 	private FieldInfo[] fields;
 	private int fieldsCount;
 
@@ -356,6 +363,10 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 						decodeAnnotations(readOffset, true);
 					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleAnnotationsName)) {
 						decodeAnnotations(readOffset, false);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleTypeAnnotationsName)) {
+						decodeTypeAnnotations(readOffset, true);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleTypeAnnotationsName)) {
+						decodeTypeAnnotations(readOffset, false);
 					}
 					break;
 				case 'M' :
@@ -434,6 +445,30 @@ private void decodeAnnotations(int offset, boolean runtimeVisible) {
 	}
 }
 
+private void decodeTypeAnnotations(int offset, boolean runtimeVisible) {
+	int numberOfAnnotations = u2At(offset + 6);
+	if (numberOfAnnotations > 0) {
+		int readOffset = offset + 8;
+		TypeAnnotationInfo[] newInfos = null;
+		newInfos = new TypeAnnotationInfo[numberOfAnnotations];
+		for (int i = 0; i < numberOfAnnotations; i++) {
+			// With the last parameter being 'false', the data structure will not be flushed out
+			TypeAnnotationInfo newInfo = new TypeAnnotationInfo(this.reference, this.constantPoolOffsets, readOffset, runtimeVisible, false);
+			readOffset += newInfo.readOffset;
+			newInfos[i] = newInfo;
+		}
+		if (this.typeAnnotations == null) {
+			this.typeAnnotations = newInfos;
+		} else {
+			int length = this.typeAnnotations.length;
+			TypeAnnotationInfo[] temp = new TypeAnnotationInfo[length + numberOfAnnotations];
+			System.arraycopy(this.typeAnnotations, 0, temp, 0, length);
+			System.arraycopy(newInfos, 0, temp, length, numberOfAnnotations);
+			this.typeAnnotations = temp;
+		}
+	}
+}
+
 /**
  * @return the annotations or null if there is none.
  */
@@ -442,6 +477,13 @@ public IBinaryAnnotation[] getAnnotations() {
 }
 
 /**
+ * @return the type annotations or null if there is none.
+ */
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return this.typeAnnotations;
+}
+
+/**
  * Answer the char array that corresponds to the class name of the constant class.
  * constantPoolIndex is the index in the constant pool that is a constant class entry.
  *
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
index 8eaea09..f03e5d6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
@@ -1,12 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *          Bug 407191 - [1.8] Binary access support for type annotations 
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -14,6 +20,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryField;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.impl.*;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.util.Util;
@@ -31,10 +38,65 @@ public class FieldInfo extends ClassFileStruct implements IBinaryField, Comparab
 
 public static FieldInfo createField(byte classFileBytes[], int offsets[], int offset) {
 	FieldInfo fieldInfo = new FieldInfo(classFileBytes, offsets, offset);
-	AnnotationInfo[] annotations = fieldInfo.readAttributes();
-	if (annotations == null)
-		return fieldInfo;
-	return new FieldInfoWithAnnotation(fieldInfo, annotations);
+	
+	int attributesCount = fieldInfo.u2At(6);
+	int readOffset = 8;
+	AnnotationInfo[] annotations = null;
+	TypeAnnotationInfo[] typeAnnotations = null;
+	for (int i = 0; i < attributesCount; i++) {
+		// check the name of each attribute
+		int utf8Offset = fieldInfo.constantPoolOffsets[fieldInfo.u2At(readOffset)] - fieldInfo.structOffset;
+		char[] attributeName = fieldInfo.utf8At(utf8Offset + 3, fieldInfo.u2At(utf8Offset + 1));
+		if (attributeName.length > 0) {
+			switch(attributeName[0]) {
+				case 'S' :
+					if (CharOperation.equals(AttributeNamesConstants.SignatureName, attributeName))
+						fieldInfo.signatureUtf8Offset = fieldInfo.constantPoolOffsets[fieldInfo.u2At(readOffset + 6)] - fieldInfo.structOffset;
+					break;
+				case 'R' :
+					AnnotationInfo[] decodedAnnotations = null;
+					TypeAnnotationInfo[] decodedTypeAnnotations = null;
+					if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleAnnotationsName)) {
+						decodedAnnotations = fieldInfo.decodeAnnotations(readOffset, true);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleAnnotationsName)) {
+						decodedAnnotations = fieldInfo.decodeAnnotations(readOffset, false);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleTypeAnnotationsName)) {
+						decodedTypeAnnotations = fieldInfo.decodeTypeAnnotations(readOffset, true);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleTypeAnnotationsName)) {
+						decodedTypeAnnotations = fieldInfo.decodeTypeAnnotations(readOffset, false);
+					}
+					if (decodedAnnotations != null) {
+						if (annotations == null) {
+							annotations = decodedAnnotations;
+						} else {
+							int length = annotations.length;
+							AnnotationInfo[] combined = new AnnotationInfo[length + decodedAnnotations.length];
+							System.arraycopy(annotations, 0, combined, 0, length);
+							System.arraycopy(decodedAnnotations, 0, combined, length, decodedAnnotations.length);
+							annotations = combined;
+						}
+					} else if (decodedTypeAnnotations != null) {
+						if (typeAnnotations == null) {
+							typeAnnotations = decodedTypeAnnotations;
+						} else {
+							int length = typeAnnotations.length;
+							TypeAnnotationInfo[] combined = new TypeAnnotationInfo[length + decodedTypeAnnotations.length];
+							System.arraycopy(typeAnnotations, 0, combined, 0, length);
+							System.arraycopy(decodedTypeAnnotations, 0, combined, length, decodedTypeAnnotations.length);
+							typeAnnotations = combined;
+						}
+					}
+			}
+		}
+		readOffset += (6 + fieldInfo.u4At(readOffset + 2));
+	}
+	fieldInfo.attributeBytes = readOffset;
+	
+	if (typeAnnotations != null)
+		return new FieldInfoWithTypeAnnotation(fieldInfo, annotations, typeAnnotations);
+	if (annotations != null)
+		return new FieldInfoWithAnnotation(fieldInfo, annotations);
+	return fieldInfo;
 }
 
 /**
@@ -75,6 +137,22 @@ private AnnotationInfo[] decodeAnnotations(int offset, boolean runtimeVisible) {
 	}
 	return null; // nothing to record
 }
+
+TypeAnnotationInfo[] decodeTypeAnnotations(int offset, boolean runtimeVisible) {
+	int numberOfAnnotations = u2At(offset + 6);
+	if (numberOfAnnotations > 0) {
+		int readOffset = offset + 8;
+		TypeAnnotationInfo[] typeAnnos = new TypeAnnotationInfo[numberOfAnnotations];
+		for (int i = 0; i < numberOfAnnotations; i++) {
+			TypeAnnotationInfo newInfo = new TypeAnnotationInfo(this.reference, this.constantPoolOffsets, readOffset + this.structOffset, runtimeVisible, false);
+			readOffset += newInfo.readOffset;
+			typeAnnos[i] = newInfo;
+		}
+		return typeAnnos;
+	}
+	return null;
+}
+
 public int compareTo(Object o) {
 	return new String(getName()).compareTo(new String(((FieldInfo) o).getName()));
 }
@@ -163,6 +241,10 @@ public char[] getTypeName() {
 public IBinaryAnnotation[] getAnnotations() {
 	return null;
 }
+
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return null;
+}
 /**
  * Return a wrapper that contains the constant of the field.
  * @return java.lang.Object
@@ -230,45 +312,6 @@ protected void initialize() {
 public boolean isSynthetic() {
 	return (getModifiers() & ClassFileConstants.AccSynthetic) != 0;
 }
-private AnnotationInfo[] readAttributes() {
-	int attributesCount = u2At(6);
-	int readOffset = 8;
-	AnnotationInfo[] annotations = null;
-	for (int i = 0; i < attributesCount; i++) {
-		// check the name of each attribute
-		int utf8Offset = this.constantPoolOffsets[u2At(readOffset)] - this.structOffset;
-		char[] attributeName = utf8At(utf8Offset + 3, u2At(utf8Offset + 1));
-		if (attributeName.length > 0) {
-			switch(attributeName[0]) {
-				case 'S' :
-					if (CharOperation.equals(AttributeNamesConstants.SignatureName, attributeName))
-						this.signatureUtf8Offset = this.constantPoolOffsets[u2At(readOffset + 6)] - this.structOffset;
-					break;
-				case 'R' :
-					AnnotationInfo[] decodedAnnotations = null;
-					if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleAnnotationsName)) {
-						decodedAnnotations = decodeAnnotations(readOffset, true);
-					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleAnnotationsName)) {
-						decodedAnnotations = decodeAnnotations(readOffset, false);
-					}
-					if (decodedAnnotations != null) {
-						if (annotations == null) {
-							annotations = decodedAnnotations;
-						} else {
-							int length = annotations.length;
-							AnnotationInfo[] combined = new AnnotationInfo[length + decodedAnnotations.length];
-							System.arraycopy(annotations, 0, combined, 0, length);
-							System.arraycopy(decodedAnnotations, 0, combined, length, decodedAnnotations.length);
-							annotations = combined;
-						}
-					}
-			}
-		}
-		readOffset += (6 + u4At(readOffset + 2));
-	}
-	this.attributeBytes = readOffset;
-	return annotations;
-}
 private void readConstantAttribute() {
 	int attributesCount = u2At(6);
 	int readOffset = 8;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithAnnotation.java
index 4e3c435..6bfbaaa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithAnnotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithAnnotation.java
@@ -1,16 +1,22 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 BEA Systems, Inc.
+ * Copyright (c) 2005, 2013 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *          Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
-public final class FieldInfoWithAnnotation extends FieldInfo {
+public class FieldInfoWithAnnotation extends FieldInfo {
 	private AnnotationInfo[] annotations;
 
 FieldInfoWithAnnotation(FieldInfo info, AnnotationInfo[] annos) {
@@ -31,8 +37,9 @@ public org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation[] getAnnotations(
 	return this.annotations;
 }
 protected void initialize() {
-	for (int i = 0, max = this.annotations.length; i < max; i++)
-		this.annotations[i].initialize();
+	if (this.annotations != null)
+		for (int i = 0, max = this.annotations.length; i < max; i++)
+			this.annotations[i].initialize();
 	super.initialize();
 }
 protected void reset() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithTypeAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithTypeAnnotation.java
new file mode 100644
index 0000000..f80085d
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfoWithTypeAnnotation.java
@@ -0,0 +1,54 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *          Bug 407191 - [1.8] Binary access support for type annotations
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+
+public final class FieldInfoWithTypeAnnotation extends FieldInfoWithAnnotation {
+	private TypeAnnotationInfo[] typeAnnotations;
+
+FieldInfoWithTypeAnnotation(FieldInfo info, AnnotationInfo[] annos, TypeAnnotationInfo[] typeAnnos) {
+	super(info, annos);
+	this.typeAnnotations = typeAnnos;
+}
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return this.typeAnnotations;
+}
+protected void initialize() {
+	for (int i = 0, max = this.typeAnnotations.length; i < max; i++)
+		this.typeAnnotations[i].initialize();
+	super.initialize();
+}
+protected void reset() {
+	if (this.typeAnnotations != null)
+		for (int i = 0, max = this.typeAnnotations.length; i < max; i++)
+			this.typeAnnotations[i].reset();
+	super.reset();
+}
+public String toString() {
+	StringBuffer buffer = new StringBuffer(getClass().getName());
+	if (this.typeAnnotations != null) {
+		buffer.append('\n');
+		buffer.append("type annotations:"); //$NON-NLS-1$
+		for (int i = 0; i < this.typeAnnotations.length; i++) {
+			buffer.append(this.typeAnnotations[i]);
+			buffer.append('\n');
+		}
+	}
+	toStringContent(buffer);
+	return buffer.toString();
+}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
index bbe5654..1b9ee47 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
@@ -8,12 +8,13 @@
  * This is an implementation of an early-draft specification developed under the Java
  * Community Process (JCP) and is made available for testing and evaluation purposes
  * only. The code is not compatible with any specification of the JCP.
- * 
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *     Jesper Steen Moeller - Contribution for bug 406973 - [compiler] Parse MethodParameters attribute
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -22,6 +23,7 @@ import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class MethodInfo extends ClassFileStruct implements IBinaryMethod, Comparable {
@@ -44,6 +46,7 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 	int readOffset = 8;
 	AnnotationInfo[] annotations = null;
 	AnnotationInfo[][] parameterAnnotations = null;
+	TypeAnnotationInfo[] typeAnnotations = null;
 	for (int i = 0; i < attributesCount; i++) {
 		// check the name of each attribute
 		int utf8Offset = methodInfo.constantPoolOffsets[methodInfo.u2At(readOffset)] - methodInfo.structOffset;
@@ -62,6 +65,7 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 				case 'R' :
 					AnnotationInfo[] methodAnnotations = null;
 					AnnotationInfo[][] paramAnnotations = null;
+					TypeAnnotationInfo[] methodTypeAnnotations = null;
 					if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleAnnotationsName)) {
 						methodAnnotations = decodeMethodAnnotations(readOffset, true, methodInfo);
 					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleAnnotationsName)) {
@@ -70,6 +74,10 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 						paramAnnotations = decodeParamAnnotations(readOffset, true, methodInfo);
 					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleParameterAnnotationsName)) {
 						paramAnnotations = decodeParamAnnotations(readOffset, false, methodInfo);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeVisibleTypeAnnotationsName)) {
+						methodTypeAnnotations = decodeTypeAnnotations(readOffset, true, methodInfo);
+					} else if (CharOperation.equals(attributeName, AttributeNamesConstants.RuntimeInvisibleTypeAnnotationsName)) {
+						methodTypeAnnotations = decodeTypeAnnotations(readOffset, false, methodInfo);
 					}
 					if (methodAnnotations != null) {
 						if (annotations == null) {
@@ -101,6 +109,16 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 								}
 							}
 						}
+					} else if (methodTypeAnnotations != null) {
+						if (typeAnnotations == null) {
+							typeAnnotations = methodTypeAnnotations;
+						} else {
+							int length = typeAnnotations.length;
+							TypeAnnotationInfo[] newAnnotations = new TypeAnnotationInfo[length + methodTypeAnnotations.length];
+							System.arraycopy(typeAnnotations, 0, newAnnotations, 0, length);
+							System.arraycopy(methodTypeAnnotations, 0, newAnnotations, length, methodTypeAnnotations.length);
+							typeAnnotations = newAnnotations;
+						}
 					}
 					break;
 			}
@@ -109,6 +127,8 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 	}
 	methodInfo.attributeBytes = readOffset;
 
+	if (typeAnnotations != null)
+		return new MethodInfoWithTypeAnnotations(methodInfo, annotations, parameterAnnotations, typeAnnotations);
 	if (parameterAnnotations != null)
 		return new MethodInfoWithParameterAnnotations(methodInfo, annotations, parameterAnnotations);
 	if (annotations != null)
@@ -157,6 +177,20 @@ static AnnotationInfo[] decodeMethodAnnotations(int offset, boolean runtimeVisib
 	}
 	return null;
 }
+static TypeAnnotationInfo[] decodeTypeAnnotations(int offset, boolean runtimeVisible, MethodInfo methodInfo) {
+	int numberOfAnnotations = methodInfo.u2At(offset + 6);
+	if (numberOfAnnotations > 0) {
+		int readOffset = offset + 8;
+		TypeAnnotationInfo[] typeAnnos = new TypeAnnotationInfo[numberOfAnnotations];
+		for (int i = 0; i < numberOfAnnotations; i++) {
+			TypeAnnotationInfo newInfo = new TypeAnnotationInfo(methodInfo.reference, methodInfo.constantPoolOffsets, readOffset + methodInfo.structOffset, runtimeVisible, false);
+			readOffset += newInfo.readOffset;
+			typeAnnos[i] = newInfo;
+		}
+		return typeAnnos;
+	}
+	return null;
+}
 static AnnotationInfo[][] decodeParamAnnotations(int offset, boolean runtimeVisible, MethodInfo methodInfo) {
 	AnnotationInfo[][] allParamAnnotations = null;
 	int numberOfParameters = methodInfo.u1At(offset + 6);
@@ -285,6 +319,9 @@ public IBinaryAnnotation[] getParameterAnnotations(int index) {
 public int getAnnotatedParametersCount() {
 	return 0;
 }
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return null;
+}
 /**
  * Answer the name of the method.
  *
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
new file mode 100644
index 0000000..a79a1e4
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithTypeAnnotations.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *            Bug 407191 - [1.8] Binary access support for type annotations
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+
+class MethodInfoWithTypeAnnotations extends MethodInfoWithParameterAnnotations {
+	private TypeAnnotationInfo[] typeAnnotations;
+
+MethodInfoWithTypeAnnotations(MethodInfo methodInfo, AnnotationInfo[] annotations, AnnotationInfo[][] parameterAnnotations, TypeAnnotationInfo[] typeAnnotations) {
+	super(methodInfo, annotations, parameterAnnotations);
+	this.typeAnnotations = typeAnnotations;
+}
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return this.typeAnnotations;
+}
+
+protected void initialize() {
+	for (int i = 0, l = this.typeAnnotations == null ? 0 : this.typeAnnotations.length; i < l; i++) {
+		this.typeAnnotations[i].initialize();
+	}
+	super.initialize();
+}
+protected void reset() {
+	for (int i = 0, l = this.typeAnnotations == null ? 0 : this.typeAnnotations.length; i < l; i++) {
+		this.typeAnnotations[i].reset();
+	}
+	super.reset();
+}
+protected void toStringContent(StringBuffer buffer) {
+	super.toStringContent(buffer);
+	buffer.append("type annotations = \n");//$NON-NLS-1$
+	for (int i = 0, l = this.typeAnnotations == null ? 0 : this.typeAnnotations.length; i < l; i++) {
+		buffer.append(this.typeAnnotations[i].toString());
+		buffer.append('\n');
+	}
+}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
new file mode 100644
index 0000000..2ccd75e
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationInfo.java
@@ -0,0 +1,242 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *          Bug 407191 - [1.8] Binary access support for type annotations
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import java.util.Arrays;
+
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+
+/**
+ * The TypeAnnotationInfo class does not currently support type annotations within code
+ * blocks (those that have a target type of 0x40 and higher) - it is not yet clear that 
+ * these need to be accessible.
+ */
+public class TypeAnnotationInfo extends ClassFileStruct implements IBinaryTypeAnnotation {
+
+	private AnnotationInfo annotation;
+	
+	private int targetType = 0;
+	
+	// info is used in different ways:
+	// TargetType 0x00: CLASS_TYPE_PARAMETER: type parameter index
+	// TargetType 0x01: METHOD_TYPE_PARAMETER: type parameter index 
+	// TargetType 0x10: CLASS_EXTENDS: supertype index (-1 = superclass, 0..N superinterface)
+	// TargetType 0x11: CLASS_TYPE_PARAMETER_BOUND: type parameter index
+	// TargetType 0x12: METHOD_TYPE_PARAMETER_BOUND: type parameter index
+	// TargetType 0x16: METHOD_FORMAL_PARAMETER: method formal parameter index
+	// TargetType 0x17: THROWS: throws type index
+	private int info;
+	
+	// TargetType 0x11: CLASS_TYPE_PARAMETER_BOUND: bound index
+	// TargetType 0x12: METHOD_TYPE_PARAMETER_BOUND: bound index
+	private int info2;
+	
+	private int[] typePath; // each pair of ints in the array is a type path entry
+	
+	int readOffset = 0;
+	
+	
+TypeAnnotationInfo(byte[] classFileBytes, int[] contantPoolOffsets, int offset) {
+	super(classFileBytes, contantPoolOffsets, offset);
+}
+	
+TypeAnnotationInfo(byte[] classFileBytes, int[] contantPoolOffsets, int offset, boolean runtimeVisible, boolean populate) {
+	this(classFileBytes, contantPoolOffsets, offset);
+	this.readOffset = 0;
+	this.targetType = u1At(0);
+	switch (this.targetType) {
+		case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER:
+		case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER:
+			this.info = u1At(1); // typeParameterIndex
+			this.readOffset += 2;
+			break;
+			
+		case AnnotationTargetTypeConstants.CLASS_EXTENDS:
+			this.info = u2At(1); // supertypeIndex
+			this.readOffset += 3;
+			break;
+			
+		case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND:
+		case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND:
+			this.info = u1At(1); // typeParameterIndex
+			this.info2 = u1At(2); // boundIndex;
+			this.readOffset += 3;
+			break;
+			
+		case AnnotationTargetTypeConstants.FIELD:
+		case AnnotationTargetTypeConstants.METHOD_RETURN:
+		case AnnotationTargetTypeConstants.METHOD_RECEIVER:
+			this.readOffset ++;
+			break;
+			
+		case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+			this.info = u1At(1); // methodFormalParameterIndex
+			this.readOffset += 2;
+			break;
+			
+		case AnnotationTargetTypeConstants.THROWS :
+			this.info = u2At(1); // throwsTypeIndex
+			this.readOffset += 3;
+			break;
+
+		default:
+			throw new IllegalStateException("Target type not handled "+this.targetType); //$NON-NLS-1$
+	}
+	int typePathLength = u1At(this.readOffset);
+	this.readOffset ++;
+	if (typePathLength == 0) {
+		this.typePath = NO_TYPE_PATH;
+	} else {
+		this.typePath = new int[typePathLength*2];
+		int index = 0;
+		for (int i = 0; i < typePathLength; i++) {
+			this.typePath[index++] = u1At(this.readOffset++); // entry kind
+			this.typePath[index++] = u1At(this.readOffset++); // type argument index
+		}
+	}
+	this.annotation = new AnnotationInfo(classFileBytes, this.constantPoolOffsets, this.structOffset + this.readOffset, runtimeVisible, populate);
+	this.readOffset += this.annotation.readOffset;
+}
+
+public IBinaryAnnotation getAnnotation() {
+	return this.annotation;
+}
+
+protected void initialize() {
+	this.annotation.initialize();
+}
+
+protected void reset() {
+	this.annotation.reset();
+	super.reset();
+}
+
+public String toString() {
+	StringBuffer buffer = new StringBuffer();
+	buffer.append(this.annotation);
+	buffer.append(' ');
+	// Not fully decoding it here, just including all the information in the string
+	buffer.append("target_type=").append(this.targetType); //$NON-NLS-1$
+	buffer.append(", info=").append(this.info); //$NON-NLS-1$
+	buffer.append(", info2=").append(this.info2); //$NON-NLS-1$
+	if (this.typePath != NO_TYPE_PATH) {
+		buffer.append(", location=["); //$NON-NLS-1$
+		for (int i = 0, max = this.typePath.length; i < max; i += 2) {
+			if (i > 0) {
+				buffer.append(", "); //$NON-NLS-1$
+			}
+			switch (this.typePath[i]) {
+				case 0:
+					buffer.append("ARRAY"); //$NON-NLS-1$
+					break;
+				case 1:
+					buffer.append("INNER_TYPE"); //$NON-NLS-1$
+					break;
+				case 2:
+					buffer.append("WILDCARD"); //$NON-NLS-1$
+					break;
+				case 3:
+					buffer.append("TYPE_ARGUMENT(").append(this.typePath[i+1]).append(')'); //$NON-NLS-1$
+					break;
+			}
+		}
+		buffer.append(']');
+	}
+	return buffer.toString();
+}
+
+
+public int getTargetType() {
+	return this.targetType;
+}
+
+public int getSupertypeIndex() {
+	// assert this.targetType == 0x10
+	return this.info;
+}
+
+public int getTypeParameterIndex() {
+	// assert this.targetType == 0x00 or 0x01
+	return this.info;
+}
+
+public int getBoundIndex() {
+	// assert this.targetType == 0x11 or 0x12
+	return this.info2;
+}
+
+public int getMethodFormalParameterIndex() {
+	// assert this.targetType == 0x16
+	return this.info;
+}
+
+public int getThrowsTypeIndex() {
+	// assert this.targetType == 0x17
+	return this.info;
+}
+
+public int[] getTypePath() {
+	return this.typePath;
+}
+
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + this.targetType;
+	result = prime * result + this.info;
+	result = prime * result + this.info2;
+	if (this.typePath != null) {
+		for (int i = 0, max = this.typePath.length; i < max; i++) {
+			result = prime * result + this.typePath[i];
+		}
+	}
+	return result;
+}
+
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+
+	TypeAnnotationInfo other = (TypeAnnotationInfo) obj;
+
+	if (this.targetType != other.targetType) {
+		return false;
+	}
+	
+	if (this.info != other.info) {
+		return false;
+	}
+
+	if (this.info2 != other.info2) {
+		return false;
+	}
+	
+	if (!Arrays.equals(this.typePath, other.typePath)) {
+		return false;
+	}
+	
+	return this.annotation.equals(other.annotation);
+}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryField.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryField.java
index 4e9b566..e22bf69 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryField.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryField.java
@@ -1,12 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
@@ -19,6 +25,11 @@ public interface IBinaryField extends IGenericField {
 IBinaryAnnotation[] getAnnotations();
 
 /**
+ * Answer the runtime visible and invisible type annotations for this field or null if none.
+ */
+IBinaryTypeAnnotation[] getTypeAnnotations();
+
+/**
  *
  * @return org.eclipse.jdt.internal.compiler.Constant
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
index 177ae24..be7aa90 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
@@ -1,13 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
@@ -89,4 +95,9 @@ long getTagBits();
  * Answer whether the receiver represents a class initializer method.
  */
 boolean isClinit();
+
+/**
+ * Answer the type annotations on this method.
+ */
+IBinaryTypeAnnotation[] getTypeAnnotations();
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
index 7424325..2cf3efa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
@@ -23,6 +25,13 @@ public interface IBinaryType extends IGenericType {
  */
 
 IBinaryAnnotation[] getAnnotations();
+
+/**
+ * Answer the runtime visible and invisible type annotations for this type or null if none.
+ */
+
+IBinaryTypeAnnotation[] getTypeAnnotations();
+
 /**
  * Answer the enclosing method (including method selector and method descriptor), or
  * null if none.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryTypeAnnotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryTypeAnnotation.java
new file mode 100644
index 0000000..c0595b2
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryTypeAnnotation.java
@@ -0,0 +1,78 @@
+/*******************************************************************************
+ * Copyright (c) 2013 GoPivotal, Inc. All Rights Reserved.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *          Bug 407191 - [1.8] Binary access support for type annotations
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.env;
+
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
+
+/**
+ * This represents class file information about an annotation instance.
+ */
+public interface IBinaryTypeAnnotation {
+	
+	static int[] NO_TYPE_PATH = new int[0];
+
+/**
+ * @return the annotation
+ */
+IBinaryAnnotation getAnnotation();
+
+/**
+ * @return the target type, according to the constants in {@link AnnotationTargetTypeConstants}
+ */
+int getTargetType();
+
+/**
+ * 
+ * @return the raw type path data, each pair of ints is a type path entry
+ */
+int[] getTypePath();
+
+/**
+ * Applicable for target type 0x10(CLASS_EXTENDS)
+ * 
+ * @return the supertype index. -1 (65535) for superclass, 0..n for superinterfaces
+ */
+int getSupertypeIndex();
+
+/**
+ * Applicable for target type 0x00(CLASS_TYPE_PARAMETER), 0x01(METHOD_TYPE_PARAMETER)
+ * 
+ * @return the type parameter index (0 based)
+ */
+int getTypeParameterIndex();
+
+/**
+ * Applicable for target type 0x11(CLASS_TYPE_PARAMETER_BOUND), 0x12(METHOD_TYPE_PARAMETER_BOUND)
+ * 
+ * @return the bound index
+ */
+int getBoundIndex();
+
+/**
+ * Applicable for target type 0x16(METHOD_FORMAL_PARAMETER)
+ * 
+ * @return the method formal parameter index
+ */
+int getMethodFormalParameterIndex();
+
+/**
+ * Applicable for target type 0x17(THROWS)
+ * 
+ * @return the throws type index
+ */
+int getThrowsTypeIndex();
+
+}
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index f0090b1..c23589d 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -1,13 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -20,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -68,6 +75,9 @@ public class CodeSnippetSkeleton implements IBinaryType, EvaluationConstants {
 		public int getAnnotatedParametersCount() {
 			return 0;
 		}
+		public IBinaryTypeAnnotation[] getTypeAnnotations() {
+			return null; 
+		}
 		public char[] getSelector() {
 			return this.selector;
 		}
@@ -112,6 +122,9 @@ public CodeSnippetSkeleton() {
 public IBinaryAnnotation[] getAnnotations() {
 	return null;
 }
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return null; 
+}
 public char[] getEnclosingMethod() {
 	return null;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index b90fa25..a0ea864 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *         bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.hierarchy;
 
@@ -19,6 +21,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;
 
 public class HierarchyBinaryType implements IBinaryType {
@@ -51,6 +54,12 @@ public HierarchyBinaryType(int modifiers, char[] qualification, char[] sourceNam
 public IBinaryAnnotation[] getAnnotations() {
 	return null;
 }
+/**
+ * @see org.eclipse.jdt.internal.compiler.env.IBinaryType
+ */
+public IBinaryTypeAnnotation[] getTypeAnnotations() {
+	return null;
+}
 public char[] getEnclosingMethod() {
 	return null;
 }
