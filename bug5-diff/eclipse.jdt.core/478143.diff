commit 12825866d75439e3f74d81246a4ee0c748270ebd
Author: manoj <manpalat@in.ibm.com>
Date:   Wed Sep 30 13:45:00 2015 +0530

    part fix for bug 478143 -[1.9][search] non java.base module types are
    not found in open type

3	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 23aa6ad..1126a3d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -76,6 +76,7 @@ import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.JavaProject;
 import org.eclipse.jdt.internal.core.LambdaFactory;
 import org.eclipse.jdt.internal.core.LocalVariable;
+import org.eclipse.jdt.internal.core.ModulePackageFragmentRoot;
 import org.eclipse.jdt.internal.core.NameLookup;
 import org.eclipse.jdt.internal.core.Openable;
 import org.eclipse.jdt.internal.core.PackageFragment;
@@ -258,7 +259,8 @@ public static ClassFileReader classFileReader(IType type) {
 		if (org.eclipse.jdt.internal.compiler.util.Util.archiveFormat(rootPath) == org.eclipse.jdt.internal.compiler.util.Util.JIMAGE_FILE) {
 			String classFileName = classFile.getElementName();
 			String path = Util.concatWith(pkg.names, classFileName, '/');
-			return ClassFileReader.readFromJimage(new File(rootPath), rootPath, path);
+			String module = root.isModule() ? ((ModulePackageFragmentRoot) root).getElementName() : null;
+			return ClassFileReader.readFromJimage(new File(rootPath), path, module);
 		} else {
 			ZipFile zipFile = null;
 			try {
commit 6b8f4e4e8de49124d87e0699e016b5f8e7ecbd15
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Sun Oct 4 19:58:41 2015 +0530

    Fix for Bug 478143 [1.9][search] non java.base module types are not
    found in open type

11	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
6	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
9	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
25	9	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
13	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
7	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
8	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
36	14	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
81	37	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
index 6c8714e..5e0264a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -112,6 +116,8 @@ protected void setUp() throws Exception {
 			"}\n"
 		);
 	}
+	waitUntilIndexesReady();
+
 }
 
 /* (non-Javadoc)
@@ -1138,6 +1144,8 @@ public void testFindSecondaryType_Bug72179() throws JavaModelException, CoreExce
 			"	jc008 a;\n" +
 			"}\n"
 		);
+		waitUntilIndexesReady();
+
 		IType type = javaProject.findType("p1", "jc008", new NullProgressMonitor());
 		assertTrue("type 'jc008' should exist!", type != null && type.exists());
 		assertEquals("Expected type 'jc008' NOT found!",
@@ -1322,6 +1330,8 @@ public void testBug306477() throws Exception {
 			"}\n"
 		);
 		
+		waitUntilIndexesReady();
+
 		// find secondary enum
 		IType type = project.findType("p.Bob", new NullProgressMonitor());
 		assertElementEquals("We should have found the secondary enum 'Bob'!",
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
index 43ca37e..fd7acde 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -46,7 +50,7 @@ private int bufferIndex, bufferEnd; // used when reading from the file into the
 private int streamEnd; // used when writing data from the streamBuffer to the file
 char separator = Index.DEFAULT_SEPARATOR;
 
-public static final String SIGNATURE= "INDEX VERSION 1.127"; //$NON-NLS-1$
+public static final String SIGNATURE= "INDEX VERSION 1.128"; //$NON-NLS-1$
 private static final char[] SIGNATURE_CHARS = SIGNATURE.toCharArray();
 public static boolean DEBUG = false;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
index 79010cb..8f052ab 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java
@@ -9,6 +9,10 @@
  * Community Process (JCP) and is made available for testing and evaluation purposes
  * only. The code is not compatible with any specification of the JCP.
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 215139
@@ -156,7 +160,7 @@ private IType createTypeFromJar(String resourcePath, int separatorIndex) throws
 	if (this.lastPkgFragmentRootPath == null
 			|| this.lastPkgFragmentRootPath.length() > resourcePath.length()
 			|| !resourcePath.startsWith(this.lastPkgFragmentRootPath)) {
-		String jarPath= resourcePath.substring(0, separatorIndex);
+		String jarPath= resourcePath.substring(0, separatorIndex); 
 		IPackageFragmentRoot root= ((AbstractJavaSearchScope)this.scope).packageFragmentRoot(resourcePath, separatorIndex, jarPath);
 		if (root == null) return null;
 		this.lastPkgFragmentRootPath= jarPath;
@@ -165,6 +169,9 @@ private IType createTypeFromJar(String resourcePath, int separatorIndex) throws
 	}
 	// create handle
 	String classFilePath= resourcePath.substring(separatorIndex + 1);
+	int actualClassIndexSeparator = classFilePath.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);
+	String moduleName = actualClassIndexSeparator == -1 ? null : classFilePath.substring(0, actualClassIndexSeparator);
+	classFilePath = moduleName != null ? classFilePath.substring(actualClassIndexSeparator + 1, classFilePath.length()) : classFilePath;
 	String[] simpleNames = new Path(classFilePath).segments();
 	String[] pkgName;
 	int length = simpleNames.length-1;
@@ -176,7 +183,7 @@ private IType createTypeFromJar(String resourcePath, int separatorIndex) throws
 	}
 	IPackageFragment pkgFragment= (IPackageFragment) this.packageHandles.get(pkgName);
 	if (pkgFragment == null) {
-		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName, null);
+		pkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName, moduleName); //BUG 478143
 		// filter org.apache.commons.lang.enum package for projects above 1.5 
 		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=317264
 		if (length == 5 && pkgName[4].equals("enum")) { //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 8d40822..1a40d1d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -24,8 +28,8 @@ public abstract class AbstractIndexer implements IIndexConstants {
 	public AbstractIndexer(SearchDocument document) {
 		this.document = document;
 	}
-	public void addAnnotationTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
+	public void addAnnotationTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, null);
 
 		addIndexEntry(
 			SUPER_REF,
@@ -43,9 +47,15 @@ public abstract class AbstractIndexer implements IIndexConstants {
 			char[] superclass,
 			char[][] superinterfaces,
 			char[][] typeParameterSignatures,
-			boolean secondary) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
+			boolean secondary,
+			char[] moduleName) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
 
+		addSuperReferences(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces,
+				typeParameterSignatures);
+	}
+	private void addSuperReferences(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames,
+			char[] superclass, char[][] superinterfaces, char[][] typeParameterSignatures) {
 		if (superclass != null) {
 			superclass = erasure(superclass);
 			addTypeReference(superclass);
@@ -119,7 +129,10 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		addIndexEntry(CONSTRUCTOR_DECL, ConstructorPattern.createDefaultDeclarationIndexKey(CharOperation.lastSegment(typeName,'.'), packageName, typeModifiers, extraFlags));
 	}
 	public void addEnumDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[] superclass, char[][] superinterfaces, boolean secondary) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
+		addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, secondary, null);
+	}
+	public void addEnumDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[] superclass, char[][] superinterfaces, boolean secondary, char[] moduleName) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
 
 		addIndexEntry(
 			SUPER_REF,
@@ -147,7 +160,10 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		this.document.addIndexEntry(category, key);
 	}
 	public void addInterfaceDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[][] superinterfaces, char[][] typeParameterSignatures, boolean secondary) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
+		addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, secondary, null);
+	}
+	public void addInterfaceDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[][] superinterfaces, char[][] typeParameterSignatures, boolean secondary, char[] moduleName) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
 
 		if (superinterfaces != null) {
 			for (int i = 0, max = superinterfaces.length; i < max; i++) {
@@ -180,8 +196,8 @@ public abstract class AbstractIndexer implements IIndexConstants {
 	public void addNameReference(char[] name) {
 		addIndexEntry(REF, name);
 	}
-	protected void addTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary) {
-		char[] indexKey = TypeDeclarationPattern.createIndexKey(modifiers, name, packageName, enclosingTypeNames, secondary);
+	protected void addTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) {
+		char[] indexKey = TypeDeclarationPattern.createIndexKey(modifiers, name, packageName, enclosingTypeNames, secondary, moduleName);
 		if (secondary)
 			JavaModelManager.getJavaModelManager().secondaryTypeAdding(
 				this.document.getPath(),
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
index 303029b..17e1e2b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJimageFileToIndex.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -148,7 +148,7 @@ public class AddJimageFileToIndex extends IndexRequest {
 				try {
 					String fullPath = path.toString();
 					final byte[] classFileBytes = JimageUtil.getClassfileContent(this.jimage, fullPath, mod.toString());
-					String docFullPath =  this.container.toString() + JAR_SEPARATOR + fullPath;
+					String docFullPath =  this.container.toString() + JAR_SEPARATOR + mod.toString() + JAR_SEPARATOR + fullPath;
 					JavaSearchDocument entryDocument = new JavaSearchDocument(docFullPath, classFileBytes, this.participant);
 					this.indexManager.indexDocument(entryDocument, this.participant, this.index, this.indexPath);
 				} catch (IOException e) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index f752c34..ce2889c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -633,6 +637,10 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			final String path = this.document.getPath();
 			ClassFileReader reader = new ClassFileReader(contents, path == null ? null : path.toCharArray());
 
+			//extract the module name
+			String[] pathParts = path.split("\\|"); //$NON-NLS-1$
+			char[] moduleName = pathParts != null && pathParts.length > 2 ? pathParts[1].toCharArray() : null;
+
 			// first add type references
 			char[] className = replace('/', '.', reader.getName()); // looks like java/lang/String
 			// need to extract the package name and the simple name
@@ -685,17 +693,17 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			switch (TypeDeclaration.kind(modifiers)) {
 				case TypeDeclaration.CLASS_DECL :
 					char[] superclass = replace('/', '.', reader.getSuperclassName());
-					addClassDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, typeParameterSignatures, false);
+					addClassDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, typeParameterSignatures, false, moduleName);
 					break;
 				case TypeDeclaration.INTERFACE_DECL :
-					addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, false);
+					addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, false, moduleName);
 					break;
 				case TypeDeclaration.ENUM_DECL :
 					superclass = replace('/', '.', reader.getSuperclassName());
-					addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, false);
+					addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, false, moduleName);
 					break;
 				case TypeDeclaration.ANNOTATION_TYPE_DECL :
-					addAnnotationTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, false);
+					addAnnotationTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, false, moduleName);
 					break;
 			}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
index df77605..6ca0564 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -218,7 +222,8 @@ public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, Su
 								CharOperation.NO_CHAR, // super class
 								new char[][] { superinterface },
 								CharOperation.NO_CHAR_CHAR,
-								true); // not primary.
+								true, // not primary.
+								null);// no module name
 
 					} else {
 						if (DEBUG) System.out.println("\tnull/bad binding in lambda"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index 4ada576..b9613aa 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -29,6 +33,7 @@ public class SourceIndexerRequestor implements ISourceElementRequestor, IIndexCo
 	SourceIndexer indexer;
 
 	char[] packageName = CharOperation.NO_CHAR;
+	char[] moduleName = null; //TODO: Figure out when to fill in during compilation
 	char[][] enclosingTypeNames = new char[5][];
 	int depth = 0;
 	int methodDepth = 0;
@@ -177,7 +182,7 @@ private void enterAnnotationType(TypeInfo typeInfo) {
 	} else {
 		typeNames = enclosingTypeNames();
 	}
-	this.indexer.addAnnotationTypeDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.secondary);
+	this.indexer.addAnnotationTypeDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.secondary, this.moduleName);
 	addDefaultConstructorIfNecessary(typeInfo);
 	pushTypeName(typeInfo.name);
 }
@@ -212,7 +217,7 @@ private void enterClass(TypeInfo typeInfo) {
 			typeParameterSignatures[i] = Signature.createTypeParameterSignature(typeParameterInfo.name, typeParameterInfo.bounds == null ? CharOperation.NO_CHAR_CHAR : typeParameterInfo.bounds);
 		}
 	}
-	this.indexer.addClassDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.superclass, typeInfo.superinterfaces, typeParameterSignatures, typeInfo.secondary);
+	this.indexer.addClassDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.superclass, typeInfo.superinterfaces, typeParameterSignatures, typeInfo.secondary, this.moduleName);
 	addDefaultConstructorIfNecessary(typeInfo);
 	pushTypeName(typeInfo.name);
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
index 42f0e7d..85fab16 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -20,6 +24,10 @@ PackageDeclarationPattern packagePattern;
 public int packageIndex = -1;
 
 public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName, char typeSuffix, int matchRule) {
+	this(qualification, simpleName, typeSuffix, matchRule, null);
+}
+
+public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName, char typeSuffix, int matchRule, char[] moduleName) {
 	this(matchRule);
 
 	this.qualification = this.isCaseSensitive ? qualification : CharOperation.toLowerCase(qualification);
@@ -27,8 +35,12 @@ public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName,
 	this.typeSuffix = typeSuffix;
 
 	this.mustResolve = this.qualification != null || typeSuffix != TYPE_SUFFIX;
+	this.moduleName = moduleName;
 }
 public QualifiedTypeDeclarationPattern(char[] qualification, int qualificationMatchRule, char[] simpleName, char typeSuffix, int matchRule) {
+	this(qualification, qualificationMatchRule, simpleName, typeSuffix, matchRule, null);
+}
+public QualifiedTypeDeclarationPattern(char[] qualification, int qualificationMatchRule, char[] simpleName, char typeSuffix, int matchRule, char[] moduleName) {
 	this(qualification, simpleName, typeSuffix, matchRule);
 	this.packagePattern = new PackageDeclarationPattern(qualification, qualificationMatchRule);
 }
@@ -40,6 +52,8 @@ public void decodeIndexKey(char[] key) {
 	this.simpleName = CharOperation.subarray(key, 0, slash);
 
 	int start = ++slash;
+	
+	// read package
 	if (key[start] == SEPARATOR) {
 		this.pkg = CharOperation.NO_CHAR;
 	} else {
@@ -48,21 +62,13 @@ public void decodeIndexKey(char[] key) {
 	}
 	this.qualification = this.pkg;
 
-	// Continue key read by the end to decode modifiers
-	int last = key.length-1;
-	this.secondary = key[last] == 'S';
-	if (this.secondary) {
-		last -= 2;
-	}
-	this.modifiers = key[last-1] + (key[last]<<16);
-	decodeModifiers();
-
 	// Retrieve enclosing type names
-	start = slash + 1;
-	last -= 2; // position of ending slash
-	if (start == last) {
-		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+	start = ++slash;
+	int last;
+	if (key[start] == SEPARATOR) {
+		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;		
 	} else {
+		last = slash = CharOperation.indexOf(SEPARATOR, key, start);
 		int length = this.qualification.length;
 		int size = last - start;
 		System.arraycopy(this.qualification, 0, this.qualification = new char[length+1+size], 0, length);
@@ -75,6 +81,22 @@ public void decodeIndexKey(char[] key) {
 			System.arraycopy(key, start, this.qualification, length+1, size);
 		}
 	}
+
+	// read modifiers
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	last = slash - 1;
+	this.modifiers = key[last-1] + (key[last]<<16);
+	decodeModifiers();
+	
+	// module name
+	start = slash + 1; // beginning of module name;
+	slash = CharOperation.indexOf(SEPARATOR, key, start); 
+	this.moduleName = start == slash ? CharOperation.NO_CHAR : CharOperation.subarray(key, start, slash);
+
+	// Primary or Secondary
+	start = slash + 1;
+	this.secondary = key[start] == 'S';
 }
 public SearchPattern getBlankPattern() {
 	return new QualifiedTypeDeclarationPattern(R_EXACT_MATCH | R_CASE_SENSITIVE);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
index ea813ef..683e3a7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -22,6 +26,7 @@ public class TypeDeclarationPattern extends JavaSearchPattern {
 public char[] simpleName;
 public char[] pkg;
 public char[][] enclosingTypeNames;
+public char[] moduleName = null;
 
 // set to CLASS_SUFFIX for only matching classes
 // set to INTERFACE_SUFFIX for only matching interfaces
@@ -81,13 +86,14 @@ void rehash() {
 
 /*
  * Create index key for type declaration pattern:
- *		key = typeName / packageName / enclosingTypeName / modifiers
+ *		key = typeName / packageName / enclosingTypeName / modifiers/ moduleName / 'P'
  * or for secondary types
- *		key = typeName / packageName / enclosingTypeName / modifiers / 'S'
+ *		key = typeName / packageName / enclosingTypeName / modifiers / moduleName / 'S'
  */
-public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary) { //, char typeSuffix) {
+public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) { //, char typeSuffix) {
 	int typeNameLength = typeName == null ? 0 : typeName.length;
 	int packageLength = packageName == null ? 0 : packageName.length;
+	int moduleLength = moduleName == null ? 0 : moduleName.length;
 	int enclosingNamesLength = 0;
 	if (enclosingTypeNames != null) {
 		for (int i = 0, length = enclosingTypeNames.length; i < length;) {
@@ -97,8 +103,8 @@ public static char[] createIndexKey(int modifiers, char[] typeName, char[] packa
 		}
 	}
 
-	int resultLength = typeNameLength + packageLength + enclosingNamesLength + 5;
-	if (secondary) resultLength += 2;
+	int resultLength = typeNameLength + packageLength + enclosingNamesLength + moduleLength + 6;
+	resultLength += 2;
 	char[] result = new char[resultLength];
 	int pos = 0;
 	if (typeNameLength > 0) {
@@ -124,12 +130,33 @@ public static char[] createIndexKey(int modifiers, char[] typeName, char[] packa
 	result[pos++] = SEPARATOR;
 	result[pos++] = (char) modifiers;
 	result[pos] = (char) (modifiers>>16);
+	result[++pos] = SEPARATOR;
+	if (moduleLength > 0) {
+		System.arraycopy(moduleName, 0, result, ++pos, moduleLength);
+		pos += moduleLength; // uncomment if adding another field
+	}
+	result[pos++] = SEPARATOR;
 	if (secondary) {
-		result[++pos] = SEPARATOR;
-		result[++pos] = 'S';
+		result[pos] = 'S';
+	} else {
+		result[pos] = 'P';
 	}
 	return result;
 }
+public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary) { //, char typeSuffix) {
+	return createIndexKey(modifiers, typeName, packageName, enclosingTypeNames, secondary, null);
+}
+
+public TypeDeclarationPattern(
+		char[] moduleName,
+		char[] pkg,
+		char[][] enclosingTypeNames,
+		char[] simpleName,
+		char typeSuffix,
+		int matchRule) {
+	this(pkg, enclosingTypeNames, simpleName, typeSuffix, matchRule);
+	this.moduleName = moduleName;
+}
 
 public TypeDeclarationPattern(
 	char[] pkg,
@@ -159,18 +186,20 @@ TypeDeclarationPattern(int matchRule) {
 }
 /*
  * Type entries are encoded as:
- * 	simpleTypeName / packageName / enclosingTypeName / modifiers
- *			e.g. Object/java.lang//0
- * 		e.g. Cloneable/java.lang//512
- * 		e.g. LazyValue/javax.swing/UIDefaults/0
+ * 	simpleTypeName / packageName / enclosingTypeName / modifiers / moduleName / 'P'
+ *			e.g. Object/java.lang//0/P/java.base
+ * 		e.g. Cloneable/java.lang//512/P/java.base
+ * 		e.g. LazyValue/javax.swing/UIDefaults/0/<module_name>/P
  * or for secondary types as:
- * 	simpleTypeName / packageName / enclosingTypeName / modifiers / S
+ * 	simpleTypeName / packageName / enclosingTypeName / modifiers / moduleName / 'S'
  */
 public void decodeIndexKey(char[] key) {
 	int slash = CharOperation.indexOf(SEPARATOR, key, 0);
 	this.simpleName = CharOperation.subarray(key, 0, slash);
 
 	int start = ++slash;
+
+	// read package
 	if (key[start] == SEPARATOR) {
 		this.pkg = CharOperation.NO_CHAR;
 	} else {
@@ -178,27 +207,32 @@ public void decodeIndexKey(char[] key) {
 		this.pkg = internedPackageNames.add(CharOperation.subarray(key, start, slash));
 	}
 
-	// Continue key read by the end to decode modifiers
-	int last = key.length-1;
-	this.secondary = key[last] == 'S';
-	if (this.secondary) {
-		last -= 2;
+	// read enclosingtype
+	start = ++slash;
+	int last;
+	if (key[start] == SEPARATOR) {
+		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;		
+	} else {
+		last = slash = CharOperation.indexOf(SEPARATOR, key, start);
+		this.enclosingTypeNames = last == (start+1) && key[start] == ZERO_CHAR ? ONE_ZERO_CHAR : CharOperation.splitOn('.', key, start, last);
 	}
+
+	// read modifiers
+	start = slash + 1;
+	slash = CharOperation.indexOf(SEPARATOR, key, start);
+	last = slash - 1;
 	this.modifiers = key[last-1] + (key[last]<<16);
 	decodeModifiers();
 
-	// Retrieve enclosing type names
+	// module name
+	start = slash + 1; // beginning of module name;
+	slash = CharOperation.indexOf(SEPARATOR, key, start); // should be start + 1 if not corrupted
+	this.moduleName = start == slash ? CharOperation.NO_CHAR : CharOperation.subarray(key, start, slash);
+
+	// Primary or Secondary
 	start = slash + 1;
-	last -= 2; // position of ending slash
-	if (start == last) {
-		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-	} else {
-		if (last == (start+1) && key[start] == ZERO_CHAR) {
-			this.enclosingTypeNames = ONE_ZERO_CHAR;
-		} else {
-			this.enclosingTypeNames = CharOperation.splitOn('.', key, start, last);
-		}
-	}
+	this.secondary = key[start] == 'S';
+	
 }
 protected void decodeModifiers() {
 
@@ -243,6 +277,10 @@ public boolean matchesDecodedKey(SearchPattern decodedPattern) {
 	if (this.pkg != null && !CharOperation.equals(this.pkg, pattern.pkg, isCaseSensitive()))
 		return false;
 
+	// check module name if present
+	if (this.moduleName != null && !CharOperation.equals(this.moduleName, pattern.moduleName))
+		return false;
+
 	// check enclosingTypeNames - exact match only
 	if (this.enclosingTypeNames != null) {
 		if (this.enclosingTypeNames.length == 0)
@@ -312,30 +350,36 @@ public EntryResult[] queryIn(Index index) throws IOException {
 protected StringBuffer print(StringBuffer output) {
 	switch (this.typeSuffix){
 		case CLASS_SUFFIX :
-			output.append("ClassDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("ClassDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case CLASS_AND_INTERFACE_SUFFIX:
-			output.append("ClassAndInterfaceDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("ClassAndInterfaceDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case CLASS_AND_ENUM_SUFFIX :
-			output.append("ClassAndEnumDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("ClassAndEnumDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case INTERFACE_SUFFIX :
-			output.append("InterfaceDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("InterfaceDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case INTERFACE_AND_ANNOTATION_SUFFIX:
-			output.append("InterfaceAndAnnotationDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("InterfaceAndAnnotationDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case ENUM_SUFFIX :
-			output.append("EnumDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("EnumDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		case ANNOTATION_TYPE_SUFFIX :
-			output.append("AnnotationTypeDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("AnnotationTypeDeclarationPattern:"); //$NON-NLS-1$
 			break;
 		default :
-			output.append("TypeDeclarationPattern: pkg<"); //$NON-NLS-1$
+			output.append("TypeDeclarationPattern:"); //$NON-NLS-1$
 			break;
 	}
+	if (this.moduleName != null) {
+		output.append(" module<"); //$NON-NLS-1$
+		output.append(this.moduleName);
+		output.append(">"); //$NON-NLS-1$
+	}
+	output.append(" pkg<");//$NON-NLS-1$
 	if (this.pkg != null)
 		output.append(this.pkg);
 	else
commit 98ea7b5c884ea38db2971ba16b50553929fbb7a3
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Mon Oct 5 14:28:20 2015 +0530

    Part reversal for Fix for Bug 478143 [1.9][search] non java.base module
    types are not found in open type

1	11	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
2	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
9	25	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
5	13	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
2	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
3	8	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
14	36	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
37	81	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
index 5e0264a..6c8714e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassNameTests.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -116,8 +112,6 @@ protected void setUp() throws Exception {
 			"}\n"
 		);
 	}
-	waitUntilIndexesReady();
-
 }
 
 /* (non-Javadoc)
@@ -1144,8 +1138,6 @@ public void testFindSecondaryType_Bug72179() throws JavaModelException, CoreExce
 			"	jc008 a;\n" +
 			"}\n"
 		);
-		waitUntilIndexesReady();
-
 		IType type = javaProject.findType("p1", "jc008", new NullProgressMonitor());
 		assertTrue("type 'jc008' should exist!", type != null && type.exists());
 		assertEquals("Expected type 'jc008' NOT found!",
@@ -1330,8 +1322,6 @@ public void testBug306477() throws Exception {
 			"}\n"
 		);
 		
-		waitUntilIndexesReady();
-
 		// find secondary enum
 		IType type = project.findType("p.Bob", new NullProgressMonitor());
 		assertElementEquals("We should have found the secondary enum 'Bob'!",
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
index fd7acde..43ca37e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -50,7 +46,7 @@ private int bufferIndex, bufferEnd; // used when reading from the file into the
 private int streamEnd; // used when writing data from the streamBuffer to the file
 char separator = Index.DEFAULT_SEPARATOR;
 
-public static final String SIGNATURE= "INDEX VERSION 1.128"; //$NON-NLS-1$
+public static final String SIGNATURE= "INDEX VERSION 1.127"; //$NON-NLS-1$
 private static final char[] SIGNATURE_CHARS = SIGNATURE.toCharArray();
 public static boolean DEBUG = false;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 1a40d1d..8d40822 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -28,8 +24,8 @@ public abstract class AbstractIndexer implements IIndexConstants {
 	public AbstractIndexer(SearchDocument document) {
 		this.document = document;
 	}
-	public void addAnnotationTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, null);
+	public void addAnnotationTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
 
 		addIndexEntry(
 			SUPER_REF,
@@ -47,15 +43,9 @@ public abstract class AbstractIndexer implements IIndexConstants {
 			char[] superclass,
 			char[][] superinterfaces,
 			char[][] typeParameterSignatures,
-			boolean secondary,
-			char[] moduleName) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
+			boolean secondary) {
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
 
-		addSuperReferences(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces,
-				typeParameterSignatures);
-	}
-	private void addSuperReferences(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames,
-			char[] superclass, char[][] superinterfaces, char[][] typeParameterSignatures) {
 		if (superclass != null) {
 			superclass = erasure(superclass);
 			addTypeReference(superclass);
@@ -129,10 +119,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		addIndexEntry(CONSTRUCTOR_DECL, ConstructorPattern.createDefaultDeclarationIndexKey(CharOperation.lastSegment(typeName,'.'), packageName, typeModifiers, extraFlags));
 	}
 	public void addEnumDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[] superclass, char[][] superinterfaces, boolean secondary) {
-		addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, secondary, null);
-	}
-	public void addEnumDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[] superclass, char[][] superinterfaces, boolean secondary, char[] moduleName) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
 
 		addIndexEntry(
 			SUPER_REF,
@@ -160,10 +147,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		this.document.addIndexEntry(category, key);
 	}
 	public void addInterfaceDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[][] superinterfaces, char[][] typeParameterSignatures, boolean secondary) {
-		addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, secondary, null);
-	}
-	public void addInterfaceDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, char[][] superinterfaces, char[][] typeParameterSignatures, boolean secondary, char[] moduleName) {
-		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary, moduleName);
+		addTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, secondary);
 
 		if (superinterfaces != null) {
 			for (int i = 0, max = superinterfaces.length; i < max; i++) {
@@ -196,8 +180,8 @@ public abstract class AbstractIndexer implements IIndexConstants {
 	public void addNameReference(char[] name) {
 		addIndexEntry(REF, name);
 	}
-	protected void addTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) {
-		char[] indexKey = TypeDeclarationPattern.createIndexKey(modifiers, name, packageName, enclosingTypeNames, secondary, moduleName);
+	protected void addTypeDeclaration(int modifiers, char[] packageName, char[] name, char[][] enclosingTypeNames, boolean secondary) {
+		char[] indexKey = TypeDeclarationPattern.createIndexKey(modifiers, name, packageName, enclosingTypeNames, secondary);
 		if (secondary)
 			JavaModelManager.getJavaModelManager().secondaryTypeAdding(
 				this.document.getPath(),
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index ce2889c..f752c34 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -637,10 +633,6 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			final String path = this.document.getPath();
 			ClassFileReader reader = new ClassFileReader(contents, path == null ? null : path.toCharArray());
 
-			//extract the module name
-			String[] pathParts = path.split("\\|"); //$NON-NLS-1$
-			char[] moduleName = pathParts != null && pathParts.length > 2 ? pathParts[1].toCharArray() : null;
-
 			// first add type references
 			char[] className = replace('/', '.', reader.getName()); // looks like java/lang/String
 			// need to extract the package name and the simple name
@@ -693,17 +685,17 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 			switch (TypeDeclaration.kind(modifiers)) {
 				case TypeDeclaration.CLASS_DECL :
 					char[] superclass = replace('/', '.', reader.getSuperclassName());
-					addClassDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, typeParameterSignatures, false, moduleName);
+					addClassDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, typeParameterSignatures, false);
 					break;
 				case TypeDeclaration.INTERFACE_DECL :
-					addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, false, moduleName);
+					addInterfaceDeclaration(modifiers, packageName, name, enclosingTypeNames, superinterfaces, typeParameterSignatures, false);
 					break;
 				case TypeDeclaration.ENUM_DECL :
 					superclass = replace('/', '.', reader.getSuperclassName());
-					addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, false, moduleName);
+					addEnumDeclaration(modifiers, packageName, name, enclosingTypeNames, superclass, superinterfaces, false);
 					break;
 				case TypeDeclaration.ANNOTATION_TYPE_DECL :
-					addAnnotationTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, false, moduleName);
+					addAnnotationTypeDeclaration(modifiers, packageName, name, enclosingTypeNames, false);
 					break;
 			}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
index 6ca0564..df77605 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -222,8 +218,7 @@ public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, Su
 								CharOperation.NO_CHAR, // super class
 								new char[][] { superinterface },
 								CharOperation.NO_CHAR_CHAR,
-								true, // not primary.
-								null);// no module name
+								true); // not primary.
 
 					} else {
 						if (DEBUG) System.out.println("\tnull/bad binding in lambda"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
index b9613aa..4ada576 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexerRequestor.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -33,7 +29,6 @@ public class SourceIndexerRequestor implements ISourceElementRequestor, IIndexCo
 	SourceIndexer indexer;
 
 	char[] packageName = CharOperation.NO_CHAR;
-	char[] moduleName = null; //TODO: Figure out when to fill in during compilation
 	char[][] enclosingTypeNames = new char[5][];
 	int depth = 0;
 	int methodDepth = 0;
@@ -182,7 +177,7 @@ private void enterAnnotationType(TypeInfo typeInfo) {
 	} else {
 		typeNames = enclosingTypeNames();
 	}
-	this.indexer.addAnnotationTypeDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.secondary, this.moduleName);
+	this.indexer.addAnnotationTypeDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.secondary);
 	addDefaultConstructorIfNecessary(typeInfo);
 	pushTypeName(typeInfo.name);
 }
@@ -217,7 +212,7 @@ private void enterClass(TypeInfo typeInfo) {
 			typeParameterSignatures[i] = Signature.createTypeParameterSignature(typeParameterInfo.name, typeParameterInfo.bounds == null ? CharOperation.NO_CHAR_CHAR : typeParameterInfo.bounds);
 		}
 	}
-	this.indexer.addClassDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.superclass, typeInfo.superinterfaces, typeParameterSignatures, typeInfo.secondary, this.moduleName);
+	this.indexer.addClassDeclaration(typeInfo.modifiers, this.packageName, typeInfo.name, typeNames, typeInfo.superclass, typeInfo.superinterfaces, typeParameterSignatures, typeInfo.secondary);
 	addDefaultConstructorIfNecessary(typeInfo);
 	pushTypeName(typeInfo.name);
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
index 85fab16..42f0e7d 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/QualifiedTypeDeclarationPattern.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -24,10 +20,6 @@ PackageDeclarationPattern packagePattern;
 public int packageIndex = -1;
 
 public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName, char typeSuffix, int matchRule) {
-	this(qualification, simpleName, typeSuffix, matchRule, null);
-}
-
-public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName, char typeSuffix, int matchRule, char[] moduleName) {
 	this(matchRule);
 
 	this.qualification = this.isCaseSensitive ? qualification : CharOperation.toLowerCase(qualification);
@@ -35,12 +27,8 @@ public QualifiedTypeDeclarationPattern(char[] qualification, char[] simpleName,
 	this.typeSuffix = typeSuffix;
 
 	this.mustResolve = this.qualification != null || typeSuffix != TYPE_SUFFIX;
-	this.moduleName = moduleName;
 }
 public QualifiedTypeDeclarationPattern(char[] qualification, int qualificationMatchRule, char[] simpleName, char typeSuffix, int matchRule) {
-	this(qualification, qualificationMatchRule, simpleName, typeSuffix, matchRule, null);
-}
-public QualifiedTypeDeclarationPattern(char[] qualification, int qualificationMatchRule, char[] simpleName, char typeSuffix, int matchRule, char[] moduleName) {
 	this(qualification, simpleName, typeSuffix, matchRule);
 	this.packagePattern = new PackageDeclarationPattern(qualification, qualificationMatchRule);
 }
@@ -52,8 +40,6 @@ public void decodeIndexKey(char[] key) {
 	this.simpleName = CharOperation.subarray(key, 0, slash);
 
 	int start = ++slash;
-	
-	// read package
 	if (key[start] == SEPARATOR) {
 		this.pkg = CharOperation.NO_CHAR;
 	} else {
@@ -62,13 +48,21 @@ public void decodeIndexKey(char[] key) {
 	}
 	this.qualification = this.pkg;
 
+	// Continue key read by the end to decode modifiers
+	int last = key.length-1;
+	this.secondary = key[last] == 'S';
+	if (this.secondary) {
+		last -= 2;
+	}
+	this.modifiers = key[last-1] + (key[last]<<16);
+	decodeModifiers();
+
 	// Retrieve enclosing type names
-	start = ++slash;
-	int last;
-	if (key[start] == SEPARATOR) {
-		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;		
+	start = slash + 1;
+	last -= 2; // position of ending slash
+	if (start == last) {
+		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
 	} else {
-		last = slash = CharOperation.indexOf(SEPARATOR, key, start);
 		int length = this.qualification.length;
 		int size = last - start;
 		System.arraycopy(this.qualification, 0, this.qualification = new char[length+1+size], 0, length);
@@ -81,22 +75,6 @@ public void decodeIndexKey(char[] key) {
 			System.arraycopy(key, start, this.qualification, length+1, size);
 		}
 	}
-
-	// read modifiers
-	start = slash + 1;
-	slash = CharOperation.indexOf(SEPARATOR, key, start);
-	last = slash - 1;
-	this.modifiers = key[last-1] + (key[last]<<16);
-	decodeModifiers();
-	
-	// module name
-	start = slash + 1; // beginning of module name;
-	slash = CharOperation.indexOf(SEPARATOR, key, start); 
-	this.moduleName = start == slash ? CharOperation.NO_CHAR : CharOperation.subarray(key, start, slash);
-
-	// Primary or Secondary
-	start = slash + 1;
-	this.secondary = key[start] == 'S';
 }
 public SearchPattern getBlankPattern() {
 	return new QualifiedTypeDeclarationPattern(R_EXACT_MATCH | R_CASE_SENSITIVE);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
index 683e3a7..ea813ef 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
-
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -26,7 +22,6 @@ public class TypeDeclarationPattern extends JavaSearchPattern {
 public char[] simpleName;
 public char[] pkg;
 public char[][] enclosingTypeNames;
-public char[] moduleName = null;
 
 // set to CLASS_SUFFIX for only matching classes
 // set to INTERFACE_SUFFIX for only matching interfaces
@@ -86,14 +81,13 @@ void rehash() {
 
 /*
  * Create index key for type declaration pattern:
- *		key = typeName / packageName / enclosingTypeName / modifiers/ moduleName / 'P'
+ *		key = typeName / packageName / enclosingTypeName / modifiers
  * or for secondary types
- *		key = typeName / packageName / enclosingTypeName / modifiers / moduleName / 'S'
+ *		key = typeName / packageName / enclosingTypeName / modifiers / 'S'
  */
-public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary, char[] moduleName) { //, char typeSuffix) {
+public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary) { //, char typeSuffix) {
 	int typeNameLength = typeName == null ? 0 : typeName.length;
 	int packageLength = packageName == null ? 0 : packageName.length;
-	int moduleLength = moduleName == null ? 0 : moduleName.length;
 	int enclosingNamesLength = 0;
 	if (enclosingTypeNames != null) {
 		for (int i = 0, length = enclosingTypeNames.length; i < length;) {
@@ -103,8 +97,8 @@ public static char[] createIndexKey(int modifiers, char[] typeName, char[] packa
 		}
 	}
 
-	int resultLength = typeNameLength + packageLength + enclosingNamesLength + moduleLength + 6;
-	resultLength += 2;
+	int resultLength = typeNameLength + packageLength + enclosingNamesLength + 5;
+	if (secondary) resultLength += 2;
 	char[] result = new char[resultLength];
 	int pos = 0;
 	if (typeNameLength > 0) {
@@ -130,33 +124,12 @@ public static char[] createIndexKey(int modifiers, char[] typeName, char[] packa
 	result[pos++] = SEPARATOR;
 	result[pos++] = (char) modifiers;
 	result[pos] = (char) (modifiers>>16);
-	result[++pos] = SEPARATOR;
-	if (moduleLength > 0) {
-		System.arraycopy(moduleName, 0, result, ++pos, moduleLength);
-		pos += moduleLength; // uncomment if adding another field
-	}
-	result[pos++] = SEPARATOR;
 	if (secondary) {
-		result[pos] = 'S';
-	} else {
-		result[pos] = 'P';
+		result[++pos] = SEPARATOR;
+		result[++pos] = 'S';
 	}
 	return result;
 }
-public static char[] createIndexKey(int modifiers, char[] typeName, char[] packageName, char[][] enclosingTypeNames, boolean secondary) { //, char typeSuffix) {
-	return createIndexKey(modifiers, typeName, packageName, enclosingTypeNames, secondary, null);
-}
-
-public TypeDeclarationPattern(
-		char[] moduleName,
-		char[] pkg,
-		char[][] enclosingTypeNames,
-		char[] simpleName,
-		char typeSuffix,
-		int matchRule) {
-	this(pkg, enclosingTypeNames, simpleName, typeSuffix, matchRule);
-	this.moduleName = moduleName;
-}
 
 public TypeDeclarationPattern(
 	char[] pkg,
@@ -186,20 +159,18 @@ TypeDeclarationPattern(int matchRule) {
 }
 /*
  * Type entries are encoded as:
- * 	simpleTypeName / packageName / enclosingTypeName / modifiers / moduleName / 'P'
- *			e.g. Object/java.lang//0/P/java.base
- * 		e.g. Cloneable/java.lang//512/P/java.base
- * 		e.g. LazyValue/javax.swing/UIDefaults/0/<module_name>/P
+ * 	simpleTypeName / packageName / enclosingTypeName / modifiers
+ *			e.g. Object/java.lang//0
+ * 		e.g. Cloneable/java.lang//512
+ * 		e.g. LazyValue/javax.swing/UIDefaults/0
  * or for secondary types as:
- * 	simpleTypeName / packageName / enclosingTypeName / modifiers / moduleName / 'S'
+ * 	simpleTypeName / packageName / enclosingTypeName / modifiers / S
  */
 public void decodeIndexKey(char[] key) {
 	int slash = CharOperation.indexOf(SEPARATOR, key, 0);
 	this.simpleName = CharOperation.subarray(key, 0, slash);
 
 	int start = ++slash;
-
-	// read package
 	if (key[start] == SEPARATOR) {
 		this.pkg = CharOperation.NO_CHAR;
 	} else {
@@ -207,32 +178,27 @@ public void decodeIndexKey(char[] key) {
 		this.pkg = internedPackageNames.add(CharOperation.subarray(key, start, slash));
 	}
 
-	// read enclosingtype
-	start = ++slash;
-	int last;
-	if (key[start] == SEPARATOR) {
-		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;		
-	} else {
-		last = slash = CharOperation.indexOf(SEPARATOR, key, start);
-		this.enclosingTypeNames = last == (start+1) && key[start] == ZERO_CHAR ? ONE_ZERO_CHAR : CharOperation.splitOn('.', key, start, last);
+	// Continue key read by the end to decode modifiers
+	int last = key.length-1;
+	this.secondary = key[last] == 'S';
+	if (this.secondary) {
+		last -= 2;
 	}
-
-	// read modifiers
-	start = slash + 1;
-	slash = CharOperation.indexOf(SEPARATOR, key, start);
-	last = slash - 1;
 	this.modifiers = key[last-1] + (key[last]<<16);
 	decodeModifiers();
 
-	// module name
-	start = slash + 1; // beginning of module name;
-	slash = CharOperation.indexOf(SEPARATOR, key, start); // should be start + 1 if not corrupted
-	this.moduleName = start == slash ? CharOperation.NO_CHAR : CharOperation.subarray(key, start, slash);
-
-	// Primary or Secondary
+	// Retrieve enclosing type names
 	start = slash + 1;
-	this.secondary = key[start] == 'S';
-	
+	last -= 2; // position of ending slash
+	if (start == last) {
+		this.enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+	} else {
+		if (last == (start+1) && key[start] == ZERO_CHAR) {
+			this.enclosingTypeNames = ONE_ZERO_CHAR;
+		} else {
+			this.enclosingTypeNames = CharOperation.splitOn('.', key, start, last);
+		}
+	}
 }
 protected void decodeModifiers() {
 
@@ -277,10 +243,6 @@ public boolean matchesDecodedKey(SearchPattern decodedPattern) {
 	if (this.pkg != null && !CharOperation.equals(this.pkg, pattern.pkg, isCaseSensitive()))
 		return false;
 
-	// check module name if present
-	if (this.moduleName != null && !CharOperation.equals(this.moduleName, pattern.moduleName))
-		return false;
-
 	// check enclosingTypeNames - exact match only
 	if (this.enclosingTypeNames != null) {
 		if (this.enclosingTypeNames.length == 0)
@@ -350,36 +312,30 @@ public EntryResult[] queryIn(Index index) throws IOException {
 protected StringBuffer print(StringBuffer output) {
 	switch (this.typeSuffix){
 		case CLASS_SUFFIX :
-			output.append("ClassDeclarationPattern:"); //$NON-NLS-1$
+			output.append("ClassDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case CLASS_AND_INTERFACE_SUFFIX:
-			output.append("ClassAndInterfaceDeclarationPattern:"); //$NON-NLS-1$
+			output.append("ClassAndInterfaceDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case CLASS_AND_ENUM_SUFFIX :
-			output.append("ClassAndEnumDeclarationPattern:"); //$NON-NLS-1$
+			output.append("ClassAndEnumDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case INTERFACE_SUFFIX :
-			output.append("InterfaceDeclarationPattern:"); //$NON-NLS-1$
+			output.append("InterfaceDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case INTERFACE_AND_ANNOTATION_SUFFIX:
-			output.append("InterfaceAndAnnotationDeclarationPattern:"); //$NON-NLS-1$
+			output.append("InterfaceAndAnnotationDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case ENUM_SUFFIX :
-			output.append("EnumDeclarationPattern:"); //$NON-NLS-1$
+			output.append("EnumDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		case ANNOTATION_TYPE_SUFFIX :
-			output.append("AnnotationTypeDeclarationPattern:"); //$NON-NLS-1$
+			output.append("AnnotationTypeDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 		default :
-			output.append("TypeDeclarationPattern:"); //$NON-NLS-1$
+			output.append("TypeDeclarationPattern: pkg<"); //$NON-NLS-1$
 			break;
 	}
-	if (this.moduleName != null) {
-		output.append(" module<"); //$NON-NLS-1$
-		output.append(this.moduleName);
-		output.append(">"); //$NON-NLS-1$
-	}
-	output.append(" pkg<");//$NON-NLS-1$
 	if (this.pkg != null)
 		output.append(this.pkg);
 	else
