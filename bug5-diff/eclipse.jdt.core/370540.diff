commit f9a46f3b03f3a4f0a3f6d3a22503ef1fa89762cc
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Tue Mar 8 22:30:54 2016 +0100

    Bug 370540 - [Formatter] New settings for parentheses positions
    
    Change-Id: I1b05433bed5bdbef1d3ba04fc12030b1725debf5
    Signed-off-by: Mateusz Matela <mateusz.matela@gmail.com>

212	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
43	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_in.java
45	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out01.java
49	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out02.java
47	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out03.java
50	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out04.java
53	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out05.java
50	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out06.java
53	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out07.java
49	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out08.java
57	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out09.java
48	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out10.java
48	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out11.java
47	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out12.java
49	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out13.java
50	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out14.java
86	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out15.java
247	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
89	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
147	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
9	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
32	2	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index d274b3f..3253f0e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -13575,4 +13575,216 @@ public void testBug325631() {
 		"}"
 	);
 }
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540a() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out01.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540b() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out02.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540c() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out03.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540d() throws JavaModelException {
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out04.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540e() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out05.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540f() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	this.formatterPrefs.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out06.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540g() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out07.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540h() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	this.formatterPrefs.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out08.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540i() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out09.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540j() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_try_clause = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.PRESERVE_POSITIONS;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out10.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540k() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_catch_clause = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.PRESERVE_POSITIONS;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out11.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540l() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	this.formatterPrefs.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out12.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540m() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	this.formatterPrefs.alignment_for_expressions_in_for_loop_header = Alignment.M_NEXT_PER_LINE_SPLIT + Alignment.M_FORCE;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out13.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540n() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_switch_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out14.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540p() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_1_8);
+	this.formatterPrefs.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_catch_clause = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_switch_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	this.formatterPrefs.parenthesis_positions_in_try_clause = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out15.java").getSource());
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540q() throws JavaModelException {
+	this.formatterPrefs.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String source = 
+		"public class Test {\n" + 
+		"	void foo() {\n" + 
+		"		for (\n" + 
+		"			String s : Arrays.asList(\"aa\")\n" + 
+		"		) {\n" + 
+		"		}\n" + 
+		"	}\n" + 
+		"}";
+	formatSource(source);
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540r() throws JavaModelException {
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES;
+	String source = 
+		"public class Test extends Exception {\n" + 
+		"	Test instance = new Test(\n" + 
+		"			1\n" + 
+		"	);\n" + 
+		"\n" + 
+		"	Test(int a) {\n" + 
+		"		this(\n" + 
+		"				a, 0\n" + 
+		"		);\n" + 
+		"	}\n" + 
+		"\n" + 
+		"	Test(int a, int b) {\n" + 
+		"		super(\n" + 
+		"				a + \"=\" + b\n" + 
+		"		);\n" + 
+		"	}\n" + 
+		"\n" + 
+		"	public void printStackTrace() {\n" + 
+		"		super.printStackTrace(\n" + 
+		"		);\n" + 
+		"	}\n" + 
+		"}";
+	formatSource(source);
+}
+/**
+ * https://bugs.eclipse.org/370540 - [Formatter] New settings for parentheses positions
+ */
+public void testBug370540s() throws JavaModelException {
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
+	String source = 
+		"public class Test extends Exception {\n" + 
+		"	void foo() {\n" + 
+		"		new StringBuilder().append(\"aaaaaaaaa\" + \"bbbbbbbbbbbbbbb\" + \"cccccccccccccc\" + \"dddddddddd\")\n" + 
+		"				.append(\"aaaaaaa\" + \"bbbbbbbbbbbbb\" + \"cccccccccccccc\" + \"ddddddddd\");\n" + 
+		"	}\n" + 
+		"}";
+	formatSource(source);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_in.java
new file mode 100644
index 0000000..4985fee
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_in.java
@@ -0,0 +1,43 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+	@Deprecated()
+	void method2(
+			String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb", "ccccccccccccccccccc");
+			break;
+		}
+	}
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5, String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)
+		) {
+			argument1.method2(argument5);
+		}
+	}
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {};
+}
+
+enum SomeEnum {
+	VALUE1(),
+	VALUE2("example")
+}
+
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out01.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out01.java
new file mode 100644
index 0000000..3e2ae88
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out01.java
@@ -0,0 +1,45 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out02.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out02.java
new file mode 100644
index 0000000..4fc8a81
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out02.java
@@ -0,0 +1,49 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(
+			String argument
+	) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(
+			Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6
+	) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out03.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out03.java
new file mode 100644
index 0000000..f884667
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out03.java
@@ -0,0 +1,47 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(
+			Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6
+	) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out04.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out04.java
new file mode 100644
index 0000000..32a4f05
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out04.java
@@ -0,0 +1,50 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1(
+	) {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(
+			String argument
+	) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(
+			Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6
+	) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out05.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out05.java
new file mode 100644
index 0000000..f08bee6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out05.java
@@ -0,0 +1,53 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(
+					this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc"
+			);
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(
+				argument4
+		)) {
+			argument1.method2(
+					argument5
+			);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(
+						""
+				));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out06.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out06.java
new file mode 100644
index 0000000..239471f
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out06.java
@@ -0,0 +1,50 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(
+					this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc"
+			);
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(
+	), VALUE2(
+			"example"
+	)
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out07.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out07.java
new file mode 100644
index 0000000..3c509c4
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out07.java
@@ -0,0 +1,53 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (
+				counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0
+			) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (
+			argument1.toString().contains(argument4)
+		) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (
+			example.toString()//
+					.contains("")
+		);
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2(
+			"example"
+	)
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out08.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out08.java
new file mode 100644
index 0000000..7c9c292
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out08.java
@@ -0,0 +1,49 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (
+			Example example, String text
+	) -> {
+		do {
+			example.method1();
+		} while (
+			example.toString()//
+					.contains("")
+		);
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out09.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out09.java
new file mode 100644
index 0000000..118bf60
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out09.java
@@ -0,0 +1,57 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(
+					this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc"
+			);
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (
+			argument1.toString().contains(
+					argument4
+			)
+		) {
+			argument1.method2(
+					argument5
+			);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (
+			example.toString()//
+					.contains(
+							""
+					)
+		);
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out10.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out10.java
new file mode 100644
index 0000000..98eb4a0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out10.java
@@ -0,0 +1,48 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (
+						AutoCloseable resource = null
+				) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(
+			String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out11.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out11.java
new file mode 100644
index 0000000..ef7bfb6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out11.java
@@ -0,0 +1,48 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (
+					Exception e
+				) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)
+		) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out12.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out12.java
new file mode 100644
index 0000000..da175c7
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out12.java
@@ -0,0 +1,47 @@
+public class Example {
+	@SomeAnnotation(
+			key1 = "value1", key2 = "value2"
+	)
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out13.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out13.java
new file mode 100644
index 0000000..3bbfbe0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out13.java
@@ -0,0 +1,49 @@
+public class Example {
+	@SomeAnnotation(key1 = "value1", key2 = "value2")
+	void method1() {
+		for (
+				int counter = 0;
+				counter < 100;
+				counter++
+		) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated()
+	void method2(String argument) {
+		switch (argument) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out14.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out14.java
new file mode 100644
index 0000000..2565304
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out14.java
@@ -0,0 +1,50 @@
+public class Example {
+	@SomeAnnotation(
+			key1 = "value1", key2 = "value2"
+	)
+	void method1() {
+		for (int counter = 0; counter < 100; counter++) {
+			if (counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0) {
+				try (AutoCloseable resource = null) {
+					// read resource
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	@Deprecated(
+	)
+	void method2(String argument) {
+		switch (
+			argument
+		) {
+		case "1":
+			this.method3(this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc");
+			break;
+		}
+	}
+
+	void method3(Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6) {
+		method1();
+		while (argument1.toString().contains(argument4)) {
+			argument1.method2(argument5);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (Example example, String text) -> {
+		do {
+			example.method1();
+		} while (example.toString()//
+				.contains(""));
+	};
+	Runnable r = () -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(), VALUE2("example")
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out15.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out15.java
new file mode 100644
index 0000000..a6727e6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test370540/Example_out15.java
@@ -0,0 +1,86 @@
+public class Example {
+	@SomeAnnotation(
+			key1 = "value1", key2 = "value2"
+	)
+	void method1(
+	) {
+		for (
+				int counter = 0; counter < 100; counter++
+		) {
+			if (
+				counter % 2 == 0 && counter % 7 == 0 && counter % 13 == 0
+			) {
+				try (
+						AutoCloseable resource = null
+				) {
+					// read resource
+				} catch (
+					Exception e
+				) {
+					e.printStackTrace(
+					);
+				}
+			}
+		}
+	}
+
+	@Deprecated(
+	)
+	void method2(
+			String argument
+	) {
+		switch (
+			argument
+		) {
+		case "1":
+			this.method3(
+					this, this, this, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+					"ccccccccccccccccccc"
+			);
+			break;
+		}
+	}
+
+	void method3(
+			Example argument1, Example argument2, Example argument3, String argument4, String argument5,
+			String argument6
+	) {
+		method1(
+		);
+		while (
+			argument1.toString(
+			).contains(
+					argument4
+			)
+		) {
+			argument1.method2(
+					argument5
+			);
+		}
+	}
+
+	java.util.function.BiConsumer<Example, String> lambda = (
+			Example example, String text
+	) -> {
+		do {
+			example.method1(
+			);
+		} while (
+			example.toString(
+			)//
+					.contains(
+							""
+					)
+		);
+	};
+	Runnable r = (
+	) -> {
+	};
+}
+
+enum SomeEnum {
+	VALUE1(
+	), VALUE2(
+			"example"
+	)
+}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
index 10795cd..8d35e23 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
@@ -651,6 +651,161 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
+	 * FORMATTER / Option to position parentheses in method declarations
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_declaration"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_method_delcaration";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in method invocations
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_method_invocation";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in enum constant declarations
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_enum_constant_declaration";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in 'if' and 'while' statements
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_if_while_statement"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_if_while_statement";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in 'for' statements
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_for_statement"
+	 *     - possible values:   { COMMON_LINES,  SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_for_statment";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in 'switch' statements
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_switch_statement"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_switch_statement";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in try clauses
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_try_clause"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_try_clause";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in catch clauses
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_catch_clause"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_catch_clause";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in annotations
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_annotation";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Option to position parentheses in lambda declarations
+	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration"
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #COMMON_LINES
+	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_WRAPPED
+	 * @see #SEPARATE_LINES
+	 * @see #PRESERVE_POSITIONS
+	 * @since 3.12
+	 */
+	public static final String FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION = JavaCore.PLUGIN_ID + ".formatter.parentheses_positions_in_lambda_declaration";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
 	 * FORMATTER / Option to control whether blank lines are cleared inside comments
 	 *     - option id:         "org.eclipse.jdt.core.formatter.comment.clear_blank_lines"
 	 *     - possible values:   { TRUE, FALSE }
@@ -3991,6 +4146,98 @@ public class DefaultCodeFormatterConstants {
 	 * @since 3.0
 	 */
 	public static final String NEXT_LINE_SHIFTED = "next_line_shifted";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * </pre>
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
+	 * @since 3.12
+	 */
+	public static final String COMMON_LINES = "common_lines";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * </pre>
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
+	 * @since 3.12
+	 */
+	public static final String SEPARATE_LINES_IF_NOT_EMPY = "separate_lines_if_not_empty";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * </pre>
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
+	 * @since 3.12
+	 */
+	public static final String SEPARATE_LINES_IF_WRAPPED = "separate_lines_if_wrapped";	//$NON-NLS-1$
+	
+	/**
+	 * <pre>
+	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * </pre>
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
+	 * @since 3.12
+	 */
+	public static final String SEPARATE_LINES = "separate_lines";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
+	 * FORMATTER / Value to set a closing parenthesis position to same line or next
+	 *             line depending on what was in the original source.
+	 * </pre>
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
+	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
+	 * @since 3.12
+	 */
+	public static final String PRESERVE_POSITIONS = "preserve_positions";	//$NON-NLS-1$
+
 	/**
 	 * <pre>
 	 * FORMATTER / Value to set an option to true.
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
index 402a82b..8bc7f7c 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
@@ -153,6 +153,17 @@ public class DefaultCodeFormatterOptions {
 	public String brace_position_for_type_declaration;
 	public String brace_position_for_switch;
 
+	public String parenthesis_positions_in_method_declaration;
+	public String parenthesis_positions_in_method_invocation;
+	public String parenthesis_positions_in_enum_constant_declaration;
+	public String parenthesis_positions_in_if_while_statement;
+	public String parenthesis_positions_in_for_statement;
+	public String parenthesis_positions_in_switch_statement;
+	public String parenthesis_positions_in_try_clause;
+	public String parenthesis_positions_in_catch_clause;
+	public String parenthesis_positions_in_annotation;
+	public String parenthesis_positions_in_lambda_declaration;
+
 	public int continuation_indentation;
 	public int continuation_indentation_for_array_initializer;
 
@@ -470,6 +481,16 @@ public class DefaultCodeFormatterOptions {
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION, this.brace_position_for_type_declaration);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY, this.brace_position_for_lambda_body);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_SWITCH, this.brace_position_for_switch);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION, this.parenthesis_positions_in_method_declaration);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION, this.parenthesis_positions_in_method_invocation);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION, this.parenthesis_positions_in_enum_constant_declaration);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT, this.parenthesis_positions_in_if_while_statement);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT, this.parenthesis_positions_in_for_statement);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT, this.parenthesis_positions_in_switch_statement);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE, this.parenthesis_positions_in_try_clause);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE, this.parenthesis_positions_in_catch_clause);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION, this.parenthesis_positions_in_annotation);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION, this.parenthesis_positions_in_lambda_declaration);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_BLOCK_COMMENT, this.comment_clear_blank_lines_in_block_comment ? DefaultCodeFormatterConstants.TRUE : DefaultCodeFormatterConstants.FALSE);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_JAVADOC_COMMENT, this.comment_clear_blank_lines_in_javadoc_comment ? DefaultCodeFormatterConstants.TRUE : DefaultCodeFormatterConstants.FALSE);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_COMMENT_NEW_LINES_AT_BLOCK_BOUNDARIES, this.comment_new_lines_at_block_boundaries ? DefaultCodeFormatterConstants.TRUE : DefaultCodeFormatterConstants.FALSE);
@@ -1088,6 +1109,48 @@ public class DefaultCodeFormatterOptions {
 				this.brace_position_for_type_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 			}
 		}
+
+		final Object closingParenPositionInMethodDeclaration = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION);
+		if (closingParenPositionInMethodDeclaration != null) {
+			this.parenthesis_positions_in_method_declaration = toString(closingParenPositionInMethodDeclaration, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInMethodInvocation = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION);
+		if (closingParenPositionInMethodInvocation != null) {
+			this.parenthesis_positions_in_method_invocation = toString(closingParenPositionInMethodInvocation, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInEnumConstantDeclaration = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION);
+		if (closingParenPositionInEnumConstantDeclaration != null) {
+			this.parenthesis_positions_in_enum_constant_declaration = toString(closingParenPositionInEnumConstantDeclaration, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInIfWhileStatement = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT);
+		if (closingParenPositionInIfWhileStatement != null) {
+			this.parenthesis_positions_in_if_while_statement = toString(closingParenPositionInIfWhileStatement, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInForStatement = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT);
+		if (closingParenPositionInForStatement != null) {
+			this.parenthesis_positions_in_for_statement = toString(closingParenPositionInForStatement, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInSwitchStatement = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT);
+		if (closingParenPositionInSwitchStatement != null) {
+			this.parenthesis_positions_in_switch_statement = toString(closingParenPositionInSwitchStatement, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInTryClause = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE);
+		if (closingParenPositionInTryClause != null) {
+			this.parenthesis_positions_in_try_clause = toString(closingParenPositionInTryClause, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInCatchClause = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE);
+		if (closingParenPositionInCatchClause != null) {
+			this.parenthesis_positions_in_catch_clause = toString(closingParenPositionInCatchClause, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInAnnotation = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION);
+		if (closingParenPositionInAnnotation != null) {
+			this.parenthesis_positions_in_annotation = toString(closingParenPositionInAnnotation, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+		final Object closingParenPositionInLambdaDeclaration = settings.get(DefaultCodeFormatterConstants.FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION);
+		if (closingParenPositionInLambdaDeclaration != null) {
+			this.parenthesis_positions_in_lambda_declaration = toString(closingParenPositionInLambdaDeclaration, DefaultCodeFormatterConstants.COMMON_LINES);
+		}
+
 		final Object continuationIndentationOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_CONTINUATION_INDENTATION);
 		if (continuationIndentationOption != null) {
 			try {
@@ -2224,6 +2287,12 @@ public class DefaultCodeFormatterOptions {
 		return defaultValue;
 	}
 
+	private String toString(Object value, String defaultValue) {
+		if (value instanceof String)
+			return (String) value;
+		return defaultValue;
+	}
+
 	/**
 	 * This method is used to handle deprecated preferences which might be replaced by
 	 * one or more preferences.
@@ -2362,6 +2431,16 @@ public class DefaultCodeFormatterOptions {
 		this.brace_position_for_method_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_type_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_switch = DefaultCodeFormatterConstants.END_OF_LINE;
+		this.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_switch_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_try_clause = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_catch_clause = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
 		this.comment_clear_blank_lines_in_block_comment = false;
 		this.comment_clear_blank_lines_in_javadoc_comment = false;
 		this.comment_format_block_comment = true;
@@ -2658,6 +2737,16 @@ public class DefaultCodeFormatterOptions {
 		this.brace_position_for_method_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_type_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_switch = DefaultCodeFormatterConstants.END_OF_LINE;
+		this.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_switch_statement = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_try_clause = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_catch_clause = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.COMMON_LINES;
+		this.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.COMMON_LINES;
 		this.comment_clear_blank_lines_in_block_comment = false;
 		this.comment_clear_blank_lines_in_javadoc_comment = false;
 		this.comment_format_block_comment = true;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
index 6da6936..c661875 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
@@ -15,10 +15,12 @@ package org.eclipse.jdt.internal.formatter;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameAT;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOLON;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMA;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_JAVADOC;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameLBRACE;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameLPAREN;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRBRACE;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRPAREN;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameSEMICOLON;
-import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_JAVADOC;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameelse;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamefinally;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamepackage;
@@ -38,7 +40,9 @@ import org.eclipse.jdt.core.dom.Block;
 import org.eclipse.jdt.core.dom.BodyDeclaration;
 import org.eclipse.jdt.core.dom.BreakStatement;
 import org.eclipse.jdt.core.dom.CatchClause;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.ContinueStatement;
 import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EmptyStatement;
@@ -54,6 +58,7 @@ import org.eclipse.jdt.core.dom.LabeledStatement;
 import org.eclipse.jdt.core.dom.LambdaExpression;
 import org.eclipse.jdt.core.dom.MarkerAnnotation;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.Modifier;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
@@ -61,6 +66,8 @@ import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Statement;
+import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperMethodInvocation;
 import org.eclipse.jdt.core.dom.SwitchCase;
 import org.eclipse.jdt.core.dom.SwitchStatement;
 import org.eclipse.jdt.core.dom.TryStatement;
@@ -69,6 +76,8 @@ import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
 import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
 import org.eclipse.jdt.core.dom.WhileStatement;
 import org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
+import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 
 public class LineBreaksPreparator extends ASTVisitor {
 	final private TokenManager tm;
@@ -251,6 +260,11 @@ public class LineBreaksPreparator extends ASTVisitor {
 	public boolean visit(MethodDeclaration node) {
 		this.declarationModifierVisited = false;
 
+		int lParen = this.tm.firstIndexAfter(node.getName(), TokenNameLPAREN);
+		int rParen = node.getBody() == null ? this.tm.lastIndexIn(node, TokenNameRPAREN)
+				: this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_declaration);
+
 		if (node.getBody() == null)
 			return true;
 
@@ -346,6 +360,10 @@ public class LineBreaksPreparator extends ASTVisitor {
 				breakLineBefore(statement);
 		}
 
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_switch_statement);
+
 		return true;
 	}
 
@@ -358,6 +376,10 @@ public class LineBreaksPreparator extends ASTVisitor {
 			Token whileToken = this.tm.firstTokenBefore(node.getExpression(), TokenNamewhile);
 			whileToken.breakBefore();
 		}
+
+		int lParen = this.tm.firstIndexBefore(node.getExpression(), TokenNameLPAREN);
+		int rParen = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_if_while_statement);
 		return true;
 	}
 
@@ -405,6 +427,10 @@ public class LineBreaksPreparator extends ASTVisitor {
 	@Override
 	public boolean visit(NormalAnnotation node) {
 		handleAnnotation(node);
+
+		int lParen = this.tm.firstIndexAfter(node.getTypeName(), TokenNameLPAREN);
+		int rParen = this.tm.lastIndexIn(node, TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_annotation);
 		return true;
 	}
 
@@ -457,6 +483,15 @@ public class LineBreaksPreparator extends ASTVisitor {
 	@Override
 	public boolean visit(EnumConstantDeclaration node) {
 		this.declarationModifierVisited = false;
+
+		int lParen = this.tm.firstIndexAfter(node.getName(), -1);
+		while (this.tm.get(lParen).isComment())
+			lParen++;
+		if (this.tm.get(lParen).tokenType == TokenNameLPAREN) {	
+			int rParen = node.getAnonymousClassDeclaration() == null ? this.tm.lastIndexIn(node, TokenNameRPAREN)
+					: this.tm.firstIndexBefore(node.getAnonymousClassDeclaration(), TokenNameRPAREN);
+			handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_enum_constant_declaration);
+		}
 		return true;
 	}
 
@@ -500,18 +535,30 @@ public class LineBreaksPreparator extends ASTVisitor {
 	@Override
 	public boolean visit(WhileStatement node) {
 		handleLoopBody(node.getBody());
+
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_if_while_statement);
 		return true;
 	}
 
 	@Override
 	public boolean visit(ForStatement node) {
 		handleLoopBody(node.getBody());
+
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_for_statement);
 		return true;
 	}
 
 	@Override
 	public boolean visit(EnhancedForStatement node) {
 		handleLoopBody(node.getBody());
+
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_for_statement);
 		return true;
 	}
 
@@ -545,6 +592,10 @@ public class LineBreaksPreparator extends ASTVisitor {
 		if (!keepThenOnSameLine)
 			handleLoopBody(thenNode);
 
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_if_while_statement);
+
 		return true;
 	}
 
@@ -553,6 +604,11 @@ public class LineBreaksPreparator extends ASTVisitor {
 		if (node.getFinally() != null && this.options.insert_new_line_before_finally_in_try_statement) {
 			this.tm.firstTokenBefore(node.getFinally(), TokenNamefinally).breakBefore();
 		}
+		if (!node.resources().isEmpty()) {
+			int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+			int rParen = this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+			handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_try_clause);
+		}
 		return true;
 	}
 
@@ -560,6 +616,63 @@ public class LineBreaksPreparator extends ASTVisitor {
 	public boolean visit(CatchClause node) {
 		if (this.options.insert_new_line_before_catch_in_try_statement)
 			breakLineBefore(node);
+
+		int lParen = this.tm.firstIndexIn(node, TokenNameLPAREN);
+		int rParen = this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_catch_clause);
+		return true;
+	}
+
+	@Override
+	public boolean visit(LambdaExpression node) {
+		int lParen = this.tm.firstIndexIn(node, -1);
+		if (this.tm.get(lParen).tokenType == TokenNameLPAREN) {
+			int rParen = this.tm.firstIndexBefore(node.getBody(), TokenNameRPAREN);
+			handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_lambda_declaration);
+		}
+		return true;
+	}
+
+	@Override
+	public boolean visit(MethodInvocation node) {
+		int lParen = this.tm.firstIndexAfter(node.getName(), TokenNameLPAREN);
+		int rParen = this.tm.lastIndexIn(node, TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_invocation);
+		return true;
+	}
+
+	@Override
+	public boolean visit(SuperMethodInvocation node) {
+		int lParen = this.tm.firstIndexAfter(node.getName(), TokenNameLPAREN);
+		int rParen = this.tm.lastIndexIn(node, TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_invocation);
+		return true;
+	}
+
+	@Override
+	public boolean visit(ClassInstanceCreation node) {
+		int lParen = this.tm.firstIndexAfter(node.getType(), TokenNameLPAREN);
+		int rParen = node.getAnonymousClassDeclaration() == null ? this.tm.lastIndexIn(node, TokenNameRPAREN)
+				: this.tm.firstIndexBefore(node.getAnonymousClassDeclaration(), TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_invocation);
+		return true;
+	}
+
+	@Override
+	public boolean visit(ConstructorInvocation node) {
+		int lParen = node.arguments().isEmpty() ? this.tm.lastIndexIn(node, TokenNameLPAREN)
+				: this.tm.firstIndexBefore((ASTNode) node.arguments().get(0), TokenNameLPAREN);
+		int rParen = this.tm.lastIndexIn(node, TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_invocation);
+		return true;
+	}
+
+	@Override
+	public boolean visit(SuperConstructorInvocation node) {
+		int lParen = node.arguments().isEmpty() ? this.tm.lastIndexIn(node, TokenNameLPAREN)
+				: this.tm.firstIndexBefore((ASTNode) node.arguments().get(0), TokenNameLPAREN);
+		int rParen = this.tm.lastIndexIn(node, TokenNameRPAREN);
+		handleParenthesesPositions(lParen, rParen, this.options.parenthesis_positions_in_method_invocation);
 		return true;
 	}
 
@@ -646,6 +759,39 @@ public class LineBreaksPreparator extends ASTVisitor {
 			this.tm.get(lastIndex + 1).unindent();
 	}
 
+	private void handleParenthesesPositions(int openingParenIndex, int closingParenIndex, String positionsSetting) {
+		switch (positionsSetting) {
+			case DefaultCodeFormatterConstants.COMMON_LINES:
+				// nothing to do
+				break;
+			case DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED:
+				this.tm.get(openingParenIndex).setSeparateLinesOnWrapUntil(this.tm.get(closingParenIndex));
+				break;
+			case DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY:
+				boolean isEmpty = openingParenIndex + 1 == closingParenIndex;
+				if (isEmpty)
+					break;
+				//$FALL-THROUGH$
+			case DefaultCodeFormatterConstants.SEPARATE_LINES:
+			case DefaultCodeFormatterConstants.PRESERVE_POSITIONS:
+				boolean always = positionsSetting != DefaultCodeFormatterConstants.PRESERVE_POSITIONS;
+				Token afterOpening = this.tm.get(openingParenIndex + 1);
+				if (always || this.tm.countLineBreaksBetween(this.tm.get(openingParenIndex), afterOpening) > 0) {
+					afterOpening.setWrapPolicy(
+							new WrapPolicy(WrapMode.WHERE_NECESSARY, openingParenIndex, this.options.indentation_size));
+					afterOpening.breakBefore();
+				}
+				Token closingParen = this.tm.get(closingParenIndex);
+				if (always || this.tm.countLineBreaksBetween(this.tm.get(closingParenIndex - 1), closingParen) > 0) {
+					closingParen.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, openingParenIndex, 0));
+					closingParen.breakBefore();
+				}
+				break;
+			default:
+				throw new IllegalArgumentException("Unrecognized parentheses positions setting: " + positionsSetting); //$NON-NLS-1$
+		}
+	}
+
 	public void finishUp() {
 		// the visits only noted where indents increase and decrease,
 		// now prepare actual indent values
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
index de6cfd2..234b473 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
@@ -98,6 +98,7 @@ public class Token {
 
 	private boolean nextLineOnWrap;
 	private WrapPolicy wrapPolicy;
+	private Token separateLinesOnWrapUntil;
 
 	private Token nlsTagToken;
 
@@ -247,6 +248,14 @@ public class Token {
 		return this.nextLineOnWrap;
 	}
 
+	public void setSeparateLinesOnWrapUntil(Token token) {
+		this.separateLinesOnWrapUntil = token;
+	}
+
+	public Token getSeparateLinesOnWrapUntil() {
+		return this.separateLinesOnWrapUntil;
+	}
+
 	public void setWrapPolicy(WrapPolicy wrapPolicy) {
 		this.wrapPolicy = wrapPolicy;
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
index cb980b5..16598b1 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
@@ -110,7 +110,7 @@ public class WrapExecutor {
 		boolean lineExceeded;
 		final List<Integer> extraLinesPerComment = new ArrayList<Integer>();
 		final List<Integer> topPriorityGroupStarts = new ArrayList<Integer>();
-		int currentTopPriorityGroupEnd;
+		private int currentTopPriorityGroupEnd;
 		private boolean isNLSTagInLine;
 
 		public LineAnalyzer(TokenManager tokenManager, DefaultCodeFormatterOptions options) {
@@ -319,15 +319,24 @@ public class WrapExecutor {
 		index++;
 		token.setIndent(indent);
 		int groupEnd = token.getWrapPolicy() != null ? token.getWrapPolicy().groupEndIndex : -1;
+		int separateLinesOnWrapFrom = -1;
 		while (index < this.tm.size()) {
 			token = this.tm.get(index);
 			if (token.isNextLineOnWrap() && this.tm.get(this.tm.findFirstTokenInLine(index)).isWrappable()) {
 				token.breakBefore();
 				return index;
 			}
+			if (separateLinesOnWrapFrom >= 0
+					&& token == this.tm.get(separateLinesOnWrapFrom).getSeparateLinesOnWrapUntil()) {
+				separateLinesOnWrapFrom = -1;
+			}
+			if (separateLinesOnWrapFrom == -1 && token.getSeparateLinesOnWrapUntil() != null) {
+				separateLinesOnWrapFrom = index;
+			}
 			while (wrapInfo != null && wrapInfo.wrapTokenIndex < index)
 				wrapInfo = this.wrapSearchResults.get(wrapInfo).nextWrap;
 			if (wrapInfo != null && wrapInfo.wrapTokenIndex == index) {
+				checkSeparateLinesOnWrap(separateLinesOnWrapFrom);
 				token.breakBefore();
 				handleOnColumnIndent(index, token.getWrapPolicy());
 				checkTopPriorityWraps(index);
@@ -338,6 +347,7 @@ public class WrapExecutor {
 			boolean isNewLine = this.tm.get(index - 1).getLineBreaksAfter() > 0 || token.getLineBreaksBefore() > 0;
 			if (isNewLine) {
 				if (token.getWrapPolicy() != null) {
+					checkSeparateLinesOnWrap(separateLinesOnWrapFrom);
 					handleOnColumnIndent(index, token.getWrapPolicy());
 					checkTopPriorityWraps(index);
 					int newIndent = getWrapIndent(token);
@@ -426,7 +436,7 @@ public class WrapExecutor {
 
 		if ((!lineExceeded || firstPotentialWrap < 0) && lastIndex + 1 < this.tm.size()) {
 			Token nextLineToken = this.tm.get(lastIndex + 1);
-			if ((nextLineToken.getWrapPolicy() != null && nextLineToken.getWrapPolicy().wrapMode != WrapMode.FORCED)
+			if (nextLineToken.getWrapPolicy() != null && nextLineToken.getWrapPolicy().wrapMode != WrapMode.FORCED
 					&& (this.tm.get(lastIndex).isComment() || nextLineToken.isComment())) {
 				// this might be a pre-existing wrap forced by a comment, calculate penalties as normal
 				bestIndent = getWrapIndent(nextLineToken);
@@ -565,6 +575,26 @@ public class WrapExecutor {
 		return Math.exp(policy.structureDepth) * policy.penaltyMultiplier;
 	}
 
+	private void checkSeparateLinesOnWrap(final int separateLinesOnWrapFrom) throws WrapRestartThrowable {
+		if (separateLinesOnWrapFrom < 0)
+			return;
+		Token next = this.tm.get(separateLinesOnWrapFrom + 1);
+		Token end = this.tm.get(separateLinesOnWrapFrom).getSeparateLinesOnWrapUntil();
+		if (next.getLineBreaksBefore() > 0 && end.getLineBreaksBefore() > 0)
+			return;
+
+		if (next.getWrapPolicy() == null || next.getWrapPolicy().wrapMode == WrapMode.FORCED) {
+			next.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, separateLinesOnWrapFrom,
+					this.options.indentation_size));
+		}
+		next.breakBefore();
+		if (end.getWrapPolicy() == null || end.getWrapPolicy().wrapMode == WrapMode.FORCED) {
+			end.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, separateLinesOnWrapFrom, 0));
+		}
+		end.breakBefore();
+		throw new WrapRestartThrowable(-1);
+	}
+
 	private void checkForceWrap(Token token, int index, int currentIndent) throws WrapRestartThrowable {
 		// A token that will have smaller indent when wrapped than the current line indent,
 		// should be wrapped because it's a low depth token following some complex wraps of higher depth.
commit a8b6a8d76efee58d7c7ebb7b8172e6680af4ebc2
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Wed Apr 20 23:23:57 2016 +0200

    Bug 370540 - [Formatter] New settings for parentheses positions - Javadoc mistakes fixed

21	21	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
index f04438d..4529da7 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
@@ -688,7 +688,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in method declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_declaration"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_NOT_EMPY
@@ -704,7 +704,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in method invocations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_NOT_EMPY
@@ -720,7 +720,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in enum constant declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_NOT_EMPY
@@ -736,7 +736,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in 'if' and 'while' statements
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_if_while_statement"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_WRAPPED
@@ -751,7 +751,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in 'for' statements
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_for_statement"
 	 *     - possible values:   { COMMON_LINES,  SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_WRAPPED
@@ -766,7 +766,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in 'switch' statements
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_switch_statement"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_WRAPPED
@@ -781,7 +781,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in try clauses
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_try_clause"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_WRAPPED
@@ -796,7 +796,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in catch clauses
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_catch_clause"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_WRAPPED
@@ -811,7 +811,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in annotations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_NOT_EMPY
@@ -827,7 +827,7 @@ public class DefaultCodeFormatterConstants {
 	 * FORMATTER / Option to position parentheses in lambda declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration"
 	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
-	 *     - default:           END_OF_LINE
+	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
 	 * @see #SEPARATE_LINES_IF_NOT_EMPY
@@ -4183,7 +4183,8 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
-	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * FORMATTER / Value to set opening and closing parentheses location in common lines with
+	 *             their contents (or simply a single line if the parentheses are empty).
 	 * </pre>
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
@@ -4201,16 +4202,12 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
-	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * FORMATTER / Value to set opening and closing parentheses location on a common line
+	 *             if the parentheses are empty and otherwise in separate lines from their contents.
 	 * </pre>
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ENUM_CONSTANT_DECLARATION
-	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_IF_WHILE_STATEMENT
-	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_FOR_STATEMENT
-	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_SWITCH_STATEMENT
-	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_TRY_CLAUSE
-	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_CATCH_CLAUSE
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_ANNOTATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
 	 * @since 3.12
@@ -4219,7 +4216,8 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
-	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * FORMATTER / Value to set opening and closing parentheses location on separate lines from their
+	 *             contents if the contents are wrapped, and in common line if they fit in line width.
 	 * </pre>
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
@@ -4237,7 +4235,9 @@ public class DefaultCodeFormatterConstants {
 	
 	/**
 	 * <pre>
-	 * FORMATTER / Value to keep always parentheses on common lines with their contents..
+	 * FORMATTER / Value to set parentheses location on separate lines from their contents,
+	 *             that is put a line break after the opening parenthesis and before
+	 *             the closing parenthesis.
 	 * </pre>
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
@@ -4255,8 +4255,8 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
-	 * FORMATTER / Value to set a closing parenthesis position to same line or next
-	 *             line depending on what was in the original source.
+	 * FORMATTER / Value to set opening and closing parentheses location to be preserved
+	 *             from the original source.
 	 * </pre>
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_DECLARATION
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_METHOD_INVOCATION
commit 9acb9fa15df23002caee282c972b7a5d0b9fdb55
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Wed Apr 20 23:23:57 2016 +0200

    Bug 370540 - [Formatter] New settings for parentheses positions - typo fixed

6	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
11	11	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
1	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index 8b5bab0..777ba9f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -13588,7 +13588,7 @@ public void testBug370540a() throws JavaModelException {
  */
 public void testBug370540b() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
-	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_method_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out02.java").getSource());
 }
@@ -13615,7 +13615,7 @@ public void testBug370540d() throws JavaModelException {
  */
 public void testBug370540e() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
-	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out05.java").getSource());
 }
@@ -13634,7 +13634,7 @@ public void testBug370540f() throws JavaModelException {
  */
 public void testBug370540g() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
-	this.formatterPrefs.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_enum_constant_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out07.java").getSource());
@@ -13645,7 +13645,7 @@ public void testBug370540g() throws JavaModelException {
 public void testBug370540h() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
 	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
-	this.formatterPrefs.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_lambda_declaration = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out08.java").getSource());
 }
@@ -13655,7 +13655,7 @@ public void testBug370540h() throws JavaModelException {
 public void testBug370540i() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
 	this.formatterPrefs.parenthesis_positions_in_if_while_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
-	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_method_invocation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out09.java").getSource());
 }
@@ -13685,7 +13685,7 @@ public void testBug370540k() throws JavaModelException {
 public void testBug370540l() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_1_8);
 	this.formatterPrefs.parenthesis_positions_in_for_statement = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED;
-	this.formatterPrefs.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY;
+	this.formatterPrefs.parenthesis_positions_in_annotation = DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY;
 	String input = getCompilationUnit("Formatter", "", "test370540", "Example_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test370540", "Example_out12.java").getSource());
 }
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
index 4529da7..adb1566 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
@@ -687,11 +687,11 @@ public class DefaultCodeFormatterConstants {
 	 * <pre>
 	 * FORMATTER / Option to position parentheses in method declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_declaration"
-	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPTY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
 	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
-	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_NOT_EMPTY
 	 * @see #SEPARATE_LINES_IF_WRAPPED
 	 * @see #SEPARATE_LINES
 	 * @see #PRESERVE_POSITIONS
@@ -703,11 +703,11 @@ public class DefaultCodeFormatterConstants {
 	 * <pre>
 	 * FORMATTER / Option to position parentheses in method invocations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation"
-	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPTY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
 	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
-	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_NOT_EMPTY
 	 * @see #SEPARATE_LINES_IF_WRAPPED
 	 * @see #SEPARATE_LINES
 	 * @see #PRESERVE_POSITIONS
@@ -719,11 +719,11 @@ public class DefaultCodeFormatterConstants {
 	 * <pre>
 	 * FORMATTER / Option to position parentheses in enum constant declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration"
-	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPTY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
 	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
-	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_NOT_EMPTY
 	 * @see #SEPARATE_LINES_IF_WRAPPED
 	 * @see #SEPARATE_LINES
 	 * @see #PRESERVE_POSITIONS
@@ -810,11 +810,11 @@ public class DefaultCodeFormatterConstants {
 	 * <pre>
 	 * FORMATTER / Option to position parentheses in annotations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation"
-	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPTY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
 	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
-	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_NOT_EMPTY
 	 * @see #SEPARATE_LINES_IF_WRAPPED
 	 * @see #SEPARATE_LINES
 	 * @see #PRESERVE_POSITIONS
@@ -826,11 +826,11 @@ public class DefaultCodeFormatterConstants {
 	 * <pre>
 	 * FORMATTER / Option to position parentheses in lambda declarations
 	 *     - option id:         "org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration"
-	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
+	 *     - possible values:   { COMMON_LINES, SEPARATE_LINES_IF_NOT_EMPTY, SEPARATE_LINES_IF_WRAPPED, SEPARATE_LINES, PRESERVE_POSITIONS }
 	 *     - default:           COMMON_LINES
 	 * </pre>
 	 * @see #COMMON_LINES
-	 * @see #SEPARATE_LINES_IF_NOT_EMPY
+	 * @see #SEPARATE_LINES_IF_NOT_EMPTY
 	 * @see #SEPARATE_LINES_IF_WRAPPED
 	 * @see #SEPARATE_LINES
 	 * @see #PRESERVE_POSITIONS
@@ -4212,7 +4212,7 @@ public class DefaultCodeFormatterConstants {
 	 * @see #FORMATTER_PARENTHESES_POSITIONS_IN_LAMBDA_DECLARATION
 	 * @since 3.12
 	 */
-	public static final String SEPARATE_LINES_IF_NOT_EMPY = "separate_lines_if_not_empty";	//$NON-NLS-1$
+	public static final String SEPARATE_LINES_IF_NOT_EMPTY = "separate_lines_if_not_empty";	//$NON-NLS-1$
 
 	/**
 	 * <pre>
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
index 7364c8e..24e59f0 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
@@ -751,7 +751,7 @@ public class LineBreaksPreparator extends ASTVisitor {
 			case DefaultCodeFormatterConstants.SEPARATE_LINES_IF_WRAPPED:
 				this.tm.get(openingParenIndex).setSeparateLinesOnWrapUntil(this.tm.get(closingParenIndex));
 				break;
-			case DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPY:
+			case DefaultCodeFormatterConstants.SEPARATE_LINES_IF_NOT_EMPTY:
 				boolean isEmpty = openingParenIndex + 1 == closingParenIndex;
 				if (isEmpty)
 					break;
