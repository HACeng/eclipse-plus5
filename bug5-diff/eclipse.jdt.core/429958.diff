commit 43cdae5117454d896e9e9cf435f63b0b509e3a4c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Mar 11 20:31:20 2014 +0100

    Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of
    @NonNullByDefault

111	11	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
493	25	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
7	5	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnParameterizedQualifiedTypeReference.java
7	5	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedQualifiedTypeReference.java
7	5	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedSingleTypeReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
88	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocImplicitTypeReference.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocQualifiedTypeReference.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocSingleTypeReference.java
16	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
8	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
13	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
31	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
11	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
151	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
113	38	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
40	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
29	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ElementValuePair.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
12	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
46	29	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
7	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
7	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
23	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
7	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
86	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 89b1b44..ffe997b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -2477,6 +2477,68 @@ public void test_default_nullness_003b() {
 		mismatch_NonNull_Nullable("Object") +
 		"----------\n");
 }
+// package level default is consumed from package-info.class, similarly for type level default - fine tuned default
+public void test_default_nullness_003c() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_8) return; // uses version 2.0 of @NonNullByDefault
+	Map customOptions = getCompilerOptions();
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected Object getObject(@Nullable Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"	 protected void bar(Object o2) { }\n" + // parameter is nonnull per type default
+			"}\n",
+	"p2/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault({org.eclipse.jdt.annotation.DefaultLocation.PARAMETER})\n" +
+			"package p2;\n",
+			},
+			customOptions,
+			"");
+	// check if default is visible from package-info.class.
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    protected @Nullable Object getObject(@Nullable Object o) {\n" + // can't override inherited default nonnull
+			"        bar(o);\n" + // parameter is nonnull in super class's .class file
+			"        @NonNull Object nno = accept(o); // 2xERR\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"    Object accept(Object a) { return a; }\n" + // governed by package level default (only the parameter!)
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p2\\Y.java (at line 5)\n" + 
+		"	protected @Nullable Object getObject(@Nullable Object o) {\n" + 
+		"	          ^^^^^^^^^^^^^^^^\n" + 
+		"The return type is incompatible with the @NonNull return from X.getObject(Object)\n" + 
+		"----------\n" + 
+		"2. ERROR in p2\\Y.java (at line 6)\n" + 
+		"	bar(o);\n" + 
+		"	    ^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Object\' but this expression has type \'@Nullable Object\'\n" + 
+		"----------\n" + 
+		"3. WARNING in p2\\Y.java (at line 7)\n" + 
+		"	@NonNull Object nno = accept(o); // 2xERR\n" + 
+		"	                      ^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'Object\' needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
+		"----------\n" + 
+		"4. ERROR in p2\\Y.java (at line 7)\n" + 
+		"	@NonNull Object nno = accept(o); // 2xERR\n" + 
+		"	                             ^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Object\' but this expression has type \'@Nullable Object\'\n" + 
+		"----------\n");
+}
 // don't apply type-level default to non-reference type
 public void test_default_nullness_004() {
 	Map customOptions = getCompilerOptions();
@@ -5987,7 +6049,7 @@ public void testBug388281_08() {
 			"package ctest;\n" +
 			"import org.eclipse.jdt.annotation.*;\n" +
 			"@NonNullByDefault\n" +
-			"public class Ctest implements i2.II {\n" +
+			"public class Ctest implements i2.II {\n" + // note: i2.II.m1(Object,Object) actually has a bug itself: conflicting default & inherited annotations
 			"    public Object m1(@Nullable Object a1) { // silent: conflict at a1 avoided\n" + 
 			"		return new Object();\n" + 
 			"    }\n" + 
@@ -6317,7 +6379,10 @@ public void testBug412076() {
 		new String[] {
 			"FooImpl.java",
 			"import org.eclipse.jdt.annotation.*;\n" +
-			"@NonNullByDefault\n" + 
+			(this.complianceLevel < ClassFileConstants.JDK1_8
+			? "@NonNullByDefault\n"
+			: "@NonNullByDefault({DefaultLocation.PARAMETER,DefaultLocation.RETURN_TYPE})\n" // avoid @NonNull on type argument <String>
+			) + 
 			"public class FooImpl implements Foo<String> {\n" + 
 			"  public String bar(final String... values) {\n" + 
 			"    return (\"\");\n" + 
@@ -6710,9 +6775,9 @@ public void testBug418843() {
 		"----------\n");
 }
 public void testBug418235() {
-    runNegativeTestWithLibs(
+	String[] testFiles = 
             new String[] {
-                    "GenericInterface.java",
+                    "GenericInterface.java", 
                     "public interface GenericInterface<T> {\n" + 
                     "       T doSomethingGeneric(T o);\n" + 
                     "}",
@@ -6726,13 +6791,48 @@ public void testBug418235() {
                     "               return o;\n" + 
                     "       }\n" + 
                     "}\n"
-            },
-            "----------\n" + 
-            "1. ERROR in Implementation.java (at line 6)\n" + 
-    		"	public Object doSomethingGeneric(Object o) {\n" + 
-    		"	                                 ^^^^^^\n" + 
-            "Illegal redefinition of parameter o, inherited method from GenericInterface<Object> does not constrain this parameter\n" + 
-            "----------\n");
+			};
+	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
+	    runNegativeTestWithLibs(
+	            testFiles,
+	            "----------\n" + 
+	            "1. ERROR in Implementation.java (at line 6)\n" + 
+	    		"	public Object doSomethingGeneric(Object o) {\n" + 
+	    		"	                                 ^^^^^^\n" + 
+	            "Illegal redefinition of parameter o, inherited method from GenericInterface<Object> does not constrain this parameter\n" + 
+	            "----------\n");
+	} else {
+		// in 1.8 the nullness default also affects the type argument <Object> from which T is instantiated to '@NonNull Object'
+		runConformTestWithLibs(
+				testFiles, getCompilerOptions(), "");
+	}
+}
+public void testBug418235b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_8)
+		return;
+	runNegativeTestWithLibs(
+	        new String[] {
+			    "GenericInterface.java", 
+			    "public interface GenericInterface<T> {\n" + 
+				"       T doSomethingGeneric(T o);\n" + 
+				"}",
+			    "Implementation.java",
+			    "import org.eclipse.jdt.annotation.*;\n" + 
+				"@NonNullByDefault({DefaultLocation.PARAMETER,DefaultLocation.RETURN_TYPE})\n" + 
+				"public class Implementation implements GenericInterface<Object> {\n" + 
+				"\n" + 
+				"      @Override\n" +
+				"       public Object doSomethingGeneric(Object o) {\n" + 
+				"               return o;\n" + 
+				"       }\n" + 
+				"}\n"
+			},
+	        "----------\n" + 
+	        "1. ERROR in Implementation.java (at line 6)\n" + 
+			"	public Object doSomethingGeneric(Object o) {\n" + 
+			"	                                 ^^^^^^\n" + 
+	        "Illegal redefinition of parameter o, inherited method from GenericInterface<Object> does not constrain this parameter\n" + 
+	        "----------\n");
 }
 
 public void testTypeAnnotationProblemNotIn17() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 85b8180..9561376 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -4300,31 +4300,6 @@ public void test429387() {
 		"IntStreamy cannot be resolved\n" + 
 		"----------\n");
 }
-public void testBug392245_tmp_warning() {
-	runNegativeTestWithLibs(
-		new String[] {
-			"X.java",
-			"import org.eclipse.jdt.annotation.*;\n" +
-			"@NonNullByDefault(DefaultLocation.TYPE_ARGUMENT)\n" +
-			"public class X {\n" +
-			"	void m(Object o) {}\n" +
-			"	void test() {\n" +
-			"		m(null); // ERR\n" + // since @NonNullByDefault is still interpreted as all or nothing
-			"	}\n" +
-			"}\n"
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 2)\n" + 
-		"	@NonNullByDefault(DefaultLocation.TYPE_ARGUMENT)\n" + 
-		"	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"Arguments controling the details of the nullness default are not yet evaluated by the analysis.\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 6)\n" + 
-		"	m(null); // ERR\n" + 
-		"	  ^^^^\n" + 
-		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
-		"----------\n");
-}
 public void testBug429403() {
 	runNegativeTestWithLibs(
 		new String[] {
@@ -4375,4 +4350,497 @@ public void testBug430219a() {
         getCompilerOptions(),
         "");
 }
+
+// apply null default to type arguments:
+public void testDefault01() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_ARGUMENT)\n" +
+			"public class X {\n" +
+			"	List<Number> test1(List<Number> in) {\n" +
+			"		in.add(null); // ERR\n" +
+			"		return new ArrayList<@Nullable Number>(); // ERR\n" +
+			"	}\n" +
+			"	java.util.List<java.lang.Number> test2(java.util.List<java.lang.Number> in) {\n" +
+			"		in.add(null); // ERR\n" +
+			"		return new ArrayList<java.lang.@Nullable Number>(); // ERR\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	in.add(null); // ERR\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	return new ArrayList<@Nullable Number>(); // ERR\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'List<@NonNull Number>\' but this expression has type \'ArrayList<@Nullable Number>\', corresponding supertype is \'List<@Nullable Number>\'\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 10)\n" + 
+		"	in.add(null); // ERR\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	return new ArrayList<java.lang.@Nullable Number>(); // ERR\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'List<@NonNull Number>\' but this expression has type \'ArrayList<@Nullable Number>\', corresponding supertype is \'List<@Nullable Number>\'\n" + 
+		"----------\n");
+}
+
+// apply null default to type arguments - no effect on type variable or wildcard:
+public void testDefault01b() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_ARGUMENT)\n" +
+			"public class X<T> {\n" +
+			"	List<T> test(List<? extends Number> in) {\n" +
+			"		in.add(null); // OK\n" +
+			"		return new ArrayList<@Nullable T>();\n" + // TODO: unannotated type variable should be regarded as 'could be either'
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+}
+
+// apply null default to parameters:
+public void testDefault02() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault(DefaultLocation.PARAMETER)\n" +
+			"public class X {\n" +
+			"	Number test1(Number in) {\n" +
+			"		System.out.print(in.intValue()); // OK\n" +
+			"		test1(null); // ERR\n" +
+			"		return null; // OK\n" +
+			"	}\n" +
+			"	java.lang.Number test2(java.lang.Number in) {\n" +
+			"		System.out.print(in.intValue()); // OK\n" +
+			"		test2(null); // ERR\n" +
+			"		return null; // OK\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	test1(null); // ERR\n" + 
+		"	      ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	test2(null); // ERR\n" + 
+		"	      ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+// apply null default to return type - annotation at method:
+public void testDefault03() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"	Number test(Number in) {\n" +
+			"		System.out.print(in.intValue());\n" +
+			"		test(null); // OK\n" +
+			"		return null; // ERR\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	return null; // ERR\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+// apply null default to field
+public void testDefault04() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault(DefaultLocation.FIELD)\n" +
+			"public class X {\n" +
+			"	Number field; // ERR since uninitialized\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	Number field; // ERR since uninitialized\n" + 
+		"	       ^^^^^\n" + 
+		"The @NonNull field field may not have been initialized\n" + 
+		"----------\n");
+}
+
+// default default
+public void testDefault05() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"	Number field; // ERR since uninitialized\n" +
+			"	void test1(Number[] ns) {\n" +
+			"		ns[0] = null; // OK since not affected by default\n" +
+			"	}\n" +
+			"	void test2(java.lang.Number[] ns) {\n" +
+			"		ns[0] = null; // OK since not affected by default\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	Number field; // ERR since uninitialized\n" + 
+		"	       ^^^^^\n" + 
+		"The @NonNull field field may not have been initialized\n" + 
+		"----------\n");
+}
+
+// apply default to type parameter - inner class
+public void testDefault06() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_PARAMETER)\n" +
+			"public class X {\n" +
+			"	class Inner<T> {\n" +
+			"		T process(T t) {\n" +
+			"			@NonNull T t2 = t; // OK\n" +
+			"			return null; // ERR\n" +
+			" 		}\n" +
+			"	}\n" +
+			"	void test(Inner<Number> inum) {\n" +
+			"		@NonNull Number nnn = inum.process(null); // ERR on argument\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	return null; // ERR\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull T\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	@NonNull Number nnn = inum.process(null); // ERR on argument\n" + 
+		"	                                   ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+// apply default to type bound - method in inner class
+public void testDefault07() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_BOUND)\n" +
+			"public class X {\n" +
+			"	class Inner {\n" +
+			"		<T extends Number> T process(T t, List<? extends Number> l) {\n" +
+			"			@NonNull T t2 = t; // OK\n" +
+			"			@NonNull Number n = l.get(0); // OK\n" +
+			"			return null; // ERR\n" +
+			" 		}\n" +
+			"	}\n" +
+			"	void test(Inner inner) {\n" +
+			"		@NonNull Number nnn = inner.process(Integer.MAX_VALUE, new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	return null; // ERR\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'T extends @NonNull Number\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 13)\n" + 
+		"	@NonNull Number nnn = inner.process(Integer.MAX_VALUE, new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" + 
+		"	                                    ^^^^^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'int\' needs unchecked conversion to conform to \'@NonNull Integer\'\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 13)\n" + 
+		"	@NonNull Number nnn = inner.process(Integer.MAX_VALUE, new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" + 
+		"	                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'List<? extends @NonNull Number>\' but this expression has type \'ArrayList<@Nullable Integer>\', corresponding supertype is \'List<@Nullable Integer>\'\n" + 
+		"----------\n");
+}
+
+//apply null default to type arguments:
+public void testDefault01_bin() {
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"import java.util.*;\n" +
+				"import java.lang.annotation.*;\n" +
+				"\n" +
+				"@Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.CLASS) @interface Important {}\n" +
+				"\n" +
+				"@NonNullByDefault(DefaultLocation.TYPE_ARGUMENT)\n" +
+				"public class X {\n" +
+				"	List<Number> test1(List<@Important Number> in) {\n" +
+				"		return new ArrayList<@NonNull Number>();\n" +
+				"	}\n" +
+				"}\n"
+			},
+			getCompilerOptions(),
+			"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"public class Y {\n" +
+			"	void test(List<Number> in, X x) {\n" +
+			"		x.test1(new ArrayList<@Nullable Number>()) // ERR at arg\n" +
+			"			.add(null); // ERR\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in Y.java (at line 5)\n" + 
+		"	x.test1(new ArrayList<@Nullable Number>()) // ERR at arg\n" + 
+		"	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'List<@NonNull Number>\' but this expression has type \'ArrayList<@Nullable Number>\', corresponding supertype is \'List<@Nullable Number>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in Y.java (at line 6)\n" + 
+		"	.add(null); // ERR\n" + 
+		"	     ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+//apply null default to parameters:
+public void testDefault02_bin() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault(DefaultLocation.PARAMETER)\n" +
+			"public class X {\n" +
+			"	Number test1(Number in) {\n" +
+			"		return null; // OK\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"	@NonNull Number test(X x) {\n" +
+			"		return x.test1(null); // error at arg, unchecked at return\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. WARNING in Y.java (at line 4)\n" + 
+		"	return x.test1(null); // error at arg, unchecked at return\n" + 
+		"	       ^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'Number\' needs unchecked conversion to conform to \'@NonNull Number\'\n" + 
+		"----------\n" + 
+		"2. ERROR in Y.java (at line 4)\n" + 
+		"	return x.test1(null); // error at arg, unchecked at return\n" + 
+		"	               ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+//apply null default to return type - annotation at method:
+public void testDefault03_bin() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"	Number test(Number in) {\n" +
+			"		return new Integer(13);\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runConformTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"	@NonNull Number test(X x) {\n" +
+			"		return x.test(null); // both OK\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+}
+
+// apply null default to field - also test mixing of explicit annotation with default @NonNull (other annot is not rendered in error)
+public void testDefault04_bin() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Target(ElementType.TYPE_USE) @Retention(RetentionPolicy.CLASS) @interface Important {}\n" +
+			"@NonNullByDefault(DefaultLocation.FIELD)\n" +
+			"public class X {\n" +
+			"	@Important Number field = new Double(1.1d);\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"public class Y {\n" +
+			"	void test(X x) {\n" +
+			"		x.field = null; // ERR\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in Y.java (at line 3)\n" + 
+		"	x.field = null; // ERR\n" + 
+		"	          ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");}
+
+// default default
+public void testDefault05_bin() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"	Number field = new Long(13);\n" +
+			"	void test1(Number[] ns) {\n" +
+			"		ns[0] = null; // OK since not affected by default\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"	void test(X x, @Nullable Number @NonNull[] ns) {\n" +
+			"		x.test1(ns); // OK since not affected by default\n" +
+			"		x.field = null; // ERR\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in Y.java (at line 5)\n" + 
+		"	x.field = null; // ERR\n" + 
+		"	          ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");}
+
+// apply default to type parameter - inner class
+public void testDefault06_bin() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_PARAMETER)\n" +
+			"public class X {\n" +
+			"	static class Inner<T> {\n" +
+			"		T process(T t) {\n" +
+			"			return t;\n" +
+			" 		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"	void test(X.Inner<Number> inum) {\n" +
+			"		@NonNull Number nnn = inum.process(null); // ERR on argument\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in Y.java (at line 4)\n" + 
+		"	@NonNull Number nnn = inum.process(null); // ERR on argument\n" + 
+		"	                                   ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Number\' but the provided value is null\n" + 
+		"----------\n");}
+
+// apply default to type bound - method in inner class
+public void testDefault07_bin() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"@NonNullByDefault(DefaultLocation.TYPE_BOUND)\n" +
+			"public class X {\n" +
+			"	static class Inner {\n" +
+			"		<T extends Number> T process(T t, List<? extends Number> l) {\n" +
+			"			return t;\n" +
+			" 		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"");
+	runNegativeTestWithLibs(
+		new String[] {
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import java.util.*;\n" +
+			"public class Y {\n" +
+			"	void test(X.Inner inner) {\n" +
+			"		@NonNull Number nnn = inner.process(Integer.MAX_VALUE, new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" +
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" +  // FIXME: this should not be a warning, a case of unrecognized boxing
+		"1. WARNING in Y.java (at line 5)\n" + 
+		"	@NonNull Number nnn = inner.process(Integer.MAX_VALUE, new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" + 
+		"	                                    ^^^^^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'int\' needs unchecked conversion to conform to \'@NonNull Integer\'\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnParameterizedQualifiedTypeReference.java
index 487813c..7a9f66e 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnParameterizedQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2009 IBM Corporation and others.
+ * Copyright (c) 2004, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist.complete;
 
@@ -76,13 +78,13 @@ public class CompletionOnParameterizedQualifiedTypeReference extends Parameteriz
 		return this.kind == K_CLASS || this.kind == K_INTERFACE;
 	}
 
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-		super.resolveType(scope, checkBounds);
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+		super.resolveType(scope, checkBounds, location);
 		throw new CompletionNodeFound(this, this.resolvedType, scope);
 	}
 
-	public TypeBinding resolveType(ClassScope scope) {
-		super.resolveType(scope);
+	public TypeBinding resolveType(ClassScope scope, int location) {
+		super.resolveType(scope, location);
 		throw new CompletionNodeFound(this, this.resolvedType, scope);
 	}
 
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedQualifiedTypeReference.java
index fa26161..ffe9b99 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist.select;
 
@@ -29,8 +31,8 @@ public class SelectionOnParameterizedQualifiedTypeReference extends Parameterize
 		this.typeArguments[length] = assistTypeArguments;
 	}
 
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-		super.resolveType(scope, checkBounds);
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+		super.resolveType(scope, checkBounds, location);
 		//// removed unnecessary code to solve bug 94653
 		//if(this.resolvedType != null && this.resolvedType.isRawType()) {
 		//	ParameterizedTypeBinding parameterizedTypeBinding = scope.createParameterizedType(((RawTypeBinding)this.resolvedType).type, new TypeBinding[0], this.resolvedType.enclosingType());
@@ -39,8 +41,8 @@ public class SelectionOnParameterizedQualifiedTypeReference extends Parameterize
 		throw new SelectionNodeFound(this.resolvedType);
 	}
 
-	public TypeBinding resolveType(ClassScope scope) {
-		super.resolveType(scope);
+	public TypeBinding resolveType(ClassScope scope, int location) {
+		super.resolveType(scope, location);
 		//// removed unnecessary code to solve bug 94653
 		//if(this.resolvedType != null && this.resolvedType.isRawType()) {
 		//	ParameterizedTypeBinding parameterizedTypeBinding = scope.createParameterizedType(((RawTypeBinding)this.resolvedType).type, new TypeBinding[0], this.resolvedType.enclosingType());
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedSingleTypeReference.java
index 57f749a..7be0d7a 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnParameterizedSingleTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist.select;
 
@@ -21,13 +23,13 @@ public class SelectionOnParameterizedSingleTypeReference extends ParameterizedSi
 		super(name, typeArguments, 0, pos);
 	}
 
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-		super.resolveType(scope, checkBounds);
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+		super.resolveType(scope, checkBounds, location);
 		throw new SelectionNodeFound(this.resolvedType);
 	}
 
-	public TypeBinding resolveType(ClassScope scope) {
-		super.resolveType(scope);
+	public TypeBinding resolveType(ClassScope scope, int location) {
+		super.resolveType(scope, location);
 		throw new SelectionNodeFound(this.resolvedType);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index a5959dd..b66d422 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1777,7 +1777,7 @@ void setSourceStart(int sourceStart);
 	/** @since 3.10 */
 	int UnsafeNullnessCast = Internal + 967;
 	/** @since 3.10 */
-	int NonNullDefaultDetailIsNotEvaluated = 968;
+	int NonNullDefaultDetailIsNotEvaluated = 968; // no longer reported
 
 	// Java 8 work
 	/** @since 3.10 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 7c38a98..b20877c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -18,6 +18,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 424728 - [1.8][null] Unexpected error: The nullness annotation 'XXXX' is not applicable at this location
  *								Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409517 - [1.8][compiler] Type annotation problems on more elaborate array references
@@ -36,6 +37,7 @@ import java.util.Stack;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
@@ -304,7 +306,8 @@ public abstract class Annotation extends Expression {
 	}
 
 	/**
-	 * Compute the bit pattern for recognized standard annotations the compiler may need to act upon
+	 * Compute the bit pattern for recognized standard annotations the compiler may need to act upon.
+	 * The lower bits (Binding.NullnessDefaultMASK) do not belong in tagBits, but in defaultNullness.
 	 */
 	private long detectStandardAnnotation(Scope scope, ReferenceBinding annotationType, MemberValuePair valueAttribute) {
 		long tagBits = 0;
@@ -388,28 +391,98 @@ public abstract class Annotation extends Expression {
 				tagBits |= TagBits.AnnotationNonNull;
 				break;
 			case TypeIds.T_ConfiguredAnnotationNonNullByDefault :
+				// seeing this id implies that null annotation analysis is enabled
+				Object value = null;
 				if (valueAttribute != null) {
 					if (valueAttribute.value instanceof FalseLiteral) {
 						// parameter 'false' means: this annotation cancels any defaults
 						tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
 						break;
 					} else if (valueAttribute.compilerElementPair != null) {
-						Object value = valueAttribute.compilerElementPair.value;
-						if (value instanceof Object[] && ((Object[])value).length == 0) {
-							// empty parameter means: this annotation cancels any defaults
-							tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-							break;
-						} else {
-							scope.problemReporter().nonNullDefaultDetailNotEvaluated(valueAttribute);
-						}
+						value = valueAttribute.compilerElementPair.value;
+					}
+				} else if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) { // fetch default value  - TODO: cache it?
+					MethodBinding[] methods = annotationType.methods();
+					if (methods != null && methods.length == 1) {
+						Object defaultValue = methods[0].getDefaultValue();
+						if (defaultValue instanceof Object[])
+							value = defaultValue;
 					}
 				}
-				tagBits |= TagBits.AnnotationNonNullByDefault;
+				if (value != null) {
+					tagBits |= nullTagBitsFromAnnotationValue(value);
+				} else {
+					// neither explicit value, nor default value from DefaultLocation (1.8)
+					tagBits |= TagBits.AnnotationNonNullByDefault;
+				}
 				break;
 		}
 		return tagBits;
 	}
 
+	/**
+	 * Convert the value() attribute of @NonNullByDefault into a bitvector a la {@link Binding#NullnessDefaultMASK}.
+	 * This method understands value encodings from source and binary types.
+	 * 
+	 * <b>pre:</b> null annotation analysis is enabled
+	 */
+	public static int nullTagBitsFromAnnotationValue(Object value) {
+		if (value instanceof Object[]) {
+			if (((Object[]) value).length == 0) {
+				return Binding.NULL_UNSPECIFIED_BY_DEFAULT;
+			} else {
+				int bits = 0;
+				for (Object single : (Object[])value)
+					bits |= evaluateDefaultNullnessLocation(single);
+				return bits;
+			}
+		} else {
+			return evaluateDefaultNullnessLocation(value);
+		}
+	}
+
+	private static int evaluateDefaultNullnessLocation(Object value) {
+		char[] name = null;
+		if (value instanceof FieldBinding) {
+			name = ((FieldBinding) value).name;
+		} else if (value instanceof EnumConstantSignature) {
+			name = ((EnumConstantSignature) value).getEnumConstantName();
+		} else if (value instanceof ElementValuePair.UnresolvedEnumConstant) {
+			name = ((ElementValuePair.UnresolvedEnumConstant) value).getEnumConstantName();
+		}
+		if (name != null) {
+			switch (name.length) {
+				case 5:
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__FIELD))
+						return Binding.DefaultLocationField;
+					break;
+				case 9:
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__PARAMETER))
+						return Binding.DefaultLocationParameter;
+					break;
+				case 10:
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__TYPE_BOUND))
+						return Binding.DefaultLocationTypeBound;
+					break;
+				case 11:
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__RETURN_TYPE))
+						return Binding.DefaultLocationReturnType;
+					break;
+				case 13 :
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__TYPE_ARGUMENT))
+						return Binding.DefaultLocationTypeArgument;
+					break;
+				case 14 :
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__TYPE_PARAMETER))
+						return Binding.DefaultLocationTypeParameter;
+					if (CharOperation.equals(name, TypeConstants.DEFAULT_LOCATION__ARRAY_CONTENTS))
+						return Binding.DefaultLocationArrayContents;
+					break;
+			}
+		}
+		return 0;
+	}
+	
 	static String getRetentionName(long tagBits) {
 		if ((tagBits & TagBits.AnnotationRuntimeRetention) == TagBits.AnnotationRuntimeRetention) {
 			// TagBits.AnnotationRuntimeRetention combines both TagBits.AnnotationClassRetention & TagBits.AnnotationSourceRetention
@@ -791,12 +864,14 @@ public abstract class Annotation extends Expression {
 		this.compilerAnnotation = scope.environment().createAnnotation((ReferenceBinding) this.resolvedType, computeElementValuePairs());
 		// recognize standard annotations ?
 		long tagBits = detectStandardAnnotation(scope, annotationType, valueAttribute);
+		int defaultNullness = (int)(tagBits & Binding.NullnessDefaultMASK);
+		tagBits &= ~Binding.NullnessDefaultMASK;
 
 		// record annotation positions in the compilation result
 		scope.referenceCompilationUnit().recordSuppressWarnings(IrritantSet.NLS, null, this.sourceStart, this.declarationSourceEnd);
 		if (this.recipient != null) {
 			int kind = this.recipient.kind();
-			if (tagBits != 0) {
+			if (tagBits != 0 || defaultNullness != 0) {
 				// tag bits onto recipient
 				switch (kind) {
 					case Binding.PACKAGE :
@@ -817,6 +892,7 @@ public abstract class Annotation extends Expression {
 							}
 							recordSuppressWarnings(scope, start, typeDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
+						sourceType.defaultNullness |= defaultNullness;
 						break;
 					case Binding.METHOD :
 						MethodBinding sourceMethod = (MethodBinding) this.recipient;
@@ -837,6 +913,7 @@ public abstract class Annotation extends Expression {
 							// for declaration annotations the inapplicability will be reported below
 							sourceMethod.tagBits &= ~TagBits.AnnotationNullMASK;
 						}
+						sourceMethod.defaultNullness |= defaultNullness;
 						break;
 					case Binding.FIELD :
 						FieldBinding sourceField = (FieldBinding) this.recipient;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
index 440d41c..8176963 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayQualifiedTypeReference.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -101,8 +103,8 @@ public class ArrayQualifiedTypeReference extends QualifiedTypeReference {
 		}
 	}
 
-	protected TypeBinding internalResolveType(Scope scope) {
-		TypeBinding internalResolveType = super.internalResolveType(scope);
+	protected TypeBinding internalResolveType(Scope scope, int location) {
+		TypeBinding internalResolveType = super.internalResolveType(scope, location);
 		return internalResolveType;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
index 0b32ffd..0513625 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayTypeReference.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -173,8 +175,8 @@ public class ArrayTypeReference extends SingleTypeReference {
 		visitor.endVisit(this, scope);
 	}
 
-	protected TypeBinding internalResolveType(Scope scope) {
-		TypeBinding internalResolveType = super.internalResolveType(scope);
+	protected TypeBinding internalResolveType(Scope scope, int location) {
+		TypeBinding internalResolveType = super.internalResolveType(scope, location);
 		return internalResolveType;
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
index 8782b5a..3ae7952 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java
@@ -7,6 +7,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *							Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
  *******************************************************************************/
@@ -66,7 +68,7 @@ public class IntersectionCastTypeReference extends TypeReference {
 	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.Scope)
 	 */
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
 
 		int length = this.typeReferences.length;
 		ReferenceBinding[] intersectingTypes = new ReferenceBinding[length];
@@ -76,7 +78,7 @@ public class IntersectionCastTypeReference extends TypeReference {
 		nextType:
 		for (int i = 0; i < length; i++) {
 			final TypeReference typeReference = this.typeReferences[i];
-			TypeBinding type = typeReference.resolveType(scope, checkBounds);
+			TypeBinding type = typeReference.resolveType(scope, checkBounds, location);
 			if (type == null || ((type.tagBits & TagBits.HasMissingType) != 0)) {
 				hasError = true;
 				continue;
@@ -196,4 +198,4 @@ public class IntersectionCastTypeReference extends TypeReference {
 		}
 		return output;
 	}
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java
index fded012..251a7a2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -610,7 +611,7 @@ public class Javadoc extends ASTNode {
 				// Scan all @param tags
 				for (int i = 0; i < paramTypeParamLength; i++) {
 					JavadocSingleTypeReference param = this.paramTypeParameters[i];
-					TypeBinding paramBindind = param.internalResolveType(scope);
+					TypeBinding paramBindind = param.internalResolveType(scope, 0);
 					if (paramBindind != null && paramBindind.isValidBinding()) {
 						if (paramBindind.isTypeVariable()) {
 							// https://bugs.eclipse.org/bugs/show_bug.cgi?id=397888
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocImplicitTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocImplicitTypeReference.java
index 64c9547..c18dd29 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocImplicitTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocImplicitTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -59,7 +61,7 @@ public class JavadocImplicitTypeReference extends TypeReference {
 	 * Resolves type on a Block, Class or CompilationUnit scope.
 	 * We need to modify resoling behavior to avoid raw type creation.
 	 */
-	protected TypeBinding internalResolveType(Scope scope) {
+	protected TypeBinding internalResolveType(Scope scope, int location) {
 		// handle the error here
 		this.constant = Constant.NotAConstant;
 		if (this.resolvedType != null) { // is a shared type reference which was already resolved
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocQualifiedTypeReference.java
index ee7df88..431ea1e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -74,11 +76,11 @@ public class JavadocQualifiedTypeReference extends QualifiedTypeReference {
 	protected void reportInvalidType(Scope scope) {
 		scope.problemReporter().javadocInvalidType(this, this.resolvedType, scope.getDeclarationModifiers());
 	}
-	public TypeBinding resolveType(BlockScope blockScope, boolean checkBounds) {
+	public TypeBinding resolveType(BlockScope blockScope, boolean checkBounds, int location) {
 		return internalResolveType(blockScope, checkBounds);
 	}
 
-	public TypeBinding resolveType(ClassScope classScope) {
+	public TypeBinding resolveType(ClassScope classScope, int location) {
 		return internalResolveType(classScope, false);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocSingleTypeReference.java
index 19aed08..1c66784 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocSingleTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -36,7 +38,7 @@ public class JavadocSingleTypeReference extends SingleTypeReference {
 	/*
 	 * We need to modify resolving behavior to handle package references
 	 */
-	protected TypeBinding internalResolveType(Scope scope) {
+	protected TypeBinding internalResolveType(Scope scope, int location) {
 		// handle the error here
 		this.constant = Constant.NotAConstant;
 		if (this.resolvedType != null) { // is a shared type reference which was already resolved
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index db03223..73e60a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -40,19 +40,22 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
  */
 public class NullAnnotationMatching {
 	
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK = new NullAnnotationMatching(0, null);
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_UNCHECKED = new NullAnnotationMatching(1, null);
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_MISMATCH = new NullAnnotationMatching(2, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK = new NullAnnotationMatching(0, FlowInfo.UNKNOWN, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK_NONNULL = new NullAnnotationMatching(0, FlowInfo.NON_NULL, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_UNCHECKED = new NullAnnotationMatching(1, FlowInfo.UNKNOWN, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_MISMATCH = new NullAnnotationMatching(2, FlowInfo.UNKNOWN, null);
 
 	/** 0 = OK, 1 = unchecked, 2 = definite mismatch */
 	public final int severity;
 	
 	/** If non-null this field holds the supertype of the provided type which was used for direct matching. */
 	public final TypeBinding superTypeHint;
+	public final int nullStatus;
 	
-	public NullAnnotationMatching(int severity, TypeBinding superTypeHint) {
+	public NullAnnotationMatching(int severity, int nullStatus, TypeBinding superTypeHint) {
 		this.severity = severity;
 		this.superTypeHint = superTypeHint;
+		this.nullStatus = nullStatus;
 	}
 
 	public boolean isAnyMismatch()      { return this.severity != 0; }
@@ -89,6 +92,8 @@ public class NullAnnotationMatching {
 			} else if (annotationStatus.isUnchecked()) {
 				flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, nullStatus);
 				hasReported = true;
+			} else if (annotationStatus.nullStatus != FlowInfo.UNKNOWN) {
+				return annotationStatus.nullStatus;
 			}
 		}
 		if (lhsTagBits == TagBits.AnnotationNonNull && nullStatus != FlowInfo.NON_NULL) {
@@ -115,6 +120,7 @@ public class NullAnnotationMatching {
 	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, int nullStatus, boolean strict) {
 		int severity = 0;
 		TypeBinding superTypeHint = null;
+		NullAnnotationMatching okStatus = NullAnnotationMatching.NULL_ANNOTATIONS_OK;
 		if (requiredType instanceof ArrayBinding) {
 			long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
 			if (requiredDimsTagBits != null) {
@@ -146,6 +152,8 @@ public class NullAnnotationMatching {
 			{
 				long providedBits = providedNullTagBits(providedType);
 				severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, strict && nullStatus == -1);
+				if (severity == 0 && (providedBits & TagBits.AnnotationNonNull) != 0)
+					okStatus = NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
 			}
 			if (severity < 2) {
 				TypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);
@@ -159,7 +167,7 @@ public class NullAnnotationMatching {
 							NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], -1, strict);
 							severity = Math.max(severity, status.severity);
 							if (severity == 2)
-								return new NullAnnotationMatching(severity, superTypeHint);
+								return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 						}
 					}
 				}
@@ -172,8 +180,8 @@ public class NullAnnotationMatching {
 			}
 		}
 		if (severity == 0)
-			return NullAnnotationMatching.NULL_ANNOTATIONS_OK;
-		return new NullAnnotationMatching(severity, superTypeHint);
+			return okStatus;
+		return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 	}
 
 	// interpreting 'type' as a required type, compute the required null bits
@@ -375,4 +383,4 @@ public class NullAnnotationMatching {
 		}
 		return method;
 	}
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index 0a3e4cf..1fb08c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 416181 – [1.8][compiler][null] Invalid assignment is not rejected by the compiler
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -146,7 +147,7 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
     /*
      * No need to check for reference to raw type per construction
      */
-	private TypeBinding internalResolveType(Scope scope, boolean checkBounds) {
+	private TypeBinding internalResolveType(Scope scope, boolean checkBounds, int location) {
 		// handle the error here
 		this.constant = Constant.NotAConstant;
 		if ((this.bits & ASTNode.DidResolve) != 0) { // is a shared type reference which was already resolved
@@ -169,7 +170,7 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		this.bits |= ASTNode.DidResolve;
 		TypeBinding type = internalResolveLeafType(scope, checkBounds);
 		createArrayType(scope);
-		resolveAnnotations(scope);
+		resolveAnnotations(scope, location);
 		if (this.typeArguments != null)
 			// relevant null annotations are on the inner most type:
 			checkNullConstraints(scope, this.typeArguments[this.typeArguments.length-1]); 
@@ -419,11 +420,11 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		return output;
 	}
 
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-	    return internalResolveType(scope, checkBounds);
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+	    return internalResolveType(scope, checkBounds, location);
 	}
-	public TypeBinding resolveType(ClassScope scope) {
-	    return internalResolveType(scope, false);
+	public TypeBinding resolveType(ClassScope scope, int location) {
+	    return internalResolveType(scope, false, location);
 	}
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
 		if (visitor.visit(this, scope)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index ea2c51f..2919b33 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -12,6 +12,7 @@
  *								Bug 420894 - ClassCastException in DefaultBindingResolver.resolveType(Type)
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -119,7 +120,7 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
     /*
      * No need to check for reference to raw type per construction
      */
-	private TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds) {
+	private TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds, int location) {
 		// handle the error here
 		this.constant = Constant.NotAConstant;
 		if ((this.bits & ASTNode.DidResolve) != 0) { // is a shared type reference which was already resolved
@@ -145,18 +146,18 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		// handle three different outcomes:
 		if (type == null) {
 			this.resolvedType = createArrayType(scope, this.resolvedType);
-			resolveAnnotations(scope);
+			resolveAnnotations(scope, 0); // no defaultNullness for buggy type
 			checkNullConstraints(scope, this.typeArguments);
-			return null;							// no useful type, but still captured dimensions into this.resolvedType
+			return null;							// (1) no useful type, but still captured dimensions into this.resolvedType
 		} else {
 			type = createArrayType(scope, type);
 			if (!this.resolvedType.isValidBinding() && this.resolvedType.dimensions() == type.dimensions()) {
-				resolveAnnotations(scope);
+				resolveAnnotations(scope, 0); // no defaultNullness for buggy type
 				checkNullConstraints(scope, this.typeArguments);
-				return type;						// found some error, but could recover useful type (like closestMatch)
+				return type;						// (2) found some error, but could recover useful type (like closestMatch)
 			} else {
-				this.resolvedType = type; 	// no complaint, keep fully resolved type (incl. dimensions)
-				resolveAnnotations(scope);
+				this.resolvedType = type; 			// (3) no complaint, keep fully resolved type (incl. dimensions)
+				resolveAnnotations(scope, location);
 				checkNullConstraints(scope, this.typeArguments);
 				return this.resolvedType; // pick up any annotated type.
 			}
@@ -351,16 +352,16 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		return output;
 	}
 
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-	    return internalResolveType(scope, null, checkBounds);
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+	    return internalResolveType(scope, null, checkBounds, location);
 	}
 
-	public TypeBinding resolveType(ClassScope scope) {
-	    return internalResolveType(scope, null, false /*no bounds check in classScope*/);
+	public TypeBinding resolveType(ClassScope scope, int location) {
+	    return internalResolveType(scope, null, false /*no bounds check in classScope*/, location);
 	}
 
 	public TypeBinding resolveTypeEnclosing(BlockScope scope, ReferenceBinding enclosingType) {
-	    return internalResolveType(scope, enclosingType, true/*check bounds*/);
+	    return internalResolveType(scope, enclosingType, true/*check bounds*/, 0);
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
index 02c0273..6b58636 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -78,7 +79,7 @@ public class SingleTypeReference extends TypeReference {
 		this.resolvedType = scope.getMemberType(this.token, enclosingType);
 		boolean hasError = false;
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391500
-		resolveAnnotations(scope);
+		resolveAnnotations(scope, 0); // defaultNullness not relevant, the only caller within the compiler: QAE
 		TypeBinding memberType = this.resolvedType; // load after possible update in resolveAnnotations()
 		if (!memberType.isValidBinding()) {
 			hasError = true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index d4ee17d..eb42b89 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -15,6 +15,7 @@
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 427163 - [1.8][null] bogus error "Contradictory null specification" on varags
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -33,10 +34,13 @@ import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -442,7 +446,7 @@ protected abstract TypeBinding getTypeBinding(Scope scope);
  */
 public abstract char [][] getTypeName() ;
 
-protected TypeBinding internalResolveType(Scope scope) {
+protected TypeBinding internalResolveType(Scope scope, int location) {
 	// handle the error here
 	this.constant = Constant.NotAConstant;
 	if (this.resolvedType != null) { // is a shared type reference which was already resolved
@@ -493,12 +497,12 @@ protected TypeBinding internalResolveType(Scope scope) {
 		scope.problemReporter().rawTypeReference(this, type);
 	}
 	if (hasError) {
-		resolveAnnotations(scope);		
+		resolveAnnotations(scope, 0); // don't apply null defaults to buggy type
 		return type;
 	} else {
 		// store the computed type only if no error, otherwise keep the problem type instead
 		this.resolvedType = type;
-		resolveAnnotations(scope);
+		resolveAnnotations(scope, location);
 		return this.resolvedType; // pick up value that may have been changed in resolveAnnotations(..)
 	}
 }
@@ -549,15 +553,23 @@ public final TypeBinding resolveType(BlockScope blockScope) {
 }
 
 public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
-	return internalResolveType(scope);
+	return resolveType(scope, checkBounds, 0);
+}
+
+public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
+	return internalResolveType(scope, location);
 }
 
 public TypeBinding resolveType(ClassScope scope) {
-	return internalResolveType(scope);
+	return resolveType(scope, 0);
+}
+
+public TypeBinding resolveType(ClassScope scope, int location) {
+	return internalResolveType(scope, location);
 }
 
 public TypeBinding resolveTypeArgument(BlockScope blockScope, ReferenceBinding genericType, int rank) {
-    return resolveType(blockScope, true /* check bounds*/);
+    return resolveType(blockScope, true /* check bounds*/, Binding.DefaultLocationTypeArgument);
 }
 
 public TypeBinding resolveTypeArgument(ClassScope classScope, ReferenceBinding genericType, int rank) {
@@ -571,7 +583,7 @@ public TypeBinding resolveTypeArgument(ClassScope classScope, ReferenceBinding g
 			ref.tagBits |= TagBits.PauseHierarchyCheck;
 			pauseHierarchyCheck = true;
 		}
-	    return resolveType(classScope);
+	    return resolveType(classScope, Binding.DefaultLocationTypeArgument);
 	} finally {
 		if (pauseHierarchyCheck) {
 			ref.tagBits &= ~TagBits.PauseHierarchyCheck;
@@ -583,7 +595,7 @@ public abstract void traverse(ASTVisitor visitor, BlockScope scope);
 
 public abstract void traverse(ASTVisitor visitor, ClassScope scope);
 
-protected void resolveAnnotations(Scope scope) {
+protected void resolveAnnotations(Scope scope, int location) {
 	Annotation[][] annotationsOnDimensions = getAnnotationsOnDimensions();
 	if (this.annotations != null || annotationsOnDimensions != null) {
 		BlockScope resolutionScope = Scope.typeAnnotationsResolutionScope(scope);
@@ -611,6 +623,17 @@ protected void resolveAnnotations(Scope scope) {
 			}
 		}
 	}
+	if (this.resolvedType != null
+			&& (this.resolvedType.tagBits & TagBits.AnnotationNullMASK) == 0
+			&& !this.resolvedType.isTypeVariable()
+			&& !this.resolvedType.isWildcard()
+			&& location != 0 
+			&& scope.hasDefaultNullnessFor(location)) 
+	{
+		LookupEnvironment environment = scope.environment();
+		AnnotationBinding[] annots = new AnnotationBinding[]{environment.getNonNullAnnotation()};
+		this.resolvedType = environment.createAnnotatedType(this.resolvedType, annots);
+	}
 }
 public int getAnnotatableLevels() {
 	return 1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
index 3eee697..1cc7d8a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2012 IBM Corporation and others.
+ * Copyright (c) 2011, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -46,13 +48,13 @@ public class UnionTypeReference extends TypeReference {
 	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.Scope)
 	 */
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
 		// return the lub (least upper bound of all type binding) 
 		int length = this.typeReferences.length;
 		TypeBinding[] allExceptionTypes = new TypeBinding[length];
 		boolean hasError = false;
 		for (int i = 0; i < length; i++) {
-			TypeBinding exceptionType = this.typeReferences[i].resolveType(scope, checkBounds);
+			TypeBinding exceptionType = this.typeReferences[i].resolveType(scope, checkBounds, location);
 			if (exceptionType == null) {
 				return null;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
index 22e6a5c..7f908cc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *        Stephan Herrmann - Contribution for
  *							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *							Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *							Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -62,15 +63,15 @@ public class Wildcard extends SingleTypeReference {
 		TypeBinding boundType = null;
 		if (this.bound != null) {
 			boundType = scope.kind == Scope.CLASS_SCOPE
-					? this.bound.resolveType((ClassScope)scope)
-					: this.bound.resolveType((BlockScope)scope, true /* check bounds*/);
+					? this.bound.resolveType((ClassScope)scope, Binding.DefaultLocationTypeBound)
+					: this.bound.resolveType((BlockScope)scope, true /* check bounds*/, Binding.DefaultLocationTypeBound);
 			this.bits |= (this.bound.bits & ASTNode.HasTypeAnnotations);
 			if (boundType == null) {
 				return null;
 			}
 		}
 		this.resolvedType = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);
-		resolveAnnotations(scope);
+		resolveAnnotations(scope, 0); // no defaultNullness for wildcards
 		if (boundType != null && boundType.hasNullTypeAnnotations() && this.resolvedType.hasNullTypeAnnotations()) {
 			if (((boundType.tagBits | this.resolvedType.tagBits) & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) { // are both set?
 				Annotation annotation = this.bound.findAnnotation(boundType.tagBits & TagBits.AnnotationNullMASK);
@@ -102,27 +103,27 @@ public class Wildcard extends SingleTypeReference {
 	}
 
 	// only invoked for improving resilience when unable to bind generic type from parameterized reference
-	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
+	public TypeBinding resolveType(BlockScope scope, boolean checkBounds, int location) {
 		if (this.bound != null) {
-			this.bound.resolveType(scope, checkBounds);
+			this.bound.resolveType(scope, checkBounds, Binding.DefaultLocationTypeBound);
 			this.bits |= (this.bound.bits & ASTNode.HasTypeAnnotations);
 		}
 		return null;
 	}
 	// only invoked for improving resilience when unable to bind generic type from parameterized reference
-	public TypeBinding resolveType(ClassScope scope) {
+	public TypeBinding resolveType(ClassScope scope, int location) {
 		if (this.bound != null) {
-			this.bound.resolveType(scope);
+			this.bound.resolveType(scope, Binding.DefaultLocationTypeBound);
 			this.bits |= (this.bound.bits & ASTNode.HasTypeAnnotations);
 		}
 		return null;
 	}
 	public TypeBinding resolveTypeArgument(BlockScope blockScope, ReferenceBinding genericType, int rank) {
-	    return internalResolveType(blockScope, genericType, rank);
+	    return internalResolveType(blockScope, genericType, rank); // no defaultNullness for wildcards
 	}
 
 	public TypeBinding resolveTypeArgument(ClassScope classScope, ReferenceBinding genericType, int rank) {
-	    return internalResolveType(classScope, genericType, rank);
+	    return internalResolveType(classScope, genericType, rank); // no defaultNullness for wildcards
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
new file mode 100644
index 0000000..fd8105b
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
@@ -0,0 +1,151 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+
+/**
+ * A type annotation walker that adds missing NonNull annotations according to the current default.
+ */
+public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalker {
+
+	private int defaultNullness;
+	private boolean atDefaultLocation;
+	private boolean nextIsDefaultLocation;
+	private boolean isEmpty;
+	IBinaryAnnotation nonNullAnnotation;
+
+	/** Create initial walker with non-empty type annotations. */
+	public NonNullDefaultAwareTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations,
+						int defaultNullness, LookupEnvironment environment) {
+		super(typeAnnotations);
+		this.nonNullAnnotation = getNonNullAnnotation(environment);
+		this.defaultNullness = defaultNullness;
+	}
+	
+	/** Create an initial walker without 'real' type annotations, but with a nonnull default. */
+	public NonNullDefaultAwareTypeAnnotationWalker(int defaultNullness, LookupEnvironment environment) {
+		this(defaultNullness, getNonNullAnnotation(environment), false);
+	}
+
+	/** Get restricted walker, still with non-empty type annotations. */
+	NonNullDefaultAwareTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long newMatches, int newPathPtr,
+						int defaultNullness, IBinaryAnnotation nonNullAnnotation, boolean atDefaultLocation) {
+		super(typeAnnotations, newMatches, newPathPtr);
+		this.defaultNullness = defaultNullness;
+		this.nonNullAnnotation = nonNullAnnotation;
+		this.atDefaultLocation = atDefaultLocation;
+	}
+
+	/** Create a restricted walker without 'real' type annotations, but with a nonnull default. */
+	NonNullDefaultAwareTypeAnnotationWalker(int defaultNullness, IBinaryAnnotation nonNullAnnotation, boolean atDefaultLocation) {
+		super(null, 0, 0);
+		this.nonNullAnnotation = nonNullAnnotation;
+		this.defaultNullness = defaultNullness;
+		this.atDefaultLocation = atDefaultLocation;
+		this.isEmpty = true;
+	}
+	
+	private static IBinaryAnnotation getNonNullAnnotation(LookupEnvironment environment) {
+		final char[] nonNullAnnotationName = CharOperation.concat(
+						'L', CharOperation.concatWith(environment.getNonNullAnnotationName(), '/'), ';');
+		// create the synthetic annotation:
+		return new IBinaryAnnotation() {
+			@Override
+			public char[] getTypeName() {
+				return nonNullAnnotationName;
+			}
+			@Override
+			public IBinaryElementValuePair[] getElementValuePairs() {
+				return null;
+			}
+		};
+	}
+
+	protected TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
+		// considers nextIsDefaultLocation as the new atDefaultLocation
+		try {
+			// do we have any change at all?
+			if (this.matches == newMatches && this.pathPtr == newPathPtr && this.atDefaultLocation == this.nextIsDefaultLocation)
+				return this;
+			// are we running out of real type annotations?
+			if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
+				return new NonNullDefaultAwareTypeAnnotationWalker(this.defaultNullness, this.nonNullAnnotation, this.nextIsDefaultLocation);
+			// proceed as normal, but pass on our specific fields, too:
+			return new NonNullDefaultAwareTypeAnnotationWalker(this.typeAnnotations, newMatches, newPathPtr,
+																this.defaultNullness, this.nonNullAnnotation, this.nextIsDefaultLocation);
+		} finally {
+			this.nextIsDefaultLocation = false; // expire
+		}
+	}
+	
+	@Override
+	public TypeAnnotationWalker toMethodParameter(short index) {
+		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toMethodParameter(index);
+	}
+
+	@Override
+	public TypeAnnotationWalker toMethodReturn() {
+		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toMethodReturn();
+	}
+
+	@Override
+	public TypeAnnotationWalker toTypeBound(short boundIndex) {
+		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toTypeBound(boundIndex);
+	}
+
+	@Override
+	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toTypeParameterBounds(isClassTypeParameter, parameterRank);
+	}
+
+	@Override
+	public TypeAnnotationWalker toTypeArgument(int rank) {
+		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeArgument) != 0;
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toTypeArgument(rank);
+	}
+
+	@Override
+	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeParameter) != 0;
+		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
+		return super.toTypeParameter(isClassTypeParameter, rank);
+	}
+
+	@Override
+	public IBinaryAnnotation[] getAnnotationsAtCursor() {
+		IBinaryAnnotation[] normalAnnotations = this.isEmpty ? null : super.getAnnotationsAtCursor();
+		if (this.atDefaultLocation) {
+			if (normalAnnotations == null || normalAnnotations.length == 0)
+				return new IBinaryAnnotation[] { this.nonNullAnnotation };
+			int len = normalAnnotations.length;
+			IBinaryAnnotation[] newAnnots = new IBinaryAnnotation[len+1];
+			System.arraycopy(normalAnnotations, 0, newAnnots, 0, len);
+			newAnnots[len] = this.nonNullAnnotation;
+			return newAnnots;
+		}
+		return normalAnnotations;
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index e727e80..9f189b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 GK Software AG.
+ * Copyright (c) 2013, 2014 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -44,9 +44,9 @@ public class TypeAnnotationWalker {
 		public IBinaryAnnotation[] getAnnotationsAtCursor() { return NO_ANNOTATIONS; }
 	};
 	
-	final private IBinaryTypeAnnotation[] typeAnnotations;	// the actual material we're managing here
-	final private long matches;							// bit mask of indices into typeAnnotations, 1 means active, 0 is filtered during the walk
-	final private int pathPtr;							// pointer into the typePath
+	final protected IBinaryTypeAnnotation[] typeAnnotations;	// the actual material we're managing here
+	final protected long matches;								// bit mask of indices into typeAnnotations, 1 means active, 0 is filtered during the walk
+	final protected int pathPtr;								// pointer into the typePath
 
 	// precondition: not-empty typeAnnotations
 	public TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations) {
@@ -55,13 +55,13 @@ public class TypeAnnotationWalker {
 	TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long matchBits) {
 		this(typeAnnotations, matchBits, 0);
 	}
-	private TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long matchBits, int pathPtr) {
+	protected TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long matchBits, int pathPtr) {
 		this.typeAnnotations = typeAnnotations;
 		this.matches = matchBits;
 		this.pathPtr = pathPtr;
 	}
 
-	private TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
+	protected TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
 		if (this.matches == newMatches && this.pathPtr == newPathPtr) return this;
 		if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
 			return EMPTY_ANNOTATION_WALKER;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 697e319..1f0d869 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -24,6 +24,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -33,7 +34,9 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.ArrayList;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.NonNullDefaultAwareTypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.env.*;
@@ -76,8 +79,9 @@ public class BinaryTypeBinding extends ReferenceBinding {
 	protected SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
 	private ReferenceBinding containerAnnotationType;
+	int defaultNullness = 0;
 
-static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char[][][] missingTypeNames) {
+static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char[][][] missingTypeNames, boolean resolveEnumConstants) {
 	if (binaryValue == null) return null;
 	if (binaryValue instanceof Constant)
 		return binaryValue;
@@ -88,6 +92,8 @@ static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char
 	if (binaryValue instanceof EnumConstantSignature) {
 		EnumConstantSignature ref = (EnumConstantSignature) binaryValue;
 		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		if (enumType.isUnresolvedType() && !resolveEnumConstants)
+			return new ElementValuePair.UnresolvedEnumConstant(enumType, env, ref.getEnumConstantName());
 		enumType = (ReferenceBinding) resolveType(enumType, env, false /* no raw conversion */);
 		return enumType.getField(ref.getEnumConstantName(), false);
 	}
@@ -97,7 +103,7 @@ static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char
 		if (length == 0) return objects;
 		Object[] values = new Object[length];
 		for (int i = 0; i < length; i++)
-			values[i] = convertMemberValue(objects[i], env, missingTypeNames);
+			values[i] = convertMemberValue(objects[i], env, missingTypeNames, resolveEnumConstants);
 		return values;
 	}
 
@@ -129,7 +135,7 @@ static AnnotationBinding createAnnotation(IBinaryAnnotation annotationInfo, Look
 	int length = binaryPairs == null ? 0 : binaryPairs.length;
 	ElementValuePair[] pairs = length == 0 ? Binding.NO_ELEMENT_VALUE_PAIRS : new ElementValuePair[length];
 	for (int i = 0; i < length; i++)
-		pairs[i] = new ElementValuePair(binaryPairs[i].getName(), convertMemberValue(binaryPairs[i].getValue(), env, missingTypeNames), null);
+		pairs[i] = new ElementValuePair(binaryPairs[i].getName(), convertMemberValue(binaryPairs[i].getValue(), env, missingTypeNames, false), null);
 
 	char[] typeName = annotationInfo.getTypeName();
 	ReferenceBinding annotationType = env.getTypeFromConstantPoolName(typeName, 1, typeName.length - 1, false, missingTypeNames);
@@ -389,6 +395,10 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		   and/or super interfaces in order to be able to detect overriding in the presence
 		   of generics.
 		 */
+		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+			// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
+			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage, this);
+		}
 		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
@@ -476,9 +486,6 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 				}
 			}
 			if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
-				// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
-				scanTypeForNullDefaultAnnotation(binaryType, this.fPackage, this);
-
 				if (iFields != null) {
 					for (int i = 0; i < iFields.length; i++)
 						scanFieldForNullAnnotation(iFields[i], this.fields[i], this.isEnum());
@@ -504,10 +511,20 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 
 private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
 	if (!isPrototype()) throw new IllegalStateException();
-	if (annotations == null || annotations.length == 0)
+	if (annotations == null || annotations.length == 0 || !this.environment.usesAnnotatedTypeSystem()) {
+		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+			int nullness = getNullDefault();
+			if (nullness > Binding.NULL_UNSPECIFIED_BY_DEFAULT)
+				return new NonNullDefaultAwareTypeAnnotationWalker(nullness, this.environment);
+		}
 		return TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
-	
-	return this.environment.usesAnnotatedTypeSystem() ? new TypeAnnotationWalker(annotations) : TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	}
+	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+		int nullness = getNullDefault();
+		if (nullness > Binding.NULL_UNSPECIFIED_BY_DEFAULT)
+			return new NonNullDefaultAwareTypeAnnotationWalker(annotations, nullness, this.environment);
+	}
+	return new TypeAnnotationWalker(annotations);
 }
 
 private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] missingTypeNames) {
@@ -741,7 +758,7 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 		result.setAnnotations(
 			createAnnotations(annotations, this.environment, missingTypeNames),
 			paramAnnotations,
-			isAnnotationType() ? convertMemberValue(method.getDefaultValue(), this.environment, missingTypeNames) : null,
+			isAnnotationType() ? convertMemberValue(method.getDefaultValue(), this.environment, missingTypeNames, true) : null,
 			this.environment);
 	}
 
@@ -1448,6 +1465,7 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	return this.storedAnnotations;
 }
 
+//pre: null annotation analysis is enabled
 private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding, boolean isEnum) {
 	if (!isPrototype()) throw new IllegalStateException();
 	if (this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
@@ -1455,7 +1473,7 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 		if (fieldType != null
 				&& !fieldType.isBaseType()
 				&& (fieldType.tagBits & TagBits.AnnotationNullMASK) == 0
-				&& (this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+				&& hasNonNullDefaultFor(DefaultLocationField, true)) {
 			fieldBinding.type = this.environment.createAnnotatedType(fieldType, new AnnotationBinding[]{this.environment.getNonNullAnnotation()});
 		}
 		return; // not using fieldBinding.tagBits when we have type annotations.
@@ -1523,6 +1541,8 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
 			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
 				methodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
+				if (useTypeAnnotations)
+					methodBinding.defaultNullness = getNonNullByDefaultValue(annotations[i]);
 			}
 			if (!useTypeAnnotations && !explicitNullness) {
 				if (CharOperation.equals(typeName, nonNullAnnotationName)) {
@@ -1571,6 +1591,7 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 		}
 	}
 }
+// pre: null annotation analysis is enabled
 private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBinding packageBinding, BinaryTypeBinding binaryBinding) {
 	if (!isPrototype()) throw new IllegalStateException();
 	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
@@ -1579,6 +1600,7 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 
 	IBinaryAnnotation[] annotations = binaryType.getAnnotations();
 	boolean isPackageInfo = CharOperation.equals(binaryBinding.sourceName(), TypeConstants.PACKAGE_INFO_NAME);
+	boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
 	if (annotations != null) {
 		long annotationBit = 0L;
 		int nullness = NO_NULL_DEFAULT;
@@ -1590,21 +1612,28 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
 			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
 				IBinaryElementValuePair[] elementValuePairs = annotations[i].getElementValuePairs();
-				if (elementValuePairs != null && elementValuePairs.length == 1) {
-					Object value = elementValuePairs[0].getValue();
-					if (value instanceof BooleanConstant
-						&& !((BooleanConstant)value).booleanValue())
-					{
-						// parameter is 'false': this means we cancel defaults from outer scopes:
-						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
-						nullness = NULL_UNSPECIFIED_BY_DEFAULT;
-						break;
-					} else if (value instanceof Object[] && ((Object[])value).length == 0) {
-						// parameter is '{}': this means we cancel defaults from outer scopes:
-						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
-						nullness = NULL_UNSPECIFIED_BY_DEFAULT;
-						break;
+				if (!useTypeAnnotations) {
+					if (elementValuePairs != null && elementValuePairs.length == 1) {
+						Object value = elementValuePairs[0].getValue();
+						if (value instanceof BooleanConstant
+							&& !((BooleanConstant)value).booleanValue())
+						{
+							// parameter is 'false': this means we cancel defaults from outer scopes:
+							annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
+							nullness = NULL_UNSPECIFIED_BY_DEFAULT;
+							break;
+						}
 					}
+				} else {
+					// using NonNullByDefault we need to inspect the details of the value() attribute:
+					nullness = getNonNullByDefaultValue(annotations[i]);
+					if (nullness == NULL_UNSPECIFIED_BY_DEFAULT) {
+						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
+					} else if (nullness != 0) {
+						annotationBit = TagBits.AnnotationNonNullByDefault;
+					}	
+					this.defaultNullness = nullness;
+					break;
 				}
 				annotationBit = TagBits.AnnotationNonNullByDefault;
 				nullness = NONNULL_BY_DEFAULT;
@@ -1625,12 +1654,19 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 	}
 	ReferenceBinding enclosingTypeBinding = binaryBinding.enclosingType;
 	if (enclosingTypeBinding != null) {
-		if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
-			binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
-			return;
-		} else if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
-			binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-			return;
+		if (useTypeAnnotations) {
+			binaryBinding.defaultNullness = enclosingTypeBinding.getNullDefault();
+			if (binaryBinding.defaultNullness != 0) {
+				return;
+			}
+		} else {
+			if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+				binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
+				return;
+			} else if ((enclosingTypeBinding.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0) {
+				binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+				return;
+			}
 		}
 	}
 	// no annotation found on the type or its enclosing types
@@ -1643,14 +1679,53 @@ private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBin
 		}
 	}
 	// no @NonNullByDefault at type level, check containing package:
-	switch (packageBinding.defaultNullness) {
-		case Binding.NONNULL_BY_DEFAULT : 
-			binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
-			break;
-		case Binding.NULL_UNSPECIFIED_BY_DEFAULT :
-			binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
-			break;
+	if (useTypeAnnotations) {
+		binaryBinding.defaultNullness = packageBinding.defaultNullness;
+	} else {
+		switch (packageBinding.defaultNullness) {
+			case Binding.NONNULL_BY_DEFAULT : 
+				binaryBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
+				break;
+			case Binding.NULL_UNSPECIFIED_BY_DEFAULT :
+				binaryBinding.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+				break;
+		}
+	}
+}
+
+/** given an application of @NonNullByDefault convert the annotation argument (if any) into a bitvector a la {@link Binding#NullnessDefaultMASK} */
+// pre: null annotation analysis is enabled
+int getNonNullByDefaultValue(IBinaryAnnotation annotation) {
+	char[] annotationTypeName = annotation.getTypeName();
+	char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+	IBinaryElementValuePair[] elementValuePairs = annotation.getElementValuePairs();
+	if (elementValuePairs == null || elementValuePairs.length == 0 ) {
+		// no argument: apply default default
+		ReferenceBinding annotationType = this.environment.getType(typeName);
+		if (annotationType == null) return 0;
+		if (annotationType.isUnresolvedType())
+			annotationType = ((UnresolvedReferenceBinding) annotationType).resolve(this.environment, false);
+		MethodBinding[] annotationMethods = annotationType.methods();
+		if (annotationMethods != null && annotationMethods.length == 1) {
+			Object value = annotationMethods[0].getDefaultValue();
+			return Annotation.nullTagBitsFromAnnotationValue(value);
+		}
+	} else if (elementValuePairs.length > 0) {
+		// evaluate the contained EnumConstantSignatures:
+		int nullness = 0;
+		for (int i = 0; i < elementValuePairs.length; i++)
+			nullness |= Annotation.nullTagBitsFromAnnotationValue(elementValuePairs[i].getValue());
+		return nullness;
+	} else {
+		// empty argument: cancel all defaults from enclosing scopes
+		return NULL_UNSPECIFIED_BY_DEFAULT;
 	}
+	return 0;
+}
+
+@Override
+int getNullDefault() {
+	return this.defaultNullness;
 }
 
 private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] missingTypeNames) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index 4d395fc..08abc3e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *******************************************************************************/
@@ -66,8 +67,44 @@ public abstract class Binding {
 
 	// Nullness defaults:
 	public static final int NO_NULL_DEFAULT = 0;
-	public static final int NULL_UNSPECIFIED_BY_DEFAULT = 1;
-	public static final int NONNULL_BY_DEFAULT = 2;
+	// SE5 style:
+	public static final int NONNULL_BY_DEFAULT = 1;
+	public static final int NULL_UNSPECIFIED_BY_DEFAULT = 2;
+	// JSR308 style:
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#PARAMETER
+	 */
+	public static final int DefaultLocationParameter = ASTNode.Bit4;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#RETURN_TYPE
+	 */
+	public static final int DefaultLocationReturnType = ASTNode.Bit5;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#FIELD
+	 */
+	public static final int DefaultLocationField = ASTNode.Bit6;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#TYPE_ARGUMENT
+	 */
+	public static final int DefaultLocationTypeArgument = ASTNode.Bit7;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#TYPE_PARAMETER
+	 */
+	public static final int DefaultLocationTypeParameter = ASTNode.Bit8;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#TYPE_BOUND
+	 */
+	public static final int DefaultLocationTypeBound = ASTNode.Bit9;
+	/**
+	 * Bit in defaultNullness bit vectors, representing the enum constant DefaultLocation#ARRAY_CONTENTS
+	 * TODO: this constant is not yet used, due to difficulty to discern these annotations between SE5 / SE8
+	 */
+	public static final int DefaultLocationArrayContents = ASTNode.Bit10;
+
+	public static final int NullnessDefaultMASK = 
+			NULL_UNSPECIFIED_BY_DEFAULT | // included to terminate search up the parent chain
+			DefaultLocationParameter | DefaultLocationReturnType | DefaultLocationField |
+			DefaultLocationTypeArgument | DefaultLocationTypeParameter | DefaultLocationTypeBound | DefaultLocationArrayContents;
 
 	/*
 	* Answer the receiver's binding type from Binding.BindingID.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index e10ef02..d7abd40 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,7 @@
  *								bug 379784 - [compiler] "Method can be static" is not getting reported
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *     Keigo Imai - Contribution for  bug 388903 - Cannot extend inner class as an anonymous class when it extends the outer class
@@ -1228,4 +1229,8 @@ private boolean checkAppropriate(MethodBinding compileTimeDeclaration, MethodBin
 	}
 	return true;
 }
+@Override
+public boolean hasDefaultNullnessFor(int location) {
+	return this.parent.hasDefaultNullnessFor(location);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 0f2cf56..7e4176a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -17,6 +17,7 @@
  *							Bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *							Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
+ *							Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415821 - [1.8][compiler] CLASS_EXTENDS target type annotation missing for anonymous classes
  *******************************************************************************/
@@ -1300,6 +1301,17 @@ public class ClassScope extends Scope {
 		return this.referenceContext;
 	}
 
+	@Override
+	public boolean hasDefaultNullnessFor(int location) {
+		SourceTypeBinding binding = this.referenceContext.binding;
+		if (binding != null) {
+			int nullDefault = binding.getNullDefault();
+			if (nullDefault != 0)
+				return (nullDefault & location) != 0;
+		}
+		return this.parent.hasDefaultNullnessFor(location);
+	}
+
 	public String toString() {
 		if (this.referenceContext != null)
 			return "--- Class Scope ---\n\n"  //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index e6058d3..0ea04c4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Erling Ellingsen -  patch for bug 125570
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -939,4 +941,10 @@ private int checkAndRecordImportBinding(
 	}
 	return this.importPtr;
 }
+@Override
+public boolean hasDefaultNullnessFor(int location) {
+	if (this.fPackage != null)
+		return (this.fPackage.defaultNullness & location) != 0;
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ElementValuePair.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ElementValuePair.java
index 5a469d6..a2297ab 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ElementValuePair.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ElementValuePair.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -18,6 +20,30 @@ public class ElementValuePair {
 	char[] name;
 	public Object value;
 	public MethodBinding binding;
+	
+	/**
+	 * We want to avoid eagerly resolving of all enums that are used in annotations.
+	 * This class encapsulates an unresolved enum constant as referenced in an ElementValuePair.
+	 * The enum constant will be resolved when asking getValue()
+	 */
+	public static class UnresolvedEnumConstant {
+		ReferenceBinding enumType;
+		LookupEnvironment environment;
+		char[] enumConstantName;
+		UnresolvedEnumConstant(ReferenceBinding enumType, LookupEnvironment environment, char[] enumConstantName) {
+			this.enumType = enumType;
+			this.environment = environment;
+			this.enumConstantName = enumConstantName;
+		}
+		FieldBinding getResolved() {
+			if (this.enumType.isUnresolvedType())
+				this.enumType = (ReferenceBinding) BinaryTypeBinding.resolveType(this.enumType, this.environment, false /* no raw conversion */);
+			return this.enumType.getField(this.enumConstantName, false);
+		}
+		public char[] getEnumConstantName() {
+			return this.enumConstantName;
+		}
+	}
 
 public static Object getValue(Expression expression) {
 	if (expression == null)
@@ -88,6 +114,8 @@ public MethodBinding getMethodBinding() {
  * @return the value of this member value pair or null if the value is missing or is not a compile-time constant
  */
 public Object getValue() {
+	if (this.value instanceof UnresolvedEnumConstant)
+		this.value = ((UnresolvedEnumConstant)this.value).getResolved();
 	return this.value;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 3485621..34b9fd4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -74,7 +74,9 @@ public class ImplicitNullAnnotationVerifier {
 			if (currentType.id == TypeIds.T_JavaLangObject) {
 				return;
 			}
-			boolean needToApplyNonNullDefault = currentMethod.hasNonNullDefault();
+			long sourceLevel = scope.compilerOptions().sourceLevel;
+			boolean needToApplyNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter|Binding.DefaultLocationReturnType,
+																					sourceLevel >= ClassFileConstants.JDK1_8);
 			// compatibility & inheritance do not consider constructors / static methods:
 			boolean isInstanceMethod = !currentMethod.isConstructor() && !currentMethod.isStatic();
 			complain &= isInstanceMethod;
@@ -110,7 +112,6 @@ public class ImplicitNullAnnotationVerifier {
 					checkNullSpecInheritance(currentMethod, srcMethod, needToApplyNonNullDefault, complain, currentSuper, scope, inheritedNonNullnessInfos);
 					needToApplyNonNullDefault = false;
 				}
-				long sourceLevel = scope.compilerOptions().sourceLevel;
 				
 				// transfer collected information into currentMethod:
 				InheritedNonNullnessInfo info = inheritedNonNullnessInfos[0];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
index 99aecb7..7633473 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,7 +9,8 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
- *								bug 401030 - [1.8][null] Null analysis support for lambda methods. 
+ *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -99,18 +100,23 @@ public ReferenceBinding anonymousOriginalSuperType() {
 	return this.superclass; // default answer
 }
 
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long annotationTagBits) {
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
-	long outerDefault = this.enclosingMethod != null ? this.enclosingMethod.tagBits & ((TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault)) : 0;
+	long outerDefault = 0;
+	if (this.enclosingMethod != null) {
+		outerDefault = isJdk18 
+				? this.enclosingMethod.defaultNullness 
+				: this.enclosingMethod.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
+	}
 	if (outerDefault != 0) {
-		if (outerDefault == annotationTagBits) {
+		if (outerDefault == nullBits) {
 			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this.enclosingMethod);
 		}
 		return;
 	}
-	super.checkRedundantNullnessDefaultRecurse(location, annotations, annotationTagBits);
+	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, isJdk18);
 }
 
 public char[] computeUniqueKey(boolean isLeaf) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 1973758..6115392 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -19,6 +19,7 @@
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 425152 - [1.8] [compiler] Lambda Expression not resolved but flow analyzed leading to NPE.
  *								Bug 423505 - [1.8] Implement "18.5.4 More Specific Method Inference"
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *******************************************************************************/
@@ -35,6 +36,7 @@ import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 @SuppressWarnings("rawtypes")
@@ -53,6 +55,7 @@ public class MethodBinding extends Binding {
 
 	/** Store nullness information from annotation (incl. applicable default). */
 	public Boolean[] parameterNonNullness;  // TRUE means @NonNull declared, FALSE means @Nullable declared, null means nothing declared
+	public int defaultNullness; // for null *type* annotations
 
 	/** Store parameter names from MethodParameters attribute (incl. applicable default). */
 	public char[][] parameterNames = Binding.NO_PARAMETER_NAMES;
@@ -506,28 +509,31 @@ protected void fillInDefaultNonNullness(AbstractMethodDeclaration sourceMethod)
 	}
 }
 
+//pre: null annotation analysis is enabled
 protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env) {
-	boolean added = false;
-	int length = this.parameters.length;
-	for (int i = 0; i < length; i++) {
-		TypeBinding parameter = this.parameters[i];
-		if (parameter.isBaseType())
-			continue;
-		long existing = parameter.tagBits & TagBits.AnnotationNullMASK;
-		if (existing == 0L) {
-			added = true;
-			if (!parameter.isBaseType()) {
-				this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});
-				if (sourceMethod != null)
-					sourceMethod.arguments[i].binding.type = this.parameters[i];
+	if (hasNonNullDefaultFor(DefaultLocationParameter, true)) {
+		boolean added = false;
+		int length = this.parameters.length;
+		for (int i = 0; i < length; i++) {
+			TypeBinding parameter = this.parameters[i];
+			if (parameter.isBaseType())
+				continue;
+			long existing = parameter.tagBits & TagBits.AnnotationNullMASK;
+			if (existing == 0L) {
+				added = true;
+				if (!parameter.isBaseType()) {
+					this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});
+					if (sourceMethod != null)
+						sourceMethod.arguments[i].binding.type = this.parameters[i];
+				}
+			} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0) {
+				sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
 			}
-		} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0) {
-			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
 		}
+		if (added)
+			this.tagBits |= TagBits.HasParameterAnnotations;
 	}
-	if (added)
-		this.tagBits |= TagBits.HasParameterAnnotations;
-	if (this.returnType != null) {
+	if (this.returnType != null && hasNonNullDefaultFor(DefaultLocationReturnType, true)) {
 		if (!this.returnType.isBaseType() && (this.returnType.tagBits & TagBits.AnnotationNullMASK) == 0) {
 			this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
 		} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {
@@ -621,11 +627,16 @@ public long getAnnotationTagBits() {
 			AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(originalMethod);
 			if (methodDecl != null)
 				ASTNode.resolveAnnotations(methodDecl.scope, methodDecl.annotations, originalMethod);
-			long nullDefaultBits = this.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
-			if (nullDefaultBits != 0 && this.declaringClass instanceof SourceTypeBinding) {
-				SourceTypeBinding declaringSourceType = (SourceTypeBinding) this.declaringClass;
-				if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits)) {
-					declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits);
+			CompilerOptions options = scope.compilerOptions();
+			if (options.isAnnotationBasedNullAnalysisEnabled) {
+				boolean isJdk18 = options.sourceLevel >= ClassFileConstants.JDK1_8;
+				long nullDefaultBits = isJdk18 ? this.defaultNullness
+						: this.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
+				if (nullDefaultBits != 0 && this.declaringClass instanceof SourceTypeBinding) {
+					SourceTypeBinding declaringSourceType = (SourceTypeBinding) this.declaringClass;
+					if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits, isJdk18)) {
+						declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits, isJdk18);
+					}
 				}
 			}
 		}
@@ -1244,12 +1255,18 @@ public String toString() {
 public TypeVariableBinding[] typeVariables() {
 	return this.typeVariables;
 }
-public boolean hasNonNullDefault() {
-	if ((this.tagBits & TagBits.AnnotationNonNullByDefault) != 0)
-		return true;
-	if ((this.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
-		return false;
-	return this.declaringClass.hasNonNullDefault();
+//pre: null annotation analysis is enabled
+public boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
+	if (useTypeAnnotations) {
+		if (this.defaultNullness != 0)
+			return (this.defaultNullness & location) != 0;
+	} else {
+		if ((this.tagBits & TagBits.AnnotationNonNullByDefault) != 0)
+			return true;
+		if ((this.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+			return false;
+	}
+	return this.declaringClass.hasNonNullDefaultFor(location, useTypeAnnotations);
 }
 
 public boolean redeclaresPublicObjectMethod(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
index bb6f059..ad005d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
@@ -14,6 +14,7 @@
  *								bug 382354 - [1.8][compiler] Compiler silent on conflicting modifier
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Jesper S Moller - Contributions for
  *							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -564,4 +565,13 @@ public TypeDeclaration referenceType() {
 void resolveTypeParameter(TypeParameter typeParameter) {
 	typeParameter.resolve(this);
 }
+@Override
+public boolean hasDefaultNullnessFor(int location) {
+	if (this.referenceContext instanceof AbstractMethodDeclaration) {
+		MethodBinding binding = ((AbstractMethodDeclaration) this.referenceContext).binding;
+		if (binding != null && binding.defaultNullness != 0)
+			return (binding.defaultNullness & location) != 0;
+	}
+	return this.parent.hasDefaultNullnessFor(location);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index 9135c05..dee4089 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -24,6 +24,7 @@
  *								Bug 420080 - [1.8] Overridden Default method is reported as duplicated
  *								Bug 404690 - [1.8][compiler] revisit bridge generation after VM bug is fixed
  *								Bug 410325 - [1.7][compiler] Generified method override different between javac and eclipse compiler
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -74,7 +75,9 @@ void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[]
 	AbstractMethodDeclaration srcMethod = null;
 	if (analyseNullAnnotations && this.type.equals(concreteMethod.declaringClass)) // is currentMethod from the current type?
 		srcMethod = concreteMethod.sourceMethod();
-	boolean hasNonNullDefault = concreteMethod.hasNonNullDefault();
+	boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+	boolean hasNonNullDefault = analyseNullAnnotations &&
+			concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter|Binding.DefaultLocationReturnType, useTypeAnnotations);
 	for (int i = 0, l = abstractMethods.length; i < l; i++) {
 		MethodBinding abstractMethod = abstractMethods[i];
 		if (concreteMethod.isVarargs() != abstractMethod.isVarargs())
@@ -387,7 +390,8 @@ void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] m
 		AbstractMethodDeclaration srcMethod = null;
 		if (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?
 			srcMethod = currentMethod.sourceMethod();
-		boolean hasNonNullDefault = currentMethod.hasNonNullDefault();
+		boolean useTypeAnnotations = options.sourceLevel >= ClassFileConstants.JDK1_8;
+		boolean hasNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter|Binding.DefaultLocationReturnType, useTypeAnnotations);
 		for (int i = length; --i >= 0;)
 			if (!currentMethod.isStatic() && !methods[i].isStatic())
 				checkNullSpecInheritance(currentMethod, srcMethod, hasNonNullDefault, true, methods[i], this.type.scope, null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
index 37d0536..bfb1f0d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								Bug 186342 - [compiler][null] Using annotations for null checking
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -29,6 +31,7 @@ public class MostSpecificExceptionMethodBinding  extends MethodBinding {
 				originalMethod.declaringClass);
 		this.originalMethod = originalMethod;
 		this.parameterNonNullness = originalMethod.parameterNonNullness;
+		this.defaultNullness = originalMethod.defaultNullness;
 	}
 	
 	public MethodBinding original() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
index 9549334..ec4ef6c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NestedTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for  bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *     Stephan Herrmann - Contributions for
+ *								Bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Keigo Imai - Contribution for  bug 388903 - Cannot extend inner class as an anonymous class when it extends the outer class
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
@@ -123,16 +125,16 @@ public SyntheticArgumentBinding addSyntheticArgumentAndField(ReferenceBinding ta
 	return synthLocal;
 }
 
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long annotationTagBits) {
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
 	if (!isPrototype()) throw new IllegalStateException();
 	ReferenceBinding currentType = this.enclosingType;
 	do {
-		if (!((SourceTypeBinding)currentType).checkRedundantNullnessDefaultOne(location, annotations, annotationTagBits)) {
+		if (!((SourceTypeBinding)currentType).checkRedundantNullnessDefaultOne(location, annotations, nullBits, isJdk18)) {
 			return;
 		}
 		currentType = currentType.enclosingType();
 	} while (currentType instanceof SourceTypeBinding);
-	super.checkRedundantNullnessDefaultRecurse(location, annotations, annotationTagBits);
+	super.checkRedundantNullnessDefaultRecurse(location, annotations, nullBits, isJdk18);
 }
 
 /* Answer the receiver's enclosing type... null if the receiver is a top level type.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 3e16d55..fb5cbb3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -18,6 +18,7 @@
  *								Bug 427438 - [1.8][compiler] NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280)
  *								Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
  *								Bug 416182 - [1.8][compiler][null] Contradictory null annotations not rejected
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -480,6 +481,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    									: Scope.substitute(rawType, originalMethod.returnType));
 	    this.wasInferred = false; // not resulting from method invocation inferrence
 	    this.parameterNonNullness = originalMethod.parameterNonNullness;
+	    this.defaultNullness = originalMethod.defaultNullness;
 	}
 
     /**
@@ -522,6 +524,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		}
 	    this.wasInferred = true;// resulting from method invocation inferrence
 	    this.parameterNonNullness = originalMethod.parameterNonNullness;
+	    this.defaultNullness = originalMethod.defaultNullness;
 	    // special case: @NonNull for a parameter that is inferred to 'null' is encoded the old way
 	    // because we cannot (and don't want to) add type annotations to NullTypeBinding.
 	    int len = this.parameters.length;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
index fe722e6..9b3f68e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
@@ -14,6 +14,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 425152 - [1.8] [compiler] Lambda Expression not resolved but flow analyzed leading to NPE.
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -47,6 +48,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 		 */
 		this.tagBits = originalMethod.tagBits & ~TagBits.HasMissingType;
 		this.parameterNonNullness = originalMethod.parameterNonNullness;
+		this.defaultNullness = originalMethod.defaultNullness;
 
 		final TypeVariableBinding[] originalVariables = originalMethod.typeVariables;
 		Substitution substitution = null;
@@ -182,6 +184,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 		 */
 		this.tagBits = originalMethod.tagBits & ~TagBits.HasMissingType;
 		this.parameterNonNullness = originalMethod.parameterNonNullness;
+		this.defaultNullness = originalMethod.defaultNullness;
 
 		final TypeVariableBinding[] originalVariables = originalMethod.typeVariables;
 		Substitution substitution = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index fe5c2b4..3a61ef7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -29,6 +29,7 @@
  *								Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -1090,20 +1091,35 @@ public boolean hasMemberTypes() {
 }
 
 /**
- * Answer whether a @NonNullByDefault is applicable at the given method binding.
+ * Answer whether a @NonNullByDefault is applicable at the reference binding,
+ * for 1.8 check if the default is applicable to the given kind of location.
  */
-boolean hasNonNullDefault() {
+// pre: null annotation analysis is enabled
+boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
 	// Note, STB overrides for correctly handling local types
 	ReferenceBinding currentType = this;
 	while (currentType != null) {
-		if ((currentType.tagBits & TagBits.AnnotationNonNullByDefault) != 0)
-			return true;
-		if ((currentType.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
-			return false;
+		if (useTypeAnnotations) {
+			int nullDefault = ((ReferenceBinding)currentType.original()).getNullDefault();
+			if (nullDefault != 0)
+				return (nullDefault & location) != 0;
+		} else {
+			if ((currentType.tagBits & TagBits.AnnotationNonNullByDefault) != 0)
+				return true;
+			if ((currentType.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+				return false;
+		}
 		currentType = currentType.enclosingType();
 	}
 	// package
-	return this.getPackage().defaultNullness == NONNULL_BY_DEFAULT;
+	if (useTypeAnnotations)
+		return (this.getPackage().defaultNullness & location) != 0;
+	else
+		return this.getPackage().defaultNullness == NONNULL_BY_DEFAULT;
+}
+
+int getNullDefault() {
+	return 0;
 }
 
 public final boolean hasRestrictedAccess() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index ce1c7cb..1e519e3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -41,6 +41,7 @@
  *								Bug 424728 - [1.8][null] Unexpected error: The nullness annotation 'XXXX' is not applicable at this location 
  *								Bug 428811 - [1.8][compiler] Type witness unnecessarily required
  *								Bug 429424 - [1.8][inference] Problem inferring type of method's parameter
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *  							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
@@ -943,8 +944,8 @@ public abstract class Scope {
 				continue nextVariable;
 			boolean isFirstBoundTypeVariable = false;
 			TypeBinding superType = this.kind == METHOD_SCOPE
-				? typeRef.resolveType((BlockScope)this, false/*no bound check*/)
-				: typeRef.resolveType((ClassScope)this);
+				? typeRef.resolveType((BlockScope)this, false/*no bound check*/, Binding.DefaultLocationTypeBound)
+				: typeRef.resolveType((ClassScope)this, Binding.DefaultLocationTypeBound);
 			if (superType == null) {
 				typeVariable.tagBits |= TagBits.HierarchyHasProblems;
 			} else {
@@ -5066,6 +5067,10 @@ public abstract class Scope {
 		}
 		return true;
 	}
+	
+	/** Answer a defaultNullness defined for the closest enclosing scope, using bits from Binding.NullnessDefaultMASK. */
+	public abstract boolean hasDefaultNullnessFor(int location);
+
 	public static BlockScope typeAnnotationsResolutionScope(Scope scope) {
 		BlockScope resolutionScope = null;
 		switch(scope.kind) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index d279d3c..7bb97d4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -30,6 +30,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 426048 - [1.8] NPE in TypeVariableBinding.internalBoundCheck when parentheses are not balanced
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *      Till Brychcy - Contributions for
@@ -87,7 +88,7 @@ public class SourceTypeBinding extends ReferenceBinding {
 
 	private SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
-	private int defaultNullness;
+	public int defaultNullness;
 	private int nullnessDefaultInitialized = 0; // 0: nothing; 1: type; 2: package
 	private int lambdaOrdinal = 0;
 	private ReferenceBinding containerAnnotationType = null;
@@ -1318,7 +1319,7 @@ void initializeForStaticImports() {
 	this.scope.buildMethods();
 }
 
-private int getNullDefault() {
+int getNullDefault() {
 	
 	if (!isPrototype()) {
 		return this.prototype.getNullDefault();
@@ -1740,7 +1741,7 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 					// enum constants neither have a type declaration nor can they be null
 					field.tagBits |= TagBits.AnnotationNonNull;
 				} else {
-					if (hasNonNullDefault()) {
+					if (hasNonNullDefaultFor(DefaultLocationField, sourceLevel >= ClassFileConstants.JDK1_8)) {
 						field.fillInDefaultNonNullness(fieldDecl, initializationScope);
 					}
 					// validate null annotation:
@@ -2029,35 +2030,78 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 		}
 	}
 	this.nullnessDefaultInitialized = 1;
-	// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
-	int newDefaultNullness = NO_NULL_DEFAULT;
-	if ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
-		newDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
-	else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)
-		newDefaultNullness = NONNULL_BY_DEFAULT;
-	if (newDefaultNullness != NO_NULL_DEFAULT) {
-		if (isPackageInfo) {
-			pkg.defaultNullness = newDefaultNullness;
-		} else {
-			this.defaultNullness = newDefaultNullness;
-			TypeDeclaration typeDecl = this.scope.referenceContext;
-			long nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);
-			checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits);
+	boolean isJdk18 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
+	if (isJdk18) {
+		if (this.defaultNullness != 0) {
+			if (isPackageInfo) {
+				pkg.defaultNullness = this.defaultNullness;
+			} else {
+				TypeDeclaration typeDecl = this.scope.referenceContext;
+				checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, this.defaultNullness, isJdk18);
+			}
+		} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
+			this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
+			if (!isInDefaultPkg)
+				pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+		}
+	} else {
+		// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
+		int newDefaultNullness = NO_NULL_DEFAULT;
+		if ((annotationTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+			newDefaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+		else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)
+			newDefaultNullness = NONNULL_BY_DEFAULT;
+		if (newDefaultNullness != NO_NULL_DEFAULT) {
+			if (isPackageInfo) {
+				pkg.defaultNullness = newDefaultNullness;
+			} else {
+				this.defaultNullness = newDefaultNullness;
+				TypeDeclaration typeDecl = this.scope.referenceContext;
+				long nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);
+				checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits, false);
+			}
+		} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
+			this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
+			if (!isInDefaultPkg)
+				pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+		}
+	}
+	maybeMarkTypeParametersNonNull();
+}
+
+private void maybeMarkTypeParametersNonNull() {
+	// when creating type variables we didn't yet have the defaultNullness, fill it in now:
+	if (this.scope == null || !this.scope.hasDefaultNullnessFor(DefaultLocationTypeParameter))
+		return;
+	if (this.typeVariables != null && this.typeVariables.length > 0) {
+		AnnotationBinding[] annots = new AnnotationBinding[]{ this.environment.getNonNullAnnotation() };
+		for (int i = 0; i < this.typeVariables.length; i++) {
+			TypeVariableBinding tvb = this.typeVariables[i];
+			if ((tvb.tagBits & TagBits.AnnotationNullMASK) == 0)
+				this.typeVariables[i] = (TypeVariableBinding) this.environment.createAnnotatedType(tvb, annots);
 		}
-	} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
-		this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
-		if (!isInDefaultPkg)
-			pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
 	}
 }
 
-protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long annotationTagBits) {
+/**
+ * Recursively check if the given annotations are redundant with equal annotations at an enclosing level.
+ * @param location fallback location to report the warning against (if we can't blame a specific annotation)
+ * @param annotations search these for the annotation that should be blamed in warning messages
+ * @param nullBits in 1.7- times these are the annotationTagBits, in 1.8+ the bitvector from {@link Binding#NullnessDefaultMASK}
+ * @param isJdk18 toggles the interpretation of 'nullBits'
+ * 
+ * @pre null annotation analysis is enabled
+ */
+protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
 	if (this.fPackage.defaultNullness != NO_NULL_DEFAULT) {
-		if ((this.fPackage.defaultNullness == NONNULL_BY_DEFAULT
-				&& ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0))) {
+		boolean isRedundant = isJdk18
+				? this.fPackage.defaultNullness == nullBits
+				: (this.fPackage.defaultNullness == NONNULL_BY_DEFAULT
+						&& ((nullBits & TagBits.AnnotationNonNullByDefault) != 0));
+		if (isRedundant) {
 			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this.fPackage);
 		}
 		return;
@@ -2065,13 +2109,16 @@ protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation
 }
 
 // return: should caller continue searching?
-protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[] annotations, long annotationTagBits) {
+protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[] annotations, long nullBits, boolean isJdk18) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
 	int thisDefault = getNullDefault();
-	if (thisDefault == NONNULL_BY_DEFAULT) {
-		if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+	if (thisDefault != NO_NULL_DEFAULT) {
+		boolean isRedundant = isJdk18
+				? thisDefault == nullBits
+				: (nullBits & TagBits.AnnotationNonNullByDefault) != 0;
+		if (isRedundant) {
 			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this);
 		}
 		return false; // different default means inner default is not redundant -> we're done
@@ -2079,10 +2126,18 @@ protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[
 	return true;
 }
 
-boolean hasNonNullDefault() {
+boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
+	// 1.8:
+	if (useTypeAnnotations) {
+		if (this.scope == null) {
+			return (this.defaultNullness & location) != 0;
+		}
+		return this.scope.hasDefaultNullnessFor(location);
+	}
+
 	// find the applicable default inside->out:
 
 	SourceTypeBinding currentType = null;
@@ -2103,6 +2158,9 @@ boolean hasNonNullDefault() {
 				currentType = ((ClassScope)currentScope).referenceContext.binding;
 				if (currentType != null) {
 					int foundDefaultNullness = currentType.getNullDefault();
+					if ((foundDefaultNullness & NullnessDefaultMASK) > NULL_UNSPECIFIED_BY_DEFAULT) {
+						return true;
+					}
 					if (foundDefaultNullness != NO_NULL_DEFAULT) {
 						return foundDefaultNullness == NONNULL_BY_DEFAULT;
 					}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 5a238e1..81ba847 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -16,6 +16,7 @@
  *								Bug 405569 - Resource leak check false positive when using DbUtils.closeQuietly
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 425183 - [1.8][inference] make CaptureBinding18 safe
+ *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *    Jesper S Moller - Contributions for
  *								Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -351,6 +352,16 @@ public interface TypeConstants {
 	char[] SYNTHETIC_ENUM_CONSTANT_INITIALIZATION_METHOD_PREFIX =  " enum constant initialization$".toCharArray(); //$NON-NLS-1$
 	char[] SYNTHETIC_STATIC_FACTORY =  "<factory>".toCharArray(); //$NON-NLS-1$
 
+	// constants in enum org.eclipse.jdt.annotation.DefaultLocation:
+	char[] DEFAULT_LOCATION__PARAMETER = "PARAMETER".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__RETURN_TYPE = "RETURN_TYPE".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__FIELD = "FIELD".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__TYPE_ARGUMENT = "TYPE_ARGUMENT".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__TYPE_PARAMETER = "TYPE_PARAMETER".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__TYPE_BOUND = "TYPE_BOUND".toCharArray(); //$NON-NLS-1$
+	char[] DEFAULT_LOCATION__ARRAY_CONTENTS = "ARRAY_CONTENTS".toCharArray(); //$NON-NLS-1$
+
+
 	// synthetic package-info name
 	public static final char[] PACKAGE_INFO_NAME = "package-info".toCharArray(); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 508b329..7a3ae9e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -9440,10 +9440,6 @@ public void nullDefaultAnnotationIsRedundant(ASTNode location, Annotation[] anno
 	this.handle(problemId, args, shortArgs, start, end);
 }
 
-public void nonNullDefaultDetailNotEvaluated(ASTNode location) {
-	this.handle(IProblem.NonNullDefaultDetailIsNotEvaluated, NoArgument, NoArgument, ProblemSeverities.Warning, location.sourceStart, location.sourceEnd);
-}
-
 public void contradictoryNullAnnotations(Annotation annotation) {
 	contradictoryNullAnnotations(annotation.sourceStart, annotation.sourceEnd);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index fdecfdf..5a26828 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -816,7 +816,7 @@
 965 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
 966 = Contradictory null annotations: method was inferred as ''{2} {3}({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
 967 = Null type safety: Unchecked cast from {0} to {1}
-968 = Arguments controling the details of the nullness default are not yet evaluated by the analysis.
+#968 temporary warning has been removed
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
