commit f0d3823e693314be74db80c5730855ddd690aa1f
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Wed Feb 27 19:31:52 2013 +0100

    Bug 401941: [1.8][compiler] DOM/AST structure review

7	7	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
30	30	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
57	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
26	19	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
14	14	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
2	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
8	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
109	184	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
84	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
30	30	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
43	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotatableType.java
18	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ArrayType.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BodyDeclaration.java
7	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
60	49	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
136	85	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ParameterizedType.java
32	24	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PrimitiveType.java
21	16	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
29	17	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
72	184	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
22	21	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
21	21	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeParameter.java
210	29	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
32	156	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
19	14	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/WildcardType.java
13	25	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
9	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
9	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index 6e91336..b9f5134 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -1055,25 +1055,25 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		List fragments = field.fragments();
 		assertEquals("Incorrect no of fragments", 3, fragments.size());
 		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
-		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensions(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 []");
 		fragment = (VariableDeclarationFragment) fragments.get(1);
-		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot4 []");		
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensions(), "@Annot2 @Annot3 [] @Annot4 []");		
 		fragment = (VariableDeclarationFragment) fragments.get(2);
-		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "[] [] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensions(), "[] [] []");
 		MethodDeclaration[] methods = type.getMethods();
 		assertEquals("Incorrect no of methods", 3, methods.length);
 		MethodDeclaration method = methods[0];
 		List parameters = method.parameters();
 		assertEquals("Incorrect no of parameters", 1, parameters.size());
-		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensions(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []");
 
 		method = methods[1];
 		parameters = method.parameters();
 		assertEquals("Incorrect no of parameters", 1, parameters.size());
-		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensionInfos(), "[] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensions(), "[] []");
 
 		method = methods[2];
-		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensionInfos(), "@Annot1 @Annot2 [] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensions(), "@Annot1 @Annot2 [] []");
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399600
 	public void test0010() throws JavaModelException {
@@ -1095,7 +1095,7 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		node = getASTNode(unit, 0, 0);
 		assertEquals("Not a method declaration", ASTNode.METHOD_DECLARATION, node.getNodeType());
 		MethodDeclaration method = (MethodDeclaration) node;
-		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensionInfos(), "@Marker [] @Marker []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensions(), "@Marker [] @Marker []");
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391894
 	public void test0011() throws JavaModelException {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
index d0de9ee..6b923f3 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
@@ -2719,23 +2719,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2762,23 +2762,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newArrayType(this.ast.newPrimitiveType(PrimitiveType.INT), 1));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2804,8 +2804,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.extraDimensionInfos().clear();
-		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		variableDeclarationFragment.extraDimensions().clear();
+		variableDeclarationFragment.extraDimensions().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String")), 1));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2833,8 +2833,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.extraDimensionInfos().clear();
-		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		variableDeclarationFragment.extraDimensions().clear();
+		variableDeclarationFragment.extraDimensions().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2862,8 +2862,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.extraDimensionInfos().clear();
-		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		variableDeclarationFragment.extraDimensions().clear();
+		variableDeclarationFragment.extraDimensions().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2892,7 +2892,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not a declaration", frag.getName().isDeclaration()); //$NON-NLS-1$
 		VariableDeclarationFragment fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i")); //$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2914,25 +2914,25 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10"); //$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.modifiers().add(this.ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("y"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		fragment.setInitializer(this.ast.newNullLiteral());
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensions().clear();
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.extraDimensionInfos().clear();
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
-		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().clear();
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
+		fragment.extraDimensions().add(this.ast.newExtraDimension());
 		fieldDeclaration.fragments().add(fragment);
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
 		checkSourceRange(node, "public int x= 10, y[] = null, i, j[][];", source); //$NON-NLS-1$
@@ -9604,7 +9604,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertNotNull("No type binding", typeBinding2); //$NON-NLS-1$
 		assertEquals("Wrong qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
-		List extraDimensions = methodDeclaration.extraDimensionInfos();
+		List extraDimensions = methodDeclaration.extraDimensions();
 		assertExtraDimensionsEqual("Wrong extra extra dimensions", extraDimensions, "[]");
 	}
 
@@ -9692,7 +9692,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not an array binding", typeBinding2.isArray()); //$NON-NLS-1$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
 		assertEquals("wrong fully qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
-		List extraDimensions = singleVariableDeclaration.extraDimensionInfos();
+		List extraDimensions = singleVariableDeclaration.extraDimensions();
 		assertExtraDimensionsEqual("Wrong extra extra dimensions", extraDimensions, "[]");
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
index e5311dd..9d38d6d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
@@ -1552,7 +1552,7 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		Annotation Annot = this.ast.newMarkerAnnotation();
 		Annot.setTypeName(this.ast.newSimpleName("NewAnnot1"));
 		x2.annotations().add(Annot);
-		x1.extraDimensionInfos().add(x2);
+		x1.extraDimensions().add(x2);
 		x2 = this.ast.newExtraDimension();
 		Annot = this.ast.newMarkerAnnotation();
 		Annot.setTypeName(this.ast.newSimpleName("NewAnnot2"));
@@ -1560,7 +1560,7 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		Annot = this.ast.newMarkerAnnotation();
 		Annot.setTypeName(this.ast.newSimpleName("NewAnnot3"));
 		x2.annotations().add(Annot);
-		x1.extraDimensionInfos().add(x2);
+		x1.extraDimensions().add(x2);
 		basicMatch(x1);
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
index e3bc2cb..0072ed8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java
@@ -397,6 +397,13 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		public void endVisit(QualifiedType node) {
 			ASTVisitorTest.this.b.append("tQ)"); //$NON-NLS-1$
 		}
+		public boolean visit(UnionType node) {
+			ASTVisitorTest.this.b.append("(tU"); //$NON-NLS-1$
+			return isVisitingChildren();
+		}
+		public void endVisit(UnionType node) {
+			ASTVisitorTest.this.b.append("tU)"); //$NON-NLS-1$
+		}
 		public boolean visit(WildcardType node) {
 			ASTVisitorTest.this.b.append("(tW"); //$NON-NLS-1$
 			return isVisitingChildren();
@@ -1048,6 +1055,14 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 			ASTVisitorTest.this.b.append("MOD)"); //$NON-NLS-1$
 		}
 
+		public boolean visit(ExtraDimension node) {
+			ASTVisitorTest.this.b.append("(@ED"); //$NON-NLS-1$
+			return isVisitingChildren();
+		}
+		public void endVisit(ExtraDimension node) {
+			ASTVisitorTest.this.b.append("@ED)"); //$NON-NLS-1$
+		}
+		
 		public void preVisit(ASTNode node) {
 			ASTVisitorTest.this.b.append("["); //$NON-NLS-1$
 		}
@@ -1148,6 +1163,21 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		assertTrue(result.equals("[(tW"+this.T1S+"tW)]")); //$NON-NLS-1$ //$NON-NLS-2$
 	}
 
+	/** @deprecated using deprecated code */
+	public void testUnionType() {
+		if (this.ast.apiLevel() <= AST.JLS4) {
+			return;
+		}
+		UnionType x1 = this.ast.newUnionType();
+		x1.types().add(this.T1);
+		x1.types().add(this.T2);
+		TestVisitor v1 = new TestVisitor();
+		this.b.setLength(0);
+		x1.accept(v1);
+		String result = this.b.toString();
+		assertTrue(result.equals("[(tU"+this.T1S+this.T2S+"tU)]")); //$NON-NLS-1$ //$NON-NLS-2$
+	}
+
 	// EXPRESSIONS and STATEMENTS
 
 	public void testArrayAccess() {
@@ -1433,6 +1463,20 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		String result = this.b.toString();
 		assertTrue(result.equals("[(sEX"+this.E1S+"sEX)]")); //$NON-NLS-1$ //$NON-NLS-2$
 	}
+	public void testExtraDimension() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		ExtraDimension x1 = this.ast.newExtraDimension();
+		x1.annotations().add(this.ANO1);
+		x1.annotations().add(this.ANO2);
+		TestVisitor v1 = new TestVisitor();
+		this.b.setLength(0);
+		x1.accept(v1);
+		String result = this.b.toString();
+		assertEquals("[(@ED"+this.ANO1S+this.ANO2S+"@ED)]", result); //$NON-NLS-1$ //$NON-NLS-2$
+	}
+
 	public void testFieldAccess() {
 		FieldAccess x1 = this.ast.newFieldAccess();
 		x1.setExpression(this.E1);
@@ -2014,8 +2058,18 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		String result = this.b.toString();
 		assertTrue(result.equals("[(sTR"+this.E1S+"sTR)]")); //$NON-NLS-1$ //$NON-NLS-2$
 	}
+	/** @deprecated using deprecated code */
 	public void testTryStatement() {
 		TryStatement x1 = this.ast.newTryStatement();
+		int level = this.ast.apiLevel();
+		if (level >= AST.JLS4) {
+			VariableDeclarationExpression vde1= this.ast.newVariableDeclarationExpression(this.W1);
+			vde1.setType(this.T1);
+			x1.resources().add(vde1);
+			VariableDeclarationExpression vde2= this.ast.newVariableDeclarationExpression(this.W2);
+			vde2.setType(this.T2);
+			x1.resources().add(vde2);
+		}
 		x1.setBody(this.B1);
 		CatchClause c1 = this.ast.newCatchClause();
 		c1.setException(this.V1);
@@ -2030,7 +2084,9 @@ public class ASTVisitorTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		this.b.setLength(0);
 		x1.accept(v1);
 		String result = this.b.toString();
-		assertTrue(result.equals("[(sTY"+this.B1S+"[(cc"+this.V1S+"[(sBsB)]"+"cc)]"+"[(cc"+this.V2S+"[(sBsB)]"+"cc)]"+"[(sBsB)]"+"sTY)]")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$
+		assertEquals("[(sTY"
+				+(level >= AST.JLS4 ? "[(eVD"+this.T1S+this.W1S+"eVD)]"+"[(eVD"+this.T2S+this.W2S+"eVD)]" : "")
+				+this.B1S+"[(cc"+this.V1S+"[(sBsB)]"+"cc)]"+"[(cc"+this.V2S+"[(sBsB)]"+"cc)]"+"[(sBsB)]"+"sTY)]", result); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$
 	}
 	/** @deprecated using deprecated code */
 	public void testTypeDeclaration() {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
index 02e2d8f..d52edf1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
@@ -37,6 +37,12 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 	 * @deprecated
 	 */
 	private static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant MethodDeclaration#THROWN_EXCEPTIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	private static final ChildListPropertyDescriptor INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY = MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY;
 
 	public ASTRewritingMethodDeclTest(String name) {
 		super(name);
@@ -68,8 +74,9 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		return this.apiLevel < AST.JLS8 ? methodDecl.thrownExceptions() : methodDecl.thrownExceptionTypes(); 
 	} 
 
+	/** @deprecated using deprecated code */
 	private ChildListPropertyDescriptor getMethodThrownExceptionsProperty(AST ast) { 
-		return ast.apiLevel() < AST.JLS8 ? MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY; 
+		return ast.apiLevel() < AST.JLS8 ? INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY; 
 	} 
 
 	public void testMethodDeclChanges() throws Exception {
@@ -950,7 +957,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			assertTrue("must be 0 thrown exceptions", thrownExceptions.size() == 0);
 
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertFirst(newThrownException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertFirst(newThrownException, null);
 
 		}
 		{ // insert before second param & insert before first exception & add synchronized
@@ -972,7 +979,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			ASTNode firstException= (ASTNode) thrownExceptions.get(0);
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertBefore(newThrownException, firstException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertBefore(newThrownException, firstException, null);
 		}
 		{ // insert after last param & insert after first exception & add synchronized, static
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "hee");
@@ -992,7 +999,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			ASTNode firstException= (ASTNode) thrownExceptions.get(0);
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, firstException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, firstException, null);
 
 		}
 		{ // insert 2 params before first & insert between two exception
@@ -1014,7 +1021,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			ASTNode firstException= (ASTNode) thrownExceptions.get(0);
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, firstException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, firstException, null);
 		}
 		{ // insert 2 params after first & replace the second exception and insert new after
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "jee");
@@ -1034,7 +1041,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			assertTrue("must be 2 thrown exceptions", thrownExceptions.size() == 2);
 
 			Name newThrownException1= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException1, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException1, null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.replace((ASTNode) thrownExceptions.get(1), newThrownException2, null);
@@ -1060,7 +1067,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.remove(lastException, null);
 
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertBefore(newThrownException, lastException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertBefore(newThrownException, lastException, null);
 		}
 		{ // insert at first and last position & remove 2nd, add after 2nd, remove 3rd
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "lee");
@@ -1083,7 +1090,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.remove(lastException, null);
 
 			Name newThrownException= ast.newSimpleName("InterruptedException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, secondException, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertAfter(newThrownException, secondException, null);
 
 		}
 
@@ -1473,7 +1480,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
 
 		}
 		{ // add extra dim, remove throws
@@ -1489,7 +1496,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
 
 		}
 		{ // add extra dim, remove throws
@@ -1509,7 +1516,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
-			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
+			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
 
 		}
 		{ // remove params, add extra dim, remove throws
@@ -2979,14 +2986,14 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo4");
-			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(0);
+			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensions().get(0);
 			ListRewrite listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot2"));
 			listRewrite.insertAt(markerAnnotation, 0, null);
 
-			dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(1);
+			dim= (ExtraDimension) methodDecl.extraDimensions().get(1);
 			listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 
 			markerAnnotation= ast.newMarkerAnnotation();
@@ -2995,23 +3002,23 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo5");
-			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(0);
+			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensions().get(0);
 			Annotation annot= (Annotation) dim.annotations().get(0);
 			ListRewrite listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			listRewrite.remove(annot, null);
 
-			dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(1);
+			dim= (ExtraDimension) methodDecl.extraDimensions().get(1);
 			listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			listRewrite.insertAt(annot, 1, null);
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo6");
-			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(0);
+			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensions().get(0);
 			Annotation annot= (Annotation) dim.annotations().get(0);
 			ListRewrite listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			listRewrite.remove(annot, null);
 
-			dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(1);
+			dim= (ExtraDimension) methodDecl.extraDimensions().get(1);
 			annot= (Annotation) dim.annotations().get(0);
 			listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			listRewrite.remove(annot, null);
@@ -3019,9 +3026,9 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo7");
 			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
-			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(0);
+			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensions().get(0);
 			listRewrite.remove(dim, null);
-			dim= (ExtraDimension) methodDecl.extraDimensionInfos().get(1);
+			dim= (ExtraDimension) methodDecl.extraDimensions().get(1);
 			listRewrite.remove(dim, null);
 		}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
index e3e3276..9d46521 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
@@ -93,7 +93,7 @@ public class ASTRewritingStatementsTest extends ASTRewritingTest {
 			node.setExtraDimensions(dimensions);
 		} else {
 			while (dimensions > 0) {
-				node.extraDimensionInfos().add(node.getAST().newExtraDimension());
+				node.extraDimensions().add(node.getAST().newExtraDimension());
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
index 35fafea..0bfc443 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
@@ -1760,7 +1760,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			ASTNode name= ast.newSimpleName("a");
 			rewrite.replace(fragment.getName(), name, null);
 
-			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot1"));
@@ -1782,7 +1782,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			assertTrue("Has no initializer", fragment.getInitializer() != null);
 			rewrite.remove(fragment.getInitializer(), null);
 
-			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot1"));
@@ -1799,7 +1799,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			Expression initializer= ast.newNullLiteral();
 			rewrite.set(fragment, VariableDeclarationFragment.INITIALIZER_PROPERTY, initializer, null);
 
-			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
 
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
@@ -1814,20 +1814,20 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // remove one dimension and add annotations for the rest of the dimensions
 			VariableDeclarationFragment fragment= (VariableDeclarationFragment) fragments.get(4);
 
-			ExtraDimension dim= (ExtraDimension) fragment.extraDimensionInfos().get(1);
+			ExtraDimension dim= (ExtraDimension) fragment.extraDimensions().get(1);
 			ListRewrite listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot1"));
 			listRewrite.insertAt(markerAnnotation, 0, null);
 
-			dim= (ExtraDimension) fragment.extraDimensionInfos().get(2);
+			dim= (ExtraDimension) fragment.extraDimensions().get(2);
 			markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot2"));
 			listRewrite= rewrite.getListRewrite(dim, ExtraDimension.ANNOTATIONS_PROPERTY);
 			listRewrite.insertAt(markerAnnotation, 0, null);
 
-			listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
-			listRewrite.remove((ExtraDimension) fragment.extraDimensionInfos().get(0), null);
+			listRewrite= rewrite.getListRewrite(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
+			listRewrite.remove((ExtraDimension) fragment.extraDimensions().get(0), null);
 		}
 		{ // remove a fragment
 			ListRewrite listRewrite= rewrite.getListRewrite(variableDeclStatement, VariableDeclarationStatement.FRAGMENTS_PROPERTY);
@@ -1881,19 +1881,19 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // add modifier, move extra dimensions from one variable to another
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(0);
 			SingleVariableDeclaration decl2= (SingleVariableDeclaration) arguments.get(1);
-			ExtraDimension dim= (ExtraDimension) decl2.extraDimensionInfos().get(0);
+			ExtraDimension dim= (ExtraDimension) decl2.extraDimensions().get(0);
 			ListRewrite listRewrite= rewrite.getListRewrite(decl, SingleVariableDeclaration.MODIFIERS2_PROPERTY);
 			listRewrite.insertFirst(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD), null);
 
-			listRewrite= rewrite.getListRewrite(decl2, SingleVariableDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			listRewrite= rewrite.getListRewrite(decl2, SingleVariableDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			listRewrite.remove(dim, null);
-			listRewrite= rewrite.getListRewrite(decl, SingleVariableDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			listRewrite= rewrite.getListRewrite(decl, SingleVariableDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			listRewrite.insertAt(dim, 0, null);
 		}
 		{ // move annotations from one dim to another
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(2);
-			ExtraDimension dim1= (ExtraDimension) decl.extraDimensionInfos().get(0);
-			ExtraDimension dim2= (ExtraDimension) decl.extraDimensionInfos().get(1);
+			ExtraDimension dim1= (ExtraDimension) decl.extraDimensions().get(0);
+			ExtraDimension dim2= (ExtraDimension) decl.extraDimensions().get(1);
 			Annotation annot1= (Annotation) dim1.annotations().get(0);
 			Annotation annot2= (Annotation) dim2.annotations().get(0);
 
@@ -1905,8 +1905,8 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		}
 		{ // remove extra dim
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(3);
-			ListRewrite listRewrite= rewrite.getListRewrite(decl, SingleVariableDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
-			listRewrite.remove((ExtraDimension) decl.extraDimensionInfos().get(0), null);
+			ListRewrite listRewrite= rewrite.getListRewrite(decl, SingleVariableDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
+			listRewrite.remove((ExtraDimension) decl.extraDimensions().get(0), null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index a15e677..95b90ec 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1359,6 +1359,8 @@ public final class AST {
 	 * By default, the union type has no types.
 	 *
 	 * @return a new unparented do statement node
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS2 or JLS3 AST
 	 * @since 3.7.1
 	 */
 	public UnionType newUnionType() {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index be4665c..335193d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -542,7 +542,7 @@ class ASTConverter {
 				int extraDimensions = retrieveExtraDimension(rightParenthesisPosition, method.bodyEnd);
 				if (this.ast.apiLevel >= AST.JLS8) {
 					setExtraAnnotatedDimensions(rightParenthesisPosition, this.scanner.currentPosition, typeReference,
-												methodDecl.extraDimensionInfos, extraDimensions);
+												methodDecl.extraDimensions(), extraDimensions);
 				} else {
 					internalSetExtraDimensions(methodDecl, extraDimensions);
 				}
@@ -868,7 +868,7 @@ class ASTConverter {
 		final int extraDimensions = retrieveExtraDimension(nameEnd + 1, typeSourceEnd);
 		if (this.ast.apiLevel >= AST.JLS8) {
 			setExtraAnnotatedDimensions(nameEnd + 1, this.scanner.currentPosition, argument.type,
-										variableDecl.extraDimensionInfos, extraDimensions);
+										variableDecl.extraDimensions(), extraDimensions);
 		} else {
 			internalSetExtraDimensions(variableDecl, extraDimensions);
 		}
@@ -890,7 +890,7 @@ class ASTConverter {
 			if (type.isAnnotatable()) {
 				AnnotatableType annotatableType = (AnnotatableType) type;
 				if (this.ast.apiLevel() >= AST.JLS8 && !annotatableType.annotations().isEmpty()) {
-					Iterator annotations = annotatableType.annotations.iterator();
+					Iterator annotations = annotatableType.annotations().iterator();
 					while (annotations.hasNext()) {
 						Annotation annotation = (Annotation) annotations.next();
 						annotation.setParent(null, null);
@@ -3039,7 +3039,7 @@ class ASTConverter {
 		final int extraDimensions = retrieveExtraDimension(nameEnd + 1, localDeclaration.type.sourceEnd);
 		if (this.ast.apiLevel >= AST.JLS8) {
 			setExtraAnnotatedDimensions(nameEnd + 1, this.scanner.currentPosition, localDeclaration.type,
-					variableDecl.extraDimensionInfos, extraDimensions);
+					variableDecl.extraDimensions(), extraDimensions);
 		} else {
 			internalSetExtraDimensions(variableDecl, extraDimensions);
 		}
@@ -3069,7 +3069,7 @@ class ASTConverter {
 		ExtraDimension dimension = this.ast.newExtraDimension();
 		for (int i = 0; i < length; i++) {
 			Annotation annot = convert(annotation[i]);
-			dimension.annotations.add(annot);
+			dimension.annotations().add(annot);
 		}
 		retrieveDimensionAndSetPositions(start, end, dimension);
 		return dimension;
@@ -3086,7 +3086,7 @@ class ASTConverter {
 		int extraDimensions = retrieveExtraDimension(fieldDeclaration.sourceEnd + 1, fieldDeclaration.declarationSourceEnd );
 		if (this.ast.apiLevel >= AST.JLS8) {
 			setExtraAnnotatedDimensions(fieldDeclaration.sourceEnd + 1, this.scanner.currentPosition,
-					fieldDeclaration.type, variableDeclarationFragment.extraDimensionInfos, extraDimensions);
+					fieldDeclaration.type, variableDeclarationFragment.extraDimensions(), extraDimensions);
 		} else {
 			internalSetExtraDimensions(variableDeclarationFragment, extraDimensions);
 		}
@@ -3129,7 +3129,7 @@ class ASTConverter {
 		int extraDimension = retrieveExtraDimension(localDeclaration.sourceEnd + 1, this.compilationUnitSourceLength);
 		if (this.ast.apiLevel >= AST.JLS8) {
 			setExtraAnnotatedDimensions(localDeclaration.sourceEnd + 1, this.scanner.currentPosition,
-					localDeclaration.type, variableDeclarationFragment.extraDimensionInfos, extraDimension);
+					localDeclaration.type, variableDeclarationFragment.extraDimensions(), extraDimension);
 		} else {
 			internalSetExtraDimensions(variableDeclarationFragment, extraDimension);
 		}
@@ -3208,7 +3208,7 @@ class ASTConverter {
 						int start = typeAnnotation.sourceStart;
 						int end = typeAnnotation.sourceEnd;
 						annotation.setSourceRange(start, end - start + 1);
-						type.annotations.add(annotation);
+						type.annotations().add(annotation);
 					}
 				}
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index c6fcb44..06ba23f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -330,37 +330,9 @@ public class ASTMatcher {
 			return false;
 		}
 		ArrayType o = (ArrayType) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return safeSubtreeMatch(node.getComponentType(), o.getComponentType());
-			default:
-				return safeSubtreeMatch(node.getComponentType(), o.getComponentType()) &&
-						safeSubtreeListMatch(node.annotations(), o.annotations());
-		}
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
-	 * @since 3.9
-	 */
-	public boolean match(ExtraDimension node, Object other) {
-		if (!(other instanceof ExtraDimension))
-			return false;
-		ExtraDimension o = (ExtraDimension) other;
-		return safeSubtreeListMatch(node.annotations(), o.annotations());
+		int level = node.getAST().apiLevel;
+		return safeSubtreeMatch(node.getComponentType(), o.getComponentType())
+				&& (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true);
 	}
 
 	/**
@@ -728,32 +700,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.7.1
-	 */
-	public boolean match(UnionType node, Object other) {
-		if (!(other instanceof UnionType)) {
-			return false;
-		}
-		UnionType o = (UnionType) other;
-		return
-			safeSubtreeListMatch(
-				node.types(),
-				o.types());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(DoStatement node, Object other) {
 		if (!(other instanceof DoStatement)) {
@@ -908,6 +854,29 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.9
+	 */
+	public boolean match(ExtraDimension node, Object other) {
+		if (!(other instanceof ExtraDimension)) {
+			return false;
+		}
+		ExtraDimension o = (ExtraDimension) other;
+		return safeSubtreeListMatch(node.annotations(), o.annotations());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(FieldAccess node, Object other) {
 		if (!(other instanceof FieldAccess)) {
@@ -1388,45 +1357,28 @@ public class ASTMatcher {
 		}
 		MethodDeclaration o = (MethodDeclaration) other;
 		int level = node.getAST().apiLevel;
-		if (level == AST.JLS2_INTERNAL) {
-			if (node.getModifiers() != o.getModifiers()) {
-				return false;
-			}
-			if (!safeSubtreeMatch(node.internalGetReturnType(), o.internalGetReturnType())) {
-				return false;
-			}
-		}
-		if (level >= AST.JLS3_INTERNAL) {
-			if (!safeSubtreeListMatch(node.modifiers(), o.modifiers())) {
-				return false;
-			}
-			if (!safeSubtreeMatch(node.getReturnType2(), o.getReturnType2())) {
-				return false;
-			}
-			// n.b. compare type parameters even for constructors
-			if (!safeSubtreeListMatch(node.typeParameters(), o.typeParameters())) {
-				return false;
-			}
-		}
-		if (level >= AST.JLS8) {
-			if (!safeSubtreeMatch(node.getReceiverType(), o.getReceiverType())) {
-				return false;
-			}
-			if (!safeSubtreeMatch(node.getReceiverQualifier(), o.getReceiverQualifier())) {
-				return false;
-			}
-		}
-		return ((node.isConstructor() == o.isConstructor())
+		return node.isConstructor() == o.isConstructor()
 				&& safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
+				&& (level >= AST.JLS3_INTERNAL
+						? safeSubtreeListMatch(node.modifiers(), o.modifiers())
+								&& safeSubtreeListMatch(node.typeParameters(), o.typeParameters())
+								// n.b. compare return type even for constructors
+								&& safeSubtreeMatch(node.getReturnType2(), o.getReturnType2())
+						: node.getModifiers() == o.getModifiers()
+								// n.b. compare return type even for constructors
+								&& safeSubtreeMatch(node.internalGetReturnType(), o.internalGetReturnType()))
 				&& safeSubtreeMatch(node.getName(), o.getName())
-				// n.b. compare return type even for constructors
+				&& (level >= AST.JLS8
+						? safeSubtreeMatch(node.getReceiverType(), o.getReceiverType())
+								&& safeSubtreeMatch(node.getReceiverQualifier(), o.getReceiverQualifier())
+						: true)
 				&& safeSubtreeListMatch(node.parameters(), o.parameters())
-				&& ((node.getAST().apiLevel < AST.JLS8) ?
-							(node.getExtraDimensions() == o.getExtraDimensions()
-								&& safeSubtreeListMatch(node.thrownExceptions(), o.thrownExceptions())) :
-							(safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos())
-								&& safeSubtreeListMatch(node.thrownExceptionTypes(), o.thrownExceptionTypes())))
-				&& safeSubtreeMatch(node.getBody(), o.getBody()));
+				&& (level >= AST.JLS8
+						? safeSubtreeListMatch(node.extraDimensions(), o.extraDimensions())
+								&& safeSubtreeListMatch(node.thrownExceptionTypes(), o.thrownExceptionTypes())
+						: node.getExtraDimensions() == o.getExtraDimensions()
+								&& safeSubtreeListMatch(node.internalThrownExceptions(), o.internalThrownExceptions()))
+				&& safeSubtreeMatch(node.getBody(), o.getBody());
 	}
 
 	/**
@@ -1692,15 +1644,9 @@ public class ASTMatcher {
 			return false;
 		}
 		PrimitiveType o = (PrimitiveType) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return (node.getPrimitiveTypeCode() == o.getPrimitiveTypeCode());
-			default:
-				return (node.getPrimitiveTypeCode() == o.getPrimitiveTypeCode()) &&
-						safeSubtreeListMatch(node.annotations(), o.annotations());
-		}		
+		int level = node.getAST().apiLevel;
+		return (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true)
+				&& node.getPrimitiveTypeCode() == o.getPrimitiveTypeCode();
 	}
 
 	/**
@@ -1722,7 +1668,6 @@ public class ASTMatcher {
 			return false;
 		}
 		QualifiedName o = (QualifiedName) other;
-
 		return safeSubtreeMatch(node.getQualifier(), o.getQualifier())
 				&& safeSubtreeMatch(node.getName(), o.getName());
 	}
@@ -1747,20 +1692,10 @@ public class ASTMatcher {
 			return false;
 		}
 		QualifiedType o = (QualifiedType) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return (
-						safeSubtreeMatch(node.getQualifier(), o.getQualifier())
-							&& safeSubtreeMatch(node.getName(), o.getName()));
-			default:
-				return (
-						safeSubtreeMatch(node.getQualifier(), o.getQualifier())
-							&& safeSubtreeMatch(node.getName(), o.getName())
-							&& safeSubtreeListMatch(node.annotations(), o.annotations()));
-		}
-		
+		int level = node.getAST().apiLevel;
+		return safeSubtreeMatch(node.getQualifier(), o.getQualifier())
+				&& (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true)
+				&& safeSubtreeMatch(node.getName(), o.getName());
 	}
 
 	/**
@@ -1826,15 +1761,9 @@ public class ASTMatcher {
 			return false;
 		}
 		SimpleType o = (SimpleType) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return safeSubtreeMatch(node.getName(), o.getName());
-			default:
-				return (safeSubtreeMatch(node.getName(), o.getName())) &&
-						safeSubtreeListMatch(node.annotations(), o.annotations());
-		}
+		int level = node.getAST().apiLevel;
+		return (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true)
+				&& safeSubtreeMatch(node.getName(), o.getName());
 	}
 
 	/**
@@ -1885,27 +1814,21 @@ public class ASTMatcher {
 		}
 		SingleVariableDeclaration o = (SingleVariableDeclaration) other;
 		int level = node.getAST().apiLevel;
-		if (level == AST.JLS2_INTERNAL) {
-			if (node.getModifiers() != o.getModifiers()) {
-				return false;
-			}
-		}
-		if (level >= AST.JLS3_INTERNAL) {
-			if (!safeSubtreeListMatch(node.modifiers(), o.modifiers())) {
-				return false;
-			}
-			if (node.isVarargs() != o.isVarargs()) {
-				return false;
-			}
-		}
-		return
-		    safeSubtreeMatch(node.getType(), o.getType())
+		return (level >= AST.JLS3_INTERNAL
+						? safeSubtreeListMatch(node.modifiers(), o.modifiers())
+						: node.getModifiers() == o.getModifiers())
+				&& safeSubtreeMatch(node.getType(), o.getType())
+				&& (level >= AST.JLS8 && node.isVarargs()
+						? safeSubtreeListMatch(node.varargsAnnotations(), o.varargsAnnotations())
+						: true)
+				&& (level >= AST.JLS3_INTERNAL
+						? node.isVarargs() == o.isVarargs()
+						: true)
 				&& safeSubtreeMatch(node.getName(), o.getName())
-	 			&& ((node.getAST().apiLevel < AST.JLS8) ?
-	 					node.getExtraDimensions() == o.getExtraDimensions() :
-	 						safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos()))
-				&& safeSubtreeMatch(node.getInitializer(), o.getInitializer())
-				&& (level >= AST.JLS8 && node.isVarargs()) ? safeSubtreeListMatch(node.varargsAnnotations(), o.varargsAnnotations()) : true;		
+				&& ((level >= AST.JLS8)
+						? safeSubtreeListMatch(node.extraDimensions(), o.extraDimensions())
+						: node.getExtraDimensions() == o.getExtraDimensions())
+				&& safeSubtreeMatch(node.getInitializer(), o.getInitializer());
 	}
 
 	/**
@@ -2194,19 +2117,11 @@ public class ASTMatcher {
 			return false;
 		}
 		TryStatement o = (TryStatement) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-				return (
-						safeSubtreeMatch(node.getBody(), o.getBody())
-							&& safeSubtreeListMatch(node.catchClauses(), o.catchClauses())
-							&& safeSubtreeMatch(node.getFinally(), o.getFinally()));
-		}
-		return (
-			safeSubtreeListMatch(node.resources(), o.resources())
-			&& safeSubtreeMatch(node.getBody(), o.getBody())
-			&& safeSubtreeListMatch(node.catchClauses(), o.catchClauses())
-			&& safeSubtreeMatch(node.getFinally(), o.getFinally()));
+		int level = node.getAST().apiLevel;
+		return (level >= AST.JLS4 ? safeSubtreeListMatch(node.resources(), o.resources()) : true)
+				&& safeSubtreeMatch(node.getBody(), o.getBody())
+				&& safeSubtreeListMatch(node.catchClauses(), o.catchClauses())
+				&& safeSubtreeMatch(node.getFinally(), o.getFinally());
 	}
 
 	/**
@@ -2325,17 +2240,33 @@ public class ASTMatcher {
 			return false;
 		}
 		TypeParameter o = (TypeParameter) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return (safeSubtreeMatch(node.getName(), o.getName())
-						&& safeSubtreeListMatch(node.typeBounds(), o.typeBounds()));
-			default:
-				return (safeSubtreeMatch(node.getName(), o.getName())
-						&& safeSubtreeListMatch(node.typeBounds(), o.typeBounds())
-						&& safeSubtreeListMatch(node.annotations(), o.annotations()));
+		int level = node.getAST().apiLevel;
+		return (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true)
+				&& safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.typeBounds(), o.typeBounds());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
+	 * @since 3.7.1
+	 */
+	public boolean match(UnionType node, Object other) {
+		if (!(other instanceof UnionType)) {
+			return false;
 		}
+		UnionType o = (UnionType) other;
+		return safeSubtreeListMatch(node.types(),	o.types());
 	}
 
 	/**
@@ -2395,11 +2326,12 @@ public class ASTMatcher {
 			return false;
 		}
 		VariableDeclarationFragment o = (VariableDeclarationFragment) other;
+		int level = node.getAST().apiLevel;
 		return safeSubtreeMatch(node.getName(), o.getName())
-			&& ((node.getAST().apiLevel < AST.JLS8) ?
-					node.getExtraDimensions() == o.getExtraDimensions() :
-						safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos()))
-			&& safeSubtreeMatch(node.getInitializer(), o.getInitializer());
+				&& (level >= AST.JLS8
+						? safeSubtreeListMatch(node.extraDimensions(), o.extraDimensions())
+						: node.getExtraDimensions() == o.getExtraDimensions())
+				&& safeSubtreeMatch(node.getInitializer(), o.getInitializer());
 	}
 
 	/**
@@ -2480,17 +2412,10 @@ public class ASTMatcher {
 			return false;
 		}
 		WildcardType o = (WildcardType) other;
-		switch(node.getAST().apiLevel) {
-			case AST.JLS2_INTERNAL :
-			case AST.JLS3_INTERNAL :
-			case AST.JLS4:
-				return (node.isUpperBound() == o.isUpperBound()
-						&& safeSubtreeMatch(node.getBound(), o.getBound()));
-			default:
-				return (node.isUpperBound() == o.isUpperBound()
-						&& safeSubtreeMatch(node.getBound(), o.getBound()) &&
-						safeSubtreeListMatch(node.annotations(), o.annotations()));
-		}
+		int level = node.getAST().apiLevel;
+		return (level >= AST.JLS8 ? safeSubtreeListMatch(node.annotations(), o.annotations()) : true)
+				&& node.isUpperBound() == o.isUpperBound()
+				&& safeSubtreeMatch(node.getBound(), o.getBound());
 	}
 
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index f79e6ed..0cc2988 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -128,10 +128,26 @@ import org.eclipse.jdt.internal.core.dom.NaiveASTFlattener;
  */
 public abstract class ASTNode {
 	/*
+	 * ATTENTION: When doing anything to the ASTNode hierarchy, do not try to
+	 * reinvent the wheel.
+	 * 
+	 * Look out for precedents with
+	 * - the same structural property type
+	 * - for child node properties: the same optionality (can be null / lazy initialization blurbs and impl.)
+	 * - the same declaring node type kind (abstract supertype or concrete type)
+	 * - a similar history (added in JLSx API, below JLSx only, replaced by {@link #xx})
+	 * ..., and copy what was done there. Most of the code and
+	 * Javadoc in this package should look like it was created by a code generator.
+	 * 
+	 * In subclasses of ASTNode, order properties by order of occurrence in source.
+	 * In general classes that list all AST node types, order alphabetically.  
+	 */
+
+	/*
 	 * INSTRUCTIONS FOR ADDING NEW CONCRETE AST NODE TYPES
 	 *
 	 * There are several things that need to be changed when a
-	 * new concrete AST node type (call it "FooBar"):
+	 * new concrete AST node type (call it "FooBar") is added:
 	 *
 	 * 1. Create the FooBar AST node type class.
 	 * The most effective way to do this is to copy a similar
@@ -146,7 +162,7 @@ public abstract class ASTNode {
 	 *
 	 * 4. Add AST.newFooBar() factory method.
 	 *
-	 * 5. Add ASTVisitor.visit(FooBar) and endVisit(FooBar) methods.
+	 * 5. Add ASTVisitor.visit(FooBar) and endVisit(FooBar) methods. Same for DefaultASTVisitor.
 	 *
 	 * 6. Add ASTMatcher.match(FooBar,Object) method.
 	 *
@@ -156,12 +172,57 @@ public abstract class ASTNode {
 	 * 8. Add NaiveASTFlattener.visit(FooBar) method to illustrate
 	 * how these nodes should be serialized.
 	 *
-	 * 9. Update the AST test suites.
+	 * 9. Update the AST test suites (ASTVisitorTest, etc.)
 	 *
 	 * The next steps are to update AST.parse* to start generating
 	 * the new type of nodes, and ASTRewrite to serialize them back out.
 	 */
 
+	/*
+	 * INSTRUCTIONS FOR ADDING A NEW PROPERTY TO AN AST NODE TYPE
+	 * 
+	 * For concrete node types, use e.g. properties of SimpleName or ClassInstanceCreation
+	 * as templates:
+	 * 
+	 * 1. Copy/paste the field, property descriptor, and getter/setter.
+	 * 
+	 * 2. Adjust everything to the new property name and type. In the field's
+	 * Javadoc, properly document default value, initialization, and applicable
+	 * API levels.
+	 * 
+	 * 3. Add/remove @since tags as necessary.
+	 * 
+	 * 4. Search for references to the members in the template, and add similar
+	 * references in corresponding places for the new property.
+	 * 
+	 * 
+	 * For abstract node types, use AbstractTypeDeclaration as a template:
+	 * 
+	 * 1. Same steps as above, but take extra care to copy and adjust the
+	 * *internal*() methods as well. 
+	 * 
+	 * 2. Search for references to the members in the template, and add similar
+	 * references in corresponding places for the new property (e.g. property
+	 * descriptor in each leaf type).
+	 */
+
+	/*
+	 * INSTRUCTIONS FOR REPLACING/DEPRECATING A PROPERTY OF AN AST NODE
+	 * 
+	 * To replace a simple property with a child list property, see e.g. how
+	 * SingleVariableDeclaration replaced MODIFIERS_PROPERTY with
+	 * MODIFIERS2_PROPERTY.
+	 * 
+	 * 1. Reuse the old property id.
+	 * 
+	 * 2. Deprecate all references to the old property, except for the old
+	 * getter, which should compute the value from the new property in
+	 * later API levels.
+	 * 
+	 * To completely replace a property, see how ClassInstanceCreation replaced
+	 * NAME_PROPERTY with TYPE_PROPERTY.
+	 */
+
 	/**
 	 * Node type constant indicating a node of type
 	 * <code>AnonymousClassDeclaration</code>.
@@ -849,6 +910,8 @@ public abstract class ASTNode {
 				return EnumDeclaration.class;
 			case EXPRESSION_STATEMENT :
 				return ExpressionStatement.class;
+			case EXTRA_DIMENSION:
+				return ExtraDimension.class;
 			case FIELD_ACCESS :
 				return FieldAccess.class;
 			case FIELD_DECLARATION :
@@ -961,8 +1024,6 @@ public abstract class ASTNode {
 				return WhileStatement.class;
 			case WILDCARD_TYPE :
 				return WildcardType.class;
-			case EXTRA_DIMENSION:
-				return ExtraDimension.class;
 		}
 		throw new IllegalArgumentException();
 	}
@@ -1747,8 +1808,8 @@ public abstract class ASTNode {
 	 * Internal helper method that starts the building a list of
 	 * property descriptors for the given node type.
 	 *
-	 * @param nodeClass the class for a concrete node type
-	 * @param propertyList empty list
+	 * @param nodeClass the class for a concrete node type with n properties
+	 * @param propertyList empty list, with capacity for n+1 elements
 	 */
 	static void createPropertyList(Class nodeClass, List propertyList) {
 		// stuff nodeClass at head of list for future ref
@@ -2530,6 +2591,21 @@ public abstract class ASTNode {
 	 * This method must be implemented in subclasses.
 	 * </p>
 	 * <p>
+	 * General template for implementation on each concrete ASTNode class:
+	 * <pre>
+	 * <code>
+	 * ConcreteNodeType result = new ConcreteNodeType(target);
+	 * result.setSourceRange(getStartPosition(), getLength());
+	 * result.setChildProperty(
+	 *         (ChildPropertyType) ASTNode.copySubtree(target, getChildProperty()));
+	 * result.setSimpleProperty(isSimpleProperty());
+	 * result.childrenProperty().addAll(
+	 *         ASTNode.copySubtrees(target, childrenProperty()));
+	 * return result;
+	 * </code>
+	 * </pre>
+	 * </p>
+	 * <p>
 	 * This method does not report pre- and post-clone events.
 	 * All callers should instead call <code>clone(AST)</code>
 	 * to ensure that pre- and post-clone events are reported.
@@ -2575,7 +2651,7 @@ public abstract class ASTNode {
 	 * if (visitChildren) {
 	 *    // visit children in normal left to right reading order
 	 *    acceptChild(visitor, getProperty1());
-	 *    acceptChildren(visitor, rawListProperty);
+	 *    acceptChildren(visitor, this.rawListProperty);
 	 *    acceptChild(visitor, getProperty2());
 	 * }
 	 * visitor.endVisit(this);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 262d584..b2c0834 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -214,23 +214,6 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.9
-	 */
-	public boolean visit(ExtraDimension node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
-	 * Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
 	 * @since 3.1
 	 */
 	public boolean visit(AnnotationTypeMemberDeclaration node) {
@@ -658,6 +641,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.9
+	 */
+	public boolean visit(ExtraDimension node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 */
 	public boolean visit(FieldAccess node) {
 		return true;
@@ -1620,19 +1620,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.9
-	 */
-	public void endVisit(ExtraDimension node) {
-		// do nothing by default
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 * @since 3.1
 	 */
 	public void endVisit(AnnotationTypeMemberDeclaration node) {
@@ -1955,6 +1942,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.9
+	 */
+	public void endVisit(ExtraDimension node) {
+		// do nothing by default
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(FieldAccess node) {
 		// default implementation: do nothing
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotatableType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotatableType.java
index 3f3cb2d..1f74ac8 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotatableType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AnnotatableType.java
@@ -20,11 +20,46 @@ import java.util.List;
  * Type node for an annotatable type.
  * <p>
  * Introduced in JLS8, type references that can be annotated are represented by 
- * AnnotatableType. For the list of types extending AnnotatableType, see {@link Type}</p>
+ * AnnotatableType. For the list of types extending AnnotatableType, see {@link Type}.</p>
  *
  * @since 3.9
  */
 public abstract class AnnotatableType extends Type {
+	
+	/**
+	 * The annotations (element type: {@link Annotation}).
+	 * Null in JLS < 8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
+	 */
+	ASTNode.NodeList annotations = null;
+
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "annotations" property declared on the given concrete node type (element type: {@link Annotation}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildListPropertyDescriptor internalAnnotationsPropertyFactory(Class nodeClass) {
+		return 	new ChildListPropertyDescriptor(nodeClass, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
+	}
+
+	/**
+	 * Returns the structural property descriptor for the "annotations" property
+	 * of this node (element type: {@link Annotation}).
+	 *
+	 * @return the property descriptor
+	 */
+	abstract ChildListPropertyDescriptor internalAnnotationsProperty();
+
+	/**
+	 * Returns the structural property descriptor for the "annotations" property
+	 * of this node (element type: {@link Annotation}).
+	 *
+	 * @return the property descriptor
+	 */
+	public final ChildListPropertyDescriptor getAnnotationsProperty() {
+		return internalAnnotationsProperty();
+	}
 
 	/**
 	 * Creates a new unparented node for an annotatable type owned by the given AST.
@@ -36,19 +71,19 @@ public abstract class AnnotatableType extends Type {
 	 */
 	AnnotatableType(AST ast) {
 		super(ast);
+		if (ast.apiLevel >= AST.JLS8) {
+			this.annotations = new ASTNode.NodeList(getAnnotationsProperty());
+		}
 	}
-	
-	ASTNode.NodeList annotations = null;
-	
+
 	/**
-	 * Returns the live ordered list of annotations for this Type node.
+	 * Returns the live ordered list of annotations for this Type node (added in JLS8 API).
 	 *
 	 * @return the live list of annotations (element type: {@link Annotation})
-	 * @exception UnsupportedOperationException if this operation is used
-	 *            in a JLS2, JLS3 or JLS4 AST
-	 * @since 3.9
+	 * @exception UnsupportedOperationException if this operation is used below JLS8
 	 */
 	public List annotations() {
+		// more efficient than just calling unsupportedIn2_3_4() to check
 		if (this.annotations == null) {
 			unsupportedIn2_3_4();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ArrayType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ArrayType.java
index a01d952..ef52909 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ArrayType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ArrayType.java
@@ -28,10 +28,10 @@ import java.util.List;
  * ArrayType:
  *    Type <b>'['</b> <b>']'</b>
  * </pre>
- * For JLS8, optional annotations on dimensions were added:
+ * For JLS8, optional annotations on the dimension were added:
  * <pre>
  * ArrayType:
- *    Type {Annotation} <b>'['</b> <b>']'</b>
+ *    Type { Annotation } <b>'['</b> <b>']'</b>
  * </pre>
  *
  * @since 2.0
@@ -47,11 +47,11 @@ public class ArrayType extends AnnotatableType {
 		new ChildPropertyDescriptor(ArrayType.class, "componentType", Type.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(ArrayType.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
+			internalAnnotationsPropertyFactory(ArrayType.class);
 	
 	/**
 	 * A list of property descriptors (element type:
@@ -104,7 +104,7 @@ public class ArrayType extends AnnotatableType {
 
 	/**
 	 * The component type; lazily initialized; defaults to a simple type with
-	 * an unspecfied, but legal, name.
+	 * an unspecified, but legal, name.
 	 */
 	private Type componentType = null;
 
@@ -119,9 +119,14 @@ public class ArrayType extends AnnotatableType {
 	 */
 	ArrayType(AST ast) {
 		super(ast);
-		if (ast.apiLevel >= AST.JLS8) {
-			this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-		}
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -130,6 +135,7 @@ public class ArrayType extends AnnotatableType {
 	final List internalStructuralPropertiesForType(int apiLevel) {
 		return propertyDescriptors(apiLevel);
 	}
+
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
@@ -172,7 +178,7 @@ public class ArrayType extends AnnotatableType {
 		result.setSourceRange(getStartPosition(), getLength());
 		result.setComponentType((Type) getComponentType().clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
 		return result;
@@ -192,6 +198,7 @@ public class ArrayType extends AnnotatableType {
 	void accept0(ASTVisitor visitor) {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
+			// visit children in normal left to right reading order
 			acceptChild(visitor, getComponentType());
 			if (this.ast.apiLevel >= AST.JLS8) {
 				acceptChildren(visitor, this.annotations);
@@ -292,8 +299,8 @@ public class ArrayType extends AnnotatableType {
 	int treeSize() {
 		return
 			memSize()
-			+ (this.annotations == null ? 0 : this.annotations.listSize())
-			+ (this.componentType == null ? 0 : getComponentType().treeSize());
+			+ (this.componentType == null ? 0 : getComponentType().treeSize())
+			+ (this.annotations == null ? 0 : this.annotations.listSize());
 	}
 }
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BodyDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BodyDeclaration.java
index 9949f8b..c0394ef 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BodyDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BodyDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -198,10 +198,10 @@ public abstract class BodyDeclaration extends ASTNode {
 	 * Returns the modifiers explicitly specified on this declaration.
 	 * <p>
 	 * In the JLS3 API, this method is a convenience method that
-	 * computes these flags from <code>modifiers()</code>.
+	 * computes these flags from {@link #modifiers()}.
 	 * </p>
 	 *
-	 * @return the bit-wise or of <code>Modifier</code> constants
+	 * @return the bit-wise "or" of <code>Modifier</code> constants
 	 * @see Modifier
 	 */
 	public int getModifiers() {
@@ -227,12 +227,12 @@ public abstract class BodyDeclaration extends ASTNode {
 	/**
 	 * Sets the modifiers explicitly specified on this declaration (JLS2 API only).
 	 *
-	 * @param modifiers the given modifiers (bit-wise or of <code>Modifier</code> constants)
+	 * @param modifiers the given modifiers (bit-wise "or" of {@link Modifier} constants)
 	 * @exception UnsupportedOperationException if this operation is used in
 	 * an AST later than JLS2
 	 * @see Modifier
 	 * @deprecated In the JLS3 API, this method is replaced by
-	 * {@link #modifiers()} which contains a list of a <code>Modifier</code> nodes.
+	 * {@link #modifiers()}, which contains a list of {@link Modifier} nodes.
 	 */
 	public void setModifiers(int modifiers) {
 		internalSetModifiers(modifiers);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index ed883d9..8709b86 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -110,6 +110,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(ExpressionStatement node) {
 		endVisitNode(node);
 	}
+	public void endVisit(ExtraDimension node) {
+		endVisitNode(node);
+	}
 	public void endVisit(FieldAccess node) {
 		endVisitNode(node);
 	}
@@ -369,6 +372,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(ExpressionStatement node) {
 		return visitNode(node);
 	}
+	public boolean visit(ExtraDimension node) {
+		return visitNode(node);
+	}
 	public boolean visit(FieldAccess node) {
 		return visitNode(node);
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
index e67dcaf..32db075 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
@@ -18,30 +18,26 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * The extra dimension node. The extra dimensions, represented as <b>[]</b>, are allowed to have
+ * The extra dimension node. An extra dimension, represented as <b>[]</b>, can have
  * type annotations. This node type is supported only in JLS8 or later.
  * <p>
- * The extra dimension node is used to represent extra dimensions in the following nodes:
- * <pre>
- * 	SingleVariableDeclaration
- * 	VariableDeclarationFragment
- * 	MethodDeclaration
- * </pre>
- * For JLS8:
+ * The extra dimension node is used to represent an extra dimension in the following node types:
+ * {@link SingleVariableDeclaration}, {@link VariableDeclarationFragment}, {@link MethodDeclaration}.
+ * It is not used for annotations on an {@link ArrayType}, since that type extends {@link AnnotatableType} now.
+ * </p>
+ * 
  * <pre>
  * ExtraDimension:
- * 	{ Annotations } <b>[]</b>
+ * 	{ Annotation } <b>[]</b>
  * </pre>
- *</p>
- * @see AST#newExtraDimension()
+ *
  * @since 3.9
+ * @noinstantiate This class is not intended to be instantiated by clients.
  */
 public class ExtraDimension extends ASTNode {
 
-
 	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
 	 */
 	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
 		new ChildListPropertyDescriptor(ExtraDimension.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
@@ -50,12 +46,11 @@ public class ExtraDimension extends ASTNode {
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
-	 * @since 3.9
 	 */
 	private static final List PROPERTY_DESCRIPTORS_8_0;
 
 	static {
-		List propertyList = new ArrayList(3);
+		List propertyList = new ArrayList(2);
 		createPropertyList(ExtraDimension.class, propertyList);
 		addProperty(ANNOTATIONS_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
@@ -69,44 +64,37 @@ public class ExtraDimension extends ASTNode {
 	 * <code>AST.JLS*</code> constants
 	 * @return a list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor})
-	 * @since 3.9
 	 */
 	public static List propertyDescriptors(int apiLevel) {
 		return PROPERTY_DESCRIPTORS_8_0;
 	}
 
 	/**
-	 * Create a new instance of ExtraDimension node (Supported only in level
-	 * JLS8 or above).  
+	 * The list of annotations for this dimension (element type: {@link Annotation}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
+
+	/**
+	 * Creates a new extra dimension node (Supported only in level
+	 * JLS8 or above).
+	 * <p>
+	 * N.B. This constructor is package-private.
+	 * </p>
 	 *
-	 * @param ast
+	 * @param ast the AST that is to own this node
 	 * @exception UnsupportedOperationException if this operation is used
 	 *            in a JLS2, JLS3 or JLS4 AST
-	 * @since 3.9
 	 */
 	ExtraDimension(AST ast) {
 		super(ast);
 		unsupportedIn2_3_4();
-		this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
 	}
 
-	/**
-	 * The list of annotations for this dimension (element type:
-	 * {@link Annotation}).
-	 */
-	ASTNode.NodeList annotations = null;
-	
-	/**
-	 * Returns the live ordered list of annotations for this dimension.
-	 *
-	 * @return the live list of annotations (element type: {@link Annotation})
-	 * @since 3.9
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
 	 */
-	public List annotations() {
-		return this.annotations;
-	}
-
-	List internalStructuralPropertiesForType(int apiLevel) {
+	final List internalStructuralPropertiesForType(int apiLevel) {
 		return propertyDescriptors(apiLevel);
 	}
 
@@ -121,36 +109,59 @@ public class ExtraDimension extends ASTNode {
 		return super.internalGetChildListProperty(property);
 	}
 
-	int getNodeType0() {
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final int getNodeType0() {
 		return EXTRA_DIMENSION;
 	}
 
-	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		return matcher.match(this, other);
-	}
-
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
 	ASTNode clone0(AST target) {
 		ExtraDimension result = new ExtraDimension(target);
-		result.annotations.addAll(
+		result.annotations().addAll(
 				ASTNode.copySubtrees(target, annotations()));
 		return result;
 	}
 
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
 	void accept0(ASTVisitor visitor) {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
+			// visit children in normal left to right reading order
 			acceptChildren(visitor, this.annotations);
 		}
 		visitor.endVisit(this);
 	}
 
-	int treeSize() {
-		int size = memSize()
-				+ this.annotations.listSize();
-			return size;
+	/**
+	 * Returns the live ordered list of annotations for this dimension.
+	 *
+	 * @return the live list of annotations (element type: {@link Annotation})
+	 */
+	public List annotations() {
+		return this.annotations;
 	}
 
 	int memSize() {
-		return BASE_NODE_SIZE + 4;
+		return BASE_NODE_SIZE + 1 * 4;
+	}
+
+	int treeSize() {
+		return
+			memSize()
+			+ this.annotations.listSize();
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index cca8ae2..5e095ca 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -57,21 +57,25 @@ import java.util.List;
  * type annotations. The annotatable extra dimensions are represented by {@link ExtraDimension}.
  * <pre>
  * MethodDeclaration:
- *    [ Javadoc ] { ExtendedModifier }
- *		  [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ]
- *        ( Type | <b>void</b> ) Identifier <b>(</b>
- *        	[ ReceiverParameter ]
- *         	[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> { ExtraDimension }
- *        [ <b>throws</b> TypeName { <b>,</b> TypeName } ] ( Block | <b>;</b> )
+ *    [ Javadoc ] { ExtendedModifier } [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ] ( Type | <b>void</b> )
+ *        Identifier <b>(</b>
+ *            [ ReceiverParameter <b>,</b> ] [ FormalParameter { <b>,</b> FormalParameter } ]
+ *        <b>)</b> { ExtraDimension }
+ *        [ <b>throws</b> Type { <b>,</b> Type } ]
+ *        ( Block | <b>;</b> )
  * ConstructorDeclaration:
- *    [ Javadoc ] { ExtendedModifier }
- *		  [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ]
+ *    [ Javadoc ] { ExtendedModifier } [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ]
  *        Identifier <b>(</b>
- * 		  	[ ReceiverParameter ]
- * 			[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b>
- *        [<b>throws</b> TypeName { <b>,</b> TypeName } ] Block
+ *            [ ReceiverParameter <b>,</b> ] [ FormalParameter { <b>,</b> FormalParameter } ]
+ *        <b>)</b> { ExtraDimension }
+ *        [ <b>throws</b> Type { <b>,</b> Type } ]
+ *        ( Block | <b>;</b> )
  * </pre>
  * <p>
+ * The ReceiverParameter is represented as: <code>AnnotatableType [ SimpleName <b>.</b> ] <b>this</b></code><br>
+ * The FormalParameter is represented by a {@link SingleVariableDeclaration}.
+ * </p>
+ * <p>
  * When a Javadoc comment is present, the source
  * range begins with the first character of the "/**" comment delimiter.
  * When there is no Javadoc comment, the source range begins with the first
@@ -82,7 +86,6 @@ import java.util.List;
  * no modifiers). The source range extends through the last character of the
  * ";" token (if no body), or the last character of the block (if body).
  * </p>
- * <p>The FormalParameter is represented by a {@link SingleVariableDeclaration}.</p>
  *
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
@@ -139,16 +142,16 @@ public class MethodDeclaration extends BodyDeclaration {
 		new ChildPropertyDescriptor(MethodDeclaration.class, "returnType2", Type.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 * The "extraDimensions" structural property of this node type (type: {@link Integer}) (below JLS8 only).
 	 *
 	 * @since 3.0
-	 * @deprecated in JLS8, use {@link MethodDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
+	 * @deprecated In JLS8 and later, use {@link MethodDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(MethodDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 	
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (added in JLS8 API).
+	 * The "extraDimensionInfos" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
@@ -169,23 +172,22 @@ public class MethodDeclaration extends BodyDeclaration {
 		new ChildListPropertyDescriptor(MethodDeclaration.class, "parameters", SingleVariableDeclaration.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "receiverType" structural property of this node type (element type:
-	 * {@link AnnotatableType}) (added in JLS8 API).
+	 * The "receiverType" structural property of this node type (child type: {@link AnnotatableType}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildPropertyDescriptor RECEIVER_TYPE_PROPERTY =
 			new ChildPropertyDescriptor(MethodDeclaration.class, "receiverType", AnnotatableType.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 	
 	/**
-	 * The "receiverQualifier" structural property of this node type (element type:
-	 * {@link SimpleName}) (added in JLS8 API).
+	 * The "receiverQualifier" structural property of this node type (child type: {@link SimpleName}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildPropertyDescriptor RECEIVER_QUALIFIER_PROPERTY =
 			new ChildPropertyDescriptor(MethodDeclaration.class, "receiverQualifier", SimpleName.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "thrownExceptions" structural property of this node type (element type: {@link Name}) (Available in JLS2, JLS3, and JLS4 Only).
+	 * The "thrownExceptions" structural property of this node type (element type: {@link Name}) (before JLS8 only).
+	 * @deprecated In JLS8 and later, use {@link MethodDeclaration#THROWN_EXCEPTION_TYPES_PROPERTY} instead.
 	 * @since 3.0
 	 */
 	public static final ChildListPropertyDescriptor THROWN_EXCEPTIONS_PROPERTY =
@@ -306,14 +308,18 @@ public class MethodDeclaration extends BodyDeclaration {
 	private SimpleName methodName = null;
 
 	/**
-	 * The explicit receiver type.
+	 * The explicit receiver type, or <code>null</code> if none.
+	 * Defaults to none.
+	 * @since 3.9
 	 */
-	private AnnotatableType receiverType = null;
+	private AnnotatableType optionalReceiverType = null;
 	
 	/**
-	 * Qualifying name if any of the explicit </code>this</code> parameter.
+	 * Qualifying name of the explicit </code>this</code> parameter, or <code>null</code> if none.
+	 * Defaults to none.
+	 * @since 3.9
 	 */
-	private SimpleName receiverQualifier = null;
+	private SimpleName optionalReceiverQualifier = null;
 
 	/**
 	 * The parameter declarations
@@ -325,8 +331,8 @@ public class MethodDeclaration extends BodyDeclaration {
 
 	/**
 	 * The return type.
-	 * JLS2 behevior: lazily initialized; defaults to void.
-	 * JLS3 behavior; lazily initialized; defaults to void; null allowed.
+	 * JLS2 behavior: lazily initialized; defaults to void.
+	 * JLS3 and later: lazily initialized; defaults to void; null allowed.
 	 * Note that this field is ignored for constructor declarations.
 	 */
 	private Type returnType = null;
@@ -347,28 +353,37 @@ public class MethodDeclaration extends BodyDeclaration {
 
 	/**
 	 * The number of array dimensions that appear after the parameters, rather
-	 * than after the return type itself; defaults to 0.
+	 * than after the return type itself; defaults to 0. Not used in JLS8 and later.
 	 *
 	 * @since 2.1
+	 * @deprecated In JLS8 and later, use {@link #extraDimensions} instead.
 	 */
 	private int extraArrayDimensions = 0;
 
 	/**
-	 * The extra dimensions this node has with optional annotations.
+	 * List of extra dimensions this node has with optional annotations
+	 * (element type: {@link ExtraDimension}).
+	 * Null before JLS8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
 	 * 
 	 * @since 3.9
 	 */
-	protected ASTNode.NodeList extraDimensionInfos = null;
+	private ASTNode.NodeList extraDimensions = null;
 
 	/**
 	 * The list of thrown exception names (element type: {@link Name}).
-	 * Defaults to an empty list for api levels below JLS8.
+	 * Before JLS8: defaults to an empty list (see constructor).
+	 * JLS8 and later: null.
+	 * @deprecated In JLS8 and later, use {@link #thrownExceptionTypes} instead.
 	 */
 	private ASTNode.NodeList thrownExceptions = null;
 
 	/**
 	 * The list of thrown exception Types (element type: {@link Type}).
-	 * Defaults to an empty list at JLS8 and above.
+	 * Null before JLS8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
+	 * 
+	 * @since 3.9
 	 */
 	private ASTNode.NodeList thrownExceptionTypes = null;
 
@@ -401,7 +416,7 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (ast.apiLevel < AST.JLS8) {
 			this.thrownExceptions = new ASTNode.NodeList(THROWN_EXCEPTIONS_PROPERTY);
 		} else {
-			this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
+			this.extraDimensions = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
 			this.thrownExceptionTypes = new ASTNode.NodeList(THROWN_EXCEPTION_TYPES_PROPERTY);
 		}
 	}
@@ -492,16 +507,18 @@ public class MethodDeclaration extends BodyDeclaration {
 		}
 		if (property == RECEIVER_TYPE_PROPERTY) {
 			if (get) {
-				return this.receiverType;
+				return getReceiverType();
 			} else {
 				setReceiverType((AnnotatableType) child);
+				return null;
 			}
 		}
 		if (property == RECEIVER_QUALIFIER_PROPERTY) {
 			if (get) {
-				return this.receiverQualifier;
+				return getReceiverQualifier();
 			} else {
 				setReceiverQualifier((SimpleName) child);
+				return null;
 			}
 		}
 		if (property == BODY_PROPERTY) {
@@ -536,7 +553,7 @@ public class MethodDeclaration extends BodyDeclaration {
 			return thrownExceptionTypes();
 		}		
 		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return extraDimensionInfos();
+			return extraDimensions();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -591,24 +608,22 @@ public class MethodDeclaration extends BodyDeclaration {
 					(Type) ASTNode.copySubtree(target, getReturnType2()));
 		}
 		result.setConstructor(isConstructor());
+		result.setName((SimpleName) getName().clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.setReceiverType((AnnotatableType) ASTNode.copySubtree(target, this.receiverType));
-			result.setReceiverQualifier((SimpleName) ASTNode.copySubtree(target, this.receiverQualifier));
-			result.extraDimensionInfos.addAll(
-					ASTNode.copySubtrees(target, this.extraDimensionInfos));
-		} else {
-			result.setExtraDimensions(getExtraDimensions());
+			result.setReceiverType((AnnotatableType) ASTNode.copySubtree(target, getReceiverType()));
+			result.setReceiverQualifier((SimpleName) ASTNode.copySubtree(target, getReceiverQualifier()));
 		}
-		result.setName((SimpleName) getName().clone(target));
 		result.parameters().addAll(
 			ASTNode.copySubtrees(target, parameters()));
-		if  (this.ast.apiLevel() < AST.JLS8) {
-			result.thrownExceptions().addAll(
-			ASTNode.copySubtrees(target, thrownExceptions()));			
+		if (this.ast.apiLevel >= AST.JLS8) {
+			result.extraDimensions().addAll(ASTNode.copySubtrees(target, extraDimensions()));
+		} else {
+			result.setExtraDimensions(getExtraDimensions());
+		}
+		if (this.ast.apiLevel() >= AST.JLS8) {
+			result.thrownExceptionTypes().addAll(ASTNode.copySubtrees(target, thrownExceptionTypes()));
 		} else {
-			result.thrownExceptionTypes().addAll(
-			ASTNode.copySubtrees(target, thrownExceptionTypes()));
-			
+			result.thrownExceptions().addAll(ASTNode.copySubtrees(target, thrownExceptions()));			
 		}
 		result.setBody(
 			(Block) ASTNode.copySubtree(target, getBody()));
@@ -641,15 +656,15 @@ public class MethodDeclaration extends BodyDeclaration {
 			// n.b. visit return type even for constructors
 			acceptChild(visitor, getName());
 			if (this.ast.apiLevel >= AST.JLS8) {
-				acceptChild(visitor, this.receiverType);
-				acceptChild(visitor, this.receiverQualifier);
+				acceptChild(visitor, this.optionalReceiverType);
+				acceptChild(visitor, this.optionalReceiverQualifier);
 			}
 			acceptChildren(visitor, this.parameters);
-			if (this.ast.apiLevel() < AST.JLS8) {
-				acceptChildren(visitor, this.thrownExceptions);				
-			} else {
-				acceptChildren(visitor, this.extraDimensionInfos);
+			if (this.ast.apiLevel() >= AST.JLS8) {
+				acceptChildren(visitor, this.extraDimensions);
 				acceptChildren(visitor, this.thrownExceptionTypes);				
+			} else {
+				acceptChildren(visitor, this.thrownExceptions);				
 			}
 			acceptChild(visitor, getBody());
 		}
@@ -741,7 +756,7 @@ public class MethodDeclaration extends BodyDeclaration {
 
 	/**
 	 * Returns the receiver type explicitly declared in the method or constructor 
-	 * declaration (JLS8 API only).
+	 * declaration (added in JLS8 API).
 	 *
 	 * If the receiver is not explicitly declared in the method or constructor 
 	 * declaration, <code>null</code> is returned.
@@ -752,29 +767,32 @@ public class MethodDeclaration extends BodyDeclaration {
 	 */
 	public AnnotatableType getReceiverType() {
 		unsupportedIn2_3_4();
-		return this.receiverType;
+		return this.optionalReceiverType;
 	}
 
 	/**
-	 * Sets the given type as the type of explicit receiver parameter. (JLS8 API only).
-	 *
-	 * @param receiverType type of explicit receiver parameter to be added to the method declaration
+	 * Sets or clears the given type as the type of explicit receiver parameter (added in JLS8 API).
+	 * <p>
+	 * A receiver type is only legal in Java code if it appears on an instance method or on a constructor of an inner class.
+	 * </p>
+	 * 
+	 * @param receiverType type of the explicit receiver parameter, or <code>null</code> if there is none
 	 * @exception UnsupportedOperationException if this operation is used below JLS8
 	 * @since 3.9
-
 	 */
 	public void setReceiverType(AnnotatableType receiverType) {
 		unsupportedIn2_3_4();
-		ASTNode oldChild = this.receiverType;
+		ASTNode oldChild = this.optionalReceiverType;
 		preReplaceChild(oldChild, receiverType, RECEIVER_TYPE_PROPERTY);
-		this.receiverType = receiverType;
+		this.optionalReceiverType = receiverType;
 		postReplaceChild(oldChild, receiverType, RECEIVER_TYPE_PROPERTY);
 	}
 
 	/**
-	 * Returns the qualifying name, if any, for the explicit receiver or null if not used. This method
-	 * always returns <code>null</code> for a non-constructor.
-	 * This API is supported in JLS8 only.
+	 * Returns the qualifying name, if any, for the explicit receiver or <code>null</code> if not used (added in JLS8 API).
+	 * <p>
+	 * A receiver qualifier is only legal in Java code if it appears on a constructor of an inner class.
+	 * </p>
 	 * 
 	 * @returns the qualifying name or <code>null</code> if a qualifier was not specified
 	 * @exception UnsupportedOperationException if this operation is used below JLS8
@@ -782,12 +800,11 @@ public class MethodDeclaration extends BodyDeclaration {
 	 */
 	public SimpleName getReceiverQualifier() {
 		unsupportedIn2_3_4();
-		return this.receiverQualifier;
+		return this.optionalReceiverQualifier;
 	}
 	
 	/**
-	 * Sets the given simple name as the qualifier for the receiver.
-	 * This API is supported in JLS8 only.
+	 * Sets the given simple name as the qualifier for the receiver (added in JLS8 API).
 	 * 
 	 * @param receiverQualifier explicit receiver parameter to be added to the method declaration
 	 * @exception UnsupportedOperationException if this operation is used below JLS8
@@ -795,9 +812,9 @@ public class MethodDeclaration extends BodyDeclaration {
 	 */
 	public void setReceiverQualifier(SimpleName receiverQualifier) {
 		unsupportedIn2_3_4();
-		ASTNode oldChild = this.receiverQualifier;
+		ASTNode oldChild = this.optionalReceiverQualifier;
 		preReplaceChild(oldChild, receiverQualifier, RECEIVER_QUALIFIER_PROPERTY);
-		this.receiverQualifier = receiverQualifier;
+		this.optionalReceiverQualifier = receiverQualifier;
 		postReplaceChild(oldChild, receiverQualifier, RECEIVER_QUALIFIER_PROPERTY);
 	}
 	
@@ -839,12 +856,27 @@ public class MethodDeclaration extends BodyDeclaration {
 
 	/**
 	 * Returns the live ordered list of thrown exception names in this method
-	 * declaration.
+	 * declaration (below JLS8 API only).
 	 *
 	 * @return the live list of exception names
 	 *    (element type: {@link Name})
+	 * @exception UnsupportedOperationException if this operation is used in
+	 *    a JLS8 or later AST
 	 */
+//TODO:	* @deprecated In the JLS8 API, this method is replaced by {@link #thrownExceptionTypes()}.
 	public List thrownExceptions() {
+		return internalThrownExceptions();
+	}
+
+	/**
+	 * Internal synonym for deprecated method. Used to avoid
+	 * deprecation warnings.
+	 * @exception UnsupportedOperationException if this operation is used in
+	 *    a JLS8 or later AST
+	 * @since 3.9
+	 */
+	/*package*/	List internalThrownExceptions() {
+		// more efficient than just calling supportedOnlyIn2_3_4() to check
 		if (this.thrownExceptions == null) {
 			supportedOnlyIn2_3_4();
 		}
@@ -892,6 +924,8 @@ public class MethodDeclaration extends BodyDeclaration {
 	/**
 	 * Internal synonym for deprecated method. Used to avoid
 	 * deprecation warnings.
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * an AST later than JLS2
 	 * @since 3.1
 	 */
 	/*package*/ final Type internalGetReturnType() {
@@ -1025,15 +1059,22 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * ASTs, even though there are really syntactic variants of the same
 	 * method declaration.
 	 * </p>
+	 * <p>
+	 * In the JLS8 API, this method is a convenience method that
+	 * counts {@link #extraDimensions()}.
+	 * </p>
 	 *
 	 * @return the number of extra array dimensions
 	 * @since 2.1
 	 */
 	public int getExtraDimensions() {
-		if (this.ast.apiLevel >= AST.JLS8) {
-			return this.extraDimensionInfos.size();
+		// more efficient than checking getAST().API_LEVEL
+		if (this.extraDimensions == null) {
+			// JLS2,3,4 behavior - bona fide property
+			return this.extraArrayDimensions;
+		} else {
+			return this.extraDimensions.size();
 		}
-		return this.extraArrayDimensions;
 	}
 
 	/**
@@ -1051,11 +1092,17 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * @param dimensions the number of array dimensions
 	 * @exception IllegalArgumentException if the number of dimensions is
 	 *    negative
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS8 or later AST 
 	 * @since 2.1
-	 * @deprecated In the JLS8 API, use: {@link #extraDimensionInfos()}.
+	 * @deprecated In the JLS8 API, this method is replaced by
+	 * {@link #extraDimensions()} which contains a list of {@link ExtraDimension} nodes.
 	 */
 	public void setExtraDimensions(int dimensions) {
-		supportedOnlyIn2_3_4();
+		// more efficient than just calling supportedOnlyIn2_3_4() to check
+		if (this.extraDimensions != null) {
+			supportedOnlyIn2_3_4();
+		}
 		if (dimensions < 0) {
 			throw new IllegalArgumentException();
 		}
@@ -1065,14 +1112,18 @@ public class MethodDeclaration extends BodyDeclaration {
 	}
 
 	/**
-	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
+	 * Returns the live ordered list of extra dimensions with optional annotations (added in JLS8 API).
 	 * 
 	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
+	 * @exception UnsupportedOperationException if this operation is used below JLS8
 	 * @since 3.9
 	 */
-	public List extraDimensionInfos() {
-		unsupportedIn2_3_4();
-		return this.extraDimensionInfos;
+	public List extraDimensions() {
+		// more efficient than just calling unsupportedIn2_3_4() to check
+		if (this.extraDimensions == null) {
+			unsupportedIn2_3_4();
+		}
+		return this.extraDimensions;
 	}
 
 	/**
@@ -1148,13 +1199,13 @@ public class MethodDeclaration extends BodyDeclaration {
 			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
 			+ (this.typeParameters == null ? 0 : this.typeParameters.listSize())
 			+ (this.methodName == null ? 0 : getName().treeSize())
-			+ (this.receiverType == null ? 0 : this.receiverType.treeSize())
-			+ (this.receiverQualifier == null ? 0 : this.receiverQualifier.treeSize())
+			+ (this.optionalReceiverType == null ? 0 : this.optionalReceiverType.treeSize())
+			+ (this.optionalReceiverQualifier == null ? 0 : this.optionalReceiverQualifier.treeSize())
 			+ (this.returnType == null ? 0 : this.returnType.treeSize())
 			+ this.parameters.listSize()
-			+ (this.ast.apiLevel < AST.JLS8 ? 
-					this.thrownExceptions.listSize() 
-					: this.extraDimensionInfos.listSize() + this.thrownExceptionTypes.listSize())
+			+ (this.ast.apiLevel < AST.JLS8
+					? this.thrownExceptions.listSize()
+					: this.extraDimensions.listSize() + this.thrownExceptionTypes.listSize())
 			+ (this.optionalBody == null ? 0 : getBody().treeSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ParameterizedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ParameterizedType.java
index 4c6fc9b..d17f269 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ParameterizedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ParameterizedType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2003, 2011 IBM Corporation and others.
+ * Copyright (c) 2003, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -76,7 +76,7 @@ public class ParameterizedType extends Type {
 	}
 
 	/**
-	 * The type node; lazily initialized; defaults to an unspecfied, but legal,
+	 * The type node; lazily initialized; defaults to an unspecified, but legal,
 	 * type.
 	 */
 	private Type type = null;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PrimitiveType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PrimitiveType.java
index 3320e9e..76ab230 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PrimitiveType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/PrimitiveType.java
@@ -22,18 +22,18 @@ import java.util.Map;
 
 /**
  * Primitive type nodes. For JLS8 optional annotations indicated by {Annotation}
- * were added and are not present in ASTs of JLS2, JLS3 and JLS4 vintages.
+ * were added.
  * <pre>
  * PrimitiveType:
- *    <b>{Annotation} byte</b>
- *    <b>{Annotation} short</b>
- *    <b>{Annotation} char</b>
- *    <b>{Annotation} int</b>
- *    <b>{Annotation} long</b>
- *    <b>{Annotation} float</b>
- *    <b>{Annotation} double</b>
- *    <b>{Annotation} boolean</b>
- *    <b>{Annotation} void</b>
+ *    { Annotation } <b>byte</b>
+ *    { Annotation } <b>short</b>
+ *    { Annotation } <b>char</b>
+ *    { Annotation } <b>int</b>
+ *    { Annotation } <b>long</b>
+ *    { Annotation } <b>float</b>
+ *    { Annotation } <b>double</b>
+ *    { Annotation } <b>boolean</b>
+ *    { Annotation } <b>void</b>
  * </pre>
  * <p>
  * Note that due to the fact that AST nodes belong to a specific AST and
@@ -160,18 +160,18 @@ public class PrimitiveType extends AnnotatableType {
 	}
 
 	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			internalAnnotationsPropertyFactory(PrimitiveType.class);
+	
+	/**
 	 * The "primitiveTypeCode" structural property of this node type (type: {@link PrimitiveType.Code}).
 	 * @since 3.0
 	 */
 	public static final SimplePropertyDescriptor PRIMITIVE_TYPE_CODE_PROPERTY =
 		new SimplePropertyDescriptor(PrimitiveType.class, "primitiveTypeCode", PrimitiveType.Code.class, MANDATORY); //$NON-NLS-1$
-	
-	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(PrimitiveType.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -194,8 +194,8 @@ public class PrimitiveType extends AnnotatableType {
 		
 		propertyList = new ArrayList(3);
 		createPropertyList(PrimitiveType.class, propertyList);
-		addProperty(PRIMITIVE_TYPE_CODE_PROPERTY, propertyList);
 		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		addProperty(PRIMITIVE_TYPE_CODE_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
@@ -232,9 +232,14 @@ public class PrimitiveType extends AnnotatableType {
 	 */
 	PrimitiveType(AST ast) {
 		super(ast);
-		if (ast.apiLevel >= AST.JLS8) {
-			this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-		}
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -254,6 +259,7 @@ public class PrimitiveType extends AnnotatableType {
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
 	}
+
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
@@ -283,11 +289,11 @@ public class PrimitiveType extends AnnotatableType {
 	ASTNode clone0(AST target) {
 		PrimitiveType result = new PrimitiveType(target);
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setPrimitiveTypeCode(getPrimitiveTypeCode());
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
+		result.setPrimitiveTypeCode(getPrimitiveTypeCode());
 		return result;
 	}
 
@@ -305,6 +311,7 @@ public class PrimitiveType extends AnnotatableType {
 	void accept0(ASTVisitor visitor) {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
+			// visit children in normal left to right reading order
 			if (this.ast.apiLevel >= AST.JLS8) {
 				acceptChildren(visitor, this.annotations);
 			}
@@ -350,6 +357,7 @@ public class PrimitiveType extends AnnotatableType {
 	 * Method declared on ASTNode.
 	 */
 	int treeSize() {
-		return memSize() + (this.annotations == null ? 0 : this.annotations.listSize());
+		return memSize()
+				+ (this.annotations == null ? 0 : this.annotations.listSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
index 2eed89e..e45a6ab 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/QualifiedType.java
@@ -29,7 +29,7 @@ import java.util.List;
  * For JLS8, optional annotations were added:
  * <pre>
  * QualifiedType:
- *    Type <b>.</b> {Annotation} SimpleName
+ *    Type <b>.</b> { Annotation } SimpleName
  * </pre>
  * <p>
  * Not all node arrangements will represent legal Java constructs. In particular,
@@ -68,19 +68,19 @@ public class QualifiedType extends AnnotatableType {
 		new ChildPropertyDescriptor(QualifiedType.class, "qualifier", Type.class, MANDATORY, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			internalAnnotationsPropertyFactory(QualifiedType.class);
+	
+	/**
 	 * The "name" structural property of this node type (child type: {@link SimpleName}).
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
 		new ChildPropertyDescriptor(QualifiedType.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 	
 	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(QualifiedType.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
-
-	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -104,8 +104,8 @@ public class QualifiedType extends AnnotatableType {
 		propertyList = new ArrayList(4);
 		createPropertyList(QualifiedType.class, propertyList);
 		addProperty(QUALIFIER_PROPERTY, propertyList);
-		addProperty(NAME_PROPERTY, propertyList);
 		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
@@ -131,7 +131,7 @@ public class QualifiedType extends AnnotatableType {
 
 	/**
 	 * The type node; lazily initialized; defaults to a type with
-	 * an unspecfied, but legal, simple name.
+	 * an unspecified, but legal, simple name.
 	 */
 	private Type qualifier = null;
 
@@ -153,9 +153,14 @@ public class QualifiedType extends AnnotatableType {
 	QualifiedType(AST ast) {
 		super(ast);
 	    unsupportedIn2();
-	    if (ast.apiLevel >= AST.JLS8) {
-			this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-		}
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -214,11 +219,11 @@ public class QualifiedType extends AnnotatableType {
 		QualifiedType result = new QualifiedType(target);
 		result.setSourceRange(getStartPosition(), getLength());
 		result.setQualifier((Type) ((ASTNode) getQualifier()).clone(target));
-		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
+		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
 		return result;
 	}
 
@@ -338,8 +343,8 @@ public class QualifiedType extends AnnotatableType {
 	int treeSize() {
 		return
 			memSize()
-			+ (this.annotations == null ? 0 : this.annotations.listSize())
 			+ (this.qualifier == null ? 0 : getQualifier().treeSize())
+			+ (this.annotations == null ? 0 : this.annotations.listSize())
 			+ (this.name == null ? 0 : getName().treeSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
index aff2b9a..779249c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SimpleType.java
@@ -20,31 +20,37 @@ import java.util.List;
 
 /**
  * Type node for a named class type, a named interface type, or a type variable.
+ * <pre>
+ * SimpleType:
+ *    { Annotation } TypeName
+ * </pre>
  * <p>
- * This kind of node is used to convert a name (<code>Name</code>) into a type
- * (<code>Type</code>) by wrapping it.
+ * This kind of node is used to convert a name ({@link Name}) into a type
+ * ({@link Type}) by wrapping it.
  * </p>
  *
- * In JLS8, the SimpleType may have optional annotations.
+ * In JLS8 and later, the SimpleType may have optional annotations.
+ * If annotations are present, then the name must be a {@link SimpleName}. 
  * 
  * @since 2.0
+ * @see QualifiedType
  * @noinstantiate This class is not intended to be instantiated by clients.
  */
 public class SimpleType extends AnnotatableType {
 
 	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			internalAnnotationsPropertyFactory(SimpleType.class);
+	
+	/**
 	 * The "name" structural property of this node type (child type: {@link Name}).
 	 * @since 3.0
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
 		new ChildPropertyDescriptor(SimpleType.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-	
-	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(SimpleType.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -68,8 +74,8 @@ public class SimpleType extends AnnotatableType {
 		
 		propertyList = new ArrayList(3);
 		createPropertyList(SimpleType.class, propertyList);
-		addProperty(NAME_PROPERTY, propertyList);
 		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
@@ -96,7 +102,7 @@ public class SimpleType extends AnnotatableType {
 
 	/**
 	 * The type name node; lazily initialized; defaults to a type with
-	 * an unspecfied, but legal, name.
+	 * an unspecified, but legal, name.
 	 */
 	private Name typeName = null;
 
@@ -111,9 +117,14 @@ public class SimpleType extends AnnotatableType {
 	 */
 	SimpleType(AST ast) {
 		super(ast);
-		if (ast.apiLevel >= AST.JLS8) {
-			this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-		}
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -163,11 +174,11 @@ public class SimpleType extends AnnotatableType {
 	ASTNode clone0(AST target) {
 		SimpleType result = new SimpleType(target);
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setName((Name) (getName()).clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
+		result.setName((Name) (getName()).clone(target));
 		return result;
 	}
 
@@ -185,6 +196,7 @@ public class SimpleType extends AnnotatableType {
 	void accept0(ASTVisitor visitor) {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
+			// visit children in normal left to right reading order
 			if (this.ast.apiLevel >= AST.JLS8) {
 				acceptChildren(visitor, this.annotations);
 			}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
index f585f4b..722b66c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
@@ -63,18 +63,19 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "modifiers", IExtendedModifier.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "name" structural property of this node type (child type: {@link SimpleName}).
+	 * The "type" structural property of this node type (child type: {@link Type}).
 	 * @since 3.0
 	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(SingleVariableDeclaration.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+			new ChildPropertyDescriptor(SingleVariableDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "type" structural property of this node type (child type: {@link Type}).
-	 * @since 3.0
+	 * The "varargsAnnotations" structural property of variable arguments of this node type (child type: {@link Annotation})
+	 * (added in JLS8 API).
+	 * @since 3.9
 	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(SingleVariableDeclaration.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildListPropertyDescriptor VARARGS_ANNOTATIONS_PROPERTY =
+			new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "varargsAnnotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "varargs" structural property of this node type (type: {@link Boolean}) (added in JLS3 API).
@@ -82,36 +83,37 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 */
 	public static final SimplePropertyDescriptor VARARGS_PROPERTY =
 		new SimplePropertyDescriptor(SingleVariableDeclaration.class, "varargs", boolean.class, MANDATORY); //$NON-NLS-1$
-	
+
 	/**
-	 * The "varargsAnnotations" structural property of variable arguments of this node type (child type: {@link Annotation}).
-	 * @since 3.9
+	 * The "name" structural property of this node type (child type: {@link SimpleName}).
+	 * @since 3.0
 	 */
-	public static final ChildListPropertyDescriptor VARARGS_ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "varargsAnnotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+			internalNamePropertyFactory(SingleVariableDeclaration.class);
 
 	/**
-	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 * The "extraDimensions" structural property of this node type (type: {@link Integer})
+	 * (before JLS8 only).
 	 *
 	 * @since 3.0
-	 * @deprecated in JLS8, use {@link SingleVariableDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
+	 * @deprecated In JLS8 and later, use {@link SingleVariableDeclaration#EXTRA_DIMENSIONS2_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
-		new SimplePropertyDescriptor(SingleVariableDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
+			internalExtraDimensionsPropertyFactory(SingleVariableDeclaration.class);
 
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (added in JLS8 API).
+	 * The "extraDimensions" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
-	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSIONS2_PROPERTY =
+			internalExtraDimensions2PropertyFactory(SingleVariableDeclaration.class);
 
 	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
 	 * @since 3.0
 	 */
 	public static final ChildPropertyDescriptor INITIALIZER_PROPERTY =
-		new ChildPropertyDescriptor(SingleVariableDeclaration.class, "initializer", Expression.class, OPTIONAL, CYCLE_RISK); //$NON-NLS-1$
+			internalInitializerPropertyFactory(SingleVariableDeclaration.class);
 
 	/**
 	 * A list of property descriptors (element type:
@@ -128,7 +130,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 * @since 3.1
 	 */
 	private static final List PROPERTY_DESCRIPTORS_3_0;
-	
+
 	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
@@ -136,7 +138,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 * @since 3.9
 	 */
 	private static final List PROPERTY_DESCRIPTORS_8_0;
-	
+
 	static {
 		List propertyList = new ArrayList(6);
 		createPropertyList(SingleVariableDeclaration.class, propertyList);
@@ -156,8 +158,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		addProperty(EXTRA_DIMENSIONS_PROPERTY, propertyList);
 		addProperty(INITIALIZER_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_3_0 = reapPropertyList(propertyList);
-		
-		
+
 		propertyList = new ArrayList(8);
 		createPropertyList(SingleVariableDeclaration.class, propertyList);
 		addProperty(MODIFIERS2_PROPERTY, propertyList);
@@ -165,11 +166,10 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		addProperty(VARARGS_ANNOTATIONS_PROPERTY, propertyList);
 		addProperty(VARARGS_PROPERTY, propertyList);
 		addProperty(NAME_PROPERTY, propertyList);
-		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSIONS2_PROPERTY, propertyList);
 		addProperty(INITIALIZER_PROPERTY, propertyList);
-		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);		
-	
-		}
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
+	}
 
 	/**
 	 * Returns a list of structural property descriptors for this node type.
@@ -207,16 +207,19 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	private int modifierFlags = Modifier.NONE;
 
 	/**
-	 * The variable name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
+	 * The type; lazily initialized; defaults to an unspecified,
+	 * legal type.
 	 */
-	private SimpleName variableName = null;
+	private Type type = null;
 
 	/**
-	 * The type; lazily initialized; defaults to a unspecified,
-	 * legal type.
+	 * The type annotations on the varargs token (element type: {@link Annotation}).
+	 * Null before JLS8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
+	 * 
+	 * @since 3.9
 	 */
-	private Type type = null;
+	private ASTNode.NodeList varargsAnnotations = null;
 
 	/**
 	 * Indicates the last parameter of a variable arity method;
@@ -227,33 +230,6 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	private boolean variableArity = false;
 
 	/**
-	 * The number of extra array dimensions that appear after the variable;
-	 * defaults to 0.
-	 *
-	 * @since 2.1
-	 */
-	private int extraArrayDimensions = 0;
-
-	/**
-	 * List of extra dimensions this node has with optional annotations.
-	 * 
-	 * @since 3.9
-	 */
-	protected ASTNode.NodeList extraDimensionInfos = null;
-
-	/**
-	 * The initializer expression, or <code>null</code> if none;
-	 * defaults to none.
-	 */
-	private Expression optionalInitializer = null;
-
-	/**
-	 * The type annotations (element type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	private ASTNode.NodeList varargsAnnotations = null;
-
-	/**
 	 * Creates a new AST node for a variable declaration owned by the given
 	 * AST. By default, the variable declaration has: no modifiers, an
 	 * unspecified (but legal) type, an unspecified (but legal) variable name,
@@ -270,7 +246,6 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			this.modifiers = new ASTNode.NodeList(MODIFIERS2_PROPERTY);
 			if (ast.apiLevel >= AST.JLS8) {
 				this.varargsAnnotations = new ASTNode.NodeList(VARARGS_ANNOTATIONS_PROPERTY);
-				this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
 			}
 		}
 	}
@@ -279,24 +254,32 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final SimplePropertyDescriptor internalExtraDimensionsProperty() {
-		return EXTRA_DIMENSIONS_PROPERTY;
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final ChildPropertyDescriptor internalInitializerProperty() {
-		return INITIALIZER_PROPERTY;
+	final SimplePropertyDescriptor internalExtraDimensionsProperty() {
+		return EXTRA_DIMENSIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalExtraDimensions2Property() {
+		return EXTRA_DIMENSIONS2_PROPERTY;
+	}
+	
+	/* (omit javadoc for this method)
+	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
+	final ChildPropertyDescriptor internalInitializerProperty() {
+		return INITIALIZER_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -322,7 +305,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			if (get) {
 				return getExtraDimensions();
 			} else {
-				setExtraDimensions(value);
+				internalSetExtraDimensions(value);
 				return 0;
 			}
 		}
@@ -350,19 +333,19 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == NAME_PROPERTY) {
+		if (property == TYPE_PROPERTY) {
 			if (get) {
-				return getName();
+				return getType();
 			} else {
-				setName((SimpleName) child);
+				setType((Type) child);
 				return null;
 			}
 		}
-		if (property == TYPE_PROPERTY) {
+		if (property == NAME_PROPERTY) {
 			if (get) {
-				return getType();
+				return getName();
 			} else {
-				setType((Type) child);
+				setName((SimpleName) child);
 				return null;
 			}
 		}
@@ -388,8 +371,8 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		if (property == VARARGS_ANNOTATIONS_PROPERTY) {
 			return varargsAnnotations();
 		}
-		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return extraDimensionInfos();
+		if (property == EXTRA_DIMENSIONS2_PROPERTY) {
+			return extraDimensions();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -416,19 +399,18 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		}
 		result.setType((Type) getType().clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.extraDimensionInfos.addAll(
-					ASTNode.copySubtrees(target, this.extraDimensionInfos));
-		} else {
-			result.setExtraDimensions(getExtraDimensions());
+			result.varargsAnnotations().addAll(
+					ASTNode.copySubtrees(target, varargsAnnotations()));
 		}
 		result.setName((SimpleName) getName().clone(target));
-		result.setInitializer(
-			(Expression) ASTNode.copySubtree(target, getInitializer()));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.varargsAnnotations = new ASTNode.NodeList(VARARGS_ANNOTATIONS_PROPERTY);
-			result.varargsAnnotations().addAll(
-					ASTNode.copySubtrees(target, varargsAnnotations()));
+			result.extraDimensions().addAll(
+					ASTNode.copySubtrees(target, this.extraDimensions()));
+		} else {
+			result.internalSetExtraDimensions(getExtraDimensions());
 		}
+		result.setInitializer(
+				(Expression) ASTNode.copySubtree(target, getInitializer()));
 		return result;
 	}
 
@@ -456,7 +438,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			}
 			acceptChild(visitor, getName());
 			if (this.ast.apiLevel >= AST.JLS8){
-				acceptChildren(visitor, this.extraDimensionInfos);
+				acceptChildren(visitor, this.extraDimensions);
 			}
 			acceptChild(visitor, getInitializer());
 		}
@@ -546,36 +528,6 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		postValueChange(MODIFIERS_PROPERTY);
 	}
 
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public SimpleName getName() {
-		if (this.variableName == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.variableName == null) {
-					preLazyInit();
-					this.variableName = new SimpleName(this.ast);
-					postLazyInit(this.variableName, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.variableName;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public void setName(SimpleName variableName) {
-		if (variableName == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.variableName;
-		preReplaceChild(oldChild, variableName, NAME_PROPERTY);
-		this.variableName = variableName;
-		postReplaceChild(oldChild, variableName, NAME_PROPERTY);
-	}
-
 	/**
 	 * Returns the type of the variable declared in this variable declaration,
 	 * exclusive of any extra array dimensions.
@@ -663,73 +615,9 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	}
 
 	/**
-	 * Returns the number of extra array dimensions over and above the
-	 * explicitly-specified type.
-	 *
-	 * @return the number of extra array dimensions
-	 * @since 2.1
-	 */
-	public int getExtraDimensions() {
-		if (this.ast.apiLevel >= AST.JLS8) {
-			return this.extraDimensionInfos.size();
-		}
-		return this.extraArrayDimensions;
-	}
-
-	/**
-	 * Sets the number of extra array dimensions over and above the
-	 * explicitly-specified type (Not supported in JLS8 and above). 
-	 *
-	 * @param dimensions the number of array dimensions
-	 * @exception IllegalArgumentException if the number of dimensions is
-	 *    negative
-	 * @since 2.1
-	 * @deprecated In the JLS8 API, see: {@link #extraDimensionInfos()}.
-	 */
-	public void setExtraDimensions(int dimensions) {
-		supportedOnlyIn2_3_4();
-		if (dimensions < 0) {
-			throw new IllegalArgumentException();
-		}
-		preValueChange(EXTRA_DIMENSIONS_PROPERTY);
-		this.extraArrayDimensions = dimensions;
-		postValueChange(EXTRA_DIMENSIONS_PROPERTY);
-	}
-
-	/**
-	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
-	 *
-	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
-	 * @since 3.9
-	 */
-	public List extraDimensionInfos() {
-		unsupportedIn2_3_4();
-		return this.extraDimensionInfos;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public Expression getInitializer() {
-		return this.optionalInitializer;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public void setInitializer(Expression initializer) {
-		// a SingleVariableDeclaration may occur inside an Expression
-		// must check cycles
-		ASTNode oldChild = this.optionalInitializer;
-		preReplaceChild(oldChild, initializer,INITIALIZER_PROPERTY);
-		this.optionalInitializer = initializer;
-		postReplaceChild(oldChild, initializer,INITIALIZER_PROPERTY);
-	}
-	
-	/**
-	 * Returns the  ordered list of annotations of variable arguments.
+	 * Returns the ordered list of annotations on the varargs token (added in JLS8 API).
 	 *
-	 * @return the list of annotations of the varargs (element type: {@link Annotation})
+	 * @return the list of annotations on the varargs token (element type: {@link Annotation})
 	 * @exception UnsupportedOperationException if this operation is used
 	 *            in a JLS2, JLS3 or JLS4 AST
 	 * @since 3.9
@@ -755,11 +643,11 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	int treeSize() {
 		return
 			memSize()
-			+ (this.varargsAnnotations == null ? 0 : this.varargsAnnotations.listSize())
 			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
-			+ (this.extraDimensionInfos == null ? 0 : this.extraDimensionInfos.listSize())
 			+ (this.type == null ? 0 : getType().treeSize())
+			+ (this.varargsAnnotations == null ? 0 : this.varargsAnnotations.listSize())
 			+ (this.variableName == null ? 0 : getName().treeSize())
+			+ (this.extraDimensions == null ? 0 : this.extraDimensions.listSize())
 			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
index 3888333..1297b9d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -342,7 +342,7 @@ public class TryStatement extends Statement {
 	}
 
 	/**
-	 * Returns the live ordered list of resources for this try statement.
+	 * Returns the live ordered list of resources for this try statement (added in JLS4 API).
 	 *
 	 * @return the live list of resources
 	 *    (element type: {@link VariableDeclarationExpression})
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
index e9860ee..1055dac 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
@@ -24,8 +24,7 @@ package org.eclipse.jdt.core.dom;
  * are meaningful in all contexts; for example, a wildcard type is only
  * meaningful in the type argument position of a parameterized type.
  * UnionType got introduced in JLS4 to support common catch blocks for disjunctive types.
- * For JLS8, optional annotations indicated by {Annotation} got added and
- * these are absent in JLS2, JLS3 and JLS4.
+ * For JLS8, optional annotations indicated by {Annotation} got added.
  * <p>
  * <pre>
  * Type:
@@ -38,26 +37,28 @@ package org.eclipse.jdt.core.dom;
  *    ParameterizedType
  *    UnionType  
  *    
- * PrimitiveType:
- *    {Annotation} <b>byte</b>
- *    {Annotation} <b>short</b>
- *    {Annotation} <b>char</b>
- *    {Annotation} <b>int</b>
- *    {Annotation} <b>long</b>
- *    {Annotation} <b>float</b>
- *    {Annotation} <b>double</b>
- *    {Annotation} <b>boolean</b>
- *    {Annotation} <b>void</b>
- * ArrayType:
- *    Type {Annotation} <b>'['</b> <b>']'</b>
- * SimpleType:
- *    {Annotation} TypeName
- * ParameterizedType:
+ * {@link PrimitiveType}:
+ *    { Annotation } <b>byte</b>
+ *    { Annotation } <b>short</b>
+ *    { Annotation } <b>char</b>
+ *    { Annotation } <b>int</b>
+ *    { Annotation } <b>long</b>
+ *    { Annotation } <b>float</b>
+ *    { Annotation } <b>double</b>
+ *    { Annotation } <b>boolean</b>
+ *    { Annotation } <b>void</b>
+ * {@link ArrayType}:
+ *    Type { Annotation } <b>'['</b> <b>']'</b>
+ * {@link SimpleType}:
+ *    { Annotation } TypeName
+ * {@link QualifiedType}:
+ *    Type <b>.</b> {Annotation} SimpleName
+ * {@link WildcardType}:
+ *    { Annotation } <b>?</b> [ ( <b>extends</b> | <b>super</b>) Type ]
+ * {@link ParameterizedType}:
  *    Type <b>&lt;</b> Type { <b>,</b> Type } <b>&gt;</b>
- * QualifiedType:
- *    Type <b>.</b>{Annotation} SimpleName
- * WildcardType:
- *    <b>{Annotation} ?</b> [ ( <b>extends</b> | <b>super</b>) Type ]
+ * {@link UnionType}:
+ *    Type <b>|</b> Type { <b>|</b> Type }
  * </pre>
  * </p>
  *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeParameter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeParameter.java
index 3edf039..d99f94d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeParameter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeParameter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2003, 2012 IBM Corporation and others.
+ * Copyright (c) 2003, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,7 +29,7 @@ import java.util.List;
  * For JLS8 optional annotations were added:
  * <pre>
  * TypeParameter:
- *    {Annotation} TypeVariable [ <b>extends</b> Type { <b>&</b> Type } ]
+ *    { Annotation } TypeVariable [ <b>extends</b> Type { <b>&</b> Type } ]
  * </pre>
  *
  * @since 3.1
@@ -38,6 +38,13 @@ import java.util.List;
 public class TypeParameter extends ASTNode {
 
 	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			new ChildListPropertyDescriptor(TypeParameter.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
+	
+	/**
 	 * The "name" structural property of this node type (child type: {@link SimpleName}).
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
@@ -48,13 +55,6 @@ public class TypeParameter extends ASTNode {
 	 */
 	public static final ChildListPropertyDescriptor TYPE_BOUNDS_PROPERTY =
 		new ChildListPropertyDescriptor(TypeParameter.class, "typeBounds", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
-	
-	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(TypeParameter.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -79,9 +79,9 @@ public class TypeParameter extends ASTNode {
 		
 		propertyList = new ArrayList(4);
 		createPropertyList(TypeParameter.class, propertyList);
+		addProperty(ANNOTATIONS_PROPERTY, propertyList);
 		addProperty(NAME_PROPERTY, propertyList);
 		addProperty(TYPE_BOUNDS_PROPERTY, propertyList);
-		addProperty(ANNOTATIONS_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
@@ -107,7 +107,7 @@ public class TypeParameter extends ASTNode {
 	}
 
 	/**
-	 * The type variable node; lazily initialized; defaults to an unspecfied,
+	 * The type variable node; lazily initialized; defaults to an unspecified,
 	 * but legal, name.
 	 */
 	private SimpleName typeVariableName = null;
@@ -121,8 +121,8 @@ public class TypeParameter extends ASTNode {
 
 	/**
 	 * The type annotations (element type: {@link Annotation}).
-	 * Null in JLS2, JLS3 and JLS4. Added in JLS8.
-	 * @since 3.9
+	 * Null in JLS < 8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
 	 */
 	private ASTNode.NodeList annotations = null;
 	
@@ -171,12 +171,12 @@ public class TypeParameter extends ASTNode {
 	 * Method declared on ASTNode.
 	 */
 	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == TYPE_BOUNDS_PROPERTY) {
-			return typeBounds();
-		}
 		if (property == ANNOTATIONS_PROPERTY) {
 			return annotations();
 		}
+		if (property == TYPE_BOUNDS_PROPERTY) {
+			return typeBounds();
+		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
 	}
@@ -194,14 +194,13 @@ public class TypeParameter extends ASTNode {
 	ASTNode clone0(AST target) {
 		TypeParameter result = new TypeParameter(target);
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
-		result.typeBounds().addAll(
-			ASTNode.copySubtrees(target, typeBounds()));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
+		result.setName((SimpleName) ((ASTNode) getName()).clone(target));
+		result.typeBounds().addAll(
+			ASTNode.copySubtrees(target, typeBounds()));
 		return result;
 	}
 
@@ -306,6 +305,7 @@ public class TypeParameter extends ASTNode {
 	 * @since 3.9
 	 */
 	public List annotations() {
+		// more efficient than just calling unsupportedIn2_3_4() to check
 		if (this.annotations == null) {
 			unsupportedIn2_3_4();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
index fc388e8..423843c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,8 +11,10 @@
 
 package org.eclipse.jdt.core.dom;
 
+import java.util.List;
+
 /**
- * Abstract base class of all AST node types that declare a single local
+ * Abstract base class of all AST node types that declare a single
  * variable.
  * <p>
  * <pre>
@@ -29,43 +31,75 @@ package org.eclipse.jdt.core.dom;
 public abstract class VariableDeclaration extends ASTNode {
 
 	/**
-	 * Returns structural property descriptor for the "extraDimensions" property
-	 * of this node (type: {@link Integer}).
+	 * The variable name; lazily initialized; defaults to an unspecified,
+	 * legal Java identifier.
+	 */
+	SimpleName variableName = null;
+
+	/**
+	 * The number of extra array dimensions that appear after the variable;
+	 * defaults to 0. Not used in JLS8 and later.
 	 *
-	 * @return the property descriptor
-	 * @since 3.1
+	 * @since 2.1
+	 * @deprecated In JLS8 and later, use {@link #extraDimensions} instead.
 	 */
-	abstract SimplePropertyDescriptor internalExtraDimensionsProperty();
+	int extraArrayDimensions = 0;
+
+	/**
+	 * List of extra dimensions this node has with optional annotations
+	 * (element type: {@link ExtraDimension}).
+	 * Null before JLS8. Added in JLS8; defaults to an empty list
+	 * (see constructor).
+	 * 
+	 * @since 3.9
+	 */
+	ASTNode.NodeList extraDimensions = null;
+
+	/**
+	 * The initializer expression, or <code>null</code> if none;
+	 * defaults to none.
+	 */
+	Expression optionalInitializer = null;
 
 	/**
-	 * Returns structural property descriptor for the "extraDimensions" property
-	 * of this node (type: {@link Integer}).
+	 * Creates and returns a structural property descriptor for the
+	 * "name" property declared on the given concrete node type (child type: {@link SimpleName}).
 	 *
 	 * @return the property descriptor
-	 * @since 3.1
 	 */
-	public final SimplePropertyDescriptor getExtraDimensionsProperty() {
-		return internalExtraDimensionsProperty();
+	static final ChildPropertyDescriptor internalNamePropertyFactory(Class nodeClass) {
+		return new ChildPropertyDescriptor(nodeClass, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 	}
 
 	/**
-	 * Returns structural property descriptor for the "initializer" property
-	 * of this node (child type: {@link Expression}).
+	 * Creates and returns a structural property descriptor for the
+	 * "extraDimensions" property declared on the given concrete node type (type: {@link Integer}).
 	 *
 	 * @return the property descriptor
-	 * @since 3.1
+	 * @deprecated In JLS8 and later, use {@link #internalExtraDimensions2PropertyFactory(Class)} instead.
 	 */
-	abstract ChildPropertyDescriptor internalInitializerProperty();
-
+	static final SimplePropertyDescriptor internalExtraDimensionsPropertyFactory(Class nodeClass) {
+		return 	new SimplePropertyDescriptor(nodeClass, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
+	}
+	
 	/**
-	 * Returns structural property descriptor for the "initializer" property
-	 * of this node (child type: {@link Expression}).
+	 * Creates and returns a structural property descriptor for the
+	 * "extraDimensions" property declared on the given concrete node type (element type: {@link ExtraDimension}).
 	 *
 	 * @return the property descriptor
-	 * @since 3.1
 	 */
-	public final ChildPropertyDescriptor getInitializerProperty() {
-		return internalInitializerProperty();
+	static final ChildListPropertyDescriptor internalExtraDimensions2PropertyFactory(Class nodeClass) {
+		return 	new ChildListPropertyDescriptor(nodeClass, "extraDimensions", ExtraDimension.class, CYCLE_RISK); //$NON-NLS-1$
+	}
+	
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "initializer" property declared on the given concrete node type (child type: {@link Expression}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildPropertyDescriptor internalInitializerPropertyFactory(Class nodeClass) {
+		return 	new ChildPropertyDescriptor(nodeClass, "initializer", Expression.class, OPTIONAL, CYCLE_RISK); //$NON-NLS-1$
 	}
 
 	/**
@@ -78,7 +112,7 @@ public abstract class VariableDeclaration extends ASTNode {
 	abstract ChildPropertyDescriptor internalNameProperty();
 
 	/**
-	 * Returns structural property descriptor for the "name" property
+	 * Returns the structural property descriptor for the "name" property
 	 * of this node (child type: {@link SimpleName}).
 	 *
 	 * @return the property descriptor
@@ -88,6 +122,69 @@ public abstract class VariableDeclaration extends ASTNode {
 		return internalNameProperty();
 	}
 
+	
+	/**
+	 * Returns the structural property descriptor for the "extraDimensions" property
+	 * of this node (type: {@link Integer}) (below JLS8 only).
+	 *
+	 * @return the property descriptor
+	 * @since 3.1
+	 * @deprecated In JLS8 and later, use {@link #internalExtraDimensions2Property()} instead.
+	 */
+	abstract SimplePropertyDescriptor internalExtraDimensionsProperty();
+
+	/**
+	 * Returns the structural property descriptor for the "extraDimensions" property
+	 * of this node (type: {@link Integer}) (below JLS8 only).
+	 *
+	 * @return the property descriptor
+	 * @since 3.1
+	 * @deprecated In JLS8 and later, use {@link #getExtraDimensions2Property()} instead.
+	 */
+	public final SimplePropertyDescriptor getExtraDimensionsProperty() {
+		return internalExtraDimensionsProperty();
+	}
+
+	/**
+	 * Returns the structural property descriptor for the "extraDimensions" property
+	 * of this node (element type: {@link ExtraDimension}) (added in JLS8 API).
+	 *
+	 * @return the property descriptor
+	 * @since 3.9
+	 */
+	abstract ChildListPropertyDescriptor internalExtraDimensions2Property();
+	
+	/**
+	 * Returns the structural property descriptor for the "extraDimensions" property
+	 * of this node (element type: {@link ExtraDimension}) (added in JLS8 API).
+	 *
+	 * @return the property descriptor
+	 * @since 3.9
+	 */
+	public final ChildListPropertyDescriptor getExtraDimensions2Property() {
+		return internalExtraDimensions2Property();
+	}
+	
+	/**
+	 * Returns structural property descriptor for the "initializer" property
+	 * of this node (child type: {@link Expression}).
+	 *
+	 * @return the property descriptor
+	 * @since 3.1
+	 */
+	abstract ChildPropertyDescriptor internalInitializerProperty();
+
+	/**
+	 * Returns structural property descriptor for the "initializer" property
+	 * of this node (child type: {@link Expression}).
+	 *
+	 * @return the property descriptor
+	 * @since 3.1
+	 */
+	public final ChildPropertyDescriptor getInitializerProperty() {
+		return internalInitializerProperty();
+	}
+
 	/**
 	 * Creates a new AST node for a variable declaration owned by the given AST.
 	 * <p>
@@ -98,6 +195,9 @@ public abstract class VariableDeclaration extends ASTNode {
 	 */
 	VariableDeclaration(AST ast) {
 		super(ast);
+		if (ast.apiLevel >= AST.JLS8) {
+			this.extraDimensions = new ASTNode.NodeList(getExtraDimensions2Property());
+		}
 	}
 
 	/**
@@ -105,7 +205,19 @@ public abstract class VariableDeclaration extends ASTNode {
 	 *
 	 * @return the variable name node
 	 */
-	public abstract SimpleName getName();
+	public SimpleName getName() {
+		if (this.variableName == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.variableName == null) {
+					preLazyInit();
+					this.variableName = new SimpleName(this.ast);
+					postLazyInit(this.variableName, internalNameProperty());
+				}
+			}
+		}
+		return this.variableName;
+	}
 
 	/**
 	 * Sets the name of the variable declared in this variable declaration
@@ -118,7 +230,16 @@ public abstract class VariableDeclaration extends ASTNode {
 	 * <li>the node already has a parent</li>
 	 * </ul>
 	 */
-	public abstract void setName(SimpleName variableName);
+	public void setName(SimpleName variableName) {
+		if (variableName == null) {
+			throw new IllegalArgumentException();
+		}
+		ChildPropertyDescriptor p = internalNameProperty();
+		ASTNode oldChild = this.variableName;
+		preReplaceChild(oldChild, variableName, p);
+		this.variableName = variableName;
+		postReplaceChild(oldChild, variableName, p);
+	}
 
 	/**
 	 * Returns the number of extra array dimensions over and above the
@@ -131,11 +252,23 @@ public abstract class VariableDeclaration extends ASTNode {
 	 * ASTs, even though there are really syntactic variants of the same
 	 * variable declaration.
 	 * </p>
+	 * <p>
+	 * In the JLS8 API, this method is a convenience method that
+	 * counts {@link #extraDimensions()}.
+	 * </p>
 	 *
 	 * @return the number of extra array dimensions
 	 * @since 2.1
 	 */
-	public abstract int getExtraDimensions();
+	public int getExtraDimensions() {
+		// more efficient than checking getAST().API_LEVEL
+		if (this.extraDimensions == null) {
+			// JLS2,3,4 behavior - bona fide property
+			return this.extraArrayDimensions;
+		} else {
+			return this.extraDimensions.size();
+		}
+	}
 
 	/**
 	 * Sets the number of extra array dimensions over and above the
@@ -152,9 +285,49 @@ public abstract class VariableDeclaration extends ASTNode {
 	 * @param dimensions the number of array dimensions
 	 * @exception IllegalArgumentException if the number of dimensions is
 	 *    negative
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS8 or later AST 
+	 * @deprecated In the JLS8 API, this method is replaced by
+	 * {@link #extraDimensions()} which contains a list of {@link ExtraDimension} nodes.
 	 * @since 2.1
 	 */
-	public abstract void setExtraDimensions(int dimensions);
+	public void setExtraDimensions(int dimensions) {
+		internalSetExtraDimensions(dimensions);
+	}
+
+	/**
+	 * Internal synonym for deprecated method. Used to avoid
+	 * deprecation warnings.
+	 * @since 3.9
+	 */
+	final void internalSetExtraDimensions(int dimensions) {
+		// more efficient than just calling supportedOnlyIn2_3_4() to check
+		if (this.extraDimensions != null) {
+			supportedOnlyIn2_3_4();
+		}
+		if (dimensions < 0) {
+			throw new IllegalArgumentException();
+		}
+		SimplePropertyDescriptor p = internalExtraDimensionsProperty();
+		preValueChange(p);
+		this.extraArrayDimensions = dimensions;
+		postValueChange(p);
+	}
+
+	/**
+	 * Returns the live ordered list of extra dimensions with optional annotations (added in JLS8 API).
+	 *
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
+	 * @exception UnsupportedOperationException if this operation is used below JLS8
+	 * @since 3.9
+	 */
+	public List extraDimensions() {
+		// more efficient than just calling unsupportedIn2_3_4() to check
+		if (this.extraDimensions == null) {
+			unsupportedIn2_3_4();
+		}
+		return this.extraDimensions;
+	}
 
 	/**
 	 * Returns the initializer of this variable declaration, or
@@ -163,7 +336,9 @@ public abstract class VariableDeclaration extends ASTNode {
 	 * @return the initializer expression node, or <code>null</code> if
 	 *    there is none
 	 */
-	public abstract Expression getInitializer();
+	public Expression getInitializer() {
+		return this.optionalInitializer;
+	}
 
 	/**
 	 * Sets or clears the initializer of this variable declaration.
@@ -177,7 +352,13 @@ public abstract class VariableDeclaration extends ASTNode {
 	 * <li>a cycle in would be created</li>
 	 * </ul>
 	 */
-	public abstract void setInitializer(Expression initializer);
+	public void setInitializer(Expression initializer) {
+		ChildPropertyDescriptor p = internalInitializerProperty();
+		ASTNode oldChild = this.optionalInitializer;
+		preReplaceChild(oldChild, initializer, p);
+		this.optionalInitializer = initializer;
+		postReplaceChild(oldChild, initializer, p);
+	}
 
 	/**
 	 * Resolves and returns the binding for the variable declared in this
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
index 20668d1..e27358f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -41,30 +41,30 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 * @since 3.0
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(VariableDeclarationFragment.class, "name", SimpleName.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+			internalNamePropertyFactory(VariableDeclarationFragment.class);
 
 	/**
-	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 * The "extraDimensions" structural property of this node type (type: {@link Integer}) (below JLS8 only).
 	 *
 	 * @since 3.0
-	 * @deprecated in JLS8, use {@link VariableDeclarationFragment#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
+	 * @deprecated in JLS8 and later, use {@link VariableDeclarationFragment#EXTRA_DIMENSIONS2_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (Added in JLS8 API).
+	 * The "extraDimensions" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
-	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSIONS2_PROPERTY =
+			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
 	 * @since 3.0
 	 */
 	public static final ChildPropertyDescriptor INITIALIZER_PROPERTY =
-		new ChildPropertyDescriptor(VariableDeclarationFragment.class, "initializer", Expression.class, OPTIONAL, CYCLE_RISK); //$NON-NLS-1$
+			internalInitializerPropertyFactory(VariableDeclarationFragment.class);
 
 	/**
 	 * A list of property descriptors (element type:
@@ -93,7 +93,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		propertyList = new ArrayList(4);
 		createPropertyList(VariableDeclarationFragment.class, propertyList);
 		addProperty(NAME_PROPERTY, propertyList);
-		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSIONS2_PROPERTY, propertyList);
 		addProperty(INITIALIZER_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
@@ -117,31 +117,6 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	}
 
 	/**
-	 * The variable name; lazily initialized; defaults to an unspecified,
-	 * legal Java identifier.
-	 */
-	private SimpleName variableName = null;
-
-	/**
-	 * The number of extra array dimensions that this variable has;
-	 * defaults to 0.
-	 */
-	private int extraArrayDimensions = 0;
-
-	/**
-	 * The extra dimensions this node has with optional annotations.
-	 *
-	 * @since 3.9
-	 */
-	protected ASTNode.NodeList extraDimensionInfos = null;
-
-	/**
-	 * The initializer expression, or <code>null</code> if none;
-	 * defaults to none.
-	 */
-	private Expression optionalInitializer = null;
-
-	/**
 	 * Creates a new AST node for a variable declaration fragment owned by the
 	 * given AST. By default, the variable declaration has: an unspecified
 	 * (but legal) variable name, no initializer, and no extra array dimensions.
@@ -153,33 +128,38 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 */
 	VariableDeclarationFragment(AST ast) {
 		super(ast);
-		if (ast.apiLevel >= AST.JLS8) {
-			this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
-		}
 	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final SimplePropertyDescriptor internalExtraDimensionsProperty() {
-		return EXTRA_DIMENSIONS_PROPERTY;
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final ChildPropertyDescriptor internalInitializerProperty() {
-		return INITIALIZER_PROPERTY;
+	final SimplePropertyDescriptor internalExtraDimensionsProperty() {
+		return EXTRA_DIMENSIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalExtraDimensions2Property() {
+		return EXTRA_DIMENSIONS2_PROPERTY;
+	}
+	
+	/* (omit javadoc for this method)
+	 * Method declared on VariableDeclaration.
 	 * @since 3.1
 	 */
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
+	final ChildPropertyDescriptor internalInitializerProperty() {
+		return INITIALIZER_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -197,7 +177,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 			if (get) {
 				return getExtraDimensions();
 			} else {
-				setExtraDimensions(value);
+				internalSetExtraDimensions(value);
 				return 0;
 			}
 		}
@@ -233,8 +213,8 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 * Method declared on ASTNode.
 	 */
 	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return extraDimensionInfos();
+		if (property == EXTRA_DIMENSIONS2_PROPERTY) {
+			return extraDimensions();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -255,10 +235,10 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		result.setSourceRange(getStartPosition(), getLength());
 		result.setName((SimpleName) getName().clone(target));
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.extraDimensionInfos.addAll(
-					ASTNode.copySubtrees(target, this.extraDimensionInfos));
+			result.extraDimensions().addAll(
+					ASTNode.copySubtrees(target, extraDimensions()));
 		} else {
-			result.setExtraDimensions(getExtraDimensions());
+			result.internalSetExtraDimensions(getExtraDimensions());
 		}
 		result.setInitializer(
 			(Expression) ASTNode.copySubtree(target, getInitializer()));
@@ -282,7 +262,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 			// visit children in normal left to right reading order
 			acceptChild(visitor, getName());
 			if (this.ast.apiLevel >= AST.JLS8) {
-				acceptChildren(visitor, this.extraDimensionInfos);
+				acceptChildren(visitor, this.extraDimensions);
 			}
 			acceptChild(visitor, getInitializer());
 		}
@@ -290,110 +270,6 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	}
 
 	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public SimpleName getName() {
-		if (this.variableName == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.variableName == null) {
-					preLazyInit();
-					this.variableName = new SimpleName(this.ast);
-					postLazyInit(this.variableName, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.variableName;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public void setName(SimpleName variableName) {
-		if (variableName == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.variableName;
-		preReplaceChild(oldChild, variableName, NAME_PROPERTY);
-		this.variableName = variableName;
-		postReplaceChild(oldChild, variableName, NAME_PROPERTY);
-	}
-
-	/**
-	 * Returns the number of extra array dimensions this variable has over
-	 * and above the type specified in the enclosing declaration.
-	 * <p>
-	 * For example, in the AST for <code>int[] i, j[], k[][]</code> the
-	 * variable declaration fragments for the variables <code>i</code>,
-	 * <code>j</code>, and <code>k</code>, have 0, 1, and 2 extra array
-	 * dimensions, respectively.
-	 * </p>
-	 *
-	 * @return the number of extra array dimensions this variable has over
-	 *         and above the type specified in the enclosing declaration
-	 * @since 2.0
-	 */
-	public int getExtraDimensions() {
-		if (this.ast.apiLevel >= AST.JLS8) {
-			return this.extraDimensionInfos.size();
-		}
-		return this.extraArrayDimensions;
-	}
-
-	/**
-	 * Sets the number of extra array dimensions this variable has over
-	 * and above the type specified in the enclosing declaration.
-	 * <p>
-	 * For example, in the AST for <code>int[] i, j[], k[][]</code> the
-	 * variable declaration fragments for the variables <code>i</code>,
-	 * <code>j</code>, and <code>k</code>, have 0, 1, and 2 extra array
-	 * dimensions, respectively.
-	 * </p>
-	 *
-	 * @param dimensions the given dimensions
-	 * @since 2.0
-	 * @deprecated In the JLS8 API, see: {@link #extraDimensionInfos()}.
-	 */
-	public void setExtraDimensions(int dimensions) {
-		supportedOnlyIn2_3_4();
-		if (dimensions < 0) {
-			throw new IllegalArgumentException();
-		}
-		preValueChange(EXTRA_DIMENSIONS_PROPERTY);
-		this.extraArrayDimensions = dimensions;
-		postValueChange(EXTRA_DIMENSIONS_PROPERTY);
-	}
-
-	/**
-	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
-	 *
-	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
-	 * @see AST#newExtraDimension()
-	 * @since 3.9
-	 */
-	public List extraDimensionInfos() {
-		unsupportedIn2_3_4();
-		return this.extraDimensionInfos;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public Expression getInitializer() {
-		return this.optionalInitializer;
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
-	 */
-	public void setInitializer(Expression initializer) {
-		ASTNode oldChild = this.optionalInitializer;
-		preReplaceChild(oldChild, initializer, INITIALIZER_PROPERTY);
-		this.optionalInitializer = initializer;
-		postReplaceChild(oldChild, initializer, INITIALIZER_PROPERTY);
-	}
-
-	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
 	int memSize() {
@@ -408,7 +284,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		return
 			memSize()
 			+ (this.variableName == null ? 0 : getName().treeSize())
-			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize())
-			+ (this.extraDimensionInfos == null ? 0 : extraDimensionInfos().size());
+			+ (this.extraDimensions == null ? 0 : this.extraDimensions.listSize())
+			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/WildcardType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/WildcardType.java
index 9f22223..6976ee1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/WildcardType.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/WildcardType.java
@@ -28,7 +28,7 @@ import java.util.List;
  * For JLS8 optional annotations were added:
  * <pre>
  * WildcardType:
- *    <b>{Annotation} ?</b> [ ( <b>extends</b> | <b>super</b>) Type ]
+ *    { Annotation } <b>?</b> [ ( <b>extends</b> | <b>super</b>) Type ]
  * </pre>
  * <p>
  * Not all node arrangements will represent legal Java constructs. In particular,
@@ -42,6 +42,13 @@ import java.util.List;
 public class WildcardType extends AnnotatableType {
 
 	/**
+	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+			internalAnnotationsPropertyFactory(WildcardType.class);
+	
+	/**
 	 * The "bound" structural property of this node type (child type: {@link Type}).
 	 */
 	public static final ChildPropertyDescriptor BOUND_PROPERTY =
@@ -52,13 +59,6 @@ public class WildcardType extends AnnotatableType {
 	 */
 	public static final SimplePropertyDescriptor UPPER_BOUND_PROPERTY =
 		new SimplePropertyDescriptor(WildcardType.class, "upperBound", boolean.class, MANDATORY); //$NON-NLS-1$
-	
-	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(WildcardType.class, "annotations", Annotation.class, CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -83,9 +83,9 @@ public class WildcardType extends AnnotatableType {
 		
 		propertyList = new ArrayList(4);
 		createPropertyList(WildcardType.class, propertyList);
+		addProperty(ANNOTATIONS_PROPERTY, propertyList);
 		addProperty(BOUND_PROPERTY, propertyList);
 		addProperty(UPPER_BOUND_PROPERTY, propertyList);
-		addProperty(ANNOTATIONS_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
@@ -135,9 +135,14 @@ public class WildcardType extends AnnotatableType {
 	WildcardType(AST ast) {
 		super(ast);
 	    unsupportedIn2();
-	    if (ast.apiLevel >= AST.JLS8) {
-			this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-		}
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on AnnotatableType.
+	 * @since 3.9
+	 */
+	final ChildListPropertyDescriptor internalAnnotationsProperty() {
+		return ANNOTATIONS_PROPERTY;
 	}
 
 	/* (omit javadoc for this method)
@@ -203,11 +208,11 @@ public class WildcardType extends AnnotatableType {
 	ASTNode clone0(AST target) {
 		WildcardType result = new WildcardType(target);
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setBound((Type) ASTNode.copySubtree(target, getBound()), isUpperBound());
 		if (this.ast.apiLevel >= AST.JLS8) {
-			result.annotations.addAll(
+			result.annotations().addAll(
 					ASTNode.copySubtrees(target, annotations()));
 		}
+		result.setBound((Type) ASTNode.copySubtree(target, getBound()), isUpperBound());
 		return result;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index b270142..0905d6a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -417,13 +417,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	public boolean visit(ExtraDimension node) {
-		this.buffer.append(" ");//$NON-NLS-1$
-		visitAnnotationsList(node.annotations());
-		this.buffer.append("[]"); //$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(AssertStatement)
 	 */
@@ -767,6 +760,13 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	public boolean visit(ExtraDimension node) {
+		this.buffer.append(" ");//$NON-NLS-1$
+		visitAnnotationsList(node.annotations());
+		this.buffer.append("[]"); //$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(FieldAccess)
 	 */
@@ -1047,7 +1047,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 		this.buffer.append(")");//$NON-NLS-1$
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.extraDimensionInfos();
+			List dimensions = node.extraDimensions();
 			for (int i = 0; i < size; i++) {
 				visit((ExtraDimension) dimensions.get(i));
 			}
@@ -1372,16 +1372,11 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getType().accept(this);
 		if (node.getAST().apiLevel() >= JLS3) {
 			if (node.isVarargs()) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391898
 				if (node.getAST().apiLevel() >= AST.JLS8) {
 					List annotations = node.varargsAnnotations();
 					if (annotations != null) {
-						this.buffer.append(' ');						
-						for (Iterator it = annotations.iterator(); it.hasNext(); ) {
-							Annotation annotation = (Annotation) it.next();
-							annotation.accept(this);
-							this.buffer.append(' ');
-						}
+						this.buffer.append(' ');
+						visitAnnotationsList(annotations);
 					}
 				}
 				this.buffer.append("...");//$NON-NLS-1$
@@ -1391,7 +1386,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getName().accept(this);
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.extraDimensionInfos();
+			List dimensions = node.extraDimensions();
 			for (int i = 0; i < size; i++) {
 				visit((ExtraDimension) dimensions.get(i));
 			}
@@ -1753,14 +1748,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	 */
 	public boolean visit(TypeParameter node) {
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List annotations = node.annotations();
-			if (annotations != null) {
-				for (Iterator it = annotations.iterator(); it.hasNext(); ) {
-					Annotation annotation = (Annotation) it.next();
-					annotation.accept(this);
-					this.buffer.append(' ');
-				}
-			}
+			visitAnnotationsList(node.annotations());
 		}
 		node.getName().accept(this);
 		if (!node.typeBounds().isEmpty()) {
@@ -1820,7 +1808,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getName().accept(this);
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.extraDimensionInfos();
+			List dimensions = node.extraDimensions();
 			for (int i = 0; i < size; i++) {
 				visit((ExtraDimension) dimensions.get(i));
 			}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index f79c6dd..a0b8c99 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -85,6 +85,12 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	 */
 	static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
 	/**
+	 * Internal synonym for deprecated constant MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	private static final ChildListPropertyDescriptor INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY = MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY;
+	/**
 	 * Internal synonym for deprecated constant SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY
 	 * to alleviate deprecated warnings.
 	 * @deprecated
@@ -1869,7 +1875,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 			}
 
 			pos= getScanner().getTokenEndOffset(TerminalTokens.TokenNameRPAREN, pos);
-			ChildListPropertyDescriptor exceptionsProperty = apiLevel < AST.JLS8 ? MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY;
+			ChildListPropertyDescriptor exceptionsProperty = apiLevel < AST.JLS8 ? INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY;
 
 			if (apiLevel < AST.JLS8) {
 				int extraDims= rewriteExtraDimensions(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, pos);
@@ -2905,7 +2911,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 				}
 			}
 		} else {
-			pos = rewriteExtraDimensionsInfo(node, pos, SingleVariableDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			pos = rewriteExtraDimensionsInfo(node, pos, SingleVariableDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 		}
 
 		rewriteNode(node, SingleVariableDeclaration.INITIALIZER_PROPERTY, pos, this.formatter.VAR_INITIALIZER);
@@ -3308,7 +3314,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 				}
 			}
 		} else {
-			pos = rewriteExtraDimensionsInfo(node, pos, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
+			pos = rewriteExtraDimensionsInfo(node, pos, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
 		}
 		rewriteNode(node, VariableDeclarationFragment.INITIALIZER_PROPERTY, pos, this.formatter.VAR_INITIALIZER);
 		return false;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 6485aff..a678af1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -42,6 +42,12 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	 */
 	static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
 	/**
+	 * Internal synonym for deprecated constant MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final ChildListPropertyDescriptor INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY = MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY;
+	/**
 	 * Internal synonym for deprecated constant SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY
 	 * to alleviate deprecated warnings.
 	 * @deprecated
@@ -658,7 +664,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		visitExtraDimensions(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
 
 		ChildListPropertyDescriptor exceptionsProperty = node.getAST().apiLevel() <	AST.JLS8 ? 
-				MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY;
+				INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY;
 		visitList(node, exceptionsProperty, String.valueOf(','), " throws ", Util.EMPTY_STRING); //$NON-NLS-1$			
 		ASTNode body= getChildNode(node, MethodDeclaration.BODY_PROPERTY);
 		if (body == null) {
@@ -821,7 +827,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		}
 		this.result.append(' ');
 		getChildNode(node, SingleVariableDeclaration.NAME_PROPERTY).accept(this);
-		visitExtraDimensions(node, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, SingleVariableDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+		visitExtraDimensions(node, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, SingleVariableDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 		ASTNode initializer= getChildNode(node, SingleVariableDeclaration.INITIALIZER_PROPERTY);
 		if (initializer != null) {
 			this.result.append('=');
@@ -1063,7 +1069,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	 */
 	public boolean visit(VariableDeclarationFragment node) {
 		getChildNode(node, VariableDeclarationFragment.NAME_PROPERTY).accept(this);
-		visitExtraDimensions(node, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, VariableDeclarationFragment.EXTRA_DIMENSION_INFOS_PROPERTY);
+		visitExtraDimensions(node, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, VariableDeclarationFragment.EXTRA_DIMENSIONS2_PROPERTY);
 		ASTNode initializer= getChildNode(node, VariableDeclarationFragment.INITIALIZER_PROPERTY);
 		if (initializer != null) {
 			this.result.append('=');
commit 31085e35ec6546fd0ce14d2c37082b7385a37318
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Wed Mar 20 18:03:00 2013 +0100

    Bug 401941: [1.8][dom/ast] DOM/AST structure review

4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
7	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
index 8d22dc6..a81894d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
@@ -3114,7 +3114,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo1");
 
-			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
 			markerAnnotation.setTypeName(ast.newSimpleName("Annot1"));
@@ -3132,7 +3132,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo2");
-			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
@@ -3146,7 +3146,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo3");
-			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 
 			ExtraDimension dim= ast.newExtraDimension();
 			MarkerAnnotation markerAnnotation= ast.newMarkerAnnotation();
@@ -3199,7 +3199,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo7");
-			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+			ListRewrite listRewrite= rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			ExtraDimension dim= (ExtraDimension) methodDecl.extraDimensions().get(0);
 			listRewrite.remove(dim, null);
 			dim= (ExtraDimension) methodDecl.extraDimensions().get(1);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index 0e4805f..a6e18ec 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -114,17 +114,17 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * The "extraDimensions" structural property of this node type (type: {@link Integer}) (below JLS8 only).
 	 *
 	 * @since 3.0
-	 * @deprecated In JLS8 and later, use {@link MethodDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
+	 * @deprecated In JLS8 and later, use {@link MethodDeclaration#EXTRA_DIMENSIONS2_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(MethodDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 	
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
+	 * The "extraDimensions2" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
-	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(MethodDeclaration.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSIONS2_PROPERTY =
+			new ChildListPropertyDescriptor(MethodDeclaration.class, "extraDimensions2", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "typeParameters" structural property of this node type (element type: {@link TypeParameter}) (added in JLS3 API).
@@ -239,7 +239,7 @@ public class MethodDeclaration extends BodyDeclaration {
 		addProperty(RECEIVER_TYPE_PROPERTY, propertyList);
 		addProperty(RECEIVER_QUALIFIER_PROPERTY, propertyList);
 		addProperty(PARAMETERS_PROPERTY, propertyList);
-		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSIONS2_PROPERTY, propertyList);
 		addProperty(THROWN_EXCEPTION_TYPES_PROPERTY, propertyList);
 		addProperty(BODY_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);	
@@ -385,7 +385,7 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (ast.apiLevel < AST.JLS8) {
 			this.thrownExceptions = new ASTNode.NodeList(THROWN_EXCEPTIONS_PROPERTY);
 		} else {
-			this.extraDimensions = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
+			this.extraDimensions = new ASTNode.NodeList(EXTRA_DIMENSIONS2_PROPERTY);
 			this.thrownExceptionTypes = new ASTNode.NodeList(THROWN_EXCEPTION_TYPES_PROPERTY);
 		}
 	}
@@ -521,7 +521,7 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (property == THROWN_EXCEPTION_TYPES_PROPERTY) {
 			return thrownExceptionTypes();
 		}		
-		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
+		if (property == EXTRA_DIMENSIONS2_PROPERTY) {
 			return extraDimensions();
 		}
 		// allow default implementation to flag the error
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 55371a7..01e6159 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -1973,7 +1973,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 					}
 				}
 			} else {
-				pos= rewriteExtraDimensionsInfo(node, pos, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+				pos= rewriteExtraDimensionsInfo(node, pos, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			}
 
 			pos= rewriteNodeList(node, exceptionsProperty, pos, " throws ", ", "); //$NON-NLS-1$ //$NON-NLS-2$
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 564a936..ee0eacc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -683,7 +683,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		this.result.append('(');
 		visitList(node, MethodDeclaration.PARAMETERS_PROPERTY, String.valueOf(','));
 		this.result.append(')');
-		visitExtraDimensions(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, MethodDeclaration.EXTRA_DIMENSION_INFOS_PROPERTY);
+		visitExtraDimensions(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 
 		ChildListPropertyDescriptor exceptionsProperty = node.getAST().apiLevel() <	AST.JLS8 ? 
 				INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY : MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY;
commit 9bafd098a4f01cb487df1e23626d9ca01b29c273
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Wed Mar 20 18:16:40 2013 +0100

    Bug 401941: [1.8][dom/ast] DOM/AST structure review

1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
index 7df49c0..ed20968 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
@@ -92,7 +92,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			internalExtraDimensionsPropertyFactory(SingleVariableDeclaration.class);
 
 	/**
-	 * The "extraDimensions" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
+	 * The "extraDimensions2" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSIONS2_PROPERTY =
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
index 423843c..c141404 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclaration.java
@@ -84,12 +84,12 @@ public abstract class VariableDeclaration extends ASTNode {
 	
 	/**
 	 * Creates and returns a structural property descriptor for the
-	 * "extraDimensions" property declared on the given concrete node type (element type: {@link ExtraDimension}).
+	 * "extraDimensions2" property declared on the given concrete node type (element type: {@link ExtraDimension}).
 	 *
 	 * @return the property descriptor
 	 */
 	static final ChildListPropertyDescriptor internalExtraDimensions2PropertyFactory(Class nodeClass) {
-		return 	new ChildListPropertyDescriptor(nodeClass, "extraDimensions", ExtraDimension.class, CYCLE_RISK); //$NON-NLS-1$
+		return 	new ChildListPropertyDescriptor(nodeClass, "extraDimensions2", ExtraDimension.class, CYCLE_RISK); //$NON-NLS-1$
 	}
 	
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
index 57fca13..866436d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
@@ -44,14 +44,14 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 * @deprecated in JLS8 and later, use {@link VariableDeclarationFragment#EXTRA_DIMENSIONS2_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
-		new SimplePropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
+			internalExtraDimensionsPropertyFactory(VariableDeclarationFragment.class);
 
 	/**
-	 * The "extraDimensions" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
+	 * The "extraDimensions2" structural property of this node type (element type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSIONS2_PROPERTY =
-			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
+			internalExtraDimensions2PropertyFactory(VariableDeclarationFragment.class);
 
 	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
