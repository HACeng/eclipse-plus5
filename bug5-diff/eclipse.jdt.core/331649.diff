commit bd0edd7688142c1743cb6b10766dfc576040f113
Author: Stephan Herrmann <sherrmann>
Date:   Sat Jan 21 20:35:01 2012 +0100

    Initial implementation for Bug 331649:
    [compiler][null] consider null annotations for fields

4	3	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
4	3	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
14	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
535	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
129	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
22	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java
15	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
37	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
8	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
41	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
22	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Literal.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
48	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
24	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
11	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
13	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
38	33	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
33	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
17	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
26	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
12	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
133	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
7	4	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
index 9372739..36ec3ae 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011 Stephan Herrmann and others.
+ * Copyright (c) 2011, 2012 Stephan Herrmann and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation can never have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -44,7 +45,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface NonNull {
 	// marker annotation with no members
 }
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
index 41f93cd..cb84e45 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011 Stephan Herrmann and others.
+ * Copyright (c) 2011, 2012 Stephan Herrmann and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation is allowed to have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -35,7 +36,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface Nullable {
 	// marker annotation with no members
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index 4a8b0fa..f8b098a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -10399,7 +10399,7 @@ public void testBug365437e() {
 			"}\n" +
 			"class E3 {\n" +
 			"	 @p.NonNull\n" +
-			"    private int E3;\n" +
+			"    private Object E3 = new Object();\n" +
 			"}\n" +
 			"class E4 {\n" +
 			"	 @Deprecated\n" +
@@ -10439,8 +10439,8 @@ public void testBug365437e() {
 		"The value of the field E2.E2 is not used\n" + 
 		"----------\n" + 
 		"4. ERROR in Example.java (at line 15)\n" + 
-		"	private int E3;\n" + 
-		"	            ^^\n" + 
+		"	private Object E3 = new Object();\n" + 
+		"	               ^^\n" + 
 		"The value of the field E3.E3 is not used\n" + 
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index fd918b5..dfa42f6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -726,8 +726,11 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonGenericConstructor", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericMethod", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -739,6 +742,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullFieldInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -798,9 +802,11 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedundantFieldNullAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -886,6 +892,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UninitializedLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1429,8 +1436,11 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonGenericConstructor", SKIP);
 		expectedProblemAttributes.put("NonGenericMethod", SKIP);
 		expectedProblemAttributes.put("NonGenericType", SKIP);
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
@@ -1442,6 +1452,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleField", SKIP);
 		expectedProblemAttributes.put("NotVisibleMethod", SKIP);
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullFieldInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
@@ -1501,9 +1512,11 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedundantFieldNullAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
@@ -1589,6 +1602,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(JavaCore.COMPILER_PB_UNHANDLED_WARNING_TOKEN));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariable", SKIP);
+		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 1b1d69c..b004d49 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -53,7 +53,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "test_redundant_annotation_" };
+//		TESTS_NAMES = new String[] { "test_nullable_field" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -1483,7 +1483,12 @@ public void test_nonnull_return_008() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	if (getObject() == null)\n" +
 		"	    ^^^^^^^^^^^\n" +
-		"Redundant null check: The method getObject() cannot return null\n" +
+		"Null comparison always yields false: The method getObject() cannot return null\n" +
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	throw new RuntimeException();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
 		"----------\n");
 }
 // a result from a nonnull method is directly checked for null (from local): redundant
@@ -1546,10 +1551,10 @@ public void test_nonnull_return_009a() {
 // a result from a nonnull method is directly checked for null (from local): redundant despite loop
 // disabled because only one of two desirable errors is raised
 // need to integrate @NonNull expressions (MessageSend and more) into deferred analysis by FlowContext
-public void _test_nonnull_return_009b() {
+public void test_nonnull_return_009b() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
-	runConformTestWithLibs(
+	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
 			"import org.eclipse.jdt.annotation.*;\n" +
@@ -1573,11 +1578,13 @@ public void _test_nonnull_return_009b() {
 		"	if (left != getObject())\n" +
 		"	    ^^^^\n" +
 		"Redundant null check: The variable left can only be null at this location\n" +
-		"----------\n" +
-		"2. ERROR in X.java (at line 9)\n" +
-		"	if (left != getObject())\n" +
-		"	            ^^^^^^^^^^^\n" +
-		"Redundant null check: The method getObject() cannot return null\n" +
+// Ideally we would see a second error, but when comparing local (depends on loop) with @NonNull
+// we would have to include @NonNull into deferred checking :(
+//		"----------\n" +
+//		"2. ERROR in X.java (at line 9)\n" +
+//		"	if (left != getObject())\n" +
+//		"	            ^^^^^^^^^^^\n" +
+//		"Redundant null check: The method getObject() cannot return null\n" +
 		"----------\n");
 }
 // a result from a nullable method is assigned and checked for null (from local): not redundant
@@ -3386,4 +3393,523 @@ public void test_options_03() {
 		"Dead code\n" + 
 		"----------\n");
 }
+// access to a non-null field
+public void test_nonnull_field_1() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is not properly initialized
+public void test_nonnull_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 2)\n" +
+		"	public class X {\n" +
+		"	             ^\n" +
+		"The @NonNull field o may not have been initialized\n" +
+		"----------\n");
+}
+
+// a non-null field is not properly initialized - explicit constructor
+public void test_nonnull_field_2a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    X (boolean b) { // only potentially initialized\n" +
+			"        if (b)\n" +
+			"            o = this;\n" +
+			"    }\n" +
+			"    X (@NonNull Object other) {\n" + // no problem
+			"        o = other;\n" +
+			"    }\n" +
+			"    public String oString() {\n" +
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	X (boolean b) { // only potentially initialized\n" + 
+		"	^^^^^^^^^^^^^\n" + 
+		"The @NonNull field o may not have been initialized\n" + 
+		"----------\n");
+}
+
+// a non-null field is initialized to null
+public void test_nonnull_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = null;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull Object o = null;\n" + 
+		"	                    ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is assigned to null
+public void test_nonnull_field_4() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    void breakIt1() {\n" +
+			"         o = null;\n" +
+			"    }\n" +
+			"    void breakIt2() {\n" +
+			"         this.o = null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	this.o = null;\n" + 
+		"	         ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is checked for null
+public void test_nonnull_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         return o == null;\n" +
+			"    }\n" +
+			"    boolean checkIt() {\n" +
+			"         return this.o != null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o == null;\n" + 
+		"	       ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o != null;\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is checked for null twice - method call inbetween
+public void test_nonnull_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         if (o != null)\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return this.o == null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (o != null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o == null;\n" + 
+		"	            ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - static field
+public void test_nonnull_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    static @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (Objects.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    @NonNull Object getIt2() {\n" +
+			"         if (null != Objects.o) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    String getIt3() {\n" +
+			"         return Objects.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (Objects.o != null) // redundant\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	if (null != Objects.o) // redundant\n" + 
+		"	                    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - instance field
+public void test_nonnull_field_8() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1(@NonNull Objects objs) {\n" +
+			"         if (objs.o == null) // always false\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return objs.o;\n" +
+			"    }\n" +
+			"    String getIt2(@NonNull Objects objs) {\n" +
+			"         return objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (objs.o == null) // always false\n" + 
+		"	         ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	System.out.print(\"not null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via an indirect field reference - instance field
+public void test_nonnull_field_9() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    Objects objs = new Objects();\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (this.objs.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         if (getObjs().o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         return this.objs.o;\n" +
+			"    }\n" +
+            "    Objects getObjs() { return this.objs; }\n" +
+			"    String getIt2() {\n" +
+			"         return this.objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	if (this.objs.o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	if (getObjs().o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - field reference
+public void test_nullable_field_1() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return this.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.o.toString();\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - single name reference
+public void test_nullable_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o.toString();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - qualified name reference
+public void test_nullable_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    @Nullable X other;\n" +
+			"    public String oString() {\n" +
+			"         return other.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	       ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	             ^\n" +
+		"Potential null pointer access: The field o is declared as @Nullable\n" +
+		"----------\n");
+}
+// access to a nullable field - dereference after check
+public void test_nullable_field_4() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         if (this.o != null)\n" +
+			"             return this.o.toString();\n" + // silent after check
+			"         return \"\";\n" +
+			"    }\n" +
+			"    public String oString2() {\n" +
+			"         String local = o.toString();\n" +
+			"         if (this.o != null) {\n" +
+			"             this.toString();\n" + // method call wipes null info
+			"             return this.o.toString(); // warn here\n" +
+			"         }\n" +
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	String local = o.toString();\n" + 
+		"	               ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	return this.o.toString(); // warn here\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+//access to a nullable field - intermediate component in a QNR
+public void test_nullable_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on z\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on z\n" + 
+		"	         ^\n" + 
+		"Potential null pointer access: The field z is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+//access to a nullable field - intermediate component in a QNR - inverse of test_nullable_field_5
+public void test_nullable_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @NonNull Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    Object dummy;\n" + // ensure different interal fieldId
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	           ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a double field reference
+public void test_nullable_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return this.y.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	              ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// illegal use of @Nullable for a field of primitive type
+public void test_nullable_field_8() {
+	runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    @Nullable int i;\n" +
+				"}\n"
+			},
+			null /*customOptions*/,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	@Nullable int i;\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"The nullness annotation @Nullable is not applicable for the primitive type int\n" + 
+			"----------\n");	
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index 46ec01e..42ab1e7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -9529,9 +9529,9 @@ public void test1023() {
 			"X.java",
 			"public class X {\n" +
 			"\n" +
-			"  void foo() {\n" +
+			"  void foo(Object that) {\n" +
 			"    Object o = new Object();\n" +
-			"    while (this != null) {\n" +
+			"    while (that != null) {\n" +
 			"      try {\n" +
 			"        o = null;\n" +
 			"        break;\n" +
@@ -9548,7 +9548,7 @@ public void test1023() {
 		"	    ^\n" +
 		"Null comparison always yields false: The variable o cannot be null at this location\n" +
 		"----------\n" +
-		"2. WARNING in X.java (at line 13)\n" + 
+		"2. WARNING in X.java (at line 13)\n" +
 		"	if (o == null) return;\n" + 
 		"	               ^^^^^^^\n" + 
 		"Dead code\n" + 
@@ -17940,4 +17940,130 @@ public void testBug247564n() {
 			""
 	);
 }
+// object/array allocation
+public void testExpressions01() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (new Object() == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"	 void goo() {\n" +
+			"		if (null != this.new I())\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    void hoo() {\n" +
+			"		if (null != new Object[3])\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    class I {}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (new Object() == null)\n" + 
+		"	    ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != this.new I())\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	if (null != new Object[3])\n" + 
+		"	            ^^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+// 'this' expressions (incl. qualif.)
+public void testExpressions02() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (this == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    class I {\n" +
+			"        void goo() {\n" +
+			"		     if (null != X.this)\n" +
+			"                System.out.println(\"nonnull\");\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (this == null)\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 8)\n" + 
+		"	if (null != X.this)\n" + 
+		"	            ^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+// various non-null expressions: class-literal, string-literal, casted 'this'
+public void testExpressions03() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (X.class == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    void goo() {\n" +
+			"        if (null != \"STRING\")\n" +
+			"            System.out.println(\"nonnull\");\n" +
+			"        if (null == (Object)this)\n" +
+			"            System.out.println(\"I'm null\");\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (X.class == null)\n" + 
+		"	    ^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != \"STRING\")\n" + 
+		"	            ^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 9)\n" + 
+		"	if (null == (Object)this)\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"5. WARNING in X.java (at line 10)\n" + 
+		"	System.out.println(\"I\'m null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n"
+	);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 8a0d434..5cd8df2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1307,6 +1307,14 @@ void setSourceStart(int sourceStart);
 	int NullFieldInstanceofYieldsFalse = Internal + FieldRelated + 677;
 	
 	/**
+	 * Null analysis for other kinds of expressions, syntactically nonnull
+	 */
+	/** @since 3.8 */
+	int NonNullExpressionComparisonYieldsFalse = Internal + 685;
+	/** @since 3.8 */
+	int RedundantNullCheckOnNonNullExpression = Internal + 686;
+
+	/**
 	 * Corrupted binaries
 	 */
 	/** @since 3.1 */
@@ -1477,8 +1485,7 @@ void setSourceStart(int sourceStart);
 	int ParameterLackingNullableAnnotation = MethodRelated + 918;
 	/** @since 3.8 */
 	int PotentialNullMessageSendReference = Internal + 919;
-	/** @since 3.8 */
-	int RedundantNullCheckOnNonNullMessageSend = Internal + 920;
+	// what was at 920 has been moved down
 	/** @since 3.8 */
 	int CannotImplementIncompatibleNullness = Internal + 921;
 	/** @since 3.8 */
@@ -1486,6 +1493,8 @@ void setSourceStart(int sourceStart);
 	/** @since 3.8 */
 	int IllegalAnnotationForBaseType = TypeRelated + 923;
 	/** @since 3.8 */
+	int NullableFieldReference = FieldRelated + 924;
+	/** @since 3.8 */
 	int RedundantNullDefaultAnnotation = Internal + 925;
 	/** @since 3.8 */
 	int RedundantNullDefaultAnnotationPackage = Internal + 926;
@@ -1495,6 +1504,17 @@ void setSourceStart(int sourceStart);
 	int RedundantNullDefaultAnnotationMethod = Internal + 928;
 	/** @since 3.8 */
 	int ContradictoryNullAnnotations = Internal + 929;
+	/** @since 3.8 */
+	int UninitializedNonNullField = FieldRelated + 930;
+	/** @since 3.8 */
+	int RedundantNullCheckOnNonNullMessageSend = Internal + 931;
+	/** @since 3.8 */
+	int NonNullMessageSendComparisonYieldsFalse = Internal + 932;
+	/** @since 3.8 */
+	int RedundantNullCheckOnNonNullSpecdField = Internal + 933;
+	/** @since 3.8 */
+	int NonNullSpecdFieldComparisonYieldsFalse = Internal + 934;
+
 
 	/**
 	 * External problems -- These are problems defined by other plugins
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index fd64fd9..c18a6af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -242,6 +242,10 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
+public int nullStatus(FlowInfo flowInfo) {
+	return FlowInfo.NON_NULL;
+}
+
 public StringBuffer printExpression(int indent, StringBuffer output) {
 	if (this.type != null) { // type null for enum constant initializations
 		output.append("new "); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index e638dc6..059745c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -78,6 +78,9 @@ public class ArrayAllocationExpression extends Expression {
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 
+	public int nullStatus(FlowInfo flowInfo) {
+		return FlowInfo.NON_NULL;
+	}
 
 	public StringBuffer printExpression(int indent, StringBuffer output) {
 		output.append("new "); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index afe4153..355b66a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -110,6 +110,10 @@ public class ArrayInitializer extends Expression {
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 
+	public int nullStatus(FlowInfo flowInfo) {
+		return FlowInfo.NON_NULL;
+	}
+
 	public StringBuffer printExpression(int indent, StringBuffer output) {
 
 		output.append('{');
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java
index 12b39cb..53c9ba2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java
@@ -67,6 +67,10 @@ public class ClassLiteralAccess extends Expression {
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 
+	public int nullStatus(FlowInfo flowInfo) {
+		return FlowInfo.NON_NULL;
+	}
+
 	public StringBuffer printExpression(int indent, StringBuffer output) {
 
 		return this.type.print(0, output).append(".class"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 9b4cf8a..d5a8bd8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -157,19 +157,26 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=235781
 		// flowInfo.setReachMode(initialReachMode);
 
-		// check missing blank final field initializations
+		// check missing blank final field initializations (plus @NonNull)
 		if ((this.constructorCall != null)
 			&& (this.constructorCall.accessMode != ExplicitConstructorCall.This)) {
 			flowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);
 			FieldBinding[] fields = this.binding.declaringClass.fields();
 			for (int i = 0, count = fields.length; i < count; i++) {
-				FieldBinding field;
-				if ((!(field = fields[i]).isStatic())
-					&& field.isFinal()
-					&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {
-					this.scope.problemReporter().uninitializedBlankFinalField(
-						field,
-						((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);
+				FieldBinding field = fields[i];
+				if (!field.isStatic()) {
+					if (field.isFinal()
+							&& (!flowInfo.isDefinitelyAssigned(field))) {
+						this.scope.problemReporter().uninitializedBlankFinalField(
+								field,
+								((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);
+					} else if (field.isNonNull()) {
+						if (!flowInfo.isDefinitelyAssigned(field)) {
+							this.scope.problemReporter().uninitializedNonNullField(
+									field,
+									((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);						
+						}
+					}
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 6b55b1b..45b8560 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -26,26 +26,40 @@ public class EqualExpression extends BinaryExpression {
 	private void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {
 		int rightStatus = this.right.nullStatus(flowInfo);
 		int leftStatus = this.left.nullStatus(flowInfo);
-		// check if either is a method annotated @NonNull and compared to null:
+
+		boolean leftNonNullChecked = false;
+		boolean rightNonNullChecked = false;
+
+		// check if either is a non-local expression known to be nonnull and compared to null, candidates are
+		// - method/field annotated @NonNull
+		// - allocation expression, some literals, this reference (see inside expressionNonNullComparison(..))
+		boolean checkForNull = ((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL;
 		if (leftStatus == FlowInfo.NON_NULL && rightStatus == FlowInfo.NULL) {
-			if (this.left instanceof MessageSend) { 
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);
-			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
+			leftNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.left, checkForNull);
 		} else if (leftStatus == FlowInfo.NULL && rightStatus == FlowInfo.NON_NULL) {
-			if (this.right instanceof MessageSend) {
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.right).binding, this.right);
+			rightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkForNull);
+		}
+		
+		if (!leftNonNullChecked) {
+			VariableBinding var = this.left.variableBinding(scope);
+			if (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {
+				checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, rightStatus, this.left);
 			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
 		}
-
-		VariableBinding var = this.left.variableBinding(scope);
-		if (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, rightStatus, this.left);
+		if (!rightNonNullChecked) {
+			VariableBinding var = this.right.variableBinding(scope);
+			if (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {
+				checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, leftStatus, this.right);
+			}
 		}
-		var = this.right.variableBinding(scope);
-		if (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, leftStatus, this.right);
+
+		if (leftNonNullChecked || rightNonNullChecked) {
+			// above checks have not propagated unrechable into the corresponding branch, do it now:
+			if (checkForNull) {
+				initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			} else {
+				initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			}
 		}
 	}
 	private void checkVariableComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse, VariableBinding var, int nullStatus, Expression reference) {
@@ -54,13 +68,17 @@ public class EqualExpression extends BinaryExpression {
 				if (((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL) {
 					flowContext.recordUsingNullReference(scope, var, reference,
 							FlowContext.CAN_ONLY_NULL_NON_NULL | FlowContext.IN_COMPARISON_NULL, flowInfo);
-					initsWhenTrue.markAsComparedEqualToNull(var); // from thereon it is set
-					initsWhenFalse.markAsComparedEqualToNonNull(var); // from thereon it is set
+					if ((var.tagBits & TagBits.AnnotationNonNull) == 0) { // never drop information from @NonNull annotation
+						initsWhenTrue.markAsComparedEqualToNull(var); // from thereon it is set
+						initsWhenFalse.markAsComparedEqualToNonNull(var); // from thereon it is set
+					}
 				} else {
 					flowContext.recordUsingNullReference(scope, var, reference,
 							FlowContext.CAN_ONLY_NULL_NON_NULL | FlowContext.IN_COMPARISON_NON_NULL, flowInfo);
-					initsWhenTrue.markAsComparedEqualToNonNull(var); // from thereon it is set
-					initsWhenFalse.markAsComparedEqualToNull(var); // from thereon it is set
+					if ((var.tagBits & TagBits.AnnotationNonNull) == 0) { // never drop information from @NonNull annotation
+						initsWhenTrue.markAsComparedEqualToNonNull(var); // from thereon it is set
+						initsWhenFalse.markAsComparedEqualToNull(var); // from thereon it is set
+					}
 				}
 				if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
 					flowInfo.markedAsNullOrNonNullInAssertExpression(var);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 665e6fc..2fc5316 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -524,8 +524,9 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
  * @param scope the scope of the analysis
  * @param flowContext the current flow context
  * @param flowInfo the upstream flow info; caveat: may get modified
+ * @return could this expression be checked by the current implementation?
  */
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	VariableBinding var = variableBinding(scope);
 	if (var != null &&
 			(var.type.tagBits & TagBits.IsBaseType) == 0) {
@@ -544,7 +545,9 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 				flowContext.initsOnFinally.markedAsNullOrNonNullInAssertExpression(var);
 			}
 		}
+		return true;
 	}
+	return false; // not checked
 }
 
 public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {
@@ -871,12 +874,13 @@ public int nullStatus(FlowInfo flowInfo) {
 
 	if (/* (this.bits & IsNonNull) != 0 || */
 		this.constant != null && this.constant != Constant.NotAConstant)
-	return FlowInfo.NON_NULL; // constant expression cannot be null
+		return FlowInfo.NON_NULL; // constant expression cannot be null
 
 	VariableBinding var = variableBinding(null);
-	if (var != null)
+	if (var != null) {
 		return flowInfo.nullStatus(var);
-	return FlowInfo.NON_NULL;
+	}
+	return FlowInfo.UNKNOWN;
 }
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index a31b905..030678a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -50,7 +50,10 @@ public FieldDeclaration(	char[] name, int sourceStart, int sourceEnd) {
 	this.sourceEnd = sourceEnd;
 }
 
-public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo) {
+public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo) {
+	// fieldResetInfo: in this info we collect all information required for UnconditionalFlowInfo.resetNullInfoForFields:
+	// - which fields should never reset their null status? (constants and @NonNull)
+	// - for other fields: to what status should it be reset at each MessageSend? (unknown or pot.null)
 	if (this.binding != null && !this.binding.isUsed() && this.binding.isOrEnclosedByPrivateType()) {
 		if (!initializationScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {
 			initializationScope.problemReporter().unusedPrivateField(this);
@@ -68,20 +71,53 @@ public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowCon
 			this);
 	}
 
+	boolean isConstant = this.binding.isFinal() && this.binding.isStatic();
+	boolean includeFieldsInNullAnalysis = initializationScope.compilerOptions().includeFieldsInNullAnalysis;
 	if (this.initialization != null) {
 		flowInfo =
 			this.initialization
 				.analyseCode(initializationScope, flowContext, flowInfo)
 				.unconditionalInits();
 		flowInfo.markAsDefinitelyAssigned(this.binding);
-		if (this.binding.isFinal() && this.binding.isStatic()) {
+		if (isConstant && includeFieldsInNullAnalysis) {
 			int nullStatus = this.initialization.nullStatus(flowInfo);
 			// static final field being initialized. Record its null status for future reference
 			// since the flowInfo from an initialization wont be available in a method
 			flowInfo.markNullStatus(this.binding, nullStatus);
-//			this.binding.setNullStatusForStaticFinalField(nullStatus);
 		}
 	}
+	if (isConstant && includeFieldsInNullAnalysis) {
+		// never reset null status for constants
+		fieldResetInfo.updateConstantFieldsMask(this.binding);
+	}
+	long tagBits = this.binding.tagBits;
+	if ((tagBits & TagBits.AnnotationNonNull) != 0) {
+		if (this.initialization != null) {
+			int nullStatus = this.initialization.nullStatus(flowInfo);
+			// check against annotation @NonNull:
+			if (nullStatus != FlowInfo.NON_NULL) {
+				char[][] annotationName = initializationScope.environment().getNonNullAnnotationName();
+				initializationScope.problemReporter().nullityMismatch(this.initialization, this.binding.type, nullStatus, annotationName);
+			}
+		}
+		// record nonnull for use by methods:
+		declaringClassFlowInfo.markAsDefinitelyNonNull(this.binding);
+
+		// tell resetNullInfoForFields not to update this field's status
+		fieldResetInfo.updateConstantFieldsMask(this.binding);
+	} else if ((tagBits & TagBits.AnnotationNullable) != 0) {
+		// record pot.null for use by methods:
+		declaringClassFlowInfo.resetNullInfo(this.binding);
+		declaringClassFlowInfo.markPotentiallyNullBit(this.binding);
+
+		// tell resetNullInfoForFields to reset this field to pot.null:
+		// (note that this info is ineffective if the field is also constant)
+		fieldResetInfo.resetNullInfo(this.binding);
+		fieldResetInfo.markPotentiallyNullBit(this.binding);
+	} else if (!isConstant && includeFieldsInNullAnalysis) {
+		// tell resetNullInfoForFields to reset this field to def.unknown:
+		fieldResetInfo.markAsDefinitelyUnknown(this.binding);
+	}
 	return flowInfo;
 }
 
@@ -197,7 +233,8 @@ public void resolve(MethodScope initializationScope) {
 		initializationScope.initializedField = this.binding;
 		initializationScope.lastVisibleFieldID = this.binding.id;
 
-		resolveAnnotations(initializationScope, this.annotations, this.binding);
+// 	already invoked from SourceTypeBinding.resolveTypeFor(..)
+//		resolveAnnotations(initializationScope, this.annotations, this.binding);
 		// check @Deprecated annotation presence
 		if ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0
 				&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index e8c6fab..85df99b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -110,6 +110,8 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			// assigning a final field outside an initializer or constructor or wrong reference
 			currentScope.problemReporter().cannotAssignToFinalField(this.binding, this);
 		}
+	} else if (this.receiver.isThis() && !this.binding.isStatic() && this.binding.isNonNull()) {
+		flowInfo.markAsDefinitelyAssigned(this.binding);
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 	if (!this.binding.isStatic()) {
@@ -152,6 +154,16 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	// first try check based on flowInfo (most accurate):
+	if (super.checkNPE(scope, flowContext, flowInfo)) return true;
+	if (!this.receiver.isThis()) {
+		// on a non-this field ref @Nullable is all we could possibly report
+		return checkNullableDereference(scope, this.binding, this.nameSourcePosition);
+	}
+	return false; // not checked
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -438,6 +450,10 @@ public boolean isTypeAccess() {
 	return this.receiver != null && this.receiver.isTypeReference();
 }
 
+public FieldBinding lastFieldBinding() {
+	return this.binding;
+}
+
 /*
  * No need to emulate access to protected fields since not implicitly accessed
  */
@@ -483,10 +499,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -673,6 +685,12 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 }
 
 public VariableBinding variableBinding(Scope scope) {
+	if (this.binding != null
+			&& ((this.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)
+			&& this.receiver.isThis()) {
+		// for fields of the current type most specific null info is in the flowInfo
+		return this.binding;
+	}
 	if (scope != null) {
 		CompilerOptions options = scope.compilerOptions();
 		if(!options.includeFieldsInNullAnalysis) return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
index 6d544aa..03bc26b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -36,7 +36,9 @@ public class Initializer extends FieldDeclaration {
 	public FlowInfo analyseCode(
 		MethodScope currentScope,
 		FlowContext flowContext,
-		FlowInfo flowInfo) {
+		FlowInfo flowInfo,
+		FlowInfo declaringClassFlowInfo,
+		FlowInfo fieldResetInfo) {
 
 		if (this.block != null) {
 			return this.block.analyseCode(currentScope, flowContext, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Literal.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Literal.java
index 2157be9..9e21fb4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Literal.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Literal.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -40,6 +40,10 @@ public abstract class Literal extends Expression {
 		return output.append(source());
 	 }
 
+	public int nullStatus(FlowInfo flowInfo) {
+		return FlowInfo.NON_NULL;
+	}
+
 	public TypeBinding resolveType(BlockScope scope) {
 		// compute the real value, which must range its type's range
 		this.resolvedType = literalType(scope);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 6469df3..af19c3e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -119,14 +119,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	// a method call can result in changed values for fields, 
 	// so wipe out null info for fields collected till now.
 	CompilerOptions options = currentScope.compilerOptions();
-	if(options.includeFieldsInNullAnalysis)
-		flowInfo.resetNullInfoForFields();
+	if(options.includeFieldsInNullAnalysis || options.isAnnotationBasedNullAnalysisEnabled)
+		flowInfo.resetNullInfoForFields(currentScope.classScope().fieldResetFlowInfo);
 	return flowInfo;
 }
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	super.checkNPE(scope, flowContext, flowInfo);
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	if ((nullStatus(flowInfo) & FlowInfo.POTENTIALLY_NULL) != 0)
 		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+	return true; // done all possible checking
 }
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
index 72bdba0..06732ca 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,12 +29,23 @@ public NameReference() {
 	this.bits |= Binding.TYPE | Binding.VARIABLE; // restrictiveFlag
 }
 
+/** 
+ * Use this method only when sure that the current reference is <strong>not</strong>
+ * a chain of several fields (QualifiedNameReference with more than one field).
+ * Otherwise use {@link #lastFieldBinding()}.
+ */
 public FieldBinding fieldBinding() {
 	//this method should be sent ONLY after a check against isFieldReference()
 	//check its use doing senders.........
 	return (FieldBinding) this.binding ;
 }
 
+public FieldBinding lastFieldBinding() {
+	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD)
+		return fieldBinding(); // most subclasses only refer to one field anyway
+	return null;
+}
+
 public boolean isSuperAccess() {
 	return false;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 95bb17b..1af0f0b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -101,7 +101,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
 			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
+				checkInternalNPE(currentScope, flowContext, flowInfo, true);
 			}
 	}
 
@@ -162,6 +162,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			}
 		}
 	}
+	// note: not covering def.assign for @NonNull: QNR cannot provable refer to a variable of the current object
 	manageSyntheticAccessIfNecessary(currentScope, lastFieldBinding, -1 /*write-access*/, flowInfo);
 
 	return flowInfo;
@@ -207,9 +208,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			} else if (localBinding.useFlag == LocalVariableBinding.UNUSED) {
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
-			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
-			}
+	}
+	if (needValue) {
+		checkInternalNPE(currentScope, flowContext, flowInfo, true);
 	}
 	if (needValue) {
 		manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
@@ -226,9 +227,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
-	// cannot override localVariableBinding because this would project o.m onto o when
-	// analyzing assignments
+/* check if any dot in this QNR may trigger an NPE. */
+private void checkInternalNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
 	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.LOCAL) {
 		LocalVariableBinding local = (LocalVariableBinding) this.binding;
 		if (local != null &&
@@ -250,7 +250,38 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 				}
 			}
 		}
+	} else if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {
+		// look for annotated fields, they do not depend on flow context -> check immediately:
+		checkNullableDereference(scope, (FieldBinding) this.binding, this.sourcePositions[0]);
+	}
+	if (this.otherBindings != null) {
+		// look for annotated fields, they do not depend on flow context -> check immediately:
+		int length = this.otherBindings.length - 1; // don't check the last binding
+		for (int i = 0; i < length; i++) {
+			checkNullableDereference(scope, this.otherBindings[i], this.sourcePositions[i+1]);
+		}
+	}
+}
+
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (super.checkNPE(scope, flowContext, flowInfo)) {
+		return true;
+	}
+	FieldBinding fieldBinding = null;
+	long position = 0L;
+	if (this.otherBindings == null) {
+		if ((this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+			fieldBinding = (FieldBinding) this.binding;
+			position = this.sourcePositions[0];
+		}
+	} else {
+		fieldBinding = this.otherBindings[this.otherBindings.length - 1];
+		position = this.sourcePositions[this.sourcePositions.length - 1];
+	}
+	if (fieldBinding != null) {
+		return checkNullableDereference(scope, fieldBinding, position);
 	}
+	return false;
 }
 
 /**
@@ -785,6 +816,15 @@ public TypeBinding getOtherFieldBindings(BlockScope scope) {
 			: type;
 }
 
+public FieldBinding lastFieldBinding() {
+	if (this.otherBindings != null) {
+		return this.otherBindings[this.otherBindings.length - 1];		
+	} else if (this.binding != null && (this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+		return (FieldBinding) this.binding;
+	}
+	return null;
+}
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -839,10 +879,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBindi
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -1096,6 +1132,6 @@ public VariableBinding variableBinding(Scope scope) {
 			}
 		}
 	}
-	return super.variableBinding(scope);
+	return null;
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index ef9e8da..3cba337 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -22,6 +22,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
@@ -38,6 +39,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+protected boolean checkNullableDereference(Scope scope, FieldBinding field, long sourcePosition) {
+	if ((field.tagBits & TagBits.AnnotationNullable) != 0) {
+		scope.problemReporter().nullableFieldDereference(field, sourcePosition);
+		return true;
+	}
+	return false;
+}
+
 public FieldBinding fieldBinding() {
 	//this method should be sent one FIELD-tagged references
 	//  (ref.bits & BindingIds.FIELD != 0)()
@@ -92,6 +101,20 @@ public abstract void generateCompoundAssignment(BlockScope currentScope, CodeStr
 
 public abstract void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired);
 
+public FieldBinding lastFieldBinding() {
+	// override to answer the field designated by the entire reference
+	// (as opposed to fieldBinding() which answers the first field in a QNR)
+	return null;
+}
+
+public int nullStatus(FlowInfo flowInfo) {
+	FieldBinding fieldBinding = lastFieldBinding();
+	if (fieldBinding != null && fieldBinding.isNonNull()) {
+		return FlowInfo.NON_NULL;
+	}
+	return super.nullStatus(flowInfo);
+}
+
 /* report if a private field is only read from a 'special operator',
  * i.e., in a postIncrement expression or a compound assignment,
  * where the information is never flowing out off the field. */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index f0891de..6485475 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -118,6 +118,8 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				} else {
 					currentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);
 				}
+			} else if (!fieldBinding.isStatic() && fieldBinding.isNonNull()) {
+				flowInfo.markAsDefinitelyAssigned(fieldBinding);
 			}
 			if (!fieldBinding.isStatic()) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
@@ -812,14 +814,21 @@ public VariableBinding variableBinding(Scope scope) {
 			// reading a field
 			if (scope != null) {
 				CompilerOptions options = scope.compilerOptions();
-				if(!options.includeFieldsInNullAnalysis) return null;
-			}			
+				FieldBinding fieldBinding = (FieldBinding) this.binding;
+				if(options.includeFieldsInNullAnalysis) {
+					return fieldBinding;
+				}
+				if (fieldBinding != null && fieldBinding.isNullable()) {
+					return fieldBinding;
+				}
+			}
 			//$FALL-THROUGH$
 		case Binding.LOCAL : // reading a local variable
 			return (VariableBinding) this.binding;
 	}
 	return null;
 }
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -866,20 +875,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	if (this.constant != null && this.constant != Constant.NotAConstant) {
-		return FlowInfo.NON_NULL; // constant expression cannot be null
-	}
-	switch (this.bits & ASTNode.RestrictiveFlagMASK) {
-		case Binding.FIELD : // reading a field
-		case Binding.LOCAL : // reading a local variable
-			VariableBinding variable = (VariableBinding) this.binding;
-			if (variable != null)
-				return flowInfo.nullStatus(variable);
-	}
-	return FlowInfo.NON_NULL; // never get there
-}
-
 	/**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#postConversionType(Scope)
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 66c17f5..1964ce2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -103,7 +103,7 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 			&& (var.tagBits & TagBits.AnnotationNonNull) != 0
 			&& nullStatus != FlowInfo.NON_NULL) {
 		flowContext.recordNullityMismatch(currentScope, expression, nullStatus, var.type);
-		nullStatus=FlowInfo.NON_NULL;
+		nullStatus=FlowInfo.NON_NULL; // @NonNull variable is still considered nonnull even after erroneous assignment
 	}
 	return nullStatus;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index a3b569e..e2ea573 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -637,6 +637,14 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 	InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, flowInfo, flowContext, this.staticInitializerScope);
 	FlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();
 	FlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();
+
+	// start assembling info for reseting field info by UnconditionalFlowInfo.resetNullInfoForFields():
+	ClassScope enclosingClassScope = this.scope.enclosingClassScope();
+	UnconditionalFlowInfo fieldResetInfo = (enclosingClassScope != null)
+			? (UnconditionalFlowInfo) enclosingClassScope.fieldResetFlowInfo.copy()
+			: FlowInfo.initial(((UnconditionalFlowInfo)staticFieldInfo).maxFieldCount);
+	this.scope.fieldResetFlowInfo = fieldResetInfo;
+
 	if (this.fields != null) {
 		for (int i = 0, count = this.fields.length; i < count; i++) {
 			FieldDeclaration field = this.fields[i];
@@ -649,12 +657,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 				} else {*/
 				staticInitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them
 				/*}*/
-				staticFieldInfo = field.analyseCode(this.staticInitializerScope, staticInitializerContext, staticFieldInfo);
-				if (field.binding != null && this.scope.compilerOptions().includeFieldsInNullAnalysis
-						&& ((field.binding.modifiers & ClassFileConstants.AccFinal) != 0)) {
-					// we won't reset null Info for constant fields
-					staticFieldInfo.updateConstantFieldsMask(field.binding);
-				}
+				staticFieldInfo = field.analyseCode(this.staticInitializerScope, staticInitializerContext, staticFieldInfo, flowInfo, fieldResetInfo);
 				// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
 				// branch, since the previous initializer already got the blame.
 				if (staticFieldInfo == FlowInfo.DEAD_END) {
@@ -670,7 +673,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 				} else {*/
 					initializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them
 				/*}*/
-				nonStaticFieldInfo = field.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo);
+				nonStaticFieldInfo = field.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo, flowInfo, fieldResetInfo);
 				// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
 				// branch, since the previous initializer already got the blame.
 				if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
@@ -695,10 +698,10 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 		FlowInfo constructorInfo;
 		if (this.scope.compilerOptions().includeFieldsInNullAnalysis) {
 			flowInfo.addNullInfoFrom(staticFieldUnconditionalInfo.discardNonFieldInitializations());
-			flowInfo.addConstantFieldsMask(staticFieldUnconditionalInfo);	// prevent resetting null info for constant fields inside methods
-			flowInfo.resetNullInfoForFields();	// only preserve null info for constant fields
+			flowInfo.addConstantFieldsMask(fieldResetInfo);	// prevent resetting null info for constant fields inside methods
+			flowInfo.resetNullInfoForFields(fieldResetInfo);	// only preserve null info for constant fields
 			constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(flowInfo);
-			constructorInfo.addConstantFieldsMask(staticFieldUnconditionalInfo); // prevent resetting null info for constant fields inside c'tor too
+			constructorInfo.addConstantFieldsMask(fieldResetInfo); // prevent resetting null info for constant fields inside c'tor too
 		} else {
 			constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
index 4689bf8..4ded203 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
@@ -155,9 +155,9 @@ public void resetNullInfo(VariableBinding var) {
 	this.initsWhenFalse.resetNullInfo(var);
 }
 
-public void resetNullInfoForFields() {
-	this.initsWhenTrue.resetNullInfoForFields();
-	this.initsWhenFalse.resetNullInfoForFields();
+public void resetNullInfoForFields(UnconditionalFlowInfo fieldResetInfo) {
+	this.initsWhenTrue.resetNullInfoForFields(fieldResetInfo);
+	this.initsWhenFalse.resetNullInfoForFields(fieldResetInfo);
 }
 
 public void updateConstantFieldsMask(FieldBinding field) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
index 61e990f..c7e7232 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
@@ -279,10 +279,10 @@ abstract public void markAsComparedEqualToNull(VariableBinding binding);
 	 *  Note that each fields status after the reset will become def. unknown i.e. 1001
 	 *  Also this method does not reset constant fields
 	 */
-	abstract public void resetNullInfoForFields();
+	abstract public void resetNullInfoForFields(UnconditionalFlowInfo fieldResetInfo);
 	
 	/**
-	 * exclude a new field from being reset by {@link #resetNullInfoForFields()}
+	 * exclude a new field from being reset by {@link #resetNullInfoForFields(UnconditionalFlowInfo)}
 	 */
 	abstract public void updateConstantFieldsMask(FieldBinding field);
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
index ac028b0..0d7bfee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
@@ -1306,7 +1306,9 @@ public void markAsDefinitelyNonNull(VariableBinding var) {
     	int position;
     	// position is zero-based
     	if (var instanceof FieldBinding) {
-			if ((var.modifiers & AccConstant) == AccConstant) {
+			if ((var.modifiers & AccConstant) == AccConstant
+				|| (var.tagBits & TagBits.AnnotationNonNull) != 0) {
+				// record precise info for constant and @NonNull fields
 				position = var.getAnalysisId(this.maxFieldCount);
 			} else {
 	    		// non-final fields may be modified in separate threads and we cannot be sure about their
@@ -1518,22 +1520,23 @@ public void resetNullInfo(VariableBinding var) {
 	}
 }
 
-public void resetNullInfoForFields() {
+public void resetNullInfoForFields(UnconditionalFlowInfo fieldResetFlow) {
 	if (this != DEAD_END) {
 		long mask = this.maxFieldCount < BitCacheSize ? (-1L << this.maxFieldCount) : 0L; 
-		mask |= this.constantFieldsMask;
+		mask |= fieldResetFlow.constantFieldsMask;
 		// first reset normal bits:
-		this.nullBit1 |= ~mask;
-		this.nullBit2 &= mask;
-		this.nullBit3 &= mask;
-		this.nullBit4 |= ~mask;
+		this.nullBit1 = (this.nullBit1 & mask) | fieldResetFlow.nullBit1;
+		this.nullBit2 = (this.nullBit2 & mask) | fieldResetFlow.nullBit2;
+		this.nullBit3 = (this.nullBit3 & mask) | fieldResetFlow.nullBit3;
+		this.nullBit4 = (this.nullBit4 & mask) | fieldResetFlow.nullBit4;
+
 		if (this.maxFieldCount >= BitCacheSize && this.extra != null) {
 			// use extra vector
 			int localsStartIndex = this.maxFieldCount/BitCacheSize - 1;
 			int localsStartOffset = this.maxFieldCount % BitCacheSize;
-			if (this.extraConstantFieldMask != null){
-				for (int vectorIndex = 0; vectorIndex < this.extra[2].length; vectorIndex++) {
-				    if (vectorIndex >= this.extraConstantFieldMask.length) {
+			for (int vectorIndex = 0; vectorIndex < this.extra[2].length; vectorIndex++) {
+				if (fieldResetFlow.extraConstantFieldMask != null) {
+				    if (vectorIndex >= fieldResetFlow.extraConstantFieldMask.length) {
 				    	// no constant fields after this, just mask all fields
 				    	if (vectorIndex == localsStartIndex) {
 				    		// some locals, some fields at this vectorIndex
@@ -1545,35 +1548,37 @@ public void resetNullInfoForFields() {
 				    } else {
 				    	if (vectorIndex == localsStartIndex) {
 				    		// some locals, some fields at this vectorIndex
-				    		mask = ((-1 << localsStartOffset) | this.extraConstantFieldMask[vectorIndex]);
+				    		mask = ((-1 << localsStartOffset) | fieldResetFlow.extraConstantFieldMask[vectorIndex]);
 				    	} else {
 				    		// all fields here
-				    		mask = 0L | this.extraConstantFieldMask[vectorIndex];
+				    		mask = 0L | fieldResetFlow.extraConstantFieldMask[vectorIndex];
 				    	}
 				    	
 				    }
-					this.extra[2][vectorIndex]
-					    |= ~mask;
-					this.extra[3][vectorIndex] &= mask;
-					this.extra[4][vectorIndex] &= mask;
-					this.extra[5][vectorIndex] |= ~mask;
-				}
-			} else {
-				// no constant fields
-				for (int vectorIndex = 0; vectorIndex < this.extra[2].length; vectorIndex++) {
-				    if (vectorIndex == localsStartIndex) {
-				    	// some locals, some fields at this vectorIndex
-				    	mask = -1L << localsStartOffset;
-				    } else {
-				    	// all fields here
-				    	mask = 0L;
-				    }
-					this.extra[2][vectorIndex]
-					    |= ~mask;
-					this.extra[3][vectorIndex] &= mask;
-					this.extra[4][vectorIndex] &= mask;
-					this.extra[5][vectorIndex] |= ~mask;
+				} else {
+					if (vectorIndex == localsStartIndex) {
+						// some locals, some fields at this vectorIndex
+						mask = -1L << localsStartOffset;
+					} else {
+						// all fields here
+						mask = 0L;
+					}
 				}
+			    long reset1, reset2, reset3, reset4;
+			    if (fieldResetFlow.extra != null && fieldResetFlow.extra[2].length > vectorIndex) {
+			    	reset1 = fieldResetFlow.extra[2][vectorIndex];
+			    	reset2 = fieldResetFlow.extra[3][vectorIndex];
+			    	reset3 = fieldResetFlow.extra[4][vectorIndex];
+			    	reset4 = fieldResetFlow.extra[5][vectorIndex];
+			    } else {
+			    	// no status recorded in fieldResetFlow, use def unknown instead:
+			    	reset1 = reset4 = 1;
+			    	reset2 = reset3 = 0;
+			    }
+				this.extra[2][vectorIndex] = (this.extra[2][vectorIndex] & mask) | reset1;
+				this.extra[3][vectorIndex] = (this.extra[3][vectorIndex] & mask) | reset2;
+				this.extra[4][vectorIndex] = (this.extra[4][vectorIndex] & mask) | reset3;
+				this.extra[5][vectorIndex] = (this.extra[5][vectorIndex] & mask) | reset4;
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 802192b..482297d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -450,6 +450,12 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 					this.fields[i].setAnnotations(createAnnotations(binaryField.getAnnotations(), this.environment, missingTypeNames));
 				}
 			}
+			if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				for (int i = 0; i <size; i++) {
+					IBinaryField binaryField = iFields[i];
+					scanFieldForNullAnnotation(binaryField, this.fields[i]);
+				}
+			}
 		}
 	}
 }
@@ -1160,6 +1166,33 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	}
 	return this.storedAnnotations;
 }
+
+void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding) {
+	// global option is checked by caller
+	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
+	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
+	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+		return; // not well-configured to use null annotations
+
+	IBinaryAnnotation[] annotations = field.getAnnotations();
+	if (annotations != null) {
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != Util.C_RESOLVED)
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNonNull;
+				break;
+			}
+			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNullable;
+				break;
+			}
+		}
+	}	
+}
+
 void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
 	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
 		return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 4d5f38e..e9c0db2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -31,6 +31,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObject;
@@ -40,6 +41,8 @@ public class ClassScope extends Scope {
 	public TypeDeclaration referenceContext;
 	public TypeReference superTypeReference;
 	java.util.ArrayList deferredBoundChecks;
+	public UnconditionalFlowInfo fieldResetFlowInfo; // during analyse for passing into UnconditionalFlowInfo#resetNullInfoForFields()
+
 	public ClassScope(Scope parent, TypeDeclaration context) {
 		super(Scope.CLASS_SCOPE, parent);
 		this.referenceContext = context;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index 4c9aa8d..cd90d73 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -276,7 +276,7 @@ public long getAnnotationTagBits() {
 }
 
 public int getAnalysisId(int maxFieldCount) {
-	TypeBinding original = this.declaringClass.original();
+	TypeBinding original = (this.declaringClass != null) ? this.declaringClass.original() : null; // Array.length has no declaringClass
 	if (original instanceof SourceTypeBinding)
 		return ((SourceTypeBinding)original).fieldAnalysisOffset + this.id;
 	return this.id;
@@ -393,4 +393,20 @@ public FieldDeclaration sourceField() {
 	}
 	return null;
 }
+public void fillInDefaultNonNullness(TypeBinding annotationBinding, FieldDeclaration sourceField, Scope scope) {
+//	if (added)
+//		this.tagBits |= TagBits.HasParameterAnnotations;
+	if (   this.type != null
+		&& !this.type.isBaseType()
+		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+	{
+		this.tagBits |= TagBits.AnnotationNonNull;
+// FIXME
+//		if (sourceField != null)
+//			sourceField.addNullnessAnnotation((ReferenceBinding)annotationBinding);
+	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
+// FIXME
+//		scope.problemReporter().nullAnnotationIsRedundant(sourceField);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 4ee7aaa..1f38c1c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1115,6 +1115,18 @@ void initializeForStaticImports() {
 	this.scope.buildMethods();
 }
 
+private void initializeNullDefault() {
+	// ensure nullness defaults are initialized at all enclosing levels:
+	switch (this.nullnessDefaultInitialized) {
+	case 0:
+		getAnnotationTagBits(); // initialize
+		//$FALL-THROUGH$
+	case 1:
+		getPackage().isViewedAsDeprecated(); // initialize annotations
+		this.nullnessDefaultInitialized = 2;
+	}
+}
+
 /**
  * Returns true if a type is identical to another one,
  * or for generic types, true if compared to its raw type.
@@ -1432,6 +1444,19 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 				if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0) {
 					field.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
 				}
+
+				// apply null default:
+				LookupEnvironment environment = this.scope.environment();
+				TypeBinding defaultNullnessAnnotationBinding = null;
+				if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+					initializeNullDefault();
+					defaultNullnessAnnotationBinding = findDefaultNullness(this.scope, environment);
+					if (defaultNullnessAnnotationBinding != null && defaultNullnessAnnotationBinding.id == TypeIds.T_ConfiguredAnnotationNonNullByDefault) {
+						field.fillInDefaultNonNullness(defaultNullnessAnnotationBinding, fieldDecl, initializationScope);
+					}
+					// validate null annotation:
+					this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations);
+				}
 			} finally {
 			    initializationScope.initializedField = previousField;
 			}
@@ -1613,15 +1638,7 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 	return method;
 }
 private void createArgumentBindings(MethodBinding method) {
-	// ensure nullness defaults are initialized at all enclosing levels:
-	switch (this.nullnessDefaultInitialized) {
-	case 0:
-		getAnnotationTagBits(); // initialize
-		//$FALL-THROUGH$
-	case 1:
-		getPackage().isViewedAsDeprecated(); // initialize annotations
-		this.nullnessDefaultInitialized = 2;
-	}
+	initializeNullDefault();
 	AbstractMethodDeclaration methodDecl = method.sourceMethod();
 	if (methodDecl != null) {
 		if (method.parameters != Binding.NO_PARAMETERS)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
index 273f2af..f63f640 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -56,7 +56,17 @@ public abstract class VariableBinding extends Binding {
 	public final boolean isEffectivelyFinal() {
 		return (this.tagBits & TagBits.IsEffectivelyFinal) != 0;
 	}
-	
+
+	/** Answer true if null annotations are enabled and this field is specified @NonNull */
+	public boolean isNonNull() {
+		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
+	}
+
+	/** Answer true if null annotations are enabled and this field is specified @Nullable */
+	public boolean isNullable() {
+		return (this.tagBits & TagBits.AnnotationNullable) != 0;
+	}
+
 	public char[] readableName() {
 		return this.name;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 3c4014b..6bae58e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -39,6 +39,7 @@ import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
@@ -48,6 +49,7 @@ import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.BranchStatement;
 import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
 import org.eclipse.jdt.internal.compiler.ast.CastExpression;
+import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
@@ -68,6 +70,7 @@ import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
+import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
@@ -291,6 +294,7 @@ public static int getIrritant(int problemID) {
 
 		case IProblem.NullLocalVariableReference:
 		case IProblem.NullFieldReference:
+		case IProblem.NullableFieldReference:
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
@@ -310,7 +314,12 @@ public static int getIrritant(int problemID) {
 		case IProblem.RedundantNullCheckOnNullField:
 		case IProblem.NonNullFieldComparisonYieldsFalse:
 		case IProblem.NullFieldComparisonYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullExpression:
+		case IProblem.NonNullExpressionComparisonYieldsFalse:
 		case IProblem.RedundantNullCheckOnNonNullMessageSend:
+		case IProblem.NonNullMessageSendComparisonYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullSpecdField:
+		case IProblem.NonNullSpecdFieldComparisonYieldsFalse:
 			return CompilerOptions.RedundantNullCheck;
 
 		case IProblem.RequiredNonNullButProvidedNull:
@@ -320,6 +329,7 @@ public static int getIrritant(int problemID) {
 		case IProblem.ParameterLackingNonNullAnnotation:
 		case IProblem.ParameterLackingNullableAnnotation:
 		case IProblem.CannotImplementIncompatibleNullness:
+		case IProblem.UninitializedNonNullField:
 			return CompilerOptions.NullSpecViolation;
 
 		case IProblem.RequiredNonNullButProvidedPotentialNull:
@@ -5126,6 +5136,94 @@ public void variableNullComparedToNonNull(VariableBinding variable, ASTNode loca
 		nodeSourceEnd(variable, location));
 }
 
+/**
+ * @parm expr expression being compared for null or nonnull
+ * @param checkForNull true if checking for null, false if checking for nonnull 
+ */
+public boolean expressionNonNullComparison(Expression expr, boolean checkForNull) {
+	int problemId;
+	Binding binding;
+	String[] arguments;
+	int start, end;
+
+	Expression location = expr;
+	// unwrap uninteresting nodes:
+	while (true) {
+		if (expr instanceof Assignment)
+			return false; // don't report against the assignment, but the variable
+		else if (expr instanceof CastExpression)
+			expr = ((CastExpression) expr).expression;
+		else
+			break;
+	}
+	// check all those kinds of expressions that can possible answer NON_NULL from nullStatus():
+	if (expr instanceof MessageSend) {
+		problemId = checkForNull 
+				? IProblem.NonNullMessageSendComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullMessageSend;
+		MethodBinding method = ((MessageSend)expr).binding;
+		binding = method;
+		arguments = new String[] { new String(method.shortReadableName()) };
+		start = location.sourceStart;
+		end = location.sourceEnd;
+	} else if (expr instanceof Reference && !(expr instanceof ThisReference) && !(expr instanceof ArrayReference)) {
+		FieldBinding field = ((Reference)expr).lastFieldBinding();
+		if (field == null) {
+			return false;
+		}
+		if (field.isNonNull()) {
+			problemId = checkForNull
+					? IProblem.NonNullSpecdFieldComparisonYieldsFalse
+					: IProblem.RedundantNullCheckOnNonNullSpecdField;
+			char[][] nonNullName = this.options.nonNullAnnotationName;
+			arguments = new String[] { new String(field.name), 
+									   new String(nonNullName[nonNullName.length-1]) };
+		} else {
+			problemId = checkForNull
+					? IProblem.NonNullFieldComparisonYieldsFalse
+					: IProblem.RedundantNullCheckOnNonNullField;
+			arguments = new String[] { new String(field.name) };
+		}
+		binding = field;
+		start = nodeSourceStart(binding, location);
+		end = nodeSourceEnd(binding, location);
+	} else if (expr instanceof AllocationExpression 
+			|| expr instanceof ArrayAllocationExpression 
+			|| expr instanceof ArrayInitializer
+			|| expr instanceof ClassLiteralAccess
+			|| expr instanceof ThisReference) {
+		problemId = checkForNull 
+				? IProblem.NonNullExpressionComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullExpression;
+		start = location.sourceStart;
+		end = location.sourceEnd;
+		arguments = NoArgument;
+	} else if (expr instanceof Literal) {
+		if (expr instanceof NullLiteral) {
+			needImplementation(location); // reported as nonnull??
+			return false;
+		}
+		if (expr.resolvedType != null && expr.resolvedType.isBaseType()) {
+			// false alarm, auto(un)boxing is involved
+			return false;
+		}
+		problemId = checkForNull 
+				? IProblem.NonNullExpressionComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullExpression;
+		start = location.sourceStart;
+		end = location.sourceEnd;
+		arguments = NoArgument;
+	} else if (expr instanceof ConditionalExpression) {
+		needImplementation(location); // TODO
+		return false;
+	} else {
+		needImplementation(expr);
+		return false;
+	}
+	this.handle(problemId, arguments, arguments, start, end);
+	return true;
+}
+
 public void variableNullInstanceof(VariableBinding variable, ASTNode location) {
 	int problem;
 	if (variable instanceof FieldBinding) {
@@ -5166,14 +5264,22 @@ public void variableNullReference(VariableBinding variable, ASTNode location) {
 
 public void variablePotentialNullReference(VariableBinding variable, ASTNode location) {
 	int problem;
+	String[] arguments = new String[] {new String(variable.name)};
 	if (variable instanceof FieldBinding) {
-		problem = IProblem.PotentialNullFieldReference;
+		if ((variable.tagBits & TagBits.AnnotationNullable) != 0) {
+			// instead of reporting "can be null at this location" say *why* we give the warning: @Nullable!
+			problem = IProblem.NullableFieldReference;
+			char[][] nullableName = this.options.nullableAnnotationName;
+			arguments = new String[] {new String(variable.name),
+					                  new String(nullableName[nullableName.length-1])};
+		} else {
+			problem = IProblem.PotentialNullFieldReference;
+		}
 	} else {
 		problem = IProblem.PotentialNullLocalVariableReference;
 	}
 	int severity = computeSeverity(problem);
 	if (severity == ProblemSeverities.Ignore) return;
-	String[] arguments = new String[] {new String(variable.name)};
 	this.handle(
 		problem,
 		arguments,
@@ -5183,6 +5289,18 @@ public void variablePotentialNullReference(VariableBinding variable, ASTNode loc
 		nodeSourceEnd(variable, location));
 }
 
+public void nullableFieldDereference(VariableBinding variable, long position) {
+	String[] arguments = new String[] {new String(variable.name)};
+	char[][] nullableName = this.options.nullableAnnotationName;
+		arguments = new String[] {new String(variable.name), new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.NullableFieldReference,
+		arguments,
+		arguments,
+		(int)(position >>> 32),
+		(int)(position));
+}
+
 public void variableRedundantCheckOnNonNull(VariableBinding variable, ASTNode location) {
 	int problem;
 	if (variable instanceof FieldBinding) {
@@ -7198,6 +7316,19 @@ public void uninitializedBlankFinalField(FieldBinding field, ASTNode location) {
 		nodeSourceStart(field, location),
 		nodeSourceEnd(field, location));
 }
+public void uninitializedNonNullField(FieldBinding field, ASTNode location) {
+	char[][] nonNullAnnotationName = this.options.nonNullAnnotationName;
+	String[] arguments = new String[] {
+			new String(nonNullAnnotationName[nonNullAnnotationName.length-1]),
+			new String(field.readableName())
+	};
+	this.handle(
+		IProblem.UninitializedNonNullField,
+		arguments,
+		arguments,
+		nodeSourceStart(field, location),
+		nodeSourceEnd(field, location));
+}
 public void uninitializedLocalVariable(LocalVariableBinding binding, ASTNode location) {
 	binding.tagBits |= TagBits.NotInitialized;
 	String[] arguments = new String[] {new String(binding.readableName())};
@@ -8265,15 +8396,6 @@ public void messageSendPotentialNullReference(MethodBinding method, ASTNode loca
 		location.sourceStart,
 		location.sourceEnd);
 }
-public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location) {
-	String[] arguments = new String[] {new String(method.readableName())  };
-	this.handle(
-		IProblem.RedundantNullCheckOnNonNullMessageSend,
-		arguments,
-		arguments,
-		location.sourceStart,
-		location.sourceEnd);
-}
 
 public void missingNullAnnotationType(char[][] nullAnnotationName) {
 	String[] args = { new String(CharOperation.concatWith(nullAnnotationName, '.')) };
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 94cccee..2176e12 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -592,6 +592,11 @@
 676 = Redundant assignment: The field {0} can only be null at this location
 677 = instanceof always yields false: The field {0} can only be null at this location
 
+### NULL ANALYSIS FOR OTHER EXPRESSIONS
+685 = Null comparison always yields false: this expression cannot be null
+686 = Redundant null check: this expression cannot be null
+
+
 ### CORRUPTED BINARIES
 700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}
 
@@ -678,15 +683,21 @@
 917 = Missing non-null annotation: inherited method from {1} declares this parameter as @{2}
 918 = Missing nullable annotation: inherited method from {1} declares this parameter as @{2}
 919 = Potential null pointer access: The method {0} may return null
-920 = Redundant null check: The method {0} cannot return null
+# 920
 921 = The method {0} from {1} cannot implement the corresponding method from {2} due to incompatible nullness constraints
 922 = The nullness annotation is redundant with a default that applies to this location
 923 = The nullness annotation @{0} is not applicable for the primitive type {1}
+924 = Potential null pointer access: The field {0} is declared as @{1}
 925 = Nullness default is redundant with the global default
 926 = Nullness default is redundant with a default specified for the enclosing package {0}
 927 = Nullness default is redundant with a default specified for the enclosing type {0}
 928 = Nullness default is redundant with a default specified for the enclosing method {0}
 929 = Contradictory null specification; only one of @{0} and @{1} can be specified at any location
+930 = The @{0} field {1} may not have been initialized
+931 = Redundant null check: The method {0} cannot return null
+932 = Null comparison always yields false: The method {0} cannot return null
+933 = Redundant null check: The field {0} is declared as @{1}
+934 = Null comparison always yields false: The field {0} is declared as @{1}
 
 ### ELABORATIONS
 ## Access restrictions
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 8b2e896..df90888 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1440,7 +1440,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is a legal value in that position. Currently supported
-	 *    positions are: method parameters, method return type and local variables.</p>
+	 *    positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>If a value whose type
 	 *    is annotated with this annotation is dereferenced without checking for null,
 	 *    the compiler will trigger a diagnostic as further controlled by
@@ -1466,7 +1466,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is <b>not</b> a legal value in that position. Currently
-	 *    supported positions are: method parameters, method return type and local variables.</p>
+	 *    supported positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>For values declared with this annotation, the compiler will never trigger a null
 	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
 	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
@@ -1490,8 +1490,8 @@ public final class JavaCore extends Plugin {
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
 	 * <p>If the annotation is applied without an argument, all unannotated types in method signatures
-	 *    within the annotated element will be treated as if they were specified with the non-null annotation
-	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
+	 *    and field declarations within the annotated element will be treated as if they were specified
+	 *    with the non-null annotation (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
 	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
 	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.
 	 *    This includes defaults specified using this annotation type or a default defined using
@@ -1540,6 +1540,9 @@ public final class JavaCore extends Plugin {
 	 *        for at least one of its parameters, tries to tighten that null contract by
 	 *        specifying a nonnull annotation for its corresponding parameter
 	 *        (prohibition of covariant parameters).</li>
+	 *    <li>A non-static field with a nonnull annotation is not definitely assigned at
+	 *        the end of each constructor.</li>
+	 *    <li>A static field with a nonnull annotation is not definitely assigned at <strong>TODO</strong> .</li>
 	 *    </ol>
 	 * </p>
 	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
commit a846071c58f9098177eef02be0134294158f9c4f
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Jan 22 20:33:56 2013 +0100

    Combined fix for
    Bug 331649 - [compiler][null] consider null annotations for fields
    Bug 382789 - [compiler][null] warn when syntactically-nonnull
      expression is compared against null
    Bug 380896 - [compiler][null] Enum constants not recognised as being
      NonNull.
    Bug 383368 - [compiler][null] syntactic null analysis for field
      references
    Bug 388630 - @NonNull diagnostics at line 0

1	1	org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
1	1	org.eclipse.jdt.annotation/pom.xml
3	2	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
2	1	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
3	2	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
4	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
18	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
1454	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
154	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
28	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
24	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
16	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
22	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
22	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
60	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
28	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
85	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
8	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
87	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
48	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
43	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
12	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
7	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
72	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
43	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
14	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
1	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
53	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
139	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
23	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
index 1b57641..e215be5 100644
--- a/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
+++ b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
@@ -3,7 +3,7 @@ Bundle-ManifestVersion: 2
 Bundle-Name: %bundleName
 Bundle-Localization: bundle
 Bundle-SymbolicName: org.eclipse.jdt.annotation
-Bundle-Version: 1.0.1.qualifier
+Bundle-Version: 1.1.0.qualifier
 Export-Package: org.eclipse.jdt.annotation
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-Vendor: %providerName
diff --git a/org.eclipse.jdt.annotation/pom.xml b/org.eclipse.jdt.annotation/pom.xml
index 8474179..a60aeab 100644
--- a/org.eclipse.jdt.annotation/pom.xml
+++ b/org.eclipse.jdt.annotation/pom.xml
@@ -20,6 +20,6 @@
   </parent>
   <groupId>eclipse.jdt.core</groupId>
   <artifactId>org.eclipse.jdt.annotation</artifactId>
-  <version>1.0.1-SNAPSHOT</version>
+  <version>1.1.0-SNAPSHOT</version>
   <packaging>eclipse-plugin</packaging>
 </project>
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
index eaaae3d..36ec3ae 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation can never have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -44,7 +45,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface NonNull {
 	// marker annotation with no members
 }
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
index d5e5aa7..196e075 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
@@ -28,7 +28,8 @@ import java.lang.annotation.Target;
  * <code>@NonNullByDefault</code> are:
  * <ul>
  * <li>method return values</li>
- * <li>parameters of a method or constructor.</li>
+ * <li>parameters of a method or constructor</li>
+ * <li>fields.</li>
  * </ul>
  * Local variables are <em>not</em> affected.
  * <dl>
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
index e1a6a1b..cb84e45 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation is allowed to have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -35,7 +36,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface Nullable {
 	// marker annotation with no members
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index dfbeb86..79b6bd5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -13,6 +13,7 @@
  *								bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639)
  *								bug 384663 - Package Based Annotation Compilation Error in JDT 3.8/4.2 (works in 3.7.2) 
  *								bug 386356 - Type mismatch error with annotations and generics
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -10401,7 +10402,7 @@ public void testBug365437e() {
 			"}\n" +
 			"class E3 {\n" +
 			"	 @p.NonNull\n" +
-			"    private int E3;\n" +
+			"    private Object E3 = new Object();\n" +
 			"}\n" +
 			"class E4 {\n" +
 			"	 @Deprecated\n" +
@@ -10441,8 +10442,8 @@ public void testBug365437e() {
 		"The value of the field E2.E2 is not used\n" + 
 		"----------\n" + 
 		"4. ERROR in Example.java (at line 15)\n" + 
-		"	private int E3;\n" + 
-		"	            ^^\n" + 
+		"	private Object E3 = new Object();\n" + 
+		"	               ^^\n" + 
 		"The value of the field E3.E3 is not used\n" + 
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 00ffdd7..a366ca4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -22,6 +22,7 @@
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1972,6 +1973,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.staticAccessReceiver\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.suppressWarnings\" value=\"enabled\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.tasks\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.typeParameterHiding\" value=\"warning\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index ce126e3..ca9139e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -17,6 +17,8 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -736,6 +738,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonGenericConstructor", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericMethod", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
@@ -748,6 +753,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -802,6 +808,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -894,6 +902,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UninitializedLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1446,7 +1456,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonGenericConstructor", SKIP);
 		expectedProblemAttributes.put("NonGenericMethod", SKIP);
 		expectedProblemAttributes.put("NonGenericType", SKIP);
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
@@ -1458,6 +1471,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleField", SKIP);
 		expectedProblemAttributes.put("NotVisibleMethod", SKIP);
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
@@ -1512,6 +1526,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_TYPE_ARGUMENTS));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
@@ -1604,6 +1620,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariable", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
+		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
+		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 4c83c85..294e913 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -53,7 +53,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "test_parameter_specification_inheritance_01" };
+//		TESTS_NAMES = new String[] { "test_nullable_field_10e" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -127,6 +127,17 @@ void runNegativeTestWithLibs(String[] testFiles, Map customOptions, String expec
 void runConformTestWithLibs(String[] testFiles, Map customOptions, String expectedCompilerLog) {
 	runConformTestWithLibs(false /* flush output directory */, testFiles, customOptions, expectedCompilerLog);
 }
+void runConformTestWithLibs(String[] testFiles, Map customOptions, String expectedCompilerLog, String expectedOutput) {
+	runConformTest(
+			false, /* flush output directory */
+			testFiles,
+			this.LIBS,
+			customOptions,
+			expectedCompilerLog,
+			expectedOutput,
+			"",/* expected error */
+		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
 void runConformTestWithLibs(boolean shouldFlushOutputDirectory, String[] testFiles, Map customOptions, String expectedCompilerLog) {
 	runConformTest(
 			shouldFlushOutputDirectory,
@@ -1633,7 +1644,12 @@ public void test_nonnull_return_008() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	if (getObject() == null)\n" +
 		"	    ^^^^^^^^^^^\n" +
-		"Redundant null check: The method getObject() cannot return null\n" +
+		"Null comparison always yields false: The method getObject() cannot return null\n" +
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	throw new RuntimeException();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
 		"----------\n");
 }
 // a result from a nonnull method is directly checked for null (from local): redundant
@@ -2784,6 +2800,87 @@ public void test_default_nullness_015() {
 		"----------\n");
 }
 
+// default nullness applied to fields, class-level:
+public void test_default_nullness_016() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    Object foo;\n" +
+			"    void doFoo() {\n" +
+			"        foo = null;\n" +
+			"    }\n" +
+			"    class Inner {\n" +
+			"        Object iFoo;\n" +
+			"        void diFoo(@Nullable Object arg) {\n" +
+			"            iFoo = arg;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	Object foo;\n" + 
+		"	       ^^^\n" + 
+		"The @NonNull field foo may not have been initialized\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	foo = null;\n" + 
+		"	      ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 9)\n" + 
+		"	Object iFoo;\n" + 
+		"	       ^^^^\n" + 
+		"The @NonNull field iFoo may not have been initialized\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	iFoo = arg;\n" + 
+		"	       ^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n");
+}
+
+// default nullness applied to fields, method level applied to local class + redundant annotation
+public void test_default_nullness_017() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNUSED_PRIVATE_MEMBER, JavaCore.IGNORE);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNullByDefault\n" +
+			"    Object doFoo() {\n" +
+			"        class Local {\n" +
+			"            Object foo;\n" +
+			"            @NonNull Object goo;\n" +
+			"        };" +
+			"        return new Local();\n" +
+			"    }\n" +
+			"}\n",
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	Object foo;\n" + 
+		"	       ^^^\n" + 
+		"The @NonNull field foo may not have been initialized\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 7)\n" + 
+		"	@NonNull Object goo;\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The nullness annotation is redundant with a default that applies to this location\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	@NonNull Object goo;\n" + 
+		"	                ^^^\n" + 
+		"The @NonNull field goo may not have been initialized\n" + 
+		"----------\n");
+}
+
 // redundant default annotations - class vs. inner class
 public void test_redundant_annotation_01() {
 	Map customOptions = getCompilerOptions();
@@ -3103,6 +3200,27 @@ public void test_contradictory_annotations_01() {
 		"----------\n");
 }
 
+// contradictory null annotations on a field
+public void test_contradictory_annotations_02() {
+	Map customOptions = getCompilerOptions();
+	runNegativeTestWithLibs(
+		new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @NonNull @Nullable Object o;\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in p2\\Y.java (at line 4)\n" + 
+		"	@NonNull @Nullable Object o;\n" + 
+		"	         ^^^^^^^^^\n" + 
+		"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
+		"----------\n");
+}
+
 // a nonnull variable is dereferenced in a loop
 public void test_nonnull_var_in_constrol_structure_1() {
 	Map customOptions = getCompilerOptions();
@@ -3336,6 +3454,7 @@ public void test_message_send_in_control_structure_01() {
 		"Null comparison always yields false: The variable enclosingSourceType cannot be null at this location\n" +
 		"----------\n");
 }
+
 // Bug 370930 - NonNull annotation not considered for enhanced for loops
 public void test_message_send_in_control_structure_02() {
 	runNegativeTestWithLibs(
@@ -3610,6 +3729,1339 @@ public void test_options_03() {
 		"Dead code\n" + 
 		"----------\n");
 }
+// access to a non-null field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_1() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is not properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	@NonNull Object o;\n" +
+		"	                ^\n" +
+		"The @NonNull field o may not have been initialized\n" +
+		"----------\n");
+}
+
+// a non-null field is not properly initialized - explicit constructor
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    X (boolean b) { // only potentially initialized\n" +
+			"        if (b)\n" +
+			"            o = this;\n" +
+			"    }\n" +
+			"    X (@NonNull Object other) {\n" + // no problem
+			"        o = other;\n" +
+			"    }\n" +
+			"    public String oString() {\n" +
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	X (boolean b) { // only potentially initialized\n" + 
+		"	^^^^^^^^^^^^^\n" + 
+		"The @NonNull field o may not have been initialized\n" + 
+		"----------\n");
+}
+
+// a non-null field is not properly initialized - explicit constructor - incomplete switch
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2b() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"enum Color { BLACK, GREEN }\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    X (Color c) { // only potentially initialized\n" +
+			"        switch (c) {\n" +
+			"            case BLACK: o = this; break;\n" +
+			"            case GREEN: o = new Object(); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"    public String oString() {\n" +
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	X (Color c) { // only potentially initialized\n" + 
+		"	^^^^^^^^^^^\n" + 
+		"The @NonNull field o may not have been initialized. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n");
+}
+
+// a non-null static field is not properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2c() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    static @NonNull Object o;\n" +
+			"    static {\n" +
+			"        if (new Object().hashCode() == 42)\n" +
+			"            o = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	static @NonNull Object o;\n" + 
+		"	                       ^\n" + 
+		"The @NonNull field o may not have been initialized\n" + 
+		"----------\n");
+}
+
+// a non-null static field is properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2d() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    static @NonNull Object o;\n" +
+			"    static {\n" +
+			"         o = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is properly initialized - using this.f reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2e() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object f;\n" +
+			"    {\n" +
+			"         this.f = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is initialized to null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = null;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull Object o = null;\n" + 
+		"	                    ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is assigned to null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_4() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    void breakIt1() {\n" +
+			"         o = null;\n" +
+			"    }\n" +
+			"    void breakIt2() {\n" +
+			"         this.o = null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	this.o = null;\n" + 
+		"	         ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is checked for null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         return o == null;\n" +
+			"    }\n" +
+			"    boolean checkIt() {\n" +
+			"         return this.o != null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o == null;\n" + 
+		"	       ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o != null;\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is checked for null twice - method call inbetween
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         if (o != null)\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return this.o == null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (o != null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o == null;\n" + 
+		"	            ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - static field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    static @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (Objects.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    @NonNull Object getIt2() {\n" +
+			"         if (null != Objects.o) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    String getIt3() {\n" +
+			"         return Objects.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (Objects.o != null) // redundant\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	if (null != Objects.o) // redundant\n" + 
+		"	                    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - instance field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_8() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1(@NonNull Objects objs) {\n" +
+			"         if (objs.o == null) // always false\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return objs.o;\n" +
+			"    }\n" +
+			"    String getIt2(@NonNull Objects objs) {\n" +
+			"         return objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (objs.o == null) // always false\n" + 
+		"	         ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	System.out.print(\"not null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via an indirect field reference - instance field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_9() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    Objects objs = new Objects();\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (this.objs.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         if (getObjs().o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         return this.objs.o;\n" +
+			"    }\n" +
+			"    Objects getObjs() { return this.objs; }\n" +
+			"    String getIt2() {\n" +
+			"         return this.objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	if (this.objs.o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	if (getObjs().o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// trying to assign null to a nonnull field via a single / a qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_11() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    void test0(@Nullable Object x) {\n" +
+			"         o = x;\n" +
+			"    }\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    void test(@NonNull Objects objs) {\n" +
+			"         objs.o = null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	o = x;\n" + 
+		"	    ^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	objs.o = null;\n" + 
+		"	         ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+// @NonNull is applied to a field with primitive type
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_12() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull int o = 1;\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull int o = 1;\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"The nullness annotation @NonNull is not applicable for the primitive type int\n" + 
+		"----------\n");
+}
+
+// A final field is initialized to non-null, treat as effectively @NonNull
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void _test_nonnull_field_13() {
+	// withdrawn as of https://bugs.eclipse.org/331649#c75
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    final String s1 = \"\";\n" +
+			"    @NonNull String s2;\n" +
+			"    X() {\n" +
+			"        s2 = s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// A field in a different CU is implicitly @NonNull (by type default) - that class is read from binary
+// Assignment to other @NonNull field should not raise a warning
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_14() {
+	runConformTestWithLibs(
+		new String[] {
+			"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    public String s1 = \"\";\n" +
+			"}\n",
+		},
+		null /*customOptions*/,
+		"");
+	runConformTestWithLibs(
+			new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import p1.X;\n" +
+			"public class Y {\n" +
+			"    @NonNull String s2 = \"\";\n" +
+			"    void foo(X other) {\n" +
+			"        s2 = other.s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// A field in a different CU is implicitly @NonNull (by package default) - that class is read from binary
+// Assignment to other @NonNull field should not raise a warning
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_14b() {
+	runConformTestWithLibs(
+		new String[] {
+			"p1/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p1;\n",
+			"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    public String s1 = \"\";\n" +
+			"}\n",
+		},
+		null /*customOptions*/,
+		"");
+	runConformTestWithLibs(
+			new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import p1.X;\n" +
+			"public class Y {\n" +
+			"    @NonNull String s2 = \"\";\n" +
+			"    void foo(X other) {\n" +
+			"        s2 = other.s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// access to a nullable field - field reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_1() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return this.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.o.toString();\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - single name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o.toString();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    @Nullable X other;\n" +
+			"    public String oString() {\n" +
+			"         return other.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	       ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	             ^\n" +
+		"Potential null pointer access: The field o is declared as @Nullable\n" +
+		"----------\n");
+}
+// access to a nullable field - qualified name reference - multiple segments
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_3m() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    @Nullable X other;\n" +
+			"    public String oString() {\n" +
+			"         return other.other.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	       ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	             ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	                   ^\n" +
+		"Potential null pointer access: The field o is declared as @Nullable\n" +
+		"----------\n");
+}
+// access to a nullable field - dereference after check
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_4() {
+	// currently no flow analysis for fields is implemented,
+	// but the direct sequence of null-check + dereference is optionally supported as a special case
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         if (this.o != null)\n" +
+			"             return this.o.toString();\n" + // silent after check
+			"         if (o != null)\n" +
+			"             return o.toString();\n" + // silent after check
+			"         return \"\";\n" +
+			"    }\n" +
+			"    public String oString2() {\n" +
+			"         String local = o.toString();\n" +
+			"         if (this.o != null) {\n" +
+			"             this.toString();\n" + // method call wipes null info
+			"             return this.o.toString(); // warn here\n" +
+			"         }\n" +
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	String local = o.toString();\n" + 
+		"	               ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 15)\n" + 
+		"	return this.o.toString(); // warn here\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a QNR
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on z\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on z\n" + 
+		"	         ^\n" + 
+		"Potential null pointer access: The field z is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a QNR - inverse of test_nullable_field_5
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @NonNull Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    Object dummy;\n" + // ensure different interal fieldId
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	           ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a double field reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return this.y.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	              ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// static access to a nullable field - qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_8() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable static final Object o = null;\n" +
+			"    public void foo() {\n" +
+			"         if (X.o == null){\n" +
+			"				System.out.println(X.o);\n" +
+			"		  }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// illegal use of @Nullable for a field of primitive type
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_9() {
+	runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    @Nullable int i;\n" +
+				"}\n"
+			},
+			null /*customOptions*/,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	@Nullable int i;\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"The nullness annotation @Nullable is not applicable for the primitive type int\n" + 
+			"----------\n");	
+}
+
+// protected access to nullable fields - different kinds of references
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    @NonNull X x = new X();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +						// qualified reference -> block
+			"             System.out.println(other.o1.toString());\n" +
+			"         }\n" +
+			"         if (this.o2 != null)\n" + 						// field reference -> statement
+			"             System.out.println(o2.toString());\n" +
+			"         if (this.o2 != null)\n" + 						// identical field references
+			"             System.out.println(this.o2.toString());\n" +
+			"         System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + // ternary
+			"         if (this.x.o1 != null)\n" +						// nested field reference ...
+			"             System.out.println(x.o1.toString());\n" + 	// ... equiv qualified name reference
+			"         if (x.o1 != null)\n" +							// qualified name reference ...
+			"             System.out.println(this.x.o1.toString());\n" +// ... equiv nested field reference
+			"         if (this.x.o1 != null)\n" +						// identical nested field references
+			"             System.out.println(this.x.o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
+// protected access to nullable fields - different kinds of references - option not enabled
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10b() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.DISABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    @NonNull X x = new X();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +						// qualified reference -> block
+			"             System.out.println(other.o1.toString());\n" +
+			"         }\n" +
+			"         if (this.o2 != null)\n" + 						// field reference -> statement
+			"             System.out.println(o2.toString());\n" +
+			"         if (this.o2 != null)\n" + 						// identical field references
+			"             System.out.println(this.o2.toString());\n" +
+			"         System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + // ternary
+			"         if (this.x.o1 != null)\n" +						// nested field reference ...
+			"             System.out.println(x.o1.toString());\n" + 	// ... equiv qualified name reference
+			"         if (x.o1 != null)\n" +							// qualified name reference ...
+			"             System.out.println(this.x.o1.toString());\n" +// ... equiv nested field reference
+			"         if (this.x.o1 != null)\n" +						// identical nested field references
+			"             System.out.println(this.x.o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	System.out.println(other.o1.toString());\n" + 
+		"	                         ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	System.out.println(o2.toString());\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 12)\n" + 
+		"	System.out.println(this.o2.toString());\n" + 
+		"	                        ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 13)\n" + 
+		"	System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + 
+		"	                                 ^^\n" + 
+		"Potential null pointer access: The field o3 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 15)\n" + 
+		"	System.out.println(x.o1.toString());\n" + 
+		"	                     ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 17)\n" + 
+		"	System.out.println(this.x.o1.toString());\n" + 
+		"	                          ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 19)\n" + 
+		"	System.out.println(this.x.o1.toString());\n" + 
+		"	                          ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - different boolean operators
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10c() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (o1 != null && o2 != null & o3 != null) \n" + // conjunction: OK
+			"             System.out.println(o2.toString());\n" +
+			"         if (o1 != null || o2 != null || o3 != null) \n" +
+			"             System.out.println(o2.toString()); // warn here: disjunktion is no protection\n" +
+			"         if (!(o1 != null)) \n" +
+			"             System.out.println(o1.toString()); // warn here: negation is no protection\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" +
+		"1. ERROR in X.java (at line 8)\n" +
+		"	System.out.println(o2.toString()); // warn here: disjunktion is no protection\n" +
+		"	                   ^^\n" +
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 10)\n" +
+		"	System.out.println(o1.toString()); // warn here: negation is no protection\n" +
+		"	                   ^^\n" +
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" +
+		"----------\n");
+}
+
+// protected access to nullable fields - assignment as expression
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10d() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    public void foo(@NonNull X other, X last) {\n" +
+			"         o1 = other;\n" +		// reference test case: assignment as statement
+			"         if (o1 == last) \n" +	// no expiry
+			"             System.out.println(o1.toString());\n" +
+			"         if ((o1 = other) == last) \n" + // no expiry
+			"             System.out.println(o1.toString());\n" +
+			"         if ((o1 = other) == last) {\n" +
+			"             o1 = null;\n" + // expire here
+			"             System.out.println(o1.toString()); // info is expired\n" +
+			"         }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	System.out.println(o1.toString()); // info is expired\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - distinguish local and field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10e() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Y {\n" +
+			"    @Nullable Object o2;\n" +
+			"    void bar(Object o2) {\n" +
+			"        if (o2 != null)\n" +
+			"            System.out.println(this.o2.toString()); // field access is not protected\n" +
+			"    }\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Y o1 = new Y();\n" +
+			"    public void foo() {\n" +
+			"         Y o1 = new Y();\n" +
+			"         if (o1.o2 != null) \n" +	// check via local
+			"             System.out.println(this.o1.o2.toString()); // field access via other field not protected\n" +
+			"         if (this.o1.o2 != null) \n" +	// check via field
+			"             System.out.println(o1.o2.toString()); // field access via local not protected\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	void bar(Object o2) {\n" + 
+		"	                ^^\n" + 
+		"The parameter o2 is hiding a field from type Y\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	System.out.println(this.o2.toString()); // field access is not protected\n" + 
+		"	                        ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 12)\n" + 
+		"	Y o1 = new Y();\n" + 
+		"	  ^^\n" + 
+		"The local variable o1 is hiding a field from type X\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 14)\n" + 
+		"	System.out.println(this.o1.o2.toString()); // field access via other field not protected\n" + 
+		"	                           ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 16)\n" + 
+		"	System.out.println(o1.o2.toString()); // field access via local not protected\n" + 
+		"	                      ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - duplicate comparison
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10f() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (o1 != null && o1 != null) // second term is redundant\n" +
+			"             System.out.println(o1.toString());\n" +
+			"         if (o1 != null)\n" +
+			"             if (o1 != null) // this if is redundant\n" +
+			"                 System.out.println(o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (o1 != null && o1 != null) // second term is redundant\n" + 
+		"	                  ^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	if (o1 != null) // this if is redundant\n" + 
+		"	    ^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n");
+}
+
+// combined test from comment 20 in https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_11() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"class X {\n" + 
+				"    @Nullable Object o;\n" + 
+				"    public @NonNull Object foo(X x) {\n" + 
+				"    	return  x.o != null ? x.o : new Object();\n" + 
+				"	 }\n" + 
+				"    public void goo(X x) {\n" + 
+				"    	if (x.o != null) {\n" + 
+				"    		x.o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void boo(X x) {\n" + 
+				"    	if (x.o instanceof String) {\n" + 
+				"    		x.o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void zoo(X x) {\n" + 
+				"    	x.o = new Object();\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + x.o.hashCode());\n" + 
+				"    }\n" + 
+				"    public void doo(X x) {\n" + 
+				"    	x.o = foo(x); // foo is guaranteed to return @NonNull Object.\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + x.o.hashCode());\n" + 
+				"    }\n" + 
+				"}\n"
+			},
+			options,
+			"");
+}
+
+// combined test from comment 20 in https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+//  - version with 'this' field references
+public void test_nullable_field_11a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"class X {\n" + 
+				"    @Nullable Object o;\n" + 
+				"    public @NonNull Object foo() {\n" + 
+				"    	return  o != null ? o : new Object();\n" + 
+				"    }\n" + 
+				"    public void goo() {\n" + 
+				"    	if (o != null) {\n" + 
+				"    		o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void boo() {\n" + 
+				"    	if (o instanceof String) {\n" + 
+				"    		o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void zoo() {\n" + 
+				"    	o = new Object();\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + o.hashCode());\n" + 
+				"    }\n" + 
+				"    public void doo() {\n" + 
+				"    	o = foo(); // foo is guaranteed to return @NonNull Object.\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + o.hashCode());\n" + 
+				"    }\n" + 
+				"}\n"
+			},
+			options,
+			"");
+}
+
+// protected access to nullable field - expiration of information
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_12() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3, o4;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +
+			"				System.out.println(goo()+other.o1.toString()); // warn here: expired by call to goo()\n" +
+			"		  }\n" +
+			"         Object x = o2 != null ? o2 : o1;\n" +
+			"         System.out.println(o2.toString()); // warn here: not protected\n" +
+			"         if (o3 != null) /*nop*/;\n" +
+			"         System.out.println(o3.toString()); // warn here: expired by empty statement\n" +
+			"         if (o4 != null && hoo())\n" +
+			"             System.out.println(o4.toString()); // warn here: expired by call to hoo()\n" +
+			"    }\n" +
+			"    String goo() { return \"\"; }\n" +
+			"    boolean hoo() { return false; }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	System.out.println(goo()+other.o1.toString()); // warn here: expired by call to goo()\n" + 
+		"	                               ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 9)\n" + 
+		"	System.out.println(o2.toString()); // warn here: not protected\n" +
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 11)\n" + 
+		"	System.out.println(o3.toString()); // warn here: expired by empty statement\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o3 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 13)\n" + 
+		"	System.out.println(o4.toString()); // warn here: expired by call to hoo()\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o4 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// example from comment 47
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_13() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    @NonNull Object o2 = new Object();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 == null){\n" +
+			"				this.o2 = other.o1; // warn here: assign @Nullable to @NonNull\n" +
+			"		  }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	this.o2 = other.o1; // warn here: assign @Nullable to @NonNull\n" + 
+		"	          ^^^^^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - protected by check against a @NonNull value
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_14() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString(@NonNull Object a) {\n" +
+			"         if (this.o == a)\n" +
+			"             return this.o.toString();\n" + // silent after check
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
+// access to a nullable field - not protected by negative check against a @NonNull value
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_14a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString(@NonNull Object a) {\n" +
+			"         if (this.o != a)\n" +
+			"             return this.o.toString(); // warn here, check has no effect\n" +
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	return this.o.toString(); // warn here, check has no effect\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// an enum is declared within the scope of a null-default
+// https://bugs.eclipse.org/331649#c61
+public void test_enum_field_01() {
+	runConformTestWithLibs(
+		new String[] {
+			"tests/X.java",
+			"package tests;\n" +
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class X {\n" +
+			"    enum A { B }\n" +
+			"    public static void main(String ... args) {\n" +
+			"         System.out.println(A.B);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null,
+		"",
+		"B");
+}
+
+// Bug 380896 - Enum constants not recognised as being NonNull.
+// see also https://bugs.eclipse.org/331649#c61
+public void test_enum_field_02() {
+	runConformTestWithLibs(
+		new String[] {
+			"tests/X.java",
+			"package tests;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    enum A { B }\n" +
+			"    public static void main(String ... args) {\n" +
+			"         test(A.B);\n" +
+			"    }\n" +
+			"    static void test(@NonNull A a) {\n" +
+			"        System.out.println(a.ordinal());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null,
+		"",
+		"0");
+}
+
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372011
 // Test whether @NonNullByDefault on a binary package or an enclosing type is respected from enclosed elements.
 public void testBug372011() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index c67196f..6245e57 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -25,6 +25,8 @@
  * 							bug 383690 - [compiler] location of error re uninitialized final field should be aligned
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 376263 - Bogus "Potential null pointer access" warning
+ *							bug 331649 - [compiler][null] consider null annotations for fields
+ *							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -9637,9 +9639,9 @@ public void test1023() {
 			"X.java",
 			"public class X {\n" +
 			"\n" +
-			"  void foo() {\n" +
+			"  void foo(Object that) {\n" +
 			"    Object o = new Object();\n" +
-			"    while (this != null) {\n" +
+			"    while (that != null) {\n" +
 			"      try {\n" +
 			"        o = null;\n" +
 			"        break;\n" +
@@ -9656,7 +9658,7 @@ public void test1023() {
 		"	    ^\n" +
 		"Null comparison always yields false: The variable o cannot be null at this location\n" +
 		"----------\n" +
-		"2. WARNING in X.java (at line 13)\n" + 
+		"2. WARNING in X.java (at line 13)\n" +
 		"	if (o == null) return;\n" + 
 		"	               ^^^^^^^\n" + 
 		"Dead code\n" + 
@@ -15661,6 +15663,155 @@ public void testBug376263() {
 		customOptions,
 		null/*requestor*/);
 }
+//object/array allocation
+public void testExpressions01() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (new Object() == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"	 void goo() {\n" +
+			"		if (null != this.new I())\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    void hoo() {\n" +
+			"		if (null != new Object[3])\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    class I {}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (new Object() == null)\n" + 
+		"	    ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != this.new I())\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	if (null != new Object[3])\n" + 
+		"	            ^^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+//'this' expressions (incl. qualif.)
+public void testExpressions02() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (this == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    class I {\n" +
+			"        void goo() {\n" +
+			"		     if (null != X.this)\n" +
+			"                System.out.println(\"nonnull\");\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (this == null)\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 8)\n" + 
+		"	if (null != X.this)\n" + 
+		"	            ^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+//various non-null expressions: class-literal, string-literal, casted 'this'
+public void testExpressions03() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (X.class == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    void goo() {\n" +
+			"        if (null != \"STRING\")\n" +
+			"            System.out.println(\"nonnull\");\n" +
+			"        if (null == (Object)this)\n" +
+			"            System.out.println(\"I'm null\");\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (X.class == null)\n" + 
+		"	    ^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != \"STRING\")\n" + 
+		"	            ^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 9)\n" + 
+		"	if (null == (Object)this)\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"5. WARNING in X.java (at line 10)\n" + 
+		"	System.out.println(\"I\'m null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n"
+	);
+}
+
+//a non-null ternary expression
+public void testExpressions04() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(boolean b) {\n" + 
+			"		Object o1 = new Object();\n" + 
+			"		Object o2 = new Object();\n" + 
+			"		if ((b ? o1 : o2) != null)\n" + 
+			"			System.out.println(\"null\");\n" + 
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if ((b ? o1 : o2) != null)\n" + 
+		"	    ^^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
 
 // Bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
 // simplified: only try-finally involved
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index f22ed24..a9da5db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -149,6 +149,14 @@
  *									UninitializedLocalVariableHintMissingDefault
  *									UninitializedBlankFinalFieldHintMissingDefault
  *									ShouldReturnValueHintMissingDefault
+ *									NullableFieldReference
+ *									UninitializedNonNullField
+ *									UninitializedNonNullFieldHintMissingDefault
+ *									NonNullMessageSendComparisonYieldsFalse
+ *									RedundantNullCheckOnNonNullSpecdField
+ *									NonNullSpecdFieldComparisonYieldsFalse
+ *									NonNullExpressionComparisonYieldsFalse
+ *									RedundantNullCheckOnNonNullExpression
  *									ConflictingNullAnnotations
  *									ConflictingInheritedNullAnnotations
  *									UnsafeElementTypeConversion
@@ -1305,6 +1313,14 @@ void setSourceStart(int sourceStart);
 	int IllegalArrayOfUnionType = TypeRelated + 662;
 
 	/**
+	 * Null analysis for other kinds of expressions, syntactically nonnull
+	 */
+	/** @since 3.9 */
+	int NonNullExpressionComparisonYieldsFalse = Internal + 670;
+	/** @since 3.9 */
+	int RedundantNullCheckOnNonNullExpression = Internal + 671;
+
+	/**
 	 * Corrupted binaries
 	 */
 	/** @since 3.1 */
@@ -1495,6 +1511,8 @@ void setSourceStart(int sourceStart);
 	int RedundantNullAnnotation = MethodRelated + 922;
 	/** @since 3.8 */
 	int IllegalAnnotationForBaseType = TypeRelated + 923;
+	/** @since 3.9 */
+	int NullableFieldReference = FieldRelated + 924;
 	/** @since 3.8 */
 	int RedundantNullDefaultAnnotation = Internal + 925; // shouldn't actually occur any more after bug 366063
 	/** @since 3.8 */
@@ -1514,6 +1532,16 @@ void setSourceStart(int sourceStart);
 	/** @since 3.8 */
 	int RequiredNonNullButProvidedSpecdNullable = Internal + 933;
 	/** @since 3.9 */
+	int UninitializedNonNullField = FieldRelated + 934;
+	/** @since 3.9 */
+	int UninitializedNonNullFieldHintMissingDefault = FieldRelated + 935;
+	/** @since 3.9 */
+	int NonNullMessageSendComparisonYieldsFalse = Internal + 936;
+	/** @since 3.9 */
+	int RedundantNullCheckOnNonNullSpecdField = Internal + 937;
+	/** @since 3.9 */
+	int NonNullSpecdFieldComparisonYieldsFalse = Internal + 938;
+	/** @since 3.9 */
 	int ConflictingNullAnnotations = MethodRelated + 939;
 	/** @since 3.9 */
 	int ConflictingInheritedNullAnnotations = MethodRelated + 940;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 1331b11..b239400 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -404,6 +405,10 @@ public abstract class Annotation extends Expression {
 							FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(sourceField);
 							recordSuppressWarnings(scope, fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
+						if ((sourceField.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
+							scope.problemReporter().contradictoryNullAnnotations(this);
+							sourceField.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems
+						}
 						break;
 					case Binding.LOCAL :
 						LocalVariableBinding variable = (LocalVariableBinding) this.recipient;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index 55d4cac..21f7e7a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -167,7 +168,7 @@ public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream
 	codeStream.arrayAtPut(this.resolvedType.id, false);
 }
 
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 	return FlowInfo.UNKNOWN;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 0ccfdd8..516e4ef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -21,12 +21,15 @@
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *							bug 331649 - [compiler][null] consider null annotations for fields
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
@@ -55,9 +58,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	}
 	
 	FlowInfo preInitInfo = null;
+	CompilerOptions compilerOptions = currentScope.compilerOptions();
 	boolean shouldAnalyseResource = local != null
 			&& flowInfo.reachMode() == FlowInfo.REACHABLE
-			&& currentScope.compilerOptions().analyseResourceLeaks
+			&& compilerOptions.analyseResourceLeaks
 			&& (FakedTrackingVariable.isAnyCloseable(this.expression.resolvedType)
 					|| this.expression.resolvedType == TypeBinding.NULL);
 	if (shouldAnalyseResource) {
@@ -75,14 +79,29 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	else
 		FakedTrackingVariable.cleanUpAfterAssignment(currentScope, this.lhs.bits, this.expression);
 
-	int nullStatus = this.expression.nullStatus(flowInfo);
+	int nullStatus = this.expression.nullStatus(flowInfo, flowContext);
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		if (nullStatus == FlowInfo.NULL) {
 			flowContext.recordUsingNullReference(currentScope, local, this.lhs,
 				FlowContext.CAN_ONLY_NULL | FlowContext.IN_ASSIGNMENT, flowInfo);
 		}
 	}
-	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, local, nullStatus, this.expression, this.expression.resolvedType);
+	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
+		VariableBinding var = this.lhs.nullAnnotatedVariableBinding();
+		if (var != null) {
+			nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, var, nullStatus, this.expression, this.expression.resolvedType);
+			if (nullStatus == FlowInfo.NON_NULL
+					&& var instanceof FieldBinding
+					&& this.lhs instanceof Reference
+					&& compilerOptions.enableSyntacticNullAnalysisForFields)
+			{
+				int timeToLive = (this.bits & InsideExpressionStatement) != 0
+									? 2  // assignment is statement: make info survives the end of this statement
+									: 1; // assignment is expression: expire on next event.
+				flowContext.recordNullCheckedFieldReference((Reference) this.lhs, timeToLive);
+			}
+		}
+	}
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
 		if (flowContext.initsOnFinally != null)
@@ -134,8 +153,8 @@ FieldBinding getLastField(Expression someExpression) {
     return null;
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return this.expression.nullStatus(flowInfo);
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	return this.expression.nullStatus(flowInfo, flowContext);
 }
 
 public StringBuffer print(int indent, StringBuffer output) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
index 439bcf7..bd419a8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -69,8 +70,15 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		} else {
 			this.left.checkNPE(currentScope, flowContext, flowInfo);
 			flowInfo = this.left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			if (((this.bits & OperatorMASK) >> OperatorSHIFT) != AND) {
+				flowContext.expireNullCheckedFieldInfo();
+			}
 			this.right.checkNPE(currentScope, flowContext, flowInfo);
-			return this.right.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			flowInfo = this.right.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			if (((this.bits & OperatorMASK) >> OperatorSHIFT) != AND) {
+				flowContext.expireNullCheckedFieldInfo();
+			}
+			return flowInfo;
 		}
 	} finally {
 		// account for exception possibly thrown by arithmetics
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index a93b327..491e0eb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -11,6 +11,7 @@
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -34,6 +35,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	// empty block
 	if (this.statements == null)	return flowInfo;
 	int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;
+	boolean enableSyntacticNullAnalysisForFields = currentScope.compilerOptions().enableSyntacticNullAnalysisForFields;
 	for (int i = 0, max = this.statements.length; i < max; i++) {
 		Statement stat = this.statements[i];
 		if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
@@ -42,6 +44,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// record the effect of stat on the finally block of an enclosing try-finally, if any:
 		if (flowContext.initsOnFinally != null)
 			flowContext.mergeFinallyNullInfo(flowInfo);
+		if (enableSyntacticNullAnalysisForFields) {
+			flowContext.expireNullCheckedFieldInfo();
+		}
 	}
 	if (this.explicitDeclarations > 0) {
 		// if block has its own scope analyze tracking vars now:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index 1e07f86..a2d9ee3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -12,6 +12,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -450,8 +451,8 @@ public LocalVariableBinding localVariableBinding() {
 	return this.expression.localVariableBinding();
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return this.expression.nullStatus(flowInfo);
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	return this.expression.nullStatus(flowInfo, flowContext);
 }
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
index 4f5c61d..9fa2410 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Patrick Wienands <pwienands@abit.de> - Contribution for bug 393749
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -69,14 +71,20 @@ public class Clinit extends AbstractMethodDeclaration {
 			flowInfo = flowInfo.mergedWith(staticInitializerFlowContext.initsOnReturn);
 			FieldBinding[] fields = this.scope.enclosingSourceType().fields();
 			for (int i = 0, count = fields.length; i < count; i++) {
-				FieldBinding field;
-				if ((field = fields[i]).isStatic()
-					&& field.isFinal()
-					&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {
-					this.scope.problemReporter().uninitializedBlankFinalField(
-						field,
-						this.scope.referenceType().declarationOf(field.original()));
-					// can complain against the field decl, since only one <clinit>
+				FieldBinding field = fields[i];
+				if (field.isStatic()) {
+					if (!flowInfo.isDefinitelyAssigned(field)) {
+						if (field.isFinal()) {
+							this.scope.problemReporter().uninitializedBlankFinalField(
+									field,
+									this.scope.referenceType().declarationOf(field.original()));
+							// can complain against the field decl, since only one <clinit>
+						} else if (field.isNonNull()) {
+							this.scope.problemReporter().uninitializedNonNullField(
+									field,
+									this.scope.referenceType().declarationOf(field.original()));
+						}
+					}
 				}
 			}
 			// check static initializers thrown exceptions
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
index 11074dd..3ab010e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -77,7 +78,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 	return FlowInfo.NON_NULL;
 	// we may have complained on checkNPE, but we avoid duplicate error
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index aa36cb9..8a58a10 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -14,6 +14,7 @@
  * 							bug 354554 - [null] conditional with redundant condition yields weak error message
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -75,6 +76,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		this.trueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);
 		trueFlowInfo = this.valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);
 
+		// may need to fetch this null status before expireNullCheckedFieldInfo():
+		int preComputedTrueNullStatus = -1;
+		if (currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) {
+			preComputedTrueNullStatus = this.valueIfTrue.nullStatus(trueFlowInfo, flowContext);
+			// wipe information that was meant only for valueIfTrue:
+			flowContext.expireNullCheckedFieldInfo();
+		}
+
 		// process the if-false part
 		FlowInfo falseFlowInfo = flowInfo.initsWhenFalse().copy();
 		if (isConditionOptimizedTrue) {
@@ -94,10 +103,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		FlowInfo mergedInfo;
 		if (isConditionOptimizedTrue){
 			mergedInfo = trueFlowInfo.addPotentialInitializationsFrom(falseFlowInfo);
-			this.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo);
+			if (preComputedTrueNullStatus != -1) {
+				this.nullStatus = preComputedTrueNullStatus;
+			} else { 
+				this.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo, flowContext);
+			}
 		} else if (isConditionOptimizedFalse) {
 			mergedInfo = falseFlowInfo.addPotentialInitializationsFrom(trueFlowInfo);
-			this.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo);
+			this.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo, flowContext);
 		} else {
 			// this block must meet two conflicting requirements (see https://bugs.eclipse.org/324178):
 			// (1) For null analysis of "Object o2 = (o1 != null) ? o1 : new Object();" we need to distinguish
@@ -110,7 +123,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			//     (regardless of the evaluation of the condition).
 			
 			// to support (1) use the infos of both branches originating from the condition for computing the nullStatus:
-			computeNullStatus(trueFlowInfo, falseFlowInfo);
+			computeNullStatus(preComputedTrueNullStatus, trueFlowInfo, falseFlowInfo, flowContext);
 			
 			// to support (2) we split the true/false branches according to their inner structure. Consider this:
 			// if (b ? false : (true && (v = false))) return v; -- ok
@@ -153,11 +166,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return mergedInfo;
 	}
 
-	private void computeNullStatus(FlowInfo trueBranchInfo, FlowInfo falseBranchInfo) {
+	private void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {
 		// given that the condition cannot be optimized to a constant 
 		// we now merge the nullStatus from both branches:
-		int ifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo);
-		int ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo);
+		if (ifTrueNullStatus == -1) { // has this status been pre-computed?
+			ifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo, flowContext);
+		}
+		int ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo, flowContext);
 
 		if (ifTrueNullStatus == ifFalseNullStatus) {
 			this.nullStatus = ifTrueNullStatus;
@@ -374,7 +389,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return this.nullStatus;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 63a1948..1d99bcf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -14,6 +14,8 @@
  *								bug 361407 - Resource leak warning when resource is assigned to a field outside of constructor
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 383690 - [compiler] location of error re uninitialized final field should be aligned
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -150,12 +152,16 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 
 		// propagate to statements
 		if (this.statements != null) {
+			boolean enableSyntacticNullAnalysisForFields = this.scope.compilerOptions().enableSyntacticNullAnalysisForFields;
 			int complaintLevel = (nonStaticFieldInfoReachMode & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 			for (int i = 0, count = this.statements.length; i < count; i++) {
 				Statement stat = this.statements[i];
 				if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 					flowInfo = stat.analyseCode(this.scope, constructorContext, flowInfo);
 				}
+				if (enableSyntacticNullAnalysisForFields) {
+					constructorContext.expireNullCheckedFieldInfo();
+				}
 			}
 		}
 		// check for missing returning path
@@ -168,21 +174,27 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=235781
 		// flowInfo.setReachMode(initialReachMode);
 
-		// check missing blank final field initializations
+		// check missing blank final field initializations (plus @NonNull)
 		if ((this.constructorCall != null)
 			&& (this.constructorCall.accessMode != ExplicitConstructorCall.This)) {
 			flowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);
 			FieldBinding[] fields = this.binding.declaringClass.fields();
 			for (int i = 0, count = fields.length; i < count; i++) {
-				FieldBinding field;
-				if ((!(field = fields[i]).isStatic())
-					&& field.isFinal()
-					&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {
-					this.scope.problemReporter().uninitializedBlankFinalField(
-						field,
-						((this.bits & ASTNode.IsDefaultConstructor) != 0)
-								? (ASTNode) this.scope.referenceType().declarationOf(field.original())
-								: this);
+				FieldBinding field = fields[i];
+				if (!field.isStatic() && !flowInfo.isDefinitelyAssigned(field)) {
+					if (field.isFinal()) {
+						this.scope.problemReporter().uninitializedBlankFinalField(
+								field,
+								((this.bits & ASTNode.IsDefaultConstructor) != 0)
+									? (ASTNode) this.scope.referenceType().declarationOf(field.original())
+									: this);
+					} else if (field.isNonNull()) {
+							this.scope.problemReporter().uninitializedNonNullField(
+								field,
+								((this.bits & ASTNode.IsDefaultConstructor) != 0) 
+									? (ASTNode) this.scope.referenceType().declarationOf(field.original())
+									: this);
+					}
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 6e4a013..8ede946 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -7,7 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -24,28 +27,67 @@ public class EqualExpression extends BinaryExpression {
 		super(left,right,operator);
 	}
 	private void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {
-		int rightStatus = this.right.nullStatus(flowInfo);
-		int leftStatus = this.left.nullStatus(flowInfo);
-		// check if either is a method annotated @NonNull and compared to null:
+
+		// collect null status of child nodes:
+		int rightStatus = this.right.nullStatus(flowInfo, flowContext);
+		int leftStatus = this.left.nullStatus(flowInfo, flowContext);
+
+		boolean leftNonNullChecked = false;
+		boolean rightNonNullChecked = false;
+
+		// check if either is a non-local expression known to be nonnull and compared to null, candidates are
+		// - method/field annotated @NonNull
+		// - allocation expression, some literals, this reference (see inside expressionNonNullComparison(..))
+		// these checks do not leverage the flowInfo.
+		boolean checkEquality = ((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL;
 		if (leftStatus == FlowInfo.NON_NULL && rightStatus == FlowInfo.NULL) {
-			if (this.left instanceof MessageSend) { 
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);
-			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
+			leftNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.left, checkEquality);
 		} else if (leftStatus == FlowInfo.NULL && rightStatus == FlowInfo.NON_NULL) {
-			if (this.right instanceof MessageSend) {
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.right).binding, this.right);
+			rightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkEquality);
+		}
+		
+		// perform flowInfo-based checks for variables and record info for syntactic null analysis for fields:
+		if (!leftNonNullChecked) {
+			LocalVariableBinding local = this.left.localVariableBinding();
+			if (local != null) {
+				if ((local.type.tagBits & TagBits.IsBaseType) == 0) {
+					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
+				}
+			} else if (this.left instanceof Reference
+							&& ((!checkEquality && rightStatus == FlowInfo.NULL) || (checkEquality && rightStatus == FlowInfo.NON_NULL))
+							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields)
+			{
+				FieldBinding field = ((Reference)this.left).lastFieldBinding();
+				if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+					flowContext.recordNullCheckedFieldReference((Reference) this.left, 1);
+				}
 			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
 		}
-
-		LocalVariableBinding local = this.left.localVariableBinding();
-		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
+		if (!rightNonNullChecked) {
+			LocalVariableBinding local = this.right.localVariableBinding();
+			if (local != null) { 
+				if ((local.type.tagBits & TagBits.IsBaseType) == 0) {
+					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
+				}
+			} else if (this.right instanceof Reference
+							&& ((!checkEquality && leftStatus == FlowInfo.NULL) || (checkEquality && leftStatus == FlowInfo.NON_NULL))
+							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields) 
+			{
+				FieldBinding field = ((Reference)this.right).lastFieldBinding();
+				if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+					flowContext.recordNullCheckedFieldReference((Reference) this.right, 1);
+				}				
+			}
 		}
-		local = this.right.localVariableBinding();
-		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
+
+		// handle reachability:
+		if (leftNonNullChecked || rightNonNullChecked) {
+			// above checks have not propagated unreachable into the corresponding branch, do it now:
+			if (checkEquality) {
+				initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			} else {
+				initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			}
 		}
 	}
 	private void checkVariableComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse, LocalVariableBinding local, int nullStatus, Expression reference) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index ab9a306..3d336da 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -7,9 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *								bug 292478 - Report potentially null across variable assignment
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -38,6 +40,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.problem.ShouldNotImplement;
 import org.eclipse.jdt.internal.compiler.util.Messages;
@@ -519,14 +522,21 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 }
 
 /**
- * Check the local variable of this expression, if any, against potential NPEs
- * given a flow context and an upstream flow info. If so, report the risk to
- * the context. Marks the local as checked, which affects the flow info.
+ * Check this expression against potential NPEs, which may occur:
+ * <ul>
+ * <li>if the expression is the receiver in a field access, qualified allocation, array reference or message send
+ * 		incl. implicit message sends like it happens for the collection in a foreach statement.</li>
+ * <li>if the expression is subject to unboxing</li>
+ * <li>if the expression is the exception in a throw statement</li>
+ * </ul>
+ * If a risk of NPE is detected report it to the context.
+ * If the expression denotes a local variable, mark it as checked, which affects the flow info.
  * @param scope the scope of the analysis
  * @param flowContext the current flow context
  * @param flowInfo the upstream flow info; caveat: may get modified
+ * @return could this expression be checked by the current implementation?
  */
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	LocalVariableBinding local = localVariableBinding();
 	if (local != null &&
 			(local.type.tagBits & TagBits.IsBaseType) == 0) {
@@ -543,7 +553,9 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 		if (flowContext.initsOnFinally != null) {
 			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
+		return true;
 	}
+	return false; // not checked
 }
 
 public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {
@@ -865,11 +877,11 @@ public void markAsNonNull() {
 	this.bits |= ASTNode.IsNonNull;
 }
 
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 
 	if (/* (this.bits & IsNonNull) != 0 || */
 		this.constant != null && this.constant != Constant.NotAConstant)
-	return FlowInfo.NON_NULL; // constant expression cannot be null
+		return FlowInfo.NON_NULL; // constant expression cannot be null
 
 	LocalVariableBinding local = localVariableBinding();
 	if (local != null)
@@ -1112,4 +1124,13 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 public void traverse(ASTVisitor visitor, ClassScope scope) {
 	// nothing to do
 }
+
+/**
+ * Used on the lhs of an assignment for detecting null spec violation.
+ * If this expression represents a null-annotated variable return the variable binding,
+ * otherwise null.
+*/
+public VariableBinding nullAnnotatedVariableBinding() {
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index c77899b..0c7eec1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -77,6 +78,16 @@ public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowCon
 				.unconditionalInits();
 		flowInfo.markAsDefinitelyAssigned(this.binding);
 	}
+	if (this.initialization != null) {
+		if (this.binding.isNonNull()) {
+			int nullStatus = this.initialization.nullStatus(flowInfo, flowContext);
+			// check against annotation @NonNull:
+			if (nullStatus != FlowInfo.NON_NULL) {
+				char[][] annotationName = initializationScope.environment().getNonNullAnnotationName();
+				initializationScope.problemReporter().nullityMismatch(this.initialization, this.initialization.resolvedType, this.binding.type, nullStatus, annotationName);
+			}
+		}
+	}
 	return flowInfo;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index 855d700..fa04bbf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -7,7 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -23,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
@@ -35,6 +39,7 @@ import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 
 public class FieldReference extends Reference implements InvocationSite {
 
@@ -107,6 +112,14 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			// assigning a final field outside an initializer or constructor or wrong reference
 			currentScope.problemReporter().cannotAssignToFinalField(this.binding, this);
 		}
+	} else if (this.binding.isNonNull()) {
+		// in a context where it can be assigned?
+		if (   !isCompound
+			&& this.receiver.isThis()
+			&& !(this.receiver instanceof QualifiedThisReference)
+			&& ((this.receiver.bits & ASTNode.ParenthesizedMASK) == 0)) { // (this).x is forbidden
+			flowInfo.markAsDefinitelyAssigned(this.binding);
+		}		
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 	if (!this.binding.isStatic()) {
@@ -149,6 +162,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (flowContext.isNullcheckedFieldAccess(this)) {
+		return true; // enough seen
+	}
+	return checkNullableFieldDereference(scope, this.binding, this.nameSourcePosition);
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -427,6 +447,58 @@ public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream
 public TypeBinding[] genericTypeArguments() {
 	return null;
 }
+
+public boolean isEquivalent(Reference reference) {
+	// only consider field references relative to "this":
+	if (this.receiver.isThis() && !(this.receiver instanceof QualifiedThisReference)) {
+		// current is a simple "this.f1"
+		char[] otherToken = null;
+		// matching 'reference' could be "f1" or "this.f1":
+		if (reference instanceof SingleNameReference) {
+			otherToken = ((SingleNameReference) reference).token;
+		} else if (reference instanceof FieldReference) {
+			FieldReference fr = (FieldReference) reference;
+			if (fr.receiver.isThis() && !(fr.receiver instanceof QualifiedThisReference)) {
+				otherToken = fr.token;
+			}		
+		}
+		return otherToken != null && CharOperation.equals(this.token, otherToken);
+	} else {
+		// search deeper for "this" inside:
+		char[][] thisTokens = getThisFieldTokens(1);
+		if (thisTokens == null) {
+			return false;
+		}
+		// other can be "this.f1.f2", too, or "f1.f2":
+		char[][] otherTokens = null;
+		if (reference instanceof FieldReference) {
+			otherTokens = ((FieldReference) reference).getThisFieldTokens(1);
+		} else if (reference instanceof QualifiedNameReference) {
+			if (((QualifiedNameReference)reference).binding instanceof LocalVariableBinding)
+				return false; // initial variable mismatch: local (from f1.f2) vs. field (from this.f1.f2)
+			otherTokens = ((QualifiedNameReference) reference).tokens;
+		}
+		return CharOperation.equals(thisTokens, otherTokens);
+	}
+}
+
+private char[][] getThisFieldTokens(int nestingCount) {
+	char[][] result = null;
+	if (this.receiver.isThis() && ! (this.receiver instanceof QualifiedThisReference)) {
+		// found an inner-most this-reference, start building the token array:
+		result = new char[nestingCount][];
+		// fill it front to tail while traveling back out:
+		result[0] = this.token;
+	} else if (this.receiver instanceof FieldReference) {
+		result = ((FieldReference)this.receiver).getThisFieldTokens(nestingCount+1);
+		if (result != null) {
+			// front to tail: outermost is last:
+			result[result.length-nestingCount] = this.token;
+		}
+	}
+	return result;
+}
+
 public boolean isSuperAccess() {
 	return this.receiver.isSuper();
 }
@@ -435,6 +507,10 @@ public boolean isTypeAccess() {
 	return this.receiver != null && this.receiver.isTypeReference();
 }
 
+public FieldBinding lastFieldBinding() {
+	return this.binding;
+}
+
 /*
  * No need to emulate access to protected fields since not implicitly accessed
  */
@@ -480,10 +556,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -668,4 +740,12 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 	}
 	visitor.endVisit(this, scope);
 }
+
+public VariableBinding nullAnnotatedVariableBinding() {
+	if (this.binding != null
+			&& ((this.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)) {
+		return this.binding;
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 4cfba98..0521cb4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -104,6 +105,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		thenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);
 	}
+	// any null check from the condition is now expired
+	flowContext.expireNullCheckedFieldInfo();
 	// code gen: optimizing the jump around the ELSE part
 	if ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 		this.bits |= ASTNode.ThenExit;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 92a05a1..3703612 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -42,6 +44,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// no impact upon enclosing try context
 		return FlowInfo.conditional(initsWhenTrue, flowInfo.copy());
 	}
+	if (this.expression instanceof Reference && currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) {
+		FieldBinding field = ((Reference)this.expression).lastFieldBinding();
+		if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+			flowContext.recordNullCheckedFieldReference((Reference) this.expression, 1);
+		}
+	}
 	return this.expression.analyseCode(currentScope, flowContext, flowInfo).
 			unconditionalInits();
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index a043c94..988bc5c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -19,6 +19,7 @@
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -113,7 +114,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	else
 		FakedTrackingVariable.cleanUpAfterAssignment(currentScope, Binding.LOCAL, this.initialization);
 
-	int nullStatus = this.initialization.nullStatus(flowInfo);
+	int nullStatus = this.initialization.nullStatus(flowInfo, flowContext);
 	if (!flowInfo.isDefinitelyAssigned(this.binding)){// for local variable debug attributes
 		this.bits |= FirstAssignmentToLocal;
 	} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index e990315..394a8ef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -21,6 +21,8 @@
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -185,12 +187,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
 	// account for pot. exceptions thrown by method execution
 	flowContext.recordAbruptExit();
+	flowContext.expireNullCheckedFieldInfo(); // no longer trust this info after any message send
 	return flowInfo;
 }
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	super.checkNPE(scope, flowContext, flowInfo);
-	if ((nullStatus(flowInfo) & FlowInfo.POTENTIALLY_NULL) != 0)
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	// message send as a receiver
+	if ((nullStatus(flowInfo, flowContext) & FlowInfo.POTENTIALLY_NULL) != 0)
 		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+	return true; // done all possible checking
 }
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
@@ -344,7 +348,7 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 		}
 	}
 }
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 	if (this.binding.isValidBinding()) {
 		// try to retrieve null status of this message send from an annotation of the called method:
 		long tagBits = this.binding.tagBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 80c18ec..c121c22 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -12,6 +12,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -113,12 +114,16 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			}
 			// propagate to statements
 			if (this.statements != null) {
+				boolean enableSyntacticNullAnalysisForFields = this.scope.compilerOptions().enableSyntacticNullAnalysisForFields;
 				int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 				for (int i = 0, count = this.statements.length; i < count; i++) {
 					Statement stat = this.statements[i];
 					if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 						flowInfo = stat.analyseCode(this.scope, methodContext, flowInfo);
 					}
+					if (enableSyntacticNullAnalysisForFields) {
+						methodContext.expireNullCheckedFieldInfo();
+					}
 				}
 			} else {
 				// method with empty body should not be flagged as static.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
index 963b81b..b2f0910 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -29,12 +31,23 @@ public NameReference() {
 	this.bits |= Binding.TYPE | Binding.VARIABLE; // restrictiveFlag
 }
 
+/** 
+ * Use this method only when sure that the current reference is <strong>not</strong>
+ * a chain of several fields (QualifiedNameReference with more than one field).
+ * Otherwise use {@link #lastFieldBinding()}.
+ */
 public FieldBinding fieldBinding() {
 	//this method should be sent ONLY after a check against isFieldReference()
 	//check its use doing senders.........
 	return (FieldBinding) this.binding ;
 }
 
+public FieldBinding lastFieldBinding() {
+	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD)
+		return fieldBinding(); // most subclasses only refer to one field anyway
+	return null;
+}
+
 public boolean isSuperAccess() {
 	return false;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
index aa77770..5e5bbbd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
@@ -7,11 +7,14 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
@@ -49,7 +52,7 @@ public class NullLiteral extends MagicLiteral {
 		return TypeBinding.NULL;
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return FlowInfo.NULL;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 443391d..111714a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     Stephan Herrmann - Contributions for
+ *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -41,13 +43,16 @@ public class OR_OR_Expression extends BinaryExpression {
 			 // need to be careful of scenario:
 			//		(x || y) || !z, if passing the left info to the right, it would be swapped by the !
 			FlowInfo mergedInfo = this.left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			flowContext.expireNullCheckedFieldInfo();
 			mergedInfo = this.right.analyseCode(currentScope, flowContext, mergedInfo);
+			flowContext.expireNullCheckedFieldInfo();
 			this.mergedInitStateIndex =
 				currentScope.methodScope().recordInitializationStates(mergedInfo);
 			return mergedInfo;
 		}
 
 		FlowInfo leftInfo = this.left.analyseCode(currentScope, flowContext, flowInfo);
+		flowContext.expireNullCheckedFieldInfo();
 
 		 // need to be careful of scenario:
 		//		(x || y) || !z, if passing the left info to the right, it would be swapped by the !
@@ -63,6 +68,7 @@ public class OR_OR_Expression extends BinaryExpression {
 			}
 		}
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
+		flowContext.expireNullCheckedFieldInfo();
 		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
 			this.left.checkNPE(currentScope, flowContext, flowInfo);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
index f43174d..8cd4584 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
@@ -8,9 +8,12 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Perry James - nullStatus method improvement (165346)
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -1556,7 +1559,7 @@ public abstract class OperatorExpression extends Expression implements OperatorI
 		return "unknown operator"; //$NON-NLS-1$
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return FlowInfo.NON_NULL;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 9045fe4..60aa97f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -13,6 +13,8 @@
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -103,7 +105,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
 			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
+				checkInternalNPE(currentScope, flowContext, flowInfo, true);
 			}
 	}
 
@@ -164,6 +166,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			}
 		}
 	}
+	// note: not covering def.assign for @NonNull: QNR cannot provably refer to a variable of the current object
 	manageSyntheticAccessIfNecessary(currentScope, lastFieldBinding, -1 /*write-access*/, flowInfo);
 
 	return flowInfo;
@@ -209,9 +212,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			} else if (localBinding.useFlag == LocalVariableBinding.UNUSED) {
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
-			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
-			}
+	}
+	if (needValue) {
+		checkInternalNPE(currentScope, flowContext, flowInfo, true);
 	}
 	if (needValue) {
 		manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
@@ -228,9 +231,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
-	// cannot override localVariableBinding because this would project o.m onto o when
-	// analyzing assignments
+/* check if any dot in this QNR may trigger an NPE. */
+private void checkInternalNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
 	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.LOCAL) {
 		LocalVariableBinding local = (LocalVariableBinding) this.binding;
 		if (local != null &&
@@ -247,6 +249,38 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 			}
 		}
 	}
+	if (this.otherBindings != null) {
+		if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {
+			// is the first field dereferenced annotated Nullable? If so, report immediately
+			checkNullableFieldDereference(scope, (FieldBinding) this.binding, this.sourcePositions[0]);
+		}
+		// look for annotated fields, they do not depend on flow context -> check immediately:
+		int length = this.otherBindings.length - 1; // don't check the last binding
+		for (int i = 0; i < length; i++) {
+			checkNullableFieldDereference(scope, this.otherBindings[i], this.sourcePositions[i+1]);
+		}
+	}
+}
+
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (super.checkNPE(scope, flowContext, flowInfo)) {
+		return true;
+	}
+	FieldBinding fieldBinding = null;
+	long position = 0L;
+	if (this.otherBindings == null) {
+		if ((this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+			fieldBinding = (FieldBinding) this.binding;
+			position = this.sourcePositions[0];
+		}
+	} else {
+		fieldBinding = this.otherBindings[this.otherBindings.length - 1];
+		position = this.sourcePositions[this.sourcePositions.length - 1];
+	}
+	if (fieldBinding != null) {
+		return checkNullableFieldDereference(scope, fieldBinding, position);
+	}
+	return false;
 }
 
 /**
@@ -781,6 +815,28 @@ public TypeBinding getOtherFieldBindings(BlockScope scope) {
 			: type;
 }
 
+public boolean isEquivalent(Reference reference) {
+	if (reference instanceof FieldReference) {
+		return reference.isEquivalent(this); // comparison FR <-> QNR is implemented only once
+	}
+	if (!(reference instanceof QualifiedNameReference)) return false;
+	// straight-forward test of equality of two QNRs:
+	QualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;
+	if (this.tokens.length != qualifiedReference.tokens.length) return false;
+	if (this.binding != qualifiedReference.binding) return false;
+	if (this.otherBindings != null) {
+		if (qualifiedReference.otherBindings == null) return false;
+		int len = this.otherBindings.length;
+		if (len != qualifiedReference.otherBindings.length) return false;
+		for (int i=0; i<len; i++) {
+			if (this.otherBindings[i] != qualifiedReference.otherBindings[i]) return false;
+		}
+	} else if (qualifiedReference.otherBindings != null) {
+		return false;
+	}
+	return true;
+}
+
 public boolean isFieldAccess() {
 	if (this.otherBindings != null) {
 		return true;
@@ -788,6 +844,15 @@ public boolean isFieldAccess() {
 	return (this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD;
 }
 
+public FieldBinding lastFieldBinding() {
+	if (this.otherBindings != null) {
+		return this.otherBindings[this.otherBindings.length - 1];		
+	} else if (this.binding != null && (this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+		return (FieldBinding) this.binding;
+	}
+	return null;
+}
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -842,10 +907,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBindi
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -1073,4 +1134,19 @@ public void traverse(ASTVisitor visitor, ClassScope scope) {
 public String unboundReferenceErrorName() {
 	return new String(this.tokens[0]);
 }
+
+public VariableBinding nullAnnotatedVariableBinding() {
+	if (this.binding != null && isFieldAccess()) {
+		FieldBinding fieldBinding;
+		if (this.otherBindings == null) {
+			fieldBinding = (FieldBinding) this.binding;
+		} else {
+			fieldBinding = this.otherBindings[this.otherBindings.length - 1];
+		}
+		if (fieldBinding.isNullable() || fieldBinding.isNonNull()) {
+			return fieldBinding;
+		}
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index 1196cdc..cc8146c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -7,7 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -22,6 +25,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
@@ -38,6 +42,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (flowContext.isNullcheckedFieldAccess(this)) {
+		return true; // enough seen
+	}
+	return super.checkNPE(scope, flowContext, flowInfo);
+}
+
+protected boolean checkNullableFieldDereference(Scope scope, FieldBinding field, long sourcePosition) {
+	if ((field.tagBits & TagBits.AnnotationNullable) != 0) {
+		scope.problemReporter().nullableFieldDereference(field, sourcePosition);
+		return true;
+	}
+	return false;
+}
+
 public FieldBinding fieldBinding() {
 	//this method should be sent one FIELD-tagged references
 	//  (ref.bits & BindingIds.FIELD != 0)()
@@ -92,6 +111,34 @@ public abstract void generateCompoundAssignment(BlockScope currentScope, CodeStr
 
 public abstract void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired);
 
+/** 
+ * Is the given reference equivalent to the receiver, 
+ * meaning that both denote the same path of field reads?
+ * Used from {@link FlowContext#isNullcheckedFieldAccess(Reference)}.
+ */
+public boolean isEquivalent(Reference reference) {
+	return false;
+}
+
+public FieldBinding lastFieldBinding() {
+	// override to answer the field designated by the entire reference
+	// (as opposed to fieldBinding() which answers the first field in a QNR)
+	return null;
+}
+
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	FieldBinding fieldBinding = lastFieldBinding();
+	if (fieldBinding != null) {
+		if (fieldBinding.isNonNull() || flowContext.isNullcheckedFieldAccess(this)) {
+			return FlowInfo.NON_NULL;
+		} else if (fieldBinding.isNullable()) {
+			return FlowInfo.POTENTIALLY_NULL;
+		}
+		return FlowInfo.UNKNOWN;
+	}
+	return super.nullStatus(flowInfo, flowContext);
+}
+
 /* report if a private field is only read from a 'special operator',
  * i.e., in a postIncrement expression or a compound assignment,
  * where the information is never flowing out off the field. */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 53ed355..319ec57 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -21,6 +21,7 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -55,7 +56,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			this.expression.checkNPE(currentScope, flowContext, flowInfo);
 		}
 		if (flowInfo.reachMode() == FlowInfo.REACHABLE)
-			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo));
+			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo, flowContext));
 		if (currentScope.compilerOptions().analyseResourceLeaks) {
 			FakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression, flowInfo, flowContext);
 			if (trackingVariable != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index c635320..411f14b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -7,8 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 292478 - Report potentially null across variable assignment,
- *     											    Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 292478 - Report potentially null across variable assignment,
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -118,6 +121,9 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				} else {
 					currentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);
 				}
+			} else if (!isCompound && fieldBinding.isNonNull()) {
+				// record assignment for detecting uninitialized non-null fields:
+				flowInfo.markAsDefinitelyAssigned(fieldBinding);
 			}
 			if (!fieldBinding.isStatic()) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
@@ -239,6 +245,17 @@ public TypeBinding checkFieldAccess(BlockScope scope) {
 
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (!super.checkNPE(scope, flowContext, flowInfo)) {
+		VariableBinding var = nullAnnotatedVariableBinding();
+		if (var instanceof FieldBinding) {
+			checkNullableFieldDereference(scope, (FieldBinding) var, ((long)this.sourceStart<<32)+this.sourceEnd);
+			return true;
+		}
+	}
+	return false;
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -792,6 +809,19 @@ public TypeBinding[] genericTypeArguments() {
 	return null;
 }
 
+public boolean isEquivalent(Reference reference) {
+	char[] otherToken = null;
+	if (reference instanceof SingleNameReference) {
+		otherToken = ((SingleNameReference) reference).token;
+	} else if (reference instanceof FieldReference) {
+		// test for comparison "f1" vs. "this.f1":
+		FieldReference fr = (FieldReference) reference;
+		if (fr.receiver.isThis() && !(fr.receiver instanceof QualifiedThisReference))
+			otherToken = fr.token;
+	}
+	return otherToken != null && CharOperation.equals(this.token, otherToken);
+}
+
 /**
  * Returns the local variable referenced by this node. Can be a direct reference (SingleNameReference)
  * or thru a cast expression etc...
@@ -806,6 +836,16 @@ public LocalVariableBinding localVariableBinding() {
 	return null;
 }
 
+public VariableBinding nullAnnotatedVariableBinding() {
+	switch (this.bits & ASTNode.RestrictiveFlagMASK) {
+		case Binding.FIELD : // reading a field
+		case Binding.LOCAL : // reading a local variable
+			if ((((VariableBinding)this.binding).tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)
+				return (VariableBinding) this.binding;
+	}
+	return null;
+}
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -852,22 +892,7 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	if (this.constant != null && this.constant != Constant.NotAConstant) {
-		return FlowInfo.NON_NULL; // constant expression cannot be null
-	}
-	switch (this.bits & ASTNode.RestrictiveFlagMASK) {
-		case Binding.FIELD : // reading a field
-			return FlowInfo.UNKNOWN;
-		case Binding.LOCAL : // reading a local variable
-			LocalVariableBinding local = (LocalVariableBinding) this.binding;
-			if (local != null)
-				return flowInfo.nullStatus(local);
-	}
-	return FlowInfo.NON_NULL; // never get there
-}
-
-	/**
+/**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#postConversionType(Scope)
  */
 public TypeBinding postConversionType(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index c4b035b..625dce2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -15,6 +15,8 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370930 - NonNull annotation not considered for enhanced for loops
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -91,7 +93,7 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 			if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
 				TypeBinding expectedType = methodBinding.parameters[i];
 				Expression argument = arguments[i];
-				int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+				int nullStatus = argument.nullStatus(flowInfo, flowContext); // slight loss of precision: should also use the null info from the receiver.
 				if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
 					flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 			}
@@ -99,19 +101,17 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 	}
 }
 
-/** Check null-ness of 'local' against a possible null annotation */
+/** Check null-ness of 'var' against a possible null annotation */
 protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext,
-												   LocalVariableBinding local, int nullStatus, Expression expression, TypeBinding providedType)
+												   VariableBinding var, int nullStatus, Expression expression, TypeBinding providedType)
 {
-	if (local != null) {
-		if ((local.tagBits & TagBits.AnnotationNonNull) != 0
-				&& nullStatus != FlowInfo.NON_NULL) {
-			flowContext.recordNullityMismatch(currentScope, expression, providedType, local.type, nullStatus);
-			return FlowInfo.NON_NULL;
-		} else if ((local.tagBits & TagBits.AnnotationNullable) != 0
-				&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
-			return FlowInfo.POTENTIALLY_NULL;			// -> use more specific info from the annotation
-		}
+	if ((var.tagBits & TagBits.AnnotationNonNull) != 0
+			&& nullStatus != FlowInfo.NON_NULL) {
+		flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, nullStatus);
+		return FlowInfo.NON_NULL;
+	} else if ((var.tagBits & TagBits.AnnotationNullable) != 0
+			&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
+		return FlowInfo.POTENTIALLY_NULL;			// -> use more specific info from the annotation
 	}
 	return nullStatus;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index 45b6447..0145ad3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -7,6 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -56,6 +59,10 @@ public class ThisReference extends Reference {
 		return true;
 	}
 
+	public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+		return true; // never problematic
+	}
+
 	/*
 	 * @see Reference#generateAssignment(...)
 	 */
@@ -98,10 +105,6 @@ public class ThisReference extends Reference {
 		return true ;
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
-		return FlowInfo.NON_NULL;
-	}
-
 	public StringBuffer printExpression(int indent, StringBuffer output){
 
 		if (isImplicitThis()) return output;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index d089b82..a8ba54a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -410,7 +410,9 @@ public MethodBinding createDefaultConstructorWithBinding(MethodBinding inherited
 			sourceType); //declaringClass
 	constructor.binding.tagBits |= (inheritedConstructorBinding.tagBits & TagBits.HasMissingType);
 	constructor.binding.modifiers |= ExtraCompilerModifiers.AccIsDefaultConstructor;
-	if (inheritedConstructorBinding.parameterNonNullness != null) { // this implies that annotation based null analysis is enabled
+	if (inheritedConstructorBinding.parameterNonNullness != null // this implies that annotation based null analysis is enabled
+			&& argumentsLength > 0) 
+	{
 		// copy nullness info from inherited constructor to the new constructor:
 		int len = inheritedConstructorBinding.parameterNonNullness.length;
 		System.arraycopy(inheritedConstructorBinding.parameterNonNullness, 0, 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
index 261bf8e..81b9323 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -33,9 +35,11 @@ public FlowInfo analyseCode(
 		FlowInfo flowInfo) {
 	this.expression.checkNPE(currentScope, flowContext, flowInfo);
 	if (((this.bits & OperatorMASK) >> OperatorSHIFT) == NOT) {
-		return this.expression.
+		flowInfo = this.expression.
 			analyseCode(currentScope, flowContext, flowInfo).
 			asNegatedCondition();
+		flowContext.expireNullCheckedFieldInfo();
+		return flowInfo;
 	} else {
 		return this.expression.
 			analyseCode(currentScope, flowContext, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 2998097..d8e5ddd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -13,6 +13,7 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -70,6 +71,12 @@ public class FlowContext implements TypeConstants {
 	// array to store the provided and expected types from the potential error location (for display in error messages):
 	public TypeBinding[][] providedExpectedTypes = null;
 
+	// record field references known to be non-null
+	//   this array will never shrink, only grow. reset happens by nulling the first cell
+	//   adding elements after reset ensures that the valid part of the array is always null-terminated
+	private Reference[] nullCheckedFieldReferences = null;
+	private int timeToLiveForNullCheckInfo = -1;
+
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
 	/**
@@ -109,8 +116,73 @@ public FlowContext(FlowContext parent, ASTNode associatedNode) {
 		}
 		this.initsOnFinally = parent.initsOnFinally;
 		this.conditionalLevel = parent.conditionalLevel;
+		this.nullCheckedFieldReferences = parent.nullCheckedFieldReferences; // re-use list if there is one
+	}
+}
+
+/**
+ * Record that a reference to a field has been seen in a non-null state.
+ *
+ * @param reference Can be a SingleNameReference, a FieldReference or a QualifiedNameReference resolving to a field
+ * @param timeToLive control how many expire events are needed to expire this information
+ */
+public void recordNullCheckedFieldReference(Reference reference, int timeToLive) {
+	this.timeToLiveForNullCheckInfo = timeToLive;
+	if (this.nullCheckedFieldReferences == null) {
+		// first entry:
+		this.nullCheckedFieldReferences = new Reference[2];
+		this.nullCheckedFieldReferences[0] = reference;
+	} else {
+		int len = this.nullCheckedFieldReferences.length;
+		// insert into first empty slot:
+		for (int i=0; i<len; i++) {
+			if (this.nullCheckedFieldReferences[i] == null) {
+				this.nullCheckedFieldReferences[i] = reference;
+				if (i+1 < len) {
+					this.nullCheckedFieldReferences[i+1] = null; // lazily mark next as empty
+				}
+				return;
+			}
+		}
+		// grow array:
+		System.arraycopy(this.nullCheckedFieldReferences, 0, this.nullCheckedFieldReferences=new Reference[len+2], 0, len);
+		this.nullCheckedFieldReferences[len] = reference;
 	}
 }
+/**
+ * Forget any information about fields that were previously known to be non-null.
+ * 
+ * Will only cause any effect if CompilerOptions.enableSyntacticNullAnalysisForFields
+ * (implicitly by guards before calls to {@link #recordNullCheckedFieldReference(Reference, int)}).
+ */	 
+public void expireNullCheckedFieldInfo() {
+	if (this.nullCheckedFieldReferences != null) {
+		if (--this.timeToLiveForNullCheckInfo == 0) {
+			this.nullCheckedFieldReferences[0] = null; // lazily wipe
+		}
+	}
+}
+
+/** 
+ * Is the given field reference equivalent to a reference that is freshly known to be non-null?
+ * Can only return true if CompilerOptions.enableSyntacticNullAnalysisForFields
+ * (implicitly by guards before calls to {@link #recordNullCheckedFieldReference(Reference, int)}).
+ */
+public boolean isNullcheckedFieldAccess(Reference reference) {
+	if (this.nullCheckedFieldReferences == null)  // always null unless CompilerOptions.enableSyntacticNullAnalysisForFields
+		return false;
+	int len = this.nullCheckedFieldReferences.length;
+	for (int i=0; i<len; i++) {
+		Reference checked = this.nullCheckedFieldReferences[i];
+		if (checked == null) {
+			return false;
+		}
+		if (checked.isEquivalent(reference)) {
+			return true;
+		}
+	}
+	return false;
+}
 
 public BranchLabel breakLabel() {
 	return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 8448f06..667e180 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -18,6 +18,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -164,6 +165,7 @@ public class CompilerOptions {
 	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
 	public static final String OPTION_ReportMissingNonNullByDefaultAnnotation = "org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation";  //$NON-NLS-1$
+	public static final String OPTION_SyntacticNullAnalysisForFields = "org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 	/**
@@ -433,6 +435,9 @@ public class CompilerOptions {
 	/** Should null annotations of overridden methods be inherited? */
 	public boolean inheritNullAnnotations;
 
+	/** Should immediate null-check for fields be considered during null analysis (syntactical match)? */
+	public boolean enableSyntacticNullAnalysisForFields;
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
@@ -823,6 +828,7 @@ public class CompilerOptions {
 			OPTION_ReportNullAnnotationInferenceConflict,
 			OPTION_ReportNullUncheckedConversion,
 			OPTION_ReportRedundantNullAnnotation,
+			OPTION_SyntacticNullAnalysisForFields,
 			OPTION_ReportUnusedTypeParameter,
 			OPTION_InheritNullAnnotations,
 			OPTION_ReportNonnullParameterAnnotationDropped
@@ -1124,6 +1130,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_NonNullByDefaultAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullByDefaultAnnotationName, '.')));
 		optionsMap.put(OPTION_ReportMissingNonNullByDefaultAnnotation, getSeverityString(MissingNonNullByDefaultAnnotation));
 		optionsMap.put(OPTION_ReportUnusedTypeParameter, getSeverityString(UnusedTypeParameter));
+		optionsMap.put(OPTION_SyntacticNullAnalysisForFields, this.enableSyntacticNullAnalysisForFields ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		return optionsMap;
@@ -1284,6 +1291,7 @@ public class CompilerOptions {
 		this.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;
 		this.nonNullByDefaultAnnotationName = DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME;
 		this.intendedDefaultNonNullness = 0;
+		this.enableSyntacticNullAnalysisForFields = false;
 		this.inheritNullAnnotations = false;
 		
 		this.analyseResourceLeaks = true;
@@ -1615,6 +1623,9 @@ public class CompilerOptions {
 				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
 			}
 			if ((optionValue = optionsMap.get(OPTION_ReportMissingNonNullByDefaultAnnotation)) != null) updateSeverity(MissingNonNullByDefaultAnnotation, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_SyntacticNullAnalysisForFields)) != null) {
+				this.enableSyntacticNullAnalysisForFields = ENABLED.equals(optionValue);
+			}
 			if ((optionValue = optionsMap.get(OPTION_InheritNullAnnotations)) != null) {
 				this.inheritNullAnnotations = ENABLED.equals(optionValue);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 6820b80..0e05920 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -15,6 +15,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -444,6 +445,12 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 					this.fields[i].setAnnotations(createAnnotations(binaryField.getAnnotations(), this.environment, missingTypeNames));
 				}
 			}
+			if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				for (int i = 0; i <size; i++) {
+					IBinaryField binaryField = iFields[i];
+					scanFieldForNullAnnotation(binaryField, this.fields[i]);
+				}
+			}
 		}
 	}
 }
@@ -1154,6 +1161,42 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	}
 	return this.storedAnnotations;
 }
+
+void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding) {
+	// global option is checked by caller
+	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
+	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
+	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+		return; // not well-configured to use null annotations
+
+	if (fieldBinding.type == null || fieldBinding.type.isBaseType())
+		return; // null annotations are only applied to reference types
+
+	boolean explicitNullness = false;
+	IBinaryAnnotation[] annotations = field.getAnnotations();
+	if (annotations != null) {
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != Util.C_RESOLVED)
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNonNull;
+				explicitNullness = true;
+				break;
+			}
+			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNullable;
+				explicitNullness = true;
+				break;
+			}
+		}
+	}
+	if (!explicitNullness && (this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+		fieldBinding.tagBits |= TagBits.AnnotationNonNull;
+	}
+}
+
 void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
 	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
 		return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index b27798d..8485b55 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -223,6 +225,17 @@ public Constant constant() {
 	return fieldConstant;
 }
 
+public void fillInDefaultNonNullness(FieldDeclaration sourceField, Scope scope) {
+	if (   this.type != null
+		&& !this.type.isBaseType()
+		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+	{
+		this.tagBits |= TagBits.AnnotationNonNull;
+	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
+		scope.problemReporter().nullAnnotationIsRedundant(sourceField);
+	}
+}
+
 /**
  * X<T> t   -->  LX<TT;>;
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
index 1a46b85..1180893 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
@@ -12,6 +12,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -176,14 +177,6 @@ public class LocalVariableBinding extends VariableBinding {
 		}
 	}
 
-	public boolean isNonNull() {
-		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
-	}
-
-	public boolean isNullable() {
-		return (this.tagBits & TagBits.AnnotationNullable) != 0;
-	}
-
 	// Answer whether the variable binding is a secret variable added for code gen purposes
 	public boolean isSecret() {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index bb36a3d..b7c7027 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -19,6 +19,8 @@
  *								bug 384663 - Package Based Annotation Compilation Error in JDT 3.8/4.2 (works in 3.7.2)
  *								bug 386356 - Type mismatch error with annotations and generics
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 380896 - [compiler][null] Enum constants not recognised as being NonNull.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1424,43 +1426,59 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 		if (fieldDecls[f].binding != field)
 			continue;
 
-			MethodScope initializationScope = field.isStatic()
-				? this.scope.referenceContext.staticInitializerScope
-				: this.scope.referenceContext.initializerScope;
-			FieldBinding previousField = initializationScope.initializedField;
-			try {
-				initializationScope.initializedField = field;
-				FieldDeclaration fieldDecl = fieldDecls[f];
-				TypeBinding fieldType =
-					fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT
-						? initializationScope.environment().convertToRawType(this, false /*do not force conversion of enclosing types*/) // enum constant is implicitly of declaring enum type
-						: fieldDecl.type.resolveType(initializationScope, true /* check bounds*/);
-				field.type = fieldType;
-				field.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
-				if (fieldType == null) {
-					fieldDecl.binding = null;
-					return null;
-				}
-				if (fieldType == TypeBinding.VOID) {
-					this.scope.problemReporter().variableTypeCannotBeVoid(fieldDecl);
-					fieldDecl.binding = null;
-					return null;
-				}
-				if (fieldType.isArrayType() && ((ArrayBinding) fieldType).leafComponentType == TypeBinding.VOID) {
-					this.scope.problemReporter().variableTypeCannotBeVoidArray(fieldDecl);
-					fieldDecl.binding = null;
-					return null;
-				}
-				if ((fieldType.tagBits & TagBits.HasMissingType) != 0) {
-					field.tagBits |= TagBits.HasMissingType;
-				}
-				TypeBinding leafType = fieldType.leafComponentType();
-				if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0) {
-					field.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
+		MethodScope initializationScope = field.isStatic()
+			? this.scope.referenceContext.staticInitializerScope
+			: this.scope.referenceContext.initializerScope;
+		FieldBinding previousField = initializationScope.initializedField;
+		try {
+			initializationScope.initializedField = field;
+			FieldDeclaration fieldDecl = fieldDecls[f];
+			TypeBinding fieldType =
+				fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT
+					? initializationScope.environment().convertToRawType(this, false /*do not force conversion of enclosing types*/) // enum constant is implicitly of declaring enum type
+					: fieldDecl.type.resolveType(initializationScope, true /* check bounds*/);
+			field.type = fieldType;
+			field.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
+			if (fieldType == null) {
+				fieldDecl.binding = null;
+				return null;
+			}
+			if (fieldType == TypeBinding.VOID) {
+				this.scope.problemReporter().variableTypeCannotBeVoid(fieldDecl);
+				fieldDecl.binding = null;
+				return null;
+			}
+			if (fieldType.isArrayType() && ((ArrayBinding) fieldType).leafComponentType == TypeBinding.VOID) {
+				this.scope.problemReporter().variableTypeCannotBeVoidArray(fieldDecl);
+				fieldDecl.binding = null;
+				return null;
+			}
+			if ((fieldType.tagBits & TagBits.HasMissingType) != 0) {
+				field.tagBits |= TagBits.HasMissingType;
+			}
+			TypeBinding leafType = fieldType.leafComponentType();
+			if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0) {
+				field.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
+			}
+
+			// apply null default:
+			LookupEnvironment environment = this.scope.environment();
+			if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				if (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {
+					// enum constants neither have a type declaration nor can they be null
+					field.tagBits |= TagBits.AnnotationNonNull;
+				} else {
+					initializeNullDefault();
+					if (hasNonNullDefault()) {
+						field.fillInDefaultNonNullness(fieldDecl, initializationScope);
+					}
+					// validate null annotation:
+					this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations);
 				}
-			} finally {
-			    initializationScope.initializedField = previousField;
 			}
+		} finally {
+		    initializationScope.initializedField = previousField;
+		}
 		return field;
 	}
 	return null; // should never reach this point
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
index 23c5bbc..53b2bd8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
@@ -7,6 +7,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -52,7 +54,17 @@ public abstract class VariableBinding extends Binding {
 	public final boolean isEffectivelyFinal() {
 		return (this.tagBits & TagBits.IsEffectivelyFinal) != 0;
 	}
-	
+
+	/** Answer true if null annotations are enabled and this field is specified @NonNull */
+	public boolean isNonNull() {
+		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
+	}
+
+	/** Answer true if null annotations are enabled and this field is specified @Nullable */
+	public boolean isNullable() {
+		return (this.tagBits & TagBits.AnnotationNullable) != 0;
+	}
+
 	public char[] readableName() {
 		return this.name;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 7c0bb82..34cf3a3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -22,6 +22,8 @@
  *								bug 376053 - [compiler][resource] Strange potential resource leak problems
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 393719 - [compiler] inconsistent warnings on iteration variables
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -46,6 +48,7 @@ import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
@@ -55,6 +58,7 @@ import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.BranchStatement;
 import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
 import org.eclipse.jdt.internal.compiler.ast.CastExpression;
+import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
@@ -75,6 +79,7 @@ import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
+import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
@@ -119,6 +124,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
@@ -298,6 +304,7 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.VarargsArgumentNeedCast;
 
 		case IProblem.NullLocalVariableReference:
+		case IProblem.NullableFieldReference:
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
@@ -310,9 +317,14 @@ public static int getIrritant(int problemID) {
 		case IProblem.NonNullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableInstanceofYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullExpression:
+		case IProblem.NonNullExpressionComparisonYieldsFalse:
 		case IProblem.RedundantNullCheckOnNonNullMessageSend:
 		case IProblem.RedundantNullCheckOnSpecdNonNullLocalVariable:
 		case IProblem.SpecdNonNullLocalVariableComparisonYieldsFalse:
+		case IProblem.NonNullMessageSendComparisonYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullSpecdField:
+		case IProblem.NonNullSpecdFieldComparisonYieldsFalse:
 			return CompilerOptions.RedundantNullCheck;
 
 		case IProblem.RequiredNonNullButProvidedNull:
@@ -322,6 +334,8 @@ public static int getIrritant(int problemID) {
 		case IProblem.IllegalDefinitionToNonNullParameter:
 		case IProblem.ParameterLackingNullableAnnotation:
 		case IProblem.CannotImplementIncompatibleNullness:
+		case IProblem.UninitializedNonNullField:
+		case IProblem.UninitializedNonNullFieldHintMissingDefault:
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
 			return CompilerOptions.NullSpecViolation;
@@ -5162,6 +5176,92 @@ public void localVariableNullComparedToNonNull(LocalVariableBinding local, ASTNo
 		nodeSourceEnd(local, location));
 }
 
+/**
+ * @param expr expression being compared for null or nonnull
+ * @param checkForNull true if checking for null, false if checking for nonnull 
+ */
+public boolean expressionNonNullComparison(Expression expr, boolean checkForNull) {
+	int problemId = 0;
+	Binding binding = null;
+	String[] arguments = null;
+	int start = 0, end = 0;
+
+	Expression location = expr;
+	// unwrap uninteresting nodes:
+	while (true) {
+		if (expr instanceof Assignment)
+			return false; // don't report against the assignment, but the variable
+		else if (expr instanceof CastExpression)
+			expr = ((CastExpression) expr).expression;
+		else
+			break;
+	}
+	// check all those kinds of expressions that can possible answer NON_NULL from nullStatus():
+	if (expr instanceof MessageSend) {
+		problemId = checkForNull 
+				? IProblem.NonNullMessageSendComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullMessageSend;
+		MethodBinding method = ((MessageSend)expr).binding;
+		binding = method;
+		arguments = new String[] { new String(method.shortReadableName()) };
+		start = location.sourceStart;
+		end = location.sourceEnd;
+	} else if (expr instanceof Reference && !(expr instanceof ThisReference) && !(expr instanceof ArrayReference)) {
+		FieldBinding field = ((Reference)expr).lastFieldBinding();
+		if (field == null) {
+			return false;
+		}
+		if (field.isNonNull()) {
+			problemId = checkForNull
+					? IProblem.NonNullSpecdFieldComparisonYieldsFalse
+					: IProblem.RedundantNullCheckOnNonNullSpecdField;
+			char[][] nonNullName = this.options.nonNullAnnotationName;
+			arguments = new String[] { new String(field.name), 
+									   new String(nonNullName[nonNullName.length-1]) };
+		}
+		binding = field;
+		start = nodeSourceStart(binding, location);
+		end = nodeSourceEnd(binding, location);
+	} else if (expr instanceof AllocationExpression 
+			|| expr instanceof ArrayAllocationExpression 
+			|| expr instanceof ArrayInitializer
+			|| expr instanceof ClassLiteralAccess
+			|| expr instanceof ThisReference) {
+		// fall through to bottom
+	} else if (expr instanceof Literal
+				|| expr instanceof ConditionalExpression) {
+		if (expr instanceof NullLiteral) {
+			needImplementation(location); // reported as nonnull??
+			return false;
+		}
+		if (expr.resolvedType != null && expr.resolvedType.isBaseType()) {
+			// false alarm, auto(un)boxing is involved
+			return false;
+		}
+		// fall through to bottom
+	} else if (expr instanceof BinaryExpression) {
+		if ((expr.bits & ASTNode.ReturnTypeIDMASK) != TypeIds.T_JavaLangString) {
+			// false alarm, primitive types involved, must be auto(un)boxing?
+			return false;
+		}
+		// fall through to bottom
+	} else {
+		needImplementation(expr); // want to see if we get here
+		return false;
+	}
+	if (problemId == 0) {
+		// standard case, fill in details now
+		problemId = checkForNull 
+				? IProblem.NonNullExpressionComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullExpression;
+		start = location.sourceStart;
+		end = location.sourceEnd;
+		arguments = NoArgument;
+	}
+	this.handle(problemId, arguments, arguments, start, end);
+	return true;
+}
+
 public void localVariableNullInstanceof(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.NullLocalVariableInstanceofYieldsFalse);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -5201,6 +5301,18 @@ public void localVariablePotentialNullReference(LocalVariableBinding local, ASTN
 		nodeSourceEnd(local, location));
 }
 
+public void nullableFieldDereference(VariableBinding variable, long position) {
+	String[] arguments = new String[] {new String(variable.name)};
+	char[][] nullableName = this.options.nullableAnnotationName;
+		arguments = new String[] {new String(variable.name), new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.NullableFieldReference,
+		arguments,
+		arguments,
+		(int)(position >>> 32),
+		(int)(position));
+}
+
 public void localVariableRedundantCheckOnNonNull(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.RedundantNullCheckOnNonNullLocalVariable);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -7223,6 +7335,19 @@ public void uninitializedBlankFinalField(FieldBinding field, ASTNode location) {
 		nodeSourceStart(field, location),
 		nodeSourceEnd(field, location));
 }
+public void uninitializedNonNullField(FieldBinding field, ASTNode location) {
+	char[][] nonNullAnnotationName = this.options.nonNullAnnotationName;
+	String[] arguments = new String[] {
+			new String(nonNullAnnotationName[nonNullAnnotationName.length-1]),
+			new String(field.readableName())
+	};
+	this.handle(
+		methodHasMissingSwitchDefault() ? IProblem.UninitializedNonNullFieldHintMissingDefault : IProblem.UninitializedNonNullField,
+		arguments,
+		arguments,
+		nodeSourceStart(field, location),
+		nodeSourceEnd(field, location));
+}
 public void uninitializedLocalVariable(LocalVariableBinding binding, ASTNode location) {
 	binding.tagBits |= TagBits.NotInitialized;
 	String[] arguments = new String[] {new String(binding.readableName())};
@@ -8236,14 +8361,13 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 		return;
 	}
 	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0) {
-		if (expression instanceof SingleNameReference) {
-			SingleNameReference snr = (SingleNameReference) expression;
-			if (snr.binding instanceof LocalVariableBinding) {
-				if (((LocalVariableBinding)snr.binding).isNullable()) {
-					nullityMismatchSpecdNullable(expression, requiredType, annotationName);
-					return;
-				}
-			}
+		VariableBinding var = expression.localVariableBinding();
+		if (var == null && expression instanceof Reference) {
+			var = ((Reference)expression).lastFieldBinding();
+		}
+		if (var != null && var.isNullable()) {
+			nullityMismatchSpecdNullable(expression, requiredType, annotationName);
+			return;
 		}
 		nullityMismatchPotentiallyNull(expression, requiredType, annotationName);
 		return;
@@ -8443,6 +8567,13 @@ public void nullAnnotationIsRedundant(AbstractMethodDeclaration sourceMethod, in
 	this.handle(IProblem.RedundantNullAnnotation, ProblemHandler.NoArgument, ProblemHandler.NoArgument, sourceStart, sourceEnd);
 }
 
+public void nullAnnotationIsRedundant(FieldDeclaration sourceField) {
+	Annotation annotation = findAnnotation(sourceField.annotations, TypeIds.T_ConfiguredAnnotationNonNull);
+	int sourceStart = annotation != null ? annotation.sourceStart : sourceField.type.sourceStart;
+	int sourceEnd = sourceField.type.sourceEnd;
+	this.handle(IProblem.RedundantNullAnnotation, ProblemHandler.NoArgument, ProblemHandler.NoArgument, sourceStart, sourceEnd);
+}
+
 public void nullDefaultAnnotationIsRedundant(ASTNode location, Annotation[] annotations, Binding outer) {
 	Annotation annotation = findAnnotation(annotations, TypeIds.T_ConfiguredAnnotationNonNullByDefault);
 	int start = annotation != null ? annotation.sourceStart : location.sourceStart;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 845ebc8..d95f900 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -19,6 +19,8 @@
 #							bug 388281 - [compiler][null] inheritance of null annotations as an option
 #							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
 #							bug 393719 - [compiler] inconsistent warnings on iteration variables
+#							bug 331649 - [compiler][null] consider null annotations for fields
+#							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -593,6 +595,10 @@
 ### MORE TYPE RELATED
 662 = Illegal attempt to create arrays of union types
 
+### NULL ANALYSIS FOR OTHER EXPRESSIONS
+670 = Null comparison always yields false: this expression cannot be null
+671 = Redundant null check: this expression cannot be null
+
 ### CORRUPTED BINARIES
 700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}
 
@@ -689,6 +695,7 @@
 921 = The method {0} from {1} cannot implement the corresponding method from {2} due to incompatible nullness constraints
 922 = The nullness annotation is redundant with a default that applies to this location
 923 = The nullness annotation @{0} is not applicable for the primitive type {1}
+924 = Potential null pointer access: The field {0} is declared as @{1}
 925 = Nullness default is redundant with the global default
 926 = Nullness default is redundant with a default specified for the enclosing package {0}
 927 = Nullness default is redundant with a default specified for the enclosing type {0}
@@ -698,6 +705,11 @@
 931 = Redundant null check: The variable {0} is specified as @{1}
 932 = Null comparison always yields false: The variable {0} is specified as @{1}
 933 = Null type mismatch: required ''@{0} {1}'' but the provided value is specified as @{2}
+934 = The @{0} field {1} may not have been initialized
+935 = The @{0} field {1} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
+936 = Null comparison always yields false: The method {0} cannot return null
+937 = Redundant null check: The field {0} is declared as @{1}
+938 = Null comparison always yields false: The field {0} is declared as @{1}
 939 = The default ''@{0}'' conflicts with the inherited ''@{1}'' annotation in the overridden method from {2} 
 940 = Conflict between inherited null annotations ''@{0}'' declared in {1} versus ''@{2}'' declared in {3} 
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index fb96c44..3985932 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -97,6 +97,7 @@
  *									COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
+ *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1490,7 +1491,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is a legal value in that position. Currently supported
-	 *    positions are: method parameters, method return type and local variables.</p>
+	 *    positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>If a value whose type
 	 *    is annotated with this annotation is dereferenced without checking for null,
 	 *    the compiler will trigger a diagnostic as further controlled by
@@ -1516,7 +1517,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is <b>not</b> a legal value in that position. Currently
-	 *    supported positions are: method parameters, method return type and local variables.</p>
+	 *    supported positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>For values declared with this annotation, the compiler will never trigger a null
 	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
 	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
@@ -1540,8 +1541,8 @@ public final class JavaCore extends Plugin {
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
 	 * <p>If the annotation is applied without an argument, all unannotated types in method signatures
-	 *    within the annotated element will be treated as if they were specified with the non-null annotation
-	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
+	 *    and field declarations within the annotated element will be treated as if they were specified
+	 *    with the non-null annotation (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
 	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
 	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.</p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
@@ -1592,6 +1593,9 @@ public final class JavaCore extends Plugin {
 	 *        for at least one of its parameters, tries to tighten that null contract by
 	 *        specifying a nonnull annotation for its corresponding parameter
 	 *        (prohibition of covariant parameters).</li>
+	 *    <li>A non-static field with a nonnull annotation is not definitely assigned at
+	 *        the end of each constructor.</li>
+	 *    <li>A static field with a nonnull annotation is not definitely assigned in static initializers.</li>
 	 *    </ol>
 	 *    In the above an expression is considered as <em>nullable</em> if
 	 *    either it is statically known to evaluate to the value <code>null</code>, or if it is
@@ -1688,6 +1692,20 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_REDUNDANT_NULL_ANNOTATION = PLUGIN_ID + ".compiler.problem.redundantNullAnnotation"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Perform syntactic null analysis for fields.
+	 * <p>When enabled, the compiler will detect certain syntactic constellations where a null
+	 *	  related warning against a field reference would normally be raised but can be suppressed
+	 *    at low risk given that the same field reference was known to be non-null immediately before.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
+	 * @since 3.9
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS = JavaCore.PLUGIN_ID+".compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
+	/**
 	 * Compiler option ID: Inheritance of null annotations.
 	 * <p>When enabled, the compiler will check for each method without any explicit null annotations:
 	 *    If it overrides a method which has null annotations, it will treat the
@@ -5597,4 +5615,4 @@ public final class JavaCore extends Plugin {
 		super.start(context);
 		JavaModelManager.getJavaModelManager().startup();
 	}
-}
\ No newline at end of file
+}
commit 29d4a1149e392c0b5c052a9202992e800f5506a5
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Feb 6 23:58:48 2013 +0100

    Combined fix for
    Bug 331649 - [compiler][null] consider null annotations for fields
    Bug 382789 - [compiler][null] warn when syntactically-nonnull
      expression is compared against null
    Bug 380896 - [compiler][null] Enum constants not recognised as being
      NonNull.
    Bug 383368 - [compiler][null] syntactic null analysis for field
      references
    Bug 388630 - @NonNull diagnostics at line 0

1	1	org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
1	1	org.eclipse.jdt.annotation/pom.xml
3	2	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
2	1	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
3	2	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
11	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
4	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
18	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
1442	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
154	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
28	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
25	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
16	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
22	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
22	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
60	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
31	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
87	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
8	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
87	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
41	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
55	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
16	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
72	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
43	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
14	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
1	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
53	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
139	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
23	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
index 1b57641..e215be5 100644
--- a/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
+++ b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
@@ -3,7 +3,7 @@ Bundle-ManifestVersion: 2
 Bundle-Name: %bundleName
 Bundle-Localization: bundle
 Bundle-SymbolicName: org.eclipse.jdt.annotation
-Bundle-Version: 1.0.1.qualifier
+Bundle-Version: 1.1.0.qualifier
 Export-Package: org.eclipse.jdt.annotation
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-Vendor: %providerName
diff --git a/org.eclipse.jdt.annotation/pom.xml b/org.eclipse.jdt.annotation/pom.xml
index 8474179..a60aeab 100644
--- a/org.eclipse.jdt.annotation/pom.xml
+++ b/org.eclipse.jdt.annotation/pom.xml
@@ -20,6 +20,6 @@
   </parent>
   <groupId>eclipse.jdt.core</groupId>
   <artifactId>org.eclipse.jdt.annotation</artifactId>
-  <version>1.0.1-SNAPSHOT</version>
+  <version>1.1.0-SNAPSHOT</version>
   <packaging>eclipse-plugin</packaging>
 </project>
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
index eaaae3d..36ec3ae 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation can never have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -44,7 +45,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface NonNull {
 	// marker annotation with no members
 }
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
index d5e5aa7..196e075 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
@@ -28,7 +28,8 @@ import java.lang.annotation.Target;
  * <code>@NonNullByDefault</code> are:
  * <ul>
  * <li>method return values</li>
- * <li>parameters of a method or constructor.</li>
+ * <li>parameters of a method or constructor</li>
+ * <li>fields.</li>
  * </ul>
  * Local variables are <em>not</em> affected.
  * <dl>
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
index e1a6a1b..cb84e45 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -22,7 +23,7 @@ import java.lang.annotation.Target;
  
 /**
  * Qualifier for a type in a method signature or a local variable declaration:
- * The entity (return value, parameter, local variable) whose type has this
+ * The entity (return value, parameter, field, local variable) whose type has this
  * annotation is allowed to have the value <code>null</code> at runtime.
  * <p>
  * This has two consequences:
@@ -35,7 +36,7 @@ import java.lang.annotation.Target;
  */
 @Documented
 @Retention(RetentionPolicy.CLASS)
-@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
+@Target({ FIELD, METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface Nullable {
 	// marker annotation with no members
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
index 719ba65..580f977 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
@@ -127,6 +127,17 @@ public abstract class AbstractNullAnnotationTest extends AbstractComparableTest
 	void runConformTestWithLibs(String[] testFiles, Map customOptions, String expectedCompilerLog) {
 		runConformTestWithLibs(false /* flush output directory */, testFiles, customOptions, expectedCompilerLog);
 	}
+	void runConformTestWithLibs(String[] testFiles, Map customOptions, String expectedCompilerLog, String expectedOutput) {
+		runConformTest(
+				false, /* flush output directory */
+				testFiles,
+				this.LIBS,
+				customOptions,
+				expectedCompilerLog,
+				expectedOutput,
+				"",/* expected error */
+			    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+	}
 	void runConformTestWithLibs(boolean shouldFlushOutputDirectory, String[] testFiles, Map customOptions, String expectedCompilerLog) {
 		runConformTest(
 				shouldFlushOutputDirectory,
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index c5b0b6a..8e9ac37 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -17,6 +17,7 @@
  *								bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639)
  *								bug 384663 - Package Based Annotation Compilation Error in JDT 3.8/4.2 (works in 3.7.2) 
  *								bug 386356 - Type mismatch error with annotations and generics
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -10429,7 +10430,7 @@ public void testBug365437e() {
 			"}\n" +
 			"class E3 {\n" +
 			"	 @p.NonNull\n" +
-			"    private int E3;\n" +
+			"    private Object E3 = new Object();\n" +
 			"}\n" +
 			"class E4 {\n" +
 			"	 @Deprecated\n" +
@@ -10469,8 +10470,8 @@ public void testBug365437e() {
 		"The value of the field E2.E2 is not used\n" + 
 		"----------\n" + 
 		"4. ERROR in Example.java (at line 15)\n" + 
-		"	private int E3;\n" + 
-		"	            ^^\n" + 
+		"	private Object E3 = new Object();\n" + 
+		"	               ^^\n" + 
 		"The value of the field E3.E3 is not used\n" + 
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 14862e3..d9e1eee 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -26,6 +26,7 @@
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1977,6 +1978,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.staticAccessReceiver\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.suppressWarnings\" value=\"enabled\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.tasks\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.typeParameterHiding\" value=\"warning\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 88bebdc..7a1152e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -24,6 +24,8 @@
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -772,6 +774,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonGenericConstructor", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericMethod", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
@@ -784,6 +789,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -840,6 +846,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -933,6 +941,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UninitializedLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1514,7 +1524,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonGenericConstructor", SKIP);
 		expectedProblemAttributes.put("NonGenericMethod", SKIP);
 		expectedProblemAttributes.put("NonGenericType", SKIP);
+		expectedProblemAttributes.put("NonNullExpressionComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
@@ -1526,6 +1539,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleField", SKIP);
 		expectedProblemAttributes.put("NotVisibleMethod", SKIP);
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
+		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationUnchecked", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
@@ -1582,6 +1596,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_TYPE_ARGUMENTS));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullExpression", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullSpecdField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
@@ -1675,6 +1691,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariable", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
+		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
+		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index cf675ea..52979e3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1517,7 +1517,12 @@ public void test_nonnull_return_008() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	if (getObject() == null)\n" +
 		"	    ^^^^^^^^^^^\n" +
-		"Redundant null check: The method getObject() cannot return null\n" +
+		"Null comparison always yields false: The method getObject() cannot return null\n" +
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	throw new RuntimeException();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
 		"----------\n");
 }
 // a result from a nonnull method is directly checked for null (from local): redundant
@@ -2668,6 +2673,87 @@ public void test_default_nullness_015() {
 		"----------\n");
 }
 
+// default nullness applied to fields, class-level:
+public void test_default_nullness_016() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    Object foo;\n" +
+			"    void doFoo() {\n" +
+			"        foo = null;\n" +
+			"    }\n" +
+			"    class Inner {\n" +
+			"        Object iFoo;\n" +
+			"        void diFoo(@Nullable Object arg) {\n" +
+			"            iFoo = arg;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	Object foo;\n" + 
+		"	       ^^^\n" + 
+		"The @NonNull field foo may not have been initialized\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	foo = null;\n" + 
+		"	      ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 9)\n" + 
+		"	Object iFoo;\n" + 
+		"	       ^^^^\n" + 
+		"The @NonNull field iFoo may not have been initialized\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	iFoo = arg;\n" + 
+		"	       ^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n");
+}
+
+// default nullness applied to fields, method level applied to local class + redundant annotation
+public void test_default_nullness_017() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNUSED_PRIVATE_MEMBER, JavaCore.IGNORE);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNullByDefault\n" +
+			"    Object doFoo() {\n" +
+			"        class Local {\n" +
+			"            Object foo;\n" +
+			"            @NonNull Object goo;\n" +
+			"        };" +
+			"        return new Local();\n" +
+			"    }\n" +
+			"}\n",
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	Object foo;\n" + 
+		"	       ^^^\n" + 
+		"The @NonNull field foo may not have been initialized\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 7)\n" + 
+		"	@NonNull Object goo;\n" + 
+		"	^^^^^^^^^^^^^^^\n" + 
+		"The nullness annotation is redundant with a default that applies to this location\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	@NonNull Object goo;\n" + 
+		"	                ^^^\n" + 
+		"The @NonNull field goo may not have been initialized\n" + 
+		"----------\n");
+}
+
 // redundant default annotations - class vs. inner class
 public void test_redundant_annotation_01() {
 	Map customOptions = getCompilerOptions();
@@ -2987,6 +3073,27 @@ public void test_contradictory_annotations_01() {
 		"----------\n");
 }
 
+// contradictory null annotations on a field
+public void test_contradictory_annotations_02() {
+	Map customOptions = getCompilerOptions();
+	runNegativeTestWithLibs(
+		new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @NonNull @Nullable Object o;\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in p2\\Y.java (at line 4)\n" + 
+		"	@NonNull @Nullable Object o;\n" + 
+		"	         ^^^^^^^^^\n" + 
+		"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
+		"----------\n");
+}
+
 // a nonnull variable is dereferenced in a loop
 public void test_nonnull_var_in_constrol_structure_1() {
 	Map customOptions = getCompilerOptions();
@@ -3220,6 +3327,7 @@ public void test_message_send_in_control_structure_01() {
 		"Null comparison always yields false: The variable enclosingSourceType cannot be null at this location\n" +
 		"----------\n");
 }
+
 // Bug 370930 - NonNull annotation not considered for enhanced for loops
 public void test_message_send_in_control_structure_02() {
 	runNegativeTestWithLibs(
@@ -3494,6 +3602,1339 @@ public void test_options_03() {
 		"Dead code\n" + 
 		"----------\n");
 }
+// access to a non-null field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_1() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is not properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	@NonNull Object o;\n" +
+		"	                ^\n" +
+		"The @NonNull field o may not have been initialized\n" +
+		"----------\n");
+}
+
+// a non-null field is not properly initialized - explicit constructor
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    X (boolean b) { // only potentially initialized\n" +
+			"        if (b)\n" +
+			"            o = this;\n" +
+			"    }\n" +
+			"    X (@NonNull Object other) {\n" + // no problem
+			"        o = other;\n" +
+			"    }\n" +
+			"    public String oString() {\n" +
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	X (boolean b) { // only potentially initialized\n" + 
+		"	^^^^^^^^^^^^^\n" + 
+		"The @NonNull field o may not have been initialized\n" + 
+		"----------\n");
+}
+
+// a non-null field is not properly initialized - explicit constructor - incomplete switch
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2b() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"enum Color { BLACK, GREEN }\n" +
+			"public class X {\n" +
+			"    @NonNull Object o;\n" +
+			"    X (Color c) { // only potentially initialized\n" +
+			"        switch (c) {\n" +
+			"            case BLACK: o = this; break;\n" +
+			"            case GREEN: o = new Object(); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"    public String oString() {\n" +
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	X (Color c) { // only potentially initialized\n" + 
+		"	^^^^^^^^^^^\n" + 
+		"The @NonNull field o may not have been initialized. Note that a problem regarding missing \'default:\' on \'switch\' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n");
+}
+
+// a non-null static field is not properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2c() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    static @NonNull Object o;\n" +
+			"    static {\n" +
+			"        if (new Object().hashCode() == 42)\n" +
+			"            o = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	static @NonNull Object o;\n" + 
+		"	                       ^\n" + 
+		"The @NonNull field o may not have been initialized\n" + 
+		"----------\n");
+}
+
+// a non-null static field is properly initialized
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2d() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    static @NonNull Object o;\n" +
+			"    static {\n" +
+			"         o = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is properly initialized - using this.f reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_2e() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object f;\n" +
+			"    {\n" +
+			"         this.f = new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// a non-null field is initialized to null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = null;\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull Object o = null;\n" + 
+		"	                    ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is assigned to null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_4() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    void breakIt1() {\n" +
+			"         o = null;\n" +
+			"    }\n" +
+			"    void breakIt2() {\n" +
+			"         this.o = null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	this.o = null;\n" + 
+		"	         ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a non-null field is checked for null
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         return o == null;\n" +
+			"    }\n" +
+			"    boolean checkIt() {\n" +
+			"         return this.o != null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o == null;\n" + 
+		"	       ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o != null;\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is checked for null twice - method call inbetween
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    boolean checkIt1() {\n" +
+			"         if (o != null)\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return this.o == null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (o != null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	return this.o == null;\n" + 
+		"	            ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - static field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    static @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (Objects.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    @NonNull Object getIt2() {\n" +
+			"         if (null != Objects.o) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return Objects.o;\n" +
+			"    }\n" +
+			"    String getIt3() {\n" +
+			"         return Objects.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (Objects.o != null) // redundant\n" + 
+		"	            ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	if (null != Objects.o) // redundant\n" + 
+		"	                    ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via a qualified name reference - instance field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_8() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Object getIt1(@NonNull Objects objs) {\n" +
+			"         if (objs.o == null) // always false\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         return objs.o;\n" +
+			"    }\n" +
+			"    String getIt2(@NonNull Objects objs) {\n" +
+			"         return objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	if (objs.o == null) // always false\n" + 
+		"	         ^\n" + 
+		"Null comparison always yields false: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	System.out.print(\"not null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+
+// a non-null field is accessed via an indirect field reference - instance field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_9() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    Objects objs = new Objects();\n" +
+			"    @NonNull Object getIt1() {\n" +
+			"         if (this.objs.o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         System.out.print(\"continue\");\n" +
+			"         if (getObjs().o != null) // redundant\n" +
+			"             System.out.print(\"not null\");\n" +
+			"         return this.objs.o;\n" +
+			"    }\n" +
+			"    Objects getObjs() { return this.objs; }\n" +
+			"    String getIt2() {\n" +
+			"         return this.objs.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	if (this.objs.o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	if (getObjs().o != null) // redundant\n" + 
+		"	              ^\n" + 
+		"Redundant null check: The field o is declared as @NonNull\n" + 
+		"----------\n");
+}
+
+// trying to assign null to a nonnull field via a single / a qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_11() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Objects {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"    void test0(@Nullable Object x) {\n" +
+			"         o = x;\n" +
+			"    }\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    void test(@NonNull Objects objs) {\n" +
+			"         objs.o = null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	o = x;\n" + 
+		"	    ^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	objs.o = null;\n" + 
+		"	         ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+
+// @NonNull is applied to a field with primitive type
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_12() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull int o = 1;\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull int o = 1;\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"The nullness annotation @NonNull is not applicable for the primitive type int\n" + 
+		"----------\n");
+}
+
+// A final field is initialized to non-null, treat as effectively @NonNull
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void _test_nonnull_field_13() {
+	// withdrawn as of https://bugs.eclipse.org/331649#c75
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    final String s1 = \"\";\n" +
+			"    @NonNull String s2;\n" +
+			"    X() {\n" +
+			"        s2 = s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// A field in a different CU is implicitly @NonNull (by type default) - that class is read from binary
+// Assignment to other @NonNull field should not raise a warning
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_14() {
+	runConformTestWithLibs(
+		new String[] {
+			"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    public String s1 = \"\";\n" +
+			"}\n",
+		},
+		null /*customOptions*/,
+		"");
+	runConformTestWithLibs(
+			new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import p1.X;\n" +
+			"public class Y {\n" +
+			"    @NonNull String s2 = \"\";\n" +
+			"    void foo(X other) {\n" +
+			"        s2 = other.s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// A field in a different CU is implicitly @NonNull (by package default) - that class is read from binary
+// Assignment to other @NonNull field should not raise a warning
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nonnull_field_14b() {
+	runConformTestWithLibs(
+		new String[] {
+			"p1/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p1;\n",
+			"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    public String s1 = \"\";\n" +
+			"}\n",
+		},
+		null /*customOptions*/,
+		"");
+	runConformTestWithLibs(
+			new String[] {
+			"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"import p1.X;\n" +
+			"public class Y {\n" +
+			"    @NonNull String s2 = \"\";\n" +
+			"    void foo(X other) {\n" +
+			"        s2 = other.s1;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// access to a nullable field - field reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_1() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return this.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.o.toString();\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - single name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_2() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return o.toString();\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+// access to a nullable field - qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_3() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    @Nullable X other;\n" +
+			"    public String oString() {\n" +
+			"         return other.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	       ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	return other.o.toString();\n" +
+		"	             ^\n" +
+		"Potential null pointer access: The field o is declared as @Nullable\n" +
+		"----------\n");
+}
+// access to a nullable field - qualified name reference - multiple segments
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_3m() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    @Nullable X other;\n" +
+			"    public String oString() {\n" +
+			"         return other.other.o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	       ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	             ^^^^^\n" +
+		"Potential null pointer access: The field other is declared as @Nullable\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 6)\n" +
+		"	return other.other.o.toString();\n" +
+		"	                   ^\n" +
+		"Potential null pointer access: The field o is declared as @Nullable\n" +
+		"----------\n");
+}
+// access to a nullable field - dereference after check
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_4() {
+	// currently no flow analysis for fields is implemented,
+	// but the direct sequence of null-check + dereference is optionally supported as a special case
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString() {\n" +
+			"         if (this.o != null)\n" +
+			"             return this.o.toString();\n" + // silent after check
+			"         if (o != null)\n" +
+			"             return o.toString();\n" + // silent after check
+			"         return \"\";\n" +
+			"    }\n" +
+			"    public String oString2() {\n" +
+			"         String local = o.toString();\n" +
+			"         if (this.o != null) {\n" +
+			"             this.toString();\n" + // method call wipes null info
+			"             return this.o.toString(); // warn here\n" +
+			"         }\n" +
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	String local = o.toString();\n" + 
+		"	               ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 15)\n" + 
+		"	return this.o.toString(); // warn here\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a QNR
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on z\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    @NonNull Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on z\n" + 
+		"	         ^\n" + 
+		"Potential null pointer access: The field z is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a QNR - inverse of test_nullable_field_5
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_6() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return y.z.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @NonNull Z z = new Z();\n" +
+			"}\n",
+			"Z.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    Object dummy;\n" + // ensure different interal fieldId
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	       ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return y.z.o.toString(); // pot.NPE on y and o\n" + 
+		"	           ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - intermediate component in a double field reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_7() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Y y = new Y();\n" +
+			"    public String oString() {\n" +
+			"         return this.y.o.toString(); // pot.NPE on y and o\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field y is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return this.y.o.toString(); // pot.NPE on y and o\n" + 
+		"	              ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// static access to a nullable field - qualified name reference
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_8() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable static final Object o = null;\n" +
+			"    public void foo() {\n" +
+			"         if (X.o == null){\n" +
+			"				System.out.println(X.o);\n" +
+			"		  }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+
+// illegal use of @Nullable for a field of primitive type
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_9() {
+	runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    @Nullable int i;\n" +
+				"}\n"
+			},
+			null /*customOptions*/,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	@Nullable int i;\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"The nullness annotation @Nullable is not applicable for the primitive type int\n" + 
+			"----------\n");	
+}
+
+// protected access to nullable fields - different kinds of references
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    @NonNull X x = new X();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +						// qualified reference -> block
+			"             System.out.println(other.o1.toString());\n" +
+			"         }\n" +
+			"         if (this.o2 != null)\n" + 						// field reference -> statement
+			"             System.out.println(o2.toString());\n" +
+			"         if (this.o2 != null)\n" + 						// identical field references
+			"             System.out.println(this.o2.toString());\n" +
+			"         System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + // ternary
+			"         if (this.x.o1 != null)\n" +						// nested field reference ...
+			"             System.out.println(x.o1.toString());\n" + 	// ... equiv qualified name reference
+			"         if (x.o1 != null)\n" +							// qualified name reference ...
+			"             System.out.println(this.x.o1.toString());\n" +// ... equiv nested field reference
+			"         if (this.x.o1 != null)\n" +						// identical nested field references
+			"             System.out.println(this.x.o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
+// protected access to nullable fields - different kinds of references - option not enabled
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10b() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.DISABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    @NonNull X x = new X();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +						// qualified reference -> block
+			"             System.out.println(other.o1.toString());\n" +
+			"         }\n" +
+			"         if (this.o2 != null)\n" + 						// field reference -> statement
+			"             System.out.println(o2.toString());\n" +
+			"         if (this.o2 != null)\n" + 						// identical field references
+			"             System.out.println(this.o2.toString());\n" +
+			"         System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + // ternary
+			"         if (this.x.o1 != null)\n" +						// nested field reference ...
+			"             System.out.println(x.o1.toString());\n" + 	// ... equiv qualified name reference
+			"         if (x.o1 != null)\n" +							// qualified name reference ...
+			"             System.out.println(this.x.o1.toString());\n" +// ... equiv nested field reference
+			"         if (this.x.o1 != null)\n" +						// identical nested field references
+			"             System.out.println(this.x.o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	System.out.println(other.o1.toString());\n" + 
+		"	                         ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	System.out.println(o2.toString());\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 12)\n" + 
+		"	System.out.println(this.o2.toString());\n" + 
+		"	                        ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 13)\n" + 
+		"	System.out.println (null != o3 ? o3.toString() : \"nothing\");\n" + 
+		"	                                 ^^\n" + 
+		"Potential null pointer access: The field o3 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 15)\n" + 
+		"	System.out.println(x.o1.toString());\n" + 
+		"	                     ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 17)\n" + 
+		"	System.out.println(this.x.o1.toString());\n" + 
+		"	                          ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 19)\n" + 
+		"	System.out.println(this.x.o1.toString());\n" + 
+		"	                          ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - different boolean operators
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10c() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (o1 != null && o2 != null & o3 != null) \n" + // conjunction: OK
+			"             System.out.println(o2.toString());\n" +
+			"         if (o1 != null || o2 != null || o3 != null) \n" +
+			"             System.out.println(o2.toString()); // warn here: disjunktion is no protection\n" +
+			"         if (!(o1 != null)) \n" +
+			"             System.out.println(o1.toString()); // warn here: negation is no protection\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" +
+		"1. ERROR in X.java (at line 8)\n" +
+		"	System.out.println(o2.toString()); // warn here: disjunktion is no protection\n" +
+		"	                   ^^\n" +
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 10)\n" +
+		"	System.out.println(o1.toString()); // warn here: negation is no protection\n" +
+		"	                   ^^\n" +
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" +
+		"----------\n");
+}
+
+// protected access to nullable fields - assignment as expression
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10d() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    public void foo(@NonNull X other, X last) {\n" +
+			"         o1 = other;\n" +		// reference test case: assignment as statement
+			"         if (o1 == last) \n" +	// no expiry
+			"             System.out.println(o1.toString());\n" +
+			"         if ((o1 = other) == last) \n" + // no expiry
+			"             System.out.println(o1.toString());\n" +
+			"         if ((o1 = other) == last) {\n" +
+			"             o1 = null;\n" + // expire here
+			"             System.out.println(o1.toString()); // info is expired\n" +
+			"         }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	System.out.println(o1.toString()); // info is expired\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - distinguish local and field
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10e() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"class Y {\n" +
+			"    @Nullable Object o2;\n" +
+			"    void bar(Object o2) {\n" +
+			"        if (o2 != null)\n" +
+			"            System.out.println(this.o2.toString()); // field access is not protected\n" +
+			"    }\n" +
+			"}\n" +
+			"public class X {\n" +
+			"    @NonNull Y o1 = new Y();\n" +
+			"    public void foo() {\n" +
+			"         Y o1 = new Y();\n" +
+			"         if (o1.o2 != null) \n" +	// check via local
+			"             System.out.println(this.o1.o2.toString()); // field access via other field not protected\n" +
+			"         if (this.o1.o2 != null) \n" +	// check via field
+			"             System.out.println(o1.o2.toString()); // field access via local not protected\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. WARNING in X.java (at line 4)\n" + 
+		"	void bar(Object o2) {\n" + 
+		"	                ^^\n" + 
+		"The parameter o2 is hiding a field from type Y\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 6)\n" + 
+		"	System.out.println(this.o2.toString()); // field access is not protected\n" + 
+		"	                        ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 12)\n" + 
+		"	Y o1 = new Y();\n" + 
+		"	  ^^\n" + 
+		"The local variable o1 is hiding a field from type X\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 14)\n" + 
+		"	System.out.println(this.o1.o2.toString()); // field access via other field not protected\n" + 
+		"	                           ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 16)\n" + 
+		"	System.out.println(o1.o2.toString()); // field access via local not protected\n" + 
+		"	                      ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// protected access to nullable fields - duplicate comparison
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_10f() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (o1 != null && o1 != null) // second term is redundant\n" +
+			"             System.out.println(o1.toString());\n" +
+			"         if (o1 != null)\n" +
+			"             if (o1 != null) // this if is redundant\n" +
+			"                 System.out.println(o1.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (o1 != null && o1 != null) // second term is redundant\n" + 
+		"	                  ^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
+		"	if (o1 != null) // this if is redundant\n" + 
+		"	    ^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n");
+}
+
+// combined test from comment 20 in https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_11() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"class X {\n" + 
+				"    @Nullable Object o;\n" + 
+				"    public @NonNull Object foo(X x) {\n" + 
+				"    	return  x.o != null ? x.o : new Object();\n" + 
+				"	 }\n" + 
+				"    public void goo(X x) {\n" + 
+				"    	if (x.o != null) {\n" + 
+				"    		x.o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void boo(X x) {\n" + 
+				"    	if (x.o instanceof String) {\n" + 
+				"    		x.o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void zoo(X x) {\n" + 
+				"    	x.o = new Object();\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + x.o.hashCode());\n" + 
+				"    }\n" + 
+				"    public void doo(X x) {\n" + 
+				"    	x.o = foo(x); // foo is guaranteed to return @NonNull Object.\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + x.o.hashCode());\n" + 
+				"    }\n" + 
+				"}\n"
+			},
+			options,
+			"");
+}
+
+// combined test from comment 20 in https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+//  - version with 'this' field references
+public void test_nullable_field_11a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"class X {\n" + 
+				"    @Nullable Object o;\n" + 
+				"    public @NonNull Object foo() {\n" + 
+				"    	return  o != null ? o : new Object();\n" + 
+				"    }\n" + 
+				"    public void goo() {\n" + 
+				"    	if (o != null) {\n" + 
+				"    		o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void boo() {\n" + 
+				"    	if (o instanceof String) {\n" + 
+				"    		o.toString();\n" + 
+				"    	}\n" + 
+				"    }\n" + 
+				"    public void zoo() {\n" + 
+				"    	o = new Object();\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + o.hashCode());\n" + 
+				"    }\n" + 
+				"    public void doo() {\n" + 
+				"    	o = foo(); // foo is guaranteed to return @NonNull Object.\n" + 
+				"    	System.out.println(\"hashCode of new Object = \" + o.hashCode());\n" + 
+				"    }\n" + 
+				"}\n"
+			},
+			options,
+			"");
+}
+
+// protected access to nullable field - expiration of information
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_12() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1, o2, o3, o4;\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 != null){\n" +
+			"				System.out.println(goo()+other.o1.toString()); // warn here: expired by call to goo()\n" +
+			"		  }\n" +
+			"         Object x = o2 != null ? o2 : o1;\n" +
+			"         System.out.println(o2.toString()); // warn here: not protected\n" +
+			"         if (o3 != null) /*nop*/;\n" +
+			"         System.out.println(o3.toString()); // warn here: expired by empty statement\n" +
+			"         if (o4 != null && hoo())\n" +
+			"             System.out.println(o4.toString()); // warn here: expired by call to hoo()\n" +
+			"    }\n" +
+			"    String goo() { return \"\"; }\n" +
+			"    boolean hoo() { return false; }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	System.out.println(goo()+other.o1.toString()); // warn here: expired by call to goo()\n" + 
+		"	                               ^^\n" + 
+		"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 9)\n" + 
+		"	System.out.println(o2.toString()); // warn here: not protected\n" +
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o2 is declared as @Nullable\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 11)\n" + 
+		"	System.out.println(o3.toString()); // warn here: expired by empty statement\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o3 is declared as @Nullable\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 13)\n" + 
+		"	System.out.println(o4.toString()); // warn here: expired by call to hoo()\n" + 
+		"	                   ^^\n" + 
+		"Potential null pointer access: The field o4 is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// example from comment 47
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_13() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o1;\n" +
+			"    @NonNull Object o2 = new Object();\n" +
+			"    public void foo(X other) {\n" +
+			"         if (other.o1 == null){\n" +
+			"				this.o2 = other.o1; // warn here: assign @Nullable to @NonNull\n" +
+			"		  }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	this.o2 = other.o1; // warn here: assign @Nullable to @NonNull\n" + 
+		"	          ^^^^^^^^\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" + 
+		"----------\n");
+}
+
+// access to a nullable field - protected by check against a @NonNull value
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_14() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString(@NonNull Object a) {\n" +
+			"         if (this.o == a)\n" +
+			"             return this.o.toString();\n" + // silent after check
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
+// access to a nullable field - not protected by negative check against a @NonNull value
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=331649
+public void test_nullable_field_14a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object o = new Object();\n" +
+			"    public String oString(@NonNull Object a) {\n" +
+			"         if (this.o != a)\n" +
+			"             return this.o.toString(); // warn here, check has no effect\n" +
+			"         return \"\";\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	return this.o.toString(); // warn here, check has no effect\n" + 
+		"	            ^\n" + 
+		"Potential null pointer access: The field o is declared as @Nullable\n" + 
+		"----------\n");
+}
+
+// an enum is declared within the scope of a null-default
+// https://bugs.eclipse.org/331649#c61
+public void test_enum_field_01() {
+	runConformTestWithLibs(
+		new String[] {
+			"tests/X.java",
+			"package tests;\n" +
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class X {\n" +
+			"    enum A { B }\n" +
+			"    public static void main(String ... args) {\n" +
+			"         System.out.println(A.B);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null,
+		"",
+		"B");
+}
+
+// Bug 380896 - Enum constants not recognised as being NonNull.
+// see also https://bugs.eclipse.org/331649#c61
+public void test_enum_field_02() {
+	runConformTestWithLibs(
+		new String[] {
+			"tests/X.java",
+			"package tests;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    enum A { B }\n" +
+			"    public static void main(String ... args) {\n" +
+			"         test(A.B);\n" +
+			"    }\n" +
+			"    static void test(@NonNull A a) {\n" +
+			"        System.out.println(a.ordinal());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null,
+		"",
+		"0");
+}
+
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372011
 // Test whether @NonNullByDefault on a binary package or an enclosing type is respected from enclosed elements.
 public void testBug372011() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index c67196f..6245e57 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -25,6 +25,8 @@
  * 							bug 383690 - [compiler] location of error re uninitialized final field should be aligned
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 376263 - Bogus "Potential null pointer access" warning
+ *							bug 331649 - [compiler][null] consider null annotations for fields
+ *							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -9637,9 +9639,9 @@ public void test1023() {
 			"X.java",
 			"public class X {\n" +
 			"\n" +
-			"  void foo() {\n" +
+			"  void foo(Object that) {\n" +
 			"    Object o = new Object();\n" +
-			"    while (this != null) {\n" +
+			"    while (that != null) {\n" +
 			"      try {\n" +
 			"        o = null;\n" +
 			"        break;\n" +
@@ -9656,7 +9658,7 @@ public void test1023() {
 		"	    ^\n" +
 		"Null comparison always yields false: The variable o cannot be null at this location\n" +
 		"----------\n" +
-		"2. WARNING in X.java (at line 13)\n" + 
+		"2. WARNING in X.java (at line 13)\n" +
 		"	if (o == null) return;\n" + 
 		"	               ^^^^^^^\n" + 
 		"Dead code\n" + 
@@ -15661,6 +15663,155 @@ public void testBug376263() {
 		customOptions,
 		null/*requestor*/);
 }
+//object/array allocation
+public void testExpressions01() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (new Object() == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"	 void goo() {\n" +
+			"		if (null != this.new I())\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    void hoo() {\n" +
+			"		if (null != new Object[3])\n" +
+			"           System.out.println(\"nonnull\");\n" +
+			"    }\n" +
+			"    class I {}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (new Object() == null)\n" + 
+		"	    ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != this.new I())\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	if (null != new Object[3])\n" + 
+		"	            ^^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+//'this' expressions (incl. qualif.)
+public void testExpressions02() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (this == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    class I {\n" +
+			"        void goo() {\n" +
+			"		     if (null != X.this)\n" +
+			"                System.out.println(\"nonnull\");\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (this == null)\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 8)\n" + 
+		"	if (null != X.this)\n" + 
+		"	            ^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
+//various non-null expressions: class-literal, string-literal, casted 'this'
+public void testExpressions03() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void foo() {\n" +
+			"		if (X.class == null)\n" +
+			"           System.out.println(\"null\");\n" +
+			"    }\n" +
+			"    void goo() {\n" +
+			"        if (null != \"STRING\")\n" +
+			"            System.out.println(\"nonnull\");\n" +
+			"        if (null == (Object)this)\n" +
+			"            System.out.println(\"I'm null\");\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (X.class == null)\n" + 
+		"	    ^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	System.out.println(\"null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	if (null != \"STRING\")\n" + 
+		"	            ^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 9)\n" + 
+		"	if (null == (Object)this)\n" + 
+		"	            ^^^^^^^^^^^^\n" + 
+		"Null comparison always yields false: this expression cannot be null\n" + 
+		"----------\n" + 
+		"5. WARNING in X.java (at line 10)\n" + 
+		"	System.out.println(\"I\'m null\");\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n"
+	);
+}
+
+//a non-null ternary expression
+public void testExpressions04() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(boolean b) {\n" + 
+			"		Object o1 = new Object();\n" + 
+			"		Object o2 = new Object();\n" + 
+			"		if ((b ? o1 : o2) != null)\n" + 
+			"			System.out.println(\"null\");\n" + 
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if ((b ? o1 : o2) != null)\n" + 
+		"	    ^^^^^^^^^^^^^\n" + 
+		"Redundant null check: this expression cannot be null\n" + 
+		"----------\n"
+	);
+}
 
 // Bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
 // simplified: only try-finally involved
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 9512d1a..2ccd865 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -125,6 +125,7 @@ public static Test suite() {
 	
 	ArrayList since_1_8 = new ArrayList();
 	since_1_8.add(NegativeTypeAnnotationTest.class);
+	since_1_8.add(NullTypeAnnotationTest.class);
 	since_1_8.add(NegativeLambdaExpressionsTest.class);
 	since_1_8.add(DefaultMethodsTest.class);
 	since_1_8.add(GrammarCoverageTests308.class);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index f2886aa..e59b56f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -162,6 +162,14 @@
  *									DereferencingNullableExpression
  *									NullityMismatchingTypeAnnotation
  *									NullityMismatchingTypeAnnotationUnchecked
+ *									NullableFieldReference
+ *									UninitializedNonNullField
+ *									UninitializedNonNullFieldHintMissingDefault
+ *									NonNullMessageSendComparisonYieldsFalse
+ *									RedundantNullCheckOnNonNullSpecdField
+ *									NonNullSpecdFieldComparisonYieldsFalse
+ *									NonNullExpressionComparisonYieldsFalse
+ *									RedundantNullCheckOnNonNullExpression
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *******************************************************************************/
@@ -1362,6 +1370,14 @@ void setSourceStart(int sourceStart);
 	int IllegalArrayOfUnionType = TypeRelated + 662;
 
 	/**
+	 * Null analysis for other kinds of expressions, syntactically nonnull
+	 */
+	/** @since 3.9 */
+	int NonNullExpressionComparisonYieldsFalse = Internal + 670;
+	/** @since 3.9 */
+	int RedundantNullCheckOnNonNullExpression = Internal + 671;
+
+	/**
 	 * Corrupted binaries
 	 */
 	/** @since 3.1 */
@@ -1552,6 +1568,8 @@ void setSourceStart(int sourceStart);
 	int RedundantNullAnnotation = MethodRelated + 922;
 	/** @since 3.8 */
 	int IllegalAnnotationForBaseType = TypeRelated + 923;
+	/** @since 3.9 */
+	int NullableFieldReference = FieldRelated + 924;
 	/** @since 3.8 */
 	int RedundantNullDefaultAnnotation = Internal + 925; // shouldn't actually occur any more after bug 366063
 	/** @since 3.8 */
@@ -1571,6 +1589,16 @@ void setSourceStart(int sourceStart);
 	/** @since 3.8 */
 	int RequiredNonNullButProvidedSpecdNullable = Internal + 933;
 	/** @since 3.9 */
+	int UninitializedNonNullField = FieldRelated + 934;
+	/** @since 3.9 */
+	int UninitializedNonNullFieldHintMissingDefault = FieldRelated + 935;
+	/** @since 3.9 */
+	int NonNullMessageSendComparisonYieldsFalse = Internal + 936;
+	/** @since 3.9 */
+	int RedundantNullCheckOnNonNullSpecdField = Internal + 937;
+	/** @since 3.9 */
+	int NonNullSpecdFieldComparisonYieldsFalse = Internal + 938;
+	/** @since 3.9 */
 	int ConflictingNullAnnotations = MethodRelated + 939;
 	/** @since 3.9 */
 	int ConflictingInheritedNullAnnotations = MethodRelated + 940;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 8a29173..4c39142 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -810,6 +811,10 @@ public abstract class Annotation extends Expression {
 							FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(sourceField);
 							recordSuppressWarnings(scope, fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
+						if ((sourceField.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
+							scope.problemReporter().contradictoryNullAnnotations(this);
+							sourceField.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems
+						}
 						break;
 					case Binding.LOCAL :
 						LocalVariableBinding variable = (LocalVariableBinding) this.recipient;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
index 24e87d4..1f5c4d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -53,7 +54,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			flowContext,
 			analyseCode(currentScope, flowContext, flowInfo).unconditionalInits());
 	if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
-		int nullStatus = assignment.expression.nullStatus(flowInfo);
+		int nullStatus = assignment.expression.nullStatus(flowInfo, flowContext);
 		if (nullStatus != FlowInfo.NON_NULL) {
 			currentScope.problemReporter().nullityMismatch(this, assignment.expression.resolvedType, this.resolvedType, nullStatus, currentScope.environment().getNonNullAnnotationName());
 		}
@@ -70,11 +71,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	if ((this.resolvedType.tagBits & TagBits.AnnotationNullable) != 0) {
 		scope.problemReporter().arrayReferencePotentialNullReference(this);
+		return true;
 	} else {
-		super.checkNPE(scope, flowContext, flowInfo);
+		return super.checkNPE(scope, flowContext, flowInfo);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 794f85c..f081a1d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -25,12 +25,16 @@
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *							bug 331649 - [compiler][null] consider null annotations for fields
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
@@ -59,9 +63,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	}
 	
 	FlowInfo preInitInfo = null;
+	CompilerOptions compilerOptions = currentScope.compilerOptions();
 	boolean shouldAnalyseResource = local != null
 			&& flowInfo.reachMode() == FlowInfo.REACHABLE
-			&& currentScope.compilerOptions().analyseResourceLeaks
+			&& compilerOptions.analyseResourceLeaks
 			&& (FakedTrackingVariable.isAnyCloseable(this.expression.resolvedType)
 					|| this.expression.resolvedType == TypeBinding.NULL);
 	if (shouldAnalyseResource) {
@@ -79,14 +84,29 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	else
 		FakedTrackingVariable.cleanUpAfterAssignment(currentScope, this.lhs.bits, this.expression);
 
-	int nullStatus = this.expression.nullStatus(flowInfo);
+	int nullStatus = this.expression.nullStatus(flowInfo, flowContext);
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		if (nullStatus == FlowInfo.NULL) {
 			flowContext.recordUsingNullReference(currentScope, local, this.lhs,
 				FlowContext.CAN_ONLY_NULL | FlowContext.IN_ASSIGNMENT, flowInfo);
 		}
 	}
-	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, local, nullStatus, this.expression, this.expression.resolvedType);
+	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
+		VariableBinding var = this.lhs.nullAnnotatedVariableBinding(compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8);
+		if (var != null) {
+			nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, var, nullStatus, this.expression, this.expression.resolvedType);
+			if (nullStatus == FlowInfo.NON_NULL
+					&& var instanceof FieldBinding
+					&& this.lhs instanceof Reference
+					&& compilerOptions.enableSyntacticNullAnalysisForFields)
+			{
+				int timeToLive = (this.bits & InsideExpressionStatement) != 0
+									? 2  // assignment is statement: make info survives the end of this statement
+									: 1; // assignment is expression: expire on next event.
+				flowContext.recordNullCheckedFieldReference((Reference) this.lhs, timeToLive);
+			}
+		}
+	}
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
 		if (flowContext.initsOnFinally != null)
@@ -138,8 +158,8 @@ FieldBinding getLastField(Expression someExpression) {
     return null;
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return this.expression.nullStatus(flowInfo);
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	return this.expression.nullStatus(flowInfo, flowContext);
 }
 
 public StringBuffer print(int indent, StringBuffer output) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
index 439bcf7..bd419a8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -69,8 +70,15 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		} else {
 			this.left.checkNPE(currentScope, flowContext, flowInfo);
 			flowInfo = this.left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			if (((this.bits & OperatorMASK) >> OperatorSHIFT) != AND) {
+				flowContext.expireNullCheckedFieldInfo();
+			}
 			this.right.checkNPE(currentScope, flowContext, flowInfo);
-			return this.right.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			flowInfo = this.right.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			if (((this.bits & OperatorMASK) >> OperatorSHIFT) != AND) {
+				flowContext.expireNullCheckedFieldInfo();
+			}
+			return flowInfo;
 		}
 	} finally {
 		// account for exception possibly thrown by arithmetics
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index a93b327..491e0eb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -11,6 +11,7 @@
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -34,6 +35,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	// empty block
 	if (this.statements == null)	return flowInfo;
 	int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;
+	boolean enableSyntacticNullAnalysisForFields = currentScope.compilerOptions().enableSyntacticNullAnalysisForFields;
 	for (int i = 0, max = this.statements.length; i < max; i++) {
 		Statement stat = this.statements[i];
 		if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
@@ -42,6 +44,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// record the effect of stat on the finally block of an enclosing try-finally, if any:
 		if (flowContext.initsOnFinally != null)
 			flowContext.mergeFinallyNullInfo(flowInfo);
+		if (enableSyntacticNullAnalysisForFields) {
+			flowContext.expireNullCheckedFieldInfo();
+		}
 	}
 	if (this.explicitDeclarations > 0) {
 		// if block has its own scope analyze tracking vars now:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index a36833b..a446f1e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -16,6 +16,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -454,8 +455,8 @@ public LocalVariableBinding localVariableBinding() {
 	return this.expression.localVariableBinding();
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return this.expression.nullStatus(flowInfo);
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	return this.expression.nullStatus(flowInfo, flowContext);
 }
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
index 4f5c61d..9fa2410 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Patrick Wienands <pwienands@abit.de> - Contribution for bug 393749
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -69,14 +71,20 @@ public class Clinit extends AbstractMethodDeclaration {
 			flowInfo = flowInfo.mergedWith(staticInitializerFlowContext.initsOnReturn);
 			FieldBinding[] fields = this.scope.enclosingSourceType().fields();
 			for (int i = 0, count = fields.length; i < count; i++) {
-				FieldBinding field;
-				if ((field = fields[i]).isStatic()
-					&& field.isFinal()
-					&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {
-					this.scope.problemReporter().uninitializedBlankFinalField(
-						field,
-						this.scope.referenceType().declarationOf(field.original()));
-					// can complain against the field decl, since only one <clinit>
+				FieldBinding field = fields[i];
+				if (field.isStatic()) {
+					if (!flowInfo.isDefinitelyAssigned(field)) {
+						if (field.isFinal()) {
+							this.scope.problemReporter().uninitializedBlankFinalField(
+									field,
+									this.scope.referenceType().declarationOf(field.original()));
+							// can complain against the field decl, since only one <clinit>
+						} else if (field.isNonNull()) {
+							this.scope.problemReporter().uninitializedNonNullField(
+									field,
+									this.scope.referenceType().declarationOf(field.original()));
+						}
+					}
 				}
 			}
 			// check static initializers thrown exceptions
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
index 11074dd..3ab010e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -77,7 +78,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 	return FlowInfo.NON_NULL;
 	// we may have complained on checkNPE, but we avoid duplicate error
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index aa36cb9..8a58a10 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -14,6 +14,7 @@
  * 							bug 354554 - [null] conditional with redundant condition yields weak error message
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -75,6 +76,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		this.trueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);
 		trueFlowInfo = this.valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);
 
+		// may need to fetch this null status before expireNullCheckedFieldInfo():
+		int preComputedTrueNullStatus = -1;
+		if (currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) {
+			preComputedTrueNullStatus = this.valueIfTrue.nullStatus(trueFlowInfo, flowContext);
+			// wipe information that was meant only for valueIfTrue:
+			flowContext.expireNullCheckedFieldInfo();
+		}
+
 		// process the if-false part
 		FlowInfo falseFlowInfo = flowInfo.initsWhenFalse().copy();
 		if (isConditionOptimizedTrue) {
@@ -94,10 +103,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		FlowInfo mergedInfo;
 		if (isConditionOptimizedTrue){
 			mergedInfo = trueFlowInfo.addPotentialInitializationsFrom(falseFlowInfo);
-			this.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo);
+			if (preComputedTrueNullStatus != -1) {
+				this.nullStatus = preComputedTrueNullStatus;
+			} else { 
+				this.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo, flowContext);
+			}
 		} else if (isConditionOptimizedFalse) {
 			mergedInfo = falseFlowInfo.addPotentialInitializationsFrom(trueFlowInfo);
-			this.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo);
+			this.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo, flowContext);
 		} else {
 			// this block must meet two conflicting requirements (see https://bugs.eclipse.org/324178):
 			// (1) For null analysis of "Object o2 = (o1 != null) ? o1 : new Object();" we need to distinguish
@@ -110,7 +123,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			//     (regardless of the evaluation of the condition).
 			
 			// to support (1) use the infos of both branches originating from the condition for computing the nullStatus:
-			computeNullStatus(trueFlowInfo, falseFlowInfo);
+			computeNullStatus(preComputedTrueNullStatus, trueFlowInfo, falseFlowInfo, flowContext);
 			
 			// to support (2) we split the true/false branches according to their inner structure. Consider this:
 			// if (b ? false : (true && (v = false))) return v; -- ok
@@ -153,11 +166,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return mergedInfo;
 	}
 
-	private void computeNullStatus(FlowInfo trueBranchInfo, FlowInfo falseBranchInfo) {
+	private void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {
 		// given that the condition cannot be optimized to a constant 
 		// we now merge the nullStatus from both branches:
-		int ifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo);
-		int ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo);
+		if (ifTrueNullStatus == -1) { // has this status been pre-computed?
+			ifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo, flowContext);
+		}
+		int ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo, flowContext);
 
 		if (ifTrueNullStatus == ifFalseNullStatus) {
 			this.nullStatus = ifTrueNullStatus;
@@ -374,7 +389,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		codeStream.recordPositionsFrom(pc, this.sourceEnd);
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return this.nullStatus;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 4bd9bb8..5378bf7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -14,6 +14,8 @@
  *								bug 361407 - Resource leak warning when resource is assigned to a field outside of constructor
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 383690 - [compiler] location of error re uninitialized final field should be aligned
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -150,12 +152,16 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 
 		// propagate to statements
 		if (this.statements != null) {
+			boolean enableSyntacticNullAnalysisForFields = this.scope.compilerOptions().enableSyntacticNullAnalysisForFields;
 			int complaintLevel = (nonStaticFieldInfoReachMode & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 			for (int i = 0, count = this.statements.length; i < count; i++) {
 				Statement stat = this.statements[i];
 				if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 					flowInfo = stat.analyseCode(this.scope, constructorContext, flowInfo);
 				}
+				if (enableSyntacticNullAnalysisForFields) {
+					constructorContext.expireNullCheckedFieldInfo();
+				}
 			}
 		}
 		// check for missing returning path
@@ -168,21 +174,27 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=235781
 		// flowInfo.setReachMode(initialReachMode);
 
-		// check missing blank final field initializations
+		// check missing blank final field initializations (plus @NonNull)
 		if ((this.constructorCall != null)
 			&& (this.constructorCall.accessMode != ExplicitConstructorCall.This)) {
 			flowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);
 			FieldBinding[] fields = this.binding.declaringClass.fields();
 			for (int i = 0, count = fields.length; i < count; i++) {
-				FieldBinding field;
-				if ((!(field = fields[i]).isStatic())
-					&& field.isFinal()
-					&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {
-					this.scope.problemReporter().uninitializedBlankFinalField(
-						field,
-						((this.bits & ASTNode.IsDefaultConstructor) != 0)
-								? (ASTNode) this.scope.referenceType().declarationOf(field.original())
-								: this);
+				FieldBinding field = fields[i];
+				if (!field.isStatic() && !flowInfo.isDefinitelyAssigned(field)) {
+					if (field.isFinal()) {
+						this.scope.problemReporter().uninitializedBlankFinalField(
+								field,
+								((this.bits & ASTNode.IsDefaultConstructor) != 0)
+									? (ASTNode) this.scope.referenceType().declarationOf(field.original())
+									: this);
+					} else if (field.isNonNull()) {
+							this.scope.problemReporter().uninitializedNonNullField(
+								field,
+								((this.bits & ASTNode.IsDefaultConstructor) != 0) 
+									? (ASTNode) this.scope.referenceType().declarationOf(field.original())
+									: this);
+					}
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 6e4a013..8ede946 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -7,7 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -24,28 +27,67 @@ public class EqualExpression extends BinaryExpression {
 		super(left,right,operator);
 	}
 	private void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {
-		int rightStatus = this.right.nullStatus(flowInfo);
-		int leftStatus = this.left.nullStatus(flowInfo);
-		// check if either is a method annotated @NonNull and compared to null:
+
+		// collect null status of child nodes:
+		int rightStatus = this.right.nullStatus(flowInfo, flowContext);
+		int leftStatus = this.left.nullStatus(flowInfo, flowContext);
+
+		boolean leftNonNullChecked = false;
+		boolean rightNonNullChecked = false;
+
+		// check if either is a non-local expression known to be nonnull and compared to null, candidates are
+		// - method/field annotated @NonNull
+		// - allocation expression, some literals, this reference (see inside expressionNonNullComparison(..))
+		// these checks do not leverage the flowInfo.
+		boolean checkEquality = ((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL;
 		if (leftStatus == FlowInfo.NON_NULL && rightStatus == FlowInfo.NULL) {
-			if (this.left instanceof MessageSend) { 
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);
-			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
+			leftNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.left, checkEquality);
 		} else if (leftStatus == FlowInfo.NULL && rightStatus == FlowInfo.NON_NULL) {
-			if (this.right instanceof MessageSend) {
-				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.right).binding, this.right);
+			rightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkEquality);
+		}
+		
+		// perform flowInfo-based checks for variables and record info for syntactic null analysis for fields:
+		if (!leftNonNullChecked) {
+			LocalVariableBinding local = this.left.localVariableBinding();
+			if (local != null) {
+				if ((local.type.tagBits & TagBits.IsBaseType) == 0) {
+					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
+				}
+			} else if (this.left instanceof Reference
+							&& ((!checkEquality && rightStatus == FlowInfo.NULL) || (checkEquality && rightStatus == FlowInfo.NON_NULL))
+							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields)
+			{
+				FieldBinding field = ((Reference)this.left).lastFieldBinding();
+				if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+					flowContext.recordNullCheckedFieldReference((Reference) this.left, 1);
+				}
 			}
-			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
 		}
-
-		LocalVariableBinding local = this.left.localVariableBinding();
-		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
+		if (!rightNonNullChecked) {
+			LocalVariableBinding local = this.right.localVariableBinding();
+			if (local != null) { 
+				if ((local.type.tagBits & TagBits.IsBaseType) == 0) {
+					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
+				}
+			} else if (this.right instanceof Reference
+							&& ((!checkEquality && leftStatus == FlowInfo.NULL) || (checkEquality && leftStatus == FlowInfo.NON_NULL))
+							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields) 
+			{
+				FieldBinding field = ((Reference)this.right).lastFieldBinding();
+				if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+					flowContext.recordNullCheckedFieldReference((Reference) this.right, 1);
+				}				
+			}
 		}
-		local = this.right.localVariableBinding();
-		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
+
+		// handle reachability:
+		if (leftNonNullChecked || rightNonNullChecked) {
+			// above checks have not propagated unreachable into the corresponding branch, do it now:
+			if (checkEquality) {
+				initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			} else {
+				initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+			}
 		}
 	}
 	private void checkVariableComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse, LocalVariableBinding local, int nullStatus, Expression reference) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index e820034..a529da7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -15,6 +15,8 @@
  *								bug 292478 - Report potentially null across variable assignment
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -43,6 +45,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.problem.ShouldNotImplement;
 import org.eclipse.jdt.internal.compiler.util.Messages;
@@ -524,20 +527,27 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 }
 
 /**
- * Check the local variable of this expression, if any, against potential NPEs
- * given a flow context and an upstream flow info. If so, report the risk to
- * the context. Marks the local as checked, which affects the flow info.
+ * Check this expression against potential NPEs, which may occur:
+ * <ul>
+ * <li>if the expression is the receiver in a field access, qualified allocation, array reference or message send
+ * 		incl. implicit message sends like it happens for the collection in a foreach statement.</li>
+ * <li>if the expression is subject to unboxing</li>
+ * <li>if the expression is the exception in a throw statement</li>
+ * </ul>
+ * If a risk of NPE is detected report it to the context.
+ * If the expression denotes a local variable, mark it as checked, which affects the flow info.
  * @param scope the scope of the analysis
  * @param flowContext the current flow context
  * @param flowInfo the upstream flow info; caveat: may get modified
+ * @return could this expression be checked by the current implementation?
  */
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	if (this.resolvedType != null) {
 		if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
-			return; // no danger
+			return true; // no danger
 		} else if ((this.resolvedType.tagBits & TagBits.AnnotationNullable) != 0) {
 			scope.problemReporter().dereferencingNullableExpression(this, scope.environment());
-			return; // danger is definite.
+			return true; // danger is definite.
 			// stopping analysis at this point requires that the above error is not suppressable
 			// unless suppressing all null warnings (otherwise we'd miss a stronger warning below).
 		}
@@ -558,7 +568,9 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 		if (flowContext.initsOnFinally != null) {
 			flowContext.markFinallyNullStatus(local, FlowInfo.NON_NULL);
 		}
+		return true;
 	}
+	return false; // not checked
 }
 
 public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {
@@ -880,15 +892,8 @@ public void markAsNonNull() {
 	this.bits |= ASTNode.IsNonNull;
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-
-	if (/* (this.bits & IsNonNull) != 0 || */
-		this.constant != null && this.constant != Constant.NotAConstant)
-		return FlowInfo.NON_NULL; // constant expression cannot be null
-
-	LocalVariableBinding local = localVariableBinding();
-	if (local != null)
-		return flowInfo.nullStatus(local);
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	// many kinds of expression need no analysis / are always non-null, make it the default:
 	return FlowInfo.NON_NULL;
 }
 
@@ -1131,4 +1136,15 @@ public void traverse(ASTVisitor visitor, ClassScope scope) {
 public boolean statementExpression() {
 	return false;
 }
+
+/**
+ * Used on the lhs of an assignment for detecting null spec violation.
+ * If this expression represents a null-annotated variable return the variable binding,
+ * otherwise null.
+ * @param supportTypeAnnotations if true this causes any variable binding to be used
+ *   independent of declaration annotations (for in-depth analysis of type annotations)
+*/
+public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
index ed09b09..c7898ee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -84,6 +85,16 @@ public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowCon
 				.unconditionalInits();
 		flowInfo.markAsDefinitelyAssigned(this.binding);
 	}
+	if (this.initialization != null) {
+		if (this.binding.isNonNull()) {
+			int nullStatus = this.initialization.nullStatus(flowInfo, flowContext);
+			// check against annotation @NonNull:
+			if (nullStatus != FlowInfo.NON_NULL) {
+				char[][] annotationName = initializationScope.environment().getNonNullAnnotationName();
+				initializationScope.problemReporter().nullityMismatch(this.initialization, this.initialization.resolvedType, this.binding.type, nullStatus, annotationName);
+			}
+		}
+	}
 	return flowInfo;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index 855d700..7f6393d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -7,7 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -23,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
@@ -35,6 +39,7 @@ import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 
 public class FieldReference extends Reference implements InvocationSite {
 
@@ -107,6 +112,14 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			// assigning a final field outside an initializer or constructor or wrong reference
 			currentScope.problemReporter().cannotAssignToFinalField(this.binding, this);
 		}
+	} else if (this.binding.isNonNull()) {
+		// in a context where it can be assigned?
+		if (   !isCompound
+			&& this.receiver.isThis()
+			&& !(this.receiver instanceof QualifiedThisReference)
+			&& ((this.receiver.bits & ASTNode.ParenthesizedMASK) == 0)) { // (this).x is forbidden
+			flowInfo.markAsDefinitelyAssigned(this.binding);
+		}		
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 	if (!this.binding.isStatic()) {
@@ -149,6 +162,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (flowContext.isNullcheckedFieldAccess(this)) {
+		return true; // enough seen
+	}
+	return checkNullableFieldDereference(scope, this.binding, this.nameSourcePosition);
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -427,6 +447,58 @@ public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream
 public TypeBinding[] genericTypeArguments() {
 	return null;
 }
+
+public boolean isEquivalent(Reference reference) {
+	// only consider field references relative to "this":
+	if (this.receiver.isThis() && !(this.receiver instanceof QualifiedThisReference)) {
+		// current is a simple "this.f1"
+		char[] otherToken = null;
+		// matching 'reference' could be "f1" or "this.f1":
+		if (reference instanceof SingleNameReference) {
+			otherToken = ((SingleNameReference) reference).token;
+		} else if (reference instanceof FieldReference) {
+			FieldReference fr = (FieldReference) reference;
+			if (fr.receiver.isThis() && !(fr.receiver instanceof QualifiedThisReference)) {
+				otherToken = fr.token;
+			}		
+		}
+		return otherToken != null && CharOperation.equals(this.token, otherToken);
+	} else {
+		// search deeper for "this" inside:
+		char[][] thisTokens = getThisFieldTokens(1);
+		if (thisTokens == null) {
+			return false;
+		}
+		// other can be "this.f1.f2", too, or "f1.f2":
+		char[][] otherTokens = null;
+		if (reference instanceof FieldReference) {
+			otherTokens = ((FieldReference) reference).getThisFieldTokens(1);
+		} else if (reference instanceof QualifiedNameReference) {
+			if (((QualifiedNameReference)reference).binding instanceof LocalVariableBinding)
+				return false; // initial variable mismatch: local (from f1.f2) vs. field (from this.f1.f2)
+			otherTokens = ((QualifiedNameReference) reference).tokens;
+		}
+		return CharOperation.equals(thisTokens, otherTokens);
+	}
+}
+
+private char[][] getThisFieldTokens(int nestingCount) {
+	char[][] result = null;
+	if (this.receiver.isThis() && ! (this.receiver instanceof QualifiedThisReference)) {
+		// found an inner-most this-reference, start building the token array:
+		result = new char[nestingCount][];
+		// fill it front to tail while traveling back out:
+		result[0] = this.token;
+	} else if (this.receiver instanceof FieldReference) {
+		result = ((FieldReference)this.receiver).getThisFieldTokens(nestingCount+1);
+		if (result != null) {
+			// front to tail: outermost is last:
+			result[result.length-nestingCount] = this.token;
+		}
+	}
+	return result;
+}
+
 public boolean isSuperAccess() {
 	return this.receiver.isSuper();
 }
@@ -435,6 +507,10 @@ public boolean isTypeAccess() {
 	return this.receiver != null && this.receiver.isTypeReference();
 }
 
+public FieldBinding lastFieldBinding() {
+	return this.binding;
+}
+
 /*
  * No need to emulate access to protected fields since not implicitly accessed
  */
@@ -480,10 +556,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -668,4 +740,14 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 	}
 	visitor.endVisit(this, scope);
 }
+
+public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
+	if (this.binding != null) {
+		if (supportTypeAnnotations
+				|| ((this.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)) {
+			return this.binding;
+		}
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 4cfba98..0521cb4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -104,6 +105,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		thenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);
 	}
+	// any null check from the condition is now expired
+	flowContext.expireNullCheckedFieldInfo();
 	// code gen: optimizing the jump around the ELSE part
 	if ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 		this.bits |= ASTNode.ThenExit;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 92a05a1..3703612 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -42,6 +44,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// no impact upon enclosing try context
 		return FlowInfo.conditional(initsWhenTrue, flowInfo.copy());
 	}
+	if (this.expression instanceof Reference && currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) {
+		FieldBinding field = ((Reference)this.expression).lastFieldBinding();
+		if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+			flowContext.recordNullCheckedFieldReference((Reference) this.expression, 1);
+		}
+	}
 	return this.expression.analyseCode(currentScope, flowContext, flowInfo).
 			unconditionalInits();
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 73ec8af..3e873ad 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -23,6 +23,7 @@
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -120,7 +121,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	else
 		FakedTrackingVariable.cleanUpAfterAssignment(currentScope, Binding.LOCAL, this.initialization);
 
-	int nullStatus = this.initialization.nullStatus(flowInfo);
+	int nullStatus = this.initialization.nullStatus(flowInfo, flowContext);
 	if (!flowInfo.isDefinitelyAssigned(this.binding)){// for local variable debug attributes
 		this.bits |= FirstAssignmentToLocal;
 	} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index d2d7463..10eb2c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -26,6 +26,8 @@
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -190,13 +192,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
 	// account for pot. exceptions thrown by method execution
 	flowContext.recordAbruptExit();
+	flowContext.expireNullCheckedFieldInfo(); // no longer trust this info after any message send
 	return flowInfo;
 }
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
-	if ((nullStatus(flowInfo) & FlowInfo.POTENTIALLY_NULL) != 0) // note that flowInfo is not used inside nullStatus(..)
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	// message send as a receiver
+	if ((nullStatus(flowInfo, flowContext) & FlowInfo.POTENTIALLY_NULL) != 0) // note that flowInfo is not used inside nullStatus(..)
 		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
-	else
-		super.checkNPE(scope, flowContext, flowInfo);
+	return true; // done all possible checking
 }
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
@@ -350,7 +353,7 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 		}
 	}
 }
-public int nullStatus(FlowInfo flowInfo) {
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 	if (this.binding.isValidBinding()) {
 		// try to retrieve null status of this message send from an annotation of the called method:
 		long tagBits = this.binding.tagBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 4f7b68d..9da0932 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -17,6 +17,7 @@
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -123,12 +124,16 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			}
 			// propagate to statements
 			if (this.statements != null) {
+				boolean enableSyntacticNullAnalysisForFields = this.scope.compilerOptions().enableSyntacticNullAnalysisForFields;
 				int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 				for (int i = 0, count = this.statements.length; i < count; i++) {
 					Statement stat = this.statements[i];
 					if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 						flowInfo = stat.analyseCode(this.scope, methodContext, flowInfo);
 					}
+					if (enableSyntacticNullAnalysisForFields) {
+						methodContext.expireNullCheckedFieldInfo();
+					}
 				}
 			} else {
 				// method with empty body should not be flagged as static.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
index 81600f0..eca8adc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NameReference.java
@@ -11,6 +11,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -33,12 +35,23 @@ public NameReference() {
 	this.bits |= Binding.TYPE | Binding.VARIABLE; // restrictiveFlag
 }
 
+/** 
+ * Use this method only when sure that the current reference is <strong>not</strong>
+ * a chain of several fields (QualifiedNameReference with more than one field).
+ * Otherwise use {@link #lastFieldBinding()}.
+ */
 public FieldBinding fieldBinding() {
 	//this method should be sent ONLY after a check against isFieldReference()
 	//check its use doing senders.........
 	return (FieldBinding) this.binding ;
 }
 
+public FieldBinding lastFieldBinding() {
+	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD)
+		return fieldBinding(); // most subclasses only refer to one field anyway
+	return null;
+}
+
 public boolean isSuperAccess() {
 	return false;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
index aa77770..5e5bbbd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullLiteral.java
@@ -7,11 +7,14 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
@@ -49,7 +52,7 @@ public class NullLiteral extends MagicLiteral {
 		return TypeBinding.NULL;
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return FlowInfo.NULL;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
index 443391d..111714a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     Stephan Herrmann - Contributions for
+ *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -41,13 +43,16 @@ public class OR_OR_Expression extends BinaryExpression {
 			 // need to be careful of scenario:
 			//		(x || y) || !z, if passing the left info to the right, it would be swapped by the !
 			FlowInfo mergedInfo = this.left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			flowContext.expireNullCheckedFieldInfo();
 			mergedInfo = this.right.analyseCode(currentScope, flowContext, mergedInfo);
+			flowContext.expireNullCheckedFieldInfo();
 			this.mergedInitStateIndex =
 				currentScope.methodScope().recordInitializationStates(mergedInfo);
 			return mergedInfo;
 		}
 
 		FlowInfo leftInfo = this.left.analyseCode(currentScope, flowContext, flowInfo);
+		flowContext.expireNullCheckedFieldInfo();
 
 		 // need to be careful of scenario:
 		//		(x || y) || !z, if passing the left info to the right, it would be swapped by the !
@@ -63,6 +68,7 @@ public class OR_OR_Expression extends BinaryExpression {
 			}
 		}
 		rightInfo = this.right.analyseCode(currentScope, flowContext, rightInfo);
+		flowContext.expireNullCheckedFieldInfo();
 		if ((this.left.implicitConversion & TypeIds.UNBOXING) != 0) {
 			this.left.checkNPE(currentScope, flowContext, flowInfo);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
index f43174d..3e3de8f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
@@ -8,10 +8,11 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Perry James - nullStatus method improvement (165346)
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
-import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public abstract class OperatorExpression extends Expression implements OperatorIds {
@@ -1556,10 +1557,6 @@ public abstract class OperatorExpression extends Expression implements OperatorI
 		return "unknown operator"; //$NON-NLS-1$
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
-		return FlowInfo.NON_NULL;
-	}
-
 	public StringBuffer printExpression(int indent, StringBuffer output){
 
 		output.append('(');
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 91af72b..9081d52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -17,6 +17,8 @@
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -107,7 +109,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
 			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
+				checkInternalNPE(currentScope, flowContext, flowInfo, true);
 			}
 	}
 
@@ -168,6 +170,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			}
 		}
 	}
+	// note: not covering def.assign for @NonNull: QNR cannot provably refer to a variable of the current object
 	manageSyntheticAccessIfNecessary(currentScope, lastFieldBinding, -1 /*write-access*/, flowInfo);
 
 	return flowInfo;
@@ -213,9 +216,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			} else if (localBinding.useFlag == LocalVariableBinding.UNUSED) {
 				localBinding.useFlag = LocalVariableBinding.FAKE_USED;
 			}
-			if (needValue) {
-				checkNPE(currentScope, flowContext, flowInfo, true);
-			}
+	}
+	if (needValue) {
+		checkInternalNPE(currentScope, flowContext, flowInfo, true);
 	}
 	if (needValue) {
 		manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
@@ -232,9 +235,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
-public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
-	// cannot override localVariableBinding because this would project o.m onto o when
-	// analyzing assignments
+/* check if any dot in this QNR may trigger an NPE. */
+private void checkInternalNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, boolean checkString) {
 	if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.LOCAL) {
 		LocalVariableBinding local = (LocalVariableBinding) this.binding;
 		if (local != null &&
@@ -251,6 +253,38 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 			}
 		}
 	}
+	if (this.otherBindings != null) {
+		if ((this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {
+			// is the first field dereferenced annotated Nullable? If so, report immediately
+			checkNullableFieldDereference(scope, (FieldBinding) this.binding, this.sourcePositions[0]);
+		}
+		// look for annotated fields, they do not depend on flow context -> check immediately:
+		int length = this.otherBindings.length - 1; // don't check the last binding
+		for (int i = 0; i < length; i++) {
+			checkNullableFieldDereference(scope, this.otherBindings[i], this.sourcePositions[i+1]);
+		}
+	}
+}
+
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (super.checkNPE(scope, flowContext, flowInfo)) {
+		return true;
+	}
+	FieldBinding fieldBinding = null;
+	long position = 0L;
+	if (this.otherBindings == null) {
+		if ((this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+			fieldBinding = (FieldBinding) this.binding;
+			position = this.sourcePositions[0];
+		}
+	} else {
+		fieldBinding = this.otherBindings[this.otherBindings.length - 1];
+		position = this.sourcePositions[this.sourcePositions.length - 1];
+	}
+	if (fieldBinding != null) {
+		return checkNullableFieldDereference(scope, fieldBinding, position);
+	}
+	return false;
 }
 
 /**
@@ -785,6 +819,28 @@ public TypeBinding getOtherFieldBindings(BlockScope scope) {
 			: type;
 }
 
+public boolean isEquivalent(Reference reference) {
+	if (reference instanceof FieldReference) {
+		return reference.isEquivalent(this); // comparison FR <-> QNR is implemented only once
+	}
+	if (!(reference instanceof QualifiedNameReference)) return false;
+	// straight-forward test of equality of two QNRs:
+	QualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;
+	if (this.tokens.length != qualifiedReference.tokens.length) return false;
+	if (this.binding != qualifiedReference.binding) return false;
+	if (this.otherBindings != null) {
+		if (qualifiedReference.otherBindings == null) return false;
+		int len = this.otherBindings.length;
+		if (len != qualifiedReference.otherBindings.length) return false;
+		for (int i=0; i<len; i++) {
+			if (this.otherBindings[i] != qualifiedReference.otherBindings[i]) return false;
+		}
+	} else if (qualifiedReference.otherBindings != null) {
+		return false;
+	}
+	return true;
+}
+
 public boolean isFieldAccess() {
 	if (this.otherBindings != null) {
 		return true;
@@ -792,6 +848,15 @@ public boolean isFieldAccess() {
 	return (this.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD;
 }
 
+public FieldBinding lastFieldBinding() {
+	if (this.otherBindings != null) {
+		return this.otherBindings[this.otherBindings.length - 1];		
+	} else if (this.binding != null && (this.bits & RestrictiveFlagMASK) == Binding.FIELD) {
+		return (FieldBinding) this.binding;
+	}
+	return null;
+}
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -846,10 +911,6 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBindi
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	return FlowInfo.UNKNOWN;
-}
-
 public Constant optimizedBooleanConstant() {
 	switch (this.resolvedType.id) {
 		case T_boolean :
@@ -1081,4 +1142,19 @@ public String unboundReferenceErrorName() {
 public char[][] getName() {
 	return this.tokens;
 }
+
+public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
+	if (this.binding != null && isFieldAccess()) {
+		FieldBinding fieldBinding;
+		if (this.otherBindings == null) {
+			fieldBinding = (FieldBinding) this.binding;
+		} else {
+			fieldBinding = this.otherBindings[this.otherBindings.length - 1];
+		}
+		if (supportTypeAnnotations || fieldBinding.isNullable() || fieldBinding.isNonNull()) {
+			return fieldBinding;
+		}
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
index 071429d..242719a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Reference.java
@@ -14,6 +14,8 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -45,6 +47,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	return flowInfo;
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (flowContext.isNullcheckedFieldAccess(this)) {
+		return true; // enough seen
+	}
+	return super.checkNPE(scope, flowContext, flowInfo);
+}
+
+protected boolean checkNullableFieldDereference(Scope scope, FieldBinding field, long sourcePosition) {
+	if ((field.tagBits & TagBits.AnnotationNullable) != 0) {
+		scope.problemReporter().nullableFieldDereference(field, sourcePosition);
+		return true;
+	}
+	return false;
+}
+
 public FieldBinding fieldBinding() {
 	//this method should be sent one FIELD-tagged references
 	//  (ref.bits & BindingIds.FIELD != 0)()
@@ -99,7 +116,30 @@ public abstract void generateCompoundAssignment(BlockScope currentScope, CodeStr
 
 public abstract void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired);
 
-public int nullStatus(FlowInfo flowInfo) {
+/** 
+ * Is the given reference equivalent to the receiver, 
+ * meaning that both denote the same path of field reads?
+ * Used from {@link FlowContext#isNullcheckedFieldAccess(Reference)}.
+ */
+public boolean isEquivalent(Reference reference) {
+	return false;
+}
+
+public FieldBinding lastFieldBinding() {
+	// override to answer the field designated by the entire reference
+	// (as opposed to fieldBinding() which answers the first field in a QNR)
+	return null;
+}
+
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	FieldBinding fieldBinding = lastFieldBinding();
+	if (fieldBinding != null) {
+		if (fieldBinding.isNonNull() || flowContext.isNullcheckedFieldAccess(this)) {
+			return FlowInfo.NON_NULL;
+		} else if (fieldBinding.isNullable()) {
+			return FlowInfo.POTENTIALLY_NULL;
+		}
+	}
 	if (this.resolvedType != null) {
 		if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0)
 			return FlowInfo.NON_NULL;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 566ac23..d90aec5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -25,8 +25,9 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *     Jesper S Moller - Contributions for
- *							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
+ *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -67,7 +68,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			this.expression.checkNPE(currentScope, flowContext, flowInfo);
 		}
 		if (flowInfo.reachMode() == FlowInfo.REACHABLE)
-			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo));
+			checkAgainstNullAnnotation(currentScope, flowContext, this.expression.nullStatus(flowInfo, flowContext));
 		if (currentScope.compilerOptions().analyseResourceLeaks) {
 			FakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression, flowInfo, flowContext);
 			if (trackingVariable != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index 0676cbb..d7f3de9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -11,8 +11,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 292478 - Report potentially null across variable assignment,
- *     											    Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 292478 - Report potentially null across variable assignment,
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -122,6 +125,9 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				} else {
 					currentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);
 				}
+			} else if (!isCompound && fieldBinding.isNonNull()) {
+				// record assignment for detecting uninitialized non-null fields:
+				flowInfo.markAsDefinitelyAssigned(fieldBinding);
 			}
 			if (!fieldBinding.isStatic()) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
@@ -243,6 +249,20 @@ public TypeBinding checkFieldAccess(BlockScope scope) {
 
 }
 
+public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	if (!super.checkNPE(scope, flowContext, flowInfo)) {
+		CompilerOptions compilerOptions = scope.compilerOptions();
+		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
+			VariableBinding var = nullAnnotatedVariableBinding(compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8);
+			if (var instanceof FieldBinding) {
+				checkNullableFieldDereference(scope, (FieldBinding) var, ((long)this.sourceStart<<32)+this.sourceEnd);
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -796,6 +816,19 @@ public TypeBinding[] genericTypeArguments() {
 	return null;
 }
 
+public boolean isEquivalent(Reference reference) {
+	char[] otherToken = null;
+	if (reference instanceof SingleNameReference) {
+		otherToken = ((SingleNameReference) reference).token;
+	} else if (reference instanceof FieldReference) {
+		// test for comparison "f1" vs. "this.f1":
+		FieldReference fr = (FieldReference) reference;
+		if (fr.receiver.isThis() && !(fr.receiver instanceof QualifiedThisReference))
+			otherToken = fr.token;
+	}
+	return otherToken != null && CharOperation.equals(this.token, otherToken);
+}
+
 /**
  * Returns the local variable referenced by this node. Can be a direct reference (SingleNameReference)
  * or thru a cast expression etc...
@@ -810,6 +843,25 @@ public LocalVariableBinding localVariableBinding() {
 	return null;
 }
 
+public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
+	switch (this.bits & ASTNode.RestrictiveFlagMASK) {
+		case Binding.FIELD : // reading a field
+		case Binding.LOCAL : // reading a local variable
+			if (supportTypeAnnotations 
+					|| (((VariableBinding)this.binding).tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)
+				return (VariableBinding) this.binding;
+	}
+	return null;
+}
+
+public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
+	LocalVariableBinding local = localVariableBinding();
+	if (local != null) {
+		return flowInfo.nullStatus(local);
+	}
+	return super.nullStatus(flowInfo, flowContext);
+}
+
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (((this.bits & ASTNode.DepthMASK) == 0) || (this.constant != Constant.NotAConstant)) {
@@ -856,22 +908,7 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 
-public int nullStatus(FlowInfo flowInfo) {
-	if (this.constant != null && this.constant != Constant.NotAConstant) {
-		return FlowInfo.NON_NULL; // constant expression cannot be null
-	}
-	switch (this.bits & ASTNode.RestrictiveFlagMASK) {
-		case Binding.FIELD : // reading a field
-			return FlowInfo.UNKNOWN;
-		case Binding.LOCAL : // reading a local variable
-			LocalVariableBinding local = (LocalVariableBinding) this.binding;
-			if (local != null)
-				return flowInfo.nullStatus(local);
-	}
-	return FlowInfo.NON_NULL; // never get there
-}
-
-	/**
+/**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#postConversionType(Scope)
  */
 public TypeBinding postConversionType(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 1a14bbb..23d2c27 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -20,6 +20,8 @@
  *								bug 370930 - NonNull annotation not considered for enhanced for loops
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -109,7 +111,7 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 					currentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity==1, currentScope.environment());
 					// next check flow-based null status against null JDK15-style annotations:
 				} else if (hasJDK15NullAnnotations && methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
-					int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+					int nullStatus = argument.nullStatus(flowInfo, flowContext); // slight loss of precision: should also use the null info from the receiver.
 					if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
 						flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 				}
@@ -119,7 +121,7 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 				if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
 					TypeBinding expectedType = methodBinding.parameters[i];
 					Expression argument = arguments[i];
-					int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+					int nullStatus = argument.nullStatus(flowInfo, flowContext); // slight loss of precision: should also use the null info from the receiver.
 					if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
 						flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 				}
@@ -128,22 +130,20 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 	}
 }
 
-/** Check null-ness of 'local' against a possible null annotation */
+/** Check null-ness of 'var' against a possible null annotation */
 protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext,
-												   LocalVariableBinding local, int nullStatus, Expression expression, TypeBinding providedType)
+												   VariableBinding var, int nullStatus, Expression expression, TypeBinding providedType)
 {
-	if (local != null) {
-		int severity = 0;
-		if ((local.tagBits & TagBits.AnnotationNonNull) != 0
-				&& nullStatus != FlowInfo.NON_NULL) {
-			flowContext.recordNullityMismatch(currentScope, expression, providedType, local.type, nullStatus);
-			return FlowInfo.NON_NULL;
-		} else if ((severity = findNullTypeAnnotationMismatch(local.type, providedType)) > 0) {
-			currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, local.type, severity==1, currentScope.environment());
-		} else if ((local.tagBits & TagBits.AnnotationNullable) != 0
-				&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
-			return FlowInfo.POTENTIALLY_NULL;			// -> use more specific info from the annotation
-		}
+	int severity = 0;
+	if ((var.tagBits & TagBits.AnnotationNonNull) != 0
+			&& nullStatus != FlowInfo.NON_NULL) {
+		flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, nullStatus);
+		return FlowInfo.NON_NULL;
+	} else if ((severity = findNullTypeAnnotationMismatch(var.type, providedType)) > 0) {
+		currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, var.type, severity==1, currentScope.environment());
+	} else if ((var.tagBits & TagBits.AnnotationNullable) != 0
+			&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
+		return FlowInfo.POTENTIALLY_NULL;			// -> use more specific info from the annotation
 	}
 	return nullStatus;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index 45b6447..8e676fb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -7,6 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -56,6 +59,10 @@ public class ThisReference extends Reference {
 		return true;
 	}
 
+	public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+		return true; // never problematic
+	}
+
 	/*
 	 * @see Reference#generateAssignment(...)
 	 */
@@ -98,7 +105,7 @@ public class ThisReference extends Reference {
 		return true ;
 	}
 
-	public int nullStatus(FlowInfo flowInfo) {
+	public int nullStatus(FlowInfo flowInfo, FlowContext flowContext) {
 		return FlowInfo.NON_NULL;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index 4241f76..e1f18f5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -414,7 +414,9 @@ public MethodBinding createDefaultConstructorWithBinding(MethodBinding inherited
 			sourceType); //declaringClass
 	constructor.binding.tagBits |= (inheritedConstructorBinding.tagBits & TagBits.HasMissingType);
 	constructor.binding.modifiers |= ExtraCompilerModifiers.AccIsDefaultConstructor;
-	if (inheritedConstructorBinding.parameterNonNullness != null) { // this implies that annotation based null analysis is enabled
+	if (inheritedConstructorBinding.parameterNonNullness != null // this implies that annotation based null analysis is enabled
+			&& argumentsLength > 0) 
+	{
 		// copy nullness info from inherited constructor to the new constructor:
 		int len = inheritedConstructorBinding.parameterNonNullness.length;
 		System.arraycopy(inheritedConstructorBinding.parameterNonNullness, 0, 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
index 261bf8e..81b9323 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -33,9 +35,11 @@ public FlowInfo analyseCode(
 		FlowInfo flowInfo) {
 	this.expression.checkNPE(currentScope, flowContext, flowInfo);
 	if (((this.bits & OperatorMASK) >> OperatorSHIFT) == NOT) {
-		return this.expression.
+		flowInfo = this.expression.
 			analyseCode(currentScope, flowContext, flowInfo).
 			asNegatedCondition();
+		flowContext.expireNullCheckedFieldInfo();
+		return flowInfo;
 	} else {
 		return this.expression.
 			analyseCode(currentScope, flowContext, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 53e8a3c..ba342e3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -17,6 +17,7 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -75,6 +76,12 @@ public class FlowContext implements TypeConstants {
 	// array to store the provided and expected types from the potential error location (for display in error messages):
 	public TypeBinding[][] providedExpectedTypes = null;
 
+	// record field references known to be non-null
+	//   this array will never shrink, only grow. reset happens by nulling the first cell
+	//   adding elements after reset ensures that the valid part of the array is always null-terminated
+	private Reference[] nullCheckedFieldReferences = null;
+	private int timeToLiveForNullCheckInfo = -1;
+
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
 	/**
@@ -114,9 +121,74 @@ public FlowContext(FlowContext parent, ASTNode associatedNode) {
 		}
 		this.initsOnFinally = parent.initsOnFinally;
 		this.conditionalLevel = parent.conditionalLevel;
+		this.nullCheckedFieldReferences = parent.nullCheckedFieldReferences; // re-use list if there is one
 	}
 }
 
+/**
+ * Record that a reference to a field has been seen in a non-null state.
+ *
+ * @param reference Can be a SingleNameReference, a FieldReference or a QualifiedNameReference resolving to a field
+ * @param timeToLive control how many expire events are needed to expire this information
+ */
+public void recordNullCheckedFieldReference(Reference reference, int timeToLive) {
+	this.timeToLiveForNullCheckInfo = timeToLive;
+	if (this.nullCheckedFieldReferences == null) {
+		// first entry:
+		this.nullCheckedFieldReferences = new Reference[2];
+		this.nullCheckedFieldReferences[0] = reference;
+	} else {
+		int len = this.nullCheckedFieldReferences.length;
+		// insert into first empty slot:
+		for (int i=0; i<len; i++) {
+			if (this.nullCheckedFieldReferences[i] == null) {
+				this.nullCheckedFieldReferences[i] = reference;
+				if (i+1 < len) {
+					this.nullCheckedFieldReferences[i+1] = null; // lazily mark next as empty
+				}
+				return;
+			}
+		}
+		// grow array:
+		System.arraycopy(this.nullCheckedFieldReferences, 0, this.nullCheckedFieldReferences=new Reference[len+2], 0, len);
+		this.nullCheckedFieldReferences[len] = reference;
+	}
+}
+/**
+ * Forget any information about fields that were previously known to be non-null.
+ * 
+ * Will only cause any effect if CompilerOptions.enableSyntacticNullAnalysisForFields
+ * (implicitly by guards before calls to {@link #recordNullCheckedFieldReference(Reference, int)}).
+ */	 
+public void expireNullCheckedFieldInfo() {
+	if (this.nullCheckedFieldReferences != null) {
+		if (--this.timeToLiveForNullCheckInfo == 0) {
+			this.nullCheckedFieldReferences[0] = null; // lazily wipe
+		}
+	}
+}
+
+/** 
+ * Is the given field reference equivalent to a reference that is freshly known to be non-null?
+ * Can only return true if CompilerOptions.enableSyntacticNullAnalysisForFields
+ * (implicitly by guards before calls to {@link #recordNullCheckedFieldReference(Reference, int)}).
+ */
+public boolean isNullcheckedFieldAccess(Reference reference) {
+	if (this.nullCheckedFieldReferences == null)  // always null unless CompilerOptions.enableSyntacticNullAnalysisForFields
+		return false;
+	int len = this.nullCheckedFieldReferences.length;
+	for (int i=0; i<len; i++) {
+		Reference checked = this.nullCheckedFieldReferences[i];
+		if (checked == null) {
+			return false;
+		}
+		if (checked.isEquivalent(reference)) {
+			return true;
+		}
+	}
+	return false;
+}
+
 public BranchLabel breakLabel() {
 	return null;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 7ed6c27..bc6b886 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -22,6 +22,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -168,6 +169,7 @@ public class CompilerOptions {
 	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
 	public static final String OPTION_ReportMissingNonNullByDefaultAnnotation = "org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation";  //$NON-NLS-1$
+	public static final String OPTION_SyntacticNullAnalysisForFields = "org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 	/**
@@ -438,6 +440,9 @@ public class CompilerOptions {
 	/** Should null annotations of overridden methods be inherited? */
 	public boolean inheritNullAnnotations;
 
+	/** Should immediate null-check for fields be considered during null analysis (syntactical match)? */
+	public boolean enableSyntacticNullAnalysisForFields;
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
@@ -834,6 +839,7 @@ public class CompilerOptions {
 			OPTION_ReportNullAnnotationInferenceConflict,
 			OPTION_ReportNullUncheckedConversion,
 			OPTION_ReportRedundantNullAnnotation,
+			OPTION_SyntacticNullAnalysisForFields,
 			OPTION_ReportUnusedTypeParameter,
 			OPTION_InheritNullAnnotations,
 			OPTION_ReportNonnullParameterAnnotationDropped
@@ -1135,6 +1141,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_NonNullByDefaultAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullByDefaultAnnotationName, '.')));
 		optionsMap.put(OPTION_ReportMissingNonNullByDefaultAnnotation, getSeverityString(MissingNonNullByDefaultAnnotation));
 		optionsMap.put(OPTION_ReportUnusedTypeParameter, getSeverityString(UnusedTypeParameter));
+		optionsMap.put(OPTION_SyntacticNullAnalysisForFields, this.enableSyntacticNullAnalysisForFields ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		return optionsMap;
@@ -1295,6 +1302,7 @@ public class CompilerOptions {
 		this.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;
 		this.nonNullByDefaultAnnotationName = DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME;
 		this.intendedDefaultNonNullness = 0;
+		this.enableSyntacticNullAnalysisForFields = false;
 		this.inheritNullAnnotations = false;
 		
 		this.analyseResourceLeaks = true;
@@ -1626,6 +1634,9 @@ public class CompilerOptions {
 				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
 			}
 			if ((optionValue = optionsMap.get(OPTION_ReportMissingNonNullByDefaultAnnotation)) != null) updateSeverity(MissingNonNullByDefaultAnnotation, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_SyntacticNullAnalysisForFields)) != null) {
+				this.enableSyntacticNullAnalysisForFields = ENABLED.equals(optionValue);
+			}
 			if ((optionValue = optionsMap.get(OPTION_InheritNullAnnotations)) != null) {
 				this.inheritNullAnnotations = ENABLED.equals(optionValue);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 3328269..992b27e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -20,6 +20,7 @@
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 388800 - [1.8][compiler] detect default methods in class files
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -449,6 +450,12 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 					this.fields[i].setAnnotations(createAnnotations(binaryField.getAnnotations(), this.environment, missingTypeNames));
 				}
 			}
+			if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				for (int i = 0; i <size; i++) {
+					IBinaryField binaryField = iFields[i];
+					scanFieldForNullAnnotation(binaryField, this.fields[i]);
+				}
+			}
 		}
 	}
 }
@@ -1166,6 +1173,42 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	}
 	return this.storedAnnotations;
 }
+
+void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding) {
+	// global option is checked by caller
+	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
+	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
+	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+		return; // not well-configured to use null annotations
+
+	if (fieldBinding.type == null || fieldBinding.type.isBaseType())
+		return; // null annotations are only applied to reference types
+
+	boolean explicitNullness = false;
+	IBinaryAnnotation[] annotations = field.getAnnotations();
+	if (annotations != null) {
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != Util.C_RESOLVED)
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNonNull;
+				explicitNullness = true;
+				break;
+			}
+			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				fieldBinding.tagBits |= TagBits.AnnotationNullable;
+				explicitNullness = true;
+				break;
+			}
+		}
+	}
+	if (!explicitNullness && (this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+		fieldBinding.tagBits |= TagBits.AnnotationNonNull;
+	}
+}
+
 void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
 	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
 		return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index b27798d..8485b55 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *								bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -223,6 +225,17 @@ public Constant constant() {
 	return fieldConstant;
 }
 
+public void fillInDefaultNonNullness(FieldDeclaration sourceField, Scope scope) {
+	if (   this.type != null
+		&& !this.type.isBaseType()
+		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+	{
+		this.tagBits |= TagBits.AnnotationNonNull;
+	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
+		scope.problemReporter().nullAnnotationIsRedundant(sourceField);
+	}
+}
+
 /**
  * X<T> t   -->  LX<TT;>;
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
index 1a46b85..1180893 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
@@ -12,6 +12,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -176,14 +177,6 @@ public class LocalVariableBinding extends VariableBinding {
 		}
 	}
 
-	public boolean isNonNull() {
-		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
-	}
-
-	public boolean isNullable() {
-		return (this.tagBits & TagBits.AnnotationNullable) != 0;
-	}
-
 	// Answer whether the variable binding is a secret variable added for code gen purposes
 	public boolean isSecret() {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 7de3f34..a242872 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -19,6 +19,8 @@
  *								bug 384663 - Package Based Annotation Compilation Error in JDT 3.8/4.2 (works in 3.7.2)
  *								bug 386356 - Type mismatch error with annotations and generics
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 380896 - [compiler][null] Enum constants not recognised as being NonNull.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1424,43 +1426,59 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 		if (fieldDecls[f].binding != field)
 			continue;
 
-			MethodScope initializationScope = field.isStatic()
-				? this.scope.referenceContext.staticInitializerScope
-				: this.scope.referenceContext.initializerScope;
-			FieldBinding previousField = initializationScope.initializedField;
-			try {
-				initializationScope.initializedField = field;
-				FieldDeclaration fieldDecl = fieldDecls[f];
-				TypeBinding fieldType =
-					fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT
-						? initializationScope.environment().convertToRawType(this, false /*do not force conversion of enclosing types*/) // enum constant is implicitly of declaring enum type
-						: fieldDecl.type.resolveType(initializationScope, true /* check bounds*/);
-				field.type = fieldType;
-				field.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
-				if (fieldType == null) {
-					fieldDecl.binding = null;
-					return null;
-				}
-				if (fieldType == TypeBinding.VOID) {
-					this.scope.problemReporter().variableTypeCannotBeVoid(fieldDecl);
-					fieldDecl.binding = null;
-					return null;
-				}
-				if (fieldType.isArrayType() && ((ArrayBinding) fieldType).leafComponentType == TypeBinding.VOID) {
-					this.scope.problemReporter().variableTypeCannotBeVoidArray(fieldDecl);
-					fieldDecl.binding = null;
-					return null;
-				}
-				if ((fieldType.tagBits & TagBits.HasMissingType) != 0) {
-					field.tagBits |= TagBits.HasMissingType;
-				}
-				TypeBinding leafType = fieldType.leafComponentType();
-				if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0) {
-					field.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
+		MethodScope initializationScope = field.isStatic()
+			? this.scope.referenceContext.staticInitializerScope
+			: this.scope.referenceContext.initializerScope;
+		FieldBinding previousField = initializationScope.initializedField;
+		try {
+			initializationScope.initializedField = field;
+			FieldDeclaration fieldDecl = fieldDecls[f];
+			TypeBinding fieldType =
+				fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT
+					? initializationScope.environment().convertToRawType(this, false /*do not force conversion of enclosing types*/) // enum constant is implicitly of declaring enum type
+					: fieldDecl.type.resolveType(initializationScope, true /* check bounds*/);
+			field.type = fieldType;
+			field.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
+			if (fieldType == null) {
+				fieldDecl.binding = null;
+				return null;
+			}
+			if (fieldType == TypeBinding.VOID) {
+				this.scope.problemReporter().variableTypeCannotBeVoid(fieldDecl);
+				fieldDecl.binding = null;
+				return null;
+			}
+			if (fieldType.isArrayType() && ((ArrayBinding) fieldType).leafComponentType == TypeBinding.VOID) {
+				this.scope.problemReporter().variableTypeCannotBeVoidArray(fieldDecl);
+				fieldDecl.binding = null;
+				return null;
+			}
+			if ((fieldType.tagBits & TagBits.HasMissingType) != 0) {
+				field.tagBits |= TagBits.HasMissingType;
+			}
+			TypeBinding leafType = fieldType.leafComponentType();
+			if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0) {
+				field.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
+			}
+
+			// apply null default:
+			LookupEnvironment environment = this.scope.environment();
+			if (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+				if (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {
+					// enum constants neither have a type declaration nor can they be null
+					field.tagBits |= TagBits.AnnotationNonNull;
+				} else {
+					initializeNullDefault();
+					if (hasNonNullDefault()) {
+						field.fillInDefaultNonNullness(fieldDecl, initializationScope);
+					}
+					// validate null annotation:
+					this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations);
 				}
-			} finally {
-			    initializationScope.initializedField = previousField;
 			}
+		} finally {
+		    initializationScope.initializedField = previousField;
+		}
 		return field;
 	}
 	return null; // should never reach this point
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
index 23c5bbc..53b2bd8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VariableBinding.java
@@ -7,6 +7,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								bug 331649 - [compiler][null] consider null annotations for fields
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -52,7 +54,17 @@ public abstract class VariableBinding extends Binding {
 	public final boolean isEffectivelyFinal() {
 		return (this.tagBits & TagBits.IsEffectivelyFinal) != 0;
 	}
-	
+
+	/** Answer true if null annotations are enabled and this field is specified @NonNull */
+	public boolean isNonNull() {
+		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
+	}
+
+	/** Answer true if null annotations are enabled and this field is specified @Nullable */
+	public boolean isNullable() {
+		return (this.tagBits & TagBits.AnnotationNullable) != 0;
+	}
+
 	public char[] readableName() {
 		return this.name;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 50e00bd..68b9d7d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -30,6 +30,8 @@
  *								bug 393719 - [compiler] inconsistent warnings on iteration variables
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 388739 - [1.8][compiler] consider default methods when detecting whether a class needs to be declared abstract
+ *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -56,6 +58,7 @@ import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
@@ -65,6 +68,7 @@ import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.BranchStatement;
 import org.eclipse.jdt.internal.compiler.ast.CaseStatement;
 import org.eclipse.jdt.internal.compiler.ast.CastExpression;
+import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
@@ -87,6 +91,7 @@ import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
+import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
@@ -134,6 +139,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
@@ -313,6 +319,7 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.VarargsArgumentNeedCast;
 
 		case IProblem.NullLocalVariableReference:
+		case IProblem.NullableFieldReference:
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
@@ -327,9 +334,14 @@ public static int getIrritant(int problemID) {
 		case IProblem.NonNullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableInstanceofYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullExpression:
+		case IProblem.NonNullExpressionComparisonYieldsFalse:
 		case IProblem.RedundantNullCheckOnNonNullMessageSend:
 		case IProblem.RedundantNullCheckOnSpecdNonNullLocalVariable:
 		case IProblem.SpecdNonNullLocalVariableComparisonYieldsFalse:
+		case IProblem.NonNullMessageSendComparisonYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullSpecdField:
+		case IProblem.NonNullSpecdFieldComparisonYieldsFalse:
 			return CompilerOptions.RedundantNullCheck;
 
 		case IProblem.RequiredNonNullButProvidedNull:
@@ -342,6 +354,8 @@ public static int getIrritant(int problemID) {
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
 		case IProblem.NullityMismatchingTypeAnnotation:
+		case IProblem.UninitializedNonNullField:
+		case IProblem.UninitializedNonNullFieldHintMissingDefault:
 			return CompilerOptions.NullSpecViolation;
 
 		case IProblem.ParameterLackingNonNullAnnotation:
@@ -5395,6 +5409,92 @@ public void localVariableNullComparedToNonNull(LocalVariableBinding local, ASTNo
 		nodeSourceEnd(local, location));
 }
 
+/**
+ * @param expr expression being compared for null or nonnull
+ * @param checkForNull true if checking for null, false if checking for nonnull 
+ */
+public boolean expressionNonNullComparison(Expression expr, boolean checkForNull) {
+	int problemId = 0;
+	Binding binding = null;
+	String[] arguments = null;
+	int start = 0, end = 0;
+
+	Expression location = expr;
+	// unwrap uninteresting nodes:
+	while (true) {
+		if (expr instanceof Assignment)
+			return false; // don't report against the assignment, but the variable
+		else if (expr instanceof CastExpression)
+			expr = ((CastExpression) expr).expression;
+		else
+			break;
+	}
+	// check all those kinds of expressions that can possible answer NON_NULL from nullStatus():
+	if (expr instanceof MessageSend) {
+		problemId = checkForNull 
+				? IProblem.NonNullMessageSendComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullMessageSend;
+		MethodBinding method = ((MessageSend)expr).binding;
+		binding = method;
+		arguments = new String[] { new String(method.shortReadableName()) };
+		start = location.sourceStart;
+		end = location.sourceEnd;
+	} else if (expr instanceof Reference && !(expr instanceof ThisReference) && !(expr instanceof ArrayReference)) {
+		FieldBinding field = ((Reference)expr).lastFieldBinding();
+		if (field == null) {
+			return false;
+		}
+		if (field.isNonNull()) {
+			problemId = checkForNull
+					? IProblem.NonNullSpecdFieldComparisonYieldsFalse
+					: IProblem.RedundantNullCheckOnNonNullSpecdField;
+			char[][] nonNullName = this.options.nonNullAnnotationName;
+			arguments = new String[] { new String(field.name), 
+									   new String(nonNullName[nonNullName.length-1]) };
+		}
+		binding = field;
+		start = nodeSourceStart(binding, location);
+		end = nodeSourceEnd(binding, location);
+	} else if (expr instanceof AllocationExpression 
+			|| expr instanceof ArrayAllocationExpression 
+			|| expr instanceof ArrayInitializer
+			|| expr instanceof ClassLiteralAccess
+			|| expr instanceof ThisReference) {
+		// fall through to bottom
+	} else if (expr instanceof Literal
+				|| expr instanceof ConditionalExpression) {
+		if (expr instanceof NullLiteral) {
+			needImplementation(location); // reported as nonnull??
+			return false;
+		}
+		if (expr.resolvedType != null && expr.resolvedType.isBaseType()) {
+			// false alarm, auto(un)boxing is involved
+			return false;
+		}
+		// fall through to bottom
+	} else if (expr instanceof BinaryExpression) {
+		if ((expr.bits & ASTNode.ReturnTypeIDMASK) != TypeIds.T_JavaLangString) {
+			// false alarm, primitive types involved, must be auto(un)boxing?
+			return false;
+		}
+		// fall through to bottom
+	} else {
+		needImplementation(expr); // want to see if we get here
+		return false;
+	}
+	if (problemId == 0) {
+		// standard case, fill in details now
+		problemId = checkForNull 
+				? IProblem.NonNullExpressionComparisonYieldsFalse
+				: IProblem.RedundantNullCheckOnNonNullExpression;
+		start = location.sourceStart;
+		end = location.sourceEnd;
+		arguments = NoArgument;
+	}
+	this.handle(problemId, arguments, arguments, start, end);
+	return true;
+}
+
 public void localVariableNullInstanceof(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.NullLocalVariableInstanceofYieldsFalse);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -5434,6 +5534,18 @@ public void localVariablePotentialNullReference(LocalVariableBinding local, ASTN
 		nodeSourceEnd(local, location));
 }
 
+public void nullableFieldDereference(VariableBinding variable, long position) {
+	String[] arguments = new String[] {new String(variable.name)};
+	char[][] nullableName = this.options.nullableAnnotationName;
+		arguments = new String[] {new String(variable.name), new String(nullableName[nullableName.length-1])};
+	this.handle(
+		IProblem.NullableFieldReference,
+		arguments,
+		arguments,
+		(int)(position >>> 32),
+		(int)(position));
+}
+
 public void localVariableRedundantCheckOnNonNull(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.RedundantNullCheckOnNonNullLocalVariable);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -7475,6 +7587,19 @@ public void uninitializedBlankFinalField(FieldBinding field, ASTNode location) {
 		nodeSourceStart(field, location),
 		nodeSourceEnd(field, location));
 }
+public void uninitializedNonNullField(FieldBinding field, ASTNode location) {
+	char[][] nonNullAnnotationName = this.options.nonNullAnnotationName;
+	String[] arguments = new String[] {
+			new String(nonNullAnnotationName[nonNullAnnotationName.length-1]),
+			new String(field.readableName())
+	};
+	this.handle(
+		methodHasMissingSwitchDefault() ? IProblem.UninitializedNonNullFieldHintMissingDefault : IProblem.UninitializedNonNullField,
+		arguments,
+		arguments,
+		nodeSourceStart(field, location),
+		nodeSourceEnd(field, location));
+}
 public void uninitializedLocalVariable(LocalVariableBinding binding, ASTNode location) {
 	binding.tagBits |= TagBits.NotInitialized;
 	String[] arguments = new String[] {new String(binding.readableName())};
@@ -8488,14 +8613,13 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 		return;
 	}
 	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0) {
-		if (expression instanceof SingleNameReference) {
-			SingleNameReference snr = (SingleNameReference) expression;
-			if (snr.binding instanceof LocalVariableBinding) {
-				if (((LocalVariableBinding)snr.binding).isNullable()) {
-					nullityMismatchSpecdNullable(expression, requiredType, annotationName);
-					return;
-				}
-			}
+		VariableBinding var = expression.localVariableBinding();
+		if (var == null && expression instanceof Reference) {
+			var = ((Reference)expression).lastFieldBinding();
+		}
+		if (var != null && var.isNullable()) {
+			nullityMismatchSpecdNullable(expression, requiredType, annotationName);
+			return;
 		}
 		nullityMismatchPotentiallyNull(expression, requiredType, annotationName);
 		return;
@@ -8687,6 +8811,13 @@ public void nullAnnotationIsRedundant(AbstractMethodDeclaration sourceMethod, in
 	this.handle(IProblem.RedundantNullAnnotation, ProblemHandler.NoArgument, ProblemHandler.NoArgument, sourceStart, sourceEnd);
 }
 
+public void nullAnnotationIsRedundant(FieldDeclaration sourceField) {
+	Annotation annotation = findAnnotation(sourceField.annotations, TypeIds.T_ConfiguredAnnotationNonNull);
+	int sourceStart = annotation != null ? annotation.sourceStart : sourceField.type.sourceStart;
+	int sourceEnd = sourceField.type.sourceEnd;
+	this.handle(IProblem.RedundantNullAnnotation, ProblemHandler.NoArgument, ProblemHandler.NoArgument, sourceStart, sourceEnd);
+}
+
 public void nullDefaultAnnotationIsRedundant(ASTNode location, Annotation[] annotations, Binding outer) {
 	Annotation annotation = findAnnotation(annotations, TypeIds.T_ConfiguredAnnotationNonNullByDefault);
 	int start = annotation != null ? annotation.sourceStart : location.sourceStart;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 924e6bb..4460853 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -27,6 +27,7 @@
 #							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
 #							bug 393719 - [compiler] inconsistent warnings on iteration variables
 #							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+#							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 ###############################################################################
@@ -625,6 +626,10 @@
 ### MORE TYPE RELATED
 662 = Illegal attempt to create arrays of union types
 
+### NULL ANALYSIS FOR OTHER EXPRESSIONS
+670 = Null comparison always yields false: this expression cannot be null
+671 = Redundant null check: this expression cannot be null
+
 ### CORRUPTED BINARIES
 700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}
 
@@ -721,6 +726,7 @@
 921 = The method {0} from {1} cannot implement the corresponding method from {2} due to incompatible nullness constraints
 922 = The nullness annotation is redundant with a default that applies to this location
 923 = The nullness annotation @{0} is not applicable for the primitive type {1}
+924 = Potential null pointer access: The field {0} is declared as @{1}
 925 = Nullness default is redundant with the global default
 926 = Nullness default is redundant with a default specified for the enclosing package {0}
 927 = Nullness default is redundant with a default specified for the enclosing type {0}
@@ -730,6 +736,11 @@
 931 = Redundant null check: The variable {0} is specified as @{1}
 932 = Null comparison always yields false: The variable {0} is specified as @{1}
 933 = Null type mismatch: required ''{0}'' but the provided value is specified as @{1}
+934 = The @{0} field {1} may not have been initialized
+935 = The @{0} field {1} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
+936 = Null comparison always yields false: The method {0} cannot return null
+937 = Redundant null check: The field {0} is declared as @{1}
+938 = Null comparison always yields false: The field {0} is declared as @{1}
 939 = The default ''@{0}'' conflicts with the inherited ''@{1}'' annotation in the overridden method from {2} 
 940 = Conflict between inherited null annotations ''@{0}'' declared in {1} versus ''@{2}'' declared in {3} 
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index fb96c44..3985932 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -97,6 +97,7 @@
  *									COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
+ *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1490,7 +1491,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is a legal value in that position. Currently supported
-	 *    positions are: method parameters, method return type and local variables.</p>
+	 *    positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>If a value whose type
 	 *    is annotated with this annotation is dereferenced without checking for null,
 	 *    the compiler will trigger a diagnostic as further controlled by
@@ -1516,7 +1517,7 @@ public final class JavaCore extends Plugin {
 	 * <p>If the annotation specified by this option is applied to a type in a method
 	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is <b>not</b> a legal value in that position. Currently
-	 *    supported positions are: method parameters, method return type and local variables.</p>
+	 *    supported positions are: method parameters, method return type, fields and local variables.</p>
 	 * <p>For values declared with this annotation, the compiler will never trigger a null
 	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
 	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
@@ -1540,8 +1541,8 @@ public final class JavaCore extends Plugin {
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
 	 * <p>If the annotation is applied without an argument, all unannotated types in method signatures
-	 *    within the annotated element will be treated as if they were specified with the non-null annotation
-	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
+	 *    and field declarations within the annotated element will be treated as if they were specified
+	 *    with the non-null annotation (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
 	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
 	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.</p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
@@ -1592,6 +1593,9 @@ public final class JavaCore extends Plugin {
 	 *        for at least one of its parameters, tries to tighten that null contract by
 	 *        specifying a nonnull annotation for its corresponding parameter
 	 *        (prohibition of covariant parameters).</li>
+	 *    <li>A non-static field with a nonnull annotation is not definitely assigned at
+	 *        the end of each constructor.</li>
+	 *    <li>A static field with a nonnull annotation is not definitely assigned in static initializers.</li>
 	 *    </ol>
 	 *    In the above an expression is considered as <em>nullable</em> if
 	 *    either it is statically known to evaluate to the value <code>null</code>, or if it is
@@ -1688,6 +1692,20 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_REDUNDANT_NULL_ANNOTATION = PLUGIN_ID + ".compiler.problem.redundantNullAnnotation"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Perform syntactic null analysis for fields.
+	 * <p>When enabled, the compiler will detect certain syntactic constellations where a null
+	 *	  related warning against a field reference would normally be raised but can be suppressed
+	 *    at low risk given that the same field reference was known to be non-null immediately before.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
+	 * @since 3.9
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS = JavaCore.PLUGIN_ID+".compiler.problem.syntacticNullAnalysisForFields"; //$NON-NLS-1$
+	/**
 	 * Compiler option ID: Inheritance of null annotations.
 	 * <p>When enabled, the compiler will check for each method without any explicit null annotations:
 	 *    If it overrides a method which has null annotations, it will treat the
@@ -5597,4 +5615,4 @@ public final class JavaCore extends Plugin {
 		super.start(context);
 		JavaModelManager.getJavaModelManager().startup();
 	}
-}
\ No newline at end of file
+}
