commit 08b9d40dde0b005b87b207f8d02b5899cde7b397
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Feb 14 12:45:53 2013 -0500

    Fixed Bug 400556 - [1.8][compiler] Visibility checks are missing for
    lambda/reference expressions.

2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
97	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
75	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
12	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
7	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
138	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 5646d0e..3a57f99 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -719,6 +719,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("JavadocUsingDeprecatedField", new ProblemAttributes(CategorizedProblem.CAT_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedMethod", new ProblemAttributes(CategorizedProblem.CAT_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedType", new ProblemAttributes(CategorizedProblem.CAT_JAVADOC));
+		expectedProblemAttributes.put("LambdaDescriptorMentionsUnmentionable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("LambdaExpressionNotBelow18", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("LambdaRedeclaresArgument", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("LambdaRedeclaresLocal", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -1478,6 +1479,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("JavadocUsingDeprecatedField", new ProblemAttributes(JavaCore.COMPILER_PB_INVALID_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedMethod", new ProblemAttributes(JavaCore.COMPILER_PB_INVALID_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedType", new ProblemAttributes(JavaCore.COMPILER_PB_INVALID_JAVADOC));
+		expectedProblemAttributes.put("LambdaDescriptorMentionsUnmentionable", SKIP);
 		expectedProblemAttributes.put("LambdaExpressionNotBelow18", SKIP);
 		expectedProblemAttributes.put("LambdaRedeclaresArgument", SKIP);
 		expectedProblemAttributes.put("LambdaRedeclaresLocal", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index 080fc33..e86f57d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -3416,6 +3416,103 @@ public void test400745a() {
 			"The type Y is never used locally\n" + 
 			"----------\n");
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"public interface I<P extends ParameterType> {\n" +
+					"	<T extends ExceptionType , R extends ReturnType> R doit(P p) throws T;\n" +
+					"}\n" +
+					"\n" +
+					"class ReturnType {\n" +
+					"}\n" +
+					"\n" +
+					"class ParameterType {\n" +
+					"}\n" +
+					"\n" +
+					"class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I i = (p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\I.java (at line 12)\n" + 
+			"	class ExceptionType extends Exception {\n" + 
+			"	      ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	^\n" + 
+			"I is a raw type. References to generic type I<P> should be parameterized\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ReturnType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ParameterType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ExceptionType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n");
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556a() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"public interface I<P extends ParameterType> {\n" +
+					"	<T extends ExceptionType , R extends ReturnType> R doit(P p) throws T;\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n" +
+					"\n" +
+					"class ParameterType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I i = (p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	^\n" + 
+			"I is a raw type. References to generic type I<P> should be parameterized\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ParameterType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n");
+}
 
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 7fee853..ae3b071 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -435,6 +435,8 @@ void setSourceStart(int sourceStart);
 	int LambdaRedeclaresArgument = Internal + 97;
 	/** @since 3.9 */
 	int LambdaRedeclaresLocal = Internal + 98;
+	/** @since 3.9 */
+	int LambdaDescriptorMentionsUnmentionable = 99;
 
 	// methods
 	int UndefinedMethod = MethodRelated + 100;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 5be9204..1d8c945 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -370,7 +370,13 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 			}
 			// recursively on the type variable upper bound
 			return checkCastTypesCompatibility(scope, castType, ((WildcardBinding)expressionType).bound, expression);
-
+		case Binding.INTERSECTION_CAST_TYPE:
+			ReferenceBinding [] intersectingTypes = expressionType.getIntersectingTypes();
+			for (int i = 0, length = intersectingTypes.length; i < length; i++) {
+				if (checkCastTypesCompatibility(scope, castType, intersectingTypes[i], expression))
+					return true;
+			}
+			return false;
 		default:
 			if (expressionType.isInterface()) {
 				switch (castType.kind()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 7f1ab02..46f2e96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -21,8 +21,13 @@ import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
+import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor;
 
 public abstract class FunctionalExpression extends Expression {
 	
@@ -67,10 +72,77 @@ public abstract class FunctionalExpression extends Expression {
 			return null;
 		}
 		
-		// Visibility checks should go here ...
-		
 		this.descriptor = sam;
-		return this.resolvedType = this.expectedType;
+		if (kosherDescriptor(blockScope, sam, true)) {
+			return this.resolvedType = this.expectedType;		
+		}
+		
+		return this.resolvedType = null;
+	}
+
+	class VisibilityInspector extends TypeBindingVisitor {
+
+		private Scope scope;
+		private boolean shouldChatter;
+        private boolean visible = true;
+		private FunctionalExpression expression;
+        
+		public VisibilityInspector(FunctionalExpression expression, Scope scope, boolean shouldChatter) {
+			this.scope = scope;
+			this.shouldChatter = shouldChatter;
+			this.expression = expression;
+		}
+
+		private void checkVisibility(ReferenceBinding referenceBinding) {
+			if (!referenceBinding.canBeSeenBy(this.scope)) {
+				this.visible = false;
+				if (this.shouldChatter)
+					this.scope.problemReporter().descriptorHasInvisibleType(this.expression, referenceBinding);
+			}
+		}
+		
+		public boolean visit(ReferenceBinding referenceBinding) {
+			checkVisibility(referenceBinding);
+			return true;
+		}
+
+		
+		public boolean visit(ParameterizedTypeBinding parameterizedTypeBinding) {
+			checkVisibility(parameterizedTypeBinding);
+			return true;
+		}
+		
+		public boolean visit(RawTypeBinding rawTypeBinding) {
+			checkVisibility(rawTypeBinding);
+			return true;
+		}
+
+		public boolean visible(TypeBinding type) {
+			TypeBindingVisitor.visit(this, type);
+			return this.visible;
+		}
+
+		public boolean visible(TypeBinding[] types) {
+			TypeBindingVisitor.visit(this, types);
+			return this.visible;
+		}
+		
+	}
+
+	public boolean kosherDescriptor(Scope scope, MethodBinding sam, boolean shouldChatter) {
+	
+		VisibilityInspector inspector = new VisibilityInspector(this, scope, shouldChatter);
+		
+		boolean status = true;
+		
+		if (!inspector.visible(sam.returnType))
+			status = false;
+		if (!inspector.visible(sam.parameters))
+			status = false;
+		if (!inspector.visible(sam.thrownExceptions))
+			status = false;
+		
+		return status;
 	}
 
 	public int nullStatus(FlowInfo flowInfo) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index f54e633..caa4db7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -65,6 +65,15 @@ public class LambdaExpression extends FunctionalExpression implements ProblemSev
 		this.body.generateCode(this.scope, codeStream);
 	}
 
+	public boolean kosherDescriptor(Scope currentScope, MethodBinding sam, boolean shouldChatter) {
+		if (sam.typeVariables != Binding.NO_TYPE_VARIABLES) {
+			if (shouldChatter)
+				currentScope.problemReporter().lambdaExpressionCannotImplementGenericMethod(this, sam);
+			return false;
+		}
+		return super.kosherDescriptor(currentScope, sam, shouldChatter);
+	}
+	
 	/* This code is arranged so that we can continue with as much analysis as possible while avoiding 
 	 * mine fields that would result in a slew of spurious messages. This method is a merger of:
 	 * @see org.eclipse.jdt.internal.compiler.lookup.MethodScope.createMethod(AbstractMethodDeclaration)
@@ -78,10 +87,9 @@ public class LambdaExpression extends FunctionalExpression implements ProblemSev
 		final boolean argumentsTypeElided = argumentsTypeElided();
 		final boolean haveDescriptor = this.descriptor != null;
 		
-		if (haveDescriptor && this.descriptor.typeVariables != Binding.NO_TYPE_VARIABLES) {
-			blockScope.problemReporter().lambdaExpressionCannotImplementGenericMethod(this, this.descriptor);
-			return this.resolvedType = null;
-		}
+		if (haveDescriptor && this.descriptor.typeVariables != Binding.NO_TYPE_VARIABLES) // already complained in kosher*
+			return null;
+		
 		if (!haveDescriptor && argumentsTypeElided) 
 			return null; // FUBAR, bail out...
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index 8d0573d..7c9e334 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -38,6 +38,9 @@ public abstract class Binding {
 	public static final int INTERSECTION_TYPE = TYPE | ASTNode.Bit14;
 	// jsr 308
 	public static final int TYPE_USE = TYPE | ASTNode.Bit15;
+	public static final int INTERSECTION_CAST_TYPE = TYPE | ASTNode.Bit16;
+	
+	// In the unlikely event you add a new type binding, remember to update TypeBindingVisitor and Scope.substitute methods. 
 
 	// Shared binding collections
 	public static final TypeBinding[] NO_TYPES = new TypeBinding[0];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
index 7ea9ade..623ae83 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
@@ -132,7 +132,7 @@ public class IntersectionCastTypeBinding extends ReferenceBinding {
 		return true;
 	}
 	public int kind() {
-		return Binding.TYPE;
+		return Binding.INTERSECTION_CAST_TYPE;
 	}
 	public String debugName() {
 		StringBuffer debugName = new StringBuffer(16);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 4ae0f04..6dc798a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -1149,12 +1149,13 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		return this.fields;
 	}
 	public MethodBinding getSingleAbstractMethod(final Scope scope) {
-		MethodBinding theAbstractMethod = genericType().getSingleAbstractMethod(scope);
+		final ReferenceBinding genericType = genericType();
+		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);
 		if (theAbstractMethod == null || !theAbstractMethod.isValidBinding())
 			return theAbstractMethod;
 		
 		TypeBinding [] typeArguments = this.arguments; // A1 ... An 
-		TypeVariableBinding [] typeParameters = genericType().typeVariables(); // P1 ... Pn
+		TypeVariableBinding [] typeParameters = genericType.typeVariables(); // P1 ... Pn
 		TypeBinding [] types = new TypeBinding[typeArguments.length];  // T1 ... Tn
 		for (int i = 0, length = typeArguments.length; i < length; i++) {
 			TypeBinding typeArgument = typeArguments[i];
@@ -1184,7 +1185,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 			if (typeParameters[i].boundCheck(null, types[i], scope) != TypeConstants.OK)
 				return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);
 		}
-		ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType(), types, this.enclosingType);
+		ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());
 		MethodBinding [] choices = parameterizedType.getMethods(theAbstractMethod.selector);
 		for (int i = 0, length = choices.length; i < length; i++) {
 			MethodBinding method = choices[i];
@@ -1196,24 +1197,18 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	}
 
 	private boolean typeParametersMentioned(TypeBinding upperBound) {
-		class MentionListener implements Substitution {
+		class MentionListener extends TypeBindingVisitor {
 			private boolean typeParametersMentioned = false;
-			public TypeBinding substitute(TypeVariableBinding typeVariable) {
+			public boolean visit(TypeVariableBinding typeVariable) {
 				this.typeParametersMentioned = true;
-				return typeVariable;
-			}
-			public boolean isRawSubstitution() {
 				return false;
 			}
-			public LookupEnvironment environment() {
-				return null;
-			}
 			public boolean typeParametersMentioned() {
 				return this.typeParametersMentioned;
 			}
 		}
 		MentionListener mentionListener = new MentionListener();
-		Scope.substitute(mentionListener, upperBound);
+		TypeBindingVisitor.visit(mentionListener, upperBound);
 		return mentionListener.typeParametersMentioned();
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index 214572f..d2fe051 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -169,6 +173,23 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 		}
 		this.arguments = typeArguments;
 	}
+	
+	public MethodBinding getSingleAbstractMethod(Scope scope) {
+		final ReferenceBinding genericType = genericType();
+		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);
+		if (theAbstractMethod == null || !theAbstractMethod.isValidBinding())
+			return theAbstractMethod;
+		
+		ReferenceBinding rawType = (ReferenceBinding) scope.environment().convertToRawType(genericType, true);
+		MethodBinding [] choices = rawType.getMethods(theAbstractMethod.selector);
+		for (int i = 0, length = choices.length; i < length; i++) {
+			MethodBinding method = choices[i];
+			if (!method.isAbstract() || method.redeclaresPublicObjectMethod(scope)) continue; // (re)skip statics, defaults, public object methods ...
+			this.singleAbstractMethod = method;
+			break;
+		}
+		return this.singleAbstractMethod;
+	}
 	/**
 	 * @see org.eclipse.jdt.internal.compiler.lookup.Binding#readableName()
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
new file mode 100644
index 0000000..7e41bb0
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
@@ -0,0 +1,138 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.lookup;
+
+import org.eclipse.jdt.internal.compiler.ast.Wildcard;
+import org.eclipse.jdt.internal.compiler.ast.Annotation.TypeUseBinding;
+
+
+public class TypeBindingVisitor {
+
+	public boolean visit(BaseTypeBinding baseTypeBinding)  {
+		return true;  // continue traversal.
+	}
+
+	public boolean visit(ArrayBinding arrayBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(TypeVariableBinding typeVariable) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(ReferenceBinding referenceBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(WildcardBinding wildcardBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(ParameterizedTypeBinding parameterizedTypeBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(IntersectionCastTypeBinding intersectionCastTypeBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(TypeUseBinding typeUseBinding) {
+		return true;  // continue traversal.
+	}
+	
+	public boolean visit(RawTypeBinding rawTypeBinding) {
+		return true;  // continue traversal.
+	}
+
+	public static void visit(TypeBindingVisitor visitor, ReferenceBinding[] types) {
+		for (int i = 0, length = types == null ? 0 : types.length; i < length; i++) {
+	        visit(visitor, types[i]);
+	    }
+	}
+
+	public static void visit(TypeBindingVisitor visitor, TypeBinding type) {
+
+		if (type == null) 
+			return;
+		
+		switch (type.kind()) {
+			
+			case Binding.TYPE_PARAMETER:
+				visitor.visit((TypeVariableBinding) type);
+	            break;
+	            
+			case Binding.PARAMETERIZED_TYPE:
+				ParameterizedTypeBinding parameterizedTypeBinding = (ParameterizedTypeBinding) type;
+				if (visitor.visit(parameterizedTypeBinding)) {
+					visit(visitor, parameterizedTypeBinding.enclosingType());
+					visit(visitor, parameterizedTypeBinding.arguments);
+				}
+				break;
+
+			case Binding.ARRAY_TYPE:
+				ArrayBinding arrayBinding = (ArrayBinding) type;
+				if (visitor.visit(arrayBinding))
+					visit(visitor, arrayBinding.leafComponentType);
+				break;
+
+			case Binding.WILDCARD_TYPE:
+			case Binding.INTERSECTION_TYPE:
+		        WildcardBinding wildcard = (WildcardBinding) type;
+		        if (visitor.visit(wildcard)) {
+		        	if (wildcard.boundKind != Wildcard.UNBOUND) {
+		        		visit(visitor, wildcard.bound);
+		        		visit(visitor, wildcard.otherBounds);
+		        	}
+		        }
+				break;
+			
+			case Binding.BASE_TYPE:
+				visitor.visit((BaseTypeBinding) type);
+				break;
+			
+			case Binding.RAW_TYPE:
+				visitor.visit((RawTypeBinding) type);
+				break;
+				
+			case Binding.TYPE:
+			case Binding.GENERIC_TYPE:
+				ReferenceBinding referenceBinding = (ReferenceBinding) type;
+				if (visitor.visit(referenceBinding)) {
+					visit(visitor, referenceBinding.enclosingType());
+					visit(visitor, referenceBinding.typeVariables());
+				}
+				break;
+			
+			case Binding.INTERSECTION_CAST_TYPE:
+				IntersectionCastTypeBinding intersectionCastTypeBinding = (IntersectionCastTypeBinding) type;
+				if (visitor.visit(intersectionCastTypeBinding))
+					visit(visitor, intersectionCastTypeBinding.intersectingTypes);
+				break;
+				
+			case Binding.TYPE_USE:
+				visitor.visit((TypeUseBinding) type);
+				break;
+				
+			default:
+				throw new InternalError("Unexpected binding type"); //$NON-NLS-1$
+		}
+	}
+
+	public static void visit(TypeBindingVisitor visitor, TypeBinding[] types) {
+		for (int i = 0, length = types == null ? 0 : types.length; i < length; i++) {
+	        visit(visitor, types[i]);
+	    }
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 6946e56..594187c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -9116,4 +9116,13 @@ public void lambdaRedeclaresLocal(LocalDeclaration local) {
 		local.sourceStart,
 		local.sourceEnd);
 }
+
+public void descriptorHasInvisibleType(FunctionalExpression expression, ReferenceBinding referenceBinding) {
+	this.handle(
+		IProblem.LambdaDescriptorMentionsUnmentionable,
+		new String[] { new String(referenceBinding.readableName()) },
+		new String[] { new String(referenceBinding.shortReadableName()) },
+		expression.sourceStart,
+		expression.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 46a09e9..55988d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -104,7 +104,7 @@
 96 = The serializable class {0} does not declare a static final serialVersionUID field of type long
 97 = Lambda expression's parameter {0} cannot redeclare another local variable defined in an enclosing scope. 
 98 = Lambda expression's local variable {0} cannot redeclare another local variable defined in an enclosing scope. 
-
+99 = The type {0} from the descriptor computed for the target context is not visible here.  
 100 = The method {1}({2}) is undefined for the type {0}
 101 = The method {1}({2}) from the type {0} is not visible
 102 = The method {1}({2}) is ambiguous for the type {0}
commit 2adf5e7af76ae05ae6976726576af8c12845ba88
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Fri Feb 15 00:14:46 2013 -0500

    Several more tests for bug 400556, [1.8][compiler] Visibility checks are
    missing for lambda/reference expressions

473	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index e86f57d..09a8708 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -3513,7 +3513,479 @@ public void test400556a() {
 			"The type ParameterType from the descriptor computed for the target context is not visible here.  \n" + 
 			"----------\n");
 }
-
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556b() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType> {\n" +
+					"	<T extends ExceptionType , R extends ReturnType> R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n" +
+					"\n" +
+					"class ReturnType {\n" +
+					"}\n" +
+					"\n" +
+					"class ParameterType {\n" +
+					"}\n" +
+					"\n" +
+					"class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I i = (p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\I.java (at line 13)\n" + 
+			"	class ExceptionType extends Exception {\n" + 
+			"	      ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	^\n" + 
+			"I is a raw type. References to generic type I<P> should be parameterized\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ReturnType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 3)\n" + 
+			"	I i = (p) -> { return null; };\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ExceptionType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556c() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n" +
+					"class ParameterType {\n" +
+					"}\n" +
+					"class ReturnType {\n" +
+					"}\n" +
+					"class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I<?, ?, ?> i = (p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\I.java (at line 10)\n" + 
+			"	class ExceptionType extends Exception {\n" + 
+			"	      ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	I<?, ?, ?> i = (p) -> { return null; };\n" + 
+			"	               ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ReturnType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 3)\n" + 
+			"	I<?, ?, ?> i = (p) -> { return null; };\n" + 
+			"	               ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ParameterType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 3)\n" + 
+			"	I<?, ?, ?> i = (p) -> { return null; };\n" + 
+			"	               ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type ExceptionType from the descriptor computed for the target context is not visible here.  \n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556d() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I<?, ?, ?> i = (p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556e() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I<?, ?, ?> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	I<?, ?, ?> i = (String p) -> { return null; };\n" + 
+			"	                ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<ParameterType>>[]\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556f() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I<? extends p.ParameterType, ? extends p.ExceptionType, ? extends p.ReturnType> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	I<? extends p.ParameterType, ? extends p.ExceptionType, ? extends p.ReturnType> i = (String p) -> { return null; };\n" + 
+			"	                                                                                     ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<ParameterType>>[]\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556g() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"class P extends p.ParameterType {}\n" +
+					"class T extends p.ExceptionType {}\n" +
+					"class R extends p.ReturnType {}\n" +
+					"public class X {\n" +
+					"	I<P, T, R> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	class T extends p.ExceptionType {}\n" + 
+			"	      ^\n" + 
+			"The serializable class T does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 6)\n" + 
+			"	I<P, T, R> i = (String p) -> { return null; };\n" + 
+			"	                ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<P>>[]\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556h() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"class P extends p.ParameterType {}\n" +
+					"class T extends p.ExceptionType {}\n" +
+					"class R extends p.ReturnType {}\n" +
+					"public class X {\n" +
+					"	I<T, R, P> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	class T extends p.ExceptionType {}\n" + 
+			"	      ^\n" + 
+			"The serializable class T does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 6)\n" + 
+			"	I<T, R, P> i = (String p) -> { return null; };\n" + 
+			"	  ^\n" + 
+			"Bound mismatch: The type T is not a valid substitute for the bounded parameter <P extends ParameterType> of the type I<P,T,R>\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 6)\n" + 
+			"	I<T, R, P> i = (String p) -> { return null; };\n" + 
+			"	     ^\n" + 
+			"Bound mismatch: The type R is not a valid substitute for the bounded parameter <T extends ExceptionType> of the type I<P,T,R>\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 6)\n" + 
+			"	I<T, R, P> i = (String p) -> { return null; };\n" + 
+			"	        ^\n" + 
+			"Bound mismatch: The type P is not a valid substitute for the bounded parameter <R extends ReturnType> of the type I<P,T,R>\n" + 
+			"----------\n" + 
+			"5. ERROR in X.java (at line 6)\n" + 
+			"	I<T, R, P> i = (String p) -> { return null; };\n" + 
+			"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The target type of this expression is not a well formed parameterized type due to bound(s) mismatch\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556i() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"class P extends p.ParameterType {}\n" +
+					"class T extends p.ExceptionType {}\n" +
+					"class R extends p.ReturnType {}\n" +
+					"public class X {\n" +
+					"	I<? super P, ? super T, ? super R> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	class T extends p.ExceptionType {}\n" + 
+			"	      ^\n" + 
+			"The serializable class T does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 6)\n" + 
+			"	I<? super P, ? super T, ? super R> i = (String p) -> { return null; };\n" + 
+			"	                                        ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<P>>[]\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556j() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends P , R extends T> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"class P extends p.ParameterType {}\n" +
+					"class T extends p.ExceptionType {}\n" +
+					"class R extends p.ReturnType {}\n" +
+					"public class X {\n" +
+					"	I<?, ?, ?> i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in p\\I.java (at line 4)\n" + 
+			"	R doit(List<? extends List<P>>[] p) throws T;\n" + 
+			"	                                           ^\n" + 
+			"No exception of type T can be thrown; an exception type must be a subclass of Throwable\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	class T extends p.ExceptionType {}\n" + 
+			"	      ^\n" + 
+			"The serializable class T does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 6)\n" + 
+			"	I<?, ?, ?> i = (String p) -> { return null; };\n" + 
+			"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The target type of this expression is not a well formed parameterized type due to bound(s) mismatch\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
+public void test400556k() {
+	this.runNegativeTest(
+			new String[] {
+					"p/I.java",
+					"package p;\n" +
+					"import java.util.List;\n" +
+					"public interface I<P extends ParameterType, T extends ExceptionType , R extends ReturnType> {\n" +
+					"	R doit(List<? extends List<P>>[] p) throws T;\n" +
+					"}\n",
+					"p/ParameterType.java",
+					"package p;\n" +
+					"public class ParameterType {\n" +
+					"}\n",
+					"p/ReturnType.java",
+					"package p;\n" +
+					"public class ReturnType {\n" +
+					"}\n",
+					"p/ExceptionType.java",
+					"package p;\n" +
+					"public class ExceptionType extends Exception {\n" +
+					"}\n",
+					"X.java",
+					"import p.I;\n" +
+					"public class X {\n" +
+					"	I i = (String p) -> { return null; };\n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in p\\ExceptionType.java (at line 2)\n" + 
+			"	public class ExceptionType extends Exception {\n" + 
+			"	             ^^^^^^^^^^^^^\n" + 
+			"The serializable class ExceptionType does not declare a static final serialVersionUID field of type long\n" + 
+			"----------\n" + 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 3)\n" + 
+			"	I i = (String p) -> { return null; };\n" + 
+			"	^\n" + 
+			"I is a raw type. References to generic type I<P,T,R> should be parameterized\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 3)\n" + 
+			"	I i = (String p) -> { return null; };\n" + 
+			"	       ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List[]\n" + 
+			"----------\n");
+}
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
index 7e41bb0..ae3846d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBindingVisitor.java
@@ -70,7 +70,12 @@ public class TypeBindingVisitor {
 		switch (type.kind()) {
 			
 			case Binding.TYPE_PARAMETER:
-				visitor.visit((TypeVariableBinding) type);
+				TypeVariableBinding typeVariableBinding = (TypeVariableBinding) type;
+				if (visitor.visit(typeVariableBinding)) {
+					visit(visitor, typeVariableBinding.firstBound);
+					visit(visitor, typeVariableBinding.superclass);
+					visit(visitor, typeVariableBinding.superInterfaces);
+				}
 	            break;
 	            
 			case Binding.PARAMETERIZED_TYPE:
