commit effc87828d40c0b15d95e17b44487025194ac03b
Author: David Audel <daudel>
Date:   Fri Feb 14 15:49:23 2003 +0000

    bug 31652

5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
30	30	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
9	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
63	45	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
2	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
108	255	org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
18	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
293	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 65db559..470998b 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -8082,14 +8082,14 @@ public void testCompletionCatchArgumentName2() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	cu.codeComplete(cursorLocation, requestor);
 
-	assertEquals(
-		"element:exception    completion:exception    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE)+"\n"+
-		"element:locException    completion:locException    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE),
-		requestor.getResults());
-		
 	options.put(JavaCore.CODEASSIST_ARGUMENT_PREFIXES,argumentPrefixPreviousValue);
 	options.put(JavaCore.CODEASSIST_LOCAL_PREFIXES,localPrefixPreviousValue);
 	JavaCore.setOptions(options);
+
+	assertEquals(
+		"element:exception    completion:exception    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE)+"\n"+
+		"element:locException    completion:locException    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX),
+		requestor.getResults());
 }
 public void testCompletionArrayAccess1() throws JavaModelException {
 	CompletionTestsRequestor requestor = new CompletionTestsRequestor();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
index 8623bd7..8992ee6 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
@@ -122,10 +122,10 @@ public void testSuggestFieldName003() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,fieldPrefixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"name\n" + //$NON-NLS-1$
 		"fName\n" + //$NON-NLS-1$
-		"oneName\n" + //$NON-NLS-1$
-		"fOneName", //$NON-NLS-1$
+		"fOneName\n" + //$NON-NLS-1$
+		"name\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName004() throws CoreException {
@@ -145,10 +145,10 @@ public void testSuggestFieldName004() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_PREFIXES,fieldPrefixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"name\n" + //$NON-NLS-1$
 		"_name\n" + //$NON-NLS-1$
-		"oneName\n" + //$NON-NLS-1$
-		"_oneName", //$NON-NLS-1$
+		"_oneName\n" + //$NON-NLS-1$
+		"name\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName005() throws CoreException {
@@ -171,10 +171,10 @@ public void testSuggestFieldName005() throws CoreException {
 	options.put(JavaCore.CODEASSIST_STATIC_FIELD_PREFIXES,staticFieldPrefixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"name\n" + //$NON-NLS-1$
 		"fgName\n" + //$NON-NLS-1$
-		"oneName\n" + //$NON-NLS-1$
-		"fgOneName", //$NON-NLS-1$
+		"fgOneName\n" + //$NON-NLS-1$
+		"name\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName006() throws CoreException {
@@ -197,14 +197,14 @@ public void testSuggestFieldName006() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,fieldSuffixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"name\n" + //$NON-NLS-1$
-		"namesuf\n" + //$NON-NLS-1$
-		"preName\n" + //$NON-NLS-1$
 		"preNamesuf\n" + //$NON-NLS-1$
-		"oneName\n" + //$NON-NLS-1$
-		"oneNamesuf\n" + //$NON-NLS-1$
+		"preOneNamesuf\n" + //$NON-NLS-1$
+		"preName\n" + //$NON-NLS-1$
 		"preOneName\n" + //$NON-NLS-1$
-		"preOneNamesuf", //$NON-NLS-1$
+		"namesuf\n" + //$NON-NLS-1$
+		"oneNamesuf\n" + //$NON-NLS-1$
+		"name\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName007() throws CoreException {
@@ -227,10 +227,10 @@ public void testSuggestFieldName007() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,fieldSuffixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"i\n" + //$NON-NLS-1$
-		"isuf\n" + //$NON-NLS-1$
+		"preIsuf\n" + //$NON-NLS-1$
 		"preI\n" + //$NON-NLS-1$
-		"preIsuf", //$NON-NLS-1$
+		"isuf\n" + //$NON-NLS-1$
+		"i", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName008() throws CoreException {
@@ -267,14 +267,14 @@ public void testSuggestFieldName009() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,fieldSuffixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"name\n" + //$NON-NLS-1$
-		"namesuf\n" + //$NON-NLS-1$
-		"preName\n" + //$NON-NLS-1$
 		"preName2suf\n" + //$NON-NLS-1$
-		"oneName\n" + //$NON-NLS-1$
-		"oneNamesuf\n" + //$NON-NLS-1$
+		"preOneNamesuf\n" + //$NON-NLS-1$
+		"preName\n" + //$NON-NLS-1$
 		"preOneName\n" + //$NON-NLS-1$
-		"preOneNamesuf", //$NON-NLS-1$
+		"namesuf\n" + //$NON-NLS-1$
+		"oneNamesuf\n" + //$NON-NLS-1$
+		"name\n" + //$NON-NLS-1$
+		"oneName", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName010() throws CoreException {
@@ -297,14 +297,14 @@ public void testSuggestFieldName010() throws CoreException {
 	options.put(JavaCore.CODEASSIST_FIELD_SUFFIXES,fieldSuffixPreviousValue);
 	JavaCore.setOptions(options);
 	assertEquals(
-		"names\n" + //$NON-NLS-1$
-		"namessuf\n" + //$NON-NLS-1$
-		"preNames\n" + //$NON-NLS-1$
 		"preNamessuf\n" + //$NON-NLS-1$
-		"oneNames\n" + //$NON-NLS-1$
-		"oneNamessuf\n" + //$NON-NLS-1$
+		"preOneNamessuf\n" + //$NON-NLS-1$
+		"preNames\n" + //$NON-NLS-1$
 		"preOneNames\n" + //$NON-NLS-1$
-		"preOneNamessuf", //$NON-NLS-1$
+		"namessuf\n" + //$NON-NLS-1$
+		"oneNamessuf\n" + //$NON-NLS-1$
+		"names\n" + //$NON-NLS-1$
+		"oneNames", //$NON-NLS-1$
 		toString(suggestions));
 }
 public void testSuggestFieldName011() throws CoreException {
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 2ba264c..b6c820a 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -61,10 +61,18 @@ two scenarii.
 *     - default:           "disabled"
 </pre>
 </li>
+<li><b>Code completion enhancement:</b>
+   <ul>
+   <li>Relevance of a proposal is higher if the proposal is a variable name and this name contains a prefix.</li>
+   <li>Relevance of a proposal is higher if the proposal is a variable name and this name contains a suffix.</li>
+   </ul>
+</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=31628">31628</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=31652">31652</a>
+NamingConvention.suggestXXNames: Put the most relevant first
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=31628">31628</a>
 Redundant import need a warning (matching package declaration)
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=31867">31867</a>
 No unused import diagnosis on duplicate import
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 8d226d2..a50f1f8 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -17,7 +17,6 @@ import org.eclipse.jdt.core.ICompletionRequestor;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.NamingConventions;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
 
@@ -39,6 +38,7 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObject;
 import org.eclipse.jdt.internal.compiler.util.ObjectVector;
+import org.eclipse.jdt.internal.core.*;
 import org.eclipse.jdt.internal.core.BasicCompilationUnit;
 import org.eclipse.jdt.internal.core.TypeConverter;
 
@@ -2848,73 +2848,91 @@ public final class CompletionEngine
 			
 		if(sourceName == null || sourceName.length == 0)
 			return;
+
+		// compute variable name for non base type
+		final char[] displayName;
+		if (dim > 0){
+			int l = qualifiedSourceName.length;
+			displayName = new char[l+(2*dim)];
+			System.arraycopy(qualifiedSourceName, 0, displayName, 0, l);
+			for(int i = 0; i < dim; i++){
+				displayName[l+(i*2)] = '[';
+				displayName[l+(i*2)+1] = ']';
+			}
+		} else {
+			displayName = qualifiedSourceName;
+		}
+		
+		final char[] t = token;
+		final char[] q = qualifiedPackageName;
+		INamingRequestor namingRequestor = new INamingRequestor() {
+			public void acceptNameWithPrefixAndSuffix(char[] name) {
+				accept(name, R_NAME_PREFIX + R_NAME_SUFFIX);
+			}
+
+			public void acceptNameWithPrefix(char[] name) {
+				accept(name, R_NAME_PREFIX);
+			}
+
+			public void acceptNameWithSuffix(char[] name) {
+				accept(name, R_NAME_SUFFIX);
+			}
+
+			public void acceptNameWithoutPrefixAndSuffix(char[] name) {
+				accept(name, 0);
+			}
+			private void accept(char[] name, int prefixAndSuffixRelevance){
+				if (CharOperation.prefixEquals(t, name, false)) {
+					int relevance = computeBaseRelevance();
+					relevance += computeRelevanceForInterestingProposal();
+					relevance += computeRelevanceForCaseMatching(t, name);
+					relevance += prefixAndSuffixRelevance;
+
+					// accept result
+					requestor.acceptVariableName(
+						q,
+						displayName,
+						name,
+						name,
+						startPosition - offset,
+						endPosition - offset,
+						relevance);
+				}
+			}
+		};
 		
-		char[][] names = CharOperation.NO_CHAR_CHAR;
 		switch (kind) {
 			case FIELD :
-				names = NamingConventions.suggestFieldNames(
+				InternalNamingConventions.suggestFieldNames(
 					javaProject,
 					qualifiedPackageName,
 					qualifiedSourceName,
 					dim,
 					modifiers,
-					excludeNames);
+					excludeNames,
+					namingRequestor);
 				break;
 			case LOCAL :
-				names = NamingConventions.suggestLocalVariableNames(
+				InternalNamingConventions.suggestLocalVariableNames(
 					javaProject,
 					qualifiedPackageName,
 					qualifiedSourceName,
 					dim,
-					excludeNames);
+					excludeNames,
+					namingRequestor);
 				break;
 			case ARGUMENT :
-				names = NamingConventions.suggestArgumentNames(
+				InternalNamingConventions.suggestArgumentNames(
 					javaProject,
 					qualifiedPackageName,
 					qualifiedSourceName,
 					dim,
-					excludeNames);
+					excludeNames,
+					namingRequestor);
 				break;
 		}
-
-		// compute variable name for non base type
-		char[] displayName;
-		if (dim > 0){
-			int l = qualifiedSourceName.length;
-			displayName = new char[l+(2*dim)];
-			System.arraycopy(qualifiedSourceName, 0, displayName, 0, l);
-			for(int i = 0; i < dim; i++){
-				displayName[l+(i*2)] = '[';
-				displayName[l+(i*2)+1] = ']';
-			}
-		} else {
-			displayName = qualifiedSourceName;
-		}
-		
-		next : for(int i = 0 ; i < names.length ; i++){
-			char[] name = names[i];
-		
-			if (!CharOperation.prefixEquals(token, name, false))
-				continue next;
-			
-			int relevance = computeBaseRelevance();
-			relevance += computeRelevanceForInterestingProposal();
-			relevance += computeRelevanceForCaseMatching(token, name);
-			
-			// accept result
-			requestor.acceptVariableName(
-				qualifiedPackageName,
-				displayName,
-				name,
-				name,
-				startPosition - offset,
-				endPosition - offset,
-				relevance);
-		}
-		
 	}
-	
+
 	private void findVariableNames(char[] name, TypeReference type , char[][] excludeNames, int kind, int modifiers){
 
 		if(type != null &&
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
index 364b7e2..d3d21de 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
@@ -24,4 +24,6 @@ public interface RelevanceConstants {
 	int R_ABSTRACT_METHOD = 20;
 	int R_NON_STATIC = 10;
 	int R_UNQUALIFIED = 5;
+	int R_NAME_PREFIX = 5;
+	int R_NAME_SUFFIX = 4;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
index 1adceb0..5a2e647 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
@@ -10,14 +10,11 @@
  ******************************************************************************/
 package org.eclipse.jdt.core;
 
-import java.util.Map;
-
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.codeassist.impl.AssistOptions;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.parser.Scanner;
-import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+import org.eclipse.jdt.internal.core.INamingRequestor;
+import org.eclipse.jdt.internal.core.InternalNamingConventions;
+
 
 /**
  * Provides methods for computing Java-specific names.
@@ -48,76 +45,94 @@ import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
  * @since 2.1
  */
 public final class NamingConventions {
-	private static final char[] DEFAULT_NAME = "name".toCharArray(); //$NON-NLS-1$
-	
 	private static final char[] GETTER_BOOL_NAME = "is".toCharArray(); //$NON-NLS-1$
 	private static final char[] GETTER_NAME = "get".toCharArray(); //$NON-NLS-1$
 	private static final char[] SETTER_NAME = "set".toCharArray(); //$NON-NLS-1$
 	
-	/**
-	 * Not instantiable.
-	 */
-	private NamingConventions() {}
-	
-	private static char[] computeBaseNames(char firstName, char[][] prefixes, char[][] excludedNames){
-		char[] name = new char[]{firstName};
-		
-		for(int i = 0 ; i < excludedNames.length ; i++){
-			if(CharOperation.equals(name, excludedNames[i], false)) {
-				name[0]++;
-				if(name[0] > 'z')
-					name[0] = 'a';
-				if(name[0] == firstName)
-					return null;
-				i = 0;
-			}	
+	private static class NamingRequestor implements INamingRequestor {
+		private final static int SIZE = 10;
+		private char[][] prefixAndSuffixResults = new char[SIZE][];
+		private int prefixAndSuffixResultsCount = 0;
+		private char[][] prefixResults = new char[SIZE][];
+		private int prefixResultsCount = 0;
+		private char[][] suffixResults = new char[SIZE][];
+		private int suffixResultsCount = 0;
+		private char[][] otherResults = new char[SIZE][];
+		private int otherResultsCount = 0;
+		public void acceptNameWithPrefixAndSuffix(char[] name) {
+			int length = prefixAndSuffixResults.length;
+			if(length == prefixAndSuffixResultsCount) {
+				System.arraycopy(
+					prefixAndSuffixResults,
+					0,
+					prefixAndSuffixResults = new char[length * 2][],
+					0,
+					length);
+			}
+			prefixAndSuffixResults[prefixAndSuffixResultsCount++] = name;
 		}
-		
-		return name;
-	}
-	
 
-	private static char[][] computeNames(char[] sourceName){
-		char[][] names = new char[5][];
-		int nameCount = 0;
-		boolean previousIsUpperCase = false;
-		boolean previousIsLetter = true;
-		for(int i = sourceName.length - 1 ; i >= 0 ; i--){
-			boolean isUpperCase = Character.isUpperCase(sourceName[i]);
-			boolean isLetter = Character.isLetter(sourceName[i]);
-			if(isUpperCase && !previousIsUpperCase && previousIsLetter){
-				char[] name = CharOperation.subarray(sourceName,i,sourceName.length);
-				if(name.length > 1){
-					if(nameCount == names.length) {
-						System.arraycopy(names, 0, names = new char[nameCount * 2][], 0, nameCount);
-					}
-					name[0] = Character.toLowerCase(name[0]);
-					names[nameCount++] = name;
-				}
+		public void acceptNameWithPrefix(char[] name) {
+			int length = prefixResults.length;
+			if(length == prefixResultsCount) {
+				System.arraycopy(
+					prefixResults,
+					0,
+					prefixResults = new char[length * 2][],
+					0,
+					length);
+			}
+			prefixResults[prefixResultsCount++] = name;
+		}
+
+		public void acceptNameWithSuffix(char[] name) {
+			int length = suffixResults.length;
+			if(length == suffixResultsCount) {
+				System.arraycopy(
+				suffixResults,
+					0,
+				suffixResults = new char[length * 2][],
+					0,
+					length);
 			}
-			previousIsUpperCase = isUpperCase;
-			previousIsLetter = isLetter;
+			suffixResults[suffixResultsCount++] = name;
 		}
-		if(nameCount == 0){
-			names[nameCount++] = CharOperation.toLowerCase(sourceName);				
+
+		public void acceptNameWithoutPrefixAndSuffix(char[] name) {
+			int length = otherResults.length;
+			if(length == otherResultsCount) {
+				System.arraycopy(
+				otherResults,
+					0,
+				otherResults = new char[length * 2][],
+					0,
+					length);
+			}
+			otherResults[otherResultsCount++] = name;
+		}
+		public char[][] getResults(){
+			int count = prefixAndSuffixResultsCount + prefixResultsCount + suffixResultsCount + otherResultsCount;
+			char[][] results = new char[count][];
+			
+			int index = 0;
+			System.arraycopy(prefixAndSuffixResults, 0, results, index, prefixAndSuffixResultsCount);
+			index += prefixAndSuffixResultsCount;
+			System.arraycopy(prefixResults, 0, results, index, prefixResultsCount);
+			index += prefixResultsCount;
+			System.arraycopy(suffixResults, 0, results, index, suffixResultsCount);
+			index += suffixResultsCount;
+			System.arraycopy(otherResults, 0, results, index, otherResultsCount);
+			
+			return results;
 		}
-		System.arraycopy(names, 0, names = new char[nameCount][], 0, nameCount);
-		return names;
 	}
-	
 
-	private static Scanner getNameScanner(CompilerOptions compilerOptions) {
-		return
-			new Scanner(
-				false /*comment*/, 
-				false /*whitespace*/, 
-				false /*nls*/, 
-				compilerOptions.sourceLevel >= CompilerOptions.JDK1_4 /*assert*/, 
-				compilerOptions.complianceLevel >= CompilerOptions.JDK1_4 /*strict comment*/,
-				null /*taskTags*/, 
-				null/*taskPriorities*/);
-	}
 	
+	/**
+	 * Not instantiable.
+	 */
+	private NamingConventions() {}
+
 	private static char[] removePrefixAndSuffix(char[] name, char[][] prefixes, char[][] suffixes) {
 		// remove longer prefix
 		char[] withoutPrefixName = name;
@@ -334,19 +349,16 @@ public final class NamingConventions {
 	 * @see JavaCore#getDefaultOptions
 	 */
 	public static char[][] suggestArgumentNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames) {
-		Map options = javaProject.getOptions(true);
-		CompilerOptions compilerOptions = new CompilerOptions(options);
-		AssistOptions assistOptions = new AssistOptions(options);
+		NamingRequestor requestor = new NamingRequestor();
+		InternalNamingConventions.suggestArgumentNames(
+			javaProject,
+			packageName,
+			qualifiedTypeName,
+			dim,
+			excludedNames,
+			requestor);
 
-		return
-			suggestNames(
-				packageName,
-				qualifiedTypeName,
-				dim,
-				assistOptions.argumentPrefixes,
-				assistOptions.argumentSuffixes,
-				excludedNames,
-				getNameScanner(compilerOptions));
+		return requestor.getResults();
 	}
 	
 	/**
@@ -408,23 +420,19 @@ public final class NamingConventions {
 	 * @see JavaCore#getDefaultOptions
 	 */
 	public static char[][] suggestFieldNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, int modifiers, char[][] excludedNames) {
-		boolean isStatic = Flags.isStatic(modifiers);
-		
-		Map options = javaProject.getOptions(true);
-		CompilerOptions compilerOptions = new CompilerOptions(options);
-		AssistOptions assistOptions = new AssistOptions(options);
+		NamingRequestor requestor = new NamingRequestor();
+		InternalNamingConventions.suggestFieldNames(
+			javaProject,
+			packageName,
+			qualifiedTypeName,
+			dim,
+			modifiers,
+			excludedNames,
+			requestor);
 
-		return
-			suggestNames(
-				packageName,
-				qualifiedTypeName,
-				dim,
-				isStatic ? assistOptions.staticFieldPrefixes : assistOptions.fieldPrefixes,
-				isStatic ? assistOptions.staticFieldSuffixes : assistOptions.fieldSuffixes,
-				excludedNames,
-				getNameScanner(compilerOptions));
+		return requestor.getResults();
 	}
-
+	
 	/**
 	 * Suggest names for a field. The name is computed from field's type
 	 * and possible prefixes or suffixes are added.<br>
@@ -485,19 +493,16 @@ public final class NamingConventions {
 	 * @see JavaCore#getDefaultOptions
 	 */
 	public static char[][] suggestLocalVariableNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames) {
-		Map options = javaProject.getOptions(true);
-		CompilerOptions compilerOptions = new CompilerOptions(options);
-		AssistOptions assistOptions = new AssistOptions(options);
+		NamingRequestor requestor = new NamingRequestor();
+		InternalNamingConventions.suggestLocalVariableNames(
+			javaProject,
+			packageName,
+			qualifiedTypeName,
+			dim,
+			excludedNames,
+			requestor);
 
-		return
-			suggestNames(
-				packageName,
-				qualifiedTypeName,
-				dim,
-				assistOptions.localPrefixes,
-				assistOptions.localSuffixes,
-				excludedNames,
-				getNameScanner(compilerOptions));
+		return requestor.getResults();
 	}
 	
 	/**
@@ -532,136 +537,6 @@ public final class NamingConventions {
 				convertStringToChars(excludedNames)));
 	}
 	
-	private static char[][] suggestNames(
-		char[] packageName,
-		char[] qualifiedTypeName,
-		int dim,
-		char[][] prefixes,
-		char[][] suffixes,
-		char[][] excludedNames,
-		Scanner nameScanner){
-			
-		if(qualifiedTypeName == null || qualifiedTypeName.length == 0)
-			return CharOperation.NO_CHAR_CHAR;
-			
-		char[] typeName = CharOperation.lastSegment(qualifiedTypeName, '.');
-		
-		if(prefixes == null || prefixes.length == 0) {
-			prefixes = new char[1][0];
-		} else {
-			int length = prefixes.length;
-			System.arraycopy(prefixes, 0, prefixes = new char[length+1][], 1, length);
-			prefixes[0] = CharOperation.NO_CHAR;
-		}
-		
-		if(suffixes == null || suffixes.length == 0) {
-			suffixes = new char[1][0];
-		} else {
-			int length = suffixes.length;
-			System.arraycopy(suffixes, 0, suffixes = new char[length+1][], 1, length);
-			suffixes[0] = CharOperation.NO_CHAR;
-		}
-		
-		char[][] names = new char[5][];
-		int namesCount = 0;
-		
-		char[][] tempNames = null;
-		
-		// compute variable name for base type
-		try{
-			nameScanner.setSource(typeName);
-			switch (nameScanner.getNextToken()) {
-				case TerminalTokens.TokenNameint :
-				case TerminalTokens.TokenNamebyte :
-				case TerminalTokens.TokenNameshort :
-				case TerminalTokens.TokenNamechar :
-				case TerminalTokens.TokenNamelong :
-				case TerminalTokens.TokenNamefloat :
-				case TerminalTokens.TokenNamedouble :
-				case TerminalTokens.TokenNameboolean :	
-					char[] name = computeBaseNames(typeName[0], prefixes, excludedNames);
-					if(name != null) {
-						tempNames =  new char[][]{name};
-					}
-					break;
-			}	
-		} catch(InvalidInputException e){
-		}
-
-		// compute variable name for non base type
-		if(tempNames == null) {
-			tempNames = computeNames(typeName);
-		}
-		
-		for (int i = 0; i < tempNames.length; i++) {
-			char[] tempName = tempNames[i];
-			if(dim > 0) {
-				int length = tempName.length;
-				if (tempName[length-1] == 's'){
-					System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
-					tempName[length] = 'e';
-					tempName[length+1] = 's';
-				} else if(tempName[length-1] == 'y') {
-					System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
-					tempName[length-1] = 'i';
-					tempName[length] = 'e';
-					tempName[length+1] = 's';
-				} else {
-					System.arraycopy(tempName, 0, tempName = new char[length + 1], 0, length);
-					tempName[length] = 's';
-				}
-			}
-			
-			for (int j = 0; j < prefixes.length; j++) {
-				if(prefixes[j].length > 0
-					&& Character.isLetterOrDigit(prefixes[j][prefixes[j].length - 1])) {
-					tempName[0] = Character.toUpperCase(tempName[0]);
-				} else {
-					tempName[0] = Character.toLowerCase(tempName[0]);
-				}
-				char[] prefixName = CharOperation.concat(prefixes[j], tempName);
-				for (int k = 0; k < suffixes.length; k++) {
-					char[] suffixName = CharOperation.concat(prefixName, suffixes[k]);
-					suffixName =
-						excludeNames(
-							suffixName,
-							prefixName,
-							suffixes[k],
-							excludedNames);
-					if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
-						names[namesCount++] = suffixName;
-					} else {
-						suffixName = CharOperation.concat(
-							prefixName,
-							String.valueOf(1).toCharArray(),
-							suffixes[k]
-						);
-						suffixName =
-							excludeNames(
-								suffixName,
-								prefixName,
-								suffixes[k],
-								excludedNames);
-						if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
-							names[namesCount++] = suffixName;
-						}
-					}
-					if(namesCount == names.length) {
-						System.arraycopy(names, 0, names = new char[namesCount * 2][], 0, namesCount);
-					}
-				}
-				
-			}
-		}
-		System.arraycopy(names, 0, names = new char[namesCount][], 0, namesCount);
-		
-		// if no names were found
-		if(names.length == 0) {
-			names = new char[][]{excludeNames(DEFAULT_NAME, DEFAULT_NAME, CharOperation.NO_CHAR, excludedNames)};
-		}
-		return names;
-	}
-	
 	/**
 	 * Suggest name for a getter method. The name is computed from field's name
 	 * and possible prefixes or suffixes are removed.<br>
@@ -873,26 +748,4 @@ public final class NamingConventions {
 		}
 		return c;
 	}
-	
-	private static char[] excludeNames(
-		char[] suffixName,
-		char[] prefixName,
-		char[] suffix,
-		char[][] excludedNames) {
-		int count = 2;
-		int m = 0;
-		while (m < excludedNames.length) {
-			if(CharOperation.equals(suffixName, excludedNames[m], false)) {
-				suffixName = CharOperation.concat(
-					prefixName,
-					String.valueOf(count++).toCharArray(),
-					suffix
-				);
-				m = 0;
-			} else {
-				m++;
-			}
-		}
-		return suffixName;
-	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
new file mode 100644
index 0000000..d6c2206
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2003 International Business Machines Corp. and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0 
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+public interface INamingRequestor {
+	void acceptNameWithPrefixAndSuffix(char[] name);
+	void acceptNameWithPrefix(char[] name);
+	void acceptNameWithSuffix(char[] name);
+	void acceptNameWithoutPrefixAndSuffix(char[] name);
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
new file mode 100644
index 0000000..9f3118c
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
@@ -0,0 +1,293 @@
+/*******************************************************************************
+ * Copyright (c) 2003 International Business Machines Corp. and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0 
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.util.Map;
+
+import org.eclipse.jdt.core.Flags;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaConventions;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.compiler.InvalidInputException;
+import org.eclipse.jdt.internal.codeassist.impl.AssistOptions;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.parser.Scanner;
+import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
+
+public class InternalNamingConventions {
+	private static final char[] DEFAULT_NAME = "name".toCharArray(); //$NON-NLS-1$
+	
+	private static Scanner getNameScanner(CompilerOptions compilerOptions) {
+		return
+			new Scanner(
+				false /*comment*/, 
+				false /*whitespace*/, 
+				false /*nls*/, 
+				compilerOptions.sourceLevel >= CompilerOptions.JDK1_4 /*assert*/, 
+				compilerOptions.complianceLevel >= CompilerOptions.JDK1_4 /*strict comment*/,
+				null /*taskTags*/, 
+				null/*taskPriorities*/);
+	}
+	public static void suggestArgumentNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames, INamingRequestor requestor) {
+		Map options = javaProject.getOptions(true);
+		CompilerOptions compilerOptions = new CompilerOptions(options);
+		AssistOptions assistOptions = new AssistOptions(options);
+
+		suggestNames(
+			packageName,
+			qualifiedTypeName,
+			dim,
+			assistOptions.argumentPrefixes,
+			assistOptions.argumentSuffixes,
+			excludedNames,
+			getNameScanner(compilerOptions),
+			requestor);
+	}
+	public static void suggestFieldNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, int modifiers, char[][] excludedNames, INamingRequestor requestor) {
+		boolean isStatic = Flags.isStatic(modifiers);
+		
+		Map options = javaProject.getOptions(true);
+		CompilerOptions compilerOptions = new CompilerOptions(options);
+		AssistOptions assistOptions = new AssistOptions(options);
+
+		suggestNames(
+			packageName,
+			qualifiedTypeName,
+			dim,
+			isStatic ? assistOptions.staticFieldPrefixes : assistOptions.fieldPrefixes,
+			isStatic ? assistOptions.staticFieldSuffixes : assistOptions.fieldSuffixes,
+			excludedNames,
+			getNameScanner(compilerOptions),
+			requestor);
+	}
+	public static void suggestLocalVariableNames(IJavaProject javaProject, char[] packageName, char[] qualifiedTypeName, int dim, char[][] excludedNames, INamingRequestor requestor) {
+		Map options = javaProject.getOptions(true);
+		CompilerOptions compilerOptions = new CompilerOptions(options);
+		AssistOptions assistOptions = new AssistOptions(options);
+
+		suggestNames(
+			packageName,
+			qualifiedTypeName,
+			dim,
+			assistOptions.localPrefixes,
+			assistOptions.localSuffixes,
+			excludedNames,
+			getNameScanner(compilerOptions),
+			requestor);
+	}
+	
+	private static void suggestNames(
+		char[] packageName,
+		char[] qualifiedTypeName,
+		int dim,
+		char[][] prefixes,
+		char[][] suffixes,
+		char[][] excludedNames,
+		Scanner nameScanner,
+		INamingRequestor requestor){
+		
+		if(qualifiedTypeName == null || qualifiedTypeName.length == 0)
+			return;
+		
+		char[] typeName = CharOperation.lastSegment(qualifiedTypeName, '.');
+	
+		if(prefixes == null || prefixes.length == 0) {
+			prefixes = new char[1][0];
+		} else {
+			int length = prefixes.length;
+			System.arraycopy(prefixes, 0, prefixes = new char[length+1][], 0, length);
+			prefixes[length] = CharOperation.NO_CHAR;
+		}
+	
+		if(suffixes == null || suffixes.length == 0) {
+			suffixes = new char[1][0];
+		} else {
+			int length = suffixes.length;
+			System.arraycopy(suffixes, 0, suffixes = new char[length+1][], 0, length);
+			suffixes[length] = CharOperation.NO_CHAR;
+		}
+	
+		char[][] tempNames = null;
+	
+		// compute variable name for base type
+		try{
+			nameScanner.setSource(typeName);
+			switch (nameScanner.getNextToken()) {
+				case TerminalTokens.TokenNameint :
+				case TerminalTokens.TokenNamebyte :
+				case TerminalTokens.TokenNameshort :
+				case TerminalTokens.TokenNamechar :
+				case TerminalTokens.TokenNamelong :
+				case TerminalTokens.TokenNamefloat :
+				case TerminalTokens.TokenNamedouble :
+				case TerminalTokens.TokenNameboolean :	
+					char[] name = computeBaseNames(typeName[0], prefixes, excludedNames);
+					if(name != null) {
+						tempNames =  new char[][]{name};
+					}
+					break;
+			}	
+		} catch(InvalidInputException e){
+		}
+
+		// compute variable name for non base type
+		if(tempNames == null) {
+			tempNames = computeNames(typeName);
+		}
+	
+		boolean acceptDefaultName = true;
+		
+		for (int i = 0; i < tempNames.length; i++) {
+			char[] tempName = tempNames[i];
+			if(dim > 0) {
+				int length = tempName.length;
+				if (tempName[length-1] == 's'){
+					System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+					tempName[length] = 'e';
+					tempName[length+1] = 's';
+				} else if(tempName[length-1] == 'y') {
+					System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
+					tempName[length-1] = 'i';
+					tempName[length] = 'e';
+					tempName[length+1] = 's';
+				} else {
+					System.arraycopy(tempName, 0, tempName = new char[length + 1], 0, length);
+					tempName[length] = 's';
+				}
+			}
+		
+			for (int j = 0; j < prefixes.length; j++) {
+				if(prefixes[j].length > 0
+					&& Character.isLetterOrDigit(prefixes[j][prefixes[j].length - 1])) {
+					tempName[0] = Character.toUpperCase(tempName[0]);
+				} else {
+					tempName[0] = Character.toLowerCase(tempName[0]);
+				}
+				char[] prefixName = CharOperation.concat(prefixes[j], tempName);
+				for (int k = 0; k < suffixes.length; k++) {
+					char[] suffixName = CharOperation.concat(prefixName, suffixes[k]);
+					suffixName =
+						excludeNames(
+							suffixName,
+							prefixName,
+							suffixes[k],
+							excludedNames);
+					if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
+						acceptName(suffixName, prefixes[j], suffixes[k], requestor);
+						acceptDefaultName = false;
+					} else {
+						suffixName = CharOperation.concat(
+							prefixName,
+							String.valueOf(1).toCharArray(),
+							suffixes[k]
+						);
+						suffixName =
+							excludeNames(
+								suffixName,
+								prefixName,
+								suffixes[k],
+								excludedNames);
+						if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
+							acceptName(suffixName, prefixes[j], suffixes[k], requestor);
+							acceptDefaultName = false;
+						}
+					}
+				}
+			
+			}
+		}
+		// if no names were found
+		if(acceptDefaultName) {
+			char[] name = excludeNames(DEFAULT_NAME, DEFAULT_NAME, CharOperation.NO_CHAR, excludedNames);
+			requestor.acceptNameWithoutPrefixAndSuffix(name);
+		}
+	}
+	
+	private static void acceptName(char[] name, char[] prefix, char[] suffix, INamingRequestor requestor) {
+		if(prefix.length > 0 && suffix.length > 0) {
+			requestor.acceptNameWithPrefixAndSuffix(name);
+		} else if(prefix.length > 0){
+			requestor.acceptNameWithPrefix(name);
+		} else if(suffix.length > 0){
+			requestor.acceptNameWithSuffix(name);
+		} else {
+			requestor.acceptNameWithoutPrefixAndSuffix(name);
+		}
+	}
+	
+
+	private static char[] computeBaseNames(char firstName, char[][] prefixes, char[][] excludedNames){
+		char[] name = new char[]{firstName};
+		
+		for(int i = 0 ; i < excludedNames.length ; i++){
+			if(CharOperation.equals(name, excludedNames[i], false)) {
+				name[0]++;
+				if(name[0] > 'z')
+					name[0] = 'a';
+				if(name[0] == firstName)
+					return null;
+				i = 0;
+			}	
+		}
+		
+		return name;
+	}
+	
+	private static char[][] computeNames(char[] sourceName){
+		char[][] names = new char[5][];
+		int nameCount = 0;
+		boolean previousIsUpperCase = false;
+		boolean previousIsLetter = true;
+		for(int i = sourceName.length - 1 ; i >= 0 ; i--){
+			boolean isUpperCase = Character.isUpperCase(sourceName[i]);
+			boolean isLetter = Character.isLetter(sourceName[i]);
+			if(isUpperCase && !previousIsUpperCase && previousIsLetter){
+				char[] name = CharOperation.subarray(sourceName,i,sourceName.length);
+				if(name.length > 1){
+					if(nameCount == names.length) {
+						System.arraycopy(names, 0, names = new char[nameCount * 2][], 0, nameCount);
+					}
+					name[0] = Character.toLowerCase(name[0]);
+					names[nameCount++] = name;
+				}
+			}
+			previousIsUpperCase = isUpperCase;
+			previousIsLetter = isLetter;
+		}
+		if(nameCount == 0){
+			names[nameCount++] = CharOperation.toLowerCase(sourceName);				
+		}
+		System.arraycopy(names, 0, names = new char[nameCount][], 0, nameCount);
+		return names;
+	}
+
+	private static char[] excludeNames(
+		char[] suffixName,
+		char[] prefixName,
+		char[] suffix,
+		char[][] excludedNames) {
+		int count = 2;
+		int m = 0;
+		while (m < excludedNames.length) {
+			if(CharOperation.equals(suffixName, excludedNames[m], false)) {
+				suffixName = CharOperation.concat(
+					prefixName,
+					String.valueOf(count++).toCharArray(),
+					suffix
+				);
+				m = 0;
+			} else {
+				m++;
+			}
+		}
+		return suffixName;
+	}
+}
commit 1612764cac82755ece5bb371b617dba233a98e7f
Author: David Audel <daudel>
Date:   Fri Feb 14 17:09:46 2003 +0000

    bug 31652

44	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
6	0	org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionVariableName3.java
7	6	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
5	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
132	33	org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
14	9	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 470998b..770f479 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -123,6 +123,7 @@ public static Test suite() {
 	suite.addTest(new CompletionTests("testCompletionReturnInInitializer"));
 	suite.addTest(new CompletionTests("testCompletionVariableName1"));
 	suite.addTest(new CompletionTests("testCompletionVariableName2"));
+	suite.addTest(new CompletionTests("testCompletionVariableName3"));
 	suite.addTest(new CompletionTests("testCompletionOnStaticMember1"));
 	suite.addTest(new CompletionTests("testCompletionOnStaticMember2"));
 	suite.addTest(new CompletionTests("testCompletionMemberType2"));
@@ -8088,7 +8089,7 @@ public void testCompletionCatchArgumentName2() throws JavaModelException {
 
 	assertEquals(
 		"element:exception    completion:exception    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE)+"\n"+
-		"element:locException    completion:locException    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX),
+		"element:locException    completion:locException    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX),
 		requestor.getResults());
 }
 public void testCompletionArrayAccess1() throws JavaModelException {
@@ -8105,4 +8106,46 @@ public void testCompletionArrayAccess1() throws JavaModelException {
 		"element:zzz2    completion:zzz2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_EXPECTED_TYPE +R_UNQUALIFIED),
 		requestor.getResults());
 }
+public void testCompletionVariableName3() throws JavaModelException {
+	Hashtable options = JavaCore.getOptions();
+	Object argumentPrefixPreviousValue = options.get(JavaCore.CODEASSIST_LOCAL_PREFIXES);
+	options.put(JavaCore.CODEASSIST_LOCAL_PREFIXES,"p1,p2"); //$NON-NLS-1$
+	Object localPrefixPreviousValue = options.get(JavaCore.CODEASSIST_LOCAL_SUFFIXES);
+	options.put(JavaCore.CODEASSIST_LOCAL_SUFFIXES,"s1,s2"); //$NON-NLS-1$
+	
+	JavaCore.setOptions(options);
+
+	CompletionTestsRequestor requestor = new CompletionTestsRequestor();
+	ICompilationUnit cu= getCompilationUnit("Completion", "src", "", "CompletionVariableName3.java");
+
+	String str = cu.getSource();
+	String completeBehind = "OneName ";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	cu.codeComplete(cursorLocation, requestor);
+
+	options.put(JavaCore.CODEASSIST_LOCAL_PREFIXES,argumentPrefixPreviousValue);
+	options.put(JavaCore.CODEASSIST_LOCAL_SUFFIXES,localPrefixPreviousValue);
+	JavaCore.setOptions(options);
+
+	assertEquals(
+		"element:name    completion:name    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE)+"\n"+
+		"element:names1    completion:names1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:names2    completion:names2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_SUFFIX)+"\n"+
+		"element:oneName    completion:oneName    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE)+"\n"+
+		"element:oneNames1    completion:oneNames1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:oneNames2    completion:oneNames2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_SUFFIX)+"\n"+
+		"element:p1Name    completion:p1Name    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX)+"\n"+
+		"element:p1Names1    completion:p1Names1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:p1Names2    completion:p1Names2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX + R_NAME_SUFFIX)+"\n"+
+		"element:p1OneName    completion:p1OneName    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX)+"\n"+
+		"element:p1OneNames1    completion:p1OneNames1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:p1OneNames2    completion:p1OneNames2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_FIRST_PREFIX + R_NAME_SUFFIX)+"\n"+
+		"element:p2Name    completion:p2Name    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX)+"\n"+
+		"element:p2Names1    completion:p2Names1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:p2Names2    completion:p2Names2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX + R_NAME_SUFFIX)+"\n"+
+		"element:p2OneName    completion:p2OneName    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX)+"\n"+
+		"element:p2OneNames1    completion:p2OneNames1    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX + R_NAME_FIRST_SUFFIX)+"\n"+
+		"element:p2OneNames2    completion:p2OneNames2    relevance:"+(R_DEFAULT + R_INTERESTING + R_CASE + R_NAME_PREFIX + R_NAME_SUFFIX),
+		requestor.getResults());
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionVariableName3.java b/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionVariableName3.java
new file mode 100644
index 0000000..513d38a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionVariableName3.java
@@ -0,0 +1,6 @@
+public class CompletionVariableName3 {
+	class OneName {}
+	void foo() {
+		OneName 
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 909ebd7..3e24d30 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -2866,16 +2866,17 @@ public final class CompletionEngine
 		final char[] t = token;
 		final char[] q = qualifiedPackageName;
 		INamingRequestor namingRequestor = new INamingRequestor() {
-			public void acceptNameWithPrefixAndSuffix(char[] name) {
-				accept(name, R_NAME_PREFIX + R_NAME_SUFFIX);
+			public void acceptNameWithPrefixAndSuffix(char[] name, boolean isFirstPrefix, boolean isFirstSuffix) {
+				accept(	name,
+					(isFirstPrefix ? R_NAME_FIRST_PREFIX : R_NAME_PREFIX) + (isFirstSuffix ? R_NAME_FIRST_SUFFIX : R_NAME_SUFFIX));
 			}
 
-			public void acceptNameWithPrefix(char[] name) {
-				accept(name, R_NAME_PREFIX);
+			public void acceptNameWithPrefix(char[] name, boolean isFirstPrefix) {
+				accept(name, isFirstPrefix ? R_NAME_FIRST_PREFIX :  R_NAME_PREFIX);
 			}
 
-			public void acceptNameWithSuffix(char[] name) {
-				accept(name, R_NAME_SUFFIX);
+			public void acceptNameWithSuffix(char[] name, boolean isFirstSuffix) {
+				accept(name, isFirstSuffix ? R_NAME_FIRST_SUFFIX : R_NAME_SUFFIX);
 			}
 
 			public void acceptNameWithoutPrefixAndSuffix(char[] name) {
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
index d3d21de..56c7ace 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/RelevanceConstants.java
@@ -24,6 +24,10 @@ public interface RelevanceConstants {
 	int R_ABSTRACT_METHOD = 20;
 	int R_NON_STATIC = 10;
 	int R_UNQUALIFIED = 5;
+	int R_NAME_FIRST_PREFIX = 6;
 	int R_NAME_PREFIX = 5;
-	int R_NAME_SUFFIX = 4;
+	int R_NAME_FIRST_SUFFIX = 4;
+	int R_NAME_SUFFIX = 3;
+	
+	
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
index 5a2e647..926b48a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java
@@ -51,74 +51,173 @@ public final class NamingConventions {
 	
 	private static class NamingRequestor implements INamingRequestor {
 		private final static int SIZE = 10;
+		
+		// for acceptNameWithPrefixAndSuffix
+		private char[][] firstPrefixAndFirstSuffixResults = new char[SIZE][];
+		private int firstPrefixAndFirstSuffixResultsCount = 0;
+		private char[][] firstPrefixAndSuffixResults = new char[SIZE][];
+		private int firstPrefixAndSuffixResultsCount = 0;
+		private char[][] prefixAndFirstSuffixResults = new char[SIZE][];
+		private int prefixAndFirstSuffixResultsCount = 0;
 		private char[][] prefixAndSuffixResults = new char[SIZE][];
 		private int prefixAndSuffixResultsCount = 0;
+		
+		// for acceptNameWithPrefix
+		private char[][] firstPrefixResults = new char[SIZE][];
+		private int firstPrefixResultsCount = 0;
 		private char[][] prefixResults = new char[SIZE][];
 		private int prefixResultsCount = 0;
+		
+		// for acceptNameWithSuffix
+		private char[][] firstSuffixResults = new char[SIZE][];
+		private int firstSuffixResultsCount = 0;
 		private char[][] suffixResults = new char[SIZE][];
 		private int suffixResultsCount = 0;
+		
+		// for acceptNameWithoutPrefixAndSuffix
 		private char[][] otherResults = new char[SIZE][];
 		private int otherResultsCount = 0;
-		public void acceptNameWithPrefixAndSuffix(char[] name) {
-			int length = prefixAndSuffixResults.length;
-			if(length == prefixAndSuffixResultsCount) {
-				System.arraycopy(
-					prefixAndSuffixResults,
-					0,
-					prefixAndSuffixResults = new char[length * 2][],
-					0,
-					length);
+		public void acceptNameWithPrefixAndSuffix(char[] name, boolean isFirstPrefix, boolean isFirstSuffix) {
+			if(isFirstPrefix && isFirstSuffix) {
+				int length = firstPrefixAndFirstSuffixResults.length;
+				if(length == firstPrefixAndFirstSuffixResultsCount) {
+					System.arraycopy(
+						firstPrefixAndFirstSuffixResults,
+						0,
+						firstPrefixAndFirstSuffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				firstPrefixAndFirstSuffixResults[firstPrefixAndFirstSuffixResultsCount++] = name;			
+			} else if (isFirstPrefix) {
+				int length = firstPrefixAndSuffixResults.length;
+				if(length == firstPrefixAndSuffixResultsCount) {
+					System.arraycopy(
+						firstPrefixAndSuffixResults,
+						0,
+						firstPrefixAndSuffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				firstPrefixAndSuffixResults[firstPrefixAndSuffixResultsCount++] = name;
+			} else if(isFirstSuffix) {
+				int length = prefixAndFirstSuffixResults.length;
+				if(length == prefixAndFirstSuffixResultsCount) {
+					System.arraycopy(
+						prefixAndFirstSuffixResults,
+						0,
+						prefixAndFirstSuffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				prefixAndFirstSuffixResults[prefixAndFirstSuffixResultsCount++] = name;
+			} else {
+				int length = prefixAndSuffixResults.length;
+				if(length == prefixAndSuffixResultsCount) {
+					System.arraycopy(
+						prefixAndSuffixResults,
+						0,
+						prefixAndSuffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				prefixAndSuffixResults[prefixAndSuffixResultsCount++] = name;
 			}
-			prefixAndSuffixResults[prefixAndSuffixResultsCount++] = name;
 		}
 
-		public void acceptNameWithPrefix(char[] name) {
-			int length = prefixResults.length;
-			if(length == prefixResultsCount) {
-				System.arraycopy(
-					prefixResults,
-					0,
-					prefixResults = new char[length * 2][],
-					0,
-					length);
+		public void acceptNameWithPrefix(char[] name, boolean isFirstPrefix) {
+			if(isFirstPrefix) {
+				int length = firstPrefixResults.length;
+				if(length == firstPrefixResultsCount) {
+					System.arraycopy(
+						firstPrefixResults,
+						0,
+						firstPrefixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				firstPrefixResults[firstPrefixResultsCount++] = name;
+			} else{
+				int length = prefixResults.length;
+				if(length == prefixResultsCount) {
+					System.arraycopy(
+						prefixResults,
+						0,
+						prefixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				prefixResults[prefixResultsCount++] = name;
 			}
-			prefixResults[prefixResultsCount++] = name;
 		}
 
-		public void acceptNameWithSuffix(char[] name) {
-			int length = suffixResults.length;
-			if(length == suffixResultsCount) {
-				System.arraycopy(
-				suffixResults,
-					0,
-				suffixResults = new char[length * 2][],
-					0,
-					length);
+		public void acceptNameWithSuffix(char[] name, boolean isFirstSuffix) {
+			if(isFirstSuffix) {
+				int length = firstSuffixResults.length;
+				if(length == firstSuffixResultsCount) {
+					System.arraycopy(
+						firstSuffixResults,
+						0,
+						firstSuffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				firstSuffixResults[firstSuffixResultsCount++] = name;
+			} else {
+				int length = suffixResults.length;
+				if(length == suffixResultsCount) {
+					System.arraycopy(
+						suffixResults,
+						0,
+						suffixResults = new char[length * 2][],
+						0,
+						length);
+				}
+				suffixResults[suffixResultsCount++] = name;
 			}
-			suffixResults[suffixResultsCount++] = name;
 		}
 
 		public void acceptNameWithoutPrefixAndSuffix(char[] name) {
 			int length = otherResults.length;
 			if(length == otherResultsCount) {
 				System.arraycopy(
-				otherResults,
+					otherResults,
 					0,
-				otherResults = new char[length * 2][],
+					otherResults = new char[length * 2][],
 					0,
 					length);
 			}
 			otherResults[otherResultsCount++] = name;
 		}
 		public char[][] getResults(){
-			int count = prefixAndSuffixResultsCount + prefixResultsCount + suffixResultsCount + otherResultsCount;
+			int count = 
+				firstPrefixAndFirstSuffixResultsCount
+				+ firstPrefixAndSuffixResultsCount
+				+ prefixAndFirstSuffixResultsCount
+				+ prefixAndSuffixResultsCount
+				+ firstPrefixResultsCount
+				+ prefixResultsCount
+				+ firstSuffixResultsCount
+				+ suffixResultsCount
+				+ otherResultsCount;
+				
 			char[][] results = new char[count][];
 			
 			int index = 0;
+			System.arraycopy(firstPrefixAndFirstSuffixResults, 0, results, index, firstPrefixAndFirstSuffixResultsCount);
+			index += firstPrefixAndFirstSuffixResultsCount;
+			System.arraycopy(firstPrefixAndSuffixResults, 0, results, index, firstPrefixAndSuffixResultsCount);
+			index += firstPrefixAndSuffixResultsCount;
+			System.arraycopy(prefixAndFirstSuffixResults, 0, results, index, prefixAndFirstSuffixResultsCount);
+			index += prefixAndFirstSuffixResultsCount;		
 			System.arraycopy(prefixAndSuffixResults, 0, results, index, prefixAndSuffixResultsCount);
 			index += prefixAndSuffixResultsCount;
+			System.arraycopy(firstPrefixResults, 0, results, index, firstPrefixResultsCount);
+			index += firstPrefixResultsCount;
 			System.arraycopy(prefixResults, 0, results, index, prefixResultsCount);
 			index += prefixResultsCount;
+			System.arraycopy(firstSuffixResults, 0, results, index, firstSuffixResultsCount);
+			index += firstSuffixResultsCount;
 			System.arraycopy(suffixResults, 0, results, index, suffixResultsCount);
 			index += suffixResultsCount;
 			System.arraycopy(otherResults, 0, results, index, otherResultsCount);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
index d6c2206..37bb4af 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/INamingRequestor.java
@@ -11,8 +11,8 @@
 package org.eclipse.jdt.internal.core;
 
 public interface INamingRequestor {
-	void acceptNameWithPrefixAndSuffix(char[] name);
-	void acceptNameWithPrefix(char[] name);
-	void acceptNameWithSuffix(char[] name);
+	void acceptNameWithPrefixAndSuffix(char[] name, boolean isFirstPrefix, boolean isFirstSuffix);
+	void acceptNameWithPrefix(char[] name, boolean isFirstPrefix);
+	void acceptNameWithSuffix(char[] name, boolean isFirstSuffix);
 	void acceptNameWithoutPrefixAndSuffix(char[] name);
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
index 9f3118c..441b1ac 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java
@@ -129,7 +129,7 @@ public class InternalNamingConventions {
 				case TerminalTokens.TokenNamefloat :
 				case TerminalTokens.TokenNamedouble :
 				case TerminalTokens.TokenNameboolean :	
-					char[] name = computeBaseNames(typeName[0], prefixes, excludedNames);
+					char[] name = computeBaseTypeNames(typeName[0], excludedNames);
 					if(name != null) {
 						tempNames =  new char[][]{name};
 					}
@@ -181,7 +181,7 @@ public class InternalNamingConventions {
 							suffixes[k],
 							excludedNames);
 					if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
-						acceptName(suffixName, prefixes[j], suffixes[k], requestor);
+						acceptName(suffixName, prefixes[j], suffixes[k],  j == 0, k == 0, requestor);
 						acceptDefaultName = false;
 					} else {
 						suffixName = CharOperation.concat(
@@ -196,7 +196,7 @@ public class InternalNamingConventions {
 								suffixes[k],
 								excludedNames);
 						if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
-							acceptName(suffixName, prefixes[j], suffixes[k], requestor);
+							acceptName(suffixName, prefixes[j], suffixes[k], j == 0, k == 0, requestor);
 							acceptDefaultName = false;
 						}
 					}
@@ -211,20 +211,25 @@ public class InternalNamingConventions {
 		}
 	}
 	
-	private static void acceptName(char[] name, char[] prefix, char[] suffix, INamingRequestor requestor) {
+	private static void acceptName(
+		char[] name,
+		char[] prefix,
+		char[] suffix,
+		boolean isFirstPrefix,
+		boolean isFirstSuffix,
+		INamingRequestor requestor) {
 		if(prefix.length > 0 && suffix.length > 0) {
-			requestor.acceptNameWithPrefixAndSuffix(name);
+			requestor.acceptNameWithPrefixAndSuffix(name, isFirstPrefix, isFirstSuffix);
 		} else if(prefix.length > 0){
-			requestor.acceptNameWithPrefix(name);
+			requestor.acceptNameWithPrefix(name, isFirstPrefix);
 		} else if(suffix.length > 0){
-			requestor.acceptNameWithSuffix(name);
+			requestor.acceptNameWithSuffix(name, isFirstSuffix);
 		} else {
 			requestor.acceptNameWithoutPrefixAndSuffix(name);
 		}
 	}
 	
-
-	private static char[] computeBaseNames(char firstName, char[][] prefixes, char[][] excludedNames){
+	private static char[] computeBaseTypeNames(char firstName, char[][] excludedNames){
 		char[] name = new char[]{firstName};
 		
 		for(int i = 0 ; i < excludedNames.length ; i++){
