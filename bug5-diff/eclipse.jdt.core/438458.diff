commit 1ab17a7eba14d35875267cc7b416da000a14dc1e
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Jun 28 16:48:58 2014 +0200

    Bug 438458 - [1.8][null] clean up handling of null type annotations wrt
    type variables
    - facility to remove only null type annotations (using unannotated(Z))

4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
12	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
24	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NullTypeBinding.java
17	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
14	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VoidTypeBinding.java
19	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
4	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 5d9cf2b..e6366c5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -20,6 +20,8 @@
  *                          Bug 415399 - [1.8][compiler] Type annotations on constructor results dropped by the code generator
  *                          Bug 415470 - [1.8][compiler] Type annotations on class declaration go vanishing
  *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
+ *     Stephan Herrmann - Contribution for
+ *							Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
 
@@ -5152,11 +5154,11 @@ public class ClassFile implements TypeConstants, TypeIds {
 			this.innerClassesBindings = new HashSet(INNER_CLASSES_SIZE);
 		}
 		ReferenceBinding innerClass = (ReferenceBinding) binding;
-		this.innerClassesBindings.add(innerClass.erasure().unannotated());  // should not emit yet another inner class for Outer.@Inner Inner.
+		this.innerClassesBindings.add(innerClass.erasure().unannotated(false));  // should not emit yet another inner class for Outer.@Inner Inner.
 		ReferenceBinding enclosingType = innerClass.enclosingType();
 		while (enclosingType != null
 				&& enclosingType.isNestedType()) {
-			this.innerClassesBindings.add(enclosingType.erasure().unannotated());
+			this.innerClassesBindings.add(enclosingType.erasure().unannotated(false));
 			enclosingType = enclosingType.enclosingType();
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index d54e5a8..5cd388c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -31,6 +31,7 @@
  *							Bug 428980 - [1.8][null] simple expression as lambda body doesn't leverage null annotation on argument
  *							Bug 429430 - [1.8] Lambdas and method reference infer wrong exception type with generics (RuntimeException instead of IOException)
  *							Bug 432110 - [1.8][compiler] nested lambda type incorrectly inferred vs javac
+ *							Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 405104 - [1.8][compiler][codegen] Implement support for serializeable lambdas
  *******************************************************************************/
@@ -507,7 +508,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			int length = this.binding.parameters.length;
 			for (int i=0; i<length; i++) {
 				if (!this.scope.validateNullAnnotation(this.binding.returnType.tagBits, this.arguments[i].type, this.arguments[i].annotations))
-					this.binding.returnType = this.binding.returnType.unannotated();
+					this.binding.returnType = this.binding.returnType.unannotated(true);
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
index 4124f49..79bb554 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
@@ -20,6 +20,7 @@
  *								Bug 425460 - [1.8] [inference] Type not inferred on stream.toArray
  *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *								Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -451,8 +452,17 @@ public void swapUnresolved(UnresolvedReferenceBinding unresolvedType, ReferenceB
 public String toString() {
 	return this.leafComponentType != null ? debugName() : "NULL TYPE ARRAY"; //$NON-NLS-1$
 }
-public TypeBinding unannotated() {
-	return this.hasTypeAnnotations() ? this.environment.getUnannotatedType(this) : this;
+public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+	if (!hasTypeAnnotations())
+		return this;
+	if (removeOnlyNullAnnotations) {
+		if (!hasNullTypeAnnotations())
+			return this;
+		AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+		if (newAnnotations.length > 0)
+			return this.environment.createArrayType(this.leafComponentType.unannotated(false), this.dimensions, newAnnotations);
+	}
+	return this.environment.getUnannotatedType(this);
 }
 @Override
 public TypeBinding uncapture(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
index 6e0bd31..aad394b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -172,7 +173,7 @@ public class BaseTypeBinding extends TypeBinding {
 		super.setTypeAnnotations(annotations, false); // never set nullTagBits on base types
 	}
 
-	public TypeBinding unannotated() {
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
 		if (!this.hasTypeAnnotations())
 			return this;
 		switch (this.id) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index f357a3d..bfe7fcb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -26,6 +26,7 @@
  *								Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *								Bug 390889 - [1.8][compiler] Evaluate options to support 1.7- projects against 1.8 JRE.
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -1917,7 +1918,14 @@ public String toString() {
 	return buffer.toString();
 }
 
-public TypeBinding unannotated() {
+public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+	if (removeOnlyNullAnnotations) {
+		if (!hasNullTypeAnnotations())
+			return this;
+		AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+		if (newAnnotations.length > 0)
+			return this.environment.createAnnotatedType(this.prototype, newAnnotations);
+	}
 	return this.prototype;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 24f9b2a..6b68f8d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -236,7 +236,7 @@ class BoundSet {
 			if (nullHints == TagBits.AnnotationNullMASK) {
 				// on contradiction remove null type annotations
 				for (int i = 0; i < boundTypes.length; i++)
-					boundTypes[i] = boundTypes[i].unannotated();
+					boundTypes[i] = boundTypes[i].unannotated(true);
 			} else {
 				AnnotationBinding[] annot = environment.nullAnnotationsFromTagBits(nullHints);
 				if (annot != null) {
@@ -266,7 +266,7 @@ class BoundSet {
 					nullHints |= it.next().nullHints;
 			}
 			if (nullHints == TagBits.AnnotationNullMASK) // on contradiction remove null type annotations
-				return type.unannotated();
+				return type.unannotated(true);
 			AnnotationBinding[] annot = environment.nullAnnotationsFromTagBits(nullHints);
 			if (annot != null)
 				// only get here if exactly one of @NonNull or @Nullable was hinted; now apply this hint:
@@ -286,7 +286,7 @@ class BoundSet {
 					// adjust 'type' to fit the newBits
 					AnnotationBinding[] annot = environment.nullAnnotationsFromTagBits(newBits);
 					if (annot != null)
-						type = environment.createAnnotatedType(type.unannotated(), annot);
+						type = environment.createAnnotatedType(type.unannotated(true), annot);
 				}
 			}
 			this.instantiation = type;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 09219e8..a242000 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -24,6 +24,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
  *								Bug 424624 - [1.8][null] if a static-object with annotation @NonNull is used, a warning is shown
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1604,4 +1605,27 @@ public TypeBinding getUnannotatedType(TypeBinding typeBinding) {
 public TypeBinding[] getAnnotatedTypes(TypeBinding type) {
 	return this.typeSystem.getAnnotatedTypes(type);
 }
+
+public AnnotationBinding[] filterNullTypeAnnotations(AnnotationBinding[] typeAnnotations) {
+	if (typeAnnotations.length == 0)
+		return typeAnnotations;
+	AnnotationBinding[] filtered = new AnnotationBinding[typeAnnotations.length];
+	int count = 0;
+	for (int i = 0; i < typeAnnotations.length; i++) {
+		AnnotationBinding typeAnnotation = typeAnnotations[i];
+		if (typeAnnotation == null) {
+			count++; // sentinel in annotation sequence for array dimensions
+		} else {
+			int id = typeAnnotation.type.id;
+			if (id != TypeIds.T_ConfiguredAnnotationNonNull && id != TypeIds.T_ConfiguredAnnotationNullable)
+				filtered[count++] = typeAnnotation;
+		}
+	}
+	if (count == 0)
+		return Binding.NO_ANNOTATIONS;
+	if (count == typeAnnotations.length)
+		return typeAnnotations;
+	System.arraycopy(filtered, 0, filtered = new AnnotationBinding[count], 0, count);
+	return filtered;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NullTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NullTypeBinding.java
index 5880f46..49eb52c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NullTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/NullTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
+ * Copyright (c) 2013, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -25,7 +27,7 @@ public class NullTypeBinding extends BaseTypeBinding {
 		return; // reject misguided attempt.
 	}
 	
-	public TypeBinding unannotated() {
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
 		return this;
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index d22336c..58da4c0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -32,6 +32,7 @@
  *								Bug 428294 - [1.8][compiler] Type mismatch: cannot convert from List<Object> to Collection<Object[]>
  *								Bug 427199 - [1.8][resource] avoid resource leak warnings on Streams that have no resource
  *								Bug 416182 - [1.8][compiler][null] Contradictory null annotations not rejected
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -873,8 +874,22 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		return isRawType();
 	}
 
-	public TypeBinding unannotated() {
-		return this.hasTypeAnnotations() ? this.environment.getUnannotatedType(this) : this;
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+		if (!hasTypeAnnotations())
+			return this;
+		if (removeOnlyNullAnnotations && !hasNullTypeAnnotations())
+			return this;
+		ReferenceBinding unannotatedType = (ReferenceBinding) this.environment.getUnannotatedType(this);
+		if (removeOnlyNullAnnotations) {
+			AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+			TypeBinding[] newArguments = new TypeBinding[this.arguments.length];
+			for (int i = 0; i < this.arguments.length; i++) {
+				newArguments[i] = this.arguments[i].unannotated(removeOnlyNullAnnotations);
+			}
+			ReferenceBinding newEnclosing = (ReferenceBinding)this.enclosingType.unannotated(removeOnlyNullAnnotations);
+			return this.environment.createParameterizedType(unannotatedType, newArguments, newEnclosing, newAnnotations);
+		}
+		return unannotatedType;
 	}
 
 	public int kind() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 31fc2c7..e434522 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -32,6 +32,7 @@
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *								Bug 432348 - [1.8] Internal compiler error (NPE) after upgrade to 1.8
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *      Till Brychcy - Contributions for
@@ -2510,7 +2511,14 @@ void verifyMethods(MethodVerifier verifier) {
 		 ((SourceTypeBinding) this.memberTypes[i]).verifyMethods(verifier);
 }
 
-public TypeBinding unannotated() {
+public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+	if (removeOnlyNullAnnotations) {
+		if (!hasNullTypeAnnotations())
+			return this;
+		AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+		if (newAnnotations.length > 0)
+			return this.environment.createAnnotatedType(this.prototype, newAnnotations);
+	}
 	return this.prototype;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 35da6e2..5a13d47 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -24,6 +24,7 @@
  *								Bug 427626 - [1.8] StackOverflow while typing new ArrayList<String>().toArray( and asking for code completion
  *								Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
  *								Bug 435962 - [RC2] StackOverFlowError when building
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -1393,16 +1394,17 @@ public TypeBinding original() {
 		case Binding.PARAMETERIZED_TYPE :
 		case Binding.RAW_TYPE :
 		case Binding.ARRAY_TYPE :
-			return erasure().unannotated();
+			return erasure().unannotated(false);
 		default :
-			return this.unannotated();
+			return this.unannotated(false);
 	}
 }
 
 /** 
  * Return this type minus its type annotations
+ * @param removeOnlyNullAnnotations if true only null type annotations are removed, otherwise all type annotations.
  */
-public TypeBinding unannotated() {
+public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
 	return this;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 3328982..f495387 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -23,6 +23,7 @@
  *								Bug 431269 - [1.8][compiler][null] StackOverflow in nullAnnotatedReadableName
  *								Bug 431408 - Java 8 (1.8) generics bug
  *								Bug 435962 - [RC2] StackOverFlowError when building
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -773,9 +774,19 @@ public class TypeVariableBinding extends ReferenceBinding {
 	    return readableName;
 	}
 
-	// May still carry declaration site annotations.
-	public TypeBinding unannotated() {
-		return this.hasTypeAnnotations() ? this.environment.getUnannotatedType(this) : this;
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+		if (!hasTypeAnnotations())
+			return this;
+		if (removeOnlyNullAnnotations && !hasNullTypeAnnotations())
+			return this;
+		TypeBinding unannotated = this.environment.getUnannotatedType(this);
+		if (removeOnlyNullAnnotations) {
+			AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+			if (newAnnotations.length > 0)
+				return this.environment.createAnnotatedType(unannotated, newAnnotations);
+			// FIXME: selectively keep type annotations on bounds
+		}
+		return unannotated; 
 	}
 	/**
 	 * Upper bound doesn't perform erasure
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VoidTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VoidTypeBinding.java
index 5fdbc1a..3ad8be4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VoidTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/VoidTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
+ * Copyright (c) 2013, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -25,7 +27,7 @@ public class VoidTypeBinding extends BaseTypeBinding {
 		return; // reject misguided attempt.
 	}
 	
-	public TypeBinding unannotated() {
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
 		return this;
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index b234b76..7837fae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -18,6 +18,7 @@
  *								Bug 427411 - [1.8][generics] JDT reports type mismatch when using method that returns generic type
  *								Bug 428019 - [1.8][compiler] Type inference failure with nested generic invocation.
  *								Bug 435962 - [RC2] StackOverFlowError when building
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -883,8 +884,24 @@ public class WildcardBinding extends ReferenceBinding {
 		return this.typeVariable;
 	}
 
-	public TypeBinding unannotated() {
-		return this.hasTypeAnnotations() ? this.environment.getUnannotatedType(this) : this;
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+		if (!hasTypeAnnotations())
+			return this;
+		if (removeOnlyNullAnnotations && !hasNullTypeAnnotations())
+			return this;
+		ReferenceBinding unannotatedGenericType = (ReferenceBinding) this.genericType.unannotated(removeOnlyNullAnnotations);
+		if (removeOnlyNullAnnotations) {
+			// cf. structure of uncapture():
+			TypeBinding unannotatedBound = this.bound != null ? this.bound.unannotated(removeOnlyNullAnnotations) : null;
+			int length = 0;
+			TypeBinding [] unannotatedOtherBounds = this.otherBounds == null ? null : new TypeBinding[length = this.otherBounds.length];
+			for (int i = 0; i < length; i++) {
+				unannotatedOtherBounds[i] = this.otherBounds[i] == null ? null : this.otherBounds[i].unannotated(removeOnlyNullAnnotations);
+			}
+			AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(getTypeAnnotations());
+			return this.environment.createWildcard(unannotatedGenericType, this.rank, unannotatedBound, unannotatedOtherBounds, this.boundKind, newAnnotations);			
+		}
+		return unannotatedGenericType;
 	}
 	@Override
 	public TypeBinding uncapture(Scope scope) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index 6eb9ee3..da7ed8e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -465,7 +467,7 @@ class TypeBinding implements ITypeBinding {
 	public ITypeBinding getTypeDeclaration() {
 		if (this.binding instanceof ParameterizedTypeBinding)
 			return this.resolver.getTypeBinding(((ParameterizedTypeBinding)this.binding).genericType());
-		return this.resolver.getTypeBinding(this.binding.unannotated());
+		return this.resolver.getTypeBinding(this.binding.unannotated(false));
 	}
 	
 	/* (non-Javadoc)
@@ -1125,7 +1127,7 @@ class TypeBinding implements ITypeBinding {
 			return false;
 		}
 		org.eclipse.jdt.internal.compiler.lookup.TypeBinding otherBinding = ((TypeBinding) other).binding;
-		if (org.eclipse.jdt.internal.compiler.lookup.TypeBinding.equalsEquals(otherBinding.unannotated(), this.binding.unannotated())) {
+		if (org.eclipse.jdt.internal.compiler.lookup.TypeBinding.equalsEquals(otherBinding.unannotated(false), this.binding.unannotated(false))) {
 			return true;
 		}
 		// check return type
commit b1c69f20f23ddb575225e5b5cb5d470714f41aad
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 13 17:43:29 2014 +0200

    Bug 438458 - [1.8][null] clean up handling of null type annotations wrt
    type variables
    - let InferenceVariable participate in deep encoding of type annotations

31	26	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 6b68f8d..d121d3e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -116,6 +116,7 @@ class BoundSet {
 			InferenceContext18.sortTypes(rights);
 			return rights;
 		}
+		// pre: beta is a prototype
 		public boolean hasDependency(InferenceVariable beta) {
 			if (this.superBounds != null && hasDependency(this.superBounds, beta))
 				return true;
@@ -131,11 +132,12 @@ class BoundSet {
 			}
 			return false;
 		}
+		// pre: var is a prototype
 		private boolean hasDependency(Set<TypeBound> someBounds, InferenceVariable var) {
 			Iterator<TypeBound> bIt = someBounds.iterator();
 			while (bIt.hasNext()) {
 				TypeBound bound = bIt.next();
-				if (bound.right == var || bound.right.mentionsAny(new TypeBinding[] {var}, -1)) //$IDENTITY-COMPARISON$ InferenceVariable
+				if (TypeBinding.equalsEquals(bound.right, var) || bound.right.mentionsAny(new TypeBinding[] {var}, -1))
 					return true;
 			}
 			return false;
@@ -355,19 +357,20 @@ class BoundSet {
 	}
 
 	public void addBound(TypeBound bound, LookupEnvironment environment) {
-		ThreeSets three = this.boundsPerVariable.get(bound.left);
+		InferenceVariable variable = bound.left.prototype();
+		ThreeSets three = this.boundsPerVariable.get(variable);
 		if (three == null)
-			this.boundsPerVariable.put(bound.left, (three = new ThreeSets()));
+			this.boundsPerVariable.put(variable, (three = new ThreeSets()));
 		three.addBound(bound);
 		// check if this makes the inference variable instantiated:
 		TypeBinding typeBinding = bound.right;
 		if (bound.relation == ReductionResult.SAME && typeBinding.isProperType(true))
-			three.setInstantiation(typeBinding, bound.left, environment);
+			three.setInstantiation(typeBinding, variable, environment);
 		if (bound.right instanceof InferenceVariable) {
 			// for a dependency between two IVs make a note about the inverse bound.
 			// this should be needed to determine IV dependencies independent of direction.
 			// TODO: so far no test could be identified which actually needs it ...
-			InferenceVariable rightIV = (InferenceVariable) bound.right;
+			InferenceVariable rightIV = (InferenceVariable) bound.right.prototype();
 			three = this.boundsPerVariable.get(rightIV);
 			if (three == null)
 				this.boundsPerVariable.put(rightIV, (three = new ThreeSets()));
@@ -387,14 +390,14 @@ class BoundSet {
 	}
 
 	public boolean isInstantiated(InferenceVariable inferenceVariable) {
-		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
+		ThreeSets three = this.boundsPerVariable.get(inferenceVariable.prototype());
 		if (three != null)
 			return three.instantiation != null;
 		return false;
 	}
 
 	public TypeBinding getInstantiation(InferenceVariable inferenceVariable, LookupEnvironment environment) {
-		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
+		ThreeSets three = this.boundsPerVariable.get(inferenceVariable.prototype());
 		if (three != null) {
 			TypeBinding instantiation = three.instantiation;
 			if (environment != null && environment.globalOptions.isAnnotationBasedNullAnalysisEnabled 
@@ -531,7 +534,7 @@ class BoundSet {
 					if (ai instanceof WildcardBinding) {
 						WildcardBinding wildcardBinding = (WildcardBinding)ai;
 						TypeBinding t = wildcardBinding.bound;
-						ThreeSets three = this.boundsPerVariable.get(alpha);
+						ThreeSets three = this.boundsPerVariable.get(alpha.prototype());
 						if (three != null) {
 							Iterator<TypeBound> it;
 							if (three.sameBounds != null) {
@@ -617,7 +620,7 @@ class BoundSet {
 	private ConstraintTypeFormula combineSameSame(TypeBound boundS, TypeBound boundT) {
 		
 		// α = S and α = T imply ⟨S = T⟩
-		if (boundS.left == boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(boundS.left, boundT.left))
 			return ConstraintTypeFormula.create(boundS.right, boundT.right, ReductionResult.SAME, boundS.isSoft||boundT.isSoft);
 
 		// match against more shapes:
@@ -649,25 +652,25 @@ class BoundSet {
 		//  α = S and T <: α imply ⟨T <: S⟩
 		InferenceVariable alpha = boundS.left;
 		TypeBinding s = boundS.right;
-		if (alpha == boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(alpha,boundT.left))
 			return ConstraintTypeFormula.create(s, boundT.right, boundT.relation, boundT.isSoft||boundS.isSoft);
-		if (alpha == boundT.right) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(alpha, boundT.right))
 			return ConstraintTypeFormula.create(boundT.right, s, boundT.relation, boundT.isSoft||boundS.isSoft);
 
 		if (boundS.right instanceof InferenceVariable) {
 			// reverse:
 			alpha = (InferenceVariable) boundS.right;
 			s = boundS.left;
-			if (alpha == boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+			if (TypeBinding.equalsEquals(alpha, boundT.left))
 				return ConstraintTypeFormula.create(s, boundT.right, boundT.relation, boundT.isSoft||boundS.isSoft);
-			if (alpha == boundT.right) //$IDENTITY-COMPARISON$ InferenceVariable
+			if (TypeBinding.equalsEquals(alpha, boundT.right))
 				return ConstraintTypeFormula.create(boundT.right, s, boundT.relation, boundT.isSoft||boundS.isSoft);			
 		}
 		
 		//  α = U and S <: T imply ⟨S[α:=U] <: T[α:=U]⟩ 
 		TypeBinding u = boundS.right;
 		if (u.isProperType(true)) {
-			TypeBinding left = (alpha == boundT.left) ? u : boundT.left; //$IDENTITY-COMPARISON$ InferenceVariable
+			TypeBinding left = (TypeBinding.equalsEquals(alpha, boundT.left)) ? u : boundT.left;
 			TypeBinding right = boundT.right.substituteInferenceVariable(alpha, u);
 			return ConstraintTypeFormula.create(left, right, boundT.relation, boundT.isSoft||boundS.isSoft);
 		}
@@ -677,13 +680,13 @@ class BoundSet {
 	private ConstraintTypeFormula combineSuperAndSub(TypeBound boundS, TypeBound boundT) {
 		//  permutations of: S <: α and α <: T imply ⟨S <: T⟩
 		InferenceVariable alpha = boundS.left;
-		if (alpha == boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(alpha, boundT.left))
 			//  α >: S and α <: T imply ⟨S <: T⟩
 			return ConstraintTypeFormula.create(boundS.right, boundT.right, ReductionResult.SUBTYPE, boundT.isSoft||boundS.isSoft);
 		if (boundS.right instanceof InferenceVariable) {
 			// try reverse:
 			alpha = (InferenceVariable) boundS.right;
-			if (alpha == boundT.right) //$IDENTITY-COMPARISON$ InferenceVariable
+			if (TypeBinding.equalsEquals(alpha, boundT.right))
 				// S :> α and T <: α  imply ⟨S :> T⟩
 				return ConstraintTypeFormula.create(boundS.left, boundT.left, ReductionResult.SUPERTYPE, boundT.isSoft||boundS.isSoft);
 		}
@@ -692,10 +695,10 @@ class BoundSet {
 	
 	private ConstraintTypeFormula combineEqualSupers(TypeBound boundS, TypeBound boundT) {
 		//  more permutations of: S <: α and α <: T imply ⟨S <: T⟩
-		if (boundS.left == boundT.right) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(boundS.left, boundT.right))
 			// came in as: α REL S and T REL α imply ⟨T REL S⟩ 
 			return ConstraintTypeFormula.create(boundT.left, boundS.right, boundS.relation, boundT.isSoft||boundS.isSoft);
-		if (boundS.right == boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(boundS.right, boundT.left))
 			// came in as: S REL α and α REL T imply ⟨S REL T⟩ 
 			return ConstraintTypeFormula.create(boundS.left, boundT.right, boundS.relation, boundT.isSoft||boundS.isSoft);
 		return null;
@@ -710,7 +713,7 @@ class BoundSet {
 		 */
 		if (boundS.relation != ReductionResult.SUBTYPE || boundT.relation != ReductionResult.SUBTYPE)
 			return null;
-		if (boundS.left != boundT.left) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.notEquals(boundS.left, boundT.left))
 			return null;
 		TypeBinding[] supers = superTypesWithCommonGenericType(boundS.right, boundT.right);
 		if (supers != null)
@@ -776,13 +779,15 @@ class BoundSet {
 	 * Does this bound set define a direct dependency between the two given inference variables? 
 	 */
 	public boolean dependsOnResolutionOf(InferenceVariable alpha, InferenceVariable beta) {
+		alpha = alpha.prototype();
+		beta = beta.prototype();
 		Iterator<Map.Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captureIter = this.captures.entrySet().iterator();
 		boolean betaIsInCaptureLhs = false;
 		while (captureIter.hasNext()) { // TODO: optimization: consider separate index structure (by IV)
 			Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> entry = captureIter.next();
 			ParameterizedTypeBinding g = entry.getKey();
 			for (int i = 0; i < g.arguments.length; i++) {
-				if (g.arguments[i] == alpha) { //$IDENTITY-COMPARISON$ InferenceVariable
+				if (TypeBinding.equalsEquals(g.arguments[i], alpha)) {
 					// An inference variable α appearing on the left-hand side of a bound of the form G<..., α, ...> = capture(G<...>)
 					// depends on the resolution of every other inference variable mentioned in this bound (on both sides of the = sign).
 					ParameterizedTypeBinding captured = entry.getValue();
@@ -790,7 +795,7 @@ class BoundSet {
 						return true;
 					if (g.mentionsAny(new TypeBinding[]{beta}, i)) // exclude itself 
 						return true;
-				} else if (g.arguments[i] == beta) { //$IDENTITY-COMPARISON$ InferenceVariable
+				} else if (TypeBinding.equalsEquals(g.arguments[i], beta)) {
 					betaIsInCaptureLhs = true;
 				}
 			}
@@ -840,7 +845,7 @@ class BoundSet {
 	 * Answer all upper bounds for the given inference variable as defined by any bounds in this set. 
 	 */
 	public TypeBinding[] upperBounds(InferenceVariable variable, boolean onlyProper) {
-		ThreeSets three = this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable.prototype());
 		if (three == null || three.subBounds == null)
 			return Binding.NO_TYPES;
 		return three.upperBounds(onlyProper, variable);
@@ -853,7 +858,7 @@ class BoundSet {
 	 * Answer all lower bounds for the given inference variable as defined by any bounds in this set. 
 	 */
 	TypeBinding[] lowerBounds(InferenceVariable variable, boolean onlyProper) {
-		ThreeSets three = this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable.prototype());
 		if (three == null || three.superBounds == null)
 			return Binding.NO_TYPES;
 		return three.lowerBounds(onlyProper, variable);
@@ -881,7 +886,7 @@ class BoundSet {
 	}
 
 	public TypeBinding findWrapperTypeBound(InferenceVariable variable) {
-		ThreeSets three = this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable.prototype());
 		if (three == null) return null;
 		return three.findSingleWrapperType();
 	}
@@ -892,7 +897,7 @@ class BoundSet {
 		// i) B2 contains a bound of one of the forms α = S or S <: α, where S is a wildcard-parameterized type, or ...
 		if (targetType.isBaseType()) return false;
 		if (InferenceContext18.parameterizedWithWildcard(targetType) != null) return false;
-		ThreeSets ts = this.boundsPerVariable.get(alpha);
+		ThreeSets ts = this.boundsPerVariable.get(alpha.prototype());
 		if (ts.sameBounds != null) {
 			Iterator<TypeBound> bounds = ts.sameBounds.iterator();
 			while (bounds.hasNext()) {
@@ -933,7 +938,7 @@ class BoundSet {
 		//   where there exists no type of the form G<...> that is a supertype of S, but the raw type G is a supertype of S.
 		if (!targetType.isParameterizedType()) return false;
 		TypeBinding g = targetType.original();
-		ThreeSets ts = this.boundsPerVariable.get(alpha);
+		ThreeSets ts = this.boundsPerVariable.get(alpha.prototype());
 		Iterator<TypeBound> boundIterator;
 		if (ts.sameBounds != null) {
 			boundIterator = ts.sameBounds.iterator();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
index 4990211..00bf725 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
@@ -104,7 +104,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 				result.add(ConstraintTypeFormula.create(ePrime[i], e[j], SUBTYPE));
 		}				
 		for (int j = 0; j < n; j++)
-			inferenceContext.currentBounds.inThrows.add(e[j]);
+			inferenceContext.currentBounds.inThrows.add(e[j].prototype());
 		return result.toArray(new ConstraintFormula[result.size()]);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index b28f024..2198386 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -354,7 +354,7 @@ public class InferenceContext18 {
 			TypeBinding parameter = parameters[i];
 			for (int j = 0; j < thrownExceptions.length; j++) {
 				if (TypeBinding.equalsEquals(parameter, thrownExceptions[j])) {
-					this.currentBounds.inThrows.add(variables[i]);
+					this.currentBounds.inThrows.add(variables[i].prototype());
 					break;
 				}
 			}
@@ -949,7 +949,7 @@ public class InferenceContext18 {
 							} else {
 								TypeBinding[] upperBounds = tmpBoundSet.upperBounds(variable, true/*onlyProper*/);
 								// check exception bounds:
-								if (tmpBoundSet.inThrows.contains(variable) && tmpBoundSet.hasOnlyTrivialExceptionBounds(variable, upperBounds)) {
+								if (tmpBoundSet.inThrows.contains(variable.prototype()) && tmpBoundSet.hasOnlyTrivialExceptionBounds(variable, upperBounds)) {
 									TypeBinding runtimeException = this.scope.getType(TypeConstants.JAVA_LANG_RUNTIMEEXCEPTION, 3);
 									tmpBoundSet.addBound(new TypeBound(variable, runtimeException, ReductionResult.SAME), this.environment);
 								} else {
@@ -996,7 +996,7 @@ public class InferenceContext18 {
 						}
 						public TypeBinding substitute(TypeVariableBinding typeVariable) {
 							for (int j = 0; j < numVars; j++)
-								if (variables[j] == typeVariable) //$IDENTITY-COMPARISON$ InferenceVariable does not participate in type annotation encoding
+								if (TypeBinding.equalsEquals(variables[j], typeVariable))
 									return zs[j];
 							return typeVariable;
 						}
@@ -1028,7 +1028,7 @@ public class InferenceContext18 {
 							ParameterizedTypeBinding key = captureKeys.next();
 							int len = key.arguments.length;
 							for (int i = 0; i < len; i++) {
-								if (key.arguments[i] == variable) { //$IDENTITY-COMPARISON$
+								if (TypeBinding.equalsEquals(key.arguments[i], variable)) {
 									toRemove.add(key);
 									break;
 								}
@@ -1126,7 +1126,7 @@ public class InferenceContext18 {
 		if (!variableSet.add(currentVariable)) return true; // already present
 		for (int j = 0; j < this.inferenceVariables.length; j++) {
 			InferenceVariable nextVariable = this.inferenceVariables[j];
-			if (nextVariable == currentVariable) continue; //$IDENTITY-COMPARISON$ Inference variables
+			if (TypeBinding.equalsEquals(nextVariable, currentVariable)) continue;
 			if (boundSet.dependsOnResolutionOf(currentVariable, nextVariable))
 				if (!addDependencies(boundSet, variableSet, nextVariable, min))
 					return false; // abort traversal: no improvement
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
index e3ccbe3..7ee28c5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
@@ -22,6 +22,7 @@ public class InferenceVariable extends TypeVariableBinding {
 	InvocationSite site;
 	TypeBinding typeParameter;
 	long nullHints;
+	private InferenceVariable prototype;
 	
 	public InferenceVariable(TypeBinding typeParameter, int variableRank, InvocationSite site, LookupEnvironment environment, ReferenceBinding object) {
 		super(CharOperation.concat(typeParameter.shortReadableName(), Integer.toString(variableRank).toCharArray(), '#'), 
@@ -40,6 +41,20 @@ public class InferenceVariable extends TypeVariableBinding {
 			}
 		}
 		this.superclass = object;
+		this.prototype = this;
+	}
+	
+	@Override
+	public TypeBinding clone(TypeBinding enclosingType) {
+		InferenceVariable clone = new InferenceVariable(this.typeParameter, this.rank, this.site, this.environment, this.superclass);
+		clone.tagBits = this.tagBits;
+		clone.nullHints = this.nullHints;
+		clone.prototype = this;
+		return clone;
+	}
+
+	public InferenceVariable prototype() {
+		return this.prototype;
 	}
 
 	public char[] constantPoolName() {
@@ -62,7 +77,7 @@ public class InferenceVariable extends TypeVariableBinding {
 	}
 
 	TypeBinding substituteInferenceVariable(InferenceVariable var, TypeBinding substituteType) {
-		if (this == var) //$IDENTITY-COMPARISON$ InferenceVariable
+		if (TypeBinding.equalsEquals(this, var))
 			return substituteType;
 		return this;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java
index 59845e3..ad520b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java
@@ -65,7 +65,7 @@ public class TypeBound extends ReductionResult {
 	public boolean equals(Object obj) {
 		if (obj instanceof TypeBound) {
 			TypeBound other = (TypeBound) obj;
-			return this.left == other.left && TypeBinding.equalsEquals(this.right, other.right) && this.relation == other.relation; //$IDENTITY-COMPARISON$ InferenceVariable
+			return TypeBinding.equalsEquals(this.left, other.left) && TypeBinding.equalsEquals(this.right, other.right) && this.relation == other.relation;
 		}
 		return false;
 	}
commit 0d60094dd9c1c614c9f260f13ccbc556ab13b245
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Jul 14 19:12:37 2014 +0200

    Bug 438458 - [1.8][null] clean up handling of null type annotations wrt
    type variables
    - activate null-bound-checks also for unannotated type arguments

2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 4dfada6..4bddd9f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -19,6 +19,7 @@
  *								Bug 434570 - Generic type mismatch for parametrized class annotation attribute with inner class
  *								Bug 434600 - Incorrect null analysis error reporting on type parameters
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -657,7 +658,7 @@ protected void checkNullConstraints(Scope scope, TypeReference[] typeArguments)
 		TypeVariableBinding[] typeVariables = this.resolvedType.original().typeVariables();
 		for (int i = 0; i < typeArguments.length; i++) {
 			TypeReference arg = typeArguments[i];
-			if (arg.resolvedType != null && arg.resolvedType.hasNullTypeAnnotations())
+			if (arg.resolvedType != null)
 				arg.checkNullConstraints(scope, typeVariables, i);
 		}
 	}
commit 96aefcf71308a63ca037558f00b8c7e24e992667
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 3 23:14:40 2014 +0200

    Bug 438458 - [1.8][null] clean up handling of null type annotations wrt
    type variables
    - fix NPE reported in comment 5, plus more issues in this method
    - added missing implementation for RawTypeBinding

62	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
12	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
17	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 0d8f468..9e7381a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -5834,6 +5834,68 @@ public void testTypeVariable17a() {
 		getCompilerOptions(),
 		"");
 }
+// NPE reported in https://bugs.eclipse.org/bugs/show_bug.cgi?id=438458#c5
+public void testTypeVariable18() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"Test.java",
+			"import java.util.*;\n" + 
+			"import org.eclipse.jdt.annotation.*;\n" + 
+			"\n" + 
+			"interface Lib1 {\n" + 
+			"    <T extends Collection<?>> T constrainedTypeParameter(@NonNull T in);\n" + 
+			"}\n" + 
+			"\n" + 
+			"public class Test {\n" + 
+			"  @NonNull Collection<?> test4(Lib1 lib, @Nullable Collection<String> in) {\n" + 
+			"    return lib.constrainedTypeParameter(in);\n" + 
+			"  }\n" + 
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. WARNING in Test.java (at line 10)\n" + 
+		"	return lib.constrainedTypeParameter(in);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'Collection<String>\' needs unchecked conversion to conform to \'@NonNull Collection<?>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 10)\n" + 
+		"	return lib.constrainedTypeParameter(in);\n" + 
+		"	                                    ^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Collection<String>\' but this expression has type \'@Nullable Collection<String>\'\n" + 
+		"----------\n");
+}
+public void testTypeVariable18raw() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"Test.java",
+			"import java.util.*;\n" + 
+			"import org.eclipse.jdt.annotation.*;\n" + 
+			"\n" + 
+			"interface Lib1 {\n" + 
+			"    <T extends Collection<?>> T constrainedTypeParameter(@NonNull T in);\n" + 
+			"}\n" + 
+			"\n" + 
+			"public class Test {\n" +
+			"  @SuppressWarnings(\"rawtypes\")\n" + 
+			"  @NonNull Collection test4(Lib1 lib, @Nullable Collection in) {\n" + 
+			"    return lib.constrainedTypeParameter(in);\n" + 
+			"  }\n" + 
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. WARNING in Test.java (at line 11)\n" + 
+		"	return lib.constrainedTypeParameter(in);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type safety (type annotations): The expression of type \'Collection\' needs unchecked conversion to conform to \'@NonNull Collection\'\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 11)\n" + 
+		"	return lib.constrainedTypeParameter(in);\n" + 
+		"	                                    ^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull Collection\' but this expression has type \'@Nullable Collection\'\n" + 
+		"----------\n");
+}
 public void testBug434600() {
 	runConformTestWithLibs(
 		new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 54fd541..8aa7be9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -880,17 +880,22 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 			return this;
 		if (removeOnlyNullAnnotations && !hasNullTypeAnnotations())
 			return this;
-		ReferenceBinding unannotatedType = (ReferenceBinding) this.environment.getUnannotatedType(this);
 		if (removeOnlyNullAnnotations) {
+			ReferenceBinding unannotatedGenericType = (ReferenceBinding) this.environment.getUnannotatedType(this.type);
 			AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
-			TypeBinding[] newArguments = new TypeBinding[this.arguments.length];
-			for (int i = 0; i < this.arguments.length; i++) {
-				newArguments[i] = this.arguments[i].unannotated(removeOnlyNullAnnotations);
+			TypeBinding[] newArguments = null;
+			if (this.arguments != null) {
+				newArguments = new TypeBinding[this.arguments.length];
+				for (int i = 0; i < this.arguments.length; i++) {
+					newArguments[i] = this.arguments[i].unannotated(removeOnlyNullAnnotations);
+				}
 			}
-			ReferenceBinding newEnclosing = (ReferenceBinding)this.enclosingType.unannotated(removeOnlyNullAnnotations);
-			return this.environment.createParameterizedType(unannotatedType, newArguments, newEnclosing, newAnnotations);
+			ReferenceBinding newEnclosing = null;
+			if (this.enclosingType != null)
+				newEnclosing = (ReferenceBinding)this.enclosingType.unannotated(removeOnlyNullAnnotations);
+			return this.environment.createParameterizedType(unannotatedGenericType, newArguments, newEnclosing, newAnnotations);
 		}
-		return unannotatedType;
+		return this.environment.getUnannotatedType(this);
 	}
 
 	public int kind() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index 531664a..259b3c4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -13,6 +13,7 @@
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *								Bug 425783 - An internal error occurred during: "Requesting Java AST from selection". java.lang.StackOverflowError
+ *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -79,6 +80,22 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 		return new RawTypeBinding(this.actualType(), (ReferenceBinding) outerType, this.environment);
 	}
 
+	public TypeBinding unannotated(boolean removeOnlyNullAnnotations) {
+		if (!hasTypeAnnotations())
+			return this;
+		if (removeOnlyNullAnnotations && !hasNullTypeAnnotations())
+			return this;
+		if (removeOnlyNullAnnotations) {
+			ReferenceBinding unannotatedGenericType = (ReferenceBinding) this.environment.getUnannotatedType(this.genericType());
+			AnnotationBinding[] newAnnotations = this.environment.filterNullTypeAnnotations(this.typeAnnotations);
+			ReferenceBinding newEnclosing = null;
+			if (this.enclosingType() != null)
+				newEnclosing = (ReferenceBinding)this.enclosingType().unannotated(removeOnlyNullAnnotations);
+			return this.environment.createRawType(unannotatedGenericType, newEnclosing, newAnnotations);
+		}
+		return this.environment.getUnannotatedType(this);
+	}
+
 	/**
 	 * @see org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding#createParameterizedMethod(org.eclipse.jdt.internal.compiler.lookup.MethodBinding)
 	 */
