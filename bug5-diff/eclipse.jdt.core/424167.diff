commit 57e8dd41219d846363c918d62edb5007994c5c79
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Mon Dec 23 19:19:54 2013 +0100

    Bug 424167 - [1.8] Fully integrate type inference with overload
    resolution

97	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
0	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
134	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
6	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
7	14	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
16	7	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
52	101	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
30	23	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
26	20	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
4	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
4	62	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
18	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
9	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
30	38	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
0	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PolyExpression.java
26	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
4	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
20	29	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
322	94	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
125	49	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
138	27	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
6	3	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index fbc92a8..34da160 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -50006,7 +50006,7 @@ public void test1439() {
 			"	       ^^^^\n" + 
 			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
 			"----------\n"
-			: // Line 7: in 1.8 <T> is infered to <null> => not a checked exception 
+			: // 1.8 infers T in this((List) null, null) to RuntimeException, hence no error here (2. above)
 			"----------\n" + 
 			"1. WARNING in X.java (at line 7)\n" + 
 			"	this((List) null, null);\n" + 
@@ -50249,7 +50249,6 @@ public void test1444() {
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=263215 - variation
-// FIXME javac8 doesn't find the error
 public void test1445() {
 	this.runNegativeTest(
 			new String[] {
@@ -50276,8 +50275,9 @@ public void test1445() {
 				"		new <IOException> X(l){}. <IOException> foo(l);\n" + 
 				"	}\n" + 
 				"\n" + 
-				"}\n",//-----------------------------------------------------------------------
+				"}\n",
 			},
+			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
 			"----------\n" + 
 			"1. WARNING in X.java (at line 8)\n" + 
 			"	static void bar(List l) {\n" + 
@@ -50378,7 +50378,100 @@ public void test1445() {
 			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
 			"	                                            ^\n" + 
 			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
-			"----------\n");
+			"----------\n"
+			: // 1.8 infers type parameters in throws clauses to RuntimeException, hence no errors
+			"----------\n" + 
+			"1. WARNING in X.java (at line 8)\n" + 
+			"	static void bar(List l) {\n" + 
+			"	                ^^^^\n" + 
+			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 9)\n" + 
+			"	new X(l).foo(l);\n" + 
+			"	^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 9)\n" + 
+			"	new X(l).foo(l);\n" + 
+			"	^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
+			"----------\n" + 
+			"4. WARNING in X.java (at line 9)\n" + 
+			"	new X(l).foo(l);\n" + 
+			"	      ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" + 
+			"----------\n" + 
+			"5. WARNING in X.java (at line 9)\n" + 
+			"	new X(l).foo(l);\n" + 
+			"	             ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" + 
+			"----------\n" + 
+			"6. WARNING in X.java (at line 11)\n" + 
+			"	static void baz(List l) throws IOException {\n" + 
+			"	                ^^^^\n" + 
+			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
+			"----------\n" + 
+			"7. WARNING in X.java (at line 12)\n" + 
+			"	new <IOException> X(l). <IOException> foo(l);\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
+			"----------\n" + 
+			"8. WARNING in X.java (at line 12)\n" + 
+			"	new <IOException> X(l). <IOException> foo(l);\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
+			"----------\n" + 
+			"9. WARNING in X.java (at line 12)\n" + 
+			"	new <IOException> X(l). <IOException> foo(l);\n" + 
+			"	                    ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
+			"----------\n" + 
+			"10. WARNING in X.java (at line 12)\n" + 
+			"	new <IOException> X(l). <IOException> foo(l);\n" + 
+			"	                                          ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
+			"----------\n" + 
+			"11. WARNING in X.java (at line 15)\n" + 
+			"	X(List l, long l2) throws IOException {\n" + 
+			"	  ^^^^\n" + 
+			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
+			"----------\n" + 
+			"12. WARNING in X.java (at line 16)\n" + 
+			"	<IOException> this(l);\n" + 
+			"	              ^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
+			"----------\n" + 
+			"13. WARNING in X.java (at line 16)\n" + 
+			"	<IOException> this(l);\n" + 
+			"	                   ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
+			"----------\n" + 
+			"14. WARNING in X.java (at line 19)\n" + 
+			"	static void baz2(List l) throws IOException {\n" + 
+			"	                 ^^^^\n" + 
+			"List is a raw type. References to generic type List<E> should be parameterized\n" + 
+			"----------\n" + 
+			"15. WARNING in X.java (at line 20)\n" + 
+			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" + 
+			"----------\n" + 
+			"16. WARNING in X.java (at line 20)\n" + 
+			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" + 
+			"----------\n" + 
+			"17. WARNING in X.java (at line 20)\n" + 
+			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
+			"	                    ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
+			"----------\n" + 
+			"18. WARNING in X.java (at line 20)\n" + 
+			"	new <IOException> X(l){}. <IOException> foo(l);\n" + 
+			"	                                            ^\n" + 
+			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" + 
+			"----------\n"
+			));
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=202393
 public void test1446() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
index c834281..9b556a8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
@@ -1131,7 +1131,6 @@ public void test0025() {
 		"----------\n");
 }
 // Test various scenarios.
-// FIXME(stephan): javac8 does not report the ambiguity, re-check after integrating inference with overload resolution
 public void test0026() {
 	this.runNegativeTest(
 		new String[] {
@@ -1181,11 +1180,6 @@ public void test0026() {
 			"	X<Object> x4 = new X<>(1).idem();\n" + 
 			"	               ^^^^^^^^^^^^^^^^^\n" + 
 			"Type mismatch: cannot convert from X<Integer> to X<Object>\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 15)\n" + 
-			"	int i = m(new X<>(\"\"));\n" + 
-			"	          ^^^^^^^^^^^\n" + 
-			"The constructor X<String>(String) is ambiguous\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=344655
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index d5dcab5..4bd6b2e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -19,7 +19,7 @@ import junit.framework.Test;
 public class GenericsRegressionTest_1_8 extends AbstractRegressionTest {
 
 static {
-//	TESTS_NAMES = new String[] { "testBug424038" };
+//	TESTS_NAMES = new String[] { "testBug414631" };
 //	TESTS_NUMBERS = new int[] { 40, 41, 43, 45, 63, 64 };
 //	TESTS_RANGE = new int[] { 11, -1 };
 }
@@ -230,4 +230,137 @@ public void testBug423504() {
 			"}\n"
 		});
 }
+// https://bugs.eclipse.org/420525 - [1.8] [compiler] Incorrect error "The type Integer does not define sum(Object, Object) that is applicable here"
+public void _testBug420525() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.ArrayList;\n" + 
+			"import java.util.List;\n" + 
+			"import java.util.concurrent.CompletableFuture;\n" + 
+			"import java.util.concurrent.ExecutionException;\n" +
+			"public class X {\n" +
+			"	void test(List<CompletableFuture<Integer>> futures) {\n" + 
+			"		CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[]{})).thenApplyAsync( (Void v) -> {\n" + 
+			"			Integer finalResult = futures.stream().map( (CompletableFuture<Integer> f) -> {\n" + 
+			"				try {\n" + 
+			"					return f.get();\n" + 
+			"				} catch (InterruptedException | ExecutionException e) {\n" + 
+			"					return 0;\n" + 
+			"				}\n" + 
+			"			}).reduce(0, Integer::sum);\n" + 
+			"			\n" + 
+			"			log(\"final result is \" + finalResult);\n" + 
+			"			if (finalResult != 50){\n" + 
+			"				throw new RuntimeException(\"FAILED\");\n" + 
+			"			} else{\n" + 
+			"				log(\"SUCCESS\");\n" + 
+			"			}\n" + 
+			"			\n" + 
+			"			return null;\n" + 
+			"		});\n" + 
+			"\n" + 
+			"	}\n" +
+			"	void log(String msg) {}\n" +
+			"}\n"
+		});
+}
+
+public void testBug424415() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"\n" + 
+			"import java.util.ArrayList;\n" + 
+			"import java.util.Collection;\n" + 
+			"\n" + 
+			"interface Functional<T> {\n" + 
+			"   T apply();\n" + 
+			"}\n" + 
+			"\n" + 
+			"class X {\n" + 
+			"    void foo(Object o) { }\n" + 
+			"\n" + 
+			"	<Q extends Collection<?>> Q goo(Functional<Q> s) {\n" + 
+			"		return null;\n" + 
+			"	} \n" + 
+			"\n" + 
+			"    void test() {\n" + 
+			"        foo(goo(ArrayList<String>::new));\n" + 
+			"    }\n" + 
+			"}\n"
+		});
+}
+
+public void _testBug424403() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"interface Functional { int foo(); }\n" + 
+			"\n" + 
+			"class X {\n" + 
+			"    static int bar() {\n" + 
+			"        return -1;\n" + 
+			"    }\n" + 
+			"    static <T> T consume(T t) { return null; }\n" + 
+			"\n" + 
+			"    public static void main(String[] args) {\n" + 
+			"    	Functional f = consume(X::bar);\n" + 
+			"    }  \n" + 
+			"}\n"
+		});
+}
+public void testBug401850a() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.List;\n" + 
+			"import java.util.ArrayList;\n" + 
+			"public class X<T> {\n" + 
+			"   X(T t) {}\n" + 
+			"   X(String s) {}\n" + 
+			"   int m(X<String> xs) { return 0; }\n" + 
+			"   int i = m(new X<>(\"\"));\n" + 
+			"}\n"
+		});
+}
+public void testBug401850b() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.List;\n" + 
+			"import java.util.ArrayList;\n" + 
+			"public class X<T> {\n" + 
+			"   X(T t) {}\n" + 
+			"   X(String s) {}\n" + 
+			"   int m(X<String> xs) { return 0; }\n" + 
+			"   int i = m(new X<String>(\"\"));\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	int i = m(new X<String>(\"\"));\n" + 
+		"	          ^^^^^^^^^^^^^^^^^\n" + 
+		"The constructor X<String>(String) is ambiguous\n" + 
+		"----------\n");
+}
+// rejecting seems to be the spec'd answer (0.7.0), but I'd expect acceptance
+public void _testBug424075() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n"	+
+			"import java.util.function.*;\n"	+
+			"public class X {\n" +
+			"    public static void main(String[] args) {\n" + 
+			"        Consumer<Object> c = null;\n" + 
+			"        Arrays.asList(pred(), c);\n" + 
+			"    }\n" + 
+			"\n" + 
+			"    static <T> Predicate<T> pred() {\n" + 
+			"        return null;\n" + 
+			"    }\n" +
+			"}\n"
+		});
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
index c0ae375..47e24d6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
@@ -25,7 +25,7 @@ import junit.framework.Test;
 public class LambdaExpressionsTest extends AbstractRegressionTest {
 
 static {
-//	TESTS_NAMES = new String[] { "testReferenceExpressionInference3a"};
+//	TESTS_NAMES = new String[] { "testReferenceExpressionInference1"};
 //	TESTS_NUMBERS = new int[] { 50 };
 //	TESTS_RANGE = new int[] { 11, -1 };
 }
@@ -1958,6 +1958,11 @@ public void testReferenceExpressionInference3b() {
 		"	I<X,String> x2s = compose(this::bar, this::i2s);\n" + 
 		"	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 		"Type mismatch: cannot convert from I<Object,Object> to I<X,String>\n" +
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	I<X,String> x2s = compose(this::bar, this::i2s);\n" + 
+		"	                                     ^^^^^^^^^\n" + 
+		"The type X does not define i2s(Object) that is applicable here\n" + 
 		"----------\n");
 }
 public void testLambdaInference1() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index db7a060..c32f9c0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -5746,13 +5746,11 @@ public void test401939a() {
 				"----------\n" + 
 				"2. ERROR in X.java (at line 8)\n" + 
 				"	foo(()->{ if (1 == 2) throw new RuntimeException(); });\n" + 
-				"	    ^^^^\n" + 
-				"This method must return a result of type int\n" + 
-				"----------\n" + 
-				"3. WARNING in X.java (at line 8)\n" + 
-				"	foo(()->{ if (1 == 2) throw new RuntimeException(); });\n" + 
-				"	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Dead code\n" + 
+				"	^^^\n" + 
+				"The method foo(I) in the type X is not applicable for the arguments (() -> {\n" + 
+				"  if ((1 == 2))\n" + 
+				"      throw new RuntimeException();\n" + 
+				"})\n" + 
 				"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=401939, [1.8][compiler] Incorrect shape analysis leads to method resolution failure .
@@ -7804,12 +7802,7 @@ public void test423129b() {
 					"}\n"
 			},
 			"----------\n" + 
-			"1. ERROR in X.java (at line 8)\n" + 
-			"	Collections.sort(new ArrayList<X>(Arrays.asList(new X(), new X(), new X())),\n" + 
-			"	            ^^^^\n" + 
-			"The method sort(List<T>, Comparator<? super T>) in the type Collections is not applicable for the arguments (ArrayList<X>, Comparator<X>)\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 12)\n" + 
+			"1. ERROR in X.java (at line 12)\n" + 
 			"	}\n" + 
 			"	^\n" + 
 			"Syntax error on token \"}\", delete this token\n" + 
@@ -7911,4 +7904,4 @@ public void test424444() throws Exception {
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
 }
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
index c7dcb47..5b800cb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/OverloadResolutionTest8.java
@@ -124,6 +124,7 @@ public void test003() {
 			"goo(J)\n" +
 			"goo(J)");
 }
+// FAIL cannot detect errors against 2nd and 3rd lambda, because of enclosingScopesHaveErrors()
 public void test004() {
 	this.runNegativeTest(
 			new String[] {
@@ -151,21 +152,29 @@ public void test004() {
 				"	}\n" +
 				"}\n",
 			},
+			// none of the lambdas is compatible because none is value-compatible, whereas foo() needs to return int.
 			"----------\n" + 
 			"1. ERROR in X.java (at line 11)\n" + 
 			"	goo(()-> { \n" + 
-			"	    ^^^^\n" + 
-			"This method must return a result of type int\n" + 
+			"	^^^\n" + 
+			"The method goo(J) in the type X is not applicable for the arguments (() -> {\n" + 
+			"  boolean y = true;\n" + 
+			"  while (y)    ;\n" + 
+			"})\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 15)\n" + 
 			"	goo(()-> { \n" + 
-			"	    ^^^^\n" + 
-			"This method must return a result of type int\n" + 
+			"	^^^\n" + 
+			"The method goo(J) in the type X is not applicable for the arguments (() -> {\n" + 
+			"  while (x)    ;\n" + 
+			"})\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 18)\n" + 
 			"	goo(()-> { \n" + 
-			"	    ^^^^\n" + 
-			"This method must return a result of type int\n" + 
+			"	^^^\n" + 
+			"The method goo(J) in the type X is not applicable for the arguments (() -> {\n" + 
+			"  while (f)    ;\n" + 
+			"})\n" + 
 			"----------\n");
 }
 public void test005() {
@@ -2131,4 +2140,4 @@ public void test401850() {
 			},
 			"foo(X<String>)");
 }
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index b0ff8d8..55996a5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -630,18 +630,16 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	}
 
 	/**
-	 * After a first round of method lookup has produces 'methodBinding' but when poly expressions have been seen as arguments,
+	 * After method lookup has produced 'methodBinding' but when poly expressions have been seen as arguments,
 	 * inspect the arguments to trigger another round of resolving with improved target types from the methods parameters.
-	 * If this resolving produces better types for any arguments, update the 'argumentTypes' array in-place and 
-	 * signal by returning null that the outer should perform another round of method lookup.
+	 * If this resolving produces better types for any arguments, update the 'argumentTypes' array in-place as an
+	 * intended side effect that will feed better type information in checkInvocationArguments() and others.
 	 * @param invocation the outer invocation which is being resolved
-	 * @param scope scope
-	 * @param methodBinding the candidate method produced by the first round of lookup
+	 * @param methodBinding the method produced by lookup (possibly involving type inference).
 	 * @param argumentTypes the argument types as collected from first resolving the invocation arguments and as used for
-	 * 	the first round of method lookup.
-	 * @return true signals that the caller should try another round of method lookup
+	 * 	the method lookup.
 	 */
-	public static boolean resolvePolyExpressionArguments(Invocation invocation, BlockScope scope, MethodBinding methodBinding, TypeBinding[] argumentTypes) {
+	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes) {
 		int problemReason = 0;
 		MethodBinding candidateMethod;
 		if (methodBinding.isValidBinding()) {
@@ -652,112 +650,65 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		} else {
 			candidateMethod = null;
 		}
-		boolean hasUpdatedInner = false;
 		if (candidateMethod != null) {
 			boolean variableArity = candidateMethod.isVarargs();
+			InferenceContext18 infCtx = null;
+			if (candidateMethod instanceof ParameterizedGenericMethodBinding) {
+				infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) candidateMethod);
+				if (infCtx != null) {
+					if (!infCtx.hasFinished)
+						return; // not yet ready for pushing type information down to arguments
+					variableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?
+				}
+			}
+			
 			final TypeBinding[] parameters = candidateMethod.parameters;
-			final int parametersLength = parameters.length;
-			Expression [] arguments = invocation.arguments();
+			Expression[] innerArguments = invocation.arguments();
+			Expression [] arguments = innerArguments;
 			for (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {
 				Expression argument = arguments[i];
-				TypeBinding parameterType = i < parametersLength ? parameters[i] : variableArity ? parameters[parametersLength - 1] : null;
 				TypeBinding updatedArgumentType = null;
+				TypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity); 
 
-				if (variableArity && i >= parametersLength - 1)
-					argument.tagAsEllipsisArgument();
-				updatedArgumentType = updateExpression(scope, argument, argumentTypes[i], parameterType, invocation.hasInferenceFinished());
-				if (updatedArgumentType == POLY_ERROR) //$IDENTITY-COMPARISON$
+				if (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())
 					continue; // don't update if inner poly has errors
-				if (problemReason != ProblemReasons.Ambiguous 	// preserve this error
-						&& updatedArgumentType != null					// do we have a relevant update? ...
-						&& !(updatedArgumentType instanceof PolyTypeBinding)
-						&& TypeBinding.notEquals(updatedArgumentType, argumentTypes[i]))
-				{
-					// update the argumentTypes array (supposed to be owned by the calling method)
-					// in order to give better information into a second round of method lookup:
-					argumentTypes[i] = updatedArgumentType;
-					hasUpdatedInner = true;
-				}
-			}
-		}
-		return hasUpdatedInner;
-	}
 
-	// special instance used to signal that an inner poly expression had errors, to cancel another method lookup of the outer based on bogus type information
-	static final TypeBinding POLY_ERROR = new PolyTypeBinding(null);
-
-	private static TypeBinding updateExpression(BlockScope scope, Expression expression, TypeBinding argumentType, TypeBinding parameterType, boolean inferenceFinished) {
-		TypeBinding updatedArgumentType = null;
-		boolean isPolyAlloc = false;
-		if (expression instanceof Invocation) {
-			Invocation invocation = (Invocation)expression;
-			updatedArgumentType = updateInvocation(invocation, parameterType);
-			if (updatedArgumentType == null && invocation.inferenceKind() != 0 && !invocation.hasInferenceFinished())
-				isPolyAlloc = true;
-		} else if (expression instanceof ConditionalExpression) {
-			updatedArgumentType = updateConditionExpresion(scope, ((ConditionalExpression) expression), argumentType, parameterType, inferenceFinished);
-		}
-
-		if (updatedArgumentType == null && (isPolyAlloc || argumentType instanceof PolyTypeBinding)) {
-			updatedArgumentType = updateOtherPolyExpression(scope, expression, parameterType, inferenceFinished);
-		}
-		return updatedArgumentType;
-	}
-
-	private static TypeBinding updateConditionExpresion(BlockScope scope, ConditionalExpression expression, TypeBinding currentType, TypeBinding targetType, boolean inferenceFinished) {
-		TypeBinding type = updateExpression(scope, expression.valueIfTrue, currentType, targetType, inferenceFinished);
-		boolean errorSeen = (type == POLY_ERROR); //$IDENTITY-COMPARISON$
-		boolean incompatibilitySeen = !errorSeen && type != null && !type.isCompatibleWith(targetType);
-		type = updateExpression(scope, expression.valueIfFalse, currentType, targetType, inferenceFinished);
-		if (errorSeen || type == POLY_ERROR) //$IDENTITY-COMPARISON$
-			return POLY_ERROR;
-		if (incompatibilitySeen || type != null && !type.isCompatibleWith(targetType))
-			return null;
-		return expression.resolvedType = targetType;
-	}
+				if (argument instanceof Invocation) {
+					Invocation innerInvocation = (Invocation)argument;
+					MethodBinding binding = innerInvocation.binding();
+					if (binding instanceof ParameterizedGenericMethodBinding) {
+						ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;
+						InferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);
+						if (innerContext != null && !innerContext.hasFinished) {							
+							argument.setExpectedType(parameterType);
+							TypeBinding[] innerArgumentTypes = null;
+							if (innerArguments != null) {
+								innerArgumentTypes = new TypeBinding[innerArguments.length];
+								for (int j = 0; j < innerArguments.length; j++)
+									innerArgumentTypes[i] = innerArguments[i].resolvedType;
+							}
+							MethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, innerArgumentTypes, parameterizedMethod);
+							innerInvocation.updateBindings(improvedBinding);
+						}
+						continue; // otherwise these have been dealt with during inner method lookup
+					}
+				}
 
-	private static TypeBinding updateInvocation(Invocation innerInvocation, TypeBinding targetType) {
-		boolean invocationFinished = false;
-		MethodBinding updatedMethod = innerInvocation.binding();
-		if (innerInvocation.hasInferenceFinished() && updatedMethod != null) {
-			// outer invocation already included invocation type inference for this inner
-			invocationFinished = true;
-		} else {
-			// Inner Inference?
-			InferenceContext18 infCtx18 = innerInvocation.inferenceContext();
-			if (infCtx18 != null) {
-				// Previous time around we only performed Invocation Applicability Inference, do the rest now:
-				updatedMethod = infCtx18.getInvocationTypeInferenceSolution(innerInvocation, targetType);
-				if (updatedMethod != null) {
-					innerInvocation.updateBindings(updatedMethod);
-					invocationFinished = true;
+				if (argument.isPolyExpression()) {
+					// poly expressions in an invocation context need to be resolved now:
+					updatedArgumentType = argument.checkAgainstFinalTargetType(parameterType);
+
+					if (problemReason == ProblemReasons.NoError // preserve errors
+							&& updatedArgumentType != null					// do we have a relevant update? ...
+							&& !(updatedArgumentType instanceof PolyTypeBinding))
+					{
+						// update the argumentTypes array (supposed to be owned by the calling method)
+						// in order to give better information for subsequent checks
+						argumentTypes[i] = updatedArgumentType;
+					}
 				}
 			}
 		}
-		if (invocationFinished) {
-			if (updatedMethod.isConstructor())
-				return updatedMethod.declaringClass;
-			else
-				return updatedMethod.returnType;
-		}
-		return null;
-	}
-
-	protected static TypeBinding updateOtherPolyExpression(BlockScope scope, Expression expression, TypeBinding parameterType, boolean inferenceFinished) {
-		TypeBinding updatedArgumentType;
-		expression.setExpressionContext(parameterType != null ? ExpressionContext.INVOCATION_CONTEXT: ExpressionContext.ASSIGNMENT_CONTEXT); // force the errors to surface.
-		// perform the level of resolving suitable for the state of affairs at the enclosing context:
-		if (inferenceFinished) {
-			expression.setExpectedType(parameterType);
-			updatedArgumentType = expression.resolveType(scope);
-		} else {
-			updatedArgumentType = expression.resolveTentatively(scope, parameterType);
-		}
-		if (updatedArgumentType == null || !updatedArgumentType.isValidBinding())
-			return POLY_ERROR;
-		if (expression instanceof LambdaExpression && ((LambdaExpression) expression).hasErrors())
-			return POLY_ERROR;
-		return updatedArgumentType;
 	}
 
 	public static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index d7c1fcd..bb705e3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -45,6 +45,7 @@ import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 public class AllocationExpression extends Expression implements Invocation {
 
@@ -60,8 +61,9 @@ public class AllocationExpression extends Expression implements Invocation {
 
 	public FakedTrackingVariable closeTracker;	// when allocation a Closeable store a pre-liminary tracking variable here
 	private ExpressionContext expressionContext = VANILLA_CONTEXT;
-	private int inferenceKind;
-	private InferenceContext18 inferenceContext;
+
+	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
+	private SimpleLookupTable/*<PGMB,IC18>*/ inferenceContexts;
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	// check captured variables are initialized in current context (26134)
@@ -451,7 +453,6 @@ public TypeBinding resolveType(BlockScope scope) {
 		// in this preliminary mode use the raw receiver type for constructor lookup, to avoid spurious type errors
 		receiverType = (ReferenceBinding) receiverType.original();
 		receiverType = scope.environment().createRawType(receiverType, receiverType.enclosingType());
-		this.inferenceKind = 1; // inference needed!
 	}
 	
 	this.binding = findConstructorBinding(scope, this, receiverType, argumentTypes, polyExpressionSeen);
@@ -487,6 +488,8 @@ public TypeBinding resolveType(BlockScope scope) {
 		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
+	if (diamondNeedsDeferring)
+		return new PolyTypeBinding(this);
 	return allocationType;
 }
 
@@ -542,7 +545,6 @@ public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType,
 	}
 	TypeBinding [] inferredTypes;
 	int previousBits = this.type.bits;
-	int previousInferenceKind = this.inferenceKind;
 	try {
 		// checking for redundant type parameters must fake a diamond, 
 		// so we infer the same results as we would get with a diamond in source code:
@@ -551,7 +553,6 @@ public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType,
 	} finally {
 		// reset effects of inference
 		this.type.bits = previousBits;
-		this.inferenceKind = previousInferenceKind;
 	}
 	if (inferredTypes == null) {
 		return;
@@ -633,31 +634,37 @@ public MethodBinding binding() {
 public Expression[] arguments() {
 	return this.arguments;
 }
-public int inferenceKind() {
-	return (this.inferenceKind & InferenceContext18.INFERENCE_KIND_MASK);
-}
-public void setInferenceKind(int checkKind) {
-	this.inferenceKind = checkKind;
-}
-public void markInferenceFinished() {
-	this.inferenceKind |= InferenceContext18.CHECK_FINISHED;
-}
-public boolean hasInferenceFinished() {
-	return this.inferenceKind == 0 // only relevant if inference has been started
-			|| (this.inferenceKind & InferenceContext18.CHECK_FINISHED) != 0;
-}
-public TypeBinding updateBindings(MethodBinding updatedBinding) {
+
+public boolean updateBindings(MethodBinding updatedBinding) {
+	if (this.binding == updatedBinding)
+		return false;
+	if (this.inferenceContexts != null) {
+		InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
+		if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
+			this.inferenceContexts.put(updatedBinding, ctx);
+			ctx.hasFinished = true;
+		}
+	}
 	this.binding = updatedBinding;
-	return this.resolvedType = updatedBinding.declaringClass;
+	this.resolvedType = updatedBinding.declaringClass;
+	return true;
 }
-public InferenceContext18 inferenceContext() {
-	return this.inferenceContext;
+public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
+	if (this.inferenceContexts == null)
+		this.inferenceContexts = new SimpleLookupTable();
+	this.inferenceContexts.put(method, infCtx18);
 }
+public InferenceContext18 getInferenceContext(ParameterizedGenericMethodBinding method) {
+	if (this.inferenceContexts == null)
+		return null;
+	return (InferenceContext18) this.inferenceContexts.get(method);
+}
+
 //-- interface InvocationSite: --
 public ExpressionContext getExpressionContext() {
 	return this.expressionContext;
 }
 public InferenceContext18 freshInferenceContext(Scope scope) {
-	return this.inferenceContext = new InferenceContext18(scope, this.arguments, this);
+	return new InferenceContext18(scope, this.arguments, this);
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 78a8925..496b19e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -650,6 +650,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		this.expressionContext = context;
 	}
 	
+	public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType) {
+		// in 1.8 if treated as a poly expression:
+		this.valueIfTrue.checkAgainstFinalTargetType(targetType);
+		this.valueIfFalse.checkAgainstFinalTargetType(targetType);
+		this.resolvedType = targetType;
+		return targetType;
+	}
+	
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
 		return this.valueIfTrue.isPertinentToApplicability(targetType, method) 
 				&& this.valueIfFalse.isPertinentToApplicability(targetType, method);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 48685a4..679709d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -37,6 +37,7 @@ import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -47,6 +48,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 public class ExplicitConstructorCall extends Statement implements Invocation, ExpressionContext {
 
@@ -66,8 +68,9 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 
 	// TODO Remove once DOMParser is activated
 	public int typeArgumentsSourceStart;
-	private InferenceContext18 inferenceContext;
-	private int inferenceKind;
+
+	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
+	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
 
 	public ExplicitConstructorCall(int accessMode) {
 		this.accessMode = accessMode;
@@ -492,29 +495,32 @@ public class ExplicitConstructorCall extends Statement implements Invocation, Ex
 	public Expression[] arguments() {
 		return this.arguments;
 	}
-	public InferenceContext18 inferenceContext() {
-		return this.inferenceContext;
-	}
-	public int inferenceKind() {
-		return (this.inferenceKind & InferenceContext18.INFERENCE_KIND_MASK);
-	}
-	public void setInferenceKind(int checkKind) {
-		this.inferenceKind = checkKind;
-	}
-	public void markInferenceFinished() {
-		this.inferenceKind |= InferenceContext18.CHECK_FINISHED;
+	public boolean updateBindings(MethodBinding updatedBinding) {
+		if (this.binding == updatedBinding)
+			return false;
+		if (this.inferenceContexts != null) {
+			InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
+			if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
+				this.inferenceContexts.put(updatedBinding, ctx);
+				ctx.hasFinished = true;
+			}
+		}
+		this.binding = updatedBinding;
+		return true;
 	}
-	public boolean hasInferenceFinished() {
-		return this.inferenceKind == 0 // only relevant if inference has been started
-				|| (this.inferenceKind & InferenceContext18.CHECK_FINISHED) != 0;
+	public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
+		if (this.inferenceContexts == null)
+			this.inferenceContexts = new SimpleLookupTable();
+		this.inferenceContexts.put(method, infCtx18);
 	}
-	public TypeBinding updateBindings(MethodBinding updatedBinding) {
-		this.binding = updatedBinding;
-		return TypeBinding.VOID; // not an expression
+	public InferenceContext18 getInferenceContext(ParameterizedGenericMethodBinding method) {
+		if (this.inferenceContexts == null)
+			return null;
+		return (InferenceContext18) this.inferenceContexts.get(method);
 	}
 
 	// -- interface InvocationSite: --
 	public InferenceContext18 freshInferenceContext(Scope scope) {
-		return this.inferenceContext = new InferenceContext18(scope, this.arguments, this);
+		return new InferenceContext18(scope, this.arguments, this);
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 8504f80..bc99538 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -953,7 +953,8 @@ public Constant optimizedBooleanConstant() {
 public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
 	return true;
 }
-// call this before resolving an expression for the second time. TODO: implement in more subclasses, or find a different strategy.
+// call this before resolving an expression for the second time.
+// FIXME: we should find a better strategy, see LambdaExpressionsTest.testLambdaInference1() f. for tests that currently need this.
 void unresolve() {
 	this.resolvedType = null;
 }
@@ -1058,21 +1059,12 @@ public TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTy
 }
 
 /**
- * If we might still be in the context of an unfinished outer inference, use this method to
- * tentatively resolve this expression without leaving any undesired traces, in case we will
- * come back with a better target type later.
- */
-public TypeBinding resolveTentatively(BlockScope scope, TypeBinding targetType) {
-	return resolveType(scope); // default is to do full resolution in just this one step
-}
-
-/**
  * Once outer contexts have finalized the target type for this expression,
  * perform any checks that might have been delayed previously.
  * @param targetType the final target type (aka expectedType) for this expression.
  */
-public void checkAgainstFinalTargetType(TypeBinding targetType) {
-	// nop, subclasses may choose to do real stuff here
+public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType) {
+	return targetType; // subclasses may choose to do real stuff here
 }
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index f2374ef..6cc092e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -36,10 +36,9 @@ import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor;
 
-public abstract class FunctionalExpression extends Expression implements PolyExpression {
+public abstract class FunctionalExpression extends Expression {
 	
 	TypeBinding expectedType;
-	boolean expectedIsFinalTargetType = false; // flip to true once the expression context has determined the final target type for this expression
 	public MethodBinding descriptor;
 	public MethodBinding binding;                 // Code generation binding. May include synthetics. See getMethodBinding()
 	protected MethodBinding actualMethodBinding;  // void of synthetics.
@@ -51,7 +50,6 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 	public BlockScope enclosingScope;
 	protected boolean ellipsisArgument;
 	protected static IErrorHandlingPolicy silentErrorHandlingPolicy = DefaultErrorHandlingPolicies.ignoreAllProblems();
-	protected boolean hasInferenceFinished = false;
 
 	public FunctionalExpression(CompilationResult compilationResult) {
 		this.compilationResult = compilationResult;
@@ -70,10 +68,7 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 		return null;
 	}
 	public void setExpectedType(TypeBinding expectedType) {
-		if (expectedType == null)
-			this.expectedType = null; // for reset
-		else
-			this.expectedType = this.ellipsisArgument ? ((ArrayBinding) expectedType).elementsType() : expectedType;
+		this.expectedType = this.ellipsisArgument ? ((ArrayBinding) expectedType).elementsType() : expectedType;
 	}
 	
 	public void setExpressionContext(ExpressionContext context) {
@@ -89,14 +84,6 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 	public boolean isPolyExpression() {
 		return true; // always as per introduction of part D, JSR 335
 	}
-	
-	public void markInferenceFinished() {
-		this.hasInferenceFinished = true;
-	}
-	
-	public boolean hasInferenceFinished() {
-		return this.hasInferenceFinished;
-	}
 
 	public TypeBinding invocationTargetType() {
 		if (this.expectedType == null) return null;
@@ -149,53 +136,8 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 		return this.resolvedType = null;
 	}
 
-	/** During inference: Try to find an applicable method binding without causing undesired side-effects. */
-	public MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope) {
-		if (this.hasInferenceFinished)
-			return this.binding;
-		return (MethodBinding)internalResolveTentatively(targetType, scope)[0];
-	}
-
-	/** During inference: Try to resolve the type of this expression without causing undesired side-effects. */
-	public TypeBinding resolveTentatively(BlockScope scope, TypeBinding targetType) {
-		if (this.hasInferenceFinished)
-			return this.resolvedType;
-		return (TypeBinding)internalResolveTentatively(targetType, scope)[1];
-	}
-
-	private Object[] internalResolveTentatively(TypeBinding targetType, Scope scope) { // TODO: convert return to Pair<MethodBinding,TypeBinding>
-		// FIXME: could enclosingScope still be null here??
-		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
-		ExpressionContext previousContext = this.expressionContext;
-		MethodBinding previousBinding = this.binding;
-		MethodBinding previousDescriptor = this.descriptor;
-		try {
-			setExpressionContext(INVOCATION_CONTEXT);
-			setExpectedType(targetType);
-			this.binding = null;
-			TypeBinding type = resolveType(this.enclosingScope);
-			return new Object[] { this.binding, type };
-		} finally {
-			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
-			// remove *any relevant* traces of this 'inofficial' resolving:
-			this.binding = previousBinding;
-			this.descriptor = previousDescriptor;
-			this.hasInferenceFinished = false;
-			setExpressionContext(previousContext);
-			this.expectedType = null; // don't call setExpectedType(null), would NPE
-			cleanUpAfterTentativeResolve();
-		}
-	}
-
-	void cleanUpAfterTentativeResolve() {
-		// nop. Subclasses: do your homework!
-	}
-
-	public void checkAgainstFinalTargetType(TypeBinding targetType) {
-		if (this.expectedIsFinalTargetType)
-			return; // already checked
-		this.expectedIsFinalTargetType = true;
-		resolveTypeExpecting(this.enclosingScope, targetType);
+	public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType) {
+		return resolveTypeExpecting(this.enclosingScope, targetType);
 	}
 
 	class VisibilityInspector extends TypeBindingVisitor {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
index 2dec011..eeaceb3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
@@ -17,37 +17,42 @@ package org.eclipse.jdt.internal.compiler.ast;
 import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 
 /**
- * Abstraction for AST nodes that can trigger 
+ * Abstraction for invocation AST nodes that can trigger 
  * <ul>
  * <li>Invocation Applicability Inferences (18.5.1), and</li> 
  * <li>Invocation Type Inference (18.5.2).</li>
  * </ul>
  */
-public interface Invocation extends InvocationSite, PolyExpression {
+public interface Invocation extends InvocationSite {
 
 	Expression[] arguments();
 
 	MethodBinding binding();
 
-	InferenceContext18 inferenceContext();
-
-	/** See {@link #inferenceContext()}. */
-	void setInferenceKind(int checkKind);
-
 	/**
-	 * Answer one of {@link InferenceContext18#CHECK_STRICT}, {@link InferenceContext18#CHECK_LOOSE} 
-	 * or {@link InferenceContext18#CHECK_VARARG}, to signal what kind of inference has been used.
+	 * Register the given inference context, which produced the given method as its intermediate result.
+	 * Later when the same method is selected as the most specific method, the inference context
+	 * for this pair (Invocation x MethodBinding) can be looked up using {@link #getExpressionContext()}
+	 * to continue the type inference.
 	 */
-	int inferenceKind();
+	void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18);
+	
+	/**
+	 * Retrieve an inference context for the given method which must have been registered
+	 * using {@link #registerInferenceContext(ParameterizedGenericMethodBinding, InferenceContext18)}.
+	 * @param method an intermediate resolved candidate for this invocation
+	 * return a suspended inference context or null if none was registered for this method.
+	 */
+	InferenceContext18 getInferenceContext(ParameterizedGenericMethodBinding method);
 
 	/**
 	 * Where the AST node may hold references to the results of Invocation Applicability Inference,
 	 * this method allows to update those references to the result of Invocation Type Inference.
 	 * Note that potentially more than just the method binding is updated.
+	 * @return true if an update has happened
 	 */
-	TypeBinding updateBindings(MethodBinding updatedBinding);
-
+	boolean updateBindings(MethodBinding updatedBinding);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 673da81..047e2b2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -368,26 +368,6 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		}
 		return this.resolvedType;
 	}
-	
-	void cleanUpAfterTentativeResolve() {
-		// remove traces of attempts to resolve the argument before we have the final target type:
-		if (this.arguments != null)
-			for (int i = 0; i < this.arguments.length; i++)
-				this.arguments[i].binding = null;
-		// also remove traces of references to this argument
-		if (this.body != null)
-			this.body.traverse(new ASTVisitor() {
-				public boolean visit(SingleNameReference singleNameReference, BlockScope blockScope) {
-					if (singleNameReference.binding instanceof LocalVariableBinding) {
-						singleNameReference.bits &= ~ASTNode.RestrictiveFlagMASK;
-						singleNameReference.bits |= Binding.VARIABLE;
-						singleNameReference.actualReceiverType = null;
-						singleNameReference.binding = null;
-					}
-					return true;
-				}
-			}, this.scope);
-	}
 
 	public boolean argumentsTypeElided() {
 		return this.arguments.length > 0 && this.arguments[0].hasElidedType();
@@ -686,7 +666,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				} else {
 					this.voidCompatible = ((Expression) this.body).statementExpression();
 					// TODO: in getResolvedCopyForInferenceTargeting() we need to check if the expression
-					//        *could* also procude a value and set valueCompatible accordingly.
+					//        *could* also produce a value and set valueCompatible accordingly.
 					//        Is that needed also here?
 					this.shapeAnalysisComplete = true;
 				}
@@ -767,7 +747,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			this.hasIgnoredMandatoryErrors = false;
 			TypeBinding type = copy.resolveType(this.enclosingScope);
 			if (this.body instanceof Block) {
-				if (this.returnsVoid) {
+				if (copy.returnsVoid) {
 					copy.shapeAnalysisComplete = true;
 				}
 			} else {
@@ -780,14 +760,15 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				copy.shapeAnalysisComplete = true;
 			}
 			// Do not proceed with data/control flow analysis if resolve encountered errors.
-			if (type == null || !type.isValidBinding() || this.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
-				return null;
+			if (type != null && type.isValidBinding() && !this.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
+				// value compatibility of block lambda's is the only open question.
+				if (!copy.shapeAnalysisComplete)
+					copy.valueCompatible = copy.doesNotCompleteNormally();
+			} else {
+				if (!copy.returnsVoid)
+					copy.valueCompatible = true; // optimistically, TODO: is this OK??
 			}
 			
-			// value compatibility of block lambda's is the only open question.
-			if (!copy.shapeAnalysisComplete)
-				copy.valueCompatible = copy.doesNotCompleteNormally();
-			
 			copy.shapeAnalysisComplete = true;
 		} finally {
 			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 96671f5..0bfcb35 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -83,6 +83,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 public class MessageSend extends Expression implements Invocation {
 
@@ -100,8 +101,9 @@ public class MessageSend extends Expression implements Invocation {
 	public TypeReference[] typeArguments;
 	public TypeBinding[] genericTypeArguments;
 	private ExpressionContext expressionContext = VANILLA_CONTEXT;
-	private int inferenceKind = 0;
-	private InferenceContext18 inferenceContext;
+
+	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
+	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	boolean nonStatic = !this.binding.isStatic();
@@ -849,11 +851,7 @@ protected void findMethodBinding(BlockScope scope, TypeBinding[] argumentTypes,
 			: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
 	
 	if (polyExpressionSeen)
-		if (resolvePolyExpressionArguments(this, scope, this.binding, argumentTypes)) {
-			this.binding = this.receiver.isImplicitThis()
-					? scope.getImplicitMethod(this.selector, argumentTypes, this)
-					: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
-		}
+		resolvePolyExpressionArguments(this, this.binding, argumentTypes);
 }
 
 public void setActualReceiverType(ReferenceBinding receiverType) {
@@ -956,41 +954,35 @@ public MethodBinding binding() {
 public Expression[] arguments() {
 	return this.arguments;
 }
-public InferenceContext18 freshInferenceContext(Scope scope) {
-	InferenceContext18 outer = this.inferenceContext != null ? this.inferenceContext.outerContext : null;
-	this.inferenceContext = new InferenceContext18(scope, this.arguments, this);
-	this.inferenceContext.outerContext = outer;
-	return this.inferenceContext;
-}
-/**
- * Here inference signals if it has established applicability.
- * If so, it sets the corresponding checkKind (see {@link InferenceContext18#CHECK_STRICT} etc.).
- * When later the message send is touched again as an element in an outer expression,
- * we re-use this bit to perform only one kind of check.
- * TODO(stephan): check if this is sanctioned by the spec.
- * TODO(stephan): cf. {@link Expression#tagAsEllipsisArgument} (not implemented in this class)
- */
-public void setInferenceKind(int checkKind) {
-	this.inferenceKind = checkKind;
-}
-public int inferenceKind() {
-	return (this.inferenceKind & InferenceContext18.INFERENCE_KIND_MASK);
+public ExpressionContext getExpressionContext() {
+	return this.expressionContext;
 }
-public void markInferenceFinished() {
-	this.inferenceKind |= InferenceContext18.CHECK_FINISHED;
+public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
+	if (this.inferenceContexts == null)
+		this.inferenceContexts = new SimpleLookupTable();
+	this.inferenceContexts.put(method, infCtx18);
 }
-public boolean hasInferenceFinished() {
-	return (this.inferenceContext == null && this.inferenceKind == 0) // only relevant if inference has been started
-			|| (this.inferenceKind & InferenceContext18.CHECK_FINISHED) != 0;
+public InferenceContext18 getInferenceContext(ParameterizedGenericMethodBinding method) {
+	if (this.inferenceContexts == null)
+		return null;
+	return (InferenceContext18) this.inferenceContexts.get(method);
 }
-public TypeBinding updateBindings(MethodBinding updatedBinding) {
+public boolean updateBindings(MethodBinding updatedBinding) {
+	if (this.binding == updatedBinding)
+		return false;
+	if (this.inferenceContexts != null) {
+		InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
+		if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
+			this.inferenceContexts.put(updatedBinding, ctx);
+			ctx.hasFinished=true;
+		}
+	}
 	this.binding = updatedBinding;
-	return this.resolvedType = updatedBinding.returnType;
-}
-public ExpressionContext getExpressionContext() {
-	return this.expressionContext;
+	this.resolvedType = updatedBinding.returnType;
+	return true;
 }
-public InferenceContext18 inferenceContext() {
-	return this.inferenceContext;
+// -- Interface InvocationSite: --
+public InferenceContext18 freshInferenceContext(Scope scope) {
+	return new InferenceContext18(scope, this.arguments, this);
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PolyExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PolyExpression.java
deleted file mode 100644
index 6b741df..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/PolyExpression.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2013 GK Software AG.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.ast;
-
-/**
- * Abstraction of AST nodes that can be poly expressions and participate in type inference.
- * (not included: ConditionalExpression).
- */
-public interface PolyExpression {
-
-	/** Mark that inference for this expression has finished. */
-	void markInferenceFinished();
-
-	/** Answer whether type inference for this expression has finished (if needed). */
-	boolean hasInferenceFinished();
-}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 19f8f8c..3cf6f07 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -526,6 +526,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
     	return this.resolvedType; // Phew !
 	}
 
+	/** During inference: Try to find an applicable method binding without causing undesired side-effects. */
 	public MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope) {
 		if (this.exactMethodBinding != null) {
 			// TODO: shouldn't extactMethodBinding already be parameterized?
@@ -534,7 +535,29 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			}
 			return this.exactMethodBinding;
 		}
-		return super.findCompileTimeMethodTargeting(targetType, scope);
+		return internalResolveTentatively(targetType, scope);
+	}
+
+	MethodBinding internalResolveTentatively(TypeBinding targetType, Scope scope) {
+		// FIXME: could enclosingScope still be null here??
+		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
+		ExpressionContext previousContext = this.expressionContext;
+		MethodBinding previousBinding = this.binding;
+		MethodBinding previousDescriptor = this.descriptor;
+		try {
+			setExpressionContext(INVOCATION_CONTEXT);
+			setExpectedType(targetType);
+			this.binding = null;
+			resolveType(this.enclosingScope);
+			return this.binding;
+		} finally {
+			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
+			// remove *any relevant* traces of this 'inofficial' resolving:
+			this.binding = previousBinding;
+			this.descriptor = previousDescriptor;
+			setExpressionContext(previousContext);
+			this.expectedType = null; // don't call setExpectedType(null), would NPE
+		}
 	}
 
 	public boolean isConstructorReference() {
@@ -558,11 +581,9 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	}
 
 	public InferenceContext18 freshInferenceContext(Scope scope) {
-		// no need to store the context for later use, since ReferenceExpression 
-		// is not subject to Invocation Type Inference (is not an invocation).
-		return new InferenceContext18(scope, null/*no arguments*/, this);
+		return null; // subject to inference only as an argument to an outer invocation
 	}
- 
+
 	public boolean isSuperAccess() {
 		return false;
 	}
@@ -620,8 +641,6 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	}
 
 	public boolean isCompatibleWith(TypeBinding left, Scope scope) {
-		if (this.hasInferenceFinished)
-			return this.resolvedType != null ? this.resolvedType.isCompatibleWith(left, scope) : false;
 		// 15.28.2
 		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sam == null || !sam.isValidBinding())
@@ -636,7 +655,6 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
 			isCompatible = this.binding != null && this.binding.isValidBinding();
 			this.binding = null;
-			this.hasInferenceFinished = false;
 			setExpectedType(null);
 		}
 		return isCompatible;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 995b68b..4a8ca8c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -330,16 +330,13 @@ public ExpressionContext getExpressionContext() {
 }
 /**
  * For all constructor invocations: find the constructor binding; 
- * if polyExpressionSeen allow for two attempts where the first round may stop
- * after applicability checking (18.5.1) to include more information into the final
- * invocation type inference (18.5.2).
+ * if polyExpressionSeen perform some post processing for those and produce
+ * any updates as side-effects into 'argumentTypes'.
  */
 protected MethodBinding findConstructorBinding(BlockScope scope, Invocation site, ReferenceBinding receiverType, TypeBinding[] argumentTypes, boolean polyExpressionSeen) {
 	MethodBinding ctorBinding = scope.getConstructor(receiverType, argumentTypes, site);
-	if (polyExpressionSeen) {
-		if (resolvePolyExpressionArguments(site, scope, ctorBinding, argumentTypes))
-			return scope.getConstructor(receiverType, argumentTypes, site);
-	}
+	if (polyExpressionSeen)
+		resolvePolyExpressionArguments(site, ctorBinding, argumentTypes);
 	return ctorBinding;
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index dda340e..fb8054f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -268,6 +268,8 @@ class BoundSet {
 			Map.Entry entry = (Entry) setsIterator.next();
 			copy.boundsPerVariable.put(entry.getKey(), ((ThreeSets)entry.getValue()).copy());
 		}
+		copy.inThrows.addAll(this.inThrows);
+		copy.captures.putAll(this.captures);
 		return copy;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index e3a0761..00ae1c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -62,8 +62,14 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		if (this.right.isProperType(true)) {
 			TypeBinding exprType = this.left.resolvedType;
 			if (exprType == null) {
-				if (this.left instanceof FunctionalExpression)
+				if (this.left instanceof FunctionalExpression) {
+					if (this.left instanceof LambdaExpression) {
+						// cf. NegativeLambdaExpressionTest.test412453()
+						LambdaExpression copy = ((LambdaExpression) this.left).getResolvedCopyForInferenceTargeting(this.right);
+						return (copy.resolvedType != null && copy.resolvedType.isValidBinding()) ? TRUE : FALSE;
+					}
 					return this.left.isCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;
+				}
 				return FALSE;
 			} else if (!exprType.isValidBinding()) {
 				return FALSE;
@@ -83,19 +89,26 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (this.left instanceof Invocation) {
 				Invocation invocation = (Invocation) this.left;
 				// ignore previous (inner) inference result and do a fresh start:
-				MethodBinding method = invocation.binding().original();
+				MethodBinding previousMethod = invocation.binding();
+				MethodBinding method = previousMethod.original();
 				InvocationRecord prevInvocation = inferenceContext.enterPolyInvocation(invocation, invocation.arguments());
 
-				// Invocation Applicability Inference: 18.5.1
+				// Invocation Applicability Inference: 18.5.1 & Invocation Type Inference: 18.5.2
 				try {
 					Expression[] arguments = invocation.arguments();
 					TypeBinding[] argumentTypes = arguments == null ? Binding.NO_PARAMETERS : new TypeBinding[arguments.length];
 					for (int i = 0; i < argumentTypes.length; i++)
 						argumentTypes[i] = arguments[i].resolvedType;
-					int checkType = (invocation.inferenceKind() != 0) ? invocation.inferenceKind() : InferenceContext18.CHECK_LOOSE;
+					if (previousMethod instanceof ParameterizedGenericMethodBinding) {
+						// find the previous inner inference context to see what inference kind this invocation needs:
+						InferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) previousMethod);
+						if (innerCtx == null)
+							InferenceContext18.missingImplementation("Missing context for inner inference for "+invocation.toString());
+						inferenceContext.inferenceKind = innerCtx.inferenceKind;
+						innerCtx.outerContext = inferenceContext;
+					}
 					boolean isDiamond = method.isConstructor() && this.left.isPolyExpression(method);
-					inferInvocationApplicability(inferenceContext, method, argumentTypes, isDiamond, checkType); // FIXME 3 phases?
-					
+					inferInvocationApplicability(inferenceContext, method, argumentTypes, isDiamond, inferenceContext.inferenceKind);
 					if (!inferPolyInvocationType(inferenceContext, invocation, this.right, method))
 						return FALSE;
 					return null; // already incorporated
@@ -144,14 +157,10 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					TypeBinding r = functionType.returnType;
 					if (lambda.body() instanceof Expression) {
 						Expression body = (Expression)lambda.body();
-						// before introducing the body into inference, we must ensure it's resolved, hm...
-						ensureResolved(lambda.enclosingScope, body, r);
 						result.add(new ConstraintExpressionFormula(body, r, COMPATIBLE));
 					} else {
 						Expression[] exprs = lambda.resultExpressions();
 						for (int i = 0; i < exprs.length; i++) {
-							// before introducing result expressions into inference, we must ensure they're resolved, hm...
-							ensureResolved(lambda.enclosingScope, exprs[i], r);
 							result.add(new ConstraintExpressionFormula(exprs[i], r, COMPATIBLE));
 						}
 					}
@@ -179,24 +188,6 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		}
 	}
 
-	private void ensureResolved(BlockScope scope, Expression expr, TypeBinding targetType) {
-		// TODO this method might be obsoleted by the use of LE.getResolvedCopyForInferenceTargeting()
-		if (expr.resolvedType == null) {
-			if (targetType.isProperType(true))
-				expr.setExpectedType(targetType);
-			else
-				expr.setExpectedType(null);
-			ExpressionContext previousExpressionContext = expr.getExpressionContext();
-			if (previousExpressionContext == ExpressionContext.VANILLA_CONTEXT)
-				expr.setExpressionContext(ExpressionContext.ASSIGNMENT_CONTEXT);
-			try {
-				expr.resolveType(scope);
-			} finally {
-				expr.setExpressionContext(previousExpressionContext);
-			}
-		}
-	}
-
 	private Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext) {
 		TypeBinding t = this.right;
 		if (t.isProperType(true))
@@ -243,7 +234,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		return FALSE;
 	}
 
-	static void inferInvocationApplicability(InferenceContext18 inferenceContext, MethodBinding method, TypeBinding[] arguments, boolean isDiamond, int checkType) 
+	static void inferInvocationApplicability(InferenceContext18 inferenceContext, MethodBinding method, TypeBinding[] arguments, boolean isDiamond, int checkType)
 	{
 		// 18.5.1
 		TypeVariableBinding[] typeVariables = method.typeVariables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index c4f1658..3c2e3ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -23,13 +23,113 @@ import java.util.List;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.dom.LambdaExpression;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.ExpressionContext;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
  * Main class for new type inference as per JLS8 sect 18.
  * Keeps contextual state and drives the algorithm.
+ * 
+ * <h2>Inference Basics</h2>
+ * <ul>
+ * <li>18.1.1 Inference variables: {@link InferenceVariable}</li>
+ * <li>18.1.2 Constraint Formulas: subclasses of {@link ConstraintFormula}</li>
+ * <li>18.1.3 Bounds: {@link TypeBound}<br/>
+ * 	Capture bounds are directly captured in {@link BoundSet#captures}, throws-bounds in {@link BoundSet#inThrows}.<br/>
+ * 	Also: {@link BoundSet}: main state during inference.</li>
+ * </ul>
+ * Each instance of {@link InferenceContext18} manages instances of the above and coordinates the inference process.
+ * <h3>Queries and utilities</h3>
+ * <ul>
+ * <li>{@link TypeBinding#isProperType(boolean)}:
+ * 	 used to exclude "types" that mention inference variables (18.1.1).</li>
+ * <li>{@link TypeBinding#mentionsAny(TypeBinding[], int)}:
+ * 	 does the receiver type binding mention any of the given types?</li>
+ * <li>{@link TypeBinding#substituteInferenceVariable(InferenceVariable, TypeBinding)}:
+ * 	 replace occurrences of an inference variable with a proper type.</li>
+ * <li>{@link TypeBinding#collectInferenceVariables(Set)}:
+ * 	 collect all inference variables mentioned in the receiver type into the given set.</li>
+ * <li>{@link TypeVariableBinding#getTypeBounds(InferenceVariable, InferenceContext18)}:
+ * 	Compute the initial type bounds for one inference variable as per JLS8 sect 18.1.3.</li>
+ * </ul>
+ * <h2>Phases of Inference</h2>
+ * <ul>
+ * <li>18.2 <b>Reduction</b>: {@link #reduce()} with most work happening in implementations of
+ *  {@link ConstraintFormula#reduce(InferenceContext18)}:
+ *  <ul>
+ *  <li>18.2.1 Expression Compatibility Constraints: {@link ConstraintExpressionFormula#reduce(InferenceContext18)}.</li>
+ *  <li>18.2.2 Type Compatibility Constraints ff. {@link ConstraintTypeFormula#reduce(InferenceContext18)}.</li>
+ *  </ul></li>
+ * <li>18.3 <b>Incorporation</b>: {@link BoundSet#incorporate(InferenceContext18)}; during inference new constraints
+ * 	are accepted via {@link BoundSet#reduceOneConstraint(InferenceContext18, ConstraintFormula)} (combining 18.2 & 18.3)</li>
+ * <li>18.4 <b>Resolution</b>: {@link #resolve()}.
+ * </ul>
+ * Some of the above operations accumulate their results into {@link #currentBounds}, whereas
+ * the last phase <em>returns</em> the resulting bound set while keeping the previous state in {@link #currentBounds}.
+ * <h2>18.5. Uses of Inference</h2>
+ * These are the main entries from the compiler into the inference engine:
+ * <dl>
+ * <dt>18.5.1 Invocation Applicability Inference</dt>
+ * <dd>{@link #inferInvocationApplicability(MethodBinding, TypeBinding[], boolean)}. Prepare the initial state for
+ * 	inference of a generic invocation - no target type used at this point.
+ *  Need to call {@link #solve()} afterwards to produce the intermediate result.<br/>
+ *  Called indirectly from {@link Scope#findMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean)} et al
+ *  to select applicable methods into overload resolution.</dd>
+ * <dt>18.5.2 Invocation Type Inference</dt>
+ * <dd>{@link InferenceContext18#inferInvocationType(BoundSet, TypeBinding, InvocationSite, MethodBinding)}. After a
+ * 	most specific method has been picked, and given a target type determine the final generic instantiation.
+ *  As long as a target type is still unavailable this phase keeps getting deferred.</br>
+ *  Different wrappers exist for the convenience of different callers.</dd>
+ * <dt>18.5.3 Functional Interface Parameterization Inference</dt>
+ * <dd>Controlled from {@link LambdaExpression#resolveTypeBinding()}.</dd>
+ * <dt>18.5.4 More Specific Method Inference</dt>
+ * <dd><em>Not Yet Implemented</em></dd>
+ * </dl>
+ * For 18.5.1 and 18.5.2 some high-level control is implemented in
+ *  {@link ParameterizedGenericMethodBinding#computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite, int)}.
+ * <h2>Inference Lifecycle</h2>
+ * The separation into 18.5.1 and 18.5.2 causes some complexity:
+ * <ul>
+ * <li>Calling both parts of inference is directly interwoven with overload resolution. See 
+ * {@link ParameterizedGenericMethodBinding#computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite, int)
+ * 		PGMB#computeCompatibleMethod()} for the basic <b>protocol</b>.</li>
+ * <li>Intermediate <b>state</b> regarding inference must be stored between both phases. Inference is performed with different
+ *   inputs for each pair of {@link Invocation} x {@link ParameterizedGenericMethodBinding},
+ *    see {@link Invocation#registerInferenceContext(ParameterizedGenericMethodBinding, InferenceContext18) Invocation.registerInferenceContext()} and
+ *    {@link Invocation#getInferenceContext(ParameterizedGenericMethodBinding) getInferenceContext()}.<br/>
+ *    As part of the lifecycle state, each instance of InferenceContext18 remembers the current {@link #inferenceKind}
+ *    and {@link #hasFinished}.</li>
+ * <li><b>Nested inference/resolving</b>: If an invocation argument is a poly expression itself, final resolving of the argument can only happened
+ *    after Invocation Type Inference regarding the outer invocation. Outer inference must produce the <b>target type</b> that drives
+ *    the inner inference / resolving. Two different protocols are applied:
+ *    <ul>
+ *    <li>If the inner poly expression is an invocation, inner inference is directly incorporated into
+ *      the {@link #currentBounds}, see block inside {@link ConstraintExpressionFormula#reduce(InferenceContext18)}.<br/>
+ *      In this case the results of the combined inference need to be applied to all contained inner invocations,
+ *      which happens in {@link #rebindInnerPolies(BoundSet, TypeBinding[])}, which must be called whenever
+ *      18.5.2 finishes.</li>
+ *    <li>If the inner poly expression is a functional expression or a conditional expression no inference variables
+ *      exist representing the inner. In this case the final target type is pushed into the inner using
+ *      {@link Expression#checkAgainstFinalTargetType(TypeBinding)}, which, too, is called from 
+ *      {@link #rebindInnerPolies(BoundSet, TypeBinding[])}.</li>
+ *    <li>For recursively pushing target types into arguments of an invocation
+ *    	method {@link ASTNode#resolvePolyExpressionArguments(Invocation, MethodBinding, TypeBinding[])} exists,
+ *    	which is called in two situations: (1) for non-generic outer invocations from MessageSend#findMethodBinding() and
+ *    	Statement#findConstructorBinding(); (2) for generic outer invocations from {@link #rebindInnerPolies(BoundSet, TypeBinding[])}.</li>
+ *    <li>In some situations invocation arguments that are poly invocations need to be resolved in the middle of overload resolution
+ *    	to answer {@link Scope#parameterCompatibilityLevel18} (where the outer invocation did not involve any inference).<br/>
+ *    </ul>
+ *    Pushing inference results into an inner invocation happens using {@link Invocation#updateBindings(MethodBinding)}.</li>
+ * <li>Decision whether or not an invocation is a <b>variable-arity</b> invocation is made by first attempting
+ * 		to solve 18.5.1 in mode {@link #CHECK_LOOSE}. Only if that fails, another attempt is made in mode {@link #CHECK_VARARG}.
+ * 		Which of these two attempts was successful is stored in {@link #inferenceKind}.
+ * 		This field must be consulted whenever arguments of an invocation should be further processed.
+ * 		See also {@link #getParameter(TypeBinding[], int, boolean)} and its clients.</li>
+ * </ul>
  */
 public class InferenceContext18 {
 
@@ -43,39 +143,55 @@ public class InferenceContext18 {
 	 */
 	static final boolean ARGUMENT_CONSTRAINTS_ARE_SOFT = false;
 
+	// --- Main State of the Inference: ---
+
+	/** the invocation being inferred (for 18.5.1 and 18.5.2) */
+	InvocationSite currentInvocation;
+	/** arguments of #currentInvocation, if any */
+	Expression[] invocationArguments;
+	
+	/** The inference variables for which as solution is sought. */
 	InferenceVariable[] inferenceVariables;
-	BoundSet currentBounds;
-	ConstraintFormula[] initialConstraints;
+	/** Number of inference variables. */
 	int variableCount = 0;
+	/** Constraints that have not yet been reduced and incorporated. */
+	ConstraintFormula[] initialConstraints;
+	/** The accumulated type bounds etc. */
+	BoundSet currentBounds;
 
+	/** solution of applicability inference, stored for use as fallback, if invocation type inference fails. */
+	BoundSet storedSolution;
+	/** One of CHECK_STRICT, CHECK_LOOSE, or CHECK_VARARGS. */
+	int inferenceKind;
+	/** Once an invocation inference has passed 18.5.2 inference, flip this to true to avoid repeated inference of the same task. */
+	public boolean hasFinished = false;
+	
+	// ---
+
+	/** Inner poly invocations which have been included in this inference. */
 	List/*<InvocationSite>*/ innerPolies = new ArrayList();
+	/** Link to an outer inference context, used for bundled error reporting. */
 	public InferenceContext18 outerContext;
 	private ArrayList problemMethods;
 
 	Scope scope;
 	LookupEnvironment environment;
-	ReferenceBinding object;
-	
-	// interim, processed by createInitialConstraintsForParameters()
-	InvocationSite currentInvocation;
-	Expression[] invocationArguments;
+	ReferenceBinding object; // java.lang.Object
 	
-	// Bitmask, lower two bits:
 	public static final int CHECK_STRICT = 1;
 	public static final int CHECK_LOOSE = 2;
 	public static final int CHECK_VARARG = 3;
-	public static final int INFERENCE_KIND_MASK = 3;
-	// bit 3:
-	public static final int CHECK_FINISHED = 4;
 	
 	static class InvocationRecord {
 		InvocationSite site;
 		Expression[] invocationArguments;
 		InferenceVariable[] inferenceVariables;
-		InvocationRecord(InvocationSite site, Expression[] invocationArguments, InferenceVariable[] inferenceVariables) {
+		int inferenceKind;
+		InvocationRecord(InvocationSite site, Expression[] invocationArguments, InferenceVariable[] inferenceVariables, int inferenceKind) {
 			this.site = site;
 			this.invocationArguments = invocationArguments;
 			this.inferenceVariables = inferenceVariables;
+			this.inferenceKind = inferenceKind;
 		}
 	}
 	
@@ -212,18 +328,17 @@ public class InferenceContext18 {
 		}		
 	}
 
-	/** JLS 18.5.1 Invocation Applicability Inference */
-	public void inferInvocationApplicability(MethodBinding method, TypeBinding[] arguments, boolean isDiamond, int checkType) {
-		ConstraintExpressionFormula.inferInvocationApplicability(this, method, arguments, isDiamond, checkType);
+	/** JLS 18.5.1 Invocation Applicability Inference. */
+	public void inferInvocationApplicability(MethodBinding method, TypeBinding[] arguments, boolean isDiamond) {
+		ConstraintExpressionFormula.inferInvocationApplicability(this, method, arguments, isDiamond, this.inferenceKind);
 	}
 
 	/** JLS 18.5.2 Invocation Type Inference 
 	 * @param b1 "the bound set produced by reduction in order to demonstrate that m is applicable in 18.5.1" 
 	 */
-	public BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method, int checkKind)
+	public BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method)
 			throws InferenceFailureException 
 	{
-		BoundSet previous = this.currentBounds;
 		this.currentBounds = b1;
 		try {
 			// bullets 1&2: definitions only.
@@ -244,7 +359,9 @@ public class InferenceContext18 {
 			if (arguments != null) {
 				int k = arguments.length;
 				int p = method.parameters.length;
-				switch (checkKind) {
+				if (k < (method.isVarargs() ? p-1 : p))
+					return null; // insufficient arguments for parameters!
+				switch (this.inferenceKind) {
 					case CHECK_STRICT:
 					case CHECK_LOOSE:
 						fs = method.parameters;
@@ -253,7 +370,7 @@ public class InferenceContext18 {
 						fs = varArgTypes(method.parameters, k);
 						break;
 					default:
-						throw new IllegalStateException("Unexpected checkKind "+checkKind); //$NON-NLS-1$
+						throw new IllegalStateException("Unexpected checkKind "+this.inferenceKind); //$NON-NLS-1$
 				}
 				for (int i = 0; i < k; i++) {
 					TypeBinding fsi = fs[Math.min(i, p-1)];
@@ -298,72 +415,75 @@ public class InferenceContext18 {
 			BoundSet solution = solve();
 			if (solution == null || !isResolved(solution))
 				return null;
-			return solution;
+			return this.currentBounds = solution; // this is final, keep the result:
 		} finally {
-			this.currentBounds = previous;
+			this.hasFinished = true;
 		}
 	}
 
 	/**
 	 * Simplified API to perform Invocation Type Inference (JLS 18.5.2)
-	 * and (if successful) return the solution.
+	 * and perform subsequent steps: bound check, rebinding of inner poly expressions,
+	 * and creating of a problem method binding if needed.
+	 * Should only be called if the inference has not yet finished.
 	 * @param invocation invocation being inferred
+	 * @param argumentTypes arguments being passed into the invocation
+	 * @param method current candidate method binding for this invocation
+	 * @return a valid method binding with updated type parameters,
+	 * 	or a problem method binding signaling either inference failure or a bound mismatch.
+	 */
+	public /*@NonNull*/ MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method) {
+		// TODO optimize: if outerContext exists and is resolved, we probably don't need to infer again.
+		TypeBinding targetType = invocation.invocationTargetType();
+		ParameterizedGenericMethodBinding finalMethod = method;
+		ParameterizedGenericMethodBinding methodToCheck = method;
+		
+		boolean haveProperTargetType = targetType != null && targetType.isProperType(true);
+		if (haveProperTargetType) {
+			finalMethod = getInvocationTypeInferenceSolution(method.originalMethod, invocation, targetType);
+			if (finalMethod != null)
+				methodToCheck = finalMethod;
+		}
+		
+		MethodBinding problemMethod = methodToCheck.boundCheck18(this.scope, argumentTypes);
+		if (problemMethod != null)
+			return problemMethod;
+
+		if (!haveProperTargetType && invocation.getExpressionContext() != ExpressionContext.VANILLA_CONTEXT)
+			return method; // still not ready!
+
+		if (finalMethod != null) {
+			if (rebindInnerPolies(finalMethod, invocation))
+				return finalMethod;
+		}
+		return getReturnProblemMethodIfNeeded(targetType, method);
+	}
+
+	/**
+	 * Simplified API to perform Invocation Type Inference (JLS 18.5.2)
+	 * and (if successful) return the solution.
+	 * @param site invocation being inferred
 	 * @param targetType target type for this invocation
 	 * @return a method binding with updated type parameters, or null if no solution was found
 	 */
-	public MethodBinding getInvocationTypeInferenceSolution(Invocation invocation, TypeBinding targetType) {
+	public ParameterizedGenericMethodBinding getInvocationTypeInferenceSolution(MethodBinding method, Invocation site, TypeBinding targetType) {
 		// start over from a previous candidate but discard its type variable instantiations
 		// TODO: should we retain any instantiations of type variables not owned by the method? 
-		MethodBinding method = invocation.binding().original();
 		BoundSet result = null;
 		try {
-			result = inferInvocationType(this.currentBounds, targetType, invocation, method, invocation.inferenceKind());
+			result = inferInvocationType(this.currentBounds, targetType, site, method);
 		} catch (InferenceFailureException e) {
 			return null;
 		}
 		if (result != null) {
-			TypeBinding[] solutions = getSolutions(method.typeVariables(), invocation, result);
-			if (solutions != null)
-				return this.environment.createParameterizedGenericMethod(method, solutions);
-		}
-		return null;
-	}
-
-	private Object pickFromCycle(Set c) {
-		missingImplementation("Breaking a dependency cycle NYI"); //$NON-NLS-1$
-		return null; // never
-	}
-
-	private Set findBottomSet(Set constraints, Set allOutputVariables) {
-		// 18.5.2 bullet 5.1
-		//  A subset of constraints is selected, satisfying the property
-		// that, for each constraint, no input variable depends on an
-		// output variable of another constraint in C ...
-		Set result = new HashSet();
-		Iterator it = constraints.iterator();
-		constraintLoop: while (it.hasNext()) {
-			ConstraintFormula constraint = (ConstraintFormula)it.next();
-			Iterator inputIt = constraint.inputVariables(this).iterator();
-			Iterator outputIt = allOutputVariables.iterator();
-			while (inputIt.hasNext()) {
-				InferenceVariable in = (InferenceVariable) inputIt.next();
-				while (outputIt.hasNext()) {
-					if (this.currentBounds.dependsOnResolutionOf(in, (InferenceVariable) outputIt.next()))
-						continue constraintLoop;
-				}
+			TypeBinding[] solutions = getSolutions(method.typeVariables(), site, result);
+			if (solutions != null) {
+				ParameterizedGenericMethodBinding substituteMethod = this.environment.createParameterizedGenericMethod(method, solutions);
+				site.registerInferenceContext(substituteMethod, this);
+				return substituteMethod;
 			}
-			result.add(constraint);
-		}		
-		return result;
-	}
-
-	Set allOutputVariables(Set constraints) {
-		Set result = new HashSet();
-		Iterator it = constraints.iterator();
-		while (it.hasNext()) {
-			result.addAll(((ConstraintFormula)it.next()).outputVariables(this));
 		}
-		return result;
+		return null;
 	}
 
 	// ========== Below this point: implementation of the generic algorithm: ==========
@@ -609,29 +729,61 @@ public class InferenceContext18 {
 		return numUninstantiated;
 	}
 
+	private Object pickFromCycle(Set c) {
+		missingImplementation("Breaking a dependency cycle NYI"); //$NON-NLS-1$
+		return null; // never
+	}
+
+	private Set findBottomSet(Set constraints, Set allOutputVariables) {
+		// 18.5.2 bullet 5.1
+		//  A subset of constraints is selected, satisfying the property
+		// that, for each constraint, no input variable depends on an
+		// output variable of another constraint in C ...
+		Set result = new HashSet();
+		Iterator it = constraints.iterator();
+		constraintLoop: while (it.hasNext()) {
+			ConstraintFormula constraint = (ConstraintFormula)it.next();
+			Iterator inputIt = constraint.inputVariables(this).iterator();
+			Iterator outputIt = allOutputVariables.iterator();
+			while (inputIt.hasNext()) {
+				InferenceVariable in = (InferenceVariable) inputIt.next();
+				while (outputIt.hasNext()) {
+					if (this.currentBounds.dependsOnResolutionOf(in, (InferenceVariable) outputIt.next()))
+						continue constraintLoop;
+				}
+			}
+			result.add(constraint);
+		}		
+		return result;
+	}
+
+	Set allOutputVariables(Set constraints) {
+		Set result = new HashSet();
+		Iterator it = constraints.iterator();
+		while (it.hasNext()) {
+			result.addAll(((ConstraintFormula)it.next()).outputVariables(this));
+		}
+		return result;
+	}
+
 	private TypeBinding[] varArgTypes(TypeBinding[] parameters, int k) {
 		TypeBinding[] types = new TypeBinding[k];
-		int declaredLength = parameters.length;
+		int declaredLength = parameters.length-1;
 		System.arraycopy(parameters, 0, types, 0, declaredLength);
-		TypeBinding last = parameters[declaredLength-1];
+		TypeBinding last = ((ArrayBinding)parameters[declaredLength]).elementsType();
 		for (int i = declaredLength; i < k; i++)
 			types[i] = last;
 		return types;
 	}
 	
 	public InvocationRecord enterPolyInvocation(InvocationSite invocation, Expression[] innerArguments) {
-		InvocationRecord record = new InvocationRecord(this.currentInvocation, this.invocationArguments, this.inferenceVariables);
+		InvocationRecord record = new InvocationRecord(this.currentInvocation, this.invocationArguments, this.inferenceVariables, this.inferenceKind);
 		this.inferenceVariables = null;
 		this.invocationArguments = innerArguments;
 		this.currentInvocation = invocation;
 		
 		// schedule for re-binding the inner after inference success:
 		this.innerPolies.add(invocation);
-		if (invocation instanceof Invocation) {
-			InferenceContext18 innerContext = ((Invocation) invocation).inferenceContext();
-			if (innerContext != null)
-				innerContext.outerContext = this;
-		}
 		return record;
 	}
 
@@ -646,14 +798,39 @@ public class InferenceContext18 {
 		// replace invocation site & arguments:
 		this.currentInvocation = record.site;
 		this.invocationArguments = record.invocationArguments;
+		this.inferenceKind = record.inferenceKind;
 	}
-	
+
+	public boolean rebindInnerPolies(MethodBinding method, InvocationSite site) {
+		BoundSet bounds = this.currentBounds;
+		TypeBinding targetType = site.invocationTargetType();
+		if ((targetType == null || !targetType.isProperType(true)) && site.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {
+			// in this case we don't yet have the solution, compute it now:
+			try {
+				bounds = inferInvocationType(this.currentBounds, null, site, method);
+			} catch (InferenceFailureException e) {
+				return false;
+			}
+			if (bounds == null)
+				return false;
+		}
+		rebindInnerPolies(bounds, method.parameters);
+		return true;
+	}
+
 	/**
-	 * After inference has finished, iterate all inner poly expressions, that have been
-	 * included in the inference. For each of these update some type information
+	 * After inference has finished, iterate all inner poly expressions (Invocations), that
+	 * have been included in the inference. For each of these update some type information
 	 * from the inference result and perhaps trigger follow-up resolving as needed.
+	 * Similar for poly expressions that did not directly participate in the inference
+	 * but are direct arguments of the current invocation (FunctionalExpression, ConditionalExpression).
 	 */
-	public void rebindInnerPolies(BoundSet bounds, TypeBinding[] argumentTypes) {
+	public void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes) {
+		// This updates all remaining poly expressions that are direct arguments of the current invocation:
+		// (handles FunctionalExpression & ConditionalExpression)
+		acceptPendingPolyArguments(bounds, parameterTypes, this.inferenceKind == CHECK_VARARG);
+		// This loops over all poly expressions for which a sub-inference was triggered:
+		// (handles generic invocations)
 		int len = this.innerPolies.size();
 		for (int i = 0; i < len; i++) {
 			Expression inner = (Expression) this.innerPolies.get(i);
@@ -669,34 +846,85 @@ public class InferenceContext18 {
 					original = ((ParameterizedTypeBinding)declaringClass).createParameterizedMethod(original);
 				}
 				
-				// apply inference results onto the binding of the inner invocation:
+				// apply results of the combined inference onto the binding of the inner invocation:
 				TypeBinding[] solutions = getSolutions(original.typeVariables(), innerMessage, bounds);
 				if (solutions == null) 
 					continue; // play safe, but shouldn't happen in a resolved context
 				ParameterizedGenericMethodBinding innerBinding = this.environment.createParameterizedGenericMethod(original, solutions);
-				innerMessage.updateBindings(innerBinding);
-				innerMessage.markInferenceFinished(); // invocation type inference has already happened on the inner, too.
 				
-				// finalize resolving of arguments of the inner invocation:
-				TypeBinding[] innerParameters = innerBinding.parameters;
-				int inferenceKind = innerMessage.inferenceKind();
-				boolean isVarargs = (inferenceKind == CHECK_VARARG) && innerBinding.isVarargs();
-				TypeBinding varArgsType = isVarargs ? ((ArrayBinding)innerParameters[innerParameters.length-1]).elementsType() : null; 
-				Expression[] arguments = innerMessage.arguments();
-				if (arguments != null) {
-					for (int j = 0; j < arguments.length; j++) {
-						TypeBinding param = (varArgsType == null || (j < innerParameters.length-1))
-												? innerParameters[j]
-												: varArgsType;
-						arguments[j].checkAgainstFinalTargetType(param);
+				if (innerMessage.updateBindings(innerBinding)) { // only if we are actually improving anything
+					TypeBinding[] innerArgumentTypes = null;
+					Expression[] innerArguments = innerMessage.arguments();
+					if (innerArguments != null) {
+						innerArgumentTypes = new TypeBinding[innerArguments.length];
+						for (int j = 0; j < innerArguments.length; j++)
+							innerArgumentTypes[i] = innerArguments[i].resolvedType;
 					}
+					ASTNode.resolvePolyExpressionArguments(innerMessage, innerBinding, innerArgumentTypes);
 				}
 			}
-			// inner FunctionalExpression don't seem to be included in inference.
-			// TODO recheck any inquires on those actually involve inference of which the results are included here. 
 		}
 	}
 
+	private void acceptPendingPolyArguments(final BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs) {
+		if (acceptedResult == null || this.invocationArguments == null) return;
+		Substitution substitution = new Substitution() {
+			public LookupEnvironment environment() { 
+				return InferenceContext18.this.environment;
+			}
+			public boolean isRawSubstitution() {
+				return false;
+			}
+			public TypeBinding substitute(TypeVariableBinding typeVariable) {
+				if (typeVariable instanceof InferenceVariable) {
+					return acceptedResult.getInstantiation((InferenceVariable) typeVariable);
+				}
+				return typeVariable;
+			}
+		};
+		for (int i = 0; i < this.invocationArguments.length; i++) {
+			TypeBinding targetType = getParameter(parameterTypes, i, isVarArgs);
+			if (!targetType.isProperType(true))
+				targetType = Scope.substitute(substitution, targetType);
+			this.invocationArguments[i].checkAgainstFinalTargetType(targetType);
+		}
+	}
+
+	public boolean isVarArgs() {
+		return this.inferenceKind == CHECK_VARARG;
+	}
+
+	/**
+	 * Retrieve the rank'th parameter, possibly respecting varargs invocation, see 15.12.2.4.
+	 * Returns null if out of bounds and CHECK_VARARG was not requested. 
+	 */
+	public static TypeBinding getParameter(TypeBinding[] parameters, int rank, boolean isVarArgs) {
+		if (isVarArgs) {
+			if (rank >= parameters.length-1)
+				return ((ArrayBinding)parameters[parameters.length-1]).elementsType();			
+		} else if (rank >= parameters.length) {
+			return null;
+		}
+		return parameters[rank];
+	}
+
+	/**
+	 * Create a problem method signaling failure of invocation type inference,
+	 * unless the given candidate is tolerable to be compatible with buggy javac.
+	 */
+	public MethodBinding getReturnProblemMethodIfNeeded(TypeBinding expectedType, MethodBinding method) {
+		if (InferenceContext18.SIMULATE_BUG_JDK_8026527 && expectedType != null && method.returnType instanceof ReferenceBinding) {
+			if (method.returnType.erasure().isCompatibleWith(expectedType))
+				return method; // don't count as problem.
+		}
+		if (expectedType == null)
+			return method; // assume inference failure concerned another expression
+		ProblemMethodBinding problemMethod = new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);
+		problemMethod.returnType = expectedType;
+		problemMethod.inferenceContext = this;
+		return problemMethod;
+	}
+
 	// debugging:
 	public String toString() {
 		StringBuffer buf = new StringBuffer("Inference Context"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index a6a226c..f14d972 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -23,7 +23,6 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.ExpressionContext;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
-import org.eclipse.jdt.internal.compiler.ast.PolyExpression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
@@ -44,8 +43,33 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 
 	/**
 	 * Perform inference of generic method type parameters and/or expected type
+	 * <p>
+	 * In 1.8+ the following discipline has to be observed by callers:
+	 * Each invocation must be subjected to two levels of inference:
+	 * </p>
+	 * <ul>
+	 * <li> {@link Scope#APPLICABILITY Invocation Applicability Inference}, which may be applied
+	 *     multiple times for the same invocation</li>
+	 * <li> {@link Scope#INVOCATION_TYPE Invocation Type Inference}, which is finally performed
+	 *     for the selected method and which adds information from the "target type".</li>
+	 * </ul>
+	 * <p>
+	 * Clients can control which parts of the inference should be performed by passing the appropriate
+	 * flags into argument 'inferenceLevel'. On each call path it must be ensured that one or more
+	 * invocation applicability inferences are always followed by exactly one invocation type inference
+	 * (unless errors have been detected).
+	 * </p>
+	 * <p>
+	 * Initial clients are the direct callers of
+	 * {@link Scope#computeCompatibleMethod(MethodBinding,TypeBinding[],InvocationSite,int)},
+	 * which should either invoke both levels of inference <em>or</em> delegate the second part to
+	 * {@link Scope#mostSpecificMethodBinding(MethodBinding[],int,TypeBinding[],InvocationSite,ReferenceBinding)},
+	 * which is intended to ensure completing the inference on all non-error exits.
+	 * </p>  
 	 */
-	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {
+	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,
+			InvocationSite invocationSite, int inferenceLevel)
+	{
 		ParameterizedGenericMethodBinding methodSubstitute;
 		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
 		TypeBinding[] substitutes = invocationSite.genericTypeArguments();
@@ -67,63 +91,78 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 
 // ==== 1.8: The main driver for inference of generic methods: ====
 			InferenceContext18 infCtx18 = null;
-			if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)
-				infCtx18 = invocationSite.freshInferenceContext(scope);
+			if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
+				if ((inferenceLevel & Scope.APPLICABILITY) != 0)
+					infCtx18 = invocationSite.freshInferenceContext(scope);
+				else if (invocationSite instanceof Invocation && originalMethod instanceof ParameterizedGenericMethodBinding)
+					infCtx18 = ((Invocation) invocationSite).getInferenceContext((ParameterizedGenericMethodBinding) originalMethod);
+			}
 			if (infCtx18 != null) {
-				int checkKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
-				// 18.5.1 (Applicability):
-				boolean isDiamond = originalMethod.isConstructor()
-						&& invocationSite instanceof Expression
-						&& ((Expression)invocationSite).isPolyExpression(originalMethod);
-				infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);
 				try {
-					BoundSet provisionalResult = infCtx18.solve();
-					if (provisionalResult == null && originalMethod.isVarargs()) {
-						// check for variable arity applicability
-						infCtx18 = invocationSite.freshInferenceContext(scope); // start over
-						checkKind = InferenceContext18.CHECK_VARARG;
-						infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);
-						provisionalResult = infCtx18.solve();
-					}
-					BoundSet result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()
-					if (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {
-						// 18.5.2 (Invocation type):
-						TypeBinding expectedType = invocationSite.invocationTargetType();
-						boolean hasReturnProblem = false;
-						boolean invocationTypeInferred = false;
-						if (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {
-							result = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod, checkKind);
-							invocationTypeInferred = true;
-							hasReturnProblem |= result == null;
-							if (hasReturnProblem)
-								result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
-						} else {
-							// we're not yet ready for invocation type inference
-							result = provisionalResult;
+					BoundSet provisionalResult = null;
+					BoundSet result = null;
+					if ((inferenceLevel & Scope.APPLICABILITY) != 0) {
+
+						// ---- 18.5.1 (Applicability): ----
+						boolean isDiamond = originalMethod.isConstructor()
+								&& invocationSite instanceof Expression
+								&& ((Expression)invocationSite).isPolyExpression(originalMethod);
+						if (arguments.length == parameters.length) {
+							infCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
+							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
+							provisionalResult = infCtx18.solve();
+						}
+						if (provisionalResult == null && originalMethod.isVarargs()) {
+							// check for variable-arity applicability
+							infCtx18 = invocationSite.freshInferenceContext(scope); // start over
+							infCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;
+							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
+							provisionalResult = infCtx18.solve();
 						}
+						if (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {
+							infCtx18.storedSolution = provisionalResult;
+						}
+					} else {
+						provisionalResult = infCtx18.storedSolution;
+					}
+					result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()
+
+					TypeBinding expectedType = invocationSite.invocationTargetType();
+					boolean hasReturnProblem = false;
+					boolean invocationTypeInferred = false;
+					if ((inferenceLevel & Scope.INVOCATION_TYPE) != 0 // requested?
+							&& (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT)) { // possible?
+
+						// ---- 18.5.2 (Invocation type): ----
+						result = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);
+						invocationTypeInferred = true;
+						hasReturnProblem |= result == null;
+						if (hasReturnProblem)
+							result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
+					} else {
+						// we're not yet ready for invocation type inference
+						result = provisionalResult;
+					}
+
+					if (result != null) {
+						// assemble the solution etc:
 						TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
 						if (solutions != null) {
 							
 							methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
-							
-							if (InferenceContext18.SIMULATE_BUG_JDK_8026527 && expectedType != null && methodSubstitute.returnType instanceof ReferenceBinding)
-								hasReturnProblem &= !methodSubstitute.returnType.erasure().isCompatibleWith(expectedType);
-							if (hasReturnProblem) {
-								ProblemMethodBinding problemMethod = new ProblemMethodBinding(methodSubstitute, methodSubstitute.selector, parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);
-								problemMethod.returnType = invocationSite.invocationTargetType();
-								problemMethod.inferenceContext = infCtx18;
-								return problemMethod;
-							}
-							if (invocationSite instanceof Invocation) {
-								Invocation invocation = (Invocation)invocationSite;
-								invocation.setInferenceKind(checkKind);
+							if (hasReturnProblem) { // illegally working from the provisional result?
+								MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
+								if (problemMethod instanceof ProblemMethodBinding)
+									return problemMethod;
 							}
 							if (invocationTypeInferred) {
-								if (invocationSite instanceof PolyExpression)
-									((PolyExpression) invocationSite).markInferenceFinished();									
-								infCtx18.rebindInnerPolies(result, arguments);
+								infCtx18.rebindInnerPolies(result, methodSubstitute.parameters);
+								return methodSubstitute.boundCheck18(scope, arguments);
+							} else {
+								if (invocationSite instanceof Invocation)
+									((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later
+								return methodSubstitute;
 							}
-							break computeSubstitutes;
 						}
 					}
 					return null;
@@ -211,6 +250,43 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		return methodSubstitute;
 	}
 
+	MethodBinding boundCheck18(Scope scope, TypeBinding[] arguments) {
+		Substitution substitution = this;
+		ParameterizedGenericMethodBinding methodSubstitute = this;
+		TypeVariableBinding[] originalTypeVariables = this.originalMethod.typeVariables;
+		// mostly original extract from above, TODO: remove stuff that's no longer needed in 1.8+
+		for (int i = 0, length = originalTypeVariables.length; i < length; i++) {
+		    TypeVariableBinding typeVariable = originalTypeVariables[i];
+		    TypeBinding substitute = methodSubstitute.typeArguments[i]; // retain for diagnostics
+		    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, 
+		       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references
+		       that constitute the inference per se.
+		     */ 
+		    TypeBinding substituteForChecks;
+		    if (substitute instanceof TypeVariableBinding) {
+		    	substituteForChecks = substitute;
+		    } else {
+		    	substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(originalTypeVariables, null, scope), substitute); // while using this for bounds check
+		    }
+		    
+			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope)) {
+				case TypeConstants.MISMATCH :
+			        // incompatible due to bound check
+					int argLength = arguments.length;
+					TypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable
+					System.arraycopy(arguments, 0, augmentedArguments, 0, argLength);
+					augmentedArguments[argLength] = substitute;
+					augmentedArguments[argLength+1] = typeVariable;
+			        return new ProblemMethodBinding(methodSubstitute, this.originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);
+				case TypeConstants.UNCHECKED :
+					// tolerate unchecked bounds
+					methodSubstitute.tagBits |= TagBits.HasUncheckedTypeArgumentForBoundCheck;
+					break;
+			}
+		}
+		return null;
+	}
+
 	/**
 	 * Collect argument type mapping, handling varargs
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 9032411..95d57a6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -63,6 +63,17 @@ public abstract class Scope {
 	public static final int NOT_RELATED = 0;
 	public static final int MORE_GENERIC = 1;
 
+	/*
+	 * Flags for PGMB.computeCompatibleMethod() and its callers, to request
+	 * which of two levels of inference should be performed (or both).
+	 */
+	/** Request Invocation Applicability Inference (18.5.1). */
+	public static final int APPLICABILITY = 1;
+	/** Request Invocation Type Inference (18.5.2). */
+	public static final int INVOCATION_TYPE = 2;
+	/** Request both {@link #APPLICABILITY} and {@link #INVOCATION_TYPE} inference. */
+	public static final int FULL_INFERENCE = APPLICABILITY | INVOCATION_TYPE;
+
 	public int kind;
 	public Scope parent;
 
@@ -657,8 +668,8 @@ public abstract class Scope {
 	 * Will answer a substituted method in case the method was generic and type inference got triggered;
 	 * in case the method was originally compatible, then simply answer it back.
 	 */
-	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite) {
-		return computeCompatibleMethod(method, arguments, invocationSite, false);
+	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, int inferenceLevel) {
+		return computeCompatibleMethod(method, arguments, invocationSite, inferenceLevel, false);
 	}	
 	/**
 	 * Internal use only
@@ -666,7 +677,9 @@ public abstract class Scope {
 	 * Will answer a substituted method in case the method was generic and type inference got triggered;
 	 * in case the method was originally compatible, then simply answer it back.
 	 */
-	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, boolean tiebreakingVarargsMethods) {
+	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments,
+			InvocationSite invocationSite, int inferenceLevel, boolean tiebreakingVarargsMethods)
+	{
 		TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();
 		TypeBinding[] parameters = method.parameters;
 		TypeVariableBinding[] typeVariables = method.typeVariables;
@@ -700,7 +713,7 @@ public abstract class Scope {
 				arguments = newArgs;
 			else  // ensure that computeCompatibleMethod() below can update arguments without harming our caller: (TODO: always copy before the loop? only in 1.8?)
 				System.arraycopy(arguments, 0, arguments=new TypeBinding[argLength], 0, argLength);
-			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);
+			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite, inferenceLevel);
 			if (method == null) return null; // incompatible
 			if (!method.isValidBinding()) return method; // bound check issue is taking precedence
 		} else if (genericTypeArguments != null && compilerOptions.complianceLevel < ClassFileConstants.JDK1_7) {
@@ -718,7 +731,7 @@ public abstract class Scope {
 			if (CompilerOptions.tolerateIllegalAmbiguousVarargsInvocation && compilerOptions.complianceLevel < ClassFileConstants.JDK1_7)
 				tiebreakingVarargsMethods = false;
 		}
-		if ((compatibilityLevel = myParameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods, invocationSite)) > NOT_COMPATIBLE) {
+		if ((compatibilityLevel = parameterCompatibilityLevel18(method, arguments, tiebreakingVarargsMethods, invocationSite)) > NOT_COMPATIBLE) {
 			if (compatibilityLevel == VARARGS_COMPATIBLE) {
 				TypeBinding varargsElementType = method.parameters[method.parameters.length - 1].leafComponentType();
 				if (varargsElementType instanceof ReferenceBinding) {
@@ -741,11 +754,64 @@ public abstract class Scope {
 		return null; // incompatible
 	}
 
-	// FIXME(stephan): final integration into the code
-	private int myParameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
+	private int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
 		if (site instanceof Invocation) {
-			if (((Invocation) site).inferenceKind() > 0)
-				return COMPATIBLE; // inference is responsible, no need to recheck
+			Invocation invocation = (Invocation) site;
+			if (method instanceof ParameterizedGenericMethodBinding) {
+				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
+				if (infCtx != null)
+					return COMPATIBLE; // inference is responsible, no need to recheck
+			}
+			// collect inner invocations where the outer did not involve any inference:
+			Expression[] invocationArguments = invocation.arguments();
+			if (invocationArguments != null) {
+				int argLen = invocationArguments.length;
+				boolean isVarArgs = false;
+				for (int i = 0; i < argLen; i++) {
+					Expression invocArg = invocationArguments[i];
+					if (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?
+						Invocation innerPoly = (Invocation) invocArg;
+						TypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, false);
+						if (targetType == null && method.isVarargs()) {
+							isVarArgs = true;
+							targetType = InferenceContext18.getParameter(method.parameters, i, true);
+						}
+						TypeBinding resolvedType = invocArg.resolvedType; 
+						if (!resolvedType.isCompatibleWith(targetType, this)) {
+							MethodBinding innerBinding = innerPoly.binding();
+							if (innerBinding instanceof ParameterizedGenericMethodBinding) { // FIXME: does this happen?
+								InferenceContext18 infCtx18 = innerPoly.getInferenceContext((ParameterizedGenericMethodBinding) innerBinding);
+								if (infCtx18 != null) {
+									// not detected as compatible, because inference still needs to complete?
+									MethodBinding solution = infCtx18.getInvocationTypeInferenceSolution(
+																		innerPoly.binding().original(), innerPoly, targetType);
+									if (solution != null) {
+										if (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))
+											return isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;
+									} else {
+										MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(targetType, innerPoly.binding());
+										if (problemMethod != null && problemMethod.isValidBinding())
+											return COMPATIBLE;
+										return NOT_COMPATIBLE;
+									}
+								} else if (innerPoly instanceof AllocationExpression) {
+									// not detected as compatible, because its a diamond whose type hasn't yet been inferred?
+									TypeBinding[] typeArguments = resolvedType.typeArguments();
+									if (typeArguments != null && typeArguments.length == 0) {
+										AllocationExpression alloc = (AllocationExpression) innerPoly;
+										if ((alloc.type.bits & ASTNode.IsDiamond) != 0) {
+											// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference
+											if (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))
+												return COMPATIBLE;
+											return NOT_COMPATIBLE;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
 		}
 		return parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);
 	}
@@ -1083,7 +1149,7 @@ public abstract class Scope {
 			// argument type compatibility check
 			for (int i = startFoundSize; i < foundSize; i++) {
 				MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
-				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, APPLICABILITY);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding()) {
 						if (concreteMatch != null && environment().methodVerifier().areMethodsCompatible(concreteMatch, compatibleMethod))
@@ -1107,6 +1173,8 @@ public abstract class Scope {
 					return problemMethod; // can be null
 				concreteMatch = candidates[0];
 			}
+			// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+			concreteMatch = inferInvocationType(invocationSite, concreteMatch, argumentTypes);
 			compilationUnitScope().recordTypeReferences(concreteMatch.thrownExceptions);
 			return concreteMatch;
 		}
@@ -1178,7 +1246,7 @@ public abstract class Scope {
 				// targeting a generic method could find an exact match with variable return type
 				if (invocationSite.genericTypeArguments() != null) {
 					// computeCompatibleMethod(..) will return a PolymorphicMethodBinding if needed
-					exactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);
+					exactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite, FULL_INFERENCE);
 				} else if ((exactMethod.tagBits & TagBits.AnnotationPolymorphicSignature) != 0) {
 					// generate polymorphic method
 					return this.environment().createPolymorphicMethod(exactMethod, argumentTypes);
@@ -1556,13 +1624,22 @@ public abstract class Scope {
 			// argument type compatibility check
 			for (int i = 0; i < foundSize; i++) {
 				MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
-				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, APPLICABILITY);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding()) {
 						if (foundSize == 1 && compatibleMethod.canBeSeenBy(receiverType, invocationSite, this)) {
 							// return the single visible match now
 							if (searchForDefaultAbstractMethod)
 								return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, compatibleMethod);
+// ==== 1.8: Finalize type inference of generic methods: ====
+							MethodBinding improved = inferInvocationType(invocationSite, compatibleMethod, argumentTypes);
+							if (improved.isValidBinding()) {
+								compatibleMethod = improved;
+							} else {
+								problemMethod = improved;
+								continue;
+							}
+// ==== 1.8 ====
 							unitScope.recordTypeReferences(compatibleMethod.thrownExceptions);
 							return compatibleMethod;
 						}
@@ -1657,8 +1734,10 @@ public abstract class Scope {
 			case 1 :
 				if (searchForDefaultAbstractMethod)
 					return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);
-				unitScope.recordTypeReferences(candidates[0].thrownExceptions);
-				return candidates[0];
+				// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+				candidate = inferInvocationType(invocationSite, candidates[0], argumentTypes);
+				unitScope.recordTypeReferences(candidate.thrownExceptions);
+				return candidate;
 			default :
 				break;
 		}
@@ -2206,7 +2285,7 @@ public abstract class Scope {
 			if (methodBinding != null && methodBinding.canBeSeenBy(invocationSite, this)) {
 			    // targeting a non generic constructor with type arguments ?
 			    if (invocationSite.genericTypeArguments() != null)
-			    	methodBinding = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
+			    	methodBinding = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, FULL_INFERENCE);
 				return methodBinding;
 			}
 			MethodBinding[] methods = receiverType.getMethods(TypeConstants.INIT, argumentTypes.length);
@@ -2220,7 +2299,7 @@ public abstract class Scope {
 			int compatibleIndex = 0;
 			MethodBinding problemMethod = null;
 			for (int i = 0, length = methods.length; i < length; i++) {
-				MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite, APPLICABILITY);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding())
 						compatible[compatibleIndex++] = compatibleMethod;
@@ -2242,7 +2321,10 @@ public abstract class Scope {
 				if (method.canBeSeenBy(invocationSite, this))
 					visible[visibleIndex++] = method;
 			}
-			if (visibleIndex == 1) return visible[0];
+			if (visibleIndex == 1) {
+				// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+				return inferInvocationType(invocationSite, visible[0], argumentTypes);
+			}
 			if (visibleIndex == 0)
 				return new ProblemMethodBinding(
 					compatible[0],
@@ -2505,7 +2587,7 @@ public abstract class Scope {
 								if (foundProblem == null)
 									foundProblem = possible; // answer as error case match
 							} else if (possible.isStatic()) {
-								MethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite);
+								MethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite, APPLICABILITY);
 								if (compatibleMethod != null) {
 									if (compatibleMethod.isValidBinding()) {
 										if (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {
@@ -2536,9 +2618,13 @@ public abstract class Scope {
 					}
 				}
 				if (visible != null) {
-					MethodBinding[] temp = new MethodBinding[visible.size];
-					visible.copyInto(temp);
-					foundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);
+					if (visible.size == 1) {
+						foundMethod = (MethodBinding) visible.elementAt(0);
+					} else {
+						MethodBinding[] temp = new MethodBinding[visible.size];
+						visible.copyInto(temp);
+						foundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);
+					}
 				}
 			}
 		}
@@ -4181,7 +4267,8 @@ public abstract class Scope {
 							methodToTest = pNext.originalMethod;
 						}
 					}
-					MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, tieBreakInvocationSite, level == VARARGS_COMPATIBLE);
+					MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters,
+							tieBreakInvocationSite, INVOCATION_TYPE, level == VARARGS_COMPATIBLE);
 					/* There are 4 choices to consider with current & next :
 					 foo(B) & foo(A) where B extends A
 					 1. the 2 methods are equal (both accept each others parameters) -> want to continue
@@ -4205,8 +4292,10 @@ public abstract class Scope {
 		if (count == 1) {
 			for (int i = 0; i < visibleSize; i++) {
 				if (moreSpecific[i] != null) {
-					compilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);
-					return visible[i];
+					// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+					MethodBinding candidate = inferInvocationType(invocationSite, visible[i], argumentTypes);
+					compilationUnitScope().recordTypeReferences(candidate.thrownExceptions);
+					return candidate;
 				}
 			}
 		} else if (count == 0) {
@@ -4323,7 +4412,8 @@ public abstract class Scope {
 				if (mostSpecificExceptions != null && mostSpecificExceptions != current.thrownExceptions) {
 					return new MostSpecificExceptionMethodBinding(current, mostSpecificExceptions);
 				}
-				return current;
+				// 1.8: Before returning give inference a chance to perform outstanding tasks (18.5.2):
+				return inferInvocationType(invocationSite, current, argumentTypes);
 			}
 		}
 
@@ -4554,7 +4644,7 @@ public abstract class Scope {
 	   that could instead be invoked with identical results. Return null if no compatible, visible, most specific method
 	   could be found. This method is modeled after Scope.getConstructor and Scope.getMethod.
 	 */
-	public MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final InvocationSite allocationSite) {
+	public MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final Invocation allocationSite) {
 		TypeVariableBinding[] classTypeVariables = allocationType.typeVariables();
 		int classTypeVariablesArity = classTypeVariables.length;
 		MethodBinding[] methods = allocationType.getMethods(TypeConstants.INIT, argumentTypes.length);
@@ -4670,7 +4760,7 @@ public abstract class Scope {
 		MethodBinding[] compatible = new MethodBinding[sfi];
 		int compatibleIndex = 0;
 		for (int i = 0; i < sfi; i++) {
-			MethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite);
+			MethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite, APPLICABILITY);
 			if (compatibleMethod != null) {
 				if (compatibleMethod.isValidBinding())
 					compatible[compatibleIndex++] = compatibleMethod;
@@ -4690,6 +4780,10 @@ public abstract class Scope {
 		if (visibleIndex == 0) {
 			return null;
 		}
+		if (visibleIndex == 1) {
+			// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+			visible[0] = inferInvocationType(allocationSite, visible[0], argumentTypes);
+		}
 		return visibleIndex == 1 ? visible[0] : mostSpecificMethodBinding(visible, visibleIndex, argumentTypes, allocationSite, allocationType);
 	}
 
@@ -4762,4 +4856,21 @@ public abstract class Scope {
 			}
 		}
 	}
+
+	/**
+	 * Given a selected applibable method, check if it has an unfinished InferenceContext18 associated.
+	 * If so perform the outstanding Invocation Type Inference and return the improved method,
+	 * otherwise return the applicable method unchanged.
+	 */
+	protected MethodBinding inferInvocationType(InvocationSite invocationSite, MethodBinding applicable, TypeBinding[] argumentTypes) {
+		if (applicable instanceof ParameterizedGenericMethodBinding && invocationSite instanceof Invocation) {
+			Invocation invocation = (Invocation) invocationSite;
+			ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) applicable;
+			InferenceContext18 infCtx18 = invocation.getInferenceContext(parameterizedMethod);
+			if (infCtx18 != null && !infCtx18.hasFinished) {
+				return infCtx18.inferInvocationType(invocation, argumentTypes, parameterizedMethod);
+			}
+		}
+		return applicable;
+	}
 }
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
index ba04e50..d567778 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
+ *     Stephan Herrmann - Contribution for
+ *								Bug 424167 - [1.8] Fully integrate type inference with overload resolution     
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -398,7 +400,7 @@ public MethodBinding findMethodForArray(ArrayBinding receiverType, char[] select
 	if (methodBinding == null)
 		return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);
 	if (methodBinding.isValidBinding()) {
-	    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
+	    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, Scope.FULL_INFERENCE);
 	    if (compatibleMethod == null)
 			return new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);
 	    methodBinding = compatibleMethod;
@@ -544,7 +546,7 @@ public MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[]
 	MethodBinding[] compatible = new MethodBinding[methods.length];
 	int compatibleIndex = 0;
 	for (int i = 0, length = methods.length; i < length; i++) {
-	    MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite);
+	    MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite, Scope.APPLICABILITY);
 		if (compatibleMethod != null)
 			compatible[compatibleIndex++] = compatibleMethod;
 	}
@@ -560,7 +562,8 @@ public MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[]
 		}
 	}
 	if (visibleIndex == 1) {
-		return visible[0];
+		// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
+		return inferInvocationType(invocationSite, visible[0], argumentTypes);
 	}
 	if (visibleIndex == 0) {
 		return new ProblemMethodBinding(compatible[0], TypeConstants.INIT, compatible[0].parameters, ProblemReasons.NotVisible);
