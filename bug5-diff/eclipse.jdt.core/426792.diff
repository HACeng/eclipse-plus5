commit 06d5ad0c6e4971f283c2f47bfc7f9df941ae34e8
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Jan 28 15:33:23 2014 +0100

    Bug 426792 - [1.8][inference][impl] generify new type inference engine

6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
70	71	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
7	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
9	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
5	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
43	44	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
10	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 0e6cce9..90826e9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -56,7 +57,6 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.problem.ShouldNotImplement;
 import org.eclipse.jdt.internal.compiler.util.Messages;
 
-@SuppressWarnings({"rawtypes", "unchecked"})
 public abstract class Expression extends Statement implements ExpressionContext {
 
 	public Constant constant;
@@ -827,15 +827,15 @@ public void generateOptimizedStringConcatenationCreation(BlockScope blockScope,
 }
 
 private MethodBinding[] getAllOriginalInheritedMethods(ReferenceBinding binding) {
-	ArrayList collector = new ArrayList();
+	ArrayList<MethodBinding> collector = new ArrayList<MethodBinding>();
 	getAllInheritedMethods0(binding, collector);
 	for (int i = 0, len = collector.size(); i < len; i++) {
-		collector.set(i, ((MethodBinding)collector.get(i)).original());
+		collector.set(i, collector.get(i).original());
 	}
-	return (MethodBinding[]) collector.toArray(new MethodBinding[collector.size()]);
+	return collector.toArray(new MethodBinding[collector.size()]);
 }
 
-private void getAllInheritedMethods0(ReferenceBinding binding, ArrayList collector) {
+private void getAllInheritedMethods0(ReferenceBinding binding, ArrayList<MethodBinding> collector) {
 	if (!binding.isInterface()) return;
 	MethodBinding[] methodBindings = binding.methods();
 	for (int i = 0, max = methodBindings.length; i < max; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
index 824c2bc..be56cf8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
@@ -22,6 +22,7 @@
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 425460 - [1.8] [inference] Type not inferred on stream.toArray
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -117,7 +118,7 @@ public void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceCon
 	}
 }
 
-void collectInferenceVariables(Set variables) {
+void collectInferenceVariables(Set<InferenceVariable> variables) {
 	this.leafComponentType.collectInferenceVariables(variables);
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index e8be084..09a79c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.ast.Wildcard;
  * Implementation of 18.1.3 in JLS8.
  * This class is also responsible for incorporation as defined in 18.3.
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 class BoundSet {
 
 	static final BoundSet TRUE = new BoundSet();	// empty set of bounds
@@ -41,9 +40,9 @@ class BoundSet {
 	 * These are internally stored in three sets, one for each of the relations.
 	 */
 	private class ThreeSets {
-		Set/*<TypeBound>*/ superBounds;
-		Set/*<TypeBound>*/ sameBounds;
-		Set/*<TypeBound>*/ subBounds;
+		Set<TypeBound> superBounds;
+		Set<TypeBound> sameBounds;
+		Set<TypeBound> subBounds;
 		TypeBinding	instantiation;
 		
 		public ThreeSets() {
@@ -53,15 +52,15 @@ class BoundSet {
 		public void addBound(TypeBound bound) {
 			switch (bound.relation) {
 				case ReductionResult.SUPERTYPE:
-					if (this.superBounds == null) this.superBounds = new HashSet();
+					if (this.superBounds == null) this.superBounds = new HashSet<TypeBound>();
 					this.superBounds.add(bound);
 					break;
 				case ReductionResult.SAME:
-					if (this.sameBounds == null) this.sameBounds = new HashSet();
+					if (this.sameBounds == null) this.sameBounds = new HashSet<TypeBound>();
 					this.sameBounds.add(bound);
 					break;
 				case ReductionResult.SUBTYPE:
-					if (this.subBounds == null) this.subBounds = new HashSet();
+					if (this.subBounds == null) this.subBounds = new HashSet<TypeBound>();
 					this.subBounds.add(bound);
 					break;
 				default:
@@ -71,10 +70,10 @@ class BoundSet {
 		// pre: this.superBounds != null
 		public TypeBinding[] lowerBounds(boolean onlyProper) {
 			TypeBinding[] boundTypes = new TypeBinding[this.superBounds.size()];
-			Iterator it = this.superBounds.iterator();
+			Iterator<TypeBound> it = this.superBounds.iterator();
 			int i = 0;
 			while(it.hasNext()) {
-				TypeBinding boundType = ((TypeBound)it.next()).right;
+				TypeBinding boundType = it.next().right;
 				if (!onlyProper || boundType.isProperType(true))
 					boundTypes[i++] = boundType;
 			}
@@ -89,10 +88,10 @@ class BoundSet {
 		public TypeBinding[] upperBounds(boolean onlyProper) {
 			ReferenceBinding[] rights = new ReferenceBinding[this.subBounds.size()];
 			TypeBinding simpleUpper = null;
-			Iterator it = this.subBounds.iterator();
+			Iterator<TypeBound> it = this.subBounds.iterator();
 			int i = 0;
 			while(it.hasNext()) {
-				TypeBinding right=((TypeBound)it.next()).right;
+				TypeBinding right=it.next().right;
 				if (!onlyProper || right.isProperType(true)) {
 					if (right instanceof ReferenceBinding) {
 						rights[i++] = (ReferenceBinding) right;
@@ -121,10 +120,10 @@ class BoundSet {
 				return true;
 			return false;
 		}
-		private boolean hasDependency(Set someBounds, InferenceVariable var) {
-			Iterator bIt = someBounds.iterator();
+		private boolean hasDependency(Set<TypeBound> someBounds, InferenceVariable var) {
+			Iterator<TypeBound> bIt = someBounds.iterator();
 			while (bIt.hasNext()) {
-				TypeBound bound = (TypeBound) bIt.next();
+				TypeBound bound = bIt.next();
 				if (bound.right == var || bound.right.mentionsAny(new TypeBinding[] {var}, -1)) //$IDENTITY-COMPARISON$ InferenceVariable
 					return true;
 			}
@@ -162,20 +161,20 @@ class BoundSet {
 		public ThreeSets copy() {
 			ThreeSets copy = new ThreeSets();
 			if (this.superBounds != null)
-				copy.superBounds = new HashSet(this.superBounds);
+				copy.superBounds = new HashSet<TypeBound>(this.superBounds);
 			if (this.sameBounds != null)
-				copy.sameBounds = new HashSet(this.sameBounds);
+				copy.sameBounds = new HashSet<TypeBound>(this.sameBounds);
 			if (this.subBounds != null)
-				copy.subBounds = new HashSet(this.subBounds);
+				copy.subBounds = new HashSet<TypeBound>(this.subBounds);
 			copy.instantiation = this.instantiation;
 			return copy;
 		}
 		public TypeBinding findSingleWrapperType() {
 			TypeBinding wrapperBound = null;
 			if (this.subBounds != null) {
-				Iterator it = this.subBounds.iterator();
+				Iterator<TypeBound> it = this.subBounds.iterator();
 				while(it.hasNext()) {
-					TypeBinding boundType = ((TypeBound)it.next()).right;
+					TypeBinding boundType = it.next().right;
 					if ((boundType).isProperType(true)) {
 						switch (boundType.id) {
 							case TypeIds.T_JavaLangByte:
@@ -194,9 +193,9 @@ class BoundSet {
 				}		
 			}
 			if (this.superBounds != null) {
-				Iterator it = this.superBounds.iterator();
+				Iterator<TypeBound> it = this.superBounds.iterator();
 				while(it.hasNext()) {
-					TypeBinding boundType = ((TypeBound)it.next()).right;
+					TypeBinding boundType = it.next().right;
 					if ((boundType).isProperType(true)) {
 						switch (boundType.id) {
 							case TypeIds.T_JavaLangByte:
@@ -218,18 +217,18 @@ class BoundSet {
 		}
 	}
 	// main storage of type bounds:
-	HashMap/*<InferenceVariable,ThreeSets>*/ boundsPerVariable = new HashMap();
+	HashMap<InferenceVariable, ThreeSets> boundsPerVariable = new HashMap<InferenceVariable, ThreeSets>();
 	
 	/**
 	 * 18.1.3 bullet 4: G<α1, ..., αn> = capture(G<A1, ..., An>)
 	 * On both sides we only enter types with nonnull arguments. 
 	 */
-	HashMap/*<ParameterizedTypeBinding,ParameterizedTypeBinding>*/ captures = new HashMap();
+	HashMap<ParameterizedTypeBinding,ParameterizedTypeBinding> captures = new HashMap<ParameterizedTypeBinding, ParameterizedTypeBinding>();
 	/** 18.1.3 bullet 5: throws α */
-	Set/*<InferenceVariable>*/ inThrows = new HashSet();
+	Set<InferenceVariable> inThrows = new HashSet<InferenceVariable>();
 
 	// avoid attempts to incorporate the same pair of type bounds more than once:
-	Set/*<TypeBound>*/ incorporatedBounds = new HashSet();
+	Set<TypeBound> incorporatedBounds = new HashSet<TypeBound>();
 
 	public BoundSet() {}
 	
@@ -251,15 +250,15 @@ class BoundSet {
 	/** Answer a flat representation of this BoundSet. */
 	public TypeBound[] flatten() {
 		int size = 0;
-		Iterator outerIt = this.boundsPerVariable.values().iterator();
+		Iterator<ThreeSets> outerIt = this.boundsPerVariable.values().iterator();
 		while (outerIt.hasNext())
-			size += ((ThreeSets)outerIt.next()).size();
+			size += outerIt.next().size();
 		TypeBound[] collected = new TypeBound[size];
 		if (size == 0) return collected;
 		outerIt = this.boundsPerVariable.values().iterator();
 		int idx = 0;
 		while (outerIt.hasNext())
-			idx = ((ThreeSets)outerIt.next()).flattenInto(collected, idx);
+			idx = outerIt.next().flattenInto(collected, idx);
 		return collected;
 	}
 
@@ -269,10 +268,10 @@ class BoundSet {
 	 */
 	public BoundSet copy() {
 		BoundSet copy = new BoundSet();
-		Iterator setsIterator = this.boundsPerVariable.entrySet().iterator();
+		Iterator<Entry<InferenceVariable, ThreeSets>> setsIterator = this.boundsPerVariable.entrySet().iterator();
 		while (setsIterator.hasNext()) {
-			Map.Entry entry = (Entry) setsIterator.next();
-			copy.boundsPerVariable.put(entry.getKey(), ((ThreeSets)entry.getValue()).copy());
+			Entry<InferenceVariable, ThreeSets> entry = setsIterator.next();
+			copy.boundsPerVariable.put(entry.getKey(), entry.getValue().copy());
 		}
 		copy.inThrows.addAll(this.inThrows);
 		copy.captures.putAll(this.captures);
@@ -280,7 +279,7 @@ class BoundSet {
 	}
 
 	public void addBound(TypeBound bound) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(bound.left);
+		ThreeSets three = this.boundsPerVariable.get(bound.left);
 		if (three == null)
 			this.boundsPerVariable.put(bound.left, (three = new ThreeSets()));
 		three.addBound(bound);
@@ -300,14 +299,14 @@ class BoundSet {
 	}
 
 	public boolean isInstantiated(InferenceVariable inferenceVariable) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(inferenceVariable);
+		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
 		if (three != null)
 			return three.instantiation != null;
 		return false;
 	}
 
 	public TypeBinding getInstantiation(InferenceVariable inferenceVariable) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(inferenceVariable);
+		ThreeSets three = this.boundsPerVariable.get(inferenceVariable);
 		if (three != null)
 			return three.instantiation;
 		return null;
@@ -407,12 +406,12 @@ class BoundSet {
 			 *  
 			 *    "The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. ..."
 			 */
-			Iterator captIter = this.captures.entrySet().iterator();
+			Iterator<Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captIter = this.captures.entrySet().iterator();
 			while (captIter.hasNext()) {
 				hasUpdate = true;
-				Map.Entry capt = (Entry) captIter.next();
-				ParameterizedTypeBinding gAlpha = (ParameterizedTypeBinding) capt.getKey();
-				ParameterizedTypeBinding gA = (ParameterizedTypeBinding) capt.getValue();
+				Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();
+				ParameterizedTypeBinding gAlpha = capt.getKey();
+				ParameterizedTypeBinding gA = capt.getValue();
 				ReferenceBinding g = (ReferenceBinding) gA.original();
 				TypeVariableBinding[] parameters = g.typeVariables();
 				for (int i = 0; i < parameters.length; i++) {
@@ -425,14 +424,14 @@ class BoundSet {
 					if (ai instanceof WildcardBinding) {
 						WildcardBinding wildcardBinding = (WildcardBinding)ai;
 						TypeBinding t = wildcardBinding.bound;
-						ThreeSets three = (ThreeSets) this.boundsPerVariable.get(alpha);
+						ThreeSets three = this.boundsPerVariable.get(alpha);
 						if (three != null) {
-							Iterator it;
+							Iterator<TypeBound> it;
 							if (three.sameBounds != null) {
 								//  α = R implies false
 								it = three.sameBounds.iterator();
 								while (it.hasNext()) {
-									TypeBound bound = (TypeBound) it.next();
+									TypeBound bound = it.next();
 									if (!(bound.right instanceof InferenceVariable))
 										return false;
 								}
@@ -442,7 +441,7 @@ class BoundSet {
 								// α <: R implies ⟨θ Bi <: R⟩				(else) 
 								it = three.subBounds.iterator();
 								while (it.hasNext()) {
-									TypeBound bound = (TypeBound) it.next();
+									TypeBound bound = it.next();
 									if (!(bound.right instanceof InferenceVariable)) {
 										TypeBinding r = bound.right;
 										TypeBinding bi1 = pi.firstBound;
@@ -473,7 +472,7 @@ class BoundSet {
 								//  R <: α implies false	 (else) 
 								it = three.superBounds.iterator();
 								while (it.hasNext()) {
-									TypeBound bound = (TypeBound) it.next();
+									TypeBound bound = it.next();
 									if (!(bound.right instanceof InferenceVariable)) {
 										if (wildcardBinding.boundKind == Wildcard.SUPER)
 											reduceOneConstraint(context, new ConstraintTypeFormula(bound.right, t, ReductionResult.SUBTYPE));
@@ -621,7 +620,7 @@ class BoundSet {
 		TypeBinding[] tis = t.typeArguments();
 		if (sis == null || tis == null || sis.length != tis.length)
 			return null;
-		List/*<ConstraintFormula>*/ result = new ArrayList(); 
+		List<ConstraintTypeFormula> result = new ArrayList<ConstraintTypeFormula>(); 
 		for (int i = 0; i < sis.length; i++) {
 			TypeBinding si = sis[i];
 			TypeBinding ti = tis[i];
@@ -630,7 +629,7 @@ class BoundSet {
 			result.add(new ConstraintTypeFormula(si, ti, ReductionResult.SAME, isSoft));
 		}
 		if (result.size() > 0)
-			return (ConstraintFormula[])result.toArray(new ConstraintFormula[result.size()]);
+			return result.toArray(new ConstraintFormula[result.size()]);
 		return null;
 	}
 
@@ -670,16 +669,16 @@ class BoundSet {
 	 * Does this bound set define a direct dependency between the two given inference variables? 
 	 */
 	public boolean dependsOnResolutionOf(InferenceVariable alpha, InferenceVariable beta) {
-		Iterator captureIter = this.captures.entrySet().iterator();
+		Iterator<Map.Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captureIter = this.captures.entrySet().iterator();
 		boolean betaIsInCaptureLhs = false;
 		while (captureIter.hasNext()) { // TODO: optimization: consider separate index structure (by IV)
-			Map.Entry entry = (Entry) captureIter.next();
-			ParameterizedTypeBinding g = (ParameterizedTypeBinding) entry.getKey();
+			Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> entry = captureIter.next();
+			ParameterizedTypeBinding g = entry.getKey();
 			for (int i = 0; i < g.arguments.length; i++) {
 				if (g.arguments[i] == alpha) { //$IDENTITY-COMPARISON$ InferenceVariable
 					// An inference variable α appearing on the left-hand side of a bound of the form G<..., α, ...> = capture(G<...>)
 					// depends on the resolution of every other inference variable mentioned in this bound (on both sides of the = sign).
-					ParameterizedTypeBinding captured = (ParameterizedTypeBinding) entry.getValue();
+					ParameterizedTypeBinding captured = entry.getValue();
 					if (captured.mentionsAny(new TypeBinding[]{beta}, -1/*don't care about index*/))
 						return true;
 					if (g.mentionsAny(new TypeBinding[]{beta}, i)) // exclude itself 
@@ -690,11 +689,11 @@ class BoundSet {
 			}
 		}
 		if (betaIsInCaptureLhs) { // swap α and β in the rule text to cover "then β depends on the resolution of α"
-			ThreeSets sets = (ThreeSets) this.boundsPerVariable.get(beta);
+			ThreeSets sets = this.boundsPerVariable.get(beta);
 			if (sets != null && sets.hasDependency(alpha))
 				return true;
 		} else {
-			ThreeSets sets = (ThreeSets) this.boundsPerVariable.get(alpha);
+			ThreeSets sets = this.boundsPerVariable.get(alpha);
 			if (sets != null && sets.hasDependency(beta))
 				return true;
 		}
@@ -702,10 +701,10 @@ class BoundSet {
 	}
 
 	// helper for 18.4
-	public boolean hasCaptureBound(Set variableSet) {
-		Iterator captureIter = this.captures.keySet().iterator();
+	public boolean hasCaptureBound(Set<InferenceVariable> variableSet) {
+		Iterator<ParameterizedTypeBinding> captureIter = this.captures.keySet().iterator();
 		while (captureIter.hasNext()) {
-			ParameterizedTypeBinding g = (ParameterizedTypeBinding) captureIter.next();
+			ParameterizedTypeBinding g = captureIter.next();
 			for (int i = 0; i < g.arguments.length; i++)
 				if (variableSet.contains(g.arguments[i]))
 					return true;
@@ -734,7 +733,7 @@ class BoundSet {
 	 * Answer all upper bounds for the given inference variable as defined by any bounds in this set. 
 	 */
 	public TypeBinding[] upperBounds(InferenceVariable variable, boolean onlyProper) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable);
 		if (three == null || three.subBounds == null)
 			return Binding.NO_TYPES;
 		return three.upperBounds(onlyProper);
@@ -745,7 +744,7 @@ class BoundSet {
 	 * Answer all lower bounds for the given inference variable as defined by any bounds in this set. 
 	 */
 	TypeBinding[] lowerBounds(InferenceVariable variable, boolean onlyProper) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable);
 		if (three == null || three.superBounds == null)
 			return Binding.NO_TYPES;
 		return three.lowerBounds(onlyProper);
@@ -762,9 +761,9 @@ class BoundSet {
 			buf.append('\t').append(flattened[i].toString()).append('\n');
 		}
 		buf.append("Capture Bounds:\n"); //$NON-NLS-1$
-		Iterator captIter = this.captures.entrySet().iterator();
+		Iterator<Map.Entry<ParameterizedTypeBinding,ParameterizedTypeBinding>> captIter = this.captures.entrySet().iterator();
 		while (captIter.hasNext()) {
-			Map.Entry capt = (Entry) captIter.next();
+			Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();
 			String lhs = String.valueOf(((TypeBinding)capt.getKey()).shortReadableName());
 			String rhs = String.valueOf(((TypeBinding)capt.getValue()).shortReadableName());
 			buf.append('\t').append(lhs).append(" = capt(").append(rhs).append(")\n"); //$NON-NLS-1$ //$NON-NLS-2$
@@ -773,7 +772,7 @@ class BoundSet {
 	}
 
 	public TypeBinding findWrapperTypeBound(InferenceVariable variable) {
-		ThreeSets three = (ThreeSets) this.boundsPerVariable.get(variable);
+		ThreeSets three = this.boundsPerVariable.get(variable);
 		if (three == null) return null;
 		return three.findSingleWrapperType();
 	}
@@ -784,19 +783,19 @@ class BoundSet {
 		// i) B2 contains a bound of one of the forms α = S or S <: α, where S is a wildcard-parameterized type, or ...
 		if (targetType.isBaseType()) return false;
 		if (InferenceContext18.parameterizedWithWildcard(targetType) != null) return false;
-		ThreeSets ts = (ThreeSets) this.boundsPerVariable.get(alpha);
+		ThreeSets ts = this.boundsPerVariable.get(alpha);
 		if (ts.sameBounds != null) {
-			Iterator bounds = ts.sameBounds.iterator();
+			Iterator<TypeBound> bounds = ts.sameBounds.iterator();
 			while (bounds.hasNext()) {
-				TypeBound bound = (TypeBound) bounds.next();
+				TypeBound bound = bounds.next();
 				if (InferenceContext18.parameterizedWithWildcard(bound.right) != null)
 					return true;
 			}
 		}
 		if (ts.superBounds != null) {
-			Iterator bounds = ts.superBounds.iterator();
+			Iterator<TypeBound> bounds = ts.superBounds.iterator();
 			while (bounds.hasNext()) {
-				TypeBound bound = (TypeBound) bounds.next();
+				TypeBound bound = bounds.next();
 				if (InferenceContext18.parameterizedWithWildcard(bound.right) != null)
 					return true;
 			}
@@ -804,12 +803,12 @@ class BoundSet {
 		// ii) B2 contains two bounds of the forms S1 <: α and S2 <: α, where
 		//     S1 and S2 have supertypes (4.10) that are two different parameterizations of the same generic class or interface.
 		if (ts.superBounds != null) {
-			List superBounds = new ArrayList(ts.superBounds);
+			ArrayList<TypeBound> superBounds = new ArrayList<TypeBound>(ts.superBounds);
 			int len = superBounds.size();
 			for (int i=0; i<len; i++) {
-				TypeBinding s1 = ((TypeBound)superBounds.get(i)).right;
+				TypeBinding s1 = superBounds.get(i).right;
 				for (int j=i+1; j<len; j++) {
-					TypeBinding s2 = ((TypeBound)superBounds.get(j)).right;
+					TypeBinding s2 = superBounds.get(j).right;
 					TypeBinding[] supers = superTypesWithCommonGenericType(s1, s2);
 					if (supers != null && !TypeBinding.equalsEquals(supers[0], supers[1]))
 						return true;
@@ -825,12 +824,12 @@ class BoundSet {
 		//   where there exists no type of the form G<...> that is a supertype of S, but the raw type G is a supertype of S.
 		if (!targetType.isParameterizedType()) return false;
 		TypeBinding g = targetType.original();
-		ThreeSets ts = (ThreeSets) this.boundsPerVariable.get(alpha);
-		Iterator boundIterator;
+		ThreeSets ts = this.boundsPerVariable.get(alpha);
+		Iterator<TypeBound> boundIterator;
 		if (ts.sameBounds != null) {
 			boundIterator = ts.sameBounds.iterator();
 			while (boundIterator.hasNext()) {
-				TypeBound b = (TypeBound) boundIterator.next();
+				TypeBound b = boundIterator.next();
 				if (superOnlyRaw(g, b.right, ctx18.environment))
 					return true;
 			}
@@ -838,7 +837,7 @@ class BoundSet {
 		if (ts.superBounds != null) {
 			boundIterator = ts.superBounds.iterator();
 			while (boundIterator.hasNext()) {
-				TypeBound b = (TypeBound) boundIterator.next();
+				TypeBound b = boundIterator.next();
 				if (superOnlyRaw(g, b.right, ctx18.environment))
 					return true;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
index 690fcfd..1c6e6a0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 GK Software AG.
+ * Copyright (c) 2013, 2014 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -31,7 +31,6 @@ import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
  * <li>Expression contains<sub>throws</sub> T</li>
  * </ul>
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 public class ConstraintExceptionFormula extends ConstraintFormula {
 
 	FunctionalExpression left;
@@ -98,7 +97,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			}
 			return TRUE;
 		} else {
-			List result = new ArrayList();
+			List<ConstraintFormula> result = new ArrayList<ConstraintFormula>();
 			actual: for (int i = 0; i < m; i++) {
 				for (int j = 0; j < thrown.length; j++)
 					if (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))
@@ -112,16 +111,16 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 		}
 	}
 
-	Collection inputVariables(final InferenceContext18 context) {
+	Collection<InferenceVariable> inputVariables(final InferenceContext18 context) {
 		// from 18.5.2.
 		if (this.left instanceof LambdaExpression) {
 			if (this.right instanceof InferenceVariable) {
-				return Collections.singletonList(this.right);
+				return Collections.singletonList((InferenceVariable)this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set variables = new HashSet();
+				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 				if (lambda.argumentsTypeElided()) {
 					// i)
 					int len = sam.parameters.length;
@@ -137,11 +136,11 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			}
 		} else if (this.left instanceof ReferenceExpression) {
 			if (this.right instanceof InferenceVariable) {
-				return Collections.singletonList(this.right);
+				return Collections.singletonList((InferenceVariable)this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope)) { // TODO: && this.left is inexact
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set variables = new HashSet();
+				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
 					sam.parameters[i].collectInferenceVariables(variables);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index fbc60fa..e8cb77c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -40,7 +40,6 @@ import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.InvocationRec
  * <li>Expression -> T</li>
  * </ul>
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 class ConstraintExpressionFormula extends ConstraintFormula {
 	Expression left;
 
@@ -155,7 +154,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					if (!lambda.isValueCompatible())
 						return FALSE;
 				}
-				List result = new ArrayList();
+				List<ConstraintFormula> result = new ArrayList<ConstraintFormula>();
 				if (!lambda.argumentsTypeElided()) {
 					Argument[] arguments = lambda.arguments();
 					for (int i = 0; i < parameters.length; i++)
@@ -221,7 +220,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		if (potentiallyApplicable == null)
 			return FALSE;
 		if (reference.isExactMethodReference()) {
-			List /*<ConstraintFormula>*/ newConstraints = new ArrayList();
+			List<ConstraintFormula> newConstraints = new ArrayList<ConstraintFormula>();
 			TypeBinding[] p = functionType.parameters;
 			int n = p.length;
 			TypeBinding[] pPrime = potentiallyApplicable.parameters;
@@ -333,7 +332,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (parameterizedType != null && parameterizedType.arguments != null) {
 				TypeBinding[] arguments = parameterizedType.arguments;
 				InferenceVariable[] betas = inferenceContext.addTypeVariableSubstitutions(arguments);
-				TypeBinding gbeta = inferenceContext.environment.createParameterizedType(
+				ParameterizedTypeBinding gbeta = inferenceContext.environment.createParameterizedType(
 						parameterizedType.genericType(), betas, parameterizedType.enclosingType(), parameterizedType.getTypeAnnotations());
 				inferenceContext.currentBounds.captures.put(gbeta, parameterizedType); // established: both types have nonnull arguments
 				ConstraintTypeFormula newConstraint = new ConstraintTypeFormula(gbeta, targetType, COMPATIBLE);
@@ -365,16 +364,16 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		return true;
 	}
 
-	Collection inputVariables(final InferenceContext18 context) {
+	Collection<InferenceVariable> inputVariables(final InferenceContext18 context) {
 		// from 18.5.2.
 		if (this.left instanceof LambdaExpression) {
 			if (this.right instanceof InferenceVariable) {
-				return Collections.singletonList(this.right);
+				return Collections.singletonList((InferenceVariable)this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set variables = new HashSet();
+				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 				if (lambda.argumentsTypeElided()) {
 					// i)
 					int len = sam.parameters.length;
@@ -402,11 +401,11 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}
 		} else if (this.left instanceof ReferenceExpression) {
 			if (this.right instanceof InferenceVariable) {
-				return Collections.singletonList(this.right);
+				return Collections.singletonList((InferenceVariable)this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope) && !this.left.isExactMethodReference()) {
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true);
-				final Set variables = new HashSet();
+				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
 					sam.parameters[i].collectInferenceVariables(variables);
@@ -415,7 +414,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}			
 		} else if (this.left instanceof ConditionalExpression && this.left.isPolyExpression()) {
 			ConditionalExpression expr = (ConditionalExpression) this.left;
-			Set variables = new HashSet();
+			Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 			variables.addAll(new ConstraintExpressionFormula(expr.valueIfTrue, this.right, COMPATIBLE).inputVariables(context));
 			variables.addAll(new ConstraintExpressionFormula(expr.valueIfFalse, this.right, COMPATIBLE).inputVariables(context));
 			return variables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
index ed74cbe..adcfc9e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 GK Software AG.
+ * Copyright (c) 2013, 2014 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,10 +23,9 @@ import java.util.Set;
 /**
  * Implementation of 18.1.2 in JLS8
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 abstract class ConstraintFormula extends ReductionResult {
 
-	static final List EMPTY_VARIABLE_LIST = Collections.EMPTY_LIST;
+	static final List<InferenceVariable> EMPTY_VARIABLE_LIST = Collections.emptyList();
 	static final ConstraintFormula[] NO_CONSTRAINTS = new ConstraintTypeFormula[0];
 
 	// constants for unicode debug output from ASCII source files:
@@ -53,12 +52,12 @@ abstract class ConstraintFormula extends ReductionResult {
 		return false;
 	}
 
-	Collection inputVariables(InferenceContext18 context) {
+	Collection<InferenceVariable> inputVariables(InferenceContext18 context) {
 		return EMPTY_VARIABLE_LIST;
 	}
 	
-	Collection outputVariables(InferenceContext18 context) {
-		Set variables = new HashSet();
+	Collection<InferenceVariable> outputVariables(InferenceContext18 context) {
+		Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
 		this.right.collectInferenceVariables(variables);
 		variables.removeAll(inputVariables(context));
 		return variables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
index 14016eb..73f55fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
@@ -28,7 +28,6 @@ import org.eclipse.jdt.internal.compiler.ast.Wildcard;
  * <li>S <= T <em>type argument containment</em></li>
  * </ul>
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 class ConstraintTypeFormula extends ConstraintFormula {
 
 	TypeBinding left;
@@ -220,7 +219,7 @@ class ConstraintTypeFormula extends ConstraintFormula {
 				}
 			case Binding.PARAMETERIZED_TYPE:
 				{
-					List constraints = new ArrayList();
+					List<ConstraintFormula> constraints = new ArrayList<ConstraintFormula>();
 					while (superCandidate instanceof ParameterizedTypeBinding && subCandidate != null)  {
 						if (!addConstraintsFromTypeParamters(subCandidate, (ParameterizedTypeBinding) superCandidate, constraints))
 							return FALSE;
@@ -304,7 +303,7 @@ class ConstraintTypeFormula extends ConstraintFormula {
 		return false;
 	}
 
-	boolean addConstraintsFromTypeParamters(TypeBinding subCandidate, ParameterizedTypeBinding ca, List constraints) {
+	boolean addConstraintsFromTypeParamters(TypeBinding subCandidate, ParameterizedTypeBinding ca, List<ConstraintFormula> constraints) {
 		TypeBinding[] ai = ca.arguments;								// C<A1,A2,...>
 		if (ai == null)
 			return true; // no arguments here means nothing to check
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index e1681ef..3069551 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -135,7 +135,6 @@ import org.eclipse.jdt.internal.compiler.ast.Wildcard;
  * 		See also {@link #getParameter(TypeBinding[], int, boolean)} and its clients.</li>
  * </ul>
  */
-@SuppressWarnings({"rawtypes", "unchecked"})
 public class InferenceContext18 {
 
 	/** to conform with javac regarding https://bugs.openjdk.java.net/browse/JDK-8026527 */
@@ -168,7 +167,7 @@ public class InferenceContext18 {
 	BoundSet storedSolution;
 
 	/** For each candidate target type imposed from the outside store the solution of invocation type inference. */
-	Map/*<TypeBinding,Solution>*/ solutionsPerTargetType = new HashMap();
+	Map<TypeBinding,Solution> solutionsPerTargetType = new HashMap<TypeBinding, Solution>();
 
 	/** One of CHECK_STRICT, CHECK_LOOSE, or CHECK_VARARGS. */
 	int inferenceKind;
@@ -184,15 +183,15 @@ public class InferenceContext18 {
 	public static final int BINDINGS_UPDATED = 3;
 	
 	/** Signals whether any type compatibility makes use of unchecked conversion. */
-	public List constraintsWithUncheckedConversion;
+	public List<ConstraintFormula> constraintsWithUncheckedConversion;
 
 	// ---
 
 	/** Inner poly invocations which have been included in this inference. */
-	List/*<InvocationSite>*/ innerPolies = new ArrayList();
+	List<InvocationSite> innerPolies = new ArrayList<InvocationSite>();
 	/** Link to an outer inference context, used for bundled error reporting. */
 	public InferenceContext18 outerContext;
-	private ArrayList problemMethods;
+	private ArrayList<MethodBinding> problemMethods;
 
 	Scope scope;
 	LookupEnvironment environment;
@@ -392,7 +391,7 @@ public class InferenceContext18 {
 			// 4. bullet: assemble C:
 			TypeBinding[] fs;
 			Expression[] arguments = this.invocationArguments;
-			Set c = new HashSet();
+			Set<ConstraintFormula> c = new HashSet<ConstraintFormula>();
 			if (arguments != null) {
 				int k = arguments.length;
 				int p = method.parameters.length;
@@ -423,25 +422,25 @@ public class InferenceContext18 {
 			// 5. bullet: determine B3 from C
 			while (!c.isEmpty()) {
 				// *
-				Set bottomSet = findBottomSet(c, allOutputVariables(c));
+				Set<ConstraintFormula> bottomSet = findBottomSet(c, allOutputVariables(c));
 				if (bottomSet.isEmpty()) {
 					bottomSet.add(pickFromCycle(c)); 
 				}
 				// *
 				c.removeAll(bottomSet);
 				// * The union of the input variables of all the selected constraints, α1, ..., αm, ...
-				Set allInputs = new HashSet();
-				Iterator bottomIt = bottomSet.iterator();
+				Set<InferenceVariable> allInputs = new HashSet<InferenceVariable>();
+				Iterator<ConstraintFormula> bottomIt = bottomSet.iterator();
 				while (bottomIt.hasNext()) {
-					allInputs.addAll(((ConstraintFormula)bottomIt.next()).inputVariables(this));
+					allInputs.addAll(bottomIt.next().inputVariables(this));
 				}
-				InferenceVariable[] variablesArray = (InferenceVariable[]) allInputs.toArray(new InferenceVariable[allInputs.size()]);
+				InferenceVariable[] variablesArray = allInputs.toArray(new InferenceVariable[allInputs.size()]);
 				//   ... is resolved
 				BoundSet solution = resolve();
 				// * ~ apply substitutions to all constraints: 
 				bottomIt = bottomSet.iterator();
 				while (bottomIt.hasNext()) {
-					ConstraintFormula constraint = ((ConstraintFormula)bottomIt.next());
+					ConstraintFormula constraint = bottomIt.next();
 					if (solution != null)
 						if (!constraint.applySubstitution(solution, variablesArray))
 							return null;
@@ -462,7 +461,7 @@ public class InferenceContext18 {
 		}
 	}
 
-	private void addExceptionConstraint(Set c, Expression argument, TypeBinding substF) {
+	private void addExceptionConstraint(Set<ConstraintFormula> c, Expression argument, TypeBinding substF) {
 		if (argument instanceof FunctionalExpression) {
 			c.add(new ConstraintExceptionFormula((FunctionalExpression) argument, substF));
 		} else if (argument instanceof ConditionalExpression) {
@@ -492,7 +491,7 @@ public class InferenceContext18 {
 		boolean haveProperTargetType = targetType != null && targetType.isProperType(true);
 		if (haveProperTargetType || invocation.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {
 			MethodBinding original = method.originalMethod;
-			Solution solution = (Solution) this.solutionsPerTargetType.get(targetType);
+			Solution solution = this.solutionsPerTargetType.get(targetType);
 			BoundSet result = solution != null ? solution.bounds : null;
 			if (result == null) {
 				// start over from a previous candidate but discard its type variable instantiations
@@ -562,7 +561,7 @@ public class InferenceContext18 {
 	}
 
 	public boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding) {
-		Solution solution = (Solution) this.solutionsPerTargetType.get(targetType);
+		Solution solution = this.solutionsPerTargetType.get(targetType);
 		if (solution != null)
 			return false; // no update
 		this.solutionsPerTargetType.put(targetType, new Solution(updatedBinding, null));
@@ -655,12 +654,12 @@ public class InferenceContext18 {
 		BoundSet tmpBoundSet = this.currentBounds;
 		if (this.inferenceVariables != null) {
 			// find a minimal set of dependent variables:
-			Set variableSet;
+			Set<InferenceVariable> variableSet;
 			while ((variableSet = getSmallestVariableSet(tmpBoundSet)) != null) {
 				int oldNumUninstantiated = tmpBoundSet.numUninstantiatedVariables(this.inferenceVariables);
 				final int numVars = variableSet.size();
 				if (numVars > 0) {
-					final InferenceVariable[] variables = (InferenceVariable[]) variableSet.toArray(new InferenceVariable[numVars]);
+					final InferenceVariable[] variables = variableSet.toArray(new InferenceVariable[numVars]);
 					if (!tmpBoundSet.hasCaptureBound(variableSet)) {
 						// try to instantiate this set of variables in a fresh copy of the bound set:
 						BoundSet prevBoundSet = tmpBoundSet;
@@ -743,10 +742,10 @@ public class InferenceContext18 {
 						}
 						if (tmpBoundSet == this.currentBounds)
 							tmpBoundSet = tmpBoundSet.copy();
-						Iterator captureKeys = tmpBoundSet.captures.keySet().iterator();
-						Set toRemove = new HashSet();
+						Iterator<ParameterizedTypeBinding> captureKeys = tmpBoundSet.captures.keySet().iterator();
+						Set<ParameterizedTypeBinding> toRemove = new HashSet<ParameterizedTypeBinding>();
 						while (captureKeys.hasNext()) {
-							ParameterizedTypeBinding key = (ParameterizedTypeBinding) captureKeys.next();
+							ParameterizedTypeBinding key = captureKeys.next();
 							int len = key.arguments.length;
 							for (int i = 0; i < len; i++) {
 								if (key.arguments[i] == variable) { //$IDENTITY-COMPARISON$
@@ -805,9 +804,9 @@ public class InferenceContext18 {
 	}
 
 	static void sortTypes(TypeBinding[] types) {
-		Arrays.sort(types, new Comparator() {
-			public int compare(Object o1, Object o2) {
-				int i1 = ((TypeBinding)o1).id, i2 = ((TypeBinding)o2).id; 
+		Arrays.sort(types, new Comparator<TypeBinding>() {
+			public int compare(TypeBinding o1, TypeBinding o2) {
+				int i1 = o1.id, i2 = o2.id; 
 				return (i1<i2 ? -1 : (i1==i2 ? 0 : 1));
 			}
 		});
@@ -817,13 +816,13 @@ public class InferenceContext18 {
 	 * Find the smallest set of uninstantiated inference variables not depending
 	 * on any uninstantiated variable outside the set.
 	 */
-	private Set getSmallestVariableSet(BoundSet bounds) {
+	private Set<InferenceVariable> getSmallestVariableSet(BoundSet bounds) {
 		int min = Integer.MAX_VALUE;
-		Set result = null;
+		Set<InferenceVariable> result = null;
 		for (int i = 0; i < this.inferenceVariables.length; i++) {
 			InferenceVariable currentVariable = this.inferenceVariables[i];
 			if (!bounds.isInstantiated(currentVariable)) {
-				Set set = new HashSet();
+				Set<InferenceVariable> set = new HashSet<InferenceVariable>();
 				if (!addDependencies(bounds, set, currentVariable, min))
 					continue;
 				int cur = set.size();
@@ -838,7 +837,7 @@ public class InferenceContext18 {
 		return result;
 	}
 
-	private boolean addDependencies(BoundSet boundSet, Set variableSet, InferenceVariable currentVariable, int min) {
+	private boolean addDependencies(BoundSet boundSet, Set<InferenceVariable> variableSet, InferenceVariable currentVariable, int min) {
 		if (variableSet.size() >= min)
 			return false; // no improvement
 		if (boundSet.isInstantiated(currentVariable)) return true; // not added
@@ -853,28 +852,28 @@ public class InferenceContext18 {
 		return true;
 	}
 
-	private Object pickFromCycle(Set c) {
+	private ConstraintFormula pickFromCycle(Set<ConstraintFormula> c) {
 		missingImplementation("Breaking a dependency cycle NYI"); //$NON-NLS-1$
 		return null; // never
 	}
 
-	private Set findBottomSet(Set constraints, Set allOutputVariables) {
+	private Set<ConstraintFormula> findBottomSet(Set<ConstraintFormula> constraints, Set<InferenceVariable> allOutputVariables) {
 		// 18.5.2 bullet 6.1
 		//  A subset of constraints is selected, satisfying the property
 		// that, for each constraint, no input variable depends on an
 		// output variable of another constraint in C ...
-		Set result = new HashSet();
-		Iterator it = constraints.iterator();
+		Set<ConstraintFormula> result = new HashSet<ConstraintFormula>();
+		Iterator<ConstraintFormula> it = constraints.iterator();
 		constraintLoop: while (it.hasNext()) {
-			ConstraintFormula constraint = (ConstraintFormula)it.next();
-			Iterator inputIt = constraint.inputVariables(this).iterator();
-			Iterator outputIt = allOutputVariables.iterator();
+			ConstraintFormula constraint = it.next();
+			Iterator<InferenceVariable> inputIt = constraint.inputVariables(this).iterator();
+			Iterator<InferenceVariable> outputIt = allOutputVariables.iterator();
 			while (inputIt.hasNext()) {
-				InferenceVariable in = (InferenceVariable) inputIt.next();
+				InferenceVariable in = inputIt.next();
 				if (allOutputVariables.contains(in)) // not explicit in the spec, but let's assume any inference variable depends on itself
 					continue constraintLoop;
 				while (outputIt.hasNext()) {
-					if (this.currentBounds.dependsOnResolutionOf(in, (InferenceVariable) outputIt.next()))
+					if (this.currentBounds.dependsOnResolutionOf(in, outputIt.next()))
 						continue constraintLoop;
 				}
 			}
@@ -883,11 +882,11 @@ public class InferenceContext18 {
 		return result;
 	}
 
-	Set allOutputVariables(Set constraints) {
-		Set result = new HashSet();
-		Iterator it = constraints.iterator();
+	Set<InferenceVariable> allOutputVariables(Set<ConstraintFormula> constraints) {
+		Set<InferenceVariable> result = new HashSet<InferenceVariable>();
+		Iterator<ConstraintFormula> it = constraints.iterator();
 		while (it.hasNext()) {
-			result.addAll(((ConstraintFormula)it.next()).outputVariables(this));
+			result.addAll(it.next().outputVariables(this));
 		}
 		return result;
 	}
@@ -937,7 +936,7 @@ public class InferenceContext18 {
 		if (targetType == null || !targetType.isProperType(true)) {
 			if (site.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {
 				// in this case we may not yet have the solution(?, get or compute it now:
-				Solution solution = (Solution) this.solutionsPerTargetType.get(targetType);
+				Solution solution = this.solutionsPerTargetType.get(targetType);
 				try {
 					if (solution != null && solution.bounds != null)
 						bounds = solution.bounds;
@@ -950,7 +949,7 @@ public class InferenceContext18 {
 					return false;
 			}
 		} else {
-			Solution solution = (Solution) this.solutionsPerTargetType.get(targetType);
+			Solution solution = this.solutionsPerTargetType.get(targetType);
 			if (solution != null && solution.bounds != null)
 				bounds = solution.bounds;
 		}
@@ -1110,7 +1109,7 @@ public class InferenceContext18 {
 
 	public void addProblemMethod(ProblemMethodBinding problemMethod) {
 		if (this.problemMethods == null)
-			this.problemMethods = new ArrayList();
+			this.problemMethods = new ArrayList<MethodBinding>();
 		this.problemMethods.add(problemMethod);
 	}
 
@@ -1198,7 +1197,7 @@ public class InferenceContext18 {
 	/** Record the fact that the given constraint requires unchecked conversion. */
 	public void recordUncheckedConversion(ConstraintTypeFormula constraint) {
 		if (this.constraintsWithUncheckedConversion == null)
-			this.constraintsWithUncheckedConversion = new ArrayList();
+			this.constraintsWithUncheckedConversion = new ArrayList<ConstraintFormula>();
 		this.constraintsWithUncheckedConversion.add(constraint);
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
index 520009e..62ac788 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceVariable.java
@@ -63,7 +63,7 @@ public class InferenceVariable extends TypeVariableBinding {
 		return this;
 	}
 
-	void collectInferenceVariables(Set variables) {
+	void collectInferenceVariables(Set<InferenceVariable> variables) {
 		variables.add(this);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index eb0d1c4..7280032 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -32,6 +32,7 @@
  *								Bug 425798 - [1.8][compiler] Another NPE in ConstraintTypeFormula.reduceSubType
  *								Bug 425156 - [1.8] Lambda as an argument is flagged with incompatible error
  *								Bug 426563 - [1.8] AIOOBE when method with error invoked with lambda expression as argument
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -886,7 +887,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		return false;
 	}
 
-	void collectInferenceVariables(Set variables) {
+	void collectInferenceVariables(Set<InferenceVariable> variables) {
 		if (this.arguments != null) {
 			int len = this.arguments.length;
 			for (int i = 0; i < len; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 2de4d7f..3db29aa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,6 +29,7 @@
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -56,7 +57,6 @@ Non-public fields have accessors which should be used everywhere you expect the
 null is NOT a valid value for a non-public field... it just means the field is not initialized.
 */
 
-@SuppressWarnings({"rawtypes", "unchecked"})
 abstract public class ReferenceBinding extends TypeBinding {
 
 	public char[][] compoundName;
@@ -77,17 +77,17 @@ abstract public class ReferenceBinding extends TypeBinding {
 		public boolean hasTypeBit(int bit) { return false; }
 	};
 
-	private static final Comparator FIELD_COMPARATOR = new Comparator() {
-		public int compare(Object o1, Object o2) {
-			char[] n1 = ((FieldBinding) o1).name;
-			char[] n2 = ((FieldBinding) o2).name;
+	private static final Comparator<FieldBinding> FIELD_COMPARATOR = new Comparator<FieldBinding>() {
+		public int compare(FieldBinding o1, FieldBinding o2) {
+			char[] n1 = o1.name;
+			char[] n2 = o2.name;
 			return ReferenceBinding.compare(n1, n2, n1.length, n2.length);
 		}
 	};
-	private static final Comparator METHOD_COMPARATOR = new Comparator() {
-		public int compare(Object o1, Object o2) {
-			MethodBinding m1 = (MethodBinding) o1;
-			MethodBinding m2 = (MethodBinding) o2;
+	private static final Comparator<MethodBinding> METHOD_COMPARATOR = new Comparator<MethodBinding>() {
+		public int compare(MethodBinding o1, MethodBinding o2) {
+			MethodBinding m1 = o1;
+			MethodBinding m2 = o2;
 			char[] s1 = m1.selector;
 			char[] s2 = m2.selector;
 			int c = ReferenceBinding.compare(s1, s2, s1.length, s2.length);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 10ae130..bca4255 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -22,6 +22,7 @@
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *								Bug 424712 - [1.8][compiler] NPE in TypeBinding.isProvablyDistinctTypeArgument
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -1509,7 +1510,7 @@ public boolean mentionsAny(TypeBinding[] parameters, int idx) {
 }
 
 /** Collect all inference variables mentioned in this type into the set 'variables'. */
-void collectInferenceVariables(Set variables) {
+void collectInferenceVariables(Set<InferenceVariable> variables) {
 	// nop
 }
 /** Answer an additional bit characterizing this type, like {@link TypeIds#BitAutoCloseable}. */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 225f246..74dae9a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,6 +21,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 426792 - [1.8][inference][impl] generify new type inference engine
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -574,7 +575,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 		}
 	}
 
-	void collectInferenceVariables(Set variables) {
+	void collectInferenceVariables(Set<InferenceVariable> variables) {
 		if (this.inRecursiveFunction)
 			return; // nothing seen
 		this.inRecursiveFunction = true;
