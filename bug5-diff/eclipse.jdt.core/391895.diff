commit ebf5deb17f462a2a1a50c9b4076f1d52394081e1
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Jan 31 15:28:02 2013 +0530

    Fix for bug 391895 - [1.8][dom ast] Annotation support for extended
    dimensions

53	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
31	18	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST3Test.java
31	18	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST4Test.java
33	16	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
12	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
22	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
19	8	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
18	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
16	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
23	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
4	0	org.eclipse.jdt.core.tests.model/workspace/Converter18/src/X.java
20	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
122	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
34	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
12	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
34	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
225	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
51	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
63	9	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
85	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
52	14	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
23	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
22	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index 061c916..5ff7205 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -1017,4 +1017,57 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertNotNull("Incorrect receiver qualfier", method.getReceiverQualifier());
 		assertEquals("Incorrect receiver qualfier", "X", method.getReceiverQualifier().getFullyQualifiedName());
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391895
+	public void test0009() throws JavaModelException {
+		String contents =
+				"import java.lang.annotation.ElementType;\n" +
+						"public class X {\n" +
+						" 	class Y {\n" +
+						"		@Annot int @Annot1 [] a @Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 [], b @Annot2 @Annot3 [] @Annot4 [], c [][][];\n" +  
+						"		public void foo1(@Annot int @Annot1 [] p @Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []) {}\n" +
+						"		public void foo2(@Annot int p [][]) {}\n" +
+						"		@Annot String @Annot1 [] foo3() @Annot1 @Annot2 [][] { return null; }\n" + 
+						"	}\n" +
+						"}\n" +
+						"@java.lang.annotation.Target(value = {ElementType.TYPE_USE})\n" + 
+						"@interface Annot {}\n" +
+						"@java.lang.annotation.Target(value = {ElementType.TYPE_USE})\n" + 
+						"@interface Annot1 {}\n" +
+						"@java.lang.annotation.Target(value = {ElementType.TYPE_USE})\n" +
+						"@interface Annot2 {}\n" +
+						"@java.lang.annotation.Target(value = {ElementType.TYPE_USE})\n" + 
+						"@interface Annot3 {}\n" +
+						"@java.lang.annotation.Target(value = {ElementType.TYPE_USE})\n" +
+						"@interface Annot4 {}";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit unit = (CompilationUnit) node;
+		node = getASTNode(unit, 0, 0);
+		assertEquals("Not a type Declaration", ASTNode.TYPE_DECLARATION, node.getNodeType());
+		TypeDeclaration type = (TypeDeclaration) node;
+		FieldDeclaration field = type.getFields()[0];
+		List fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 3, fragments.size());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
+		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 []");
+		fragment = (VariableDeclarationFragment) fragments.get(1);
+		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot4 []");		
+		fragment = (VariableDeclarationFragment) fragments.get(2);
+		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "[] [] []");
+		MethodDeclaration[] methods = type.getMethods();
+		assertEquals("Incorrect no of methods", 3, methods.length);
+		MethodDeclaration method = methods[0];
+		List parameters = method.parameters();
+		assertEquals("Incorrect no of parameters", 1, parameters.size());
+		assertExtraDimensionsEqual("Incorrect dimension info", ((SingleVariableDeclaration) parameters.get(0)).getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []");
+
+		method = methods[1];
+		parameters = method.parameters();
+		assertEquals("Incorrect no of parameters", 1, parameters.size());
+		assertExtraDimensionsEqual("Incorrect dimension info", ((SingleVariableDeclaration) parameters.get(0)).getExtraDimensionInfos(), "[] []");
+
+		method = methods[2];
+		assertExtraDimensionsEqual("Incorrect dimension info", method.getExtraDimensionInfos(), "@Annot1 @Annot2 [] []");
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST3Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST3Test.java
index 6daa07a..97ccf30 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST3Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST3Test.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -37,7 +41,16 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 	public static Test suite() {
 		return buildModelTestSuite(ASTConverterAST3Test.class);
 	}
-
+	/** 
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions() for avoiding deprecated warnings.
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
 	public void test0001() throws JavaModelException {
 		ICompilationUnit sourceUnit = getCompilationUnit("Converter" , "src", "test0001", "Test.java"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
 		char[] source = sourceUnit.getSource().toCharArray();
@@ -2714,20 +2727,20 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2754,20 +2767,20 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newArrayType(this.ast.newPrimitiveType(PrimitiveType.INT), 1));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2793,7 +2806,7 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String")), 1));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2821,7 +2834,7 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2849,7 +2862,7 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2878,7 +2891,7 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		assertTrue("Not a declaration", frag.getName().isDeclaration()); //$NON-NLS-1$
 		VariableDeclarationFragment fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i")); //$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2900,22 +2913,22 @@ public class ASTConverterAST3Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10"); //$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.modifiers().add(this.ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("y"));//$NON-NLS-1$
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		fragment.setInitializer(this.ast.newNullLiteral());
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		fieldDeclaration.fragments().add(fragment);
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
 		checkSourceRange(node, "public int x= 10, y[] = null, i, j[][];", source); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST4Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST4Test.java
index 2d65325..b8d4af9 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST4Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST4Test.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2011 IBM Corporation and others.
+ * Copyright (c) 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -37,7 +41,16 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 	public static Test suite() {
 		return buildModelTestSuite(ASTConverterAST4Test.class);
 	}
-
+	/** 
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions() for avoiding deprecated warnings.
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
 	public void test0001() throws JavaModelException {
 		ICompilationUnit sourceUnit = getCompilationUnit("Converter" , "src", "test0001", "Test.java"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
 		char[] source = sourceUnit.getSource().toCharArray();
@@ -2714,20 +2727,20 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2754,20 +2767,20 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newArrayType(this.ast.newPrimitiveType(PrimitiveType.INT), 1));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2793,7 +2806,7 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String")), 1));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2821,7 +2834,7 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2849,7 +2862,7 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		internalSetExtraDimensions(variableDeclarationFragment, 1);
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2878,7 +2891,7 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		assertTrue("Not a declaration", frag.getName().isDeclaration()); //$NON-NLS-1$
 		VariableDeclarationFragment fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i")); //$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2900,22 +2913,22 @@ public class ASTConverterAST4Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10"); //$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.modifiers().add(this.ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("y"));//$NON-NLS-1$
-		fragment.setExtraDimensions(1);
+		internalSetExtraDimensions(fragment, 1);
 		fragment.setInitializer(this.ast.newNullLiteral());
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		internalSetExtraDimensions(fragment, 0);
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		internalSetExtraDimensions(fragment, 2);
 		fieldDeclaration.fragments().add(fragment);
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
 		checkSourceRange(node, "public int x= 10, y[] = null, i, j[][];", source); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
index 927ab3f..9781546 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
@@ -37,6 +37,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 
 	static {
 //		TESTS_NUMBERS = new int[] { 356 };
+//		TESTS_NAMES = new String[]{ "test0393" };
 	}
 	public static Test suite() {
 		return buildModelTestSuite(ASTConverterAST8Test.class);
@@ -2718,20 +2719,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2758,20 +2762,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.setExtraDimensions(1);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newArrayType(this.ast.newPrimitiveType(PrimitiveType.INT), 1));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2797,7 +2804,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		variableDeclarationFragment.getExtraDimensionInfos().clear();
+		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String")), 1));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2825,7 +2833,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		variableDeclarationFragment.getExtraDimensionInfos().clear();
+		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2853,7 +2862,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.setExtraDimensions(1);
+		variableDeclarationFragment.getExtraDimensionInfos().clear();
+		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2882,7 +2892,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not a declaration", frag.getName().isDeclaration()); //$NON-NLS-1$
 		VariableDeclarationFragment fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i")); //$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2904,22 +2914,25 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10"); //$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.modifiers().add(this.ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("y"));//$NON-NLS-1$
-		fragment.setExtraDimensions(1);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		fragment.setInitializer(this.ast.newNullLiteral());
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.setExtraDimensions(0);
+		fragment.getExtraDimensionInfos().clear();
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.setExtraDimensions(2);
+		fragment.getExtraDimensionInfos().clear();
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
 		fieldDeclaration.fragments().add(fragment);
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
 		checkSourceRange(node, "public int x= 10, y[] = null, i, j[][];", source); //$NON-NLS-1$
@@ -9591,6 +9604,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertNotNull("No type binding", typeBinding2); //$NON-NLS-1$
 		assertEquals("Wrong qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
+		List extraDimensions = methodDeclaration.getExtraDimensionInfos();
+		assertExtraDimensionsEqual("Wrong extra dimension info", extraDimensions, "[]");
 	}
 
 	/**
@@ -9677,6 +9692,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not an array binding", typeBinding2.isArray()); //$NON-NLS-1$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
 		assertEquals("wrong fully qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
+		List extraDimensions = singleVariableDeclaration.getExtraDimensionInfos();
+		assertExtraDimensionsEqual("Wrong extra dimension info", extraDimensions, "[]");
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index 2403e9d..cc87f32 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2011 IBM Corporation and others.
+ * Copyright (c) 2004, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -346,7 +350,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 84, hi); // last known one
+		assertEquals("Wrong last known type", 85, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 36b52d1..42b21cc 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -789,6 +789,15 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 	}
 
 	/**
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions for avoiding deprecated warnings.
+	 *
+	 * @param node
+	 * @deprecated
+	 */
+	private void setExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
+	/**
 	 * Snippets that show how to...
 	 * @deprecated using deprecated code
 	 */
@@ -3308,18 +3317,18 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 		assertTrue(this.ast.modificationCount() == previousCount);
 
 		previousCount = this.ast.modificationCount();
-		x.setExtraDimensions(1);
+		setExtraDimensions(x, 1);
 		assertTrue(this.ast.modificationCount() > previousCount);
 		assertTrue(x.getExtraDimensions() == 1);
 
 		previousCount = this.ast.modificationCount();
-		x.setExtraDimensions(0);
+		setExtraDimensions(x, 0);
 		assertTrue(this.ast.modificationCount() > previousCount);
 		assertTrue(x.getExtraDimensions() == 0);
 
 		// check that property cannot be set negative
 		try {
-			x.setExtraDimensions(-1);
+			setExtraDimensions(x, -1);
 			assertTrue(false);
 		} catch (RuntimeException e) {
 			// pass
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
index cdbc4a0..cc859b3 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.core.tests.dom;
 
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
@@ -141,6 +142,26 @@ public abstract class ConverterTestSetup extends AbstractASTTests {
 		}
 	}
 
+	protected void assertExtraDimensionsEqual(String message, List dimensions, String expected) {
+		StringBuffer buffer = new StringBuffer();
+		Iterator iter = dimensions.iterator();
+		while(iter.hasNext()) {
+			DimensionInfo dim = (DimensionInfo) iter.next();
+			Iterator annotations = dim.annotations().iterator();
+			while (annotations.hasNext()) {
+				buffer.append('@');
+				buffer.append(((Annotation) annotations.next()).getTypeName().getFullyQualifiedName());
+				buffer.append(' ');
+			}
+			if (iter.hasNext()) {
+				buffer.append("[] ");
+			} else {
+				buffer.append("[]");
+			}
+		}
+		assertEquals(message, expected, buffer.toString());
+	}
+
 	public ASTNode runConversion(ICompilationUnit unit, boolean resolveBindings,
 			boolean bindingsRecovery) {
 		return runConversion(astInternalJLS2(), unit, resolveBindings, false, bindingsRecovery);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
index 63b0aa5..113642a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -30,6 +34,13 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 	private static final Class THIS= ASTRewritingMethodDeclTest.class;
 
+	/**
+	 * Internal synonym for deprecated constant MethodDeclaration#EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+
 	public ASTRewritingMethodDeclTest(String name) {
 		super(name);
 	}
@@ -1447,7 +1458,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, add throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo1");
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1456,14 +1467,14 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, remove throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo2");
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			rewrite.remove((ASTNode) methodDecl.thrownExceptions().get(0), null);
 		}
 		{ // remove extra dim, add throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo3");
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1472,7 +1483,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, remove throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo4");
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			rewrite.remove((ASTNode) methodDecl.thrownExceptions().get(0), null);
 		}
@@ -1483,7 +1494,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.getListRewrite(methodDecl, MethodDeclaration.PARAMETERS_PROPERTY).insertLast(newParam1, null);
 
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1494,7 +1505,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			rewrite.remove((ASTNode) methodDecl.parameters().get(0), null);
 
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
 
 			rewrite.remove((ASTNode) methodDecl.thrownExceptions().get(0), null);
 		}
@@ -2006,7 +2017,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "DD");
 
 			rewrite.set(methodDecl, MethodDeclaration.CONSTRUCTOR_PROPERTY, Boolean.TRUE, null);
-			rewrite.set(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
index 429dce8..2b98eb4 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -51,7 +55,16 @@ public class ASTRewritingStatementsTest extends ASTRewritingTest {
 //		suite.addTest(new ASTRewritingStatementsTest("testTryStatementWithResources5"));
 //		return suite;
 	}
-
+	/** 
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions() for avoiding deprecated warnings
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
 	public void testInsert1() throws Exception {
 		IPackageFragment pack1= this.sourceFolder.createPackageFragment("test1", false, null);
 		/* foo(): append a return statement */
@@ -5156,7 +5169,7 @@ public class ASTRewritingStatementsTest extends ASTRewritingTest {
 			TryStatement tryStatement = (TryStatement) statement;
 
 			VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
-			fragment.setExtraDimensions(0);
+			internalSetExtraDimensions(fragment, 0);
 			fragment.setName(ast.newSimpleName("reader2"));
 			ClassInstanceCreation classInstanceCreation = ast.newClassInstanceCreation();
 			classInstanceCreation.setType(ast.newSimpleType(ast.newSimpleName("FileReader")));
@@ -5234,7 +5247,7 @@ public class ASTRewritingStatementsTest extends ASTRewritingTest {
 			TryStatement tryStatement = (TryStatement) statement;
 
 			VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();
-			fragment.setExtraDimensions(0);
+			internalSetExtraDimensions(fragment, 0);
 			fragment.setName(ast.newSimpleName("reader2"));
 			ClassInstanceCreation classInstanceCreation = ast.newClassInstanceCreation();
 			classInstanceCreation.setType(ast.newSimpleType(ast.newSimpleName("FileReader")));
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
index 6382569..8107a81 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -45,7 +49,16 @@ public class ASTRewritingTrackingTest extends ASTRewritingTest {
 	public static Test suite() {
 		return allTests();
 	}
-
+	/** 
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions() for avoiding deprecated warnings
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
 	public void testNamesWithDelete() throws Exception {
 
 		IPackageFragment pack1= this.sourceFolder.createPackageFragment("test1", false, null);
@@ -159,7 +172,7 @@ public class ASTRewritingTrackingTest extends ASTRewritingTest {
 
 		VariableDeclarationFragment newFrag= ast.newVariableDeclarationFragment();
 		newFrag.setName(ast.newSimpleName("newVariable"));
-		newFrag.setExtraDimensions(2);
+		internalSetExtraDimensions(newFrag, 2);
 
 		rewrite.getListRewrite(field, FieldDeclaration.FRAGMENTS_PROPERTY).insertFirst(newFrag, null);
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
index 7f9a192..f26d5b1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -27,6 +31,19 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 	private static final Class THIS= ASTRewritingTypeDeclTest.class;
 
+	/**
+	 * Internal synonym for deprecated constant SingleVariableDeclaration#EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY = SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant VariableDeclarationFragment#EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY = VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY;
+
 	public ASTRewritingTypeDeclTest(String name) {
 		super(name);
 	}
@@ -1000,7 +1017,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			int newModifiers= Modifier.FINAL;
 			rewrite.set(decl, SingleVariableDeclaration.MODIFIERS_PROPERTY, new Integer(newModifiers), null);
 
-			rewrite.set(decl, SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
 
 			ArrayType newVarType= ast.newArrayType(ast.newPrimitiveType(PrimitiveType.FLOAT), 2);
 			rewrite.replace(decl.getType(), newVarType, null);
@@ -1020,7 +1037,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // remove extra dim
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(2);
 
-			rewrite.set(decl, SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
@@ -1069,7 +1086,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			ASTNode name= ast.newSimpleName("a");
 			rewrite.replace(fragment.getName(), name, null);
 
-			rewrite.set(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY, new Integer(2), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(2), null);
 		}
 
 		{ // add initializer
@@ -1090,7 +1107,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // add dimension, add initializer
 			VariableDeclarationFragment fragment= (VariableDeclarationFragment) fragments.get(3);
 
-			rewrite.set(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
 
 			assertTrue("Has initializer", fragment.getInitializer() == null);
 
@@ -1100,7 +1117,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // remove dimension
 			VariableDeclarationFragment fragment= (VariableDeclarationFragment) fragments.get(4);
 
-			rewrite.set(fragment, VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Converter18/src/X.java b/org.eclipse.jdt.core.tests.model/workspace/Converter18/src/X.java
new file mode 100644
index 0000000..5a1a888
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Converter18/src/X.java
@@ -0,0 +1,4 @@
+public class X {
+	public void foo(X this) {
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 0d5aed5..b6c2514 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1116,6 +1116,25 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented annotatable dimension info node
+	 * (Supported only in JLS8 level).
+	 *
+	 * @return a new unparented annotatable dimension info node
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 * @exception UnsupportedOperationException if this operation is used
+	 *            in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	public DimensionInfo newDimensionInfo() {
+		DimensionInfo result = new DimensionInfo(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented array type node with the given
 	 * element type and number of (additional) dimensions.
 	 * <p>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 361ace6..8a1ac31 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -338,6 +338,36 @@ class ASTConverter {
 			}
 		}
 	}
+	/** 
+	 * Internal access method to SingleVariableDeclaration#setExtraDimensions() for avoiding deprecated warnings
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(SingleVariableDeclaration node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
+	/** 
+	 * Internal access method to VariableDeclarationFragment#setExtraDimensions() for avoiding deprecated warnings
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(VariableDeclarationFragment node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
+	/** 
+	 * Internal access method to MethodDeclaration#setExtraDimension() for avoiding deprecated warnings
+	 *
+	 * @param node
+	 * @param dimensions
+	 * @deprecated
+	 */
+	private void internalSetExtraDimensions(MethodDeclaration node, int dimensions) {
+		node.setExtraDimensions(dimensions);
+	}
 
 	/**
 	 * @param compilationUnit
@@ -508,7 +538,12 @@ class ASTConverter {
 				// get the positions of the right parenthesis
 				int rightParenthesisPosition = retrieveEndOfRightParenthesisPosition(end, method.bodyEnd);
 				int extraDimensions = retrieveExtraDimension(rightParenthesisPosition, method.bodyEnd);
-				methodDecl.setExtraDimensions(extraDimensions);
+				if (this.ast.apiLevel >= AST.JLS8) {
+					setExtraAnnotatedDimensions(rightParenthesisPosition, this.scanner.currentPosition, typeReference,
+												methodDecl.extraDimensionInfos, extraDimensions);
+				} else {
+					internalSetExtraDimensions(methodDecl, extraDimensions);
+				}
 				setTypeForMethodDeclaration(methodDecl, returnType, extraDimensions);
 			} else {
 				// no return type for a method that is not a constructor
@@ -829,7 +864,12 @@ class ASTConverter {
 		variableDecl.setName(name);
 		final int typeSourceEnd = argument.type.sourceEnd;
 		final int extraDimensions = retrieveExtraDimension(nameEnd + 1, typeSourceEnd);
-		variableDecl.setExtraDimensions(extraDimensions);
+		if (this.ast.apiLevel >= AST.JLS8) {
+			setExtraAnnotatedDimensions(nameEnd + 1, this.scanner.currentPosition, argument.type,
+										variableDecl.extraDimensionInfos, extraDimensions);
+		} else {
+			internalSetExtraDimensions(variableDecl, extraDimensions);
+		}
 		final boolean isVarArgs = argument.isVarArgs();
 		if (isVarArgs && extraDimensions == 0) {
 			// remove the ellipsis from the type source end
@@ -2992,7 +3032,12 @@ class ASTConverter {
 		name.setSourceRange(start, nameEnd - start + 1);
 		variableDecl.setName(name);
 		final int extraDimensions = retrieveExtraDimension(nameEnd + 1, localDeclaration.type.sourceEnd);
-		variableDecl.setExtraDimensions(extraDimensions);
+		if (this.ast.apiLevel >= AST.JLS8) {
+			setExtraAnnotatedDimensions(nameEnd + 1, this.scanner.currentPosition, localDeclaration.type,
+					variableDecl.extraDimensionInfos, extraDimensions);
+		} else {
+			internalSetExtraDimensions(variableDecl, extraDimensions);
+		}
 		Type type = convertType(localDeclaration.type);
 		int typeEnd = type.getStartPosition() + type.getLength() - 1;
 		int rightEnd = Math.max(typeEnd, localDeclaration.declarationSourceEnd);
@@ -3010,6 +3055,17 @@ class ASTConverter {
 		return variableDecl;
 	}
 
+	private DimensionInfo convertToDimensionInfo(int start, int end, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotation) {
+		int length = annotation == null ? 0 : annotation.length;
+		DimensionInfo dimension = this.ast.newDimensionInfo();
+		for (int i = 0; i < length; i++) {
+			Annotation annot = convert(annotation[i]);
+			dimension.annotations.add(annot);
+		}
+		retrieveDimensionAndSetPositions(start, end, dimension);
+		return dimension;
+	}
+
 	protected VariableDeclarationFragment convertToVariableDeclarationFragment(org.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration) {
 		final VariableDeclarationFragment variableDeclarationFragment = new VariableDeclarationFragment(this.ast);
 		final SimpleName name = new SimpleName(this.ast);
@@ -3019,7 +3075,12 @@ class ASTConverter {
 		int start = fieldDeclaration.sourceEnd;
 		int end = start;
 		int extraDimensions = retrieveExtraDimension(fieldDeclaration.sourceEnd + 1, fieldDeclaration.declarationSourceEnd );
-		variableDeclarationFragment.setExtraDimensions(extraDimensions);
+		if (this.ast.apiLevel >= AST.JLS8) {
+			setExtraAnnotatedDimensions(fieldDeclaration.sourceEnd + 1, this.scanner.currentPosition,
+					fieldDeclaration.type, variableDeclarationFragment.extraDimensionInfos, extraDimensions);
+		} else {
+			internalSetExtraDimensions(variableDeclarationFragment, extraDimensions);
+		}
 		if (fieldDeclaration.initialization != null) {
 			final Expression expression = convert(fieldDeclaration.initialization);
 			variableDeclarationFragment.setInitializer(expression);
@@ -3057,7 +3118,13 @@ class ASTConverter {
 		int start = localDeclaration.sourceEnd;
 		org.eclipse.jdt.internal.compiler.ast.Expression initialization = localDeclaration.initialization;
 		int extraDimension = retrieveExtraDimension(localDeclaration.sourceEnd + 1, this.compilationUnitSourceLength);
-		variableDeclarationFragment.setExtraDimensions(extraDimension);
+		if (this.ast.apiLevel >= AST.JLS8) {
+			setExtraAnnotatedDimensions(localDeclaration.sourceEnd + 1, this.scanner.currentPosition,
+					localDeclaration.type, variableDeclarationFragment.extraDimensionInfos, extraDimension);
+		} else {
+			internalSetExtraDimensions(variableDeclarationFragment, extraDimension);
+		}
+
 		boolean hasInitialization = initialization != null;
 		int end;
 		if (hasInitialization) {
@@ -3088,6 +3155,18 @@ class ASTConverter {
 		return variableDeclarationFragment;
 	}
 
+	protected void setExtraAnnotatedDimensions(int start, int end, TypeReference type, final List extraAnnotatedDimensions, int extraDimension) {
+		if (extraDimension > 0) {
+			org.eclipse.jdt.internal.compiler.ast.Annotation[][] annotationsOnDims = type.getAnnotationsOnDimensions();
+			int length = (annotationsOnDims == null) ? 0 : annotationsOnDims.length;
+			for (int i = (length - extraDimension); i < length; i++) {
+				DimensionInfo dim = convertToDimensionInfo(start, end, (annotationsOnDims == null) ? null : annotationsOnDims[i]);
+				extraAnnotatedDimensions.add(dim);
+				start = dim.getStartPosition() + dim.getLength();
+			}
+		}
+	}
+
 	protected VariableDeclarationStatement convertToVariableDeclarationStatement(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration localDeclaration) {
 		final VariableDeclarationFragment variableDeclarationFragment = convertToVariableDeclarationFragment(localDeclaration);
 		final VariableDeclarationStatement variableDeclarationStatement = new VariableDeclarationStatement(this.ast);
@@ -4344,14 +4423,26 @@ class ASTConverter {
 		int dimensions = 0;
 		try {
 			int token;
+			boolean isAnnotation = false;
 			while ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
 				switch(token) {
 					case TerminalTokens.TokenNameLBRACKET:
 					case TerminalTokens.TokenNameCOMMENT_BLOCK:
 					case TerminalTokens.TokenNameCOMMENT_JAVADOC:
 					case TerminalTokens.TokenNameCOMMENT_LINE:
+						isAnnotation = false;
+						break;
+					case TerminalTokens.TokenNameAT:
+						isAnnotation = true;
+						break;
+					case TerminalTokens.TokenNameIdentifier:
+						if (!isAnnotation) {
+							return dimensions;
+						}
+						isAnnotation = false;
 						break;
 					case TerminalTokens.TokenNameRBRACKET://166
+						isAnnotation = false;
 						dimensions++;
 						break;
 					default:
@@ -4364,6 +4455,31 @@ class ASTConverter {
 		return dimensions;
 	}
 
+	protected void retrieveDimensionAndSetPositions(int start, int end, DimensionInfo dim) {
+		this.scanner.resetTo(start, end);
+		int token;
+		boolean startSet = false;
+		try {
+			while((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF)  {
+				switch(token) {
+					case TerminalTokens.TokenNameWHITESPACE:
+						break;
+					case TerminalTokens.TokenNameRBRACKET:
+						int endDim = this.scanner.currentPosition - 1;
+						dim.setSourceRange(start, endDim - start + 1);
+						return;
+					default:
+						if (!startSet) {
+							start = this.scanner.startPosition;
+							startSet = true;
+						}
+						break;
+				}
+			}
+		} catch(InvalidInputException e) {
+			// ignore
+		}
+	}
 	protected void retrieveIdentifierAndSetPositions(int start, int end, Name name) {
 		this.scanner.resetTo(start, end);
 		int token;
@@ -5277,7 +5393,7 @@ class ASTConverter {
 							break;
 						default :
 							methodDeclaration.setReturnType2(subarrayType);
-						break;
+							break;
 					}
 					this.ast.getBindingResolver().updateKey(type, subarrayType);
 				}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 95c2e47..24de25a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -354,6 +354,29 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.9
+	 */
+	public boolean match(DimensionInfo node, Object other) {
+		if (!(other instanceof DimensionInfo))
+			return false;
+		DimensionInfo o = (DimensionInfo) other;
+		return safeSubtreeListMatch(node.annotations(), o.annotations())
+				&& safeSubtreeMatch(node.expression(), o.expression());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(AssertStatement node, Object other) {
 		if (!(other instanceof AssertStatement)) {
@@ -1399,10 +1422,11 @@ public class ASTMatcher {
 				&& safeSubtreeMatch(node.getName(), o.getName())
 				// n.b. compare return type even for constructors
 				&& safeSubtreeListMatch(node.parameters(), o.parameters())
-	 			&& node.getExtraDimensions() == o.getExtraDimensions()
-				&& (node.getAST().apiLevel() < AST.JLS8 ? 
-						safeSubtreeListMatch(node.thrownExceptions(), o.thrownExceptions()) :
-						safeSubtreeListMatch(node.thrownExceptionTypes(), o.thrownExceptionTypes()))
+				&& ((node.getAST().apiLevel < AST.JLS8) ?
+							(node.getExtraDimensions() == o.getExtraDimensions()
+								&& safeSubtreeListMatch(node.thrownExceptions(), o.thrownExceptions())) :
+							(safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos())
+								&& safeSubtreeListMatch(node.thrownExceptionTypes(), o.thrownExceptionTypes())))
 				&& safeSubtreeMatch(node.getBody(), o.getBody()));
 	}
 
@@ -1878,7 +1902,9 @@ public class ASTMatcher {
 		return
 		    safeSubtreeMatch(node.getType(), o.getType())
 				&& safeSubtreeMatch(node.getName(), o.getName())
-	 			&& node.getExtraDimensions() == o.getExtraDimensions()
+	 			&& ((node.getAST().apiLevel < AST.JLS8) ?
+	 					node.getExtraDimensions() == o.getExtraDimensions() :
+	 						safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos()))
 				&& safeSubtreeMatch(node.getInitializer(), o.getInitializer())
 				&& (level >= AST.JLS8 && node.isVarargs()) ? safeSubtreeListMatch(node.varargsAnnotations(), o.varargsAnnotations()) : true;		
 	}
@@ -2371,7 +2397,9 @@ public class ASTMatcher {
 		}
 		VariableDeclarationFragment o = (VariableDeclarationFragment) other;
 		return safeSubtreeMatch(node.getName(), o.getName())
-			&& node.getExtraDimensions() == o.getExtraDimensions()
+			&& ((node.getAST().apiLevel < AST.JLS8) ?
+					node.getExtraDimensions() == o.getExtraDimensions() :
+						safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos()))
 			&& safeSubtreeMatch(node.getInitializer(), o.getInitializer());
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 6ea43ba..713d1a0 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -773,6 +773,15 @@ public abstract class ASTNode {
 	public static final int UNION_TYPE = 84;
 
 	/**
+	 * Node type constant indicating a node of type
+	 * <code>DimensionInfo</code>.
+	 *
+	 * @see DimensionInfo
+	 * @since 3.9
+	 */
+	public static final int DIMENSION_INFO = 85;
+
+	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
@@ -952,6 +961,8 @@ public abstract class ASTNode {
 				return WhileStatement.class;
 			case WILDCARD_TYPE :
 				return WildcardType.class;
+			case DIMENSION_INFO:
+				return DimensionInfo.class;
 		}
 		throw new IllegalArgumentException();
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index b293053..b01fad7 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -199,6 +203,22 @@ public abstract class ASTVisitor {
 		return true;
 	}
 
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.9
+	 */
+	public boolean visit(DimensionInfo node) {
+		return true;
+	}
 
 	/**
 	 * Visits the given type-specific AST node.
@@ -1600,6 +1620,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.9
+	 */
+	public void endVisit(DimensionInfo node) {
+		// do nothing by default
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.1
 	 */
 	public void endVisit(AnnotationTypeMemberDeclaration node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
new file mode 100644
index 0000000..6687665
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
@@ -0,0 +1,225 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The array dimension info node. The array dimension, represented as <b>[]</b>, can have
+ * type annotations. It may also include an <code>Expression</code> depending on where it appears.
+ * The only node that supports a dimension info with an expression is <code>ArrayCreation</code>.
+ * This node type is supported only in JLS8 or later.
+ * <p>
+ * The dimension info node is used to represent extra dimensions in the following nodes:
+ * <pre>
+ * 	SingleVariableDeclaration
+ * 	VariableDeclarationFragment
+ * 	MethodDeclaration
+ * </pre>
+ * For JLS8:
+ * <pre>
+ * DimensionInfo:
+ * 	{ Annotations } <b>[</b> [ Expression ] <b>]</b>
+ * </pre>
+ *</p>
+ * @see AST#newDimensionInfo()
+ * @since 3.9
+ */
+public class DimensionInfo extends ASTNode {
+
+
+	/**
+	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+		new ChildListPropertyDescriptor(DimensionInfo.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+
+	/**
+	 * The "expression" structural property of this node type (element type: {@link Expression}).
+	 * @since 3.9
+	 */
+	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
+			new ChildPropertyDescriptor(DimensionInfo.class, "expression", Expression.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 * @since 3.9
+	 */
+	private static final List PROPERTY_DESCRIPTORS_8_0;
+
+	static {
+		List propertyList = new ArrayList(3);
+		createPropertyList(DimensionInfo.class, propertyList);
+		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		addProperty(EXPRESSION_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 * @since 3.9
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_8_0;
+	}
+
+	/**
+	 * Create a new instance of DimensionInfo node (Supported only in level
+	 * JLS8 or above).  
+	 *
+	 * @param ast
+	 * @exception UnsupportedOperationException if this operation is used
+	 *            in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	DimensionInfo(AST ast) {
+		super(ast);
+		unsupportedIn2_3_4();
+		this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
+	}
+
+	/**
+	 * The list of annotations for this dimension (element type:
+	 * {@link Annotation}).
+	 */
+	ASTNode.NodeList annotations = null;
+	
+	/**
+	 * Returns the live ordered list of annotations for this dimension.
+	 *
+	 * @return the live list of annotations (element type: {@link Annotation})
+	 * @since 3.9
+	 */
+	public List annotations() {
+		return this.annotations;
+	}
+
+	private Expression expression = null;
+
+	/**
+	 * Sets the expression to this dimension. This operation will have
+	 * effect only if this dimension info node is part of an array creation
+	 * node.
+	 *
+	 * @param expression the expression for this dimension
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 *
+	 * @since 3.9
+	 */
+	public void setExpression(Expression expression) {
+		// an ArrayCreation cannot occur inside a ArrayType - cycles not possible
+		ASTNode oldChild = this.expression;
+		preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+		this.expression = expression;
+		postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
+	}
+
+	/**
+	 * Returns the expression in the dimension info or null if not applicable.
+	 *
+	 * @return the expression
+	 * @since 3.9
+	 */
+	public Expression expression() {
+		return this.expression;
+	}
+
+	List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == EXPRESSION_PROPERTY) {
+			if (get) {
+				return expression();
+			} else {
+				setExpression((Expression) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == ANNOTATIONS_PROPERTY) {
+			return annotations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	int getNodeType0() {
+		return DIMENSION_INFO;
+	}
+
+	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		return matcher.match(this, other);
+	}
+
+	ASTNode clone0(AST target) {
+		DimensionInfo result = new DimensionInfo(target);
+		result.annotations.addAll(
+				ASTNode.copySubtrees(target, annotations()));
+		if (this.expression != null) {
+			result.setExpression((Expression)expression().clone(target));
+		}
+		return result;
+	}
+
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChildren(visitor, this.annotations);
+			if (this.expression != null) {
+				acceptChild(visitor, this.expression);
+			}
+		}
+		visitor.endVisit(this);
+	}
+
+	int treeSize() {
+		int size = memSize()
+				+ this.annotations.listSize()
+				+ (this.expression == null ? 0 : this.expression.treeSize());
+			return size;
+	}
+
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index 1946c00..eb1a368 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -53,14 +53,15 @@ import java.util.List;
  * 			 { <b>,</b> FormalParameter } ] <b>)</b>
  *        [<b>throws</b> TypeName { <b>,</b> TypeName } ] Block
  * </pre>
- * For JLS8 optional receiver parameter is added:
+ * For JLS8 optional receiver parameter is added and extra dimensions are allowed to have 
+ * type annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
  * <pre>
  * MethodDeclaration:
  *    [ Javadoc ] { ExtendedModifier }
  *		  [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ]
  *        ( Type | <b>void</b> ) Identifier <b>(</b>
  *        	[ ReceiverParameter ]
- *         	[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> {<b>[</b> <b>]</b> }
+ *         	[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> { DimensionInfo }
  *        [ <b>throws</b> TypeName { <b>,</b> TypeName } ] ( Block | <b>;</b> )
  * ConstructorDeclaration:
  *    [ Javadoc ] { ExtendedModifier }
@@ -139,10 +140,19 @@ public class MethodDeclaration extends BodyDeclaration {
 
 	/**
 	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 *
 	 * @since 3.0
+	 * @deprecated in JLS8, use {@link MethodDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(MethodDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
+	
+	/**
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (added in JLS8 API).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
+			new ChildListPropertyDescriptor(MethodDeclaration.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "typeParameters" structural property of this node type (element type: {@link TypeParameter}) (added in JLS3 API).
@@ -258,7 +268,7 @@ public class MethodDeclaration extends BodyDeclaration {
 		addProperty(RECEIVER_TYPE_PROPERTY, propertyList);
 		addProperty(RECEIVER_QUALIFIER_PROPERTY, propertyList);
 		addProperty(PARAMETERS_PROPERTY, propertyList);
-		addProperty(EXTRA_DIMENSIONS_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
 		addProperty(THROWN_EXCEPTION_TYPES_PROPERTY, propertyList);
 		addProperty(BODY_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);	
@@ -344,6 +354,13 @@ public class MethodDeclaration extends BodyDeclaration {
 	private int extraArrayDimensions = 0;
 
 	/**
+	 * The extra dimensions this node has with optional annotations.
+	 * 
+	 * @since 3.9
+	 */
+	protected ASTNode.NodeList extraDimensionInfos = null;
+
+	/**
 	 * The list of thrown exception names (element type: {@link Name}).
 	 * Defaults to an empty list for api levels below JLS8.
 	 */
@@ -381,9 +398,10 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (ast.apiLevel >= AST.JLS3_INTERNAL) {
 			this.typeParameters = new ASTNode.NodeList(TYPE_PARAMETERS_PROPERTY);
 		}
-		if (ast.apiLevel() < AST.JLS8) {
+		if (ast.apiLevel < AST.JLS8) {
 			this.thrownExceptions = new ASTNode.NodeList(THROWN_EXCEPTIONS_PROPERTY);
 		} else {
+			this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
 			this.thrownExceptionTypes = new ASTNode.NodeList(THROWN_EXCEPTION_TYPES_PROPERTY);
 		}
 	}
@@ -517,6 +535,9 @@ public class MethodDeclaration extends BodyDeclaration {
 		if (property == THROWN_EXCEPTION_TYPES_PROPERTY) {
 			return thrownExceptionTypes();
 		}		
+		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
+			return getExtraDimensionInfos();
+		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
 	}
@@ -569,12 +590,15 @@ public class MethodDeclaration extends BodyDeclaration {
 			result.setReturnType2(
 					(Type) ASTNode.copySubtree(target, getReturnType2()));
 		}
+		result.setConstructor(isConstructor());
 		if (this.ast.apiLevel >= AST.JLS8) {
 			result.setReceiverType((AnnotatableType) ASTNode.copySubtree(target, this.receiverType));
 			result.setReceiverQualifier((SimpleName) ASTNode.copySubtree(target, this.receiverQualifier));
+			result.extraDimensionInfos.addAll(
+					ASTNode.copySubtrees(target, this.extraDimensionInfos));
+		} else {
+			result.setExtraDimensions(getExtraDimensions());
 		}
-		result.setConstructor(isConstructor());
-		result.setExtraDimensions(getExtraDimensions());
 		result.setName((SimpleName) getName().clone(target));
 		result.parameters().addAll(
 			ASTNode.copySubtrees(target, parameters()));
@@ -622,6 +646,7 @@ public class MethodDeclaration extends BodyDeclaration {
 			}
 			acceptChildren(visitor, this.parameters);
 			if (this.ast.apiLevel() < AST.JLS8) {
+				acceptChildren(visitor, this.extraDimensionInfos);
 				acceptChildren(visitor, this.thrownExceptions);				
 			} else {
 				acceptChildren(visitor, this.thrownExceptionTypes);				
@@ -1005,6 +1030,9 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * @since 2.1
 	 */
 	public int getExtraDimensions() {
+		if (this.ast.apiLevel >= AST.JLS8) {
+			return this.extraDimensionInfos.size();
+		}
 		return this.extraArrayDimensions;
 	}
 
@@ -1024,8 +1052,10 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * @exception IllegalArgumentException if the number of dimensions is
 	 *    negative
 	 * @since 2.1
+	 * @deprecated In the JLS8 API, use: {@link #getExtraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
+		supportedOnlyIn2_3_4();
 		if (dimensions < 0) {
 			throw new IllegalArgumentException();
 		}
@@ -1035,6 +1065,17 @@ public class MethodDeclaration extends BodyDeclaration {
 	}
 
 	/**
+	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
+	 * 
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
+	 * @since 3.9
+	 */
+	public List getExtraDimensionInfos() {
+		unsupportedIn2_3_4();
+		return this.extraDimensionInfos;
+	}
+
+	/**
 	 * Returns the body of this method declaration, or <code>null</code> if
 	 * this method has <b>no</b> body.
 	 * <p>
@@ -1094,7 +1135,7 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * Method declared on ASTNode.
 	 */
 	int memSize() {
-		return super.memSize() + 12 * 4;
+		return super.memSize() + 13 * 4;
 	}
 
 	/* (omit javadoc for this method)
@@ -1111,7 +1152,9 @@ public class MethodDeclaration extends BodyDeclaration {
 			+ (this.receiverQualifier == null ? 0 : this.receiverQualifier.treeSize())
 			+ (this.returnType == null ? 0 : this.returnType.treeSize())
 			+ this.parameters.listSize()
-			+ (this.ast.apiLevel < AST.JLS8 ? this.thrownExceptions.listSize() : this.thrownExceptionTypes.listSize())
+			+ (this.ast.apiLevel < AST.JLS8 ? 
+					this.thrownExceptions.listSize() 
+					: this.extraDimensionInfos.listSize() + this.thrownExceptionTypes.listSize())
 			+ (this.optionalBody == null ? 0 : getBody().treeSize());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
index 5c28b08..4e81298 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
@@ -36,10 +36,11 @@ import java.util.List;
  * SingleVariableDeclaration:
  *    { ExtendedModifier } Type [ <b>...</b> ] Identifier { <b>[</b><b>]</b> } [ <b>=</b> Expression ]
  * </pre>
- * For JLS8, variable arguments are allowed to have optional annotations:
+ * For JLS8, variable declarations and extra dimensions on variable declarations are allowed to 
+ * have optional annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
  * <pre>
  * SingleVariableDeclaration:
- *    { ExtendedModifier } Type {Annotation} [ <b>...</b> ] Identifier { <b>[</b><b>]</b> } [ <b>=</b> Expression ]
+ *    { ExtendedModifier } Type {Annotation} [ <b>...</b> ] Identifier { DimensionInfo } [ <b>=</b> Expression ]
  * </pre>
  *
  * @since 2.0
@@ -91,12 +92,21 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 
 	/**
 	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 *
 	 * @since 3.0
+	 * @deprecated in JLS8, use {@link SingleVariableDeclaration#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(SingleVariableDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 
 	/**
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (added in JLS8 API).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
+			new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
 	 * @since 3.0
 	 */
@@ -155,7 +165,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		addProperty(VARARGS_ANNOTATIONS_PROPERTY, propertyList);
 		addProperty(VARARGS_PROPERTY, propertyList);
 		addProperty(NAME_PROPERTY, propertyList);
-		addProperty(EXTRA_DIMENSIONS_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
 		addProperty(INITIALIZER_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);		
 	
@@ -225,6 +235,13 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	private int extraArrayDimensions = 0;
 
 	/**
+	 * List of extra dimensions this node has with optional annotations.
+	 * 
+	 * @since 3.9
+	 */
+	protected ASTNode.NodeList extraDimensionInfos = null;
+
+	/**
 	 * The initializer expression, or <code>null</code> if none;
 	 * defaults to none.
 	 */
@@ -253,6 +270,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			this.modifiers = new ASTNode.NodeList(MODIFIERS2_PROPERTY);
 			if (ast.apiLevel >= AST.JLS8) {
 				this.varargsAnnotations = new ASTNode.NodeList(VARARGS_ANNOTATIONS_PROPERTY);
+				this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
 			}
 		}
 	}
@@ -370,6 +388,9 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		if (property == VARARGS_ANNOTATIONS_PROPERTY) {
 			return varargsAnnotations();
 		}
+		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
+			return getExtraDimensionInfos();
+		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
 	}
@@ -394,7 +415,12 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			result.setVarargs(isVarargs());
 		}
 		result.setType((Type) getType().clone(target));
-		result.setExtraDimensions(getExtraDimensions());
+		if (this.ast.apiLevel >= AST.JLS8) {
+			result.extraDimensionInfos.addAll(
+					ASTNode.copySubtrees(target, this.extraDimensionInfos));
+		} else {
+			result.setExtraDimensions(getExtraDimensions());
+		}
 		result.setName((SimpleName) getName().clone(target));
 		result.setInitializer(
 			(Expression) ASTNode.copySubtree(target, getInitializer()));
@@ -429,6 +455,9 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 				acceptChildren(visitor, this.varargsAnnotations);
 			}
 			acceptChild(visitor, getName());
+			if (this.ast.apiLevel >= AST.JLS8){
+				acceptChildren(visitor, this.extraDimensionInfos);
+			}
 			acceptChild(visitor, getInitializer());
 		}
 		visitor.endVisit(this);
@@ -633,19 +662,32 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		postValueChange(VARARGS_PROPERTY);
 	}
 
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
+	/**
+	 * Returns the number of extra array dimensions over and above the
+	 * explicitly-specified type.
+	 *
+	 * @return the number of extra array dimensions
 	 * @since 2.1
 	 */
 	public int getExtraDimensions() {
+		if (this.ast.apiLevel >= AST.JLS8) {
+			return this.extraDimensionInfos.size();
+		}
 		return this.extraArrayDimensions;
 	}
 
-	/* (omit javadoc for this method)
-	 * Method declared on VariableDeclaration.
+	/**
+	 * Sets the number of extra array dimensions over and above the
+	 * explicitly-specified type (Not supported in JLS8 and above). 
+	 *
+	 * @param dimensions the number of array dimensions
+	 * @exception IllegalArgumentException if the number of dimensions is
+	 *    negative
 	 * @since 2.1
+	 * @deprecated In the JLS8 API, see: {@link #getExtraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
+		supportedOnlyIn2_3_4();
 		if (dimensions < 0) {
 			throw new IllegalArgumentException();
 		}
@@ -654,6 +696,17 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		postValueChange(EXTRA_DIMENSIONS_PROPERTY);
 	}
 
+	/**
+	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
+	 *
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
+	 * @since 3.9
+	 */
+	public List getExtraDimensionInfos() {
+		unsupportedIn2_3_4();
+		return this.extraDimensionInfos;
+	}
+
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
 	 */
@@ -693,7 +746,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 */
 	int memSize() {
 		// treat Operator as free
-		return BASE_NODE_SIZE + 8 * 4;
+		return BASE_NODE_SIZE + 9 * 4;
 	}
 
 	/* (omit javadoc for this method)
@@ -704,6 +757,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			memSize()
 			+ (this.varargsAnnotations == null ? 0 : this.varargsAnnotations.listSize())
 			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
+			+ (this.extraDimensionInfos == null ? 0 : this.extraDimensionInfos.listSize())
 			+ (this.type == null ? 0 : getType().treeSize())
 			+ (this.variableName == null ? 0 : getName().treeSize())
 			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize());
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
index e9de7c8..d484b01 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
@@ -25,7 +25,12 @@ import java.util.List;
  * VariableDeclarationFragment:
  *    Identifier { <b>[</b><b>]</b> } [ <b>=</b> Expression ]
  * </pre>
- *
+ * For JLS8, variable fragments and extra dimensions on fragments are allowed to have optional 
+ * annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
+ * <pre>
+ * VariableDeclarationFragment:
+ *    Identifier { DimensionInfo } [ <b>=</b> Expression ]
+ * </pre>
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
  */
@@ -40,12 +45,21 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 
 	/**
 	 * The "extraDimensions" structural property of this node type (type: {@link Integer}).
+	 *
 	 * @since 3.0
+	 * @deprecated in JLS8, use {@link VariableDeclarationFragment#EXTRA_DIMENSION_INFOS_PROPERTY} instead.
 	 */
 	public static final SimplePropertyDescriptor EXTRA_DIMENSIONS_PROPERTY =
 		new SimplePropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 
 	/**
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (Added in JLS8 API).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
+			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
 	 * @since 3.0
 	 */
@@ -60,6 +74,14 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 */
 	private static final List PROPERTY_DESCRIPTORS;
 
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 * @since 3.9
+	 */
+	private static final List PROPERTY_DESCRIPTORS_8_0;
+
 	static {
 		List propertyList = new ArrayList(4);
 		createPropertyList(VariableDeclarationFragment.class, propertyList);
@@ -67,6 +89,13 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		addProperty(EXTRA_DIMENSIONS_PROPERTY, propertyList);
 		addProperty(INITIALIZER_PROPERTY, propertyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(propertyList);
+
+		propertyList = new ArrayList(4);
+		createPropertyList(VariableDeclarationFragment.class, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
+		addProperty(EXTRA_DIMENSION_INFOS_PROPERTY, propertyList);
+		addProperty(INITIALIZER_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
 	}
 
 	/**
@@ -80,7 +109,11 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS;
+		if (apiLevel >= AST.JLS8) {
+			return PROPERTY_DESCRIPTORS_8_0;
+		} else {
+			return PROPERTY_DESCRIPTORS;
+		}
 	}
 
 	/**
@@ -96,6 +129,13 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	private int extraArrayDimensions = 0;
 
 	/**
+	 * The extra dimensions this node has with optional annotations.
+	 *
+	 * @since 3.9
+	 */
+	protected ASTNode.NodeList extraDimensionInfos = null;
+
+	/**
 	 * The initializer expression, or <code>null</code> if none;
 	 * defaults to none.
 	 */
@@ -113,6 +153,9 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 */
 	VariableDeclarationFragment(AST ast) {
 		super(ast);
+		if (ast.apiLevel >= AST.JLS8) {
+			this.extraDimensionInfos = new ASTNode.NodeList(EXTRA_DIMENSION_INFOS_PROPERTY);
+		}
 	}
 
 	/* (omit javadoc for this method)
@@ -189,6 +232,17 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
 	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
+			return getExtraDimensionInfos();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
 	final int getNodeType0() {
 		return VARIABLE_DECLARATION_FRAGMENT;
 	}
@@ -200,7 +254,12 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		VariableDeclarationFragment result = new VariableDeclarationFragment(target);
 		result.setSourceRange(getStartPosition(), getLength());
 		result.setName((SimpleName) getName().clone(target));
-		result.setExtraDimensions(getExtraDimensions());
+		if (this.ast.apiLevel >= AST.JLS8) {
+			result.extraDimensionInfos.addAll(
+					ASTNode.copySubtrees(target, this.extraDimensionInfos));
+		} else {
+			result.setExtraDimensions(getExtraDimensions());
+		}
 		result.setInitializer(
 			(Expression) ASTNode.copySubtree(target, getInitializer()));
 		return result;
@@ -222,6 +281,9 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		if (visitChildren) {
 			// visit children in normal left to right reading order
 			acceptChild(visitor, getName());
+			if (this.ast.apiLevel >= AST.JLS8) {
+				acceptChildren(visitor, this.extraDimensionInfos);
+			}
 			acceptChild(visitor, getInitializer());
 		}
 		visitor.endVisit(this);
@@ -272,6 +334,9 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 * @since 2.0
 	 */
 	public int getExtraDimensions() {
+		if (this.ast.apiLevel >= AST.JLS8) {
+			return this.extraDimensionInfos.size();
+		}
 		return this.extraArrayDimensions;
 	}
 
@@ -287,8 +352,10 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 *
 	 * @param dimensions the given dimensions
 	 * @since 2.0
+	 * @deprecated In the JLS8 API, see: {@link #getExtraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
+		supportedOnlyIn2_3_4();
 		if (dimensions < 0) {
 			throw new IllegalArgumentException();
 		}
@@ -297,6 +364,18 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		postValueChange(EXTRA_DIMENSIONS_PROPERTY);
 	}
 
+	/**
+	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
+	 *
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
+	 * @see AST#newDimensionInfo()
+	 * @since 3.9
+	 */
+	public List getExtraDimensionInfos() {
+		unsupportedIn2_3_4();
+		return this.extraDimensionInfos;
+	}
+
 	/* (omit javadoc for this method)
 	 * Method declared on VariableDeclaration.
 	 */
@@ -319,7 +398,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 */
 	int memSize() {
 		// treat Operator as free
-		return BASE_NODE_SIZE + 3 * 4;
+		return BASE_NODE_SIZE + 4 * 4;
 	}
 
 	/* (omit javadoc for this method)
@@ -329,6 +408,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		return
 			memSize()
 			+ (this.variableName == null ? 0 : getName().treeSize())
-			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize());
+			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize())
+			+ (this.extraDimensionInfos == null ? 0 : getExtraDimensionInfos().size());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index ecceda9..16072bc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -45,6 +45,7 @@ import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.ConditionalExpression;
 import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.ContinueStatement;
+import org.eclipse.jdt.core.dom.DimensionInfo;
 import org.eclipse.jdt.core.dom.UnionType;
 import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EmptyStatement;
@@ -416,6 +417,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	public boolean visit(DimensionInfo node) {
+		visitAnnotationsList(node.annotations());
+		this.buffer.append("["); //$NON-NLS-1$
+		if (node.expression() != null) {
+			node.expression().accept(this);
+		}
+		this.buffer.append("]"); //$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(AssertStatement)
 	 */
@@ -1037,8 +1048,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 			}
 		}
 		this.buffer.append(")");//$NON-NLS-1$
-		for (int i = 0; i < node.getExtraDimensions(); i++) {
-			this.buffer.append("[]"); //$NON-NLS-1$
+		int size = node.getExtraDimensions();
+		if (node.getAST().apiLevel() >= AST.JLS8) {
+			List dimensions = node.getExtraDimensionInfos();
+			for (int i = 0; i < size; i++) {
+				visit((DimensionInfo) dimensions.get(i));
+			}
+		} else {
+			for (int i = 0; i < size; i++) {
+				this.buffer.append("[]"); //$NON-NLS-1$
+			}
 		}
 		if (node.getAST().apiLevel() < AST.JLS8) {
 			if (!node.thrownExceptions().isEmpty()) {
@@ -1373,8 +1392,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		}
 		this.buffer.append(" ");//$NON-NLS-1$
 		node.getName().accept(this);
-		for (int i = 0; i < node.getExtraDimensions(); i++) {
-			this.buffer.append("[]"); //$NON-NLS-1$
+		int size = node.getExtraDimensions();
+		if (node.getAST().apiLevel() >= AST.JLS8) {
+			List dimensions = node.getExtraDimensionInfos();
+			for (int i = 0; i < size; i++) {
+				visit((DimensionInfo) dimensions.get(i));
+			}
+		} else {
+			for (int i = 0; i < size; i++) {
+				this.buffer.append("[]"); //$NON-NLS-1$
+			}
 		}
 		if (node.getInitializer() != null) {
 			this.buffer.append("=");//$NON-NLS-1$
@@ -1794,8 +1821,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 	 */
 	public boolean visit(VariableDeclarationFragment node) {
 		node.getName().accept(this);
-		for (int i = 0; i < node.getExtraDimensions(); i++) {
-			this.buffer.append("[]");//$NON-NLS-1$
+		int size = node.getExtraDimensions();
+		if (node.getAST().apiLevel() >= AST.JLS8) {
+			List dimensions = node.getExtraDimensionInfos();
+			for (int i = 0; i < size; i++) {
+				visit((DimensionInfo) dimensions.get(i));
+			}
+		} else {
+			for (int i = 0; i < size; i++) {
+				this.buffer.append("[]");//$NON-NLS-1$
+			}
 		}
 		if (node.getInitializer() != null) {
 			this.buffer.append("=");//$NON-NLS-1$
@@ -1860,14 +1895,17 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 	private void visitTypeAnnotations(AnnotatableType node) {
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List annotations = node.annotations();
-			if (annotations != null) {
-				for (Iterator it = annotations.iterator(); it.hasNext(); ) {
-					Annotation annotation = (Annotation) it.next();
-					annotation.accept(this);
-					this.buffer.append(' ');
-				}
+			visitAnnotationsList(node.annotations());
+		}
+	}
+
+	private void visitAnnotationsList(List annotations) {
+		if (annotations != null) {
+			for (Iterator it = annotations.iterator(); it.hasNext(); ) {
+				Annotation annotation = (Annotation) it.next();
+				annotation.accept(this);
+				this.buffer.append(' ');
 			}
 		}
-	}	
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 3dcc32a..26b723d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -77,6 +77,25 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	 * @deprecated
 	 */
 	/*package*/ static final int JLS3_INTERNAL = AST.JLS3;
+	
+	/**
+	 * Internal synonym for deprecated constant MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY = SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY = VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY;
 
 	TextEdit currentEdit;
 	final RewriteEventStore eventStore; // used from inner classes
@@ -1832,14 +1851,14 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 
 			pos= getScanner().getTokenEndOffset(TerminalTokens.TokenNameRPAREN, pos);
 
-			int extraDims= rewriteExtraDimensions(node, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY, pos);
+			int extraDims= rewriteExtraDimensions(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, pos);
 
 			boolean hasExceptionChanges= isChanged(node, MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
 
 			int bodyChangeKind= getChangeKind(node, MethodDeclaration.BODY_PROPERTY);
 
 			if ((extraDims > 0) && (hasExceptionChanges || bodyChangeKind == RewriteEvent.INSERTED || bodyChangeKind == RewriteEvent.REMOVED)) {
-				int dim= ((Integer) getOriginalValue(node, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY)).intValue();
+				int dim= ((Integer) getOriginalValue(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY)).intValue();
 				while (dim > 0) {
 					pos= getScanner().getTokenEndOffset(TerminalTokens.TokenNameRBRACKET, pos);
 					dim--;
@@ -2844,7 +2863,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 		}
 
 		pos= rewriteRequiredNode(node, SingleVariableDeclaration.NAME_PROPERTY);
-		int extraDims= rewriteExtraDimensions(node, SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY, pos);
+		int extraDims= rewriteExtraDimensions(node, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, pos);
 
 		if (extraDims > 0) {
 			int kind= getChangeKind(node, SingleVariableDeclaration.INITIALIZER_PROPERTY);
@@ -3244,7 +3263,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 
 		int pos= rewriteRequiredNode(node, VariableDeclarationFragment.NAME_PROPERTY);
 
-		int extraDims= rewriteExtraDimensions(node, VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY, pos);
+		int extraDims= rewriteExtraDimensions(node, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, pos);
 
 		if (extraDims > 0) {
 			int kind= getChangeKind(node, VariableDeclarationFragment.INITIALIZER_PROPERTY);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index cef0301..fca9572 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -35,6 +35,25 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	 */
 	/*package*/ static final int JLS3_INTERNAL = AST.JLS3;
 
+	/**
+	 * Internal synonym for deprecated constant MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY = MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY = SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY;
+	/**
+	 * Internal synonym for deprecated constant VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY
+	 * to alleviate deprecated warnings.
+	 * @deprecated
+	 */
+	static final SimplePropertyDescriptor INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY = VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY;
+
 	public static String asString(ASTNode node, RewriteEventStore store) {
 		ASTRewriteFlattener flattener= new ASTRewriteFlattener(store);
 		node.accept(flattener);
@@ -622,7 +641,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		this.result.append('(');
 		visitList(node, MethodDeclaration.PARAMETERS_PROPERTY, String.valueOf(','));
 		this.result.append(')');
-		int extraDims= getIntAttribute(node, MethodDeclaration.EXTRA_DIMENSIONS_PROPERTY);
+		int extraDims= getIntAttribute(node, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY);
 		for (int i = 0; i < extraDims; i++) {
 			this.result.append("[]"); //$NON-NLS-1$
 		}
@@ -788,7 +807,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		}
 		this.result.append(' ');
 		getChildNode(node, SingleVariableDeclaration.NAME_PROPERTY).accept(this);
-		int extraDimensions= getIntAttribute(node, SingleVariableDeclaration.EXTRA_DIMENSIONS_PROPERTY);
+		int extraDimensions= getIntAttribute(node, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY);
 		for (int i = 0; i < extraDimensions; i++) {
 			this.result.append("[]"); //$NON-NLS-1$
 		}
@@ -1033,7 +1052,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	 */
 	public boolean visit(VariableDeclarationFragment node) {
 		getChildNode(node, VariableDeclarationFragment.NAME_PROPERTY).accept(this);
-		int extraDimensions= getIntAttribute(node, VariableDeclarationFragment.EXTRA_DIMENSIONS_PROPERTY);
+		int extraDimensions= getIntAttribute(node, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY);
 		for (int i = 0; i < extraDimensions; i++) {
 			this.result.append("[]"); //$NON-NLS-1$
 		}
commit a6672627189e3721a2c066ce225fd09afe979f63
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Jan 31 17:22:17 2013 +0530

    Fix for bug 391895 - Changes missed out due conflict

1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index eb1a368..f879427 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -646,9 +646,9 @@ public class MethodDeclaration extends BodyDeclaration {
 			}
 			acceptChildren(visitor, this.parameters);
 			if (this.ast.apiLevel() < AST.JLS8) {
-				acceptChildren(visitor, this.extraDimensionInfos);
 				acceptChildren(visitor, this.thrownExceptions);				
 			} else {
+				acceptChildren(visitor, this.extraDimensionInfos);
 				acceptChildren(visitor, this.thrownExceptionTypes);				
 			}
 			acceptChild(visitor, getBody());
commit 7df061f9da0ab96be87e5851cb157a28c5f5bca0
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Sun Feb 3 22:23:42 2013 +0530

    Fix for bug 391895 - Rename DimensionInfo to ExtraDimension and remove
    expression from same.

7	7	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
32	32	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
4	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
4	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
7	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
0	225	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
156	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
8	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
8	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
10	10	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
9	13	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index addb847..d71cc44 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -1050,25 +1050,25 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		List fragments = field.fragments();
 		assertEquals("Incorrect no of fragments", 3, fragments.size());
 		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
-		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 []");
 		fragment = (VariableDeclarationFragment) fragments.get(1);
-		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot4 []");		
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot4 []");		
 		fragment = (VariableDeclarationFragment) fragments.get(2);
-		assertExtraDimensionsEqual("Incorrect dimension info", fragment.getExtraDimensionInfos(), "[] [] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", fragment.extraDimensionInfos(), "[] [] []");
 		MethodDeclaration[] methods = type.getMethods();
 		assertEquals("Incorrect no of methods", 3, methods.length);
 		MethodDeclaration method = methods[0];
 		List parameters = method.parameters();
 		assertEquals("Incorrect no of parameters", 1, parameters.size());
-		assertExtraDimensionsEqual("Incorrect dimension info", ((SingleVariableDeclaration) parameters.get(0)).getExtraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensionInfos(), "@Annot2 @Annot3 [] @Annot3 @Annot2 [] @Annot4 @Annot3 []");
 
 		method = methods[1];
 		parameters = method.parameters();
 		assertEquals("Incorrect no of parameters", 1, parameters.size());
-		assertExtraDimensionsEqual("Incorrect dimension info", ((SingleVariableDeclaration) parameters.get(0)).getExtraDimensionInfos(), "[] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", ((SingleVariableDeclaration) parameters.get(0)).extraDimensionInfos(), "[] []");
 
 		method = methods[2];
-		assertExtraDimensionsEqual("Incorrect dimension info", method.getExtraDimensionInfos(), "@Annot1 @Annot2 [] []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensionInfos(), "@Annot1 @Annot2 [] []");
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399600
 	public void test0010() throws JavaModelException {
@@ -1090,6 +1090,6 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		node = getASTNode(unit, 0, 0);
 		assertEquals("Not a method declaration", ASTNode.METHOD_DECLARATION, node.getNodeType());
 		MethodDeclaration method = (MethodDeclaration) node;
-		assertExtraDimensionsEqual("Incorrect dimension info", method.getExtraDimensionInfos(), "@Marker [] @Marker []");
+		assertExtraDimensionsEqual("Incorrect extra dimensions", method.extraDimensionInfos(), "@Marker [] @Marker []");
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
index 9781546..d0de9ee 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterAST8Test.java
@@ -2719,23 +2719,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2762,23 +2762,23 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10");//$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		VariableDeclarationStatement statement = this.ast.newVariableDeclarationStatement(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("z"));//$NON-NLS-1$
 		fragment.setInitializer(this.ast.newNullLiteral());
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		statement.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		statement.fragments().add(fragment);
 		statement.setType(this.ast.newArrayType(this.ast.newPrimitiveType(PrimitiveType.INT), 1));
 		assertTrue("Both AST trees should be identical", statement.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2804,8 +2804,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.getExtraDimensionInfos().clear();
-		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		variableDeclarationFragment.extraDimensionInfos().clear();
+		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String")), 1));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2833,8 +2833,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.getExtraDimensionInfos().clear();
-		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		variableDeclarationFragment.extraDimensionInfos().clear();
+		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2862,8 +2862,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		VariableDeclarationFragment variableDeclarationFragment = this.ast.newVariableDeclarationFragment();
 		variableDeclarationFragment.setName(this.ast.newSimpleName("tab")); //$NON-NLS-1$
 		variableDeclarationFragment.setInitializer(this.ast.newNullLiteral());//$NON-NLS-1$
-		variableDeclarationFragment.getExtraDimensionInfos().clear();
-		variableDeclarationFragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		variableDeclarationFragment.extraDimensionInfos().clear();
+		variableDeclarationFragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		VariableDeclarationExpression variableDeclarationExpression = this.ast.newVariableDeclarationExpression(variableDeclarationFragment);
 		variableDeclarationExpression.setType(this.ast.newSimpleType(this.ast.newSimpleName("String")));//$NON-NLS-1$
 		forStatement.initializers().add(variableDeclarationExpression);
@@ -2892,7 +2892,7 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not a declaration", frag.getName().isDeclaration()); //$NON-NLS-1$
 		VariableDeclarationFragment fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i")); //$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
@@ -2914,25 +2914,25 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		NumberLiteral literal = this.ast.newNumberLiteral();
 		literal.setToken("10"); //$NON-NLS-1$
 		fragment.setInitializer(literal);
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(fragment);
 		fieldDeclaration.modifiers().add(this.ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
 		fieldDeclaration.setType(this.ast.newPrimitiveType(PrimitiveType.INT));
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("y"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		fragment.setInitializer(this.ast.newNullLiteral());
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("i"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
+		fragment.extraDimensionInfos().clear();
 		fieldDeclaration.fragments().add(fragment);
 		fragment = this.ast.newVariableDeclarationFragment();
 		fragment.setName(this.ast.newSimpleName("j"));//$NON-NLS-1$
-		fragment.getExtraDimensionInfos().clear();
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
-		fragment.getExtraDimensionInfos().add(this.ast.newDimensionInfo());
+		fragment.extraDimensionInfos().clear();
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
+		fragment.extraDimensionInfos().add(this.ast.newExtraDimension());
 		fieldDeclaration.fragments().add(fragment);
 		assertTrue("Both AST trees should be identical", fieldDeclaration.subtreeMatch(new ASTMatcher(), node));		//$NON-NLS-1$
 		checkSourceRange(node, "public int x= 10, y[] = null, i, j[][];", source); //$NON-NLS-1$
@@ -9604,8 +9604,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertNotNull("No type binding", typeBinding2); //$NON-NLS-1$
 		assertEquals("Wrong qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
-		List extraDimensions = methodDeclaration.getExtraDimensionInfos();
-		assertExtraDimensionsEqual("Wrong extra dimension info", extraDimensions, "[]");
+		List extraDimensions = methodDeclaration.extraDimensionInfos();
+		assertExtraDimensionsEqual("Wrong extra extra dimensions", extraDimensions, "[]");
 	}
 
 	/**
@@ -9692,8 +9692,8 @@ public class ASTConverterAST8Test extends ConverterTestSetup {
 		assertTrue("Not an array binding", typeBinding2.isArray()); //$NON-NLS-1$
 		assertEquals("Wrong dimension", 1, typeBinding2.getDimensions()); //$NON-NLS-1$
 		assertEquals("wrong fully qualified name", "java.lang.String[]", typeBinding2.getQualifiedName()); //$NON-NLS-1$ //$NON-NLS-2$
-		List extraDimensions = singleVariableDeclaration.getExtraDimensionInfos();
-		assertExtraDimensionsEqual("Wrong extra dimension info", extraDimensions, "[]");
+		List extraDimensions = singleVariableDeclaration.extraDimensionInfos();
+		assertExtraDimensionsEqual("Wrong extra extra dimensions", extraDimensions, "[]");
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
index cc859b3..8694f67 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ConverterTestSetup.java
@@ -146,7 +146,7 @@ public abstract class ConverterTestSetup extends AbstractASTTests {
 		StringBuffer buffer = new StringBuffer();
 		Iterator iter = dimensions.iterator();
 		while(iter.hasNext()) {
-			DimensionInfo dim = (DimensionInfo) iter.next();
+			ExtraDimension dim = (ExtraDimension) iter.next();
 			Iterator annotations = dim.annotations().iterator();
 			while (annotations.hasNext()) {
 				buffer.append('@');
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index b6c2514..a15e677 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1116,10 +1116,10 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented annotatable dimension info node
+	 * Creates and returns a new unparented annotatable extra dimension node
 	 * (Supported only in JLS8 level).
 	 *
-	 * @return a new unparented annotatable dimension info node
+	 * @return a new unparented annotatable extra dimension node
 	 * @exception IllegalArgumentException if:
 	 * <ul>
 	 * <li>the node belongs to a different AST</li>
@@ -1129,8 +1129,8 @@ public final class AST {
 	 *            in a JLS2, JLS3 or JLS4 AST
 	 * @since 3.9
 	 */
-	public DimensionInfo newDimensionInfo() {
-		DimensionInfo result = new DimensionInfo(this);
+	public ExtraDimension newExtraDimension() {
+		ExtraDimension result = new ExtraDimension(this);
 		return result;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 790aec7..6d0d55d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -3055,9 +3055,9 @@ class ASTConverter {
 		return variableDecl;
 	}
 
-	private DimensionInfo convertToDimensionInfo(int start, int end, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotation) {
+	private ExtraDimension convertToExtraDimensions(int start, int end, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotation) {
 		int length = annotation == null ? 0 : annotation.length;
-		DimensionInfo dimension = this.ast.newDimensionInfo();
+		ExtraDimension dimension = this.ast.newExtraDimension();
 		for (int i = 0; i < length; i++) {
 			Annotation annot = convert(annotation[i]);
 			dimension.annotations.add(annot);
@@ -3160,7 +3160,7 @@ class ASTConverter {
 			org.eclipse.jdt.internal.compiler.ast.Annotation[][] annotationsOnDims = type.getAnnotationsOnDimensions();
 			int length = (annotationsOnDims == null) ? 0 : annotationsOnDims.length;
 			for (int i = (length - extraDimension); i < length; i++) {
-				DimensionInfo dim = convertToDimensionInfo(start, end, (annotationsOnDims == null) ? null : annotationsOnDims[i]);
+				ExtraDimension dim = convertToExtraDimensions(start, end, (annotationsOnDims == null) ? null : annotationsOnDims[i]);
 				extraAnnotatedDimensions.add(dim);
 				start = dim.getStartPosition() + dim.getLength();
 			}
@@ -4463,7 +4463,7 @@ class ASTConverter {
 		return dimensions;
 	}
 
-	protected void retrieveDimensionAndSetPositions(int start, int end, DimensionInfo dim) {
+	protected void retrieveDimensionAndSetPositions(int start, int end, ExtraDimension dim) {
 		this.scanner.resetTo(start, end);
 		int token;
 		boolean startSet = false;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 24de25a..c6fcb44 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -356,12 +356,11 @@ public class ASTMatcher {
 	 *   different node type or is <code>null</code>
 	 * @since 3.9
 	 */
-	public boolean match(DimensionInfo node, Object other) {
-		if (!(other instanceof DimensionInfo))
+	public boolean match(ExtraDimension node, Object other) {
+		if (!(other instanceof ExtraDimension))
 			return false;
-		DimensionInfo o = (DimensionInfo) other;
-		return safeSubtreeListMatch(node.annotations(), o.annotations())
-				&& safeSubtreeMatch(node.expression(), o.expression());
+		ExtraDimension o = (ExtraDimension) other;
+		return safeSubtreeListMatch(node.annotations(), o.annotations());
 	}
 
 	/**
@@ -1425,7 +1424,7 @@ public class ASTMatcher {
 				&& ((node.getAST().apiLevel < AST.JLS8) ?
 							(node.getExtraDimensions() == o.getExtraDimensions()
 								&& safeSubtreeListMatch(node.thrownExceptions(), o.thrownExceptions())) :
-							(safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos())
+							(safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos())
 								&& safeSubtreeListMatch(node.thrownExceptionTypes(), o.thrownExceptionTypes())))
 				&& safeSubtreeMatch(node.getBody(), o.getBody()));
 	}
@@ -1904,7 +1903,7 @@ public class ASTMatcher {
 				&& safeSubtreeMatch(node.getName(), o.getName())
 	 			&& ((node.getAST().apiLevel < AST.JLS8) ?
 	 					node.getExtraDimensions() == o.getExtraDimensions() :
-	 						safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos()))
+	 						safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos()))
 				&& safeSubtreeMatch(node.getInitializer(), o.getInitializer())
 				&& (level >= AST.JLS8 && node.isVarargs()) ? safeSubtreeListMatch(node.varargsAnnotations(), o.varargsAnnotations()) : true;		
 	}
@@ -2399,7 +2398,7 @@ public class ASTMatcher {
 		return safeSubtreeMatch(node.getName(), o.getName())
 			&& ((node.getAST().apiLevel < AST.JLS8) ?
 					node.getExtraDimensions() == o.getExtraDimensions() :
-						safeSubtreeListMatch(node.getExtraDimensionInfos(), o.getExtraDimensionInfos()))
+						safeSubtreeListMatch(node.extraDimensionInfos(), o.extraDimensionInfos()))
 			&& safeSubtreeMatch(node.getInitializer(), o.getInitializer());
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 713d1a0..f79e6ed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -774,12 +774,12 @@ public abstract class ASTNode {
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>DimensionInfo</code>.
+	 * <code>ExtraDimension</code>.
 	 *
-	 * @see DimensionInfo
+	 * @see ExtraDimension
 	 * @since 3.9
 	 */
-	public static final int DIMENSION_INFO = 85;
+	public static final int EXTRA_DIMENSION = 85;
 
 	/**
 	 * Returns the node class for the corresponding node type.
@@ -961,8 +961,8 @@ public abstract class ASTNode {
 				return WhileStatement.class;
 			case WILDCARD_TYPE :
 				return WildcardType.class;
-			case DIMENSION_INFO:
-				return DimensionInfo.class;
+			case EXTRA_DIMENSION:
+				return ExtraDimension.class;
 		}
 		throw new IllegalArgumentException();
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index b01fad7..262d584 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -216,7 +216,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.9
 	 */
-	public boolean visit(DimensionInfo node) {
+	public boolean visit(ExtraDimension node) {
 		return true;
 	}
 
@@ -1622,7 +1622,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.9
 	 */
-	public void endVisit(DimensionInfo node) {
+	public void endVisit(ExtraDimension node) {
 		// do nothing by default
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
deleted file mode 100644
index 6687665..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DimensionInfo.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * The array dimension info node. The array dimension, represented as <b>[]</b>, can have
- * type annotations. It may also include an <code>Expression</code> depending on where it appears.
- * The only node that supports a dimension info with an expression is <code>ArrayCreation</code>.
- * This node type is supported only in JLS8 or later.
- * <p>
- * The dimension info node is used to represent extra dimensions in the following nodes:
- * <pre>
- * 	SingleVariableDeclaration
- * 	VariableDeclarationFragment
- * 	MethodDeclaration
- * </pre>
- * For JLS8:
- * <pre>
- * DimensionInfo:
- * 	{ Annotations } <b>[</b> [ Expression ] <b>]</b>
- * </pre>
- *</p>
- * @see AST#newDimensionInfo()
- * @since 3.9
- */
-public class DimensionInfo extends ASTNode {
-
-
-	/**
-	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
-	 * @since 3.9
-	 */
-	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(DimensionInfo.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-
-	/**
-	 * The "expression" structural property of this node type (element type: {@link Expression}).
-	 * @since 3.9
-	 */
-	public static final ChildPropertyDescriptor EXPRESSION_PROPERTY =
-			new ChildPropertyDescriptor(DimensionInfo.class, "expression", Expression.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 * @since 3.9
-	 */
-	private static final List PROPERTY_DESCRIPTORS_8_0;
-
-	static {
-		List propertyList = new ArrayList(3);
-		createPropertyList(DimensionInfo.class, propertyList);
-		addProperty(ANNOTATIONS_PROPERTY, propertyList);
-		addProperty(EXPRESSION_PROPERTY, propertyList);
-		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 * @since 3.9
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_8_0;
-	}
-
-	/**
-	 * Create a new instance of DimensionInfo node (Supported only in level
-	 * JLS8 or above).  
-	 *
-	 * @param ast
-	 * @exception UnsupportedOperationException if this operation is used
-	 *            in a JLS2, JLS3 or JLS4 AST
-	 * @since 3.9
-	 */
-	DimensionInfo(AST ast) {
-		super(ast);
-		unsupportedIn2_3_4();
-		this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
-	}
-
-	/**
-	 * The list of annotations for this dimension (element type:
-	 * {@link Annotation}).
-	 */
-	ASTNode.NodeList annotations = null;
-	
-	/**
-	 * Returns the live ordered list of annotations for this dimension.
-	 *
-	 * @return the live list of annotations (element type: {@link Annotation})
-	 * @since 3.9
-	 */
-	public List annotations() {
-		return this.annotations;
-	}
-
-	private Expression expression = null;
-
-	/**
-	 * Sets the expression to this dimension. This operation will have
-	 * effect only if this dimension info node is part of an array creation
-	 * node.
-	 *
-	 * @param expression the expression for this dimension
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 *
-	 * @since 3.9
-	 */
-	public void setExpression(Expression expression) {
-		// an ArrayCreation cannot occur inside a ArrayType - cycles not possible
-		ASTNode oldChild = this.expression;
-		preReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-		this.expression = expression;
-		postReplaceChild(oldChild, expression, EXPRESSION_PROPERTY);
-	}
-
-	/**
-	 * Returns the expression in the dimension info or null if not applicable.
-	 *
-	 * @return the expression
-	 * @since 3.9
-	 */
-	public Expression expression() {
-		return this.expression;
-	}
-
-	List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == EXPRESSION_PROPERTY) {
-			if (get) {
-				return expression();
-			} else {
-				setExpression((Expression) child);
-				return null;
-			}
-		}
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == ANNOTATIONS_PROPERTY) {
-			return annotations();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	int getNodeType0() {
-		return DIMENSION_INFO;
-	}
-
-	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		return matcher.match(this, other);
-	}
-
-	ASTNode clone0(AST target) {
-		DimensionInfo result = new DimensionInfo(target);
-		result.annotations.addAll(
-				ASTNode.copySubtrees(target, annotations()));
-		if (this.expression != null) {
-			result.setExpression((Expression)expression().clone(target));
-		}
-		return result;
-	}
-
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChildren(visitor, this.annotations);
-			if (this.expression != null) {
-				acceptChild(visitor, this.expression);
-			}
-		}
-		visitor.endVisit(this);
-	}
-
-	int treeSize() {
-		int size = memSize()
-				+ this.annotations.listSize()
-				+ (this.expression == null ? 0 : this.expression.treeSize());
-			return size;
-	}
-
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
new file mode 100644
index 0000000..e67dcaf
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExtraDimension.java
@@ -0,0 +1,156 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The extra dimension node. The extra dimensions, represented as <b>[]</b>, are allowed to have
+ * type annotations. This node type is supported only in JLS8 or later.
+ * <p>
+ * The extra dimension node is used to represent extra dimensions in the following nodes:
+ * <pre>
+ * 	SingleVariableDeclaration
+ * 	VariableDeclarationFragment
+ * 	MethodDeclaration
+ * </pre>
+ * For JLS8:
+ * <pre>
+ * ExtraDimension:
+ * 	{ Annotations } <b>[]</b>
+ * </pre>
+ *</p>
+ * @see AST#newExtraDimension()
+ * @since 3.9
+ */
+public class ExtraDimension extends ASTNode {
+
+
+	/**
+	 * The "annotations" structural property of this node type (child type: {@link Annotation}).
+	 * @since 3.9
+	 */
+	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
+		new ChildListPropertyDescriptor(ExtraDimension.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 * @since 3.9
+	 */
+	private static final List PROPERTY_DESCRIPTORS_8_0;
+
+	static {
+		List propertyList = new ArrayList(3);
+		createPropertyList(ExtraDimension.class, propertyList);
+		addProperty(ANNOTATIONS_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 * @since 3.9
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_8_0;
+	}
+
+	/**
+	 * Create a new instance of ExtraDimension node (Supported only in level
+	 * JLS8 or above).  
+	 *
+	 * @param ast
+	 * @exception UnsupportedOperationException if this operation is used
+	 *            in a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9
+	 */
+	ExtraDimension(AST ast) {
+		super(ast);
+		unsupportedIn2_3_4();
+		this.annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
+	}
+
+	/**
+	 * The list of annotations for this dimension (element type:
+	 * {@link Annotation}).
+	 */
+	ASTNode.NodeList annotations = null;
+	
+	/**
+	 * Returns the live ordered list of annotations for this dimension.
+	 *
+	 * @return the live list of annotations (element type: {@link Annotation})
+	 * @since 3.9
+	 */
+	public List annotations() {
+		return this.annotations;
+	}
+
+	List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == ANNOTATIONS_PROPERTY) {
+			return annotations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	int getNodeType0() {
+		return EXTRA_DIMENSION;
+	}
+
+	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		return matcher.match(this, other);
+	}
+
+	ASTNode clone0(AST target) {
+		ExtraDimension result = new ExtraDimension(target);
+		result.annotations.addAll(
+				ASTNode.copySubtrees(target, annotations()));
+		return result;
+	}
+
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChildren(visitor, this.annotations);
+		}
+		visitor.endVisit(this);
+	}
+
+	int treeSize() {
+		int size = memSize()
+				+ this.annotations.listSize();
+			return size;
+	}
+
+	int memSize() {
+		return BASE_NODE_SIZE + 4;
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
index f879427..cca8ae2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodDeclaration.java
@@ -54,14 +54,14 @@ import java.util.List;
  *        [<b>throws</b> TypeName { <b>,</b> TypeName } ] Block
  * </pre>
  * For JLS8 optional receiver parameter is added and extra dimensions are allowed to have 
- * type annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
+ * type annotations. The annotatable extra dimensions are represented by {@link ExtraDimension}.
  * <pre>
  * MethodDeclaration:
  *    [ Javadoc ] { ExtendedModifier }
  *		  [ <b>&lt;</b> TypeParameter { <b>,</b> TypeParameter } <b>&gt;</b> ]
  *        ( Type | <b>void</b> ) Identifier <b>(</b>
  *        	[ ReceiverParameter ]
- *         	[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> { DimensionInfo }
+ *         	[ <b>, </b> FormalParameter { <b>,</b> FormalParameter } ] <b>)</b> { ExtraDimension }
  *        [ <b>throws</b> TypeName { <b>,</b> TypeName } ] ( Block | <b>;</b> )
  * ConstructorDeclaration:
  *    [ Javadoc ] { ExtendedModifier }
@@ -148,11 +148,11 @@ public class MethodDeclaration extends BodyDeclaration {
 		new SimplePropertyDescriptor(MethodDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 	
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (added in JLS8 API).
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(MethodDeclaration.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
+			new ChildListPropertyDescriptor(MethodDeclaration.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "typeParameters" structural property of this node type (element type: {@link TypeParameter}) (added in JLS3 API).
@@ -536,7 +536,7 @@ public class MethodDeclaration extends BodyDeclaration {
 			return thrownExceptionTypes();
 		}		
 		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return getExtraDimensionInfos();
+			return extraDimensionInfos();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -1052,7 +1052,7 @@ public class MethodDeclaration extends BodyDeclaration {
 	 * @exception IllegalArgumentException if the number of dimensions is
 	 *    negative
 	 * @since 2.1
-	 * @deprecated In the JLS8 API, use: {@link #getExtraDimensionInfos()}.
+	 * @deprecated In the JLS8 API, use: {@link #extraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
 		supportedOnlyIn2_3_4();
@@ -1067,10 +1067,10 @@ public class MethodDeclaration extends BodyDeclaration {
 	/**
 	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
 	 * 
-	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
 	 * @since 3.9
 	 */
-	public List getExtraDimensionInfos() {
+	public List extraDimensionInfos() {
 		unsupportedIn2_3_4();
 		return this.extraDimensionInfos;
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
index 4e81298..f585f4b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/SingleVariableDeclaration.java
@@ -37,10 +37,10 @@ import java.util.List;
  *    { ExtendedModifier } Type [ <b>...</b> ] Identifier { <b>[</b><b>]</b> } [ <b>=</b> Expression ]
  * </pre>
  * For JLS8, variable declarations and extra dimensions on variable declarations are allowed to 
- * have optional annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
+ * have optional annotations. The annotatable extra dimensions are represented by {@link ExtraDimension}.
  * <pre>
  * SingleVariableDeclaration:
- *    { ExtendedModifier } Type {Annotation} [ <b>...</b> ] Identifier { DimensionInfo } [ <b>=</b> Expression ]
+ *    { ExtendedModifier } Type {Annotation} [ <b>...</b> ] Identifier { ExtraDimension } [ <b>=</b> Expression ]
  * </pre>
  *
  * @since 2.0
@@ -100,11 +100,11 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 		new SimplePropertyDescriptor(SingleVariableDeclaration.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (added in JLS8 API).
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
+			new ChildListPropertyDescriptor(SingleVariableDeclaration.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
@@ -389,7 +389,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 			return varargsAnnotations();
 		}
 		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return getExtraDimensionInfos();
+			return extraDimensionInfos();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -684,7 +684,7 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	 * @exception IllegalArgumentException if the number of dimensions is
 	 *    negative
 	 * @since 2.1
-	 * @deprecated In the JLS8 API, see: {@link #getExtraDimensionInfos()}.
+	 * @deprecated In the JLS8 API, see: {@link #extraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
 		supportedOnlyIn2_3_4();
@@ -699,10 +699,10 @@ public class SingleVariableDeclaration extends VariableDeclaration {
 	/**
 	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
 	 *
-	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
 	 * @since 3.9
 	 */
-	public List getExtraDimensionInfos() {
+	public List extraDimensionInfos() {
 		unsupportedIn2_3_4();
 		return this.extraDimensionInfos;
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
index d484b01..20668d1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableDeclarationFragment.java
@@ -26,10 +26,10 @@ import java.util.List;
  *    Identifier { <b>[</b><b>]</b> } [ <b>=</b> Expression ]
  * </pre>
  * For JLS8, variable fragments and extra dimensions on fragments are allowed to have optional 
- * annotations. The annotatable extra dimensions are represented by {@link DimensionInfo}.
+ * annotations. The annotatable extra dimensions are represented by {@link ExtraDimension}.
  * <pre>
  * VariableDeclarationFragment:
- *    Identifier { DimensionInfo } [ <b>=</b> Expression ]
+ *    Identifier { ExtraDimension } [ <b>=</b> Expression ]
  * </pre>
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
@@ -53,11 +53,11 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 		new SimplePropertyDescriptor(VariableDeclarationFragment.class, "extraDimensions", int.class, MANDATORY); //$NON-NLS-1$
 
 	/**
-	 * The "extraDimensionInfos" structural property of this node type (child type: {@link DimensionInfo}) (Added in JLS8 API).
+	 * The "extraDimensionInfos" structural property of this node type (child type: {@link ExtraDimension}) (Added in JLS8 API).
 	 * @since 3.9
 	 */
 	public static final ChildListPropertyDescriptor EXTRA_DIMENSION_INFOS_PROPERTY =
-			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensionInfos", DimensionInfo.class, NO_CYCLE_RISK); //$NON-NLS-1$
+			new ChildListPropertyDescriptor(VariableDeclarationFragment.class, "extraDimensionInfos", ExtraDimension.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "initializer" structural property of this node type (child type: {@link Expression}).
@@ -234,7 +234,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 */
 	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
 		if (property == EXTRA_DIMENSION_INFOS_PROPERTY) {
-			return getExtraDimensionInfos();
+			return extraDimensionInfos();
 		}
 		// allow default implementation to flag the error
 		return super.internalGetChildListProperty(property);
@@ -352,7 +352,7 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	 *
 	 * @param dimensions the given dimensions
 	 * @since 2.0
-	 * @deprecated In the JLS8 API, see: {@link #getExtraDimensionInfos()}.
+	 * @deprecated In the JLS8 API, see: {@link #extraDimensionInfos()}.
 	 */
 	public void setExtraDimensions(int dimensions) {
 		supportedOnlyIn2_3_4();
@@ -367,11 +367,11 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 	/**
 	 * Returns the live ordered list of extra dimensions with optional annotations (JLS8 API only).
 	 *
-	 * @return the live list of extra dimensions with optional annotations (element type: {@link DimensionInfo})
-	 * @see AST#newDimensionInfo()
+	 * @return the live list of extra dimensions with optional annotations (element type: {@link ExtraDimension})
+	 * @see AST#newExtraDimension()
 	 * @since 3.9
 	 */
-	public List getExtraDimensionInfos() {
+	public List extraDimensionInfos() {
 		unsupportedIn2_3_4();
 		return this.extraDimensionInfos;
 	}
@@ -409,6 +409,6 @@ public class VariableDeclarationFragment extends VariableDeclaration {
 			memSize()
 			+ (this.variableName == null ? 0 : getName().treeSize())
 			+ (this.optionalInitializer == null ? 0 : getInitializer().treeSize())
-			+ (this.extraDimensionInfos == null ? 0 : getExtraDimensionInfos().size());
+			+ (this.extraDimensionInfos == null ? 0 : extraDimensionInfos().size());
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 16072bc..0280a8e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -45,7 +45,7 @@ import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.ConditionalExpression;
 import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.ContinueStatement;
-import org.eclipse.jdt.core.dom.DimensionInfo;
+import org.eclipse.jdt.core.dom.ExtraDimension;
 import org.eclipse.jdt.core.dom.UnionType;
 import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EmptyStatement;
@@ -417,13 +417,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	public boolean visit(DimensionInfo node) {
+	public boolean visit(ExtraDimension node) {
 		visitAnnotationsList(node.annotations());
-		this.buffer.append("["); //$NON-NLS-1$
-		if (node.expression() != null) {
-			node.expression().accept(this);
-		}
-		this.buffer.append("]"); //$NON-NLS-1$
+		this.buffer.append("[]"); //$NON-NLS-1$
 		return false;
 	}
 
@@ -1050,9 +1046,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 		this.buffer.append(")");//$NON-NLS-1$
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.getExtraDimensionInfos();
+			List dimensions = node.extraDimensionInfos();
 			for (int i = 0; i < size; i++) {
-				visit((DimensionInfo) dimensions.get(i));
+				visit((ExtraDimension) dimensions.get(i));
 			}
 		} else {
 			for (int i = 0; i < size; i++) {
@@ -1394,9 +1390,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getName().accept(this);
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.getExtraDimensionInfos();
+			List dimensions = node.extraDimensionInfos();
 			for (int i = 0; i < size; i++) {
-				visit((DimensionInfo) dimensions.get(i));
+				visit((ExtraDimension) dimensions.get(i));
 			}
 		} else {
 			for (int i = 0; i < size; i++) {
@@ -1823,9 +1819,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getName().accept(this);
 		int size = node.getExtraDimensions();
 		if (node.getAST().apiLevel() >= AST.JLS8) {
-			List dimensions = node.getExtraDimensionInfos();
+			List dimensions = node.extraDimensionInfos();
 			for (int i = 0; i < size; i++) {
-				visit((DimensionInfo) dimensions.get(i));
+				visit((ExtraDimension) dimensions.get(i));
 			}
 		} else {
 			for (int i = 0; i < size; i++) {
