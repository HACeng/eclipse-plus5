commit 799bcf90c7e5ed6ce45339b7f5c6f4ecccd1d29c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Dec 15 17:44:48 2013 +0100

    Bug 423504 - [1.8] Implement "18.5.3 Functional Interface
    Parameterization Inference"

18	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
1	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
6	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
6	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
35	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
5	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
81	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
52	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index a29f7b3..d5dcab5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -212,4 +212,22 @@ public void testBug424038() {
 		"Type mismatch: cannot convert from List<Foo<E>.Stuff<E>> to List<Consumer<E>>\n" + 
 		"----------\n");
 }
+
+// https://bugs.eclipse.org/423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference" 
+public void testBug423504() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"public class X  {\n" + 
+			"  public static void main(String argv[]) {\n" + 
+			"    I<? extends Collection<String>> sorter = (List<String> m) -> { /* sort */ };\n" + 
+			"  }\n" + 
+			"} \n" + 
+			"\n" + 
+			"interface I<T> { \n" + 
+			"  public void sort(T col);\n" + 
+			"}\n"
+		});
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
index f0bf00e..21c5cbb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1957,11 +1958,6 @@ public void testReferenceExpressionInference3b() {
 		"	I<X,String> x2s = compose(this::bar, this::i2s);\n" + 
 		"	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 		"Type mismatch: cannot convert from I<Object,Object> to I<X,String>\n" +
-		"----------\n" + 
-		"2. ERROR in X.java (at line 7)\n" + 
-		"	I<X,String> x2s = compose(this::bar, this::i2s);\n" + 
-		"	                                     ^^^^^^^^^\n" + 
-		"The type X does not define i2s(Object) that is applicable here\n" + 
 		"----------\n");
 }
 public void testLambdaInference1() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index 964bd29..c6af705 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -20,6 +20,7 @@
  *							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super via I.super.m() syntax
  *							bug 404728 - [1.8]NPE on QualifiedSuperReference error
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -3647,7 +3648,7 @@ public void test400556e() {
 			"1. ERROR in X.java (at line 3)\n" + 
 			"	I<?, ?, ?> i = (String p) -> { return null; };\n" + 
 			"	                ^^^^^^\n" + 
-			"Lambda expression\'s parameter p is expected to be of type List<? extends List<ParameterType>>[]\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<?>>[]\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
@@ -3688,7 +3689,7 @@ public void test400556f() {
 			"1. ERROR in X.java (at line 3)\n" + 
 			"	I<? extends p.ParameterType, ? extends p.ExceptionType, ? extends p.ReturnType> i = (String p) -> { return null; };\n" + 
 			"	                                                                                     ^^^^^^\n" + 
-			"Lambda expression\'s parameter p is expected to be of type List<? extends List<ParameterType>>[]\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<? extends ParameterType>>[]\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
@@ -3850,7 +3851,7 @@ public void test400556i() {
 			"2. ERROR in X.java (at line 6)\n" + 
 			"	I<? super P, ? super T, ? super R> i = (String p) -> { return null; };\n" + 
 			"	                                        ^^^^^^\n" + 
-			"Lambda expression\'s parameter p is expected to be of type List<? extends List<P>>[]\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<? super P>>[]\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
@@ -3904,8 +3905,8 @@ public void test400556j() {
 			"----------\n" + 
 			"2. ERROR in X.java (at line 6)\n" + 
 			"	I<?, ?, ?> i = (String p) -> { return null; };\n" + 
-			"	               ^^^^^^^^^^^^^\n" + 
-			"The target type of this expression is not a well formed parameterized type due to bound(s) mismatch\n" + 
+			"	                ^^^^^^\n" + 
+			"Lambda expression\'s parameter p is expected to be of type List<? extends List<?>>[]\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=400556, [1.8][compiler] Visibility checks are missing for lambda/reference expressions
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 6933963..f2374ef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -15,7 +15,8 @@
  *							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
  *     Stephan Herrmann - Contribution for
- *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec) 
+ *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -102,7 +103,7 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 		// when during inference this expression mimics as an invocationSite,
 		// we simulate an *invocation* of this functional expression,
 		// where the expected type of the expression is the return type of the sam:
-		MethodBinding sam = this.expectedType.getSingleAbstractMethod(this.enclosingScope);
+		MethodBinding sam = this.expectedType.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sam != null) {
 			if (sam.isConstructor())
 				return sam.declaringClass;
@@ -116,9 +117,11 @@ public abstract class FunctionalExpression extends Expression implements PolyExp
 		return this.expectedType;
 	}
 	
+	public boolean argumentsTypeElided() { return true; /* only exception: lambda with explicit argument types. */ }
+
 	public TypeBinding resolveType(BlockScope blockScope) {
 		this.constant = Constant.NotAConstant;
-		MethodBinding sam = this.expectedType == null ? null : this.expectedType.getSingleAbstractMethod(blockScope);
+		MethodBinding sam = this.expectedType == null ? null : this.expectedType.getSingleAbstractMethod(blockScope, argumentsTypeElided());
 		if (sam == null) {
 			blockScope.problemReporter().targetTypeIsNotAFunctionalInterface(this);
 			return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index fcc662e..81158f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -20,6 +20,7 @@
  *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -43,10 +44,12 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
@@ -259,6 +262,34 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				if ((parameterType.tagBits & TagBits.HasMissingType) != 0) {
 					this.binding.tagBits |= TagBits.HasMissingType;
 				}
+			}
+		}
+		if (!argumentsTypeElided && !buggyArguments) {
+			ParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(this.expectedType);
+			if (withWildCards != null) {
+				// invoke 18.5.3 Functional Interface Parameterization Inference
+				InferenceContext18 ctx = new InferenceContext18(methodScope);
+				TypeBinding[] q = ctx.createBoundsForFunctionalInterfaceParameterizationInference(withWildCards);
+				if (q.length != this.arguments.length) {
+					// fail  TODO: can this still happen here?
+				} else {
+					if (ctx.reduceWithEqualityConstraints(this.argumentTypes, q)) {
+						TypeBinding[] a = withWildCards.arguments;
+						TypeBinding[] aprime = ctx.getFunctionInterfaceArgumentSolutions(a);
+						// TODO If F<A'1, ..., A'm> is a well-formed type, ...
+						ReferenceBinding genericType = withWildCards.genericType();
+						this.resolvedType = blockScope.environment().createParameterizedType(genericType, aprime, genericType.enclosingType());
+						this.descriptor = this.resolvedType.getSingleAbstractMethod(blockScope, false);
+					}
+				}
+			}
+		}
+		for (int i = 0; i < length; i++) {
+			Argument argument = this.arguments[i];
+			TypeBinding parameterType;
+			final TypeBinding expectedParameterType = haveDescriptor && i < this.descriptor.parameters.length ? this.descriptor.parameters[i] : null;
+			parameterType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];
+			if (parameterType != null && parameterType != TypeBinding.VOID) {
 				if (haveDescriptor && expectedParameterType != null && parameterType.isValidBinding() && TypeBinding.notEquals(parameterType, expectedParameterType)) {
 					this.scope.problemReporter().lambdaParameterTypeMismatched(argument, argument.type, expectedParameterType);
 				}
@@ -611,7 +642,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	
 	public boolean isCompatibleWith(final TypeBinding left, final Scope someScope) {
 		
-		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope);
+		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);
 		
 		if (sam == null || !sam.isValidBinding())
 			return false;
@@ -774,11 +805,11 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			return false;
 		
 		s = s.capture(this.enclosingScope, this.sourceEnd);
-		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope);
+		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sSam == null || !sSam.isValidBinding())
 			return false;
 		TypeBinding r1 = sSam.returnType;
-		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);
+		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope, true);
 		if (tSam == null || !tSam.isValidBinding())
 			return false;
 		TypeBinding r2 = tSam.returnType;
@@ -1077,4 +1108,4 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	public int diagnosticsSourceEnd() {
 		return this.body instanceof Block ? this.arrowPosition : this.sourceEnd;
 	}
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 17b11cb..96671f5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -39,6 +39,7 @@
  *								Bug 411964 - [1.8][null] leverage null type annotation in foreach statement
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -979,7 +980,7 @@ public void markInferenceFinished() {
 	this.inferenceKind |= InferenceContext18.CHECK_FINISHED;
 }
 public boolean hasInferenceFinished() {
-	return this.inferenceKind == 0 // only relevant if inference has been started
+	return (this.inferenceContext == null && this.inferenceKind == 0) // only relevant if inference has been started
 			|| (this.inferenceKind & InferenceContext18.CHECK_FINISHED) != 0;
 }
 public TypeBinding updateBindings(MethodBinding updatedBinding) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index c9f2d3d..1353af5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -21,6 +21,7 @@
  *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *							Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contribution for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -546,7 +547,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		if (targetType == null) // assumed to signal another primary error
 			return true;
 
-		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope); // cached/cheap call.
+		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true); // cached/cheap call.
 		
 		if (sam == null || !sam.isValidBinding())
 			return true;
@@ -624,7 +625,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		if (this.hasInferenceFinished)
 			return this.resolvedType != null ? this.resolvedType.isCompatibleWith(left, scope) : false;
 		// 15.28.2
-		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope);
+		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sam == null || !sam.isValidBinding())
 			return false;
 		boolean isCompatible;
@@ -652,12 +653,12 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			return false;
 		
 		s = s.capture(this.enclosingScope, this.sourceEnd);
-		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope);
+		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sSam == null || !sSam.isValidBinding())
 			return false;
 		TypeBinding r1 = sSam.returnType;
 		
-		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);
+		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope, true);
 		if (tSam == null || !tSam.isValidBinding())
 			return false;
 		TypeBinding r2 = tSam.returnType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
index 325f6cd..6b21073 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
@@ -48,7 +48,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			Scope scope = inferenceContext.scope;
 			if (!this.right.isFunctionalInterface(scope))
 				return FALSE;
-			MethodBinding sam = this.right.getSingleAbstractMethod(scope);
+			MethodBinding sam = this.right.getSingleAbstractMethod(scope, true);
 			if (sam == null)
 				return FALSE;
 			// TODO: this condition is awaiting confirmation, see http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000455.html 
@@ -123,7 +123,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			}
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
-				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope); // TODO derive with target type?
+				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
 				final Set variables = new HashSet();
 				if (lambda.argumentsTypeElided()) {
 					// i)
@@ -143,7 +143,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 				return Collections.singletonList(this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope)) { // TODO: && this.left is inexact
-				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope); // TODO derive with target type?
+				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
 				final Set variables = new HashSet();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index d5e7339..e3a0761 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -114,7 +114,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				TypeBinding t = this.right;
 				if (!t.isFunctionalInterface(scope))
 					return FALSE;
-				MethodBinding functionType = t.getSingleAbstractMethod(scope);
+				MethodBinding functionType = t.getSingleAbstractMethod(scope, true);
 				if (functionType == null)
 					return FALSE;
 				TypeBinding[] parameters = functionType.parameters;
@@ -203,7 +203,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			throw new IllegalStateException("Should not reach here with T being a proper type"); //$NON-NLS-1$
 		if (!t.isFunctionalInterface(inferenceContext.scope))
 			return FALSE;
-		MethodBinding functionType = t.getSingleAbstractMethod(inferenceContext.scope);
+		MethodBinding functionType = t.getSingleAbstractMethod(inferenceContext.scope, true);
 		if (functionType == null)
 			return FALSE;
 		// potentially-applicable method for the method reference when targeting T (15.28.1),
@@ -282,7 +282,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (returnType == TypeBinding.VOID)
 				throw new InferenceFailureException("expression has no value"); //$NON-NLS-1$
 
-			ParameterizedTypeBinding parameterizedType = parameterizedWithWildcard(returnType);
+			ParameterizedTypeBinding parameterizedType = InferenceContext18.parameterizedWithWildcard(returnType);
 			if (parameterizedType != null) {
 				TypeBinding[] arguments = parameterizedType.arguments;
 				InferenceVariable[] betas = inferenceContext.addTypeVariableSubstitutions(arguments);
@@ -313,18 +313,6 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		return true;
 	}
 
-	private static ParameterizedTypeBinding parameterizedWithWildcard(TypeBinding returnType) {
-		if (returnType.kind() != Binding.PARAMETERIZED_TYPE)
-			return null;
-		ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) returnType;
-		TypeBinding[] arguments = parameterizedType.arguments;
-		for (int i = 0; i < arguments.length; i++) {
-			if (arguments[i].isWildcard())
-				return parameterizedType;
-		}
-		return null;
-	}
-
 	Collection inputVariables(final InferenceContext18 context) {
 		// from 18.5.2.
 		if (this.left instanceof LambdaExpression) {
@@ -333,7 +321,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
-				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope); // TODO derive with target type?
+				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
 				final Set variables = new HashSet();
 				if (lambda.argumentsTypeElided()) {
 					// i)
@@ -365,7 +353,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				return Collections.singletonList(this.right);
 			}
 			if (this.right.isFunctionalInterface(context.scope) && !this.left.isExactMethodReference()) {
-				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope);
+				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true);
 				final Set variables = new HashSet();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index b3761e4..ceb80ec 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -25,6 +25,7 @@ import java.util.Set;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
+import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
  * Main class for new type inference as per JLS8 sect 18.
@@ -87,6 +88,12 @@ public class InferenceContext18 {
 		this.currentInvocation = site;
 	}
 
+	public InferenceContext18(Scope scope) {
+		this.scope = scope;
+		this.environment = scope.environment();
+		this.object = scope.getJavaLangObject();
+	}
+
 	/**
 	 * JLS 18.1.3: Create initial bounds from a given set of type parameters declarations.
 	 * @return the set of inference variables created for the given typeParameters
@@ -723,6 +730,80 @@ public class InferenceContext18 {
 		this.problemMethods.add(problemMethod);
 	}
 
+	public static ParameterizedTypeBinding parameterizedWithWildcard(TypeBinding returnType) {
+		if (returnType == null || returnType.kind() != Binding.PARAMETERIZED_TYPE)
+			return null;
+		ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) returnType;
+		TypeBinding[] arguments = parameterizedType.arguments;
+		for (int i = 0; i < arguments.length; i++) {
+			if (arguments[i].isWildcard())
+				return parameterizedType;
+		}
+		return null;
+	}
+
+	/**
+	 * Create initial bound set for 18.5.3 Functional Interface Parameterization Inference
+	 * @param functionalInterface the functional interface F<A1,..Am>
+	 * @return the parameter types Q1..Qk of the function type of the type F<α1, ..., αm> 
+	 */
+	public TypeBinding[] createBoundsForFunctionalInterfaceParameterizationInference(ParameterizedTypeBinding functionalInterface) {
+		this.currentBounds = new BoundSet();
+		TypeBinding[] a = functionalInterface.arguments;
+		InferenceVariable[] alpha = addInitialTypeVariableSubstitutions(a);
+
+		for (int i = 0; i < a.length; i++) {
+			TypeBound bound;
+			if (a[i].kind() == Binding.WILDCARD_TYPE) {
+				WildcardBinding wildcard = (WildcardBinding) a[i];
+				switch(wildcard.boundKind) {
+    				case Wildcard.EXTENDS :
+    					bound = new TypeBound(alpha[i], wildcard.allBounds(), ReductionResult.SUBTYPE);
+    					break;
+    				case Wildcard.SUPER :
+    					bound = new TypeBound(alpha[i], wildcard.bound, ReductionResult.SUPERTYPE);
+    					break;
+    				case Wildcard.UNBOUND :
+    					bound = new TypeBound(alpha[i], this.object, ReductionResult.SUBTYPE);
+    					break;
+    				default:
+    					continue; // cannot
+				}
+			} else {
+				bound = new TypeBound(alpha[i], a[i], ReductionResult.SAME);
+			}
+			this.currentBounds.addBound(bound);
+		}
+		TypeBinding falpha = substitute(functionalInterface);
+		return falpha.getSingleAbstractMethod(this.scope, true).parameters;
+	}
+
+	public boolean reduceWithEqualityConstraints(TypeBinding[] p, TypeBinding[] q) {
+		for (int i = 0; i < p.length; i++) {
+			try {
+				if (!this.reduceAndIncorporate(new ConstraintTypeFormula(p[i], q[i], ReductionResult.SAME)))
+					return false;
+			} catch (InferenceFailureException e) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	public TypeBinding[] getFunctionInterfaceArgumentSolutions(TypeBinding[] a) {
+		int m = a.length;
+		TypeBinding[] aprime = new TypeBinding[m];
+		for (int i = 0; i < this.inferenceVariables.length; i++) {
+			InferenceVariable alphai = this.inferenceVariables[i];
+			TypeBinding t = this.currentBounds.getInstantiation(alphai);
+			if (t != null)
+				aprime[i] = t;
+			else
+				aprime[i] = a[i];
+		}
+		return aprime;
+	}
+
 	// INTERIM: infrastructure for detecting failures caused by specific known incompleteness:
 	public static void missingImplementation(String msg) {
 		throw new UnsupportedOperationException(msg);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
index 677d2d8..1db5593 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionCastTypeBinding.java
@@ -11,6 +11,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *							Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.lookup;
@@ -32,12 +34,12 @@ public class IntersectionCastTypeBinding extends ReferenceBinding {
 		}
 	}
 	
-	public MethodBinding getSingleAbstractMethod(Scope scope) {
+	public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
 		if (this.singleAbstractMethod != null)
 			return this.singleAbstractMethod;
 		MethodBinding sam = samProblemBinding;  // guilty unless proven innocent !
 		for (int i = 0; i < this.length; i++) {
-			MethodBinding method = this.intersectingTypes[i].getSingleAbstractMethod(scope);
+			MethodBinding method = this.intersectingTypes[i].getSingleAbstractMethod(scope, replaceWildcards);
 			if (method != null) {
 				if (method.isValidBinding()) {
 					if (sam.isValidBinding())
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index ee1fbf1..64e4ae0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -27,6 +27,7 @@
  *								Bug 416174 - [1.8][compiler][null] Bogus name clash error with null annotations
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1315,12 +1316,12 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	public FieldBinding[] unResolvedFields() {
 		return this.fields;
 	}
-	public MethodBinding getSingleAbstractMethod(final Scope scope) {
+	public MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards) {
 		if (this.singleAbstractMethod != null) {
 			return this.singleAbstractMethod;
 		}
 		final ReferenceBinding genericType = genericType();
-		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);
+		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, true);
 		if (theAbstractMethod == null || !theAbstractMethod.isValidBinding())
 			return this.singleAbstractMethod = theAbstractMethod;
 		
@@ -1329,28 +1330,55 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		TypeBinding [] types = new TypeBinding[typeArguments.length];  // T1 ... Tn
 		for (int i = 0, length = typeArguments.length; i < length; i++) {
 			TypeBinding typeArgument = typeArguments[i];
-			switch (typeArgument.kind()) {
-				case Binding.WILDCARD_TYPE :
-					WildcardBinding wildcard = (WildcardBinding) typeArgument;
-					switch(wildcard.boundKind) {
-	    				case Wildcard.EXTENDS :
-	    				case Wildcard.SUPER :
-	    					types[i] = wildcard.bound;
-	    					break;
-	    				case Wildcard.UNBOUND :
-	    					// if Pi has upper bound Bi that mentions none of P1...Pn, then Ti = Bi; otherwise, Ti = Object
-	    					final TypeBinding upperBound = typeParameters[i].firstBound;
-							if (upperBound == null || typeParametersMentioned(upperBound)) {
-	    						types[i] = scope.getJavaLangObject();
-	    					} else {
-	    						types[i] = upperBound;
-	    					}
-	    					break;
-					}
-					break;
-				default :
-					types[i] = typeArgument;
-					break;
+			if (replaceWildcards && typeArgument.kind() == Binding.WILDCARD_TYPE) {
+				if (typeParameters[i].mentionsAny(typeParameters, i))
+					return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);
+				WildcardBinding wildcard = (WildcardBinding) typeArgument;
+				switch(wildcard.boundKind) {
+    				case Wildcard.EXTENDS :
+    					// If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi).
+    					// Note: neither Ui nor Bi is necessarily scalar -> need to collect all bounds
+    					TypeBinding[] otherUBounds = wildcard.otherBounds;
+    					TypeBinding[] otherBBounds = typeParameters[i].otherUpperBounds();
+    					int len = 2 + (otherUBounds != null ? otherUBounds.length : 0) + otherBBounds.length;
+    					ReferenceBinding[] allBounds = new ReferenceBinding[len];
+    					try {
+    						int idx = 0;
+    						// Ui
+	    					allBounds[idx++] = (ReferenceBinding) wildcard.bound;
+	    					if (otherUBounds != null)
+	    						for (int j = 0; j < otherUBounds.length; j++)
+	    							allBounds[idx++] = (ReferenceBinding) otherUBounds[j];
+	    					// Bi
+	    					allBounds[idx++] = (ReferenceBinding) typeParameters[i].firstBound;
+	    					for (int j = 0; j < otherBBounds.length; j++)
+	    						allBounds[idx++] = (ReferenceBinding) otherBBounds[j];
+    					} catch (ClassCastException cce) {
+    						return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);		    						
+    					}
+    					ReferenceBinding[] glb = Scope.greaterLowerBound(allBounds);
+    					if (glb == null || glb.length == 0) {
+							return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);
+						} else if (glb.length == 1) {
+							types[i] = glb[0];
+						} else {
+							types[i] = new IntersectionCastTypeBinding(glb, this.environment);
+						}
+    					break;
+    				case Wildcard.SUPER :
+    					// If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.
+    					types[i] = wildcard.bound;
+    					break;
+    				case Wildcard.UNBOUND :
+    					// If Ai is an unbound wildcard ?, then Ti = Bi.
+    					types[i] = typeParameters[i].firstBound;
+    					if (types[i] == null)
+    						types[i] = typeParameters[i].superclass; // assumably j.l.Object?
+    					break;
+				}
+			} else {
+				// If Ai is a type, then Ti = Ai.
+				types[i] = typeArgument;
 			}
 			if (typeParameters[i].boundCheck(null, types[i], scope) != TypeConstants.OK)
 				return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index 0fbea9b..cef21c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -15,6 +15,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 416174 - [1.8][compiler][null] Bogus name clash error with null annotations
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -188,12 +189,12 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 		this.arguments = typeArguments;
 	}
 	
-	public MethodBinding getSingleAbstractMethod(Scope scope) {
+	public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
 		if (this.singleAbstractMethod != null) {
 			return this.singleAbstractMethod;
 		}
 		final ReferenceBinding genericType = genericType();
-		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);
+		MethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, replaceWildcards);
 		if (theAbstractMethod == null || !theAbstractMethod.isValidBinding())
 			return this.singleAbstractMethod = theAbstractMethod;
 		
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 781cb2a..e520057 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -28,6 +28,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -1358,7 +1359,7 @@ public boolean isInterface() {
 
 public boolean isFunctionalInterface(Scope scope) {
 	MethodBinding method;
-	return isInterface() && (method = getSingleAbstractMethod(scope)) != null && method.isValidBinding();
+	return isInterface() && (method = getSingleAbstractMethod(scope, true)) != null && method.isValidBinding();
 }
 
 /**
@@ -1851,7 +1852,7 @@ private MethodBinding [] getInterfaceAbstractContracts(Scope scope) throws Inval
 	}
 	return contracts;
 }
-public MethodBinding getSingleAbstractMethod(Scope scope) {
+public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
 	
 	if (this.singleAbstractMethod != null) {
 		return this.singleAbstractMethod;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 5f0a17c..88b04a8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -20,6 +20,7 @@
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -1423,10 +1424,11 @@ public TypeVariableBinding[] typeVariables() {
 /**
  * Return the single abstract method of a functional interface, or null, if the receiver is not a functional interface as defined in JLS 9.8.
  * @param scope scope
+ * @param replaceWildcards Should wildcards be replaced following JLS 9.8? Say false for lambdas with explicit argument types which should apply 18.5.3
  *  
  * @return The single abstract method of a functional interface, or null, if the receiver is not a functional interface. 
  */
-public MethodBinding getSingleAbstractMethod(Scope scope) {
+public MethodBinding getSingleAbstractMethod(Scope scope, boolean replaceWildcards) {
 	return null;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index 7b6ed4a..6492a50 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -17,6 +17,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
+ *								Bug 423504 - [1.8] Implement "18.5.3 Functional Interface Parameterization Inference"
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -70,6 +71,21 @@ public class WildcardBinding extends ReferenceBinding {
 		return this.boundKind;
 	}
 	
+	public TypeBinding allBounds() {
+		if (this.otherBounds == null || this.otherBounds.length == 0)
+			return this.bound;
+		ReferenceBinding[] allBounds = new ReferenceBinding[this.otherBounds.length+1];
+		try {
+			allBounds[0] = (ReferenceBinding) this.bound;
+			System.arraycopy(this.otherBounds, 0, allBounds, 1, this.otherBounds.length);
+		} catch (ClassCastException cce) {
+			return this.bound;
+		} catch (ArrayStoreException ase) {
+			return this.bound;
+		}
+		return new IntersectionCastTypeBinding(allBounds, this.environment);
+	}
+
 	public ReferenceBinding actualType() {
 		return this.genericType;
 	}
