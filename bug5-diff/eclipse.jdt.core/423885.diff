commit 65f5152e309a08bb91b2b35f96e93b2fa93bae4f
Author: Gauthier JACQUES <gauthier.jacques@gmail.com>
Date:   Thu Aug 21 13:36:19 2014 +0530

    Fixed bug 423885 - JDT's implementation of JSR-199 reports wrong errors
    with classes generated by APT
    
    Change-Id: I7be75aaa581610e35efc09204d1aeb21601fbf08
    Signed-off-by: Gauthier JACQUES <gauthier.jacques@gmail.com>

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
18	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/jsr199/F.java
13	1	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
26	0	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/ModelTests.java
66	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseBatchRequestor.java
5	150	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
43	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerRequestor.java
147	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseDiagnostic.java
48	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BatchCompilerRequestor.java
1	21	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index 79b1cdb..2524570 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/jsr199/F.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/jsr199/F.java
new file mode 100644
index 0000000..430b14f
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/jsr199/F.java
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package targets.jsr199;
+
+public class F {
+	
+	private static void staticMethod(){
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
index c020a08..3a8a0ab 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
@@ -97,7 +97,19 @@ public class BatchTestUtils {
 	public static void compileTree(JavaCompiler compiler, List<String> options, File targetFolder) {
 		compileTree(compiler, options, targetFolder, false);
 	}
+	
+	public static void compileTree(JavaCompiler compiler, List<String> options, File targetFolder, 
+			DiagnosticListener<? super JavaFileObject> listener) {
+		compileTree(compiler, options, targetFolder, false, listener);
+	}
+
 	public static void compileTree(JavaCompiler compiler, List<String> options, File targetFolder, boolean useJLS8Processors) {
+		compileTree(compiler, options, targetFolder, useJLS8Processors, null);
+	}
+
+	public static void compileTree(JavaCompiler compiler, List<String> options,
+			File targetFolder, boolean useJLS8Processors,
+			DiagnosticListener<? super JavaFileObject> listener) {
 		StandardJavaFileManager manager = compiler.getStandardFileManager(null, Locale.getDefault(), Charset.defaultCharset());
 
 		// create new list containing inputfile
@@ -113,7 +125,7 @@ public class BatchTestUtils {
 		options.add(_tmpGenFolderName);
 		addProcessorPaths(options, useJLS8Processors);
 		options.add("-XprintRounds");
-		CompilationTask task = compiler.getTask(printWriter, manager, null, options, null, units);
+		CompilationTask task = compiler.getTask(printWriter, manager, listener, options, null, units);
 		Boolean result = task.call();
 
 		if (!result.booleanValue()) {
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/ModelTests.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/ModelTests.java
index 71d41b9..26df4c8 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/ModelTests.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/ModelTests.java
@@ -17,6 +17,8 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import javax.tools.Diagnostic;
+import javax.tools.DiagnosticListener;
 import javax.tools.JavaCompiler;
 import javax.tools.ToolProvider;
 
@@ -127,6 +129,12 @@ public class ModelTests extends TestCase {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
 		internalTest(compiler, VISITORPROC);
 	}
+	
+	public void testReportedProblemsWithDiagnosticListener() throws IOException {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, ELEMENTPROC, 
+				"The method staticMethod() from the type targets.jsr199.F is never used locally\n");
+	}
 
 	/**
 	 * Test functionality by running a particular processor against the types in
@@ -147,6 +155,24 @@ public class ModelTests extends TestCase {
 		// if not, it will set it to an error value.
 		assertEquals("succeeded", System.getProperty(processorClass));
 	}
+	
+	@SuppressWarnings({ "rawtypes", "unchecked" })
+	private void internalTest(JavaCompiler compiler, String processorClass, String errors) throws IOException {
+		System.clearProperty(processorClass);
+		File targetFolder = TestUtils.concatPath(BatchTestUtils.getSrcFolderName(), "targets", "jsr199");
+		BatchTestUtils.copyResources("targets/jsr199", targetFolder);
+
+		List<String> options = new ArrayList<String>();
+		options.add("-A" + processorClass);
+		final StringBuffer reported = new StringBuffer();
+		BatchTestUtils.compileTree(compiler, options, targetFolder, new DiagnosticListener () {
+			@Override
+			public void report(Diagnostic diag) {
+				reported.append(diag.getMessage(null)).append("\n");
+			}});
+
+		assertEquals(errors, reported.toString());
+	}
 
 	@Override
 	protected void tearDown() throws Exception {
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseBatchRequestor.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseBatchRequestor.java
new file mode 100644
index 0000000..9b60897
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseBatchRequestor.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright (c) 2014 Gauthier JACQUES, IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *  Gauthier JACQUES - Initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.tool;
+
+import javax.tools.DiagnosticListener;
+import javax.tools.JavaFileObject;
+
+import org.eclipse.jdt.core.compiler.CategorizedProblem;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
+import org.eclipse.jdt.internal.compiler.batch.Main;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+
+public class EclipseBatchRequestor implements ICompilerRequestor {
+
+	private final Main compiler;
+	private int lineDelta = 0;
+	private final DiagnosticListener<? super JavaFileObject> diagnosticListener;
+	private final DefaultProblemFactory problemFactory;
+
+	public EclipseBatchRequestor(Main compiler,
+			DiagnosticListener<? super JavaFileObject> diagnosticListener,
+			DefaultProblemFactory problemFactory) {
+		this.compiler = compiler;
+		this.diagnosticListener = diagnosticListener;
+		this.problemFactory = problemFactory;
+	}
+
+	@Override
+	public void acceptResult(CompilationResult compilationResult) {
+		if (compilationResult.lineSeparatorPositions != null) {
+			int unitLineCount = compilationResult.lineSeparatorPositions.length;
+			this.lineDelta += unitLineCount;
+			if (this.compiler.showProgress && this.lineDelta > 2000) {
+				// in -log mode, dump a dot every 2000 lines compiled
+				this.compiler.logger.logProgress();
+				this.lineDelta = 0;
+			}
+		}
+		this.compiler.logger.startLoggingSource(compilationResult);
+		if (compilationResult.hasProblems() || compilationResult.hasTasks()) {
+			this.compiler.logger.logProblems(
+											compilationResult.getAllProblems(),					
+											compilationResult.compilationUnit.getContents(),
+											this.compiler);
+			reportProblems(compilationResult);
+		}
+		this.compiler.outputClassFiles(compilationResult);
+		this.compiler.logger.endLoggingSource();
+	}
+
+	private void reportProblems(CompilationResult result) {
+		for (CategorizedProblem problem : result.getAllProblems()) {
+			EclipseDiagnostic diagnostic = EclipseDiagnostic.newInstance(problem, this.problemFactory);
+			this.diagnosticListener.report(diagnostic);
+		}
+	}
+}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
index 0442038..2897d8d 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
@@ -35,16 +35,15 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.CompilationProgress;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
 import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
-import org.eclipse.jdt.internal.compiler.IProblemFactory;
 import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem;
-import org.eclipse.jdt.internal.compiler.batch.Main;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
+import org.eclipse.jdt.internal.compiler.batch.Main;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblem;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
-import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.Messages;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 
@@ -156,155 +155,11 @@ public class EclipseCompilerImpl extends Main {
 	}
 
 	@Override
-	public IProblemFactory getProblemFactory() {
-		return new DefaultProblemFactory() {
-			@Override
-			public CategorizedProblem createProblem(
-					final char[] originatingFileName,
-					final int problemId,
-					final String[] problemArguments,
-					final String[] messageArguments,
-					final int severity,
-					final int startPosition,
-					final int endPosition,
-					final int lineNumber,
-					final int columnNumber) {
-
-				DiagnosticListener<? super JavaFileObject> diagListener = EclipseCompilerImpl.this.diagnosticListener;
-				if (diagListener != null) {
-					diagListener.report(new Diagnostic<JavaFileObject>() {
-						@Override
-						public String getCode() {
-							return Integer.toString(problemId);
-						}
-						@Override
-						public long getColumnNumber() {
-							return columnNumber;
-						}
-						@Override
-						public long getEndPosition() {
-							return endPosition;
-						}
-						@Override
-						public Kind getKind() {
-							if ((severity & ProblemSeverities.Error) != 0) {
-								return Diagnostic.Kind.ERROR;
-							}
-							if ((severity & ProblemSeverities.Optional) != 0) {
-								return Diagnostic.Kind.WARNING;
-							}
-							if ((severity & ProblemSeverities.Warning) != 0) {
-								return Diagnostic.Kind.MANDATORY_WARNING;
-							}
-							return Diagnostic.Kind.OTHER;
-						}
-						@Override
-						public long getLineNumber() {
-							return lineNumber;
-						}
-						@Override
-						public String getMessage(Locale locale) {
-							if (locale != null) {
-								setLocale(locale);
-							}
-							return getLocalizedMessage(problemId, problemArguments);
-						}
-						@Override
-						public long getPosition() {
-							return startPosition;
-						}
-						@Override
-						public JavaFileObject getSource() {
-							File f = new File(new String(originatingFileName));
-							if (f.exists()) {
-								return new EclipseFileObject(null, f.toURI(), JavaFileObject.Kind.SOURCE, null);
-							}
-							return null;
-						}
-						@Override
-						public long getStartPosition() {
-							return startPosition;
-						}
-					});
-				}
-				return super.createProblem(originatingFileName, problemId, problemArguments, messageArguments, severity, startPosition, endPosition, lineNumber, columnNumber);
-			}
-			@Override
-			public CategorizedProblem createProblem(
-					final char[] originatingFileName,
-					final int problemId,
-					final String[] problemArguments,
-					final int elaborationID,
-					final String[] messageArguments,
-					final int severity,
-					final int startPosition,
-					final int endPosition,
-					final int lineNumber,
-					final int columnNumber) {
-
-				DiagnosticListener<? super JavaFileObject> diagListener = EclipseCompilerImpl.this.diagnosticListener;
-				if (diagListener != null) {
-					diagListener.report(new Diagnostic<JavaFileObject>() {
-						@Override
-						public String getCode() {
-							return Integer.toString(problemId);
-						}
-						@Override
-						public long getColumnNumber() {
-							return columnNumber;
-						}
-						@Override
-						public long getEndPosition() {
-							return endPosition;
-						}
-						@Override
-						public Kind getKind() {
-							if ((severity & ProblemSeverities.Error) != 0) {
-								return Diagnostic.Kind.ERROR;
-							}
-							if ((severity & ProblemSeverities.Optional) != 0) {
-								return Diagnostic.Kind.WARNING;
-							}
-							if ((severity & ProblemSeverities.Warning) != 0) {
-								return Diagnostic.Kind.MANDATORY_WARNING;
-							}
-							return Diagnostic.Kind.OTHER;
-						}
-						@Override
-						public long getLineNumber() {
-							return lineNumber;
-						}
-						@Override
-						public String getMessage(Locale locale) {
-							if (locale != null) {
-								setLocale(locale);
-							}
-							return getLocalizedMessage(problemId, problemArguments);
-						}
-						@Override
-						public long getPosition() {
-							return startPosition;
-						}
-						@Override
-						public JavaFileObject getSource() {
-							File f = new File(new String(originatingFileName));
-							if (f.exists()) {
-								return new EclipseFileObject(null, f.toURI(), JavaFileObject.Kind.SOURCE, null);
-							}
-							return null;
-						}
-						@Override
-						public long getStartPosition() {
-							return startPosition;
-						}
-					});
-				}
-				return super.createProblem(originatingFileName, problemId, problemArguments, elaborationID, messageArguments, severity, startPosition, endPosition, lineNumber, columnNumber);
-			}
-		};
+    public ICompilerRequestor getBatchRequestor() {
+        return new EclipseCompilerRequestor(this, this.diagnosticListener, (DefaultProblemFactory) getProblemFactory());
 	}
 
-	@Override
+						@Override
 	protected void initialize(PrintWriter outWriter, PrintWriter errWriter, boolean systemExit, Map customDefaultOptions, CompilationProgress compilationProgress) {
 		super.initialize(outWriter, errWriter, systemExit, customDefaultOptions, compilationProgress);
 		this.javaFileObjectMap = new HashMap<CompilationUnit, JavaFileObject>();
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerRequestor.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerRequestor.java
new file mode 100644
index 0000000..4cd1ab5
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerRequestor.java
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Gauthier JACQUES - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.compiler.tool;
+
+import javax.tools.DiagnosticListener;
+import javax.tools.JavaFileObject;
+
+import org.eclipse.jdt.core.compiler.CategorizedProblem;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.batch.BatchCompilerRequestor;
+import org.eclipse.jdt.internal.compiler.batch.Main;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+
+public class EclipseCompilerRequestor extends BatchCompilerRequestor {
+
+    private final DiagnosticListener<? super JavaFileObject> diagnosticListener;
+    private final DefaultProblemFactory problemFactory;
+
+    public EclipseCompilerRequestor(Main compiler, DiagnosticListener<? super JavaFileObject> diagnosticListener, DefaultProblemFactory problemFactory) {
+        super(compiler);
+        this.diagnosticListener = diagnosticListener;
+        this.problemFactory = problemFactory;
+    }
+
+    @Override
+	protected void reportProblems(CompilationResult result) {
+    	if (this.diagnosticListener != null) {
+    		for (CategorizedProblem problem : result.getAllProblems()) {
+                EclipseDiagnostic diagnostic = EclipseDiagnostic.newInstance(problem, this.problemFactory);
+                this.diagnosticListener.report(diagnostic);
+            }
+    	}
+    }
+}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseDiagnostic.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseDiagnostic.java
new file mode 100644
index 0000000..661c81d
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseDiagnostic.java
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Gauthier JACQUES - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.tool;
+
+import java.io.File;
+import java.util.Locale;
+
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+
+import org.eclipse.jdt.core.compiler.CategorizedProblem;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblem;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+
+public class EclipseDiagnostic implements Diagnostic<EclipseFileObject> {
+
+    private Kind kind;
+    private final int problemId;
+    private final String[] problemArguments;
+    private final char[] originatingFileName;
+    private final int lineNumber;
+    private final int columnNumber;
+    private final int startPosition;
+    private final int endPosition;
+    private final DefaultProblemFactory problemFactory;
+
+    private EclipseDiagnostic(Kind kind,
+                              int problemId,
+                              String[] problemArguments,
+                              char[] originatingFileName,
+                              DefaultProblemFactory problemFactory,
+                              int lineNumber,
+                              int columnNumber,
+                              int startPosition,
+                              int endPosition) {
+        this.kind = kind;
+        this.problemId = problemId;
+        this.problemArguments = problemArguments;
+        this.originatingFileName = originatingFileName;
+        this.problemFactory = problemFactory;
+        this.lineNumber = lineNumber;
+        this.columnNumber = columnNumber;
+        this.startPosition = startPosition;
+        this.endPosition = endPosition;
+    }
+
+    private EclipseDiagnostic(Kind kind,
+                              int problemId,
+                              String[] problemArguments,
+                              char[] originatingFileName,
+                              DefaultProblemFactory problemFactory) {
+        this(kind, problemId, problemArguments, originatingFileName, problemFactory, (int)Diagnostic.NOPOS, (int)Diagnostic.NOPOS, (int)Diagnostic.NOPOS, (int)Diagnostic.NOPOS);
+    }
+
+    public static EclipseDiagnostic newInstance(CategorizedProblem problem, DefaultProblemFactory factory) {
+        if(problem instanceof DefaultProblem) return newInstanceFromDefaultProblem((DefaultProblem) problem, factory);
+        return new EclipseDiagnostic(getKind(problem),
+              problem.getID(),
+              problem.getArguments(),
+              problem.getOriginatingFileName(),
+              factory);
+    }
+
+    private static EclipseDiagnostic newInstanceFromDefaultProblem(DefaultProblem problem, DefaultProblemFactory factory) {
+        return new EclipseDiagnostic(getKind(problem),
+              problem.getID(),
+              problem.getArguments(),
+              problem.getOriginatingFileName(),
+              factory,
+              problem.getSourceLineNumber(),
+              problem.getSourceColumnNumber(),
+              problem.getSourceStart(),
+              problem.getSourceEnd()
+        );
+    }
+
+    private static Kind getKind(CategorizedProblem problem) {
+        Kind kind = Kind.OTHER;
+        if(problem.isError()) {
+            kind = Kind.ERROR;
+        }
+        if(problem.isWarning()) {
+            kind = Kind.WARNING;
+        }
+        return kind;
+    }
+
+    @Override
+    public Kind getKind() {
+        return this.kind;
+    }
+
+    @Override
+    public EclipseFileObject getSource() {
+        File f = new File(new String(this.originatingFileName));
+        if (f.exists()) {
+            return new EclipseFileObject(null, f.toURI(), JavaFileObject.Kind.SOURCE, null);
+        }
+        return null;
+    }
+
+    @Override
+    public long getPosition() {
+        return this.startPosition;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public long getStartPosition() {
+        return this.startPosition;
+    }
+
+    @Override
+    public long getEndPosition() {
+        return this.endPosition;
+    }
+
+    @Override
+    public long getLineNumber() {
+        return this.lineNumber;
+    }
+
+    @Override
+    public long getColumnNumber() {
+        return this.columnNumber;
+    }
+
+    @Override
+    public String getCode() {
+        return Integer.toString(this.problemId);
+    }
+
+    @Override
+    public String getMessage(Locale locale) {
+        if (locale != null) {
+        	this.problemFactory.setLocale(locale);
+        }
+        return this.problemFactory.getLocalizedMessage(this.problemId, this.problemArguments);
+    }
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BatchCompilerRequestor.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BatchCompilerRequestor.java
new file mode 100644
index 0000000..bfaf56e
--- /dev/null
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BatchCompilerRequestor.java
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Gauthier JACQUES - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.batch;
+
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
+
+public class BatchCompilerRequestor implements ICompilerRequestor {
+
+    private Main compiler;
+    private int lineDelta = 0;
+
+    public BatchCompilerRequestor(Main compiler) {
+        this.compiler = compiler;
+    }
+
+    @Override
+    public void acceptResult(CompilationResult compilationResult) {
+        if (compilationResult.lineSeparatorPositions != null) {
+            int unitLineCount = compilationResult.lineSeparatorPositions.length;
+            this.lineDelta += unitLineCount;
+            if (this.compiler.showProgress && this.lineDelta > 2000) {
+                // in -log mode, dump a dot every 2000 lines compiled
+                this.compiler.logger.logProgress();
+                this.lineDelta = 0;
+            }
+        }
+        this.compiler.logger.startLoggingSource(compilationResult);
+        if (compilationResult.hasProblems() || compilationResult.hasTasks()) {
+        	this.compiler.logger.logProblems(compilationResult.getAllProblems(), compilationResult.compilationUnit.getContents(), this.compiler);
+            reportProblems(compilationResult);
+        }
+        this.compiler.outputClassFiles(compilationResult);
+        this.compiler.logger.endLoggingSource();
+    }
+
+    protected void reportProblems(CompilationResult result) {
+        // Nothing to do
+    }
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 805d94c..3e4c44e 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -1668,7 +1668,6 @@ private boolean checkVMVersion(long minimalSupportedVersion) {
  *  Low-level API performing the actual compilation
  */
 public boolean compile(String[] argv) {
-
 	// decode command line arguments
 	try {
 		configure(argv);
@@ -2972,26 +2971,7 @@ public String extractDestinationPathFromSourceFile(CompilationResult result) {
  * Answer the component to which will be handed back compilation results from the compiler
  */
 public ICompilerRequestor getBatchRequestor() {
-	return new ICompilerRequestor() {
-		int lineDelta = 0;
-		public void acceptResult(CompilationResult compilationResult) {
-			if (compilationResult.lineSeparatorPositions != null) {
-				int unitLineCount = compilationResult.lineSeparatorPositions.length;
-				this.lineDelta += unitLineCount;
-				if (Main.this.showProgress && this.lineDelta > 2000) {
-					// in -log mode, dump a dot every 2000 lines compiled
-					Main.this.logger.logProgress();
-					this.lineDelta = 0;
-				}
-			}
-			Main.this.logger.startLoggingSource(compilationResult);
-			if (compilationResult.hasProblems() || compilationResult.hasTasks()) {
-				Main.this.logger.logProblems(compilationResult.getAllProblems(), compilationResult.compilationUnit.getContents(), Main.this);
-			}
-			outputClassFiles(compilationResult);
-			Main.this.logger.endLoggingSource();
-		}
-	};
+    return new BatchCompilerRequestor(this);
 }
 /*
  *  Build the set of compilation source units
