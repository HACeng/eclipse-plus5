commit 4dbf58ed02c0dfb1caf57dde8ed3132339812324
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Aug 10 20:16:20 2017 +0200

    Bug 520826: [9] detect and report "API leaks"
    
    Change-Id: Ib41d97fc7572208f0d457b06c3b3c4e8f84b027c

2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
6	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
342	21	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
3	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
10	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
62	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
15	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
31	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
24	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index d0079a7..48e1815 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -998,7 +998,8 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.doc.comment.support\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.emulateJavacBug8031744\" value=\"enabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.generateClassFiles\" value=\"enabled\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.maxProblemPerUnit\" value=\"100\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.maxProblemPerUnit\" value=\"100\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.APILeak\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.annotationSuperInterface\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.assertIdentifier\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.autoboxing\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 3d8a591..de3a11f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -825,6 +825,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
+		expectedProblemAttributes.put("MissingRequiresTransitiveForTypeInAPI", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingReturnType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingSemiColon", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("MissingSerialVersion", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -865,6 +866,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullTypeVariableFromLegacyMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullMethodTypeVariableFromLegacyMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonPublicTypeInAPI", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -877,6 +879,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotAccessibleMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotAccessibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NotAccessiblePackage", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
+		expectedProblemAttributes.put("NotExportedTypeInAPI", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ConflictingPackageFromModules", new ProblemAttributes(CategorizedProblem.CAT_MODULE));
 		expectedProblemAttributes.put("ConflictingPackageFromOtherModules", new ProblemAttributes(CategorizedProblem.CAT_MODULE));
 		expectedProblemAttributes.put("NotVisibleConstructor", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1705,6 +1708,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
+		expectedProblemAttributes.put("MissingRequiresTransitiveForTypeInAPI", new ProblemAttributes(JavaCore.COMPILER_PB_API_LEAKS));
 		expectedProblemAttributes.put("MissingReturnType", SKIP);
 		expectedProblemAttributes.put("MissingSemiColon", SKIP);
 		expectedProblemAttributes.put("MissingSerialVersion", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION));
@@ -1745,6 +1749,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullTypeVariableFromLegacyMethod", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_TYPEVAR_FROM_LEGACY_INVOCATION));
 		expectedProblemAttributes.put("NonNullMethodTypeVariableFromLegacyMethod", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_TYPEVAR_FROM_LEGACY_INVOCATION));
+		expectedProblemAttributes.put("NonPublicTypeInAPI", new ProblemAttributes(JavaCore.COMPILER_PB_API_LEAKS));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
@@ -1757,6 +1762,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotAccessibleMethod", SKIP);
 		expectedProblemAttributes.put("NotAccessibleType", SKIP);
 		expectedProblemAttributes.put("NotAccessiblePackage", SKIP);
+		expectedProblemAttributes.put("NotExportedTypeInAPI", new ProblemAttributes(JavaCore.COMPILER_PB_API_LEAKS));
 		expectedProblemAttributes.put("ConflictingPackageFromModules", SKIP);
 		expectedProblemAttributes.put("ConflictingPackageFromOtherModules", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructor", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index b15532a..d78b0c9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -40,7 +40,7 @@ import junit.framework.Test;
 public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 
 	static {
-//		 TESTS_NAMES = new String[] { "test013" };
+//		 TESTS_NAMES = new String[] { "testAPILeakDetection" };
 		// TESTS_NUMBERS = new int[] { 1 };
 		// TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -124,7 +124,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				JavacCompiler javacCompiler = (JavacCompiler) comp;
 				if (javacCompiler.compliance < ClassFileConstants.JDK9)
 					continue;
-				commandLine = commandLine.replace(" -9", " -source 9");
+				commandLine = adjustForJavac(commandLine);
 				StringBuffer log = new StringBuffer();
 				try {
 					long compileResult = javacCompiler.compile(
@@ -190,7 +190,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				JavacCompiler javacCompiler = (JavacCompiler) comp;
 				if (javacCompiler.compliance < ClassFileConstants.JDK9)
 					continue;
-				commandLine = commandLine.replace(" -9", " -source 9");
+				commandLine = adjustForJavac(commandLine);
 				StringBuffer log = new StringBuffer();
 				try {
 					long compileResult = javacCompiler.compile(
@@ -217,6 +217,24 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			}
 		}
 	}
+
+	String adjustForJavac(String commandLine) {
+		String[] tokens = commandLine.split(" ");
+		StringBuffer buf = new StringBuffer();
+		for (int i = 0; i < tokens.length; i++) {
+			if (tokens[i].trim().equals("-9")) {
+				buf.append(" -source 9 ");
+				continue;
+			}
+			if (tokens[i].startsWith("-warn") || tokens[i].startsWith("-err") || tokens[i].startsWith("-info")) {
+				if (tokens[i].contains("exports") && !tokens[i].contains("-exports"))
+					buf.append(" -Xlint:exports ");
+				continue;
+			}
+			buf.append(tokens[i]).append(' ');
+		}
+		return buf.toString();
+	}
 	
 	private void walkOutFiles(final String outputLocation, final Set<String> fileNames, boolean add) {
 		if (!(new File(outputLocation)).exists()) 
@@ -499,6 +517,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
+			.append(" -warn:-exports") // Y.con unreliably refers to Connection (missing requires transitive)
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runConformModuleTest(files,
@@ -935,9 +954,6 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"",
 				false);
 	}
-	/*
-	 * Test with --add-exports, without a "requires", the packages are seen by the target module
-	 */
 	public void test015() {
 		File outputDirectory = new File(OUTPUT_DIR);
 		Util.flushDirectoryContent(outputDirectory);
@@ -977,11 +993,18 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two");
-		runConformModuleTest(files,
+		runNegativeModuleTest(files,
 				buffer,
 				"",
-				"",
+				"----------\n" +
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" +
+				"	java.sql.Connection con = p.X.getConnection();\n" +
+				"	                          ^\n" +
+				"p cannot be resolved\n" +
+				"----------\n" +
+				"1 problem (1 error)\n",
 				false,
+				"cannot be resolved",
 				OUTPUT_DIR + File.separator + out);
 	}
 	public void test016() {
@@ -1533,7 +1556,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"----------\n" + 
 				"1 problem (1 error)\n",
 				false,
-				"visible", 
+				"visible",
 				outDir);
 	}
 	public void test029() {
@@ -1542,7 +1565,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		List<String> files = new ArrayList<>(); 
+		List<String> files = new ArrayList<>();
 		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
@@ -1579,13 +1602,19 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		runNegativeModuleTest(files, 
 			buffer,
 			"",
-			"----------\n"+
-			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n"+
-			"	java.sql.Connection con = p.X.getConnection();\n"+
-			"	^^^^^^^^^^^^^^^^^^^\n"+
-			"The type java.sql.Connection is not accessible\n"+
-			"----------\n"+
-			"1 problem (1 error)\n",
+			"----------\n" +
+			"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/X.java (at line 3)\n" +
+			"	public static java.sql.Connection getConnection() {\n" +
+			"	              ^^^^^^^^^^^^^^^^^^^\n" +
+			"The type Connection from module java.sql is not accessible to clients due to missing \'requires transitive\'\n" +
+			"----------\n" +
+			"----------\n" +
+			"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" +
+			"	java.sql.Connection con = p.X.getConnection();\n" +
+			"	^^^^^^^^^^^^^^^^^^^\n" +
+			"The type java.sql.Connection is not accessible\n" +
+			"----------\n" +
+			"2 problems (1 error, 1 warning)\n",
 			false,
 			"visible");
 	}
@@ -1626,6 +1655,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
+			.append(" -warn:-exports") // getConnection() leaks non-transitively required type
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
@@ -1664,7 +1694,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
-						"	public static java.sql.Connection getConnection() {\n" +
+						"	static java.sql.Connection getConnection() {\n" +
 						"		return null;\n" +
 						"	}\n" +
 						"}");
@@ -2011,7 +2041,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		runConformModuleTest(files, 
 				buffer,
 				"",
-				"",
+				"----------\n" + 
+				"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/pm/C1.java (at line 4)\n" + 
+				"	public void m1(Other o) {}\n" + 
+				"	               ^^^^^\n" + 
+				"The type Other is not exported from this module\n" + 
+				"----------\n" + 
+				"1 problem (1 warning)\n",
 				false);
 	}
 
@@ -2075,18 +2111,25 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
+			.append(" -info:+exports")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runNegativeModuleTest(files, 
 				buffer,
 				"",
 				"----------\n" + 
-				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/po/Client.java (at line 8)\n" + 
+				"1. INFO in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/pm/C1.java (at line 4)\n" +
+				"	public void m1(SomeImpl o) {}\n" +
+				"	               ^^^^^^^^\n" +
+				"The type SomeImpl is not exported from this module\n" +
+				"----------\n" +
+				"----------\n" +
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/po/Client.java (at line 8)\n" +
 				"	one.m1(impl);\n" + 
 				"	    ^^\n" + 
 				"The method m1(impl.SomeImpl) in the type C1 is not applicable for the arguments (impl.SomeImpl)\n" + 
 				"----------\n" + 
-				"1 problem (1 error)\n",
+				"2 problems (1 error, 0 warnings, 1 info)\n",
 				false,
 				"incompatible",
 				OUTPUT_DIR + File.separator + out);
@@ -2452,4 +2495,282 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"cannot specify both",
 				OUTPUT_DIR + File.separator + out);
 	}
+
+	// causes: non-public type (C0), non-exported package (p.priv)
+	// locations: field, method parameter, method return
+	public void testAPILeakDetection1() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"import p.priv.*;\n" +
+						"class C0 {\n" +
+						"	public void test(C0 c) {}\n" +
+						"}\n" +
+						"public class C1 {\n" +
+						"	public C2 f;\n" +
+						"	public void test1(C0 c) {}\n" +
+						"	public void test2(C2 c) {}\n" +
+						"	protected void test3(C0 c) {}\n" +
+						"	protected void test4(C2 c) {}\n" +
+						"	public p.priv.C2 test5() { return null; }\n" +
+						"}\n");
+
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "priv", "C2.java", 
+						"package p.priv;\n" +
+						"public class C2 {\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeModuleTest(files, buffer,
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 7)\n" + 
+				"	public C2 f;\n" + 
+				"	       ^^\n" + 
+				"The type C2 is not exported from this module\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 8)\n" + 
+				"	public void test1(C0 c) {}\n" + 
+				"	                  ^^\n" + 
+				"The type C0 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 9)\n" + 
+				"	public void test2(C2 c) {}\n" + 
+				"	                  ^^\n" + 
+				"The type C2 is not exported from this module\n" + 
+				"----------\n" + 
+				"4. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 12)\n" + 
+				"	public p.priv.C2 test5() { return null; }\n" + 
+				"	       ^^^^^^^^^\n" + 
+				"The type C2 is not exported from this module\n" + 
+				"----------\n" + 
+				"4 problems (4 errors)\n",
+				false,
+				"is not exported");
+	}
+
+	// details: in array, parameterized type
+	public void testAPILeakDetection2() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"import java.util.*;\n" +
+						"class C0 {\n" +
+						"	public void test(C0 c) {}\n" +
+						"}\n" +
+						"public class C1 {\n" +
+						"	public List<C0> f1;\n" +
+						"	public C0[] f2;\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:+exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeModuleTest(files, buffer,
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 7)\n" + 
+				"	public List<C0> f1;\n" + 
+				"	            ^^\n" + 
+				"The type C0 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 8)\n" + 
+				"	public C0[] f2;\n" + 
+				"	       ^^\n" + 
+				"The type C0 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2 problems (2 errors)\n",
+				false,
+				"not accessible to clients");
+	}
+
+	// suppress
+	public void testAPILeakDetection3() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"import java.util.*;\n" +
+						"class C0 {\n" +
+						"	public void test(C0 c) {}\n" +
+						"}\n" +
+						"public class C1 {\n" +
+						"	@SuppressWarnings(\"exports\")\n" +
+						"	public List<C0> f1;\n" +
+						"	@SuppressWarnings(\"exports\")\n" +
+						"	public C0[] f2;\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -warn:+exports,+suppress")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runConformModuleTest(files,
+				buffer, 
+				"",
+				"",
+				false);
+	}
+	
+	// details: nested types
+	public void testAPILeakDetection4() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"public class C1 {\n" +
+						"	static class C3 {\n" +
+						"		public static class C4 {}\n" + // public but nested in non-public
+						"	}\n" +
+						"	public C3 f1;\n" +
+						"	public C3.C4 f2;\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:+exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeModuleTest(files, buffer,
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 6)\n" + 
+				"	public C3 f1;\n" + 
+				"	       ^^\n" + 
+				"The type C1.C3 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 7)\n" + 
+				"	public C3.C4 f2;\n" + 
+				"	       ^^^^^\n" + 
+				"The type C1.C3.C4 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2 problems (2 errors)\n",
+				false,
+				"one is not accessible to clients");
+	}
+
+	// type from non-transitive required module
+	public void testAPILeakDetection5() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp1;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp1", "C1.java", 
+						"package p.exp1;\n" +
+						"public class C1 {\n" +
+						"}\n");
+
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	exports p.exp2;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp2", "C2.java", 
+						"package p.exp2;\n" +
+						"public class C2 {\n" +
+						"}\n");
+
+		moduleLoc = directory + File.separator + "mod.three";
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.three { \n" +
+						"	requires mod.one; // missing transitive\n" +
+						"	requires transitive mod.two;\n" +
+						"	exports p.exp3;\n" + 
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp3", "C3.java", 
+						"package p.exp3;\n" +
+						"public class C3 {\n" +
+						"	public void m1(p.exp1.C1 arg) {}\n" +
+						"	public void m2(p.exp2.C2 arg) {}\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:+exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeModuleTest(files, buffer,
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/p/exp3/C3.java (at line 3)\n" + 
+				"	public void m1(p.exp1.C1 arg) {}\n" + 
+				"	               ^^^^^^^^^\n" + 
+				"The type C1 from module mod.one is not accessible to clients due to missing \'requires transitive\'\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false,
+				"is not indirectly exported");
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index a32dfc6..a7d7fb8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -207,7 +207,10 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			waitForManualRefresh();
 			this.currentProject.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = this.currentProject.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
-			assertMarkers("Unexpected markers", "", markers);
+			assertMarkers("Unexpected markers",
+					// just an API leak warning:
+					"The type Connection from module java.sql is not accessible to clients due to missing \'requires transitive\'",
+					markers);
 		} finally {
 		}
 	}
@@ -1175,7 +1178,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"src/module-info.java",
 				"module com.greetings {\n" +
 				"	requires org.astro;\n" +
-				"	requires other.mod;\n" +
+				"	requires transitive other.mod;\n" +
 				"	exports com.greetings;\n" +
 				"	provides org.astro.World with com.greetings.MyImpl;\n" +
 				"}",
@@ -4634,6 +4637,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 															new IClasspathAttribute[] { modAttr },
 															false/*not exported*/);
 			IJavaProject p1 = setupModuleProject("mod.one", src1, new IClasspathEntry[] { dep });
+			p1.setOption(JavaCore.COMPILER_PB_API_LEAKS, JavaCore.IGNORE); // the stub org.astro.World is not exported but used in API
 			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p1.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers",	"",  markers);
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index bdf1f8c..8e8d239 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3854,6 +3854,9 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("enumIdentifier")) { //$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportEnumIdentifier, severity, isEnabling);
 				return;
+			} else if (token.equals("exports")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportAPILeak, severity, isEnabling);
+				return;
 			}
 			break;
 		case 'f' :
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index df88a4e..15021fb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1964,6 +1964,12 @@ void setSourceStart(int sourceStart);
 	int ConflictingPackageFromModules = ModuleRelated + 1455;
 	/** @since 3.13 BETA_JAVA9 */
 	int ConflictingPackageFromOtherModules = ModuleRelated + 1456;
+	/** @since 3.13 BETA_JAVA9 */
+	int NonPublicTypeInAPI = ModuleRelated + 1457;
+	/** @since 3.13 BETA_JAVA9 */
+	int NotExportedTypeInAPI = ModuleRelated + 1458;
+	/** @since 3.13 BETA_JAVA9 */
+	int MissingRequiresTransitiveForTypeInAPI = ModuleRelated + 1459;
 
 	/** @since 3.13 */
 	int RedundantNullDefaultAnnotationLocal = Internal + 1062;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 1ee4beb..c2ad51a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -199,6 +199,8 @@ public class CompilerOptions {
 	public static final String OPTION_ReportUnlikelyCollectionMethodArgumentTypeStrict = "org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict"; //$NON-NLS-1$
 	public static final String OPTION_ReportUnlikelyEqualsArgumentType = "org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType"; //$NON-NLS-1$
 
+	public static final String OPTION_ReportAPILeak = "org.eclipse.jdt.core.compiler.problem.APILeak"; //$NON-NLS-1$
+
 	/**
 	 * Possible values for configurable options
 	 */
@@ -324,6 +326,7 @@ public class CompilerOptions {
 	public static final int UnlikelyCollectionMethodArgumentType = IrritantSet.GROUP2 | ASTNode.Bit22;
 	public static final int UnlikelyEqualsArgumentType = IrritantSet.GROUP2 | ASTNode.Bit23;
 	public static final int UsingTerminallyDeprecatedAPI = IrritantSet.GROUP2 | ASTNode.Bit24;
+	public static final int APILeak = IrritantSet.GROUP2 | ASTNode.Bit25;
 
 
 	// Severity level for handlers
@@ -520,6 +523,7 @@ public class CompilerOptions {
 		"cast", //$NON-NLS-1$
 		"dep-ann", //$NON-NLS-1$
 		"deprecation", //$NON-NLS-1$
+		"exports",  //$NON-NLS-1$
 		"fallthrough", //$NON-NLS-1$
 		"finally", //$NON-NLS-1$
 		"hiding", //$NON-NLS-1$
@@ -741,6 +745,8 @@ public class CompilerOptions {
 				return OPTION_ReportUnlikelyCollectionMethodArgumentType;
 			case UnlikelyEqualsArgumentType:
 				return OPTION_ReportUnlikelyEqualsArgumentType;
+			case APILeak:
+				return OPTION_ReportAPILeak;
 		}
 		return null;
 	}
@@ -941,6 +947,7 @@ public class CompilerOptions {
 			OPTION_ReportNonnullParameterAnnotationDropped,
 			OPTION_ReportUnlikelyCollectionMethodArgumentType,
 			OPTION_ReportUnlikelyEqualsArgumentType,
+			OPTION_ReportAPILeak,
 		};
 		return result;
 	}
@@ -1038,6 +1045,8 @@ public class CompilerOptions {
 			case UnlikelyEqualsArgumentType:
 			case UnlikelyCollectionMethodArgumentType:
 				return "unlikely-arg-type"; //$NON-NLS-1$
+			case APILeak:
+				return "exports"; //$NON-NLS-1$
 		}
 		return null;
 	}
@@ -1064,6 +1073,10 @@ public class CompilerOptions {
 				if ("dep-ann".equals(warningToken)) //$NON-NLS-1$
 					return IrritantSet.DEP_ANN;
 				break;
+			case 'e' :
+				if ("exports".equals(warningToken)) //$NON-NLS-1$
+					return IrritantSet.API_LEAK;
+				break;
 			case 'f' :
 				if ("fallthrough".equals(warningToken)) //$NON-NLS-1$
 					return IrritantSet.FALLTHROUGH;
@@ -1271,6 +1284,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportUnlikelyCollectionMethodArgumentType, getSeverityString(UnlikelyCollectionMethodArgumentType));
 		optionsMap.put(OPTION_ReportUnlikelyCollectionMethodArgumentTypeStrict, this.reportUnlikelyCollectionMethodArgumentTypeStrict ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportUnlikelyEqualsArgumentType, getSeverityString(UnlikelyEqualsArgumentType));
+		optionsMap.put(OPTION_ReportAPILeak, getSeverityString(APILeak));
 		return optionsMap;
 	}
 
@@ -1788,6 +1802,7 @@ public class CompilerOptions {
 		} else {
 			this.analyseResourceLeaks = true;
 		}
+		if ((optionValue = optionsMap.get(OPTION_ReportAPILeak)) != null) updateSeverity(APILeak, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_AnnotationBasedNullAnalysis)) != null) {
 			this.isAnnotationBasedNullAnalysisEnabled = ENABLED.equals(optionValue);
 		}
@@ -2112,6 +2127,7 @@ public class CompilerOptions {
 		buf.append("\n\t- unlikely argument type for collection methods: ").append(getSeverityString(UnlikelyCollectionMethodArgumentType)); //$NON-NLS-1$
 		buf.append("\n\t- unlikely argument type for collection methods, strict check against expected type: ").append(this.reportUnlikelyCollectionMethodArgumentTypeStrict ? ENABLED : DISABLED); //$NON-NLS-1$
 		buf.append("\n\t- unlikely argument types for equals(): ").append(getSeverityString(UnlikelyEqualsArgumentType)); //$NON-NLS-1$
+		buf.append("\n\t- API leak: ").append(getSeverityString(APILeak)); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 07622bc..b35094e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -70,6 +74,7 @@ public class IrritantSet {
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 	public static final IrritantSet RESOURCE = new IrritantSet(CompilerOptions.UnclosedCloseable);
 	public static final IrritantSet UNLIKELY_ARGUMENT_TYPE = new IrritantSet(CompilerOptions.UnlikelyCollectionMethodArgumentType);
+	public static final IrritantSet API_LEAK = new IrritantSet(CompilerOptions.APILeak);
 
 	public static final IrritantSet JAVADOC = new IrritantSet(CompilerOptions.InvalidJavadoc);
 	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
@@ -127,7 +132,8 @@ public class IrritantSet {
 				|CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables
 				|CompilerOptions.NonNullTypeVariableFromLegacyInvocation
 				|CompilerOptions.UnlikelyCollectionMethodArgumentType
-				|CompilerOptions.UsingTerminallyDeprecatedAPI);
+				|CompilerOptions.UsingTerminallyDeprecatedAPI
+				|CompilerOptions.APILeak);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
index 61707ed..e6fac25 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryModuleBinding.java
@@ -102,6 +102,7 @@ public class BinaryModuleBinding extends ModuleBinding {
 			PackageBinding declaredPackage = getVisiblePackage(CharOperation.splitOn('.', export.name()));
 			if (declaredPackage != null) {
 				this.exportedPackages[count++] = declaredPackage;
+				declaredPackage.isExported = Boolean.TRUE;
 				recordExportRestrictions(declaredPackage, export.targets());
 			} else {
 				// TODO(SHMOD): report incomplete module path?
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 4188a08..6aa1b04 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1086,8 +1086,16 @@ public PackageBinding createPackage(char[][] compoundName) {
 					return null;
 				}
 			}
-			packageBinding = new PackageBinding(CharOperation.subarray(compoundName, 0, i + 1), parent, this, this.module);
-			packageBinding = parent.addPackage(packageBinding, this.module, true);
+			if (parent instanceof SplitPackageBinding) {
+				// parent.getPackage0() may have been too shy, so drill into the split:
+				PackageBinding singleParent = ((SplitPackageBinding) parent).getIncarnation(this.module);
+				if (singleParent != null)
+					packageBinding = singleParent.getPackage0(compoundName[i]);
+			}
+			if (packageBinding == null) {
+				packageBinding = new PackageBinding(CharOperation.subarray(compoundName, 0, i + 1), parent, this, this.module);
+				packageBinding = parent.addPackage(packageBinding, this.module, true);
+			}
 		}
 	}
 	if (packageBinding instanceof SplitPackageBinding)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
index 25cea65..842b72e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
@@ -25,6 +25,7 @@
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
@@ -627,4 +628,65 @@ public Binding checkRedundantDefaultNullness(int nullBits, int sourceStart) {
 	}
 	return this.parent.checkRedundantDefaultNullness(nullBits, sourceStart);
 }
+public boolean shouldCheckAPILeaks(ReferenceBinding declaringClass, boolean memberIsPublic) {
+	if (environment().useModuleSystem)
+		return memberIsPublic && declaringClass.isPublic() && declaringClass.fPackage.isExported();
+	return false;
+}
+public void detectAPILeaks(ASTNode typeNode, TypeBinding type) {
+	if (environment().useModuleSystem) {
+		// NB: using an ASTVisitor yields more precise locations than a TypeBindingVisitor would
+		ASTVisitor visitor = new ASTVisitor() {
+			@Override
+			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
+				if (typeReference.resolvedType instanceof ReferenceBinding)
+					checkType((ReferenceBinding) typeReference.resolvedType, typeReference.sourceStart, typeReference.sourceEnd);
+				return true;
+			}
+			@Override
+			public boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {
+				if (typeReference.resolvedType instanceof ReferenceBinding)
+					checkType((ReferenceBinding) typeReference.resolvedType, typeReference.sourceStart, typeReference.sourceEnd);
+				return true;
+			}
+			@Override
+			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
+				TypeBinding leafComponentType = typeReference.resolvedType.leafComponentType();
+				if (leafComponentType instanceof ReferenceBinding)
+					checkType((ReferenceBinding) leafComponentType, typeReference.sourceStart, typeReference.originalSourceEnd);
+				return true;
+			}
+			private void checkType(ReferenceBinding referenceBinding, int sourceStart, int sourceEnd) {
+				if (!referenceBinding.isValidBinding())
+					return;
+				ModuleBinding otherModule = referenceBinding.module();
+				if (otherModule == otherModule.environment.javaBaseModule())
+					return; // always accessible
+				if (!isFullyPublic(referenceBinding)) {
+					problemReporter().nonPublicTypeInAPI(referenceBinding, sourceStart, sourceEnd);
+				} else if (!referenceBinding.fPackage.isExported()) {
+					problemReporter().notExportedTypeInAPI(referenceBinding, sourceStart, sourceEnd);
+				} else if (isUnrelatedModule(referenceBinding.fPackage)) {
+					problemReporter().missingRequiresTransitiveForTypeInAPI(referenceBinding, sourceStart, sourceEnd);
+				}
+			}
+			private boolean isFullyPublic(ReferenceBinding referenceBinding) {
+				if (!referenceBinding.isPublic())
+					return false;
+				if (referenceBinding instanceof NestedTypeBinding)
+					return isFullyPublic(((NestedTypeBinding) referenceBinding).enclosingType);
+				return true;
+			}
+			private boolean isUnrelatedModule(PackageBinding fPackage) {
+				ModuleBinding otherModule = fPackage.enclosingModule;
+				ModuleBinding thisModule = module();
+				if (thisModule != otherModule) {
+					return !thisModule.isTransitivelyRequired(otherModule);
+				}
+				return false;
+			}
+		};
+		typeNode.traverse(visitor, this);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index 6e01327..faa27e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -107,6 +107,7 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 	ModuleBinding[] requiredModules = null;
 	boolean isAuto;
 	private boolean[] isComplete = new boolean[UpdateKind.values().length];
+	private Set<ModuleBinding> transitiveRequires;
 
 	/** Packages declared in this module (indexed by qualified name). */
 	HashtableOfPackage declaredPackages; // TODO(SHMOD): measure if this is worth the memory. LE->PackageBinding basically hold the same information
@@ -246,6 +247,7 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 			System.arraycopy(this.exportedPackages, 0, this.exportedPackages = new PackageBinding[len+1], 0, len);
 			this.exportedPackages[len] = declaredPackage;
 		}
+		declaredPackage.isExported = Boolean.TRUE;
 		recordExportRestrictions(declaredPackage, targetModules);
 	}
 
@@ -757,4 +759,12 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 		// TODO(SHMOD) implement deprecation for modules
 		return false;
 	}
+	public boolean isTransitivelyRequired(ModuleBinding otherModule) {
+		if (this.transitiveRequires == null) {
+			Set<ModuleBinding> transitiveDeps = new HashSet<>();
+			collectTransitiveDependencies(transitiveDeps);
+			this.transitiveRequires = transitiveDeps;
+		}
+		return this.transitiveRequires.contains(otherModule);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 887bb44..5db364b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -40,6 +40,9 @@ public class PackageBinding extends Binding implements TypeConstants {
 
 	public ModuleBinding enclosingModule;
 
+	/** Is this package exported from its module? NB: to query this property use {@link #isExported()} to ensure initialization. */
+	Boolean isExported;
+
 protected PackageBinding() {
 	// for creating problem package
 }
@@ -356,6 +359,18 @@ public boolean subsumes(PackageBinding binding) {
 	return binding == this;
 }
 /**
+ * Is this package exported from its module?
+ * Does not consider export restrictions.
+ */
+public boolean isExported() {
+	if (this.isExported == null) {
+		this.enclosingModule.getExports(); // ensure resolved and completed
+		if (this.isExported == null)
+			this.isExported = Boolean.FALSE;
+	}
+	return this.isExported == Boolean.TRUE;
+}
+/**
  * If this package is uniquely visible to 'module' return a plain PackageBinding.
  * In case of a conflict between a local package and foreign package
  * the plain local package is returned, because this conflict will more
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 4408173..8742190 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1815,6 +1815,8 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 						field.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
 			}
+			if (initializationScope.shouldCheckAPILeaks(this, field.isPublic()))
+				initializationScope.detectAPILeaks(fieldDecl.type, fieldType);
 		} finally {
 		    initializationScope.initializedField = previousField;
 		}
@@ -1909,6 +1911,7 @@ private MethodBinding resolveTypesWithSuspendedTempErrorHandlingPolicy(MethodBin
 	}
 	final boolean reportUnavoidableGenericTypeProblems = this.scope.compilerOptions().reportUnavoidableGenericTypeProblems;
 	boolean foundArgProblem = false;
+	boolean checkAPIleak = methodDecl.scope.shouldCheckAPILeaks(this, method.isPublic());
 	Argument[] arguments = methodDecl.arguments;
 	if (arguments != null) {
 		int size = arguments.length;
@@ -1946,6 +1949,8 @@ private MethodBinding resolveTypesWithSuspendedTempErrorHandlingPolicy(MethodBin
 				if (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
 					method.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
 				newParameters[i] = parameterType;
+				if (checkAPIleak)
+					methodDecl.scope.detectAPILeaks(arg.type, parameterType);
 				arg.binding = new LocalVariableBinding(arg, parameterType, arg.modifiers, methodDecl.scope);
 			}
 		}
@@ -2013,6 +2018,8 @@ private MethodBinding resolveTypesWithSuspendedTempErrorHandlingPolicy(MethodBin
 					method.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
 				else if (leafType == TypeBinding.VOID && methodDecl.annotations != null)
 					rejectTypeAnnotatedVoidMethod(methodDecl);
+				if (checkAPIleak)
+					methodDecl.scope.detectAPILeaks(returnType, methodType);
 			}
 		}
 	} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index e09e979..c697cff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -635,6 +635,11 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.UnlikelyCollectionMethodArgumentType;
 		case IProblem.UnlikelyEqualsArgumentType:
 			return CompilerOptions.UnlikelyEqualsArgumentType;
+
+		case IProblem.NonPublicTypeInAPI:
+		case IProblem.NotExportedTypeInAPI:
+		case IProblem.MissingRequiresTransitiveForTypeInAPI:
+			return CompilerOptions.APILeak;
 }
 	return 0;
 }
@@ -696,6 +701,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NonNullTypeVariableFromLegacyInvocation :
 			case CompilerOptions.UnlikelyCollectionMethodArgumentType :
 			case CompilerOptions.UnlikelyEqualsArgumentType:
+			case CompilerOptions.APILeak:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10691,4 +10697,29 @@ public void unlikelyArgumentType(Expression argument, MethodBinding method, Type
 			argument.sourceStart, 
 			argument.sourceEnd);
 }
+
+public void nonPublicTypeInAPI(TypeBinding type, int sourceStart, int sourceEnd) {
+	handle(IProblem.NonPublicTypeInAPI,
+			new String[] { new String(type.readableName()) },
+			new String[] { new String(type.shortReadableName()) },
+			sourceStart,
+			sourceEnd);
+}
+
+public void notExportedTypeInAPI(TypeBinding type, int sourceStart, int sourceEnd) {
+	handle(IProblem.NotExportedTypeInAPI,
+			new String[] { new String(type.readableName()) },
+			new String[] { new String(type.shortReadableName()) },
+			sourceStart,
+			sourceEnd);
+}
+
+public void missingRequiresTransitiveForTypeInAPI(ReferenceBinding referenceBinding, int sourceStart, int sourceEnd) {
+	String moduleName = new String(referenceBinding.fPackage.enclosingModule.readableName());
+	handle(IProblem.MissingRequiresTransitiveForTypeInAPI,
+			new String[] { new String(referenceBinding.readableName()), moduleName },
+			new String[] { new String(referenceBinding.shortReadableName()), moduleName },
+			sourceStart,
+			sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index f9e7f31..47c605d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -921,6 +921,9 @@
 1454 = The package {0} is not accessible
 1455 = The package {0} is accessible from more than one module: {1}
 1456 = The package {0} conflicts with a package accessible from another module: {1}
+1457 = The type {0} is not accessible to clients that require this module
+1458 = The type {0} is not exported from this module
+1459 = The type {0} from module {1} is not accessible to clients due to missing ''requires transitive''
 
 ### ELABORATIONS
 ## Access restrictions
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 1e38b3f..4a470ca 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1594,6 +1594,30 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_UNLIKELY_EQUALS_ARGUMENT_TYPE = PLUGIN_ID + ".compiler.problem.unlikelyEqualsArgumentType"; //$NON-NLS-1$
 
 	/**
+	 * Compiler option ID: Reporting when public API uses a non-API type.
+	 * <p>
+	 * This option is relevant only when compiling code in a named module (at compliance 9 or greater).
+	 * <p>
+	 * When enabled, the compiler will issue an error or warning when public API mentions a type that is not
+	 * accessible to clients. Here, public API refers to signatures of public fields and methods declared
+	 * by a public type in an exported package.
+	 * In these positions types are complained against that are either not public or not in an exported package.
+	 * Export qualification is not taken into account.
+	 * If a type in one of these positions is declared in another module that is required by the current module,
+	 * but without the {@code transitive} modifier, this is reported as a problem, too.
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.APILeak"</code></dd>
+	 * <dt>Possible values:</dt>
+	 * <dd><code>{ "error", "warning", "info", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * 
+	 * @since 3.13 BETA_JAVA9
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_API_LEAKS = PLUGIN_ID + ".compiler.problem.APILeak"; //$NON-NLS-1$
+	
+	/**
 	 * Compiler option ID: Annotation-based Null Analysis.
 	 * <p>This option controls whether the compiler will use null annotations for
 	 *    improved analysis of (potential) null references.</p>
commit 8ecdb355889ce5681ec8faeaba71b81c1e5dd3e2
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 13 23:25:30 2017 +0200

    Bug 520826: [9] detect and report "API leaks"
    - fix 2 NPEs involving annotated types in API and enum
    
    Change-Id: Ia270c6dd6b56f4399526c735c7f9e5c4af4cf9ef

86	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index e17335c..3ff09a3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -2773,4 +2773,90 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				false,
 				"is not indirectly exported");
 	}
+
+	// annotated types in API
+	public void testAPILeakDetection6() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"import java.lang.annotation.*;\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface ANN {}\n" +
+						"class C0 {}\n" +
+						"public class C1 {\n" +
+						"	public @ANN String f1;\n" +
+						"	public @ANN C0 f3;\n" +
+						"	public @ANN String test(@ANN String arg, @ANN C0 c) { return \"\"; }\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeModuleTest(files, buffer,
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 8)\n" + 
+				"	public @ANN C0 f3;\n" + 
+				"	            ^^\n" + 
+				"The type C0 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/exp/C1.java (at line 9)\n" + 
+				"	public @ANN String test(@ANN String arg, @ANN C0 c) { return \"\"; }\n" + 
+				"	                                              ^^\n" + 
+				"The type C0 is not accessible to clients that require this module\n" + 
+				"----------\n" + 
+				"2 problems (2 errors)\n",
+				false,
+				"is not accessible to clients");
+	}
+
+	// enum API
+	public void testAPILeakDetection7() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>();
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p.exp;\n" +
+						"}");
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "exp", "C1.java", 
+						"package p.exp;\n" +
+						"public enum C1 {\n" +
+						"	X, Y, Z;\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -err:exports")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runConformModuleTest(files, buffer,
+				"",
+				"",
+				false);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 1fbc558..51c6d54 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -2106,6 +2106,8 @@ public FieldBinding[] unResolvedFields() {
 	return this.fields;
 }
 public ModuleBinding module() {
+	if (!isPrototype())
+		return this.prototype.module;
 	return this.module;
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 8742190..9a3283f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1815,7 +1815,7 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 						field.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
 			}
-			if (initializationScope.shouldCheckAPILeaks(this, field.isPublic()))
+			if (initializationScope.shouldCheckAPILeaks(this, field.isPublic()) && fieldDecl.type != null) // fieldDecl.type is null for enum constants
 				initializationScope.detectAPILeaks(fieldDecl.type, fieldType);
 		} finally {
 		    initializationScope.initializedField = previousField;
@@ -2684,6 +2684,8 @@ public void tagIndirectlyAccessibleMembers() {
 			((SourceTypeBinding) this.superclass).tagIndirectlyAccessibleMembers();
 }
 public ModuleBinding module() {
+	if (!isPrototype())
+		return this.prototype.module;
 	return this.module;
 }
 }
