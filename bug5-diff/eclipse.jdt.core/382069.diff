commit 340d76460697d1d853431b9a4e8d18df2a5632b9
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Feb 17 18:50:37 2013 +0100

    Bug 382069: [null] Make the null analysis consider JUnit's assertNotNull
    similarly to assertions

87	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
273	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
7	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
165	32	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
56	23	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
52	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
11	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index b8b13ec..d02d7ef 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2010, 2012 GK Software AG and others.
+ * Copyright (c) 2010, 2013 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -5980,6 +5980,91 @@ public void testBug388281_10() {
 		"	      ^^^^\n" + 
 		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n"); 
-	}
+}
 
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNull vs. a @NonNull field / expression
+public void testBug382069_j() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			NullReferenceTestAsserts.JUNIT_ASSERT_NAME,
+			NullReferenceTestAsserts.JUNIT_ASSERT_CONTENT,		
+			"X.java",
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"public class X {\n" +
+			"  @NonNull String o1 = \"\";\n" +
+			"  boolean foo() {\n" +
+			"    junit.framework.Assert.assertNull(\"something's wrong\", o1);\n" + // always fails due to @NonNull
+			"    return false; // dead code\n" +
+			"  }\n" +
+			"  void bar() {\n" +
+			"      junit.framework.Assert.assertNull(\"\");\n" + // constantly false
+			"      return; // dead code\n" +
+			"  }\n" +
+			"  void zork() {\n" +
+			"      junit.framework.Assert.assertNotNull(null);\n" + // constantly false
+			"      return; // dead code\n" +
+			"  }\n" +
+			"}\n"},
+			options,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 6)\n" + 
+			"	return false; // dead code\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 14)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNonNull et al. affecting a @Nullable field using syntactic analysis
+public void testBug382069_k() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			NullReferenceTestAsserts.JUNIT_ASSERT_NAME,
+			NullReferenceTestAsserts.JUNIT_ASSERT_CONTENT,		
+			"X.java",
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"public class X {\n" +
+			"  @Nullable String o1;\n" +
+			"  int foo() {\n" +
+			"    junit.framework.Assert.assertNotNull(\"something's wrong\", o1);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"  int bar(int i) {\n" +
+			"    junit.framework.Assert.assertNotNull(o1);\n" +
+			"    i++;\n" + // expire
+			"    return o1.length(); // no longer protected\n" +
+			"  }\n" +
+			"  int garp() {\n" +
+			"    junit.framework.Assert.assertFalse(\"something's wrong\", o1 == null);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"  int zipp() {\n" +
+			"    junit.framework.Assert.assertTrue(\"something's wrong\", o1 != null);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"}\n"},
+			options,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	return o1.length(); // no longer protected\n" + 
+			"	       ^^\n" + 
+			"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+			"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
index 98df523..1973828 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
@@ -1,12 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     IBM Corporation - initial API and implementation
+ *		IBM Corporation - initial API and implementation
+ *		Stephan Herrmann - Contribution for
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -35,11 +37,61 @@ public NullReferenceTestAsserts(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "testBug373953" };
+//		TESTS_NAMES = new String[] { "testBug382069" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
 
+static final String JUNIT_ASSERT_NAME = "junit/framework/Assert.java";
+static final String JUNIT_ASSERT_CONTENT = "package junit.framework;\n" +
+		"public class Assert {\n" +
+		"    static public void assertNull(Object object) {}\n" +
+		"    static public void assertNull(String message, Object object) {}\n" +
+		"    static public void assertNotNull(Object object) {}\n" +
+		"    static public void assertNotNull(String message, Object object) {}\n" +
+		"    static public void assertTrue(boolean expression) {}\n" +
+		"    static public void assertTrue(String message, boolean expression) {}\n" +
+		"    static public void assertFalse(boolean expression) {}\n" +
+		"    static public void assertFalse(String message, boolean expression) {}\n" +
+		"}\n";
+
+static final String APACHE_VALIDATE_NAME = "org/apache/commons/lang/Validate.java";
+static final String APACHE_VALIDATE_CONTENT = "package org.apache.commons.lang;\n" +
+		"public class Validate {\n" +
+		"    static public void notNull(Object object) {}\n" +
+		"    static public void notNull(Object object, String message) {}\n" +
+		"    static public void isTrue(boolean expression) {}\n" +
+		"    static public void isTrue(boolean expression, String message) {}\n" +
+		"    static public void isTrue(boolean expression, String message, double value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, long value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, Object value) {}\n" +
+		"}\n";
+
+static final String APACHE_3_VALIDATE_NAME = "org/apache/commons/lang3/Validate.java";
+static final String APACHE_3_VALIDATE_CONTENT = "package org.apache.commons.lang3;\n" +
+		"public class Validate {\n" +
+		"    static public <T> T notNull(T object) { return object; }\n" +
+		"    static public <T> T notNull(T object, String message, Object... values) { return object; }\n" +
+		"    static public void isTrue(boolean expression) {}\n" +
+		"    static public void isTrue(boolean expression, String message, double value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, long value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, Object value) {}\n" +
+		"}\n";
+
+static final String GOOGLE_PRECONDITIONS_NAME = "com/google/common/base/Preconditions.java";
+static final String GOOGLE_PRECONDITIONS_CONTENT = "package com.google.common.base;\n" +
+		"public class Preconditions {\n" +
+		"    static public <T> T checkNotNull(T object) { return object; }\n" +
+		"    static public <T> T checkNotNull(T object, Object message) { return object; }\n" +
+		"    static public <T> T checkNotNull(T object, String message, Object... values) { return object; }\n" +
+		"    static public void checkArgument(boolean expression) {}\n" +
+		"    static public void checkArgument(boolean expression, Object message) {}\n" +
+		"    static public void checkArgument(boolean expression, String msgTmpl, Object... messageArgs) {}\n" +
+		"    static public void checkState(boolean expression) {}\n" +
+		"    static public void checkState(boolean expression, Object message) {}\n" +
+		"    static public void checkState(boolean expression, String msgTmpl, Object... messageArgs) {}\n" +
+		"}\n";
+
 public static Test suite() {
 	return buildAllCompliancesTestSuite(testClass());
 }
@@ -91,7 +143,7 @@ public void testBug127575a() throws IOException {
 				"}\n"},
 			"",
 			this.assertLib,
-			false,
+			true,
 			null);
 }
 
@@ -751,4 +803,221 @@ public void testBug373953() throws IOException {
 			"Potential null pointer access: The variable o may be null at this location\n" + 
 			"----------\n");
 }
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNotNull
+public void testBug382069a() throws IOException {
+	this.runConformTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  void foo(Object o1, String o2) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    junit.framework.Assert.assertNotNull(o1);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    junit.framework.Assert.assertNotNull(\"msg\", o2);\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"  }\n" +
+			"}\n"},
+		"");
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// org.eclipse.core.runtime.Assert.isNotNull
+public void testBug382069b() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runConformTest(
+			new String[] {
+		"X.java",
+				"public class X {\n" + 
+				"  void foo(Object o1, String o2) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    org.eclipse.core.runtime.Assert.isNotNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    org.eclipse.core.runtime.Assert.isNotNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"  }\n" +
+				"}"	
+			},
+			"",
+			this.assertLib,
+			true,
+			null);
+	}
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNull and dead code analysis
+public void testBug382069c() throws IOException {
+	this.runNegativeTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  boolean foo(String o1, String o2) {\n" +
+			"    junit.framework.Assert.assertNull(\"something's wrong\", o1);\n" + 	// establish nullness
+			"    if (o2 == null)\n" +
+			"        return o1 != null;\n" +
+			"    junit.framework.Assert.assertNull(o2);\n" + // will always throw
+			"    return false; // dead code\n" +
+			"  }\n" +
+			"  void bar(X x) {\n" +
+			"    if (x == null) {\n" +
+			"      junit.framework.Assert.assertNotNull(x);\n" +
+			"      return; // dead code\n" +
+			"    }\n" +
+			"  }\n" +
+			"}\n"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 5)\n" + 
+			"	return o1 != null;\n" + 
+			"	       ^^\n" + 
+			"Null comparison always yields false: The variable o1 can only be null at this location\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 7)\n" + 
+			"	return false; // dead code\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 12)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from org.apache.commons.lang.Validate
+public void testBug382069d() throws IOException {
+	this.runNegativeTest(
+		new String[] {
+			APACHE_VALIDATE_NAME,
+			APACHE_VALIDATE_CONTENT,
+			"X.java",
+			"import org.apache.commons.lang.Validate;\n" +
+			"public class X {\n" +
+			"  void foo(Object o1, String o2, X x) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    Validate.notNull(o1);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    Validate.notNull(o2, \"msg\");\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"    Validate.isTrue(x == null, \"ups\", x);\n" +
+			"    x.foo(null, null, null); // definite NPE\n" +
+			"  }\n" +
+			"}\n"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	x.foo(null, null, null); // definite NPE\n" + 
+			"	^\n" + 
+			"Null pointer access: The variable x can only be null at this location\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from org.apache.commons.lang3Validate
+public void testBug382069e() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+				APACHE_3_VALIDATE_NAME,
+				APACHE_3_VALIDATE_CONTENT,
+				"X.java",
+				"import org.apache.commons.lang3.Validate;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    Validate.notNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    Validate.notNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"    Validate.isTrue(x == null, \"ups\", x);\n" +
+				"    x.foo(null, null, null); // definite NPE\n" +
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	x.foo(null, null, null); // definite NPE\n" + 
+				"	^\n" + 
+				"Null pointer access: The variable x can only be null at this location\n" + 
+				"----------\n");
+	}
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from com.google.common.base.Preconditions
+public void testBug382069f() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+				GOOGLE_PRECONDITIONS_NAME,
+				GOOGLE_PRECONDITIONS_CONTENT,
+				"X.java",
+				"import com.google.common.base.Preconditions;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    Preconditions.checkNotNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    Preconditions.checkNotNull(o2, \"msg {0}.{1}\", o1, o2);\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"    Preconditions.checkArgument(x == null, \"ups\");\n" +
+				"    x.foo(null, null, null); // definite NPE\n" +
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	x.foo(null, null, null); // definite NPE\n" + 
+				"	^\n" + 
+				"Null pointer access: The variable x can only be null at this location\n" + 
+				"----------\n");
+	}
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// java.util.Objects#requireNonNull
+public void testBug382069g() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_7) {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import static java.util.Objects.requireNonNull;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    requireNonNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    requireNonNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"  }\n" +
+				"}\n"},
+				"");
+	}
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertTrue / assertFalse
+public void testBug382069h() throws IOException {
+	this.runConformTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  void foo(Object o1, String o2) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    junit.framework.Assert.assertTrue(o1 != null);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    junit.framework.Assert.assertFalse(\"msg\", o2 == null);\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"  }\n" +
+			"}\n"},
+		"");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 8ede946..ff8c93e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -46,6 +47,7 @@ public class EqualExpression extends BinaryExpression {
 			rightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkEquality);
 		}
 		
+		boolean contextualCheckEquality = checkEquality ^ ((flowContext.tagBits & FlowContext.INSIDE_NEGATIVE_ASSERT) != 0);
 		// perform flowInfo-based checks for variables and record info for syntactic null analysis for fields:
 		if (!leftNonNullChecked) {
 			LocalVariableBinding local = this.left.localVariableBinding();
@@ -54,7 +56,8 @@ public class EqualExpression extends BinaryExpression {
 					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
 				}
 			} else if (this.left instanceof Reference
-							&& ((!checkEquality && rightStatus == FlowInfo.NULL) || (checkEquality && rightStatus == FlowInfo.NON_NULL))
+							&& ((!contextualCheckEquality && rightStatus == FlowInfo.NULL) 
+									|| (contextualCheckEquality && rightStatus == FlowInfo.NON_NULL))
 							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields)
 			{
 				FieldBinding field = ((Reference)this.left).lastFieldBinding();
@@ -70,7 +73,8 @@ public class EqualExpression extends BinaryExpression {
 					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
 				}
 			} else if (this.right instanceof Reference
-							&& ((!checkEquality && leftStatus == FlowInfo.NULL) || (checkEquality && leftStatus == FlowInfo.NON_NULL))
+							&& ((!contextualCheckEquality && leftStatus == FlowInfo.NULL) 
+									|| (contextualCheckEquality && leftStatus == FlowInfo.NON_NULL))
 							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields) 
 			{
 				FieldBinding field = ((Reference)this.right).lastFieldBinding();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 394a8ef..fcdee4c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -40,7 +41,9 @@ import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier;
@@ -126,7 +129,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 	}
 
-	FlowInfo conditionFlowInfo;
 	if (this.arguments != null) {
 		int length = this.arguments.length;
 		for (int i = 0; i < length; i++) {
@@ -134,36 +136,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			if ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {
 				argument.checkNPE(currentScope, flowContext, flowInfo);
 			}
-			if (this.receiver.resolvedType != null 
-					&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert
-					&& argument.resolvedType != null
-					&& argument.resolvedType.id == TypeIds.T_boolean) {
-				Constant cst = argument.optimizedBooleanConstant();
-				boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
-				boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
-				flowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;
-				conditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());
-				if (!wasInsideAssert) {
-					flowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;
-				}
-				UnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
-				FlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();
-				if (isOptimizedTrueAssertion) {
-					assertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
-				}
-				if (!isOptimizedFalseAssertion) {
-					// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.
-					// if the code does reach ahead, it means the assert didn't cause an exit, and so
-					// the expression inside it shouldn't change the prior flowinfo
-					// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)
-					
-					// keep the merge from the initial code for the definite assignment
-					// analysis, tweak the null part to influence nulls downstream
-					flowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).
-						addInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());
-				}
-			} else {
-				flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			switch (detectAssertionUtility(i)) {
+				case TRUE_ASSERTION:
+					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);
+					break;
+				case FALSE_ASSERTION:
+					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, false);
+					break;
+				case NONNULL_ASSERTION:
+					flowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, false);
+					break;
+				case NULL_ASSERTION:
+					flowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, true);
+					break;
+				default:
+					flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 			}
 			if (analyseResources) {
 				// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)
@@ -190,6 +177,152 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	flowContext.expireNullCheckedFieldInfo(); // no longer trust this info after any message send
 	return flowInfo;
 }
+
+// classification of well-known assertion utilities:
+private static final int TRUE_ASSERTION = 1;
+private static final int FALSE_ASSERTION = 2;
+private static final int NULL_ASSERTION = 3;
+private static final int NONNULL_ASSERTION = 4;
+
+// is the argument at the given position being checked by a well-known assertion utility?
+// if so answer what kind of assertion we are facing.
+private int detectAssertionUtility(int argumentIdx) {
+	TypeBinding[] parameters = this.binding.original().parameters;
+	if (argumentIdx < parameters.length) {
+		TypeBinding parameterType = parameters[argumentIdx];
+		if (this.actualReceiverType != null && parameterType != null) {
+			switch (this.actualReceiverType.id) {
+				case TypeIds.T_OrgEclipseCoreRuntimeAssert:
+					if (parameterType.id == TypeIds.T_boolean)
+						return TRUE_ASSERTION;
+					if (parameterType.id == TypeIds.T_JavaLangObject && CharOperation.equals(TypeConstants.IS_NOTNULL, this.selector))
+						return NONNULL_ASSERTION;
+					break;
+				case TypeIds.T_JunitFrameworkAssert:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.ASSERT_TRUE, this.selector))
+							return TRUE_ASSERTION;
+						if (CharOperation.equals(TypeConstants.ASSERT_FALSE, this.selector))
+							return FALSE_ASSERTION;
+					} else if (parameterType.id == TypeIds.T_JavaLangObject) {
+						if (CharOperation.equals(TypeConstants.ASSERT_NOTNULL, this.selector))
+							return NONNULL_ASSERTION;
+						if (CharOperation.equals(TypeConstants.ASSERT_NULL, this.selector))
+							return NULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_OrgApacheCommonsLangValidate:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.IS_TRUE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.id == TypeIds.T_JavaLangObject) {
+						if (CharOperation.equals(TypeConstants.NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_OrgApacheCommonsLang3Validate:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.IS_TRUE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_ComGoogleCommonBasePreconditions:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.CHECK_ARGUMENT, this.selector)
+							|| CharOperation.equals(TypeConstants.CHECK_STATE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.CHECK_NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;					
+				case TypeIds.T_JavaUtilObjects:
+					if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.REQUIRE_NON_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;					
+			}
+		}
+	}
+	return 0;
+}
+private FlowInfo analyseBooleanAssertion(BlockScope currentScope, Expression argument,
+		FlowContext flowContext, FlowInfo flowInfo, boolean wasInsideAssert, boolean passOnTrue)
+{
+	Constant cst = argument.optimizedBooleanConstant();
+	boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
+	boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
+	int tagBitsSave = flowContext.tagBits;
+	flowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;
+	if (!passOnTrue)
+		flowContext.tagBits |= FlowContext.INSIDE_NEGATIVE_ASSERT; // this affects syntactic analysis for fields in EqualExpression
+	FlowInfo conditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());
+	flowContext.extendTimeToLiveForNullCheckedField(2); // survive this assert as a MessageSend and as a Statement
+	flowContext.tagBits = tagBitsSave;
+
+	UnconditionalFlowInfo assertWhenPassInfo;
+	FlowInfo assertWhenFailInfo;
+	boolean isOptimizedPassing;
+	boolean isOptimizedFailing;
+	if (passOnTrue) {
+		assertWhenPassInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
+		assertWhenFailInfo = conditionFlowInfo.initsWhenFalse();
+		isOptimizedPassing = isOptimizedTrueAssertion;
+		isOptimizedFailing = isOptimizedFalseAssertion;
+	} else {
+		assertWhenPassInfo = conditionFlowInfo.initsWhenFalse().unconditionalInits();
+		assertWhenFailInfo = conditionFlowInfo.initsWhenTrue();
+		isOptimizedPassing = isOptimizedFalseAssertion;
+		isOptimizedFailing = isOptimizedTrueAssertion;
+	}
+	if (isOptimizedPassing) {
+		assertWhenFailInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
+	}
+	if (!isOptimizedFailing) {
+		// if assertion is not failing for sure, only then it makes sense to carry the flow info ahead.
+		// if the code does reach ahead, it means the assert didn't cause an exit, and so
+		// the expression inside it shouldn't change the prior flowinfo
+		// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)
+		
+		// keep the merge from the initial code for the definite assignment
+		// analysis, tweak the null part to influence nulls downstream
+		flowInfo = flowInfo.mergedWith(assertWhenFailInfo.nullInfoLessUnconditionalCopy()).
+			addInitializationsFrom(assertWhenPassInfo.discardInitializationInfo());
+	}
+	return flowInfo;
+}
+private FlowInfo analyseNullAssertion(BlockScope currentScope, Expression argument,
+		FlowContext flowContext, FlowInfo flowInfo, boolean expectingNull)
+{
+	int nullStatus = argument.nullStatus(flowInfo, flowContext);
+	boolean willFail = (nullStatus == (expectingNull ? FlowInfo.NON_NULL : FlowInfo.NULL));
+	flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+	LocalVariableBinding local = argument.localVariableBinding();
+	if (local != null) {// beyond this point the argument can only be null/nonnull
+		if (expectingNull) 
+			flowInfo.markAsDefinitelyNull(local);
+		else 
+			flowInfo.markAsDefinitelyNonNull(local);
+	} else {
+		if (!expectingNull
+			&& argument instanceof Reference 
+			&& currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) 
+		{
+			FieldBinding field = ((Reference)argument).lastFieldBinding();
+			if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+				flowContext.recordNullCheckedFieldReference((Reference) argument, 3); // survive this assert as a MessageSend and as a Statement
+			}
+		}
+	}
+	if (willFail)
+		flowInfo.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+	return flowInfo;
+}
+
 public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	// message send as a receiver
 	if ((nullStatus(flowInfo, flowContext) & FlowInfo.POTENTIALLY_NULL) != 0)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index d8e5ddd..664d240 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -79,6 +79,8 @@ public class FlowContext implements TypeConstants {
 
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
+	// inside an assertFalse checks for equality / inequality have reversed meaning for syntactic analysis for fields:
+	public static final int INSIDE_NEGATIVE_ASSERT = 0x4;
 	/**
 	 * used to hide null comparison related warnings inside assert statements 
 	 */
@@ -149,6 +151,13 @@ public void recordNullCheckedFieldReference(Reference reference, int timeToLive)
 		this.nullCheckedFieldReferences[len] = reference;
 	}
 }
+
+/** If a null checked field has been recorded recently, increase its time to live. */
+public void extendTimeToLiveForNullCheckedField(int t) {
+	if (this.timeToLiveForNullCheckInfo > 0)
+		this.timeToLiveForNullCheckInfo += t;
+}
+
 /**
  * Forget any information about fields that were previously known to be non-null.
  * 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index d21c640..c8c7e2d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,7 @@
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -381,15 +382,23 @@ public void computeId() {
 
 		case 3 :
 			char[] packageName = this.compoundName[0];
-			// expect only java.*.* and javax.*.*
+			// expect only java.*.* and javax.*.* and junit.*.*
 			switch (packageName.length) {
 				case 4:
 					if (!CharOperation.equals(TypeConstants.JAVA, packageName))
 						return;
 					break; // continue below ...
 				case 5:
-					if (CharOperation.equals(TypeConstants.JAVAX_ANNOTATION_INJECT_INJECT, this.compoundName))
-						this.id = TypeIds.T_JavaxInjectInject;
+					switch (packageName[1]) {
+						case 'a':
+							if (CharOperation.equals(TypeConstants.JAVAX_ANNOTATION_INJECT_INJECT, this.compoundName))
+								this.id = TypeIds.T_JavaxInjectInject;
+							return;
+						case 'u':
+							if (CharOperation.equals(TypeConstants.JUNIT_FRAMEWORK_ASSERT, this.compoundName))
+								this.id = TypeIds.T_JunitFrameworkAssert;
+							return;
+					}
 					return;
 				default: return;
 			}
@@ -443,6 +452,10 @@ public void computeId() {
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_ITERATOR[2]))
 										this.id = TypeIds.T_JavaUtilIterator;
 									return;
+								case 'O' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_OBJECTS[2]))
+										this.id = TypeIds.T_JavaUtilObjects;
+									return;
 							}
 						}
 						return;
@@ -733,29 +746,49 @@ public void computeId() {
 					packageName = this.compoundName[1];
 					if (packageName.length == 0) return; // just to be safe
 
-					if (CharOperation.equals(TypeConstants.ECLIPSE, packageName)) {
-						packageName = this.compoundName[2];
-						if (packageName.length == 0) return; // just to be safe
-						switch (packageName[0]) {
-							case 'c' :
-								if (CharOperation.equals(packageName, TypeConstants.CORE)) { 
-									typeName = this.compoundName[3];
-									if (typeName.length == 0) return; // just to be safe
-									switch (typeName[0]) {
-										case 'r' :
-											char[] memberTypeName = this.compoundName[4];
-											if (memberTypeName.length == 0) return; // just to be safe
-											if (CharOperation.equals(typeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[3])
-													&& CharOperation.equals(memberTypeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[4]))
-												this.id = TypeIds.T_OrgEclipseCoreRuntimeAssert;
-											return;
-									}
+					switch (packageName[0]) {
+						case 'e':
+							if (CharOperation.equals(TypeConstants.ECLIPSE, packageName)) {
+								packageName = this.compoundName[2];
+								if (packageName.length == 0) return; // just to be safe
+								switch (packageName[0]) {
+									case 'c' :
+										if (CharOperation.equals(packageName, TypeConstants.CORE)) { 
+											typeName = this.compoundName[3];
+											if (typeName.length == 0) return; // just to be safe
+											switch (typeName[0]) {
+												case 'r' :
+													char[] memberTypeName = this.compoundName[4];
+													if (memberTypeName.length == 0) return; // just to be safe
+													if (CharOperation.equals(typeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[3])
+															&& CharOperation.equals(memberTypeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[4]))
+														this.id = TypeIds.T_OrgEclipseCoreRuntimeAssert;
+													return;
+											}
+										}
+										return;
 								}
 								return;
-						}
-						return;
+							}
+							return;
+						case 'a':
+							if (CharOperation.equals(TypeConstants.APACHE, packageName)) {
+								if (CharOperation.equals(TypeConstants.COMMONS, this.compoundName[2])) {
+									if (CharOperation.equals(TypeConstants.ORG_APACHE_COMMONS_LANG_VALIDATE, this.compoundName))
+										this.id = TypeIds.T_OrgApacheCommonsLangValidate;
+									else if (CharOperation.equals(TypeConstants.ORG_APACHE_COMMONS_LANG3_VALIDATE, this.compoundName))
+										this.id = TypeIds.T_OrgApacheCommonsLang3Validate;
+								}
+							}
+							return;
 					}
 					return;
+				case 'c':
+					if (!CharOperation.equals(TypeConstants.COM, this.compoundName[0]))
+						return;
+					if (CharOperation.equals(TypeConstants.COM_GOOGLE_COMMON_BASE_PRECONDITIONS, this.compoundName))
+						this.id = TypeIds.T_ComGoogleCommonBasePreconditions;
+					return;
 			}
 			break;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 1209039..a9c12fd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -82,6 +83,17 @@ public interface TypeConstants {
     char[] UPPER_LOCAL_VARIABLE = "LOCAL_VARIABLE".toCharArray(); //$NON-NLS-1$
     char[] UPPER_ANNOTATION_TYPE = "ANNOTATION_TYPE".toCharArray(); //$NON-NLS-1$
     char[] UPPER_PACKAGE = "PACKAGE".toCharArray(); //$NON-NLS-1$
+    
+    // common 3rd party package components:
+    char[] ORG = "org".toCharArray(); //$NON-NLS-1$
+    char[] ECLIPSE = "eclipse".toCharArray(); //$NON-NLS-1$
+    char[] CORE = "core".toCharArray(); //$NON-NLS-1$
+    char[] RUNTIME = "runtime".toCharArray(); //$NON-NLS-1$
+    char[] APACHE = "apache".toCharArray(); //$NON-NLS-1$
+    char[] COMMONS = "commons".toCharArray(); //$NON-NLS-1$
+    char[] LANG3 = "lang3".toCharArray(); //$NON-NLS-1$
+    char[] COM = "com".toCharArray(); //$NON-NLS-1$
+    char[] GOOGLE = "google".toCharArray(); //$NON-NLS-1$
 
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
@@ -118,6 +130,7 @@ public interface TypeConstants {
 	char[][] JAVA_LANG_VOID = {JAVA, LANG, "Void".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_OBJECTS = {JAVA, UTIL, "Objects".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
@@ -168,12 +181,13 @@ public interface TypeConstants {
 			this.selector = selector;
 		}
 	}
-	char[][] GUAVA_CLOSEABLES = { "com".toCharArray(), "google".toCharArray(), "common".toCharArray(), "io".toCharArray(), "Closeables".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
-	char[][] APACHE_IOUTILS = { "org".toCharArray(), "apache".toCharArray(), "commons".toCharArray(), "io".toCharArray(), "IOUtils".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
+	char[][] GUAVA_CLOSEABLES = { COM, GOOGLE, "common".toCharArray(), IO, "Closeables".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$
+	char[][] APACHE_IOUTILS = { ORG, APACHE, COMMONS, IO, "IOUtils".toCharArray() }; //$NON-NLS-1$
+	char[] CLOSE_QUIETLY = "closeQuietly".toCharArray(); //$NON-NLS-1$
 	CloseMethodRecord[] closeMethods = new CloseMethodRecord[] {
-		new CloseMethodRecord(GUAVA_CLOSEABLES, "closeQuietly".toCharArray()), //$NON-NLS-1$
-		new CloseMethodRecord(GUAVA_CLOSEABLES, "close".toCharArray()), //$NON-NLS-1$
-		new CloseMethodRecord(APACHE_IOUTILS, "closeQuietly".toCharArray()) //$NON-NLS-1$
+		new CloseMethodRecord(GUAVA_CLOSEABLES, CLOSE_QUIETLY),
+		new CloseMethodRecord(GUAVA_CLOSEABLES, CLOSE),
+		new CloseMethodRecord(APACHE_IOUTILS, CLOSE_QUIETLY)
 	};
 	// white lists of closeables:
 	char[][] JAVA_IO_WRAPPER_CLOSEABLES = new char[][] {
@@ -229,17 +243,43 @@ public interface TypeConstants {
 		"StringBufferInputStream".toCharArray(), //$NON-NLS-1$
 	};
 	
-	char[] ORG = "org".toCharArray(); //$NON-NLS-1$
-	char[] ECLIPSE = "eclipse".toCharArray(); //$NON-NLS-1$
-	char[] CORE = "core".toCharArray(); //$NON-NLS-1$
-	char[] RUNTIME = "runtime".toCharArray(); //$NON-NLS-1$
-	char[][] ORG_ECLIPSE_CORE_RUNTIME_ASSERT = new char[][] { ORG, ECLIPSE, CORE, RUNTIME, "Assert".toCharArray()}; //$NON-NLS-1$
+	// different assertion utilities:
+	char[] ASSERT_CLASS = "Assert".toCharArray(); //$NON-NLS-1$
+	char[][] ORG_ECLIPSE_CORE_RUNTIME_ASSERT = new char[][] { ORG, ECLIPSE, CORE, RUNTIME, ASSERT_CLASS };
+	// ... methods:
+	char[] IS_NOTNULL = "isNotNull".toCharArray(); //$NON-NLS-1$
+	
+	char[] JUNIT = "junit".toCharArray(); //$NON-NLS-1$
+	char[] FRAMEWORK = "framework".toCharArray(); //$NON-NLS-1$
+	char[][] JUNIT_FRAMEWORK_ASSERT = new char[][] { JUNIT, FRAMEWORK, ASSERT_CLASS };
+	// ... methods:
+	char[] ASSERT_NULL = "assertNull".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_NOTNULL = "assertNotNull".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_TRUE = "assertTrue".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_FALSE = "assertFalse".toCharArray(); //$NON-NLS-1$
+	
+	char[] VALIDATE_CLASS = "Validate".toCharArray(); //$NON-NLS-1$
+	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
+	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
+	// ... methods:
+	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
+	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
+	
+	char[][] COM_GOOGLE_COMMON_BASE_PRECONDITIONS = new char[][] { 
+			COM, GOOGLE, "common".toCharArray(), "base".toCharArray(), "Preconditions".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+	// ... methods:
+	char[] CHECK_NOT_NULL = "checkNotNull".toCharArray(); //$NON-NLS-1$
+	char[] CHECK_ARGUMENT = "checkArgument".toCharArray(); //$NON-NLS-1$
+	char[] CHECK_STATE = "checkState".toCharArray(); //$NON-NLS-1$
 
+	// ... methods in java.util.Objects:
+	char[] REQUIRE_NON_NULL = "requireNonNull".toCharArray(); //$NON-NLS-1$
+	
 	// different @Inject annotations are relevant for @NonNull fields
 	char[] INJECT_PACKAGE = "inject".toCharArray(); //$NON-NLS-1$
 	char[] INJECT_TYPE = "Inject".toCharArray(); //$NON-NLS-1$
 	char[][] JAVAX_ANNOTATION_INJECT_INJECT = new char[][] { JAVAX, INJECT_PACKAGE, INJECT_TYPE };
-	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {"com".toCharArray(), "google".toCharArray(), INJECT_PACKAGE, INJECT_TYPE }; //$NON-NLS-1$ //$NON-NLS-2$
+	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {COM, GOOGLE, INJECT_PACKAGE, INJECT_TYPE };
 	//    detail for the above:
 	char[] OPTIONAL = "optional".toCharArray(); //$NON-NLS-1$
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 559b62c..e15d805 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -110,10 +111,17 @@ public interface TypeIds {
 	
 	// new in 3.8 to identify org.eclipse.core.runtime.Assert
 	final int T_OrgEclipseCoreRuntimeAssert = 68;
+	// new in 3.9 to identify more assertion utilities:
+	final int T_JunitFrameworkAssert = 69;
+	final int T_OrgApacheCommonsLangValidate = 70;
+	final int T_OrgApacheCommonsLang3Validate = 71;
+	final int T_ComGoogleCommonBasePreconditions = 72;
+	final int T_JavaUtilObjects = 73;
 
 	// new in 3.9 to identify known @Inject annotations
-	final int T_JavaxInjectInject = 69;
-	final int T_ComGoogleInjectInject = 70;
+	final int T_JavaxInjectInject = 80;
+	final int T_ComGoogleInjectInject = 81;
+
 
 	final int NoId = Integer.MAX_VALUE;
 
commit 986a6d11b1b7e4db82dd5d830210e01550f74aa3
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Feb 17 18:50:37 2013 +0100

    Bug 382069: [null] Make the null analysis consider JUnit's assertNotNull
    similarly to assertions

87	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
273	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
7	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
164	31	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
55	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
51	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
10	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 3e4165c..1c1f521 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2010, 2012 GK Software AG and others.
+ * Copyright (c) 2010, 2013 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -5854,4 +5854,90 @@ public void testBug388281_10() {
 		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n"); 
 }
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNull vs. a @NonNull field / expression
+public void testBug382069_j() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			NullReferenceTestAsserts.JUNIT_ASSERT_NAME,
+			NullReferenceTestAsserts.JUNIT_ASSERT_CONTENT,		
+			"X.java",
+			"import org.eclipse.jdt.annotation.NonNull;\n" +
+			"public class X {\n" +
+			"  @NonNull String o1 = \"\";\n" +
+			"  boolean foo() {\n" +
+			"    junit.framework.Assert.assertNull(\"something's wrong\", o1);\n" + // always fails due to @NonNull
+			"    return false; // dead code\n" +
+			"  }\n" +
+			"  void bar() {\n" +
+			"      junit.framework.Assert.assertNull(\"\");\n" + // constantly false
+			"      return; // dead code\n" +
+			"  }\n" +
+			"  void zork() {\n" +
+			"      junit.framework.Assert.assertNotNull(null);\n" + // constantly false
+			"      return; // dead code\n" +
+			"  }\n" +
+			"}\n"},
+			options,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 6)\n" + 
+			"	return false; // dead code\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 10)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 14)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNonNull et al. affecting a @Nullable field using syntactic analysis
+public void testBug382069_k() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS, JavaCore.ENABLED);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			NullReferenceTestAsserts.JUNIT_ASSERT_NAME,
+			NullReferenceTestAsserts.JUNIT_ASSERT_CONTENT,		
+			"X.java",
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"public class X {\n" +
+			"  @Nullable String o1;\n" +
+			"  int foo() {\n" +
+			"    junit.framework.Assert.assertNotNull(\"something's wrong\", o1);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"  int bar(int i) {\n" +
+			"    junit.framework.Assert.assertNotNull(o1);\n" +
+			"    i++;\n" + // expire
+			"    return o1.length(); // no longer protected\n" +
+			"  }\n" +
+			"  int garp() {\n" +
+			"    junit.framework.Assert.assertFalse(\"something's wrong\", o1 == null);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"  int zipp() {\n" +
+			"    junit.framework.Assert.assertTrue(\"something's wrong\", o1 != null);\n" +
+			"    return o1.length();\n" +
+			"  }\n" +
+			"}\n"},
+			options,
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	return o1.length(); // no longer protected\n" + 
+			"	       ^^\n" + 
+			"Potential null pointer access: The field o1 is declared as @Nullable\n" + 
+			"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
index 98df523..1973828 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
@@ -1,12 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     IBM Corporation - initial API and implementation
+ *		IBM Corporation - initial API and implementation
+ *		Stephan Herrmann - Contribution for
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -35,11 +37,61 @@ public NullReferenceTestAsserts(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "testBug373953" };
+//		TESTS_NAMES = new String[] { "testBug382069" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
 
+static final String JUNIT_ASSERT_NAME = "junit/framework/Assert.java";
+static final String JUNIT_ASSERT_CONTENT = "package junit.framework;\n" +
+		"public class Assert {\n" +
+		"    static public void assertNull(Object object) {}\n" +
+		"    static public void assertNull(String message, Object object) {}\n" +
+		"    static public void assertNotNull(Object object) {}\n" +
+		"    static public void assertNotNull(String message, Object object) {}\n" +
+		"    static public void assertTrue(boolean expression) {}\n" +
+		"    static public void assertTrue(String message, boolean expression) {}\n" +
+		"    static public void assertFalse(boolean expression) {}\n" +
+		"    static public void assertFalse(String message, boolean expression) {}\n" +
+		"}\n";
+
+static final String APACHE_VALIDATE_NAME = "org/apache/commons/lang/Validate.java";
+static final String APACHE_VALIDATE_CONTENT = "package org.apache.commons.lang;\n" +
+		"public class Validate {\n" +
+		"    static public void notNull(Object object) {}\n" +
+		"    static public void notNull(Object object, String message) {}\n" +
+		"    static public void isTrue(boolean expression) {}\n" +
+		"    static public void isTrue(boolean expression, String message) {}\n" +
+		"    static public void isTrue(boolean expression, String message, double value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, long value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, Object value) {}\n" +
+		"}\n";
+
+static final String APACHE_3_VALIDATE_NAME = "org/apache/commons/lang3/Validate.java";
+static final String APACHE_3_VALIDATE_CONTENT = "package org.apache.commons.lang3;\n" +
+		"public class Validate {\n" +
+		"    static public <T> T notNull(T object) { return object; }\n" +
+		"    static public <T> T notNull(T object, String message, Object... values) { return object; }\n" +
+		"    static public void isTrue(boolean expression) {}\n" +
+		"    static public void isTrue(boolean expression, String message, double value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, long value) {}\n" +
+		"    static public void isTrue(boolean expression, String message, Object value) {}\n" +
+		"}\n";
+
+static final String GOOGLE_PRECONDITIONS_NAME = "com/google/common/base/Preconditions.java";
+static final String GOOGLE_PRECONDITIONS_CONTENT = "package com.google.common.base;\n" +
+		"public class Preconditions {\n" +
+		"    static public <T> T checkNotNull(T object) { return object; }\n" +
+		"    static public <T> T checkNotNull(T object, Object message) { return object; }\n" +
+		"    static public <T> T checkNotNull(T object, String message, Object... values) { return object; }\n" +
+		"    static public void checkArgument(boolean expression) {}\n" +
+		"    static public void checkArgument(boolean expression, Object message) {}\n" +
+		"    static public void checkArgument(boolean expression, String msgTmpl, Object... messageArgs) {}\n" +
+		"    static public void checkState(boolean expression) {}\n" +
+		"    static public void checkState(boolean expression, Object message) {}\n" +
+		"    static public void checkState(boolean expression, String msgTmpl, Object... messageArgs) {}\n" +
+		"}\n";
+
 public static Test suite() {
 	return buildAllCompliancesTestSuite(testClass());
 }
@@ -91,7 +143,7 @@ public void testBug127575a() throws IOException {
 				"}\n"},
 			"",
 			this.assertLib,
-			false,
+			true,
 			null);
 }
 
@@ -751,4 +803,221 @@ public void testBug373953() throws IOException {
 			"Potential null pointer access: The variable o may be null at this location\n" + 
 			"----------\n");
 }
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNotNull
+public void testBug382069a() throws IOException {
+	this.runConformTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  void foo(Object o1, String o2) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    junit.framework.Assert.assertNotNull(o1);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    junit.framework.Assert.assertNotNull(\"msg\", o2);\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"  }\n" +
+			"}\n"},
+		"");
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// org.eclipse.core.runtime.Assert.isNotNull
+public void testBug382069b() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runConformTest(
+			new String[] {
+		"X.java",
+				"public class X {\n" + 
+				"  void foo(Object o1, String o2) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    org.eclipse.core.runtime.Assert.isNotNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    org.eclipse.core.runtime.Assert.isNotNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"  }\n" +
+				"}"	
+			},
+			"",
+			this.assertLib,
+			true,
+			null);
+	}
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertNull and dead code analysis
+public void testBug382069c() throws IOException {
+	this.runNegativeTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  boolean foo(String o1, String o2) {\n" +
+			"    junit.framework.Assert.assertNull(\"something's wrong\", o1);\n" + 	// establish nullness
+			"    if (o2 == null)\n" +
+			"        return o1 != null;\n" +
+			"    junit.framework.Assert.assertNull(o2);\n" + // will always throw
+			"    return false; // dead code\n" +
+			"  }\n" +
+			"  void bar(X x) {\n" +
+			"    if (x == null) {\n" +
+			"      junit.framework.Assert.assertNotNull(x);\n" +
+			"      return; // dead code\n" +
+			"    }\n" +
+			"  }\n" +
+			"}\n"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 5)\n" + 
+			"	return o1 != null;\n" + 
+			"	       ^^\n" + 
+			"Null comparison always yields false: The variable o1 can only be null at this location\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 7)\n" + 
+			"	return false; // dead code\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 12)\n" + 
+			"	return; // dead code\n" + 
+			"	^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from org.apache.commons.lang.Validate
+public void testBug382069d() throws IOException {
+	this.runNegativeTest(
+		new String[] {
+			APACHE_VALIDATE_NAME,
+			APACHE_VALIDATE_CONTENT,
+			"X.java",
+			"import org.apache.commons.lang.Validate;\n" +
+			"public class X {\n" +
+			"  void foo(Object o1, String o2, X x) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    Validate.notNull(o1);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    Validate.notNull(o2, \"msg\");\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"    Validate.isTrue(x == null, \"ups\", x);\n" +
+			"    x.foo(null, null, null); // definite NPE\n" +
+			"  }\n" +
+			"}\n"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 11)\n" + 
+			"	x.foo(null, null, null); // definite NPE\n" + 
+			"	^\n" + 
+			"Null pointer access: The variable x can only be null at this location\n" + 
+			"----------\n");
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from org.apache.commons.lang3Validate
+public void testBug382069e() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+				APACHE_3_VALIDATE_NAME,
+				APACHE_3_VALIDATE_CONTENT,
+				"X.java",
+				"import org.apache.commons.lang3.Validate;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    Validate.notNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    Validate.notNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"    Validate.isTrue(x == null, \"ups\", x);\n" +
+				"    x.foo(null, null, null); // definite NPE\n" +
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	x.foo(null, null, null); // definite NPE\n" + 
+				"	^\n" + 
+				"Null pointer access: The variable x can only be null at this location\n" + 
+				"----------\n");
+	}
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// various asserts from com.google.common.base.Preconditions
+public void testBug382069f() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+				GOOGLE_PRECONDITIONS_NAME,
+				GOOGLE_PRECONDITIONS_CONTENT,
+				"X.java",
+				"import com.google.common.base.Preconditions;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    Preconditions.checkNotNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    Preconditions.checkNotNull(o2, \"msg {0}.{1}\", o1, o2);\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"    Preconditions.checkArgument(x == null, \"ups\");\n" +
+				"    x.foo(null, null, null); // definite NPE\n" +
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	x.foo(null, null, null); // definite NPE\n" + 
+				"	^\n" + 
+				"Null pointer access: The variable x can only be null at this location\n" + 
+				"----------\n");
+	}
+}
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// java.util.Objects#requireNonNull
+public void testBug382069g() throws IOException {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_7) {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import static java.util.Objects.requireNonNull;\n" +
+				"public class X {\n" +
+				"  void foo(Object o1, String o2, X x) {\n" +
+				"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+				"    requireNonNull(o1);\n" + 	// protection
+				"    o1.toString();\n" + 		// quiet
+				"    b = o2 != null;\n" + // sheds doubts upon o2
+				"    requireNonNull(o2, \"msg\");\n" + 	// protection
+				"    o2.toString();\n" + 		// quiet
+				"  }\n" +
+				"}\n"},
+				"");
+	}
+}
+
+// https://bugs.eclipse.org/382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+// junit's assertTrue / assertFalse
+public void testBug382069h() throws IOException {
+	this.runConformTest(
+		new String[] {
+			JUNIT_ASSERT_NAME,
+			JUNIT_ASSERT_CONTENT,
+			"X.java",
+			"public class X {\n" +
+			"  void foo(Object o1, String o2) {\n" +
+			"    boolean b = o1 != null;\n" + // sheds doubts upon o1
+			"    junit.framework.Assert.assertTrue(o1 != null);\n" + 	// protection
+			"    o1.toString();\n" + 		// quiet
+			"    b = o2 != null;\n" + // sheds doubts upon o2
+			"    junit.framework.Assert.assertFalse(\"msg\", o2 == null);\n" + 	// protection
+			"    o2.toString();\n" + 		// quiet
+			"  }\n" +
+			"}\n"},
+		"");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 8ede946..ff8c93e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -46,6 +47,7 @@ public class EqualExpression extends BinaryExpression {
 			rightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkEquality);
 		}
 		
+		boolean contextualCheckEquality = checkEquality ^ ((flowContext.tagBits & FlowContext.INSIDE_NEGATIVE_ASSERT) != 0);
 		// perform flowInfo-based checks for variables and record info for syntactic null analysis for fields:
 		if (!leftNonNullChecked) {
 			LocalVariableBinding local = this.left.localVariableBinding();
@@ -54,7 +56,8 @@ public class EqualExpression extends BinaryExpression {
 					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
 				}
 			} else if (this.left instanceof Reference
-							&& ((!checkEquality && rightStatus == FlowInfo.NULL) || (checkEquality && rightStatus == FlowInfo.NON_NULL))
+							&& ((!contextualCheckEquality && rightStatus == FlowInfo.NULL) 
+									|| (contextualCheckEquality && rightStatus == FlowInfo.NON_NULL))
 							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields)
 			{
 				FieldBinding field = ((Reference)this.left).lastFieldBinding();
@@ -70,7 +73,8 @@ public class EqualExpression extends BinaryExpression {
 					checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
 				}
 			} else if (this.right instanceof Reference
-							&& ((!checkEquality && leftStatus == FlowInfo.NULL) || (checkEquality && leftStatus == FlowInfo.NON_NULL))
+							&& ((!contextualCheckEquality && leftStatus == FlowInfo.NULL) 
+									|| (contextualCheckEquality && leftStatus == FlowInfo.NON_NULL))
 							&& scope.compilerOptions().enableSyntacticNullAnalysisForFields) 
 			{
 				FieldBinding field = ((Reference)this.right).lastFieldBinding();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index e3a5430..818d647 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -28,6 +28,7 @@
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *								bug 382350 - [1.8][compiler] Unable to invoke inherited default method via I.super.m() syntax
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
  *******************************************************************************/
@@ -48,7 +49,9 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier;
+import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
@@ -136,7 +139,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 	}
 
-	FlowInfo conditionFlowInfo;
 	if (this.arguments != null) {
 		int length = this.arguments.length;
 		for (int i = 0; i < length; i++) {
@@ -144,36 +146,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			if ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {
 				argument.checkNPE(currentScope, flowContext, flowInfo);
 			}
-			if (this.receiver.resolvedType != null 
-					&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert
-					&& argument.resolvedType != null
-					&& argument.resolvedType.id == TypeIds.T_boolean) {
-				Constant cst = argument.optimizedBooleanConstant();
-				boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
-				boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
-				flowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;
-				conditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());
-				if (!wasInsideAssert) {
-					flowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;
-				}
-				UnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
-				FlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();
-				if (isOptimizedTrueAssertion) {
-					assertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
-				}
-				if (!isOptimizedFalseAssertion) {
-					// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.
-					// if the code does reach ahead, it means the assert didn't cause an exit, and so
-					// the expression inside it shouldn't change the prior flowinfo
-					// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)
-					
-					// keep the merge from the initial code for the definite assignment
-					// analysis, tweak the null part to influence nulls downstream
-					flowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).
-						addInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());
-				}
-			} else {
-				flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			switch (detectAssertionUtility(i)) {
+				case TRUE_ASSERTION:
+					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);
+					break;
+				case FALSE_ASSERTION:
+					flowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, false);
+					break;
+				case NONNULL_ASSERTION:
+					flowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, false);
+					break;
+				case NULL_ASSERTION:
+					flowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, true);
+					break;
+				default:
+					flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 			}
 			if (analyseResources) {
 				// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)
@@ -200,6 +187,152 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	flowContext.expireNullCheckedFieldInfo(); // no longer trust this info after any message send
 	return flowInfo;
 }
+
+// classification of well-known assertion utilities:
+private static final int TRUE_ASSERTION = 1;
+private static final int FALSE_ASSERTION = 2;
+private static final int NULL_ASSERTION = 3;
+private static final int NONNULL_ASSERTION = 4;
+
+// is the argument at the given position being checked by a well-known assertion utility?
+// if so answer what kind of assertion we are facing.
+private int detectAssertionUtility(int argumentIdx) {
+	TypeBinding[] parameters = this.binding.original().parameters;
+	if (argumentIdx < parameters.length) {
+		TypeBinding parameterType = parameters[argumentIdx];
+		if (this.actualReceiverType != null && parameterType != null) {
+			switch (this.actualReceiverType.id) {
+				case TypeIds.T_OrgEclipseCoreRuntimeAssert:
+					if (parameterType.id == TypeIds.T_boolean)
+						return TRUE_ASSERTION;
+					if (parameterType.id == TypeIds.T_JavaLangObject && CharOperation.equals(TypeConstants.IS_NOTNULL, this.selector))
+						return NONNULL_ASSERTION;
+					break;
+				case TypeIds.T_JunitFrameworkAssert:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.ASSERT_TRUE, this.selector))
+							return TRUE_ASSERTION;
+						if (CharOperation.equals(TypeConstants.ASSERT_FALSE, this.selector))
+							return FALSE_ASSERTION;
+					} else if (parameterType.id == TypeIds.T_JavaLangObject) {
+						if (CharOperation.equals(TypeConstants.ASSERT_NOTNULL, this.selector))
+							return NONNULL_ASSERTION;
+						if (CharOperation.equals(TypeConstants.ASSERT_NULL, this.selector))
+							return NULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_OrgApacheCommonsLangValidate:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.IS_TRUE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.id == TypeIds.T_JavaLangObject) {
+						if (CharOperation.equals(TypeConstants.NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_OrgApacheCommonsLang3Validate:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.IS_TRUE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;
+				case TypeIds.T_ComGoogleCommonBasePreconditions:
+					if (parameterType.id == TypeIds.T_boolean) {
+						if (CharOperation.equals(TypeConstants.CHECK_ARGUMENT, this.selector)
+							|| CharOperation.equals(TypeConstants.CHECK_STATE, this.selector))
+							return TRUE_ASSERTION;
+					} else if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.CHECK_NOT_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;					
+				case TypeIds.T_JavaUtilObjects:
+					if (parameterType.isTypeVariable()) {
+						if (CharOperation.equals(TypeConstants.REQUIRE_NON_NULL, this.selector))
+							return NONNULL_ASSERTION;
+					}
+					break;					
+			}
+		}
+	}
+	return 0;
+}
+private FlowInfo analyseBooleanAssertion(BlockScope currentScope, Expression argument,
+		FlowContext flowContext, FlowInfo flowInfo, boolean wasInsideAssert, boolean passOnTrue)
+{
+	Constant cst = argument.optimizedBooleanConstant();
+	boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
+	boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
+	int tagBitsSave = flowContext.tagBits;
+	flowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;
+	if (!passOnTrue)
+		flowContext.tagBits |= FlowContext.INSIDE_NEGATIVE_ASSERT; // this affects syntactic analysis for fields in EqualExpression
+	FlowInfo conditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());
+	flowContext.extendTimeToLiveForNullCheckedField(2); // survive this assert as a MessageSend and as a Statement
+	flowContext.tagBits = tagBitsSave;
+
+	UnconditionalFlowInfo assertWhenPassInfo;
+	FlowInfo assertWhenFailInfo;
+	boolean isOptimizedPassing;
+	boolean isOptimizedFailing;
+	if (passOnTrue) {
+		assertWhenPassInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
+		assertWhenFailInfo = conditionFlowInfo.initsWhenFalse();
+		isOptimizedPassing = isOptimizedTrueAssertion;
+		isOptimizedFailing = isOptimizedFalseAssertion;
+	} else {
+		assertWhenPassInfo = conditionFlowInfo.initsWhenFalse().unconditionalInits();
+		assertWhenFailInfo = conditionFlowInfo.initsWhenTrue();
+		isOptimizedPassing = isOptimizedFalseAssertion;
+		isOptimizedFailing = isOptimizedTrueAssertion;
+	}
+	if (isOptimizedPassing) {
+		assertWhenFailInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
+	}
+	if (!isOptimizedFailing) {
+		// if assertion is not failing for sure, only then it makes sense to carry the flow info ahead.
+		// if the code does reach ahead, it means the assert didn't cause an exit, and so
+		// the expression inside it shouldn't change the prior flowinfo
+		// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)
+		
+		// keep the merge from the initial code for the definite assignment
+		// analysis, tweak the null part to influence nulls downstream
+		flowInfo = flowInfo.mergedWith(assertWhenFailInfo.nullInfoLessUnconditionalCopy()).
+			addInitializationsFrom(assertWhenPassInfo.discardInitializationInfo());
+	}
+	return flowInfo;
+}
+private FlowInfo analyseNullAssertion(BlockScope currentScope, Expression argument,
+		FlowContext flowContext, FlowInfo flowInfo, boolean expectingNull)
+{
+	int nullStatus = argument.nullStatus(flowInfo, flowContext);
+	boolean willFail = (nullStatus == (expectingNull ? FlowInfo.NON_NULL : FlowInfo.NULL));
+	flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+	LocalVariableBinding local = argument.localVariableBinding();
+	if (local != null) {// beyond this point the argument can only be null/nonnull
+		if (expectingNull) 
+			flowInfo.markAsDefinitelyNull(local);
+		else 
+			flowInfo.markAsDefinitelyNonNull(local);
+	} else {
+		if (!expectingNull
+			&& argument instanceof Reference 
+			&& currentScope.compilerOptions().enableSyntacticNullAnalysisForFields) 
+		{
+			FieldBinding field = ((Reference)argument).lastFieldBinding();
+			if (field != null && (field.type.tagBits & TagBits.IsBaseType) == 0) {
+				flowContext.recordNullCheckedFieldReference((Reference) argument, 3); // survive this assert as a MessageSend and as a Statement
+			}
+		}
+	}
+	if (willFail)
+		flowInfo.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+	return flowInfo;
+}
+
 public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	// message send as a receiver
 	if ((nullStatus(flowInfo, flowContext) & FlowInfo.POTENTIALLY_NULL) != 0) // note that flowInfo is not used inside nullStatus(..)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index ba342e3..56e25ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -84,6 +84,8 @@ public class FlowContext implements TypeConstants {
 
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
+	// inside an assertFalse checks for equality / inequality have reversed meaning for syntactic analysis for fields:
+	public static final int INSIDE_NEGATIVE_ASSERT = 0x4;
 	/**
 	 * used to hide null comparison related warnings inside assert statements 
 	 */
@@ -154,6 +156,13 @@ public void recordNullCheckedFieldReference(Reference reference, int timeToLive)
 		this.nullCheckedFieldReferences[len] = reference;
 	}
 }
+
+/** If a null checked field has been recorded recently, increase its time to live. */
+public void extendTimeToLiveForNullCheckedField(int t) {
+	if (this.timeToLiveForNullCheckInfo > 0)
+		this.timeToLiveForNullCheckInfo += t;
+}
+
 /**
  * Forget any information about fields that were previously known to be non-null.
  * 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 20a162b..e7736d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -21,6 +21,7 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *      Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -391,15 +392,23 @@ public void computeId() {
 
 		case 3 :
 			char[] packageName = this.compoundName[0];
-			// expect only java.*.* and javax.*.*
+			// expect only java.*.* and javax.*.* and junit.*.*
 			switch (packageName.length) {
 				case 4:
 					if (!CharOperation.equals(TypeConstants.JAVA, packageName))
 						return;
 					break; // continue below ...
 				case 5:
-					if (CharOperation.equals(TypeConstants.JAVAX_ANNOTATION_INJECT_INJECT, this.compoundName))
-						this.id = TypeIds.T_JavaxInjectInject;
+					switch (packageName[1]) {
+						case 'a':
+							if (CharOperation.equals(TypeConstants.JAVAX_ANNOTATION_INJECT_INJECT, this.compoundName))
+								this.id = TypeIds.T_JavaxInjectInject;
+							return;
+						case 'u':
+							if (CharOperation.equals(TypeConstants.JUNIT_FRAMEWORK_ASSERT, this.compoundName))
+								this.id = TypeIds.T_JunitFrameworkAssert;
+							return;
+					}
 					return;
 				default: return;
 			}
@@ -453,6 +462,10 @@ public void computeId() {
 									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_ITERATOR[2]))
 										this.id = TypeIds.T_JavaUtilIterator;
 									return;
+								case 'O' :
+									if (CharOperation.equals(typeName, TypeConstants.JAVA_UTIL_OBJECTS[2]))
+										this.id = TypeIds.T_JavaUtilObjects;
+									return;
 							}
 						}
 						return;
@@ -745,29 +758,49 @@ public void computeId() {
 					packageName = this.compoundName[1];
 					if (packageName.length == 0) return; // just to be safe
 
-					if (CharOperation.equals(TypeConstants.ECLIPSE, packageName)) {
-						packageName = this.compoundName[2];
-						if (packageName.length == 0) return; // just to be safe
-						switch (packageName[0]) {
-							case 'c' :
-								if (CharOperation.equals(packageName, TypeConstants.CORE)) { 
-									typeName = this.compoundName[3];
-									if (typeName.length == 0) return; // just to be safe
-									switch (typeName[0]) {
-										case 'r' :
-											char[] memberTypeName = this.compoundName[4];
-											if (memberTypeName.length == 0) return; // just to be safe
-											if (CharOperation.equals(typeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[3])
-													&& CharOperation.equals(memberTypeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[4]))
-												this.id = TypeIds.T_OrgEclipseCoreRuntimeAssert;
-											return;
-									}
+					switch (packageName[0]) {
+						case 'e':
+							if (CharOperation.equals(TypeConstants.ECLIPSE, packageName)) {
+								packageName = this.compoundName[2];
+								if (packageName.length == 0) return; // just to be safe
+								switch (packageName[0]) {
+									case 'c' :
+										if (CharOperation.equals(packageName, TypeConstants.CORE)) { 
+											typeName = this.compoundName[3];
+											if (typeName.length == 0) return; // just to be safe
+											switch (typeName[0]) {
+												case 'r' :
+													char[] memberTypeName = this.compoundName[4];
+													if (memberTypeName.length == 0) return; // just to be safe
+													if (CharOperation.equals(typeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[3])
+															&& CharOperation.equals(memberTypeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[4]))
+														this.id = TypeIds.T_OrgEclipseCoreRuntimeAssert;
+													return;
+											}
+										}
+										return;
 								}
 								return;
-						}
-						return;
+							}
+							return;
+						case 'a':
+							if (CharOperation.equals(TypeConstants.APACHE, packageName)) {
+								if (CharOperation.equals(TypeConstants.COMMONS, this.compoundName[2])) {
+									if (CharOperation.equals(TypeConstants.ORG_APACHE_COMMONS_LANG_VALIDATE, this.compoundName))
+										this.id = TypeIds.T_OrgApacheCommonsLangValidate;
+									else if (CharOperation.equals(TypeConstants.ORG_APACHE_COMMONS_LANG3_VALIDATE, this.compoundName))
+										this.id = TypeIds.T_OrgApacheCommonsLang3Validate;
+								}
+							}
+							return;
 					}
 					return;
+				case 'c':
+					if (!CharOperation.equals(TypeConstants.COM, this.compoundName[0]))
+						return;
+					if (CharOperation.equals(TypeConstants.COM_GOOGLE_COMMON_BASE_PRECONDITIONS, this.compoundName))
+						this.id = TypeIds.T_ComGoogleCommonBasePreconditions;
+					return;
 			}
 			break;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index cfa37cd..a26c81b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -16,6 +16,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 381445 - [compiler][resource] Can the resource leak check be made aware of Closeables.closeQuietly?
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -91,6 +92,17 @@ public interface TypeConstants {
 	// jsr308
 	char[] TYPE_USE_TARGET  = "TYPE_USE".toCharArray(); //$NON-NLS-1$
 	char[] TYPE_PARAMETER_TARGET = "TYPE_PARAMETER".toCharArray(); //$NON-NLS-1$
+    
+    // common 3rd party package components:
+    char[] ORG = "org".toCharArray(); //$NON-NLS-1$
+    char[] ECLIPSE = "eclipse".toCharArray(); //$NON-NLS-1$
+    char[] CORE = "core".toCharArray(); //$NON-NLS-1$
+    char[] RUNTIME = "runtime".toCharArray(); //$NON-NLS-1$
+    char[] APACHE = "apache".toCharArray(); //$NON-NLS-1$
+    char[] COMMONS = "commons".toCharArray(); //$NON-NLS-1$
+    char[] LANG3 = "lang3".toCharArray(); //$NON-NLS-1$
+    char[] COM = "com".toCharArray(); //$NON-NLS-1$
+    char[] GOOGLE = "google".toCharArray(); //$NON-NLS-1$
 
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
@@ -127,6 +139,7 @@ public interface TypeConstants {
 	char[][] JAVA_LANG_VOID = {JAVA, LANG, "Void".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_OBJECTS = {JAVA, UTIL, "Objects".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
 	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
@@ -178,12 +191,13 @@ public interface TypeConstants {
 			this.selector = selector;
 		}
 	}
-	char[][] GUAVA_CLOSEABLES = { "com".toCharArray(), "google".toCharArray(), "common".toCharArray(), "io".toCharArray(), "Closeables".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
-	char[][] APACHE_IOUTILS = { "org".toCharArray(), "apache".toCharArray(), "commons".toCharArray(), "io".toCharArray(), "IOUtils".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
+	char[][] GUAVA_CLOSEABLES = { COM, GOOGLE, "common".toCharArray(), IO, "Closeables".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$
+	char[][] APACHE_IOUTILS = { ORG, APACHE, COMMONS, IO, "IOUtils".toCharArray() }; //$NON-NLS-1$
+	char[] CLOSE_QUIETLY = "closeQuietly".toCharArray(); //$NON-NLS-1$
 	CloseMethodRecord[] closeMethods = new CloseMethodRecord[] {
-		new CloseMethodRecord(GUAVA_CLOSEABLES, "closeQuietly".toCharArray()), //$NON-NLS-1$
-		new CloseMethodRecord(GUAVA_CLOSEABLES, "close".toCharArray()), //$NON-NLS-1$
-		new CloseMethodRecord(APACHE_IOUTILS, "closeQuietly".toCharArray()) //$NON-NLS-1$
+		new CloseMethodRecord(GUAVA_CLOSEABLES, CLOSE_QUIETLY),
+		new CloseMethodRecord(GUAVA_CLOSEABLES, CLOSE),
+		new CloseMethodRecord(APACHE_IOUTILS, CLOSE_QUIETLY)
 	};
 	// white lists of closeables:
 	char[][] JAVA_IO_WRAPPER_CLOSEABLES = new char[][] {
@@ -239,17 +253,43 @@ public interface TypeConstants {
 		"StringBufferInputStream".toCharArray(), //$NON-NLS-1$
 	};
 	
-	char[] ORG = "org".toCharArray(); //$NON-NLS-1$
-	char[] ECLIPSE = "eclipse".toCharArray(); //$NON-NLS-1$
-	char[] CORE = "core".toCharArray(); //$NON-NLS-1$
-	char[] RUNTIME = "runtime".toCharArray(); //$NON-NLS-1$
-	char[][] ORG_ECLIPSE_CORE_RUNTIME_ASSERT = new char[][] { ORG, ECLIPSE, CORE, RUNTIME, "Assert".toCharArray()}; //$NON-NLS-1$
+	// different assertion utilities:
+	char[] ASSERT_CLASS = "Assert".toCharArray(); //$NON-NLS-1$
+	char[][] ORG_ECLIPSE_CORE_RUNTIME_ASSERT = new char[][] { ORG, ECLIPSE, CORE, RUNTIME, ASSERT_CLASS };
+	// ... methods:
+	char[] IS_NOTNULL = "isNotNull".toCharArray(); //$NON-NLS-1$
+	
+	char[] JUNIT = "junit".toCharArray(); //$NON-NLS-1$
+	char[] FRAMEWORK = "framework".toCharArray(); //$NON-NLS-1$
+	char[][] JUNIT_FRAMEWORK_ASSERT = new char[][] { JUNIT, FRAMEWORK, ASSERT_CLASS };
+	// ... methods:
+	char[] ASSERT_NULL = "assertNull".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_NOTNULL = "assertNotNull".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_TRUE = "assertTrue".toCharArray(); //$NON-NLS-1$
+	char[] ASSERT_FALSE = "assertFalse".toCharArray(); //$NON-NLS-1$
+	
+	char[] VALIDATE_CLASS = "Validate".toCharArray(); //$NON-NLS-1$
+	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
+	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
+	// ... methods:
+	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
+	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
+	
+	char[][] COM_GOOGLE_COMMON_BASE_PRECONDITIONS = new char[][] { 
+			COM, GOOGLE, "common".toCharArray(), "base".toCharArray(), "Preconditions".toCharArray() }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+	// ... methods:
+	char[] CHECK_NOT_NULL = "checkNotNull".toCharArray(); //$NON-NLS-1$
+	char[] CHECK_ARGUMENT = "checkArgument".toCharArray(); //$NON-NLS-1$
+	char[] CHECK_STATE = "checkState".toCharArray(); //$NON-NLS-1$
 
+	// ... methods in java.util.Objects:
+	char[] REQUIRE_NON_NULL = "requireNonNull".toCharArray(); //$NON-NLS-1$
+	
 	// different @Inject annotations are relevant for @NonNull fields
 	char[] INJECT_PACKAGE = "inject".toCharArray(); //$NON-NLS-1$
 	char[] INJECT_TYPE = "Inject".toCharArray(); //$NON-NLS-1$
 	char[][] JAVAX_ANNOTATION_INJECT_INJECT = new char[][] { JAVAX, INJECT_PACKAGE, INJECT_TYPE };
-	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {"com".toCharArray(), "google".toCharArray(), INJECT_PACKAGE, INJECT_TYPE }; //$NON-NLS-1$ //$NON-NLS-2$
+	char[][] COM_GOOGLE_INJECT_INJECT = new char[][] {COM, GOOGLE, INJECT_PACKAGE, INJECT_TYPE };
 	//    detail for the above:
 	char[] OPTIONAL = "optional".toCharArray(); //$NON-NLS-1$
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 9309929..86c0401 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -17,6 +17,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 400421 - [compiler] Null analysis for fields does not take @com.google.inject.Inject into account
+ *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -114,13 +115,20 @@ public interface TypeIds {
 	
 	// new in 3.8 to identify org.eclipse.core.runtime.Assert
 	final int T_OrgEclipseCoreRuntimeAssert = 68;
+	// new in 3.9 to identify more assertion utilities:
+	final int T_JunitFrameworkAssert = 69;
+	final int T_OrgApacheCommonsLangValidate = 70;
+	final int T_OrgApacheCommonsLang3Validate = 71;
+	final int T_ComGoogleCommonBasePreconditions = 72;
+	final int T_JavaUtilObjects = 73;
 
 	// java 8
 	final int T_JavaLangFunctionalInterface = 69;
 
 	// new in 3.9 to identify known @Inject annotations
-	final int T_JavaxInjectInject = 69;
-	final int T_ComGoogleInjectInject = 70;
+	final int T_JavaxInjectInject = 80;
+	final int T_ComGoogleInjectInject = 81;
+
 
 	final int NoId = Integer.MAX_VALUE;
 
