commit 911d33fcf73cf50d25fee7b3e39062c93c0d7abb
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Thu Jun 15 18:14:02 2017 +0530

    Fix for Bug 518301: [1.9] [dom]Change ModuleStatements to
    ModuleDirectives  - dom ast part

16	16	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
38	38	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
10	10	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
10	10	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
14	14	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
25	25	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
10	10	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
128	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
0	128	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
4	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
37	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
0	37	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
127	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
0	127	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
226	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
0	226	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
251	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
0	251	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
190	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
0	190	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
11	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
11	11	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
4	4	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
6	6	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
6	6	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
22	22	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index 2a9efa3..e0ddc00 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -166,13 +166,13 @@ public class ASTConverter9Test extends ConverterTestSetup {
 
 		assertFalse(moduleDecl.isOpen());
 		checkSourceRange(moduleDecl, content, content);
-		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		List<ModuleDirective> stmts = moduleDecl.moduleStatements();
 		assertTrue(stmts.size() > 0);
 
-		RequiresStatement req = (RequiresStatement) stmts.get(0);
+		RequiresDirective req = (RequiresDirective) stmts.get(0);
 		checkSourceRange(req, "requires second;", content);
 
-		ExportsStatement exp = (ExportsStatement) stmts.get(1);
+		ExportsDirective exp = (ExportsDirective) stmts.get(1);
 		checkSourceRange(exp, "exports pack11 to third, fourth;", content);
 		checkSourceRange(exp.getName(), "pack11", content);
 		List<Name> modules = exp.modules();
@@ -180,12 +180,12 @@ public class ASTConverter9Test extends ConverterTestSetup {
 		checkSourceRange(modules.get(0), "third", content);
 		checkSourceRange(modules.get(1), "fourth", content);
 		
-		UsesStatement u = (UsesStatement) stmts.get(2);
+		UsesDirective u = (UsesDirective) stmts.get(2);
 		checkSourceRange(u, "uses NewType;", content);
 		Type type = u.getType();
 		checkSourceRange(type, "NewType", content);
 		
-		ProvidesStatement p = (ProvidesStatement) stmts.get(3);
+		ProvidesDirective p = (ProvidesDirective) stmts.get(3);
 		checkSourceRange(p, "provides pack22.I22 with pack11.packinternal.Z11;", content);
 		type = p.getType();
 		checkSourceRange(type, "pack22.I22", content);
@@ -217,17 +217,17 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			ModuleDeclaration moduleDecl = unit.getModule();
 			assertFalse(moduleDecl.isOpen());
 			checkSourceRange(moduleDecl, content, content);
-			List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+			List<ModuleDirective> stmts = moduleDecl.moduleStatements();
 			assertTrue(stmts.size() > 0);
 
 			QualifiedName qName;
-			RequiresStatement req = (RequiresStatement) stmts.get(0);
+			RequiresDirective req = (RequiresDirective) stmts.get(0);
 			qName = (QualifiedName) req.getName();
 			checkSourceRange(qName, "second.third", content);
 			checkSourceRange(qName.getName(), "third", content);
 			checkSourceRange(qName.getQualifier(), "second", content);
 
-			ExportsStatement exp = (ExportsStatement) stmts.get(1);
+			ExportsDirective exp = (ExportsDirective) stmts.get(1);
 			checkSourceRange(exp, "exports pack1.X11 to org.eclipse.jdt;", content);
 			qName = (QualifiedName) exp.getName();
 			checkSourceRange(qName, "pack1.X11", content);
@@ -301,27 +301,27 @@ public class ASTConverter9Test extends ConverterTestSetup {
 		
 		assertTrue(moduleDecl.isOpen());
 		checkSourceRange(moduleDecl, content, content);
-		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		List<ModuleDirective> stmts = moduleDecl.moduleStatements();
 		assertTrue(stmts.size() > 0);
 		
 		int count = 0;
-		RequiresStatement req = (RequiresStatement) stmts.get(count++);
+		RequiresDirective req = (RequiresDirective) stmts.get(count++);
 		checkSourceRange(req, "requires one;", content);
 
-		req = (RequiresStatement) stmts.get(count++);
+		req = (RequiresDirective) stmts.get(count++);
 		checkSourceRange(req, "requires static two;", content);
 		checkSourceRange((ASTNode) req.modifiers().get(0), "static", content);
 
-		req = (RequiresStatement) stmts.get(count++);
+		req = (RequiresDirective) stmts.get(count++);
 		checkSourceRange(req, "requires transitive three;", content);
 		checkSourceRange((ASTNode) req.modifiers().get(0), "transitive", content);
 
-		req = (RequiresStatement) stmts.get(count++);
+		req = (RequiresDirective) stmts.get(count++);
 		checkSourceRange(req, "requires static transitive four;", content);
 		checkSourceRange((ASTNode) req.modifiers().get(0), "static", content);
 		checkSourceRange((ASTNode) req.modifiers().get(1), "transitive", content);
 
-		req = (RequiresStatement) stmts.get(count++);
+		req = (RequiresDirective) stmts.get(count++);
 		checkSourceRange(req, "requires transitive static five;", content);
 		checkSourceRange((ASTNode) req.modifiers().get(0), "transitive", content);
 		checkSourceRange((ASTNode) req.modifiers().get(1), "static", content);
@@ -504,7 +504,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			ModuleDeclaration moduleDecl1 = ((CompilationUnit) unit1).getModule();
 			checkSourceRange(moduleDecl1, fileContent, fileContent);
 
-			RequiresStatement req = (RequiresStatement) moduleDecl1.moduleStatements().get(0);
+			RequiresDirective req = (RequiresDirective) moduleDecl1.moduleStatements().get(0);
 			Name reqModule = req.getName();
 			ModuleBinding moduleBinding = (ModuleBinding) reqModule.resolveBinding();
 			assertTrue("Module Binding null", moduleBinding != null);
@@ -565,7 +565,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			assertTrue("Module Binding null", moduleBinding != null);
 			assertTrue("Module not open", moduleBinding.isOpen());
 
-			RequiresStatement req = (RequiresStatement) moduleDecl1.moduleStatements().get(0);
+			RequiresDirective req = (RequiresDirective) moduleDecl1.moduleStatements().get(0);
 			name = req.getName();
 			moduleBinding = (ModuleBinding) name.resolveBinding();
 			assertTrue("Module Binding null", moduleBinding != null);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index ae2afc7..bcdc5ca 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -8862,11 +8862,11 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			ASTNode.SUPER_METHOD_REFERENCE,
 			ASTNode.TYPE_METHOD_REFERENCE,
 			ASTNode.MODULE_DECLARATION,
-			ASTNode.EXPORTS_STATEMENT,
-			ASTNode.REQUIRES_STATEMENT,
-			ASTNode.USES_STATEMENT,
-			ASTNode.PROVIDES_STATEMENT,
-			ASTNode.OPENS_STATEMENT,
+			ASTNode.EXPORTS_DIRECTIVE,
+			ASTNode.REQUIRES_DIRECTIVE,
+			ASTNode.USES_DIRECTIVE,
+			ASTNode.PROVIDES_DIRECTIVE,
+			ASTNode.OPENS_DIRECTIVE,
 			ASTNode.MODULE_MODIFIER,
 
 		};
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
index 838b6dd..65736a5 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
@@ -253,7 +253,7 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 					buffer.append("ENUM_DECLARATION");break;
 				case ASTNode.EXPRESSION_STATEMENT :
 					buffer.append("EXPRESSION_STATEMENT");break;
-				case ASTNode.EXPORTS_STATEMENT :
+				case ASTNode.EXPORTS_DIRECTIVE :
 					buffer.append("EXPORTS_STATEMENT");break;
 				case ASTNode.FIELD_ACCESS :
 					buffer.append("FIELD_ACCESS");break;
@@ -301,7 +301,7 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 					buffer.append("NULL_LITERAL");break;
 				case ASTNode.NUMBER_LITERAL :
 					buffer.append("NUMBER_LITERAL");break;
-				case ASTNode.OPENS_STATEMENT :
+				case ASTNode.OPENS_DIRECTIVE :
 					buffer.append("OPENS_STATEMENT");break;
 				case ASTNode.PACKAGE_DECLARATION :
 					buffer.append("PACKAGE_DECLARATION");break;
@@ -315,13 +315,13 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 					buffer.append("PREFIX_EXPRESSION");break;
 				case ASTNode.PRIMITIVE_TYPE :
 					buffer.append("PRIMITIVE_TYPE");break;
-				case ASTNode.PROVIDES_STATEMENT :
+				case ASTNode.PROVIDES_DIRECTIVE :
 					buffer.append("PROVIDES_STATEMENT");break;
 				case ASTNode.QUALIFIED_NAME :
 					buffer.append("QUALIFIED_NAME");break;
 				case ASTNode.QUALIFIED_TYPE :
 					buffer.append("QUALIFIED_TYPE");break;
-				case ASTNode.REQUIRES_STATEMENT :
+				case ASTNode.REQUIRES_DIRECTIVE :
 					buffer.append("REQUIRES_STATEMENT");break;
 				case ASTNode.RETURN_STATEMENT :
 					buffer.append("RETURN_STATEMENT");break;
@@ -365,7 +365,7 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 					buffer.append("TYPE_LITERAL");break;
 				case ASTNode.TYPE_PARAMETER :
 					buffer.append("TYPE_PARAMETER");break;
-				case ASTNode.USES_STATEMENT :
+				case ASTNode.USES_DIRECTIVE :
 					buffer.append("USES_STATEMENT");break;
 				case ASTNode.VARIABLE_DECLARATION_EXPRESSION :
 					buffer.append("VARIABLE_DECLARATION_EXPRESSION");break;
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
index 753488a..5f5cf25 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
@@ -68,35 +68,35 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 
 			ModuleDeclaration moduleDecl = astRoot.getModule();
 			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
-			List<ModuleStatement> moduleStatements = moduleDecl.moduleStatements();
+			List<ModuleDirective> moduleStatements = moduleDecl.moduleStatements();
 			int index = 0;
 			{
-				RequiresStatement req = (RequiresStatement) moduleStatements.get(index++); // replace the module in first required
+				RequiresDirective req = (RequiresDirective) moduleStatements.get(index++); // replace the module in first required
 				Name newName = ast.newSimpleName("newSecond");
 				rewrite.replace(req.getName(), newName, null);
 				listRewrite.remove(moduleStatements.get(index++), null); // remove the second required
 
-				RequiresStatement newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				listRewrite.insertAfter(newNode, req, null);
 			}
 			{
 				// exports pack11 to third, fourth; -> exports newpack11 to third;
-				ExportsStatement exp = (ExportsStatement) moduleStatements.get(index++);
+				ExportsDirective exp = (ExportsDirective) moduleStatements.get(index++);
 				Name newName = ast.newSimpleName("newpack11");
 				rewrite.replace(exp.getName(), newName, null);
-				ListRewrite expListRewrite = rewrite.getListRewrite(exp, ExportsStatement.MODULES_PROPERTY);
+				ListRewrite expListRewrite = rewrite.getListRewrite(exp, ExportsDirective.MODULES_PROPERTY);
 				expListRewrite.remove((ASTNode) exp.modules().get(1), null); 
 
 				// exports pack12 to fifth -> exports pack12 to fifth, sixth
-				exp = (ExportsStatement) moduleStatements.get(index++);
+				exp = (ExportsDirective) moduleStatements.get(index++);
 				newName = ast.newSimpleName("sixth");
-				expListRewrite = rewrite.getListRewrite(exp, ExportsStatement.MODULES_PROPERTY);
+				expListRewrite = rewrite.getListRewrite(exp, ExportsDirective.MODULES_PROPERTY);
 				expListRewrite.insertLast(newName, null);
 
 				// exports pack12 to remove.mod1 -> exports pack12
-				exp = (ExportsStatement) moduleStatements.get(index++);
-				expListRewrite = rewrite.getListRewrite(exp, ExportsStatement.MODULES_PROPERTY);
+				exp = (ExportsDirective) moduleStatements.get(index++);
+				expListRewrite = rewrite.getListRewrite(exp, ExportsDirective.MODULES_PROPERTY);
 				expListRewrite.remove((ASTNode) exp.modules().get(0), null);
 
 				// exports pack12 to never.to.be.module - remove the export
@@ -111,7 +111,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			}
 			{
 				// uses MyType -> uses MyNewType;
-				UsesStatement usesStatement = (UsesStatement) moduleStatements.get(index++);
+				UsesDirective usesStatement = (UsesDirective) moduleStatements.get(index++);
 				Name newName = ast.newSimpleName("MyNewType");
 				SimpleType type = ast.newSimpleType(newName);
 				rewrite.replace(usesStatement.getType(), type, null);
@@ -128,21 +128,21 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			}
 			{
 				// provides pack22.I22 with pack11.packinternal.Z11 ->  provides pack22.INew22 with pack11.packinternal.NewZ11, pack11.Y11
-				ProvidesStatement providesStatement = (ProvidesStatement) moduleStatements.get(index++);
+				ProvidesDirective providesStatement = (ProvidesDirective) moduleStatements.get(index++);
 				Name newName = ast.newName("pack22.INew22");
 				SimpleType type = ast.newSimpleType(newName);
 				rewrite.replace(providesStatement.getType(), type, null);
 				newName = ast.newName("pack11.packinternal.NewZ11");
 				type = ast.newSimpleType(newName);
-				ListRewrite pListRewrite = rewrite.getListRewrite(providesStatement, ProvidesStatement.IMPLEMENTATIONS_PROPERTY);
+				ListRewrite pListRewrite = rewrite.getListRewrite(providesStatement, ProvidesDirective.IMPLEMENTATIONS_PROPERTY);
 				pListRewrite.replace((ASTNode) providesStatement.implementations().get(0), type ,null);
 
 				newName = ast.newName("pack11.Y11");
 				type = ast.newSimpleType(newName);
 				pListRewrite.insertLast(type, null);
 				// provides pack23.I23 with pack11.Z23, pack12.ZZ23 -> provides pack23.I23 with pack12.ZZ23
-				providesStatement = (ProvidesStatement) moduleStatements.get(index++);
-				pListRewrite = rewrite.getListRewrite(providesStatement, ProvidesStatement.IMPLEMENTATIONS_PROPERTY);
+				providesStatement = (ProvidesDirective) moduleStatements.get(index++);
+				pListRewrite = rewrite.getListRewrite(providesStatement, ProvidesDirective.IMPLEMENTATIONS_PROPERTY);
 				pListRewrite.remove((ASTNode) providesStatement.implementations().get(0), null);
 			}
 			String preview= evaluateRewrite(cu, rewrite);
@@ -184,7 +184,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			ModuleDeclaration moduleDecl = astRoot.getModule();
 			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
 			{
-				RequiresStatement newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				listRewrite.insertLast(newNode, null);
 			}
@@ -220,25 +220,25 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			ModuleDeclaration moduleDecl = astRoot.getModule();
 			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
 			{
-				RequiresStatement reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(0);
+				RequiresDirective reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(0);
 				ASTNode newModifier = ast.newModuleModifier(ModuleModifierKeyword.STATIC_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(1);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).remove((ASTNode) reqNode.modifiers().get(0), null);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(1);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).remove((ASTNode) reqNode.modifiers().get(0), null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(2);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(2);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).replace((ASTNode) reqNode.modifiers().get(0), newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).replace((ASTNode) reqNode.modifiers().get(0), newModifier, null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(3);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(3);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertLast(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertLast(newModifier, null);
 
-				RequiresStatement newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(newNode, RequiresStatement.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
+				rewrite.getListRewrite(newNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 				listRewrite.insertLast(newNode, null);
 			}
 			String preview= evaluateRewrite(cu, rewrite);
@@ -327,31 +327,31 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
 			{
 				int count = 0;
-				RequiresStatement reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(count++);
+				RequiresDirective reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
 				ASTNode newModifier = ast.newModuleModifier(ModuleModifierKeyword.STATIC_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertLast(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertLast(newModifier, null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(count++);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).remove((ASTNode) reqNode.modifiers().get(0), null);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).remove((ASTNode) reqNode.modifiers().get(0), null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(count++);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).replace((ASTNode) reqNode.modifiers().get(0), newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).replace((ASTNode) reqNode.modifiers().get(0), newModifier, null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(count++);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertLast(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertLast(newModifier, null);
 
-				reqNode = (RequiresStatement) moduleDecl.moduleStatements().get(count++);
+				reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(reqNode, RequiresStatement.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
+				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 
-				RequiresStatement newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
-				rewrite.getListRewrite(newNode, RequiresStatement.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
+				rewrite.getListRewrite(newNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 				listRewrite.insertLast(newNode, null);
 			}
 			String preview= evaluateRewrite(cu, rewrite);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 8fd4d7d..0ead17d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1516,8 +1516,8 @@ public final class AST {
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public ExportsStatement newExportsStatement() {
-		ExportsStatement result = new ExportsStatement(this);
+	public ExportsDirective newExportsStatement() {
+		ExportsDirective result = new ExportsDirective(this);
 		return result;
 	}
 
@@ -2143,8 +2143,8 @@ public final class AST {
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public OpensStatement newOpensStatement() {
-		OpensStatement result = new OpensStatement(this);
+	public OpensDirective newOpensStatement() {
+		OpensDirective result = new OpensDirective(this);
 		return result;
 	}
 
@@ -2239,8 +2239,8 @@ public final class AST {
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public ProvidesStatement newProvidesStatement() {
-		ProvidesStatement result = new ProvidesStatement(this);
+	public ProvidesDirective newProvidesStatement() {
+		ProvidesDirective result = new ProvidesDirective(this);
 		return result;
 	}
 
@@ -2298,8 +2298,8 @@ public final class AST {
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public RequiresStatement newRequiresStatement() {
-		RequiresStatement result = new RequiresStatement(this);
+	public RequiresDirective newRequiresStatement() {
+		RequiresDirective result = new RequiresDirective(this);
 		return result;
 	}
 
@@ -2678,8 +2678,8 @@ public final class AST {
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public UsesStatement newUsesStatement() {
-		UsesStatement result = new UsesStatement(this);
+	public UsesDirective newUsesStatement() {
+		UsesDirective result = new UsesDirective(this);
 		return result;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 7a24d7e..e2b0858 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -3315,24 +3315,24 @@ class ASTConverter {
 		moduleDecl.setName(moduleName);
 		moduleDecl.setSourceRange(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd - moduleDeclaration.declarationSourceStart + 1);
 
-		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
-		TreeSet<ModuleStatement> tSet = new TreeSet<> (new Comparator() {
+		List<ModuleDirective> stmts = moduleDecl.moduleStatements();
+		TreeSet<ModuleDirective> tSet = new TreeSet<> (new Comparator() {
 			public int compare(Object o1, Object o2) {
-				int p1 = ((ModuleStatement) o1).getStartPosition();
-				int p2 = ((ModuleStatement) o2).getStartPosition();
+				int p1 = ((ModuleDirective) o1).getStartPosition();
+				int p2 = ((ModuleDirective) o2).getStartPosition();
 				return p1 < p2 ? -1 : p1 == p2 ? 0 : 1;
 			}
 		});
 		for (int i = 0; i < moduleDeclaration.exportsCount; ++i) {
-			tSet.add(getPackageVisibilityStatement(moduleDeclaration.exports[i], new ExportsStatement(this.ast)));
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.exports[i], new ExportsDirective(this.ast)));
 		}
 		for (int i = 0; i < moduleDeclaration.opensCount; ++i) {
-			tSet.add(getPackageVisibilityStatement(moduleDeclaration.opens[i], new OpensStatement(this.ast)));
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.opens[i], new OpensDirective(this.ast)));
 		}
 		for (int i = 0; i < moduleDeclaration.requiresCount; ++i) {
 			org.eclipse.jdt.internal.compiler.ast.RequiresStatement req = moduleDeclaration.requires[i];
 			ModuleReference moduleRef = req.module;
-			RequiresStatement stmt = new RequiresStatement(this.ast);
+			RequiresDirective stmt = new RequiresDirective(this.ast);
 			Name name = getName(moduleRef, CharOperation.splitOn('.', moduleRef.moduleName), moduleRef.sourcePositions);
 			stmt.setName(name);
 			if (this.resolveBindings) {
@@ -3345,7 +3345,7 @@ class ASTConverter {
 		}
 		for (int i = 0; i < moduleDeclaration.usesCount; ++i) {
 			org.eclipse.jdt.internal.compiler.ast.UsesStatement usesStatement = moduleDeclaration.uses[i];
-			UsesStatement stmt = new UsesStatement(this.ast);
+			UsesDirective stmt = new UsesDirective(this.ast);
 			TypeReference usesRef = usesStatement.serviceInterface;
 			stmt.setType(convertType(usesRef));
 			stmt.setSourceRange(usesStatement.declarationSourceStart, usesStatement.declarationSourceEnd - usesStatement.declarationSourceStart + 1);			
@@ -3353,7 +3353,7 @@ class ASTConverter {
 		}
 		for (int i = 0; i < moduleDeclaration.servicesCount; ++i) {
 			org.eclipse.jdt.internal.compiler.ast.ProvidesStatement pStmt = moduleDeclaration.services[i];
-			ProvidesStatement stmt = new ProvidesStatement(this.ast);
+			ProvidesDirective stmt = new ProvidesDirective(this.ast);
 			stmt.setType(convertType(pStmt.serviceInterface));
 			TypeReference[] impls = pStmt.implementations;
 			for (TypeReference impl : impls) {
@@ -3372,7 +3372,7 @@ class ASTConverter {
 		return moduleDecl;
 	}
 
-	private void setModuleModifiers(org.eclipse.jdt.internal.compiler.ast.RequiresStatement req,	RequiresStatement stmt) {
+	private void setModuleModifiers(org.eclipse.jdt.internal.compiler.ast.RequiresStatement req,	RequiresDirective stmt) {
 		boolean fakeInModule = this.scanner.fakeInModule;
 		this.scanner.fakeInModule = true;
 		this.scanner.resetTo(req.declarationSourceStart, req.sourceEnd);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 58f4582..ec48794 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -894,11 +894,11 @@ public class ASTMatcher {
 	 *   different node type or is <code>null</code>
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean match(ExportsStatement node, Object other) {
-		if (!(other instanceof ExportsStatement)) {
+	public boolean match(ExportsDirective node, Object other) {
+		if (!(other instanceof ExportsDirective)) {
 			return false;
 		}
-		ExportsStatement o = (ExportsStatement) other;
+		ExportsDirective o = (ExportsDirective) other;
 		return (
 			safeSubtreeMatch(node.getName(), o.getName())
 				&& safeSubtreeListMatch(node.modules(), o.modules()));
@@ -1727,11 +1727,11 @@ public class ASTMatcher {
 	 *   different node type or is <code>null</code>
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean match(OpensStatement node, Object other) {
-		if (!(other instanceof OpensStatement)) {
+	public boolean match(OpensDirective node, Object other) {
+		if (!(other instanceof OpensDirective)) {
 			return false;
 		}
-		OpensStatement o = (OpensStatement) other;
+		OpensDirective o = (OpensDirective) other;
 		return (
 			safeSubtreeMatch(node.getName(), o.getName())
 				&& safeSubtreeListMatch(node.modules(), o.modules()));
@@ -1901,11 +1901,11 @@ public class ASTMatcher {
 	 * @since 3.13 BETA_JAVA9
 
 	 */
-	public boolean match(ProvidesStatement node, Object other) {
-		if (!(other instanceof ProvidesStatement)) {
+	public boolean match(ProvidesDirective node, Object other) {
+		if (!(other instanceof ProvidesDirective)) {
 			return false;
 		}
-		ProvidesStatement o = (ProvidesStatement) other;
+		ProvidesDirective o = (ProvidesDirective) other;
 		return (
 				safeSubtreeMatch(node.getType(), o.getType())
 				&& safeSubtreeListMatch(node.implementations(), o.implementations()));
@@ -1976,11 +1976,11 @@ public class ASTMatcher {
 	 *
 	 *   @since 3.13 BETA_JAVA9
 	 */
-	public boolean match(RequiresStatement node, Object other) {
-		if (!(other instanceof RequiresStatement)) {
+	public boolean match(RequiresDirective node, Object other) {
+		if (!(other instanceof RequiresDirective)) {
 			return false;
 		}
-		RequiresStatement o = (RequiresStatement) other;
+		RequiresDirective o = (RequiresDirective) other;
 		return safeSubtreeListMatch(node.modifiers(), o.modifiers())
 				&& safeSubtreeMatch(node.getName(), o.getName());
 	}
@@ -2623,11 +2623,11 @@ public class ASTMatcher {
 	 *   different node type or is <code>null</code>
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean match(UsesStatement node, Object other) {
+	public boolean match(UsesDirective node, Object other) {
 		if (!(other instanceof UnionType)) {
 			return false;
 		}
-		UsesStatement o = (UsesStatement) other;
+		UsesDirective o = (UsesDirective) other;
 		return safeSubtreeMatch(node.getType(), o.getType());
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index a21f0b0..3efeb95 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -910,43 +910,43 @@ public abstract class ASTNode {
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>ExportsStatement</code>.
-	 * @see ExportsStatement
+	 * <code>ExportsdIRECTIVE</code>.
+	 * @see ExportsDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int EXPORTS_STATEMENT = 94;
+	public static final int EXPORTS_DIRECTIVE = 94;
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>RequiresStatement</code>.
-	 * @see RequiresStatement
+	 * <code>RequiresDirective</code>.
+	 * @see RequiresDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int REQUIRES_STATEMENT = 95;
+	public static final int REQUIRES_DIRECTIVE = 95;
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>UsesStatement</code>.
-	 * @see UsesStatement
+	 * <code>UsesDirective</code>.
+	 * @see UsesDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int USES_STATEMENT = 96;
+	public static final int USES_DIRECTIVE = 96;
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>ProvidesStatement</code>.
-	 * @see ProvidesStatement
+	 * <code>ProvidesDirective</code>.
+	 * @see ProvidesDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int PROVIDES_STATEMENT = 97;
+	public static final int PROVIDES_DIRECTIVE = 97;
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>OpensStatement</code>.
-	 * @see OpensStatement
+	 * <code>OpensDirective</code>.
+	 * @see OpensDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int OPENS_STATEMENT = 98;
+	public static final int OPENS_DIRECTIVE = 98;
 
 	/**
 	 * Node type constant indicating a node of type
@@ -1024,8 +1024,8 @@ public abstract class ASTNode {
 				return EnumConstantDeclaration.class;
 			case ENUM_DECLARATION :
 				return EnumDeclaration.class;
-			case EXPORTS_STATEMENT :
-				return ExportsStatement.class;
+			case EXPORTS_DIRECTIVE :
+				return ExportsDirective.class;
 			case EXPRESSION_METHOD_REFERENCE :
 				return ExpressionMethodReference.class;
 			case EXPRESSION_STATEMENT :
@@ -1084,8 +1084,8 @@ public abstract class ASTNode {
 				return NullLiteral.class;
 			case NUMBER_LITERAL :
 				return NumberLiteral.class;
-			case OPENS_STATEMENT :
-				return OpensStatement.class;
+			case OPENS_DIRECTIVE :
+				return OpensDirective.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
 			case PARAMETERIZED_TYPE :
@@ -1098,14 +1098,14 @@ public abstract class ASTNode {
 				return PrefixExpression.class;
 			case PRIMITIVE_TYPE :
 				return PrimitiveType.class;
-			case PROVIDES_STATEMENT :
-				return ProvidesStatement.class;
+			case PROVIDES_DIRECTIVE :
+				return ProvidesDirective.class;
 			case QUALIFIED_NAME :
 				return QualifiedName.class;
 			case QUALIFIED_TYPE :
 				return QualifiedType.class;
-			case REQUIRES_STATEMENT :
-				return RequiresStatement.class;
+			case REQUIRES_DIRECTIVE :
+				return RequiresDirective.class;
 			case RETURN_STATEMENT :
 				return ReturnStatement.class;
 			case SIMPLE_NAME :
@@ -1154,8 +1154,8 @@ public abstract class ASTNode {
 				return TypeParameter.class;
 			case UNION_TYPE :
 				return UnionType.class;
-			case USES_STATEMENT :
-				return UsesStatement.class;
+			case USES_DIRECTIVE :
+				return UsesDirective.class;
 			case VARIABLE_DECLARATION_EXPRESSION :
 				return VariableDeclarationExpression.class;
 			case VARIABLE_DECLARATION_FRAGMENT :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
index 96270f6..94fd243 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
@@ -56,7 +56,7 @@ class ASTRecoveryPropagator extends DefaultASTVisitor {
 		this.endingTokens.put(MethodDeclaration.class, new int[]{NOTHING, TerminalTokens.TokenNameSEMICOLON});
 		this.endingTokens.put(MethodInvocation.class, new int[]{TerminalTokens.TokenNameRPAREN});
 		this.endingTokens.put(ModuleDeclaration.class, new int[]{TerminalTokens.TokenNameRBRACE});
-		this.endingTokens.put(ModuleStatement.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
+		this.endingTokens.put(ModuleDirective.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
 		this.endingTokens.put(NullLiteral.class, new int[]{TerminalTokens.TokenNamenull});
 		this.endingTokens.put(NumberLiteral.class, new int[]{TerminalTokens.TokenNameIntegerLiteral, TerminalTokens.TokenNameLongLiteral, TerminalTokens.TokenNameFloatingPointLiteral, TerminalTokens.TokenNameDoubleLiteral});
 		this.endingTokens.put(PackageDeclaration.class, new int[]{TerminalTokens.TokenNameSEMICOLON});
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 67f9255..b89f477 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -661,7 +661,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		return true;
 	}
 
@@ -1175,7 +1175,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean visit(OpensStatement node) {
+	public boolean visit(OpensDirective node) {
 		return true;
 	}
 
@@ -1273,7 +1273,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		return true;
 	}
 
@@ -1339,7 +1339,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean visit(RequiresStatement node) {
+	public boolean visit(RequiresDirective node) {
 		return true;
 	}
 
@@ -1752,7 +1752,7 @@ public abstract class ASTVisitor {
 	 * be skipped
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public boolean visit(UsesStatement node) {
+	public boolean visit(UsesDirective node) {
 		return true;
 	}
 
@@ -2182,7 +2182,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public void endVisit(ExportsStatement node) {
+	public void endVisit(ExportsDirective node) {
 		// default implementation: do nothing
 	}
 
@@ -2562,7 +2562,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public void endVisit(OpensStatement node) {
+	public void endVisit(OpensDirective node) {
 		// default implementation: do nothing
 	}
 
@@ -2648,7 +2648,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public void endVisit(ProvidesStatement node) {
+	public void endVisit(ProvidesDirective node) {
 		// default implementation: do nothing
 	}
 
@@ -2686,7 +2686,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public void endVisit(RequiresStatement node) {
+	public void endVisit(RequiresDirective node) {
 		// default implementation: do nothing
 	}
 
@@ -2994,7 +2994,7 @@ public abstract class ASTVisitor {
 	 * @param node the node to visit
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public void endVisit(UsesStatement node) {
+	public void endVisit(UsesDirective node) {
 		// default implementation: do nothing
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index ac3f05e..fd50abd 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -190,7 +190,7 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(ModuleDeclaration node) {
 		endVisitNode(node);
 	}
-	public void endVisit(ModuleStatement node) {
+	public void endVisit(ModuleDirective node) {
 		endVisitNode(node);
 	}
 	public void endVisit(NameQualifiedType node) {
@@ -481,7 +481,7 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(ModuleDeclaration node) {
 		return visitNode(node);
 	}
-	public boolean visit(ModuleStatement node) {
+	public boolean visit(ModuleDirective node) {
 		return visitNode(node);
 	}
 	public boolean visit(MethodRefParameter node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
new file mode 100644
index 0000000..d89a102
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Exports directive AST node type.
+ * <pre>
+ * ExportsDirective:
+ *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * 
+ * @noextend This class is not intended to be subclassed by clients.
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class ExportsDirective extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+			internalNamePropertyFactory(ExportsDirective.class);
+
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(ExportsDirective.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ExportsDirective.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an export directive owned by the
+	 * given AST. The export directive initially is a regular (non-targetted)
+	 * single package export for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ExportsDirective(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return EXPORTS_DIRECTIVE;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new ExportsDirective(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
deleted file mode 100644
index 9af5e11..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Exports statement AST node type.
- * <pre>
- * ExportsStatement:
- *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * 
- * @noextend This class is not intended to be subclassed by clients.
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes"})
-public class ExportsStatement extends ModulePackageAccess {
-
-	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-			internalNamePropertyFactory(ExportsStatement.class);
-
-	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
-	 */
-	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
-			internalModulesPropertyFactory(ExportsStatement.class);
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(ExportsStatement.class, properyList);
-		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULES_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * Creates a new AST node for an export statement owned by the
-	 * given AST. The export statement initially is a regular (non-targetted)
-	 * single package export for an unspecified, but legal, Java package name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	ExportsStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
-	}
-
-	@Override
-	final ChildListPropertyDescriptor internalModulesProperty() {
-		return MODULES_PROPERTY;
-	}
-
-	@Override
-	final int getNodeType0() {
-		return EXPORTS_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		return cloneHelper(target, new ExportsStatement(target));
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		acceptVisitChildren(visitChildren, visitor);
-		visitor.endVisit(this);
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
index 20f26c9..dd5fa4f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
@@ -62,10 +62,10 @@ public class ModuleDeclaration extends ASTNode {
 		new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleStatement}).
+	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleDirective}).
 	 */
 	public static final ChildListPropertyDescriptor MODULE_STATEMENTS_PROPERTY =
-		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleStatement.class, NO_CYCLE_RISK); //$NON-NLS-1$
+		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleDirective.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -124,7 +124,7 @@ public class ModuleDeclaration extends ASTNode {
 	private Name name = null;
 
 	/**
-	 * The list of statements (element type: {@link ModuleStatement}).
+	 * The list of statements (element type: {@link ModuleDirective}).
 	 * Defaults to an empty list.
 	 */
 	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_STATEMENTS_PROPERTY);
@@ -333,7 +333,7 @@ public class ModuleDeclaration extends ASTNode {
 	 * exception.
 	 *
 	 * @return the live list of statements in this module declaration
-	 *    (element type: {@link ModuleStatement})
+	 *    (element type: {@link ModuleDirective})
 	 */
 	public List moduleStatements() {
 		return this.moduleStatements;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
new file mode 100644
index 0000000..d81197e
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+/**
+ * Abstract base class of AST nodes that represent module directives.
+ * There are many kinds of module directives.
+ *
+ * <pre>
+ * ModuleStatement: [ {@link ExportsDirective} |
+ *    {@link OpensDirective} |
+ *    {@link RequiresDirective} |
+ *    {@link UsesDirective} |
+ *    {@link ProvidesDirective} ]
+ * </pre>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @since 3.13 BETA_JAVA9
+ */
+public abstract class ModuleDirective extends ASTNode {
+
+	ModuleDirective(AST ast) {
+		super(ast);
+		unsupportedBelow9();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
index 4dae45a..2967715 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
@@ -19,15 +19,15 @@ import java.util.List;
  * Abstract base class of AST nodes that represent exports and opens statements.
  *
  * <pre>
- * ModuleStatement: [ {@link ExportsStatement} |
- *    {@link OpensStatement} ]
+ * ModuleStatement: [ {@link ExportsDirective} |
+ *    {@link OpensDirective} ]
  * </pre>
  *
  * @noextend This class is not intended to be subclassed by clients.
  * @since 3.13 BETA_JAVA9
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
-public abstract class ModulePackageAccess extends ModuleStatement {
+public abstract class ModulePackageAccess extends ModuleDirective {
 
 	/**
 	 * The package name; lazily initialized; defaults to a unspecified,
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
deleted file mode 100644
index b245f7b..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2017 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-/**
- * Abstract base class of AST nodes that represent module statements.
- * There are many kinds of module statements.
- *
- * <pre>
- * ModuleStatement: [ {@link ExportsStatement} |
- *    {@link OpensStatement} |
- *    {@link RequiresStatement} |
- *    {@link UsesStatement} |
- *    {@link ProvidesStatement} ]
- * </pre>
- *
- * @noextend This class is not intended to be subclassed by clients.
- * @since 3.13 BETA_JAVA9
- */
-public abstract class ModuleStatement extends ASTNode {
-
-	ModuleStatement(AST ast) {
-		super(ast);
-		unsupportedBelow9();
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
new file mode 100644
index 0000000..e0ec761
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
@@ -0,0 +1,127 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * opens directive AST node type.
+ * <pre>
+ * OpensDirective:
+ *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * 
+ * @noextend This class is not intended to be subclassed by clients.
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class OpensDirective extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		internalNamePropertyFactory(OpensDirective.class);
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(OpensDirective.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(OpensDirective.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an opens directive owned by the
+	 * given AST. The open directive initially is a regular (non-targetted)
+	 * single package open for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	OpensDirective(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return OPENS_DIRECTIVE;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new OpensDirective(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
deleted file mode 100644
index 06d48aa..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * opens statement AST node type.
- * <pre>
- * OpensStatement:
- *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * 
- * @noextend This class is not intended to be subclassed by clients.
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes"})
-public class OpensStatement extends ModulePackageAccess {
-
-	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		internalNamePropertyFactory(OpensStatement.class);
-	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
-	 */
-	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
-			internalModulesPropertyFactory(OpensStatement.class);
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(OpensStatement.class, properyList);
-		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULES_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * Creates a new AST node for an opens statement owned by the
-	 * given AST. The open statement initially is a regular (non-targetted)
-	 * single package open for an unspecified, but legal, Java package name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	OpensStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
-	}
-
-	@Override
-	final ChildListPropertyDescriptor internalModulesProperty() {
-		return MODULES_PROPERTY;
-	}
-
-	@Override
-	final int getNodeType0() {
-		return OPENS_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		return cloneHelper(target, new OpensStatement(target));
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		acceptVisitChildren(visitChildren, visitor);
-		visitor.endVisit(this);
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
new file mode 100644
index 0000000..75d1500
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
@@ -0,0 +1,226 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides directive AST node type.
+ * <pre>
+ * ProvidesDirective:
+ *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * 
+ * @noextend This class is not intended to be subclassed by clients.
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class ProvidesDirective extends ModuleDirective {
+
+	/**
+	 * The "interface type" structural property of this node type (child type: {@link Type}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(ProvidesDirective.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "implementation type" structural property of this node type (element type: {@link Type}).
+	 */
+	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
+			new ChildListPropertyDescriptor(ProvidesDirective.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ProvidesDirective.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		addProperty(IMPLEMENTATIONS_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The interface name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * The implementation names
+	 * (element type: {@link Name}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList implementations =
+		new ASTNode.NodeList(IMPLEMENTATIONS_PROPERTY);
+
+	/**
+	 * Creates a new AST node for an provides directive owned by the
+	 * given AST. The provides directive initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ProvidesDirective(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == IMPLEMENTATIONS_PROPERTY) {
+			return implementations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return PROVIDES_DIRECTIVE;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		ProvidesDirective result = new ProvidesDirective(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		result.implementations().addAll(ASTNode.copySubtrees(target, implementations()));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+			acceptChildren(visitor, this.implementations);
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type name in this statement
+	 *
+	 * @return the type name
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type =this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the target module name in exports declaration to the given name.
+	 *
+	 * @param type the new target module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of implementations for the interface in this provides statement.
+	 *
+	 * @return the live list of implementations for the interface
+	 *    (element type: {@link Name})
+	 */
+	public List implementations() {
+		return this.implementations;
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize())
+			+ this.implementations.listSize();
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
deleted file mode 100644
index acc2a90..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Provides statement AST node type.
- * <pre>
- * ProvidesStatement:
- *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * 
- * @noextend This class is not intended to be subclassed by clients.
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes", "unchecked"})
-public class ProvidesStatement extends ModuleStatement {
-
-	/**
-	 * The "interface type" structural property of this node type (child type: {@link Type}).
-	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(ProvidesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "implementation type" structural property of this node type (element type: {@link Type}).
-	 */
-	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
-			new ChildListPropertyDescriptor(ProvidesStatement.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(ProvidesStatement.class, properyList);
-		addProperty(TYPE_PROPERTY, properyList);
-		addProperty(IMPLEMENTATIONS_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The interface name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Type type = null;
-
-	/**
-	 * The implementation names
-	 * (element type: {@link Name}).
-	 * Defaults to an empty list.
-	 */
-	private ASTNode.NodeList implementations =
-		new ASTNode.NodeList(IMPLEMENTATIONS_PROPERTY);
-
-	/**
-	 * Creates a new AST node for an provides statement owned by the
-	 * given AST. The provides statement initially is
-	 * for an unspecified, but legal, Java type name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	ProvidesStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == IMPLEMENTATIONS_PROPERTY) {
-			return implementations();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return PROVIDES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		ProvidesStatement result = new ProvidesStatement(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setType((Type) getType().clone(target));
-		result.implementations().addAll(ASTNode.copySubtrees(target, implementations()));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChild(visitor, getType());
-			acceptChildren(visitor, this.implementations);
-		}
-		visitor.endVisit(this);
-	}
-
-
-	/**
-	 * Returns the type name in this statement
-	 *
-	 * @return the type name
-	 */
-	public Type getType()  {
-		if (this.type == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.type == null) {
-					preLazyInit();
-					this.type =this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.type, TYPE_PROPERTY);
-				}
-			}
-		}
-		return this.type;
-	}
-
-	/**
-	 * Sets the target module name in exports declaration to the given name.
-	 *
-	 * @param type the new target module name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setType(Type type) {
-		if (type == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.type;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.type = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
-	}
-
-	/**
-	 * Returns the live ordered list of implementations for the interface in this provides statement.
-	 *
-	 * @return the live list of implementations for the interface
-	 *    (element type: {@link Name})
-	 */
-	public List implementations() {
-		return this.implementations;
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.type == null ? 0 : getType().treeSize())
-			+ this.implementations.listSize();
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
new file mode 100644
index 0000000..40ebe05
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
@@ -0,0 +1,251 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Requires directive AST node type.
+ * <pre>
+ * RequiresDirective:
+ *     <b>requires</b> { ModuleModifier } Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class RequiresDirective extends ModuleDirective {
+
+	/**
+	 * The "modifiers" structural property of this node type (element type: {@link ModuleModifier}).
+	 */
+	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
+		new ChildListPropertyDescriptor(RequiresDirective.class, "modifiers", ModuleModifier.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The module structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(RequiresDirective.class, "name", Name.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List propertyList = new ArrayList(3);
+		createPropertyList(RequiresDirective.class, propertyList);
+		addProperty(MODIFIERS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The extended modifiers (element type: {@link ModuleModifier}).
+	 * defaults to an empty list
+	 */
+	private ASTNode.NodeList modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
+
+	/**
+	 * The referenced module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Name name = null;
+
+	/**
+	 * Creates a new AST node for an requires directive owned by the
+	 * given AST. The requires directive initially is a regular (no modifiers)
+	 * requires for an unspecified, but legal, Java module name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	RequiresDirective(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == MODIFIERS_PROPERTY) {
+			return modifiers();
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return REQUIRES_DIRECTIVE;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		RequiresDirective result = new RequiresDirective(target);
+		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+		result.setName((Name) getName().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChildren(visitor, this.modifiers);
+			acceptChild(visitor, getName());
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * Returns the live ordered list of modifiers
+	 * of this declaration.
+	 * <p>
+	 * Note that the not all modifiers are legal.
+	 * </p>
+	 *
+	 * @return the live list of module modifiers
+	 *    (element type: {@link ModuleModifier})
+	 */
+	public List modifiers() {
+		return this.modifiers;
+	}
+
+	/**
+	 * Returns the module modifiers explicitly specified on this declaration.
+	 * <p>
+	 * this method is a convenience method that
+	 * computes these flags from <code>modifiers()</code>.
+	 * </p>
+	 *
+	 * @return the bit-wise or of <code>ModuleModifier</code> constants
+	 * @see ModuleModifier
+	 */
+	public int getModifiers() {
+		// do not cache - performance could be improved by caching computed flags
+		// but this would require tracking changes to this.modifiers
+		int computedModifierFlags = ModuleModifier.NONE;
+		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
+			Object x = it.next();
+			if (x instanceof ModuleModifier) {
+				computedModifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
+			}
+		}
+		return computedModifierFlags;
+	}
+
+	/**
+	 * Returns the module name referenced by this declaration.
+	 *
+	 * @return the module referenced
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the module name in requires directive to the given name.
+	 *
+	 * @param name the new module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
+			+ (this.name == null ? 0 : getName().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
deleted file mode 100644
index 8f9201d..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2017 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Requires statement AST node type.
- * <pre>
- * RequiresStatement:
- *     <b>requires</b> { ModuleModifier } Name <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes", "unchecked"})
-public class RequiresStatement extends ModuleStatement {
-
-	/**
-	 * The "modifiers" structural property of this node type (element type: {@link ModuleModifier}).
-	 */
-	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
-		new ChildListPropertyDescriptor(RequiresStatement.class, "modifiers", ModuleModifier.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The module structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(RequiresStatement.class, "name", Name.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List propertyList = new ArrayList(3);
-		createPropertyList(RequiresStatement.class, propertyList);
-		addProperty(MODIFIERS_PROPERTY, propertyList);
-		addProperty(NAME_PROPERTY, propertyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(propertyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The extended modifiers (element type: {@link ModuleModifier}).
-	 * defaults to an empty list
-	 */
-	private ASTNode.NodeList modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
-
-	/**
-	 * The referenced module name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Name name = null;
-
-	/**
-	 * Creates a new AST node for an requires statement owned by the
-	 * given AST. The requires statement initially is a regular (no modifiers)
-	 * requires for an unspecified, but legal, Java module name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	RequiresStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == NAME_PROPERTY) {
-			if (get) {
-				return getName();
-			} else {
-				setName((Name) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == MODIFIERS_PROPERTY) {
-			return modifiers();
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return REQUIRES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		RequiresStatement result = new RequiresStatement(target);
-		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
-		result.setName((Name) getName().clone(target));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChildren(visitor, this.modifiers);
-			acceptChild(visitor, getName());
-		}
-		visitor.endVisit(this);
-	}
-
-	/**
-	 * Returns the live ordered list of modifiers
-	 * of this declaration.
-	 * <p>
-	 * Note that the not all modifiers are legal.
-	 * </p>
-	 *
-	 * @return the live list of module modifiers
-	 *    (element type: {@link ModuleModifier})
-	 */
-	public List modifiers() {
-		return this.modifiers;
-	}
-
-	/**
-	 * Returns the module modifiers explicitly specified on this declaration.
-	 * <p>
-	 * this method is a convenience method that
-	 * computes these flags from <code>modifiers()</code>.
-	 * </p>
-	 *
-	 * @return the bit-wise or of <code>ModuleModifier</code> constants
-	 * @see ModuleModifier
-	 */
-	public int getModifiers() {
-		// do not cache - performance could be improved by caching computed flags
-		// but this would require tracking changes to this.modifiers
-		int computedModifierFlags = ModuleModifier.NONE;
-		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
-			Object x = it.next();
-			if (x instanceof ModuleModifier) {
-				computedModifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
-			}
-		}
-		return computedModifierFlags;
-	}
-
-	/**
-	 * Returns the module name referenced by this declaration.
-	 *
-	 * @return the module referenced
-	 */
-	public Name getName()  {
-		if (this.name == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.name == null) {
-					preLazyInit();
-					this.name =this.ast.newQualifiedName(
-							new SimpleName(this.ast), new SimpleName(this.ast));
-					postLazyInit(this.name, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.name;
-	}
-
-	/**
-	 * Sets the module name in requires statement to the given name.
-	 *
-	 * @param name the new module name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setName(Name name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.name;
-		preReplaceChild(oldChild, name, NAME_PROPERTY);
-		this.name = name;
-		postReplaceChild(oldChild, name, NAME_PROPERTY);
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
-			+ (this.name == null ? 0 : getName().treeSize());
-	}
-
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
new file mode 100644
index 0000000..9350554
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
@@ -0,0 +1,190 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Uses directive AST node type.
+ * <pre>
+ * UsesDirective:
+ *     <b>uses</b> Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * 
+ * @noextend This class is not intended to be subclassed by clients.
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings("rawtypes")
+public class UsesDirective extends ModuleDirective {
+
+	/**
+	 * The "type" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(UsesDirective.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(2);
+		createPropertyList(UsesDirective.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * Creates a new AST node for an uses directive owned by the
+	 * given AST. The uses directive initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	UsesDirective(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return USES_DIRECTIVE;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		UsesDirective result = new UsesDirective(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type in this directive
+	 *
+	 * @return the type
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type = this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the type in uses directive
+	 *
+	 * @param type the new type in uses
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 1 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
deleted file mode 100644
index 75b0bc4..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Uses statement AST node type.
- * <pre>
- * UsesStatement:
- *     <b>uses</b> Name <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * 
- * @noextend This class is not intended to be subclassed by clients.
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings("rawtypes")
-public class UsesStatement extends ModuleStatement {
-
-	/**
-	 * The "type" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(UsesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(2);
-		createPropertyList(UsesStatement.class, properyList);
-		addProperty(TYPE_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The module name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Type type = null;
-
-	/**
-	 * Creates a new AST node for an uses statement owned by the
-	 * given AST. The uses statement initially is
-	 * for an unspecified, but legal, Java type name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	UsesStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return USES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		UsesStatement result = new UsesStatement(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setType((Type) getType().clone(target));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChild(visitor, getType());
-		}
-		visitor.endVisit(this);
-	}
-
-
-	/**
-	 * Returns the type in this statement
-	 *
-	 * @return the type
-	 */
-	public Type getType()  {
-		if (this.type == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.type == null) {
-					preLazyInit();
-					this.type = this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.type, TYPE_PROPERTY);
-				}
-			}
-		}
-		return this.type;
-	}
-
-	/**
-	 * Sets the type in uses statement
-	 *
-	 * @param type the new type in uses
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setType(Type type) {
-		if (type == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.type;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.type = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 1 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.type == null ? 0 : getType().treeSize());
-	}
-
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 7e1cfe8..c366ffe 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -762,7 +762,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		return visit(node, "exports"); //$NON-NLS-1$
 	}
 
@@ -1242,7 +1242,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 		node.getName().accept(this);
 		this.buffer.append(" {\n"); //$NON-NLS-1$
 		this.indent++;
-		for (ModuleStatement stmt : (List<ModuleStatement>)node.moduleStatements()) {
+		for (ModuleDirective stmt : (List<ModuleDirective>)node.moduleStatements()) {
 			stmt.accept(this);
 		}
 		this.indent--;
@@ -1317,7 +1317,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(OpensStatement node) {
+	public boolean visit(OpensDirective node) {
 		return visit(node, "opens"); //$NON-NLS-1$
 	}
 
@@ -1398,7 +1398,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		printIndent();
 		this.buffer.append("provides");//$NON-NLS-1$
 		this.buffer.append(" ");//$NON-NLS-1$
@@ -1431,7 +1431,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(RequiresStatement node) {
+	public boolean visit(RequiresDirective node) {
 		printIndent();
 		this.buffer.append("requires");//$NON-NLS-1$
 		this.buffer.append(" ");//$NON-NLS-1$
@@ -1941,7 +1941,7 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(UsesStatement node) {
+	public boolean visit(UsesDirective node) {
 		printIndent();
 		this.buffer.append("uses");//$NON-NLS-1$
 		this.buffer.append(" ");//$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 197c7f4..6f3ba4c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -2159,13 +2159,13 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(RequiresStatement node) {
+	public boolean visit(RequiresDirective node) {
 		if (!hasChildrenChanges(node)) {
 			return doVisitUnchangedChildren(node);
 		}
 		int pos = getPosAfterToken(node.getStartPosition(), TerminalTokens.TokenNamerequires);
-		rewriteNodeList(node, RequiresStatement.MODIFIERS_PROPERTY, pos, String.valueOf(' '), String.valueOf(' '), String.valueOf(' '));
-		rewriteRequiredNode(node, RequiresStatement.NAME_PROPERTY);
+		rewriteNodeList(node, RequiresDirective.MODIFIERS_PROPERTY, pos, String.valueOf(' '), String.valueOf(' '), String.valueOf(' '));
+		rewriteRequiredNode(node, RequiresDirective.NAME_PROPERTY);
 		return false;
 	}
 
@@ -2707,12 +2707,12 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		if (!hasChildrenChanges(node)) {
 			return doVisitUnchangedChildren(node);
 		}
-		int pos = rewriteRequiredNode(node, ExportsStatement.NAME_PROPERTY);
-		rewriteNodeList(node, ExportsStatement.MODULES_PROPERTY, pos, "to ", ", "); //$NON-NLS-1$ //$NON-NLS-2$ 
+		int pos = rewriteRequiredNode(node, ExportsDirective.NAME_PROPERTY);
+		rewriteNodeList(node, ExportsDirective.MODULES_PROPERTY, pos, "to ", ", "); //$NON-NLS-1$ //$NON-NLS-2$ 
 
 		return false;
 	}
@@ -3290,12 +3290,12 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		if (!hasChildrenChanges(node)) {
 			return doVisitUnchangedChildren(node);
 		}
-		int pos = rewriteRequiredNode(node, ProvidesStatement.TYPE_PROPERTY);
-		pos= rewriteNodeList(node, ProvidesStatement.IMPLEMENTATIONS_PROPERTY, pos, " with ", ", "); //$NON-NLS-1$ //$NON-NLS-2$
+		int pos = rewriteRequiredNode(node, ProvidesDirective.TYPE_PROPERTY);
+		pos= rewriteNodeList(node, ProvidesDirective.IMPLEMENTATIONS_PROPERTY, pos, " with ", ", "); //$NON-NLS-1$ //$NON-NLS-2$
 		return false;
 	}
 	/* (non-Javadoc)
@@ -3765,11 +3765,11 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(UsesStatement node) {
+	public boolean visit(UsesDirective node) {
 		if (!hasChildrenChanges(node)) {
 			return doVisitUnchangedChildren(node);
 		}
-		rewriteRequiredNode(node,UsesStatement.TYPE_PROPERTY);
+		rewriteRequiredNode(node,UsesDirective.TYPE_PROPERTY);
 		return false;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index d4c26c5..6066071 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -534,13 +534,13 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		this.result.append("exports "); //$NON-NLS-1$
-		getChildNode(node, ExportsStatement.NAME_PROPERTY).accept(this);
+		getChildNode(node, ExportsDirective.NAME_PROPERTY).accept(this);
 		List<Name> modules = node.modules();
 		if (modules.size() > 0) {
 			this.result.append(" to "); //$NON-NLS-1$
-			visitList(node, ExportsStatement.MODULES_PROPERTY, Util.COMMA_SEPARATOR, Util.EMPTY_STRING, Util.EMPTY_STRING);
+			visitList(node, ExportsDirective.MODULES_PROPERTY, Util.COMMA_SEPARATOR, Util.EMPTY_STRING, Util.EMPTY_STRING);
 		}
 		this.result.append(';');
 		return false;
@@ -899,11 +899,11 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		this.result.append("provides "); //$NON-NLS-1$
-		getChildNode(node, ProvidesStatement.TYPE_PROPERTY).accept(this);
+		getChildNode(node, ProvidesDirective.TYPE_PROPERTY).accept(this);
 		this.result.append(" with "); //$NON-NLS-1$
-		visitList(node, ProvidesStatement.IMPLEMENTATIONS_PROPERTY, Util.EMPTY_STRING, Util.COMMA_SEPARATOR, Util.EMPTY_STRING);
+		visitList(node, ProvidesDirective.IMPLEMENTATIONS_PROPERTY, Util.EMPTY_STRING, Util.COMMA_SEPARATOR, Util.EMPTY_STRING);
 		this.result.append(';');
 		return false;
 	}
@@ -930,10 +930,10 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(RequiresStatement node) {
+	public boolean visit(RequiresDirective node) {
 		this.result.append("requires "); //$NON-NLS-1$
-		visitList(node, RequiresStatement.MODIFIERS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));
-		getChildNode(node, RequiresStatement.NAME_PROPERTY).accept(this);
+		visitList(node, RequiresDirective.MODIFIERS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));
+		getChildNode(node, RequiresDirective.NAME_PROPERTY).accept(this);
 		this.result.append(';');
 		return false;
 	}
@@ -1216,9 +1216,9 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 	
 	@Override
-	public boolean visit(UsesStatement node) {
+	public boolean visit(UsesDirective node) {
 		this.result.append("uses "); //$NON-NLS-1$
-		getChildNode(node, UsesStatement.TYPE_PROPERTY).accept(this);
+		getChildNode(node, UsesDirective.TYPE_PROPERTY).accept(this);
 		this.result.append(';');
 		return false;
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
index ddf781b..9124dcb 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
@@ -61,7 +61,7 @@ import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.Modifier;
 import org.eclipse.jdt.core.dom.ModuleDeclaration;
-import org.eclipse.jdt.core.dom.ModuleStatement;
+import org.eclipse.jdt.core.dom.ModuleDirective;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ReturnStatement;
@@ -684,9 +684,9 @@ public class LineBreaksPreparator extends ASTVisitor {
 				this.options.indent_body_declarations_compare_to_type_header,
 				this.options.insert_new_line_in_empty_type_declaration);
 
-		List<ModuleStatement> statements = node.moduleStatements();
-		ModuleStatement previous = null;
-		for (ModuleStatement statement : statements) {
+		List<ModuleDirective> statements = node.moduleStatements();
+		ModuleDirective previous = null;
+		for (ModuleDirective statement : statements) {
 			int blankLines = previous == null ? this.options.blank_lines_before_first_class_body_declaration
 					: previous.getClass().equals(statement.getClass()) ? this.options.blank_lines_before_field
 							: this.options.blank_lines_before_new_chunk;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
index 23bb472..865091b 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
@@ -40,7 +40,7 @@ import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EnhancedForStatement;
 import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
 import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.ExportsStatement;
+import org.eclipse.jdt.core.dom.ExportsDirective;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.ExpressionMethodReference;
 import org.eclipse.jdt.core.dom.ExpressionStatement;
@@ -60,13 +60,13 @@ import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.ModuleDeclaration;
 import org.eclipse.jdt.core.dom.Name;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
-import org.eclipse.jdt.core.dom.OpensStatement;
+import org.eclipse.jdt.core.dom.OpensDirective;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.PostfixExpression;
 import org.eclipse.jdt.core.dom.PrefixExpression;
-import org.eclipse.jdt.core.dom.ProvidesStatement;
+import org.eclipse.jdt.core.dom.ProvidesDirective;
 import org.eclipse.jdt.core.dom.PrefixExpression.Operator;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
@@ -964,19 +964,19 @@ public class SpacePreparator extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		handleModuleStatementCommas(node.modules());
 		return true;
 	}
 	
 	@Override
-	public boolean visit(OpensStatement node) {
+	public boolean visit(OpensDirective node) {
 		handleModuleStatementCommas(node.modules());
 		return true;
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		handleModuleStatementCommas(node.implementations());
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
index 5daa0d1..404b1a4 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
@@ -57,7 +57,7 @@ import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.CreationReference;
 import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
 import org.eclipse.jdt.core.dom.EnumDeclaration;
-import org.eclipse.jdt.core.dom.ExportsStatement;
+import org.eclipse.jdt.core.dom.ExportsDirective;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.ExpressionMethodReference;
 import org.eclipse.jdt.core.dom.FieldAccess;
@@ -72,9 +72,9 @@ import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.Name;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
-import org.eclipse.jdt.core.dom.OpensStatement;
+import org.eclipse.jdt.core.dom.OpensDirective;
 import org.eclipse.jdt.core.dom.ParameterizedType;
-import org.eclipse.jdt.core.dom.ProvidesStatement;
+import org.eclipse.jdt.core.dom.ProvidesDirective;
 import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Statement;
@@ -786,19 +786,19 @@ public class WrapPreparator extends ASTVisitor {
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
+	public boolean visit(ExportsDirective node) {
 		handleModuleStatement(node.modules(), TokenNameto);
 		return true;
 	}
 
 	@Override
-	public boolean visit(OpensStatement node) {
+	public boolean visit(OpensDirective node) {
 		handleModuleStatement(node.modules(), TokenNameto);
 		return true;
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
+	public boolean visit(ProvidesDirective node) {
 		handleModuleStatement(node.implementations(), TokenNamewith);
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
index ca2293b..00d9e97 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
@@ -62,7 +62,7 @@ public class ModulePathContainer implements IClasspathContainer{
 	@Override
 	public String getDescription() {
 		// 
-		return "Module source path"; //$NON-NLS-1$
+		return "Module path"; //$NON-NLS-1$
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
index 7ebd2cf..41e0e22 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/HierarchicalASTVisitor.java
@@ -1160,62 +1160,62 @@ public abstract class HierarchicalASTVisitor extends ASTVisitor {
 		endVisit((ASTNode) node);
 	}
 
-	public boolean visit(ModuleStatement node) {
+	public boolean visit(ModuleDirective node) {
 		return visit((ASTNode) node);
 	}
 
-	public void endVisit(ModuleStatement node) {
+	public void endVisit(ModuleDirective node) {
 		endVisit((ASTNode) node);
 	}
 
 	@Override
-	public boolean visit(ExportsStatement node) {
-		return visit((ModuleStatement) node);
+	public boolean visit(ExportsDirective node) {
+		return visit((ModuleDirective) node);
 	}
 
 	@Override
-	public void endVisit(ExportsStatement node) {
-		endVisit((ModuleStatement) node);
+	public void endVisit(ExportsDirective node) {
+		endVisit((ModuleDirective) node);
 	}
 
 	@Override
-	public boolean visit(OpensStatement node) {
-		return visit((ModuleStatement) node);
+	public boolean visit(OpensDirective node) {
+		return visit((ModuleDirective) node);
 	}
 
 	@Override
-	public void endVisit(OpensStatement node) {
-		endVisit((ModuleStatement) node);
+	public void endVisit(OpensDirective node) {
+		endVisit((ModuleDirective) node);
 	}
 
 	@Override
-	public boolean visit(RequiresStatement node) {
-		return visit((ModuleStatement) node);
+	public boolean visit(RequiresDirective node) {
+		return visit((ModuleDirective) node);
 	}
 
 	@Override
-	public void endVisit(RequiresStatement node) {
-		endVisit((ModuleStatement) node);
+	public void endVisit(RequiresDirective node) {
+		endVisit((ModuleDirective) node);
 	}
 
 	@Override
-	public boolean visit(ProvidesStatement node) {
-		return visit((ModuleStatement) node);
+	public boolean visit(ProvidesDirective node) {
+		return visit((ModuleDirective) node);
 	}
 
 	@Override
-	public void endVisit(ProvidesStatement node) {
-		endVisit((ModuleStatement) node);
+	public void endVisit(ProvidesDirective node) {
+		endVisit((ModuleDirective) node);
 	}
 
 	@Override
-	public boolean visit(UsesStatement node) {
-		return visit((ModuleStatement) node);
+	public boolean visit(UsesDirective node) {
+		return visit((ModuleDirective) node);
 	}
 
 	@Override
-	public void endVisit(UsesStatement node) {
-		endVisit((ModuleStatement) node);
+	public void endVisit(UsesDirective node) {
+		endVisit((ModuleDirective) node);
 	}
 
 //---- End Module Hierarchy -------------------------------------------
commit b4a92afd579d4c65bb42b8e593ce89a80b355f1a
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Sat Jun 17 00:18:12 2017 +0200

    Bug 518301: [9] [dom] Change ModuleStatements to ModuleDirectives

9	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
33	0	org.eclipse.jdt.core/.settings/.api_filters
20	20	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
16	16	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
14	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
30	31	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
7	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
8	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleModifier.java
7	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
5	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
3	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
2	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
index 5f5cf25..d697bb7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingModuleDeclarationTest.java
@@ -67,7 +67,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			AST ast= astRoot.getAST();
 
 			ModuleDeclaration moduleDecl = astRoot.getModule();
-			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
+			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY);
 			List<ModuleDirective> moduleStatements = moduleDecl.moduleStatements();
 			int index = 0;
 			{
@@ -76,7 +76,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 				rewrite.replace(req.getName(), newName, null);
 				listRewrite.remove(moduleStatements.get(index++), null); // remove the second required
 
-				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresDirective(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				listRewrite.insertAfter(newNode, req, null);
 			}
@@ -120,7 +120,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 				listRewrite.remove(moduleStatements.get(index++), null);
 
 				// uses MyNewFoundType - add the uses
-				usesStatement = ast.newUsesStatement();
+				usesStatement = ast.newUsesDirective();
 				newName = ast.newSimpleName("MyNewFoundType");
 				type = ast.newSimpleType(newName);
 				usesStatement.setType(type);
@@ -182,9 +182,9 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			AST ast= astRoot.getAST();
 
 			ModuleDeclaration moduleDecl = astRoot.getModule();
-			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
+			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY);
 			{
-				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresDirective(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				listRewrite.insertLast(newNode, null);
 			}
@@ -218,7 +218,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			ASTRewrite rewrite= ASTRewrite.create(astRoot.getAST());
 			AST ast= astRoot.getAST();
 			ModuleDeclaration moduleDecl = astRoot.getModule();
-			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
+			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY);
 			{
 				RequiresDirective reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(0);
 				ASTNode newModifier = ast.newModuleModifier(ModuleModifierKeyword.STATIC_KEYWORD);
@@ -235,7 +235,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
 				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertLast(newModifier, null);
 
-				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresDirective(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
 				rewrite.getListRewrite(newNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
@@ -324,7 +324,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 			ASTRewrite rewrite= ASTRewrite.create(astRoot.getAST());
 			AST ast= astRoot.getAST();
 			ModuleDeclaration moduleDecl = astRoot.getModule();
-			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY);
+			ListRewrite listRewrite = rewrite.getListRewrite(moduleDecl, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY);
 			{
 				int count = 0;
 				RequiresDirective reqNode = (RequiresDirective) moduleDecl.moduleStatements().get(count++);
@@ -348,7 +348,7 @@ public class ASTRewritingModuleDeclarationTest extends ASTRewritingTest {
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
 				rewrite.getListRewrite(reqNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
 
-				RequiresDirective newNode = ast.newRequiresStatement(); // add a new required
+				RequiresDirective newNode = ast.newRequiresDirective(); // add a new required
 				newNode.setName(ast.newSimpleName("addedme"));
 				newModifier = ast.newModuleModifier(ModuleModifierKeyword.TRANSITIVE_KEYWORD);
 				rewrite.getListRewrite(newNode, RequiresDirective.MODIFIERS_PROPERTY).insertFirst(newModifier, null);
diff --git a/org.eclipse.jdt.core/.settings/.api_filters b/org.eclipse.jdt.core/.settings/.api_filters
new file mode 100644
index 0000000..a176127
--- /dev/null
+++ b/org.eclipse.jdt.core/.settings/.api_filters
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<component id="org.eclipse.jdt.core" version="2">
+    <resource path="META-INF/MANIFEST.MF">
+        <filter comment="keep the same version as 4.7.1 for now" id="924844039">
+            <message_arguments>
+                <message_argument value="3.13.0"/>
+                <message_argument value="3.13.0"/>
+            </message_arguments>
+        </filter>
+    </resource>
+    <resource path="dom/org/eclipse/jdt/core/dom/CompilationUnit.java" type="org.eclipse.jdt.core.dom.CompilationUnit">
+        <filter comment="has never been subclassable" id="336744520">
+            <message_arguments>
+                <message_argument value="org.eclipse.jdt.core.dom.CompilationUnit"/>
+            </message_arguments>
+        </filter>
+    </resource>
+    <resource path="dom/org/eclipse/jdt/core/dom/TryStatement.java" type="org.eclipse.jdt.core.dom.TryStatement">
+        <filter comment="has never been subclassable" id="336744520">
+            <message_arguments>
+                <message_argument value="org.eclipse.jdt.core.dom.TryStatement"/>
+            </message_arguments>
+        </filter>
+    </resource>
+    <resource path="formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java" type="org.eclipse.jdt.core.formatter.CodeFormatter">
+        <filter comment="safe in practice" id="336658481">
+            <message_arguments>
+                <message_argument value="org.eclipse.jdt.core.formatter.CodeFormatter"/>
+                <message_argument value="K_MODULE_INFO"/>
+            </message_arguments>
+        </filter>
+    </resource>
+</component>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 0ead17d..821008f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1509,11 +1509,11 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented exports statement
+	 * Creates and returns a new unparented exports directive
 	 * node for an unspecified, but legal, name; no target modules
 	 *
-	 * @return a new unparented exports statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @return a new unparented exports directive node
+	 * @exception UnsupportedOperationException if this operation is used in an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
 	public ExportsDirective newExportsStatement() {
@@ -1888,7 +1888,7 @@ public final class AST {
 	 * @return a new unparented module modifier node
 	 * @exception IllegalArgumentException if the primitive type code is invalid
 	 * @exception UnsupportedOperationException if this operation is used in
-	 * an AST less than 9
+	 * an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
 	public ModuleModifier newModuleModifier(ModuleModifier.ModuleModifierKeyword keyword) {
@@ -1964,7 +1964,7 @@ public final class AST {
 	 * and an empty list of statements.
 	 *
 	 * @return a new unparented module declaration node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @exception UnsupportedOperationException if this operation is used in an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
 	public ModuleDeclaration newModuleDeclaration() {
@@ -2136,14 +2136,14 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented opens statement
+	 * Creates and returns a new unparented opens directive
 	 * node for an unspecified, but legal, name; no target modules
 	 *
-	 * @return a new unparented opens statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @return a new unparented opens directive node
+	 * @exception UnsupportedOperationException if this operation is used in an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public OpensDirective newOpensStatement() {
+	public OpensDirective newOpensDirective() {
 		OpensDirective result = new OpensDirective(this);
 		return result;
 	}
@@ -2232,14 +2232,14 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented provides statement
+	 * Creates and returns a new unparented provides directive
 	 * node for an unspecified, but legal, type; no target types
 	 *
-	 * @return a new unparented provides statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @return a new unparented provides directive node
+	 * @exception UnsupportedOperationException if this operation is used in an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public ProvidesDirective newProvidesStatement() {
+	public ProvidesDirective newProvidesDirective() {
 		ProvidesDirective result = new ProvidesDirective(this);
 		return result;
 	}
@@ -2291,14 +2291,14 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented requires statement
+	 * Creates and returns a new unparented requires directive
 	 * node for an unspecified, but legal, name;
 	 *
-	 * @return a new unparented requires statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @return a new unparented requires directive node
+	 * @exception UnsupportedOperationException if this operation is used in an AST with level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public RequiresDirective newRequiresStatement() {
+	public RequiresDirective newRequiresDirective() {
 		RequiresDirective result = new RequiresDirective(this);
 		return result;
 	}
@@ -2671,14 +2671,14 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented uses statement
+	 * Creates and returns a new unparented uses directive
 	 * node for an unspecified, but legal, name;
 	 *
-	 * @return a new unparented uses statement node
+	 * @return a new unparented uses directive node
 	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public UsesDirective newUsesStatement() {
+	public UsesDirective newUsesDirective() {
 		UsesDirective result = new UsesDirective(this);
 		return result;
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 3efeb95..9375a68 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -910,27 +910,35 @@ public abstract class ASTNode {
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>ExportsdIRECTIVE</code>.
+	 * <code>RequiresDirective</code>.
+	 * @see RequiresDirective
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int REQUIRES_DIRECTIVE = 94;
+	
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>ExportsDirective</code>.
 	 * @see ExportsDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int EXPORTS_DIRECTIVE = 94;
+	public static final int EXPORTS_DIRECTIVE = 95;
 
 	/**
 	 * Node type constant indicating a node of type
-	 * <code>RequiresDirective</code>.
-	 * @see RequiresDirective
+	 * <code>OpensDirective</code>.
+	 * @see OpensDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int REQUIRES_DIRECTIVE = 95;
-
+	public static final int OPENS_DIRECTIVE = 96;
+	
 	/**
 	 * Node type constant indicating a node of type
 	 * <code>UsesDirective</code>.
 	 * @see UsesDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int USES_DIRECTIVE = 96;
+	public static final int USES_DIRECTIVE = 97;
 
 	/**
 	 * Node type constant indicating a node of type
@@ -938,15 +946,7 @@ public abstract class ASTNode {
 	 * @see ProvidesDirective
 	 * @since 3.13 BETA_JAVA9
 	 */
-	public static final int PROVIDES_DIRECTIVE = 97;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>OpensDirective</code>.
-	 * @see OpensDirective
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int OPENS_DIRECTIVE = 98;
+	public static final int PROVIDES_DIRECTIVE = 98;
 
 	/**
 	 * Node type constant indicating a node of type
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index 69f3bcb..07d3782 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -32,21 +32,29 @@ import org.eclipse.text.edits.TextEdit;
 
 /**
  * Java compilation unit AST node type. This is the type of the root of an AST.
- * From JLS 9 onwards, this can contain a ModuleDeclation. To be noted that not
- * all nodes make sense in all contexts.
+ * In JLS9 and later, this node can also contain a ModuleDeclaration (with a completely different grammar).
  * <p>
  * The source range for this type of node is ordinarily the entire source file,
  * including leading and trailing whitespace and comments.
  * </p>
  * <pre>
  * CompilationUnit:
- *    [ PackageDeclaration ]
- *        { ImportDeclaration }
- *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ModuleDeclaration <b>;</b> }
+ *     OrdinaryCompilationUnit
+ *     ModularCompilationUnit
+ *     
+ * OrdinaryCompilationUnit:
+ *     [ PackageDeclaration ]
+ *         { ImportDeclaration }
+ *         { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | <b>;</b> }
+ * 
+ * ModularCompilationUnit:
+ *     {ImportDeclaration}
+ *         ModuleDeclaration
  * </pre>
  *
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
+ * @noextend This class is not intended to be subclassed by clients.
  */
 @SuppressWarnings({ "rawtypes", "unchecked" })
 public class CompilationUnit extends ASTNode {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
index d89a102..e97823b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Exports directive AST node type.
+ * Exports directive AST node type (added in JLS9 API).
  * <pre>
  * ExportsDirective:
  *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
index dd5fa4f..a3af4f1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,12 +17,12 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Module declaration AST node type representing the module descriptor file
+ * Module declaration AST node type representing the module descriptor file (added in JLS9 API).
  *
  * <pre>
  * ModuleDeclaration:
  *  [ Javadoc ] { Annotation } [ <b>open</b> ] <b>module</b> Name <b>{</b>
- *        [ ExportsStatement | OpensStatement | RequiresStatement | UsesStatement | ProvidesStatement ]
+ *        { RequiresDirective | ExportsDirective | OpensDirective | UsesDirective | ProvidesDirective }
  *  <b>}</b>
  * </pre>
  * <p>
@@ -46,26 +46,25 @@ public class ModuleDeclaration extends ASTNode {
 	 * The "annotations" structural property of this node type (element type: {@link Annotation}).
 	 */
 	public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY =
-		new ChildListPropertyDescriptor(ModuleDeclaration.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
+			new ChildListPropertyDescriptor(ModuleDeclaration.class, "annotations", Annotation.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * The "open" structural property of this node type (type: {@link Boolean}).
 	 */
 	public static final SimplePropertyDescriptor OPEN_PROPERTY =
-		new SimplePropertyDescriptor(ModuleDeclaration.class, "open", boolean.class, MANDATORY); //$NON-NLS-1$
+			new SimplePropertyDescriptor(ModuleDeclaration.class, "open", boolean.class, MANDATORY); //$NON-NLS-1$
 
 	/**
 	 * The "name" structural property of this node type (child type: {@link Name}).
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+			new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleDirective}).
+	 * The "moduleDirectives" structural property of this node type (element type: {@link ModuleDirective}).
 	 */
-	public static final ChildListPropertyDescriptor MODULE_STATEMENTS_PROPERTY =
-		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleDirective.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	public static final ChildListPropertyDescriptor MODULE_DIRECTIVES_PROPERTY =
+			new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleDirectives", ModuleDirective.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -81,7 +80,7 @@ public class ModuleDeclaration extends ASTNode {
 		addProperty(ANNOTATIONS_PROPERTY, properyList);
 		addProperty(OPEN_PROPERTY, properyList);
 		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULE_STATEMENTS_PROPERTY, properyList);
+		addProperty(MODULE_DIRECTIVES_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
 	}
 
@@ -106,8 +105,8 @@ public class ModuleDeclaration extends ASTNode {
 	private Javadoc optionalDocComment = null;
 
 	/**
-	 * The extended annotations (element type: {@link Annotation}).
-	 * defaults to an empty list
+	 * The annotations (element type: {@link Annotation}).
+	 * Defaults to an empty list.
 	 *
 	 */
 	private ASTNode.NodeList annotations = new ASTNode.NodeList(ANNOTATIONS_PROPERTY);
@@ -127,7 +126,7 @@ public class ModuleDeclaration extends ASTNode {
 	 * The list of statements (element type: {@link ModuleDirective}).
 	 * Defaults to an empty list.
 	 */
-	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_STATEMENTS_PROPERTY);
+	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_DIRECTIVES_PROPERTY);
 
 	ModuleDeclaration(AST ast) {
 		super(ast);
@@ -185,7 +184,7 @@ public class ModuleDeclaration extends ASTNode {
 		if (property == ANNOTATIONS_PROPERTY) {
 			return annotations();
 		}
-		if (property == MODULE_STATEMENTS_PROPERTY) {
+		if (property == MODULE_DIRECTIVES_PROPERTY) {
 			return moduleStatements();
 		}
 		// allow default implementation to flag the error
@@ -253,7 +252,18 @@ public class ModuleDeclaration extends ASTNode {
 	}
 
 	/**
-	 * Returns whether this module declaration is open or not
+	 * Returns the live ordered list of annotations
+	 * of this declaration.
+	 *
+	 * @return the live list of annotations
+	 *    (element type: {@link Annotation})
+	 */
+	public List annotations() {
+		return this.annotations;
+	}
+
+	/**
+	 * Returns whether this module declaration is open or not.
 	 *
 	 * @return <code>true</code> if this is open, else
 	 *    <code>false</code>
@@ -263,9 +273,9 @@ public class ModuleDeclaration extends ASTNode {
 	}
 
 	/**
-	 * Sets whether this module declaration is open or not
+	 * Sets whether this module declaration is open or not.
 	 *
-	 * @param isOpen <code>true</code> if this is open module,
+	 * @param isOpen <code>true</code> if this is an open module,
 	 *    and <code>false</code> if not
 	 */
 	public void setOpen(boolean isOpen) {
@@ -315,20 +325,9 @@ public class ModuleDeclaration extends ASTNode {
 	}
 
 	/**
-	 * Returns the live ordered list of annotations
-	 * of this declaration.
-	 *
-	 * @return the live list of annotations
-	 *    (element type: {@link Annotation})
-	 */
-	public List annotations() {
-		return this.annotations;
-	}
-
-	/**
 	 * Returns the live list of statements in this module. Adding and
 	 * removing nodes from this list affects this node dynamically.
-	 * All nodes in this list must be <code>Statement</code>s;
+	 * All nodes in this list must be <code>ModuleDirective</code>s;
 	 * attempts to add any other type of node will trigger an
 	 * exception.
 	 *
@@ -340,7 +339,7 @@ public class ModuleDeclaration extends ASTNode {
 	}
 
 	/**
-	 * Resolves and returns the binding for the module
+	 * Resolves and returns the binding for the module.
 	 * <p>
 	 * Note that bindings are generally unavailable unless requested when the
 	 * AST is being built.
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
index d81197e..735d02e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDirective.java
@@ -14,15 +14,15 @@
 package org.eclipse.jdt.core.dom;
 
 /**
- * Abstract base class of AST nodes that represent module directives.
- * There are many kinds of module directives.
+ * Abstract base class of AST nodes that represent module directives (added in JLS9 API).
  *
  * <pre>
- * ModuleStatement: [ {@link ExportsDirective} |
- *    {@link OpensDirective} |
- *    {@link RequiresDirective} |
- *    {@link UsesDirective} |
- *    {@link ProvidesDirective} ]
+ * ModuleDirective:
+ *    {@link RequiresDirective}
+ *    {@link ExportsDirective}
+ *    {@link OpensDirective}
+ *    {@link UsesDirective}
+ *    {@link ProvidesDirective}
  * </pre>
  *
  * @noextend This class is not intended to be subclassed by clients.
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleModifier.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleModifier.java
index 2ce36ec..718f644 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleModifier.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleModifier.java
@@ -20,7 +20,7 @@ import java.util.List;
 import java.util.Map;
 
 /**
- * Module Modifier node - represents the modifiers for the requires statement in module declaration.
+ * Module Modifier node - represents the modifiers for the requires directive in module declaration (added in JLS9 API).
  * <pre>
  * ModuleModifier:
  *    <b>static</b>
@@ -28,7 +28,8 @@ import java.util.Map;
  * </pre>
  * <p>
  * The numeric values of these flags match the ones for class
- * files as described in the Java Virtual Machine Specification
+ * files as described in the Java Virtual Machine Specification.
+ * Note that the value of <b>static</b> does <b>not</b> correspond to the value of {@link Modifier#STATIC}!
  * </p>
  *
  * @since 3.13 BETA_JAVA9
@@ -166,13 +167,16 @@ public final class ModuleModifier extends ASTNode {
 
 	/**
 	 * "static" module modifier constant (bit mask).
-	 * Applicable to requires statement.
+	 * Applicable to requires directive.
+	 * <p>
+	 * Note that the value of <b>static</b> does <b>not</b> correspond to the value of {@link Modifier#STATIC}!
+	 * </p>
 	 */
 	public static final int STATIC_PHASE = 0x0040;
 
 	/**
 	 * "transitive" module modifier constant (bit mask).
-	 * Applicable only to requires statement.
+	 * Applicable only to requires directive.
 	 */
 	public static final int TRANSITIVE = 0x0080;
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
index 2967715..84284b5 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,11 +16,12 @@ package org.eclipse.jdt.core.dom;
 import java.util.List;
 
 /**
- * Abstract base class of AST nodes that represent exports and opens statements.
+ * Abstract base class of AST nodes that represent exports and opens directives (added in JLS9 API).
  *
  * <pre>
- * ModuleStatement: [ {@link ExportsDirective} |
- *    {@link OpensDirective} ]
+ * ModulePackageAccess:
+ *    {@link ExportsDirective}
+ *    {@link OpensDirective}
  * </pre>
  *
  * @noextend This class is not intended to be subclassed by clients.
@@ -126,7 +127,7 @@ public abstract class ModulePackageAccess extends ModuleDirective {
 	}
 
 	/**
-	 * Returns the name of the package
+	 * Returns the name of the package.
 	 *
 	 * @return the package name node
 	 */
@@ -169,7 +170,7 @@ public abstract class ModulePackageAccess extends ModuleDirective {
 
 	/**
 	 * Returns the live ordered list of target modules for this
-	 * statement.
+	 * directive.
 	 *
 	 * @return the live list of target modules
 	 *    (element type: {@link Name})
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
index e0ec761..e246d0c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * opens directive AST node type.
+ * Opens directive AST node type (added in JLS9 API).
  * <pre>
  * OpensDirective:
  *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
index 75d1500..479ee2e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesDirective.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Provides directive AST node type.
+ * Provides directive AST node type (added in JLS9 API).
  * <pre>
  * ProvidesDirective:
  *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
@@ -41,7 +41,7 @@ public class ProvidesDirective extends ModuleDirective {
 	 * The "implementation type" structural property of this node type (element type: {@link Type}).
 	 */
 	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
-			new ChildListPropertyDescriptor(ProvidesDirective.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
+			new ChildListPropertyDescriptor(ProvidesDirective.class, "implementations", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
 	 * A list of property descriptors (element type:
@@ -163,7 +163,7 @@ public class ProvidesDirective extends ModuleDirective {
 
 
 	/**
-	 * Returns the type name in this statement
+	 * Returns the type name in this directive.
 	 *
 	 * @return the type name
 	 */
@@ -202,7 +202,7 @@ public class ProvidesDirective extends ModuleDirective {
 	}
 
 	/**
-	 * Returns the live ordered list of implementations for the interface in this provides statement.
+	 * Returns the live ordered list of implementations for the interface in this provides directive.
 	 *
 	 * @return the live list of implementations for the interface
 	 *    (element type: {@link Name})
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
index 40ebe05..f2394d2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresDirective.java
@@ -18,7 +18,7 @@ import java.util.Iterator;
 import java.util.List;
 
 /**
- * Requires directive AST node type.
+ * Requires directive AST node type (added in JLS9 API).
  * <pre>
  * RequiresDirective:
  *     <b>requires</b> { ModuleModifier } Name <b>;</b>
@@ -26,6 +26,7 @@ import java.util.List;
  *
  * @since 3.13 BETA_JAVA9
  * @noinstantiate This class is not intended to be instantiated by clients.
+ * @noextend This class is not intended to be subclassed by clients.
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class RequiresDirective extends ModuleDirective {
@@ -175,7 +176,7 @@ public class RequiresDirective extends ModuleDirective {
 	/**
 	 * Returns the module modifiers explicitly specified on this declaration.
 	 * <p>
-	 * this method is a convenience method that
+	 * This method is a convenience method that
 	 * computes these flags from <code>modifiers()</code>.
 	 * </p>
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
index cf65b03..cd53276 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -36,6 +36,7 @@ import java.util.List;
  * 
  * @since 2.0
  * @noinstantiate This class is not intended to be instantiated by clients.
+ * @noextend This class is not intended to be subclassed by clients.
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class TryStatement extends Statement {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
index 9350554..d699cdb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesDirective.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Uses directive AST node type.
+ * Uses directive AST node type (added in JLS9 API).
  * <pre>
  * UsesDirective:
  *     <b>uses</b> Name <b>;</b>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 6f3ba4c..e1925ab 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -2114,7 +2114,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 		int startIndent= getIndent(node.getStartPosition()) + 1;
 		boolean fakeInModule = this.tokenScanner.getScanner().fakeInModule;
 		this.tokenScanner.getScanner().fakeInModule = true;
-		rewriteParagraphList(node, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY, startPos, startIndent, 0, 1);
+		rewriteParagraphList(node, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY, startPos, startIndent, 0, 1);
 		this.tokenScanner.getScanner().fakeInModule = fakeInModule;
 		return false;
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 6066071..8510d19 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -812,7 +812,7 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		this.result.append("module "); //$NON-NLS-1$
 		getChildNode(node, ModuleDeclaration.NAME_PROPERTY).accept(this);
 		this.result.append('{');
-		visitList(node, ModuleDeclaration.MODULE_STATEMENTS_PROPERTY, null);
+		visitList(node, ModuleDeclaration.MODULE_DIRECTIVES_PROPERTY, null);
 		this.result.append('}');
 		return false;
 	}
