commit 8b3b76d9e0df45554ba959021d798047877d1acc
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Nov 14 21:30:01 2016 +0530

    Bug 506888 - Unused @SuppressWarnings("incomplete-switch") not reported
    
    Change-Id: I28f9246fd0d16f0e3a72da34dd77959e4212d444
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>
    Also-by: Stephan Herrmann <stephan.herrmann@berlin.de>

131	11	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
40	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index 89897b0..060df16 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -59,7 +59,7 @@ public class AnnotationTest extends AbstractComparableTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//		TESTS_NAMES = new String[] { "testBug384663" };
+//		TESTS_NAMES = new String[] { "testBug506888c" };
 //		TESTS_NUMBERS = new int[] { 297 };
 //		TESTS_RANGE = new int[] { 294, -1 };
 	}
@@ -4902,7 +4902,7 @@ public void test143() {
     public void test153() {
 		Map options = getCompilerOptions();
 		options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.WARNING);
-        this.runNegativeTest(
+        this.runConformTest(
             new String[] {
                 "X.java",
                 "enum E { A, B, C }\n" +
@@ -4919,9 +4919,6 @@ public void test143() {
 				"	 }\n" +
 				"}",
             },
-			"",
-			null,
-			true,
 			options
 		);
     }
@@ -8135,11 +8132,16 @@ public void test245() {
 				"}	\n",
 		},
 		null, options,
-		"----------\n" +
-		"1. ERROR in X.java (at line 3)\n" +
-		"	@SuppressWarnings({\"unchecked\",\"unused\"})\n" +
-		"	                               ^^^^^^^^\n" +
-		"Unnecessary @SuppressWarnings(\"unused\")\n" +
+		"----------\n" + 
+		"1. INFO in X.java (at line 3)\n" + 
+		"	@SuppressWarnings({\"unchecked\",\"unused\"})\n" + 
+		"	                   ^^^^^^^^^^^\n" + 
+		"At least one of the problems in category \'unchecked\' is not analysed due to a compiler option being ignored\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 3)\n" + 
+		"	@SuppressWarnings({\"unchecked\",\"unused\"})\n" + 
+		"	                               ^^^^^^^^\n" + 
+		"Unnecessary @SuppressWarnings(\"unused\")\n" + 
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -11650,4 +11652,122 @@ public void testBug470665() throws Exception {
 		this.enableAPT = apt;
 	}
 }
+public void testBug506888a() throws Exception {
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.ERROR);
+	options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.IGNORE);
+	options.put(CompilerOptions.OPTION_ReportMissingDefaultCase, CompilerOptions.WARNING);
+	this.runNegativeTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"incomplete-switch\"})\n" +
+				"	void foo() {\n" +
+				"	}\n" +
+				"}	\n",
+		},
+		"----------\n" + 
+		"1. INFO in X.java (at line 3)\n" + 
+		"	@SuppressWarnings({\"incomplete-switch\"})\n" + 
+		"	                   ^^^^^^^^^^^^^^^^^^^\n" + 
+		"At least one of the problems in category \'incomplete-switch\' is not analysed due to a compiler option being ignored\n" + 
+		"----------\n", 
+		null, true, options);
+}
+public void testBug506888b() throws Exception {
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.ERROR);
+	options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportMissingDefaultCase, CompilerOptions.IGNORE);
+	this.runConformTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"incomplete-switch\"})\n" +
+				"	void foo(Color c) {\n" +
+				"		switch(c) {\n" + 
+				"		}\n" +
+				"	}\n" +
+				"	enum Color { BLUE, RED; } \n" +
+				"}	\n",
+		},
+		options);
+}
+public void testBug506888c() throws Exception {
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportMissingDefaultCase, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.WARNING);
+	this.runNegativeTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"incomplete-switch\", \"unchecked\"})\n" +
+				"	void foo(Color c) {\n" +
+				"		switch(c) {\n" + 
+				"		}\n" +
+				"	}\n" +
+				"	enum Color { BLUE, RED; } \n" +
+				"}	\n",
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 3)\n" + 
+		"	@SuppressWarnings({\"incomplete-switch\", \"unchecked\"})\n" + 
+		"	                                        ^^^^^^^^^^^\n" + 
+		"Unnecessary @SuppressWarnings(\"unchecked\")\n" + 
+		"----------\n", 
+		null, true, options);
+}
+public void testBug506888d() throws Exception {
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.IGNORE);
+	options.put(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"incomplete-switch\"})\n" +
+				"	void foo() {\n" +
+				"	}\n" +
+				"}	\n",
+		},
+		"", 
+		null, true, options);
+}
+public void testBug506888e() throws Exception {
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.IGNORE);
+	options.put(CompilerOptions.OPTION_ReportUnusedLabel, CompilerOptions.WARNING);
+	this.runNegativeTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"unused\"})\n" +
+				"	void foo() {}\n" +
+				"}	\n",
+		},
+		"", 
+		null, true, options);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 636d0b2..fe3f0ac 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1100,6 +1100,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("lambdaSignatureMismatched", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalArrayOfUnionType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalArrayTypeInIntersectionCast", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("ProblemNotAnalysed", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		StringBuffer failures = new StringBuffer();
 		StringBuffer correctResult = new StringBuffer(70000);
 		Field[] fields = (iProblemClass = IProblem.class).getFields();
@@ -1939,6 +1940,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DisallowedExplicitThisParameter", SKIP);
 		expectedProblemAttributes.put("IllegalArrayOfUnionType", SKIP);
 		expectedProblemAttributes.put("IllegalArrayTypeInIntersectionCast", SKIP);
+		expectedProblemAttributes.put("ProblemNotAnalysed", SKIP);
 		Map constantNamesIndex = new HashMap();
 		Field[] fields = JavaCore.class.getFields();
 		for (int i = 0, length = fields.length; i < length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index fc45e19..4faa530 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1881,5 +1881,6 @@ void setSourceStart(int sourceStart);
 	/** @deprecated - problem is no longer generated (implementation issue has been resolved)
 	 * @since 3.10 */
 	int LambdaShapeComputationError = 1101;
-	
+	/** @since 3.13 */
+	int ProblemNotAnalysed = 1102;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 895ea19..acb079b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -299,22 +299,28 @@ public void finalizeProblems() {
 										Constant cst = inits[iToken].constant;
 										if (cst != Constant.NotAConstant && cst.typeID() == TypeIds.T_JavaLangString) {
 											IrritantSet tokenIrritants = CompilerOptions.warningTokenToIrritants(cst.stringValue());
-											if (tokenIrritants != null
-													&& !tokenIrritants.areAllSet() // no complaint against @SuppressWarnings("all")
-													&& options.isAnyEnabled(tokenIrritants) // if irritant is effectively enabled
-													&& (foundIrritants[iSuppress] == null || !foundIrritants[iSuppress].isAnySet(tokenIrritants))) { // if irritant had no matching problem
-												if (unusedWarningTokenIsWarning) {
-													int start = value.sourceStart, end = value.sourceEnd;
-													nextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {
-														long position = this.suppressWarningScopePositions[jSuppress];
-														int startSuppress = (int) (position >>> 32);
-														int endSuppress = (int) position;
-														if (start < startSuppress) continue nextSuppress;
-														if (end > endSuppress) continue nextSuppress;
-														if (this.suppressWarningIrritants[jSuppress].areAllSet()) break pairLoop; // suppress all?
+											if (tokenIrritants != null) {
+												if (!tokenIrritants.areAllSet() // no complaint against @SuppressWarnings("all")
+														&& (foundIrritants[iSuppress] == null || !foundIrritants[iSuppress].isAnySet(tokenIrritants))) { // if irritant had no matching problem
+													if (unusedWarningTokenIsWarning) {
+														int start = value.sourceStart, end = value.sourceEnd;
+														nextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {
+															long position = this.suppressWarningScopePositions[jSuppress];
+															int startSuppress = (int) (position >>> 32);
+															int endSuppress = (int) position;
+															if (start < startSuppress) continue nextSuppress;
+															if (end > endSuppress) continue nextSuppress;
+															if (this.suppressWarningIrritants[jSuppress].areAllSet()) break pairLoop; // suppress all?
+														}
+													}
+													int id = options.getIgnoredIrritant(tokenIrritants);
+													if (id > 0) {
+														String key = CompilerOptions.optionKeyFromIrritant(id);
+														this.scope.problemReporter().problemNotAnalysed(inits[iToken], key);
+													} else {
+														this.scope.problemReporter().unusedWarningToken(inits[iToken]);														
 													}
 												}
-												this.scope.problemReporter().unusedWarningToken(inits[iToken]);
 											}
 										}
 									}
@@ -323,22 +329,28 @@ public void finalizeProblems() {
 								Constant cst = value.constant;
 								if (cst != Constant.NotAConstant && cst.typeID() == T_JavaLangString) {
 									IrritantSet tokenIrritants = CompilerOptions.warningTokenToIrritants(cst.stringValue());
-									if (tokenIrritants != null
-											&& !tokenIrritants.areAllSet() // no complaint against @SuppressWarnings("all")
-											&& options.isAnyEnabled(tokenIrritants) // if irritant is effectively enabled
-											&& (foundIrritants[iSuppress] == null || !foundIrritants[iSuppress].isAnySet(tokenIrritants))) { // if irritant had no matching problem
-										if (unusedWarningTokenIsWarning) {
-											int start = value.sourceStart, end = value.sourceEnd;
-											nextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {
-												long position = this.suppressWarningScopePositions[jSuppress];
-												int startSuppress = (int) (position >>> 32);
-												int endSuppress = (int) position;
-												if (start < startSuppress) continue nextSuppress;
-												if (end > endSuppress) continue nextSuppress;
-												if (this.suppressWarningIrritants[jSuppress].areAllSet()) break pairLoop; // suppress all?
+									if (tokenIrritants != null) {
+										if (!tokenIrritants.areAllSet() // no complaint against @SuppressWarnings("all")
+												&& (foundIrritants[iSuppress] == null || !foundIrritants[iSuppress].isAnySet(tokenIrritants))) { // if irritant had no matching problem
+											if (unusedWarningTokenIsWarning) {
+												int start = value.sourceStart, end = value.sourceEnd;
+												nextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {
+													long position = this.suppressWarningScopePositions[jSuppress];
+													int startSuppress = (int) (position >>> 32);
+													int endSuppress = (int) position;
+													if (start < startSuppress) continue nextSuppress;
+													if (end > endSuppress) continue nextSuppress;
+													if (this.suppressWarningIrritants[jSuppress].areAllSet()) break pairLoop; // suppress all?
+												}
+											}
+											int id = options.getIgnoredIrritant(tokenIrritants);
+											if (id > 0) {
+												String key = CompilerOptions.optionKeyFromIrritant(id);
+												this.scope.problemReporter().problemNotAnalysed(value, key);
+											} else {
+												this.scope.problemReporter().unusedWarningToken(value);
 											}
 										}
-										this.scope.problemReporter().unusedWarningToken(value);
 									}
 								}
 							}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 9328f1f..b53db57 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1270,6 +1270,22 @@ public class CompilerOptions {
 		return this.warningThreshold.isAnySet(irritants) || this.errorThreshold.isAnySet(irritants)
 					|| this.infoThreshold.isAnySet(irritants);
 	}
+	/*
+	 * Just return the first irritant id that is set to 'ignored'.
+	 */
+	public int getIgnoredIrritant(IrritantSet irritants) {
+		int[] bits = irritants.getBits();
+		for (int i = 0; i < IrritantSet.GROUP_MAX; i++) {
+			int bit = bits[i];
+			if (bit > 0) {
+				bit |= (i << IrritantSet.GROUP_SHIFT);
+				if (!(this.warningThreshold.isSet(bit) || this.errorThreshold.isSet(bit) || this.infoThreshold.isSet(bit))) {
+					return bit;
+				}
+			}
+		}
+		return 0;
+	}
 
 	protected void resetDefaults() {
 		// problem default severities defined on IrritantSet
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 54f524d..280a502 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -259,7 +259,9 @@ public class IrritantSet {
 		int group = (singleGroupIrritants & GROUP_MASK) >> GROUP_SHIFT;
 		return (this.bits[group] & singleGroupIrritants) != 0;
 	}
-
+	public int[] getBits() {
+		return this.bits;
+	}
 	public IrritantSet set(int singleGroupIrritants) {
 		int group = (singleGroupIrritants & GROUP_MASK) >> GROUP_SHIFT;
 		this.bits[group] |= (singleGroupIrritants & ~GROUP_MASK); // erase the group bits
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 762c83d..f139e72 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -1589,6 +1589,8 @@ public int computeSeverity(int problemID){
 			return ProblemSeverities.Warning;
 		case IProblem.IllegalUseOfUnderscoreAsAnIdentifier:
 			return this.underScoreIsLambdaParameter ? ProblemSeverities.Error : ProblemSeverities.Warning;
+		case IProblem.ProblemNotAnalysed:
+			return ProblemSeverities.Info; // Not configurable
 	}
 	int irritant = getIrritant(problemID);
 	if (irritant != 0) {
@@ -8960,6 +8962,14 @@ public void unusedWarningToken(Expression token) {
 		token.sourceStart,
 		token.sourceEnd);
 }
+public void problemNotAnalysed(Expression token, String optionKey) {
+	this.handle(
+		IProblem.ProblemNotAnalysed,
+		optionKey != null ? new String[]{optionKey} : new String[]{},
+		new String[] { token.constant.stringValue() },
+		token.sourceStart,
+		token.sourceEnd);
+}
 public void useAssertAsAnIdentifier(int sourceStart, int sourceEnd) {
 	this.handle(
 		IProblem.UseAssertAsAnIdentifier,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 86acbe5..82f4734 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -863,6 +863,8 @@
 1061 = The nullness annotation ''{0}'' is not applicable at this location, it must be placed directly before the nested type name.
 
 1100 = Problem detected during type inference: {0}
+#1101 is already used up but deprecated
+1102 = At least one of the problems in category ''{0}'' is not analysed due to a compiler option being ignored
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
commit d4a42e338d4b7a3675ded36e4f113e216c85af03
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Nov 24 23:10:33 2016 +0100

    Bug 506888 - Unused @SuppressWarnings("incomplete-switch") not reported
    - fixed passing of optionId to UI
    - fixed mapping of UnusedDeclaredThrownException
    - opportunistically exclude MissingNonNullByDefaultAnnotation
    - follow-up adjustments in tests
    
    
    Change-Id: I645a394946b8f496c0905f193f2939308a8e2424
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>

18	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
67	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ResourceLeakTests.java
10	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
index 2db2c29..ee6196c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
@@ -82,6 +82,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
@@ -1152,6 +1153,23 @@ protected static class JavacTestOptions {
 		return defaultOptions;
 	}
 
+	protected void enableAllWarningsForIrritants(Map<String, String> options, IrritantSet irritants) {
+		int[] bits = irritants.getBits();
+		for (int i = 0; i < bits.length; i++) {
+			int bit = bits[i];
+			for (int b = 0; b < IrritantSet.GROUP_SHIFT; b++) {
+				int single = bit & (1 << b);
+				if (single != 0) {
+					single |= (i<<IrritantSet.GROUP_SHIFT);
+					if (single == CompilerOptions.MissingNonNullByDefaultAnnotation)
+						continue;
+					String optionKey = CompilerOptions.optionKeyFromIrritant(single);
+					options.put(optionKey, CompilerOptions.WARNING);
+				}
+			}
+		}
+	}
+
 	protected String[] getDefaultClassPaths() {
 		return DefaultJavaRuntimeEnvironment.getDefaultClassPaths();
 	}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index 060df16..b2244d9 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -34,10 +34,14 @@ import java.util.Map;
 
 import junit.framework.Test;
 
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.ToolFactory;
+import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.Compiler;
+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
 import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
 import org.eclipse.jdt.internal.compiler.IProblemFactory;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -49,6 +53,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
@@ -7689,6 +7694,7 @@ public void test229() {
 public void test230() {
 	Map options = getCompilerOptions();
 	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.ERROR);
+	enableAllWarningsForIrritants(options, IrritantSet.UNUSED);
 	this.runNegativeTest(
 		true,
 		new String[] {
@@ -7727,6 +7733,7 @@ public void test230() {
 public void test231() {
 	Map options = getCompilerOptions();
 	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.ERROR);
+	enableAllWarningsForIrritants(options, IrritantSet.UNUSED);
 	this.runNegativeTest(
 		true,
 		new String[] {
@@ -8119,6 +8126,7 @@ public void test245() {
 	options.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.IGNORE);
 	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
 	options.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.WARNING);
+	enableAllWarningsForIrritants(options, IrritantSet.UNUSED);
 	this.runNegativeTest(
 		true,
 		new String[] {
@@ -10199,6 +10207,7 @@ public void testBug366003e() {
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=365437
 public void testBug365437a() {
 	Map customOptions = getCompilerOptions();
+	enableAllWarningsForIrritants(customOptions, IrritantSet.NULL);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	String testFiles [] = new String[] {
 			"p/A.java",
@@ -10297,6 +10306,7 @@ public void testBug365437b() {
 public void testBug365437c() {
 	if (this.complianceLevel < ClassFileConstants.JDK1_7) return;
 	Map customOptions = getCompilerOptions();
+	enableAllWarningsForIrritants(customOptions, IrritantSet.NULL);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	String testFiles [] = new String[] {
 			"p/A.java",
@@ -10346,6 +10356,7 @@ public void testBug365437c() {
 // unused constructor
 public void testBug365437d() {
 	Map customOptions = getCompilerOptions();
+	enableAllWarningsForIrritants(customOptions, IrritantSet.NULL);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_AnnotationBasedNullAnalysis, CompilerOptions.ENABLED);
@@ -10425,6 +10436,7 @@ public void testBug365437d() {
 // unused field
 public void testBug365437e() {
 	Map customOptions = getCompilerOptions();
+	enableAllWarningsForIrritants(customOptions, IrritantSet.NULL);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_AnnotationBasedNullAnalysis, CompilerOptions.ENABLED);
@@ -10497,6 +10509,7 @@ public void testBug365437e() {
 // unused type
 public void testBug365437f() {
 	Map customOptions = getCompilerOptions();
+	enableAllWarningsForIrritants(customOptions, IrritantSet.NULL);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
 	customOptions.put(CompilerOptions.OPTION_AnnotationBasedNullAnalysis, CompilerOptions.ENABLED);
@@ -11770,4 +11783,58 @@ public void testBug506888e() throws Exception {
 		"", 
 		null, true, options);
 }
+public void testBug506888f() throws Exception {
+
+	class MyCompilerRequestor implements ICompilerRequestor {
+		String[] problemArguments = null;
+
+		@Override
+		public void acceptResult(CompilationResult result) {
+			for (CategorizedProblem problem : result.getAllProblems()) {
+				String[] arguments = problem.getArguments();
+				if (arguments != null && arguments.length > 0) {
+					this.problemArguments = arguments;
+					return;
+				}
+			}
+		}
+	}
+
+	if (this.complianceLevel <= ClassFileConstants.JDK1_5) {
+		return;
+	}
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportUnusedWarningToken, CompilerOptions.ERROR);
+	options.put(CompilerOptions.OPTION_ReportUnusedDeclaredThrownException, CompilerOptions.IGNORE);
+	options.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.WARNING);
+	MyCompilerRequestor requestor = new MyCompilerRequestor();
+	runTest(new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	\n" +
+				"	@SuppressWarnings({\"unused\"})\n" +
+				"	void foo() {\n" +
+				"	}\n" +
+				"}	\n",
+			},
+			false,
+			"----------\n" + 
+			"1. INFO in X.java (at line 3)\n" + 
+			"	@SuppressWarnings({\"unused\"})\n" + 
+			"	                   ^^^^^^^^\n" + 
+			"At least one of the problems in category \'unused\' is not analysed due to a compiler option being ignored\n" + 
+			"----------\n",
+			"" /*expectedOutputString */,
+			"" /* expectedErrorString */,
+			false /* forceExecution */,
+			null /* classLib */,
+			true /* shouldFlushOutputDirectory */,
+			null /* vmArguments */,
+			options,
+			new Requestor(true, requestor, false, true),
+			JavacTestOptions.DEFAULT);
+	assertNotNull(requestor.problemArguments);
+	assertEquals(1, requestor.problemArguments.length);
+	assertEquals(JavaCore.COMPILER_PB_UNUSED_PARAMETER, requestor.problemArguments[0]);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index a6b7201..a5d68e3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -11668,7 +11668,7 @@ public void test299(){
 		"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 2)\n" + 
 		"	@SuppressWarnings(\"unused\")\n" + 
 		"	                  ^^^^^^^^\n" + 
-		"Unnecessary @SuppressWarnings(\"unused\")\n" + 
+		"At least one of the problems in category 'unused' is not analysed due to a compiler option being ignored\n" + 
 		"----------\n" + 
 		"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n" + 
 		"	private int i;\n" + 
@@ -11759,7 +11759,7 @@ public void test303(){
 		"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 2)\n" + 
 		"	@SuppressWarnings(\"unused\")\n" + 
 		"	                  ^^^^^^^^\n" + 
-		"Unnecessary @SuppressWarnings(\"unused\")\n" + 
+		"At least one of the problems in category 'unused' is not analysed due to a compiler option being ignored\n" + 
 		"----------\n" + 
 		"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n" + 
 		"	private int i;\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index fe3f0ac..4c28907 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1905,10 +1905,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UnsafeTypeConversion", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("UnterminatedComment", SKIP);
 		expectedProblemAttributes.put("UnterminatedString", SKIP);
-		expectedProblemAttributes.put("UnusedConstructorDeclaredThrownException", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_DECLARED_THROWN_EXCEPTION_WHEN_OVERRIDING));
+		expectedProblemAttributes.put("UnusedConstructorDeclaredThrownException", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_DECLARED_THROWN_EXCEPTION));
 		expectedProblemAttributes.put("UnusedImport", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_IMPORT));
 		expectedProblemAttributes.put("UnusedLabel", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_LABEL));
-		expectedProblemAttributes.put("UnusedMethodDeclaredThrownException", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_DECLARED_THROWN_EXCEPTION_WHEN_OVERRIDING));
+		expectedProblemAttributes.put("UnusedMethodDeclaredThrownException", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_DECLARED_THROWN_EXCEPTION));
 		expectedProblemAttributes.put("UnusedObjectAllocation", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_OBJECT_ALLOCATION));
 		expectedProblemAttributes.put("UnusedPrivateConstructor", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_PRIVATE_MEMBER));
 		expectedProblemAttributes.put("UnusedPrivateField", new ProblemAttributes(JavaCore.COMPILER_PB_UNUSED_PRIVATE_MEMBER));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ResourceLeakTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ResourceLeakTests.java
index 055ab74..3939590 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ResourceLeakTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ResourceLeakTests.java
@@ -24,6 +24,7 @@ import org.eclipse.core.runtime.Platform;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.impl.IrritantSet;
 
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class ResourceLeakTests extends AbstractRegressionTest {
@@ -266,6 +267,7 @@ public void test056d() {
 public void test056d_suppress() {
 	if (this.complianceLevel < ClassFileConstants.JDK1_5) return; // annotations used
 	Map options = getCompilerOptions();
+	enableAllWarningsForIrritants(options, IrritantSet.RESOURCE);
 	options.put(CompilerOptions.OPTION_ReportUnclosedCloseable, CompilerOptions.ERROR);
 	options.put(CompilerOptions.OPTION_ReportPotentiallyUnclosedCloseable, CompilerOptions.WARNING);
 	options.put(CompilerOptions.OPTION_SuppressOptionalErrors, CompilerOptions.ENABLED);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index b53db57..22c2272 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -607,7 +607,7 @@ public class CompilerOptions {
 			case UnqualifiedFieldAccess :
 				return OPTION_ReportUnqualifiedFieldAccess;
 			case UnusedDeclaredThrownException :
-				return OPTION_ReportUnusedDeclaredThrownExceptionWhenOverriding;
+				return OPTION_ReportUnusedDeclaredThrownException;
 			case FinallyBlockNotCompleting :
 				return OPTION_ReportFinallyBlockNotCompletingNormally;
 			case InvalidJavadoc :
@@ -1277,10 +1277,15 @@ public class CompilerOptions {
 		int[] bits = irritants.getBits();
 		for (int i = 0; i < IrritantSet.GROUP_MAX; i++) {
 			int bit = bits[i];
-			if (bit > 0) {
-				bit |= (i << IrritantSet.GROUP_SHIFT);
-				if (!(this.warningThreshold.isSet(bit) || this.errorThreshold.isSet(bit) || this.infoThreshold.isSet(bit))) {
-					return bit;
+			for (int b = 0; b < IrritantSet.GROUP_SHIFT; b++) {
+				int single = bit & (1 << b);
+				if (single > 0) {
+					single |= (i << IrritantSet.GROUP_SHIFT);
+					if (single == MissingNonNullByDefaultAnnotation)
+						continue;
+					if (!(this.warningThreshold.isSet(single) || this.errorThreshold.isSet(single) || this.infoThreshold.isSet(single))) {
+						return single;
+					}
 				}
 			}
 		}
commit 3326525029387a18844224f1aad80e29503cdd5b
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Mar 27 14:34:17 2017 +0530

    Bug 506888 - Unused @SuppressWarnings("incomplete-switch") not reported
    
    IProblem.ProblemNotAnalysed should be categorized as unnecessary code.
    
    Change-Id: If6151f7d109664a4bc203fb9931e0651f6e42cc3
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index fad307e..bd2c172 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1104,7 +1104,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("lambdaSignatureMismatched", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalArrayOfUnionType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalArrayTypeInIntersectionCast", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
-		expectedProblemAttributes.put("ProblemNotAnalysed", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("ProblemNotAnalysed", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		StringBuffer failures = new StringBuffer();
 		StringBuffer correctResult = new StringBuffer(70000);
 		Field[] fields = (iProblemClass = IProblem.class).getFields();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 0dc2f7d..d1b542d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -743,7 +743,8 @@ public static int getProblemCategory(int severity, int problemID) {
 		case IProblem.IsClassPathCorrect :
 		case IProblem.CorruptedSignature :
 			return CategorizedProblem.CAT_BUILDPATH;
-
+		case IProblem.ProblemNotAnalysed :
+			return CategorizedProblem.CAT_UNNECESSARY_CODE;
 		default :
 			if ((problemID & IProblem.Syntax) != 0)
 				return CategorizedProblem.CAT_SYNTAX;
