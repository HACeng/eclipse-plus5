commit efbb87073d9dbcb7374efd4fcb6785889c57a494
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Tue Dec 20 18:20:59 2016 +0530

    Fix for bug 496123 Fix for bug 496123 Fix for bug 496123 [9] DOM AST for
    ModuleDeclaration in module-info.java - conversion part
    
    Change-Id: I19f18629a96d5422fe5890259858081810b43529

45	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
14	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
80	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
154	45	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
157	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
80	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
184	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
86	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
126	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
329	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
207	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
36	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
125	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
224	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
251	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
188	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
83	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index c5220c2..c3dde4f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -130,7 +130,50 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			checkSourceRange(fieldAccess, "this.y2", contents);
 			expr = resources.get(5);
 			VariableDeclarationExpression variableDeclarationExpression = (VariableDeclarationExpression) expr;
-			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);			
+			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);
 	}
-
+	public void testBug496123_0001() throws JavaModelException {
+		this.workingCopies = new ICompilationUnit[1];
+		String content =  "module first {"
+				+ "  requires second;\n"
+				+ "  exports pack11 to third, fourth;\n"
+				+ "  uses NewType;\n"
+				+ "  provides pack22.I22 with pack11.packinternal.Z11;\n"
+				+ "}";
+		this.workingCopies[0] = getWorkingCopy(
+				"/Converter9/src/module-info.java", content);
+		
+		CompilationUnit unit = (CompilationUnit) runConversion(AST.JLS9, this.workingCopies[0], false/*no bindings*/);
+		ModuleDeclaration moduleDecl = unit.getModule();
+		
+		checkSourceRange(moduleDecl, content, content);
+		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		assertTrue(stmts.size() > 0);
+		
+		RequiresStatement req = (RequiresStatement) stmts.get(0);
+		checkSourceRange(req, "requires second;", content);
+		
+		ExportsStatement exp = (ExportsStatement) stmts.get(1);
+		checkSourceRange(exp, "exports pack11 to third, fourth;", content);
+		checkSourceRange(exp.getName(), "pack11", content);
+		List<Name> modules = exp.modules();
+		assertTrue(modules.size() == 2);
+		checkSourceRange(modules.get(0), "third", content);
+		checkSourceRange(modules.get(1), "fourth", content);
+		
+		UsesStatement u = (UsesStatement) stmts.get(2);
+		checkSourceRange(u, "uses NewType;", content);
+		Type type = u.getType();
+		checkSourceRange(type, "NewType", content);
+		
+		ProvidesStatement p = (ProvidesStatement) stmts.get(3);
+		checkSourceRange(p, "provides pack22.I22 with pack11.packinternal.Z11;", content);
+		type = p.getType();
+		checkSourceRange(type, "pack22.I22", content);
+		List<Type> impls = p.implementations();
+		assertTrue(impls.size() > 0);
+		type = impls.get(0);
+		checkSourceRange(type, "pack11.packinternal.Z11", content);		
+	}
+// Add new tests here 
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index 3909178..29fa62f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2015 IBM Corporation and others.
+ * Copyright (c) 2004, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -369,7 +373,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 92, hi); // last known one
+		assertEquals("Wrong last known type", 98, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 4830f26..5c481ef 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -8847,14 +8851,20 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			ASTNode.CREATION_REFERENCE,
 			ASTNode.EXPRESSION_METHOD_REFERENCE,
 			ASTNode.SUPER_METHOD_REFERENCE,
-			ASTNode.TYPE_METHOD_REFERENCE
+			ASTNode.TYPE_METHOD_REFERENCE,
+			ASTNode.MODULE_DECLARATION,
+			ASTNode.EXPORTS_STATEMENT,
+			ASTNode.REQUIRES_STATEMENT,
+			ASTNode.USES_STATEMENT,
+			ASTNode.PROVIDES_STATEMENT,
+			ASTNode.OPENS_STATEMENT
 		};
-		
+
 		// assert that nodeType values are correct:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			assertSame(i + 1, nodeTypes[i]);
 		}
-		
+
 		// test nodeClassForType:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			int nodeType = nodeTypes[i];
@@ -8862,7 +8872,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			try {
 				node = this.ast.createInstance(nodeType);
 			} catch (IllegalArgumentException e) {
-				if (this.API_LEVEL < getJLS8() && e.getCause() instanceof UnsupportedOperationException) {
+				if (this.API_LEVEL < AST.JLS9 && e.getCause() instanceof UnsupportedOperationException) {
 					continue;
 				} else {
 					throw new AssertionFailedError("missing node type: " + nodeType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
index ab16c1b..aedd896 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
@@ -48,6 +48,12 @@ public final class CharOperation {
 	 */
 	public static final char[] ALL_PREFIX = new char[] {'*'};
 
+	/**
+	 * Constant for comma
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final char[] COMMA_SEPARATOR = new char[] {','};
+
 /**
  * Answers a new array with appending the suffix character at the end of the array.
  * <br>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index a4133ae..77a7ad8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
@@ -199,7 +203,8 @@ public class Scanner implements TerminalTokens {
 	private VanguardParser vanguardParser;
 	ConflictedParser activeParser = null;
 	private boolean consumingEllipsisAnnotations = false;
-	
+	public boolean fakeInModule = false;
+
 	public static final int RoundBracket = 0;
 	public static final int SquareBracket = 1;
 	public static final int CurlyBracket = 2;
@@ -2531,6 +2536,7 @@ final char[] optimizedCurrentTokenSource6() {
 	return table[this.newEntry6 = max] = r; //(r = new char[] {c0, c1, c2, c3, c4, c5});
 }
 private boolean isInModuleDeclaration() {
+	if (this.fakeInModule) return true;
 	return this.activeParser != null ? this.activeParser.isParsingModuleDeclaration() : false;
 }
 private void parseTags() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 9948fdc..34f4984 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -239,6 +239,10 @@ public class Util implements SuffixConstants {
 	public static final String LINE_SEPARATOR = System.getProperty("line.separator"); //$NON-NLS-1$
 
 	public static final String EMPTY_STRING = new String(CharOperation.NO_CHAR);
+	/**
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final String COMMA_SEPARATOR = new String(CharOperation.COMMA_SEPARATOR);
 	public static final int[] EMPTY_INT_ARRAY= new int[0];
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 4232757..ca977c9 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1504,10 +1504,23 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented exports statement
+	 * node for an unspecified, but legal, name; no target modules
+	 *
+	 * @return a new unparented exports statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ExportsStatement newExportsStatement() {
+		ExportsStatement result = new ExportsStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates an unparented expression method reference node owned by this AST.
 	 * By default, the expression and method name are unspecified (but legal),
 	 * and there are no type arguments.
-	 * 
+	 *
 	 * @return a new unparented expression method reference expression node
 	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
 	 * @since 3.10
@@ -1924,6 +1937,20 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented module declaration
+	 * node for an unspecified, but legal, name; no modifiers; no javadoc;
+	 * and an empty list of statements.
+	 *
+	 * @return a new unparented module declaration node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ModuleDeclaration newModuleDeclaration() {
+		ModuleDeclaration result = new ModuleDeclaration(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented name node for the given name.
 	 * The name string must consist of 1 or more name segments separated
 	 * by single dots '.'. Returns a {@link QualifiedName} if the name has
@@ -2087,6 +2114,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented opens statement
+	 * node for an unspecified, but legal, name; no target modules
+	 *
+	 * @return a new unparented opens statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public OpensStatement newOpensStatement() {
+		OpensStatement result = new OpensStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates an unparented package declaration node owned by this AST.
 	 * The package declaration initially declares a package with an
 	 * unspecified name.
@@ -2170,6 +2210,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented provides statement
+	 * node for an unspecified, but legal, type; no target types
+	 *
+	 * @return a new unparented provides statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ProvidesStatement newProvidesStatement() {
+		ProvidesStatement result = new ProvidesStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented qualified name node for the given
 	 * qualifier and simple name child node.
 	 *
@@ -2216,6 +2269,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented requires statement
+	 * node for an unspecified, but legal, name;
+	 *
+	 * @return a new unparented requires statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public RequiresStatement newRequiresStatement() {
+		RequiresStatement result = new RequiresStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates a new unparented return statement node owned by this AST.
 	 * By default, the return statement has no expression.
 	 *
@@ -2583,6 +2649,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented uses statement
+	 * node for an unspecified, but legal, name;
+	 *
+	 * @return a new unparented uses statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public UsesStatement newUsesStatement() {
+		UsesStatement result = new UsesStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates a new unparented intersection type node owned by this AST.
 	 * By default, the intersection type has no types.
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index c20728c..e2049a0 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -17,11 +17,13 @@
 
 package org.eclipse.jdt.core.dom;
 
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
@@ -42,6 +44,7 @@ import org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
@@ -1380,12 +1383,15 @@ class ASTConverter {
 					if (type == null) {
 						compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
 					} else {
-						compilationUnit.types().add(type);
+						if (type instanceof ModuleDeclaration)
+							compilationUnit.setModule((ModuleDeclaration) type);
+						else
+							compilationUnit.types().add(type);
 					}
 				}
 			}
 			compilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);
-	
+
 			int problemLength = unit.compilationResult.problemCount;
 			if (problemLength != 0) {
 				CategorizedProblem[] resizedProblems = null;
@@ -1684,6 +1690,24 @@ class ASTConverter {
 		return newStatement;
 	}
 
+	private ModulePackageAccess getPackageVisibilityStatement(
+			org.eclipse.jdt.internal.compiler.ast.PackageVisibilityStatement pvsStmt, ModulePackageAccess stmt) {
+		int sourceEnd = pvsStmt.declarationSourceEnd;
+		if (pvsStmt.declarationEnd > sourceEnd) sourceEnd = pvsStmt.declarationEnd; // TODO: working around a compiler issue
+		stmt.setName(getUpdatedSimpleName(pvsStmt.pkgName, pvsStmt.pkgRef.sourceStart, pvsStmt.pkgRef.sourceEnd));
+		int tmp = sourceEnd;
+		if (pvsStmt.targets != null && pvsStmt.targets.length > 0) {
+			List<Name> modules = stmt.modules();
+			for (ModuleReference moduleRef : pvsStmt.getTargetedModules()) {
+				modules.add(getUpdatedSimpleName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd));
+				if (tmp < moduleRef.sourceEnd) tmp = moduleRef.sourceEnd;
+			}
+		}
+		if (tmp > sourceEnd) sourceEnd = tmp;
+		stmt.setSourceRange(pvsStmt.declarationSourceStart, sourceEnd - pvsStmt.declarationSourceStart + 1);			
+		return stmt;
+	}
+
 	public Expression convert(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		if ((expression.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) != 0) {
 			return convertToParenthesizedExpression(expression);
@@ -2005,54 +2029,50 @@ class ASTConverter {
 		return literal;
 	}
 
-	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
-		if (bodyDeclaration.getJavadoc() == null) {
-			if (javadoc != null) {
-				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
-					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
-				}
-				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
-				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
-					Javadoc docComment = (Javadoc) comment;
-					if (this.resolveBindings) {
-						recordNodes(docComment, javadoc);
-						// resolve member and method references binding
-						Iterator tags = docComment.tags().listIterator();
-						while (tags.hasNext()) {
-							recordNodes(javadoc, (TagElement) tags.next());
-						}
+	interface IGetJavaDoc {
+		Javadoc getJavaDoc();
+	}
+	interface ISetJavaDoc {
+		void setJavadoc(Javadoc javadoc);
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, IGetJavaDoc getJ, ISetJavaDoc setJ) {
+		if (getJ.getJavaDoc() == null) {
+			Javadoc docComment = convert(javadoc);
+			if (docComment != null) 
+				setJ.setJavadoc(docComment);
+		}
+	}
+	private Javadoc convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc) {
+		Javadoc docComment = null;
+		if (javadoc != null) {
+			if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
+				this.commentMapper = new DefaultCommentMapper(this.commentsTable);
+			}
+			Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
+			if (comment != null && comment.isDocComment() && comment.getParent() == null) {
+				docComment = (Javadoc) comment;
+				if (this.resolveBindings) {
+					recordNodes(docComment, javadoc);
+					// resolve member and method references binding
+					Iterator tags = docComment.tags().listIterator();
+					while (tags.hasNext()) {
+						recordNodes(javadoc, (TagElement) tags.next());
 					}
-					bodyDeclaration.setJavadoc(docComment);
 				}
 			}
 		}
+		return docComment;
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
+		convert(javadoc, bodyDeclaration::getJavadoc, bodyDeclaration::setJavadoc);
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, ModuleDeclaration moduleDeclaration) {
+		convert(javadoc, moduleDeclaration::getJavadoc, moduleDeclaration::setJavadoc);
 	}
 
 	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, PackageDeclaration packageDeclaration) {
-		switch(this.ast.apiLevel) {
-			case AST.JLS2_INTERNAL :
-				return;
-		}
-		if (packageDeclaration.getJavadoc() == null) {
-			if (javadoc != null) {
-				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
-					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
-				}
-				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
-				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
-					Javadoc docComment = (Javadoc) comment;
-					if (this.resolveBindings) {
-						recordNodes(docComment, javadoc);
-						// resolve member and method references binding
-						Iterator tags = docComment.tags().listIterator();
-						while (tags.hasNext()) {
-							recordNodes(javadoc, (TagElement) tags.next());
-						}
-					}
-					packageDeclaration.setJavadoc(docComment);
-				}
-			}
-		}
+		if (this.ast.apiLevel == AST.JLS2_INTERNAL) return;
+		convert(javadoc, packageDeclaration::getJavadoc, packageDeclaration::setJavadoc);
 	}
 
 	public LabeledStatement convert(org.eclipse.jdt.internal.compiler.ast.LabeledStatement statement) {
@@ -2936,6 +2956,8 @@ class ASTConverter {
 				} else {
 					return convertToAnnotationDeclaration(typeDeclaration);
 				}
+			case org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.MODULE_DECL :
+				return convertToModuleDeclaration(typeDeclaration);
 		}
 
 		checkCanceled();
@@ -3253,6 +3275,81 @@ class ASTConverter {
 		return fieldDeclaration;
 	}
 
+	public ModuleDeclaration convertToModuleDeclaration(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
+		checkCanceled();
+		if (this.scanner.sourceLevel < ClassFileConstants.JDK9) return null;
+		org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) typeDeclaration;
+		ModuleDeclaration moduleDecl = this.ast.newModuleDeclaration();
+		convert(moduleDeclaration.javadoc, moduleDecl);
+		setModifiers(moduleDecl, moduleDeclaration);
+		SimpleName moduleName = getUpdatedSimpleName(moduleDeclaration.moduleName, moduleDeclaration.sourceStart, moduleDeclaration.sourceEnd);
+		moduleDecl.setName(moduleName);
+		moduleDecl.setSourceRange(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd - moduleDeclaration.declarationSourceStart + 1);
+
+		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		TreeSet<ModuleStatement> tSet = new TreeSet<> (new Comparator() {
+			public int compare(Object o1, Object o2) {
+				int p1 = ((ModuleStatement) o1).getStartPosition();
+				int p2 = ((ModuleStatement) o2).getStartPosition();
+				return p1 < p2 ? -1 : p1 == p2 ? 0 : 1;
+			}
+		});
+		for (int i = 0; i < moduleDeclaration.exportsCount; ++i) {
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.exports[i], new ExportsStatement(this.ast)));
+		}
+		for (int i = 0; i < moduleDeclaration.opensCount; ++i) {
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.opens[i], new OpensStatement(this.ast)));
+		}
+		for (int i = 0; i < moduleDeclaration.requiresCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.RequiresStatement req = moduleDeclaration.requires[i];
+			ModuleReference moduleRef = req.module;
+			RequiresStatement stmt = new RequiresStatement(this.ast);
+			SimpleName name = getUpdatedSimpleName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd);
+			stmt.setName(name);
+
+			addModifierToRequires(req, req.isTransitive(), Modifier.ModifierKeyword.TRANSIENT_KEYWORD, stmt);
+			addModifierToRequires(req, req.isStatic(), Modifier.ModifierKeyword.STATIC_KEYWORD, stmt);
+			stmt.setSourceRange(req.declarationSourceStart, req.declarationEnd - req.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		for (int i = 0; i < moduleDeclaration.usesCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.UsesStatement usesStatement = moduleDeclaration.uses[i];
+			UsesStatement stmt = new UsesStatement(this.ast);
+			TypeReference usesRef = usesStatement.serviceInterface;
+			stmt.setType(convertType(usesRef));
+			stmt.setSourceRange(usesStatement.declarationSourceStart, usesStatement.declarationSourceEnd - usesStatement.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		for (int i = 0; i < moduleDeclaration.servicesCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.ProvidesStatement pStmt = moduleDeclaration.services[i];
+			ProvidesStatement stmt = new ProvidesStatement(this.ast);
+			stmt.setType(convertType(pStmt.serviceInterface));
+			TypeReference[] impls = pStmt.implementations;
+			for (TypeReference impl : impls) {
+				stmt.implementations().add(convertType(impl));
+			}
+			stmt.setSourceRange(pStmt.declarationSourceStart, pStmt.declarationEnd - pStmt.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		// The javadoc comment is now got from 	list store in compilation unit declaration
+		if (this.resolveBindings) {
+			recordNodes(moduleDecl, moduleDeclaration);
+			recordNodes(moduleName, moduleDeclaration);
+			// moduleDecl.resolveBinding(); TODO: Implement resolveBinding
+		}
+		stmts.addAll(tSet);
+		return moduleDecl;
+	}
+
+	private void addModifierToRequires(org.eclipse.jdt.internal.compiler.ast.RequiresStatement req, boolean flag, Modifier.ModifierKeyword keyword,
+			RequiresStatement stmt) {
+		if (flag) {
+			Modifier modifier = createModifier(keyword);
+			modifier.setSourceRange(req.modifiersSourceStart, keyword.toString().length());
+			stmt.modifiers().add(modifier);
+		}
+	}
+
 	public ParenthesizedExpression convertToParenthesizedExpression(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		final ParenthesizedExpression parenthesizedExpression = new ParenthesizedExpression(this.ast);
 		if (this.resolveBindings) {
@@ -4272,7 +4369,12 @@ class ASTConverter {
 		}
 		return false;
 	}
-
+	private SimpleName getUpdatedSimpleName(char[] s, int sourceStart, int sourceEnd) {
+		SimpleName name = new SimpleName(this.ast);
+		name.setIdentifier(new String(s));
+		name.setSourceRange(sourceStart, sourceEnd - sourceStart  + 1);
+		return name;
+	}
 	private void lookupForScopes() {
 		if (this.pendingNameScopeResolution != null) {
 			for (Iterator iterator = this.pendingNameScopeResolution.iterator(); iterator.hasNext(); ) {
@@ -5024,6 +5126,9 @@ class ASTConverter {
 	 * @param bodyDeclaration
 	 */
 	protected void setModifiers(BodyDeclaration bodyDeclaration, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
+		setModifiers(bodyDeclaration.modifiers(), annotations, modifiersEnd);
+	}
+	protected void setModifiers(List modifiers, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
 		this.scanner.tokenizeWhiteSpace = false;
 		try {
 			int token;
@@ -5084,7 +5189,7 @@ class ASTConverter {
 						break;
 				}
 				if (modifier != null) {
-					bodyDeclaration.modifiers().add(modifier);
+					modifiers.add(modifier);
 				}
 			}
 		} catch(InvalidInputException e) {
@@ -5164,6 +5269,10 @@ class ASTConverter {
 		}
 	}
 
+	protected void setModifiers(ModuleDeclaration moduleDecl, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
+		this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
+		this.setModifiers(moduleDecl.modifiers(), typeDeclaration.annotations, typeDeclaration.sourceStart);
+	}
 	/**
 	 * @param variableDecl
 	 * @param argument
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 070bb52..d0552d2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -615,7 +619,8 @@ public class ASTMatcher {
 		}
 		CompilationUnit o = (CompilationUnit) other;
 		return (
-			safeSubtreeMatch(node.getPackage(), o.getPackage())
+			safeSubtreeMatch(node.getModule(), o.getModule())
+				&& safeSubtreeMatch(node.getPackage(), o.getPackage())
 				&& safeSubtreeListMatch(node.imports(), o.imports())
 				&& safeSubtreeListMatch(node.types(), o.types()));
 	}
@@ -887,6 +892,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(ExportsStatement node, Object other) {
+		if (!(other instanceof ExportsStatement)) {
+			return false;
+		}
+		ExportsStatement o = (ExportsStatement) other;
+		return (
+			safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.modules(), o.modules()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(ExpressionMethodReference node, Object other) {
@@ -1553,6 +1583,32 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(ModuleDeclaration node, Object other) {
+		if (!(other instanceof ModuleDeclaration)) {
+			return false;
+		}
+		ModuleDeclaration o = (ModuleDeclaration) other;
+		return (safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
+				&& safeSubtreeListMatch(node.modifiers(), o.modifiers())
+				&& safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.moduleStatements(), o.moduleStatements()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(NameQualifiedType node, Object other) {
@@ -1645,6 +1701,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(OpensStatement node, Object other) {
+		if (!(other instanceof OpensStatement)) {
+			return false;
+		}
+		OpensStatement o = (OpensStatement) other;
+		return (
+			safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.modules(), o.modules()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(PackageDeclaration node, Object other) {
 		if (!(other instanceof PackageDeclaration)) {
@@ -1793,6 +1874,32 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+
+	 */
+	public boolean match(ProvidesStatement node, Object other) {
+		if (!(other instanceof ProvidesStatement)) {
+			return false;
+		}
+		ProvidesStatement o = (ProvidesStatement) other;
+		return (
+				safeSubtreeMatch(node.getType(), o.getType())
+				&& safeSubtreeListMatch(node.implementations(), o.implementations()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(QualifiedName node, Object other) {
 		if (!(other instanceof QualifiedName)) {
@@ -1842,6 +1949,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 *
+	 *   @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(RequiresStatement node, Object other) {
+		if (!(other instanceof RequiresStatement)) {
+			return false;
+		}
+		RequiresStatement o = (RequiresStatement) other;
+		return safeSubtreeListMatch(node.modifiers(), o.modifiers())
+				&& safeSubtreeMatch(node.getName(), o.getName());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(ReturnStatement node, Object other) {
 		if (!(other instanceof ReturnStatement)) {
@@ -2465,6 +2597,29 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(UsesStatement node, Object other) {
+		if (!(other instanceof UnionType)) {
+			return false;
+		}
+		UsesStatement o = (UsesStatement) other;
+		return safeSubtreeMatch(node.getType(), o.getType());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(VariableDeclarationExpression node, Object other) {
 		if (!(other instanceof VariableDeclarationExpression)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index a665aed..b91d7ca 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -897,6 +901,53 @@ public abstract class ASTNode {
 	public static final int TYPE_METHOD_REFERENCE = 92;
 
 	/**
+	 * Node type constant indicating a node of type
+	 * <code>ModuleDeclaration</code>.
+	 * @see ModuleDeclaration
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int MODULE_DECLARATION = 93;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>ExportsStatement</code>.
+	 * @see ExportsStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int EXPORTS_STATEMENT = 94;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>RequiresStatement</code>.
+	 * @see RequiresStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int REQUIRES_STATEMENT = 95;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>UsesStatement</code>.
+	 * @see UsesStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int USES_STATEMENT = 96;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>ProvidesStatement</code>.
+	 * @see ProvidesStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int PROVIDES_STATEMENT = 97;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>OpensStatement</code>.
+	 * @see OpensStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int OPENS_STATEMENT = 98;
+	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
@@ -964,6 +1015,8 @@ public abstract class ASTNode {
 				return EnumConstantDeclaration.class;
 			case ENUM_DECLARATION :
 				return EnumDeclaration.class;
+			case EXPORTS_STATEMENT :
+				return ExportsStatement.class;
 			case EXPRESSION_METHOD_REFERENCE :
 				return ExpressionMethodReference.class;
 			case EXPRESSION_STATEMENT :
@@ -1010,6 +1063,8 @@ public abstract class ASTNode {
 				return MethodRefParameter.class;
 			case MODIFIER :
 				return Modifier.class;
+			case MODULE_DECLARATION :
+				return ModuleDeclaration.class;
 			case NAME_QUALIFIED_TYPE :
 				return NameQualifiedType.class;
 			case NORMAL_ANNOTATION :
@@ -1018,6 +1073,8 @@ public abstract class ASTNode {
 				return NullLiteral.class;
 			case NUMBER_LITERAL :
 				return NumberLiteral.class;
+			case OPENS_STATEMENT :
+				return OpensStatement.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
 			case PARAMETERIZED_TYPE :
@@ -1030,10 +1087,14 @@ public abstract class ASTNode {
 				return PrefixExpression.class;
 			case PRIMITIVE_TYPE :
 				return PrimitiveType.class;
+			case PROVIDES_STATEMENT :
+				return ProvidesStatement.class;
 			case QUALIFIED_NAME :
 				return QualifiedName.class;
 			case QUALIFIED_TYPE :
 				return QualifiedType.class;
+			case REQUIRES_STATEMENT :
+				return RequiresStatement.class;
 			case RETURN_STATEMENT :
 				return ReturnStatement.class;
 			case SIMPLE_NAME :
@@ -1082,6 +1143,8 @@ public abstract class ASTNode {
 				return TypeParameter.class;
 			case UNION_TYPE :
 				return UnionType.class;
+			case USES_STATEMENT :
+				return UsesStatement.class;
 			case VARIABLE_DECLARATION_EXPRESSION :
 				return VariableDeclarationExpression.class;
 			case VARIABLE_DECLARATION_FRAGMENT :
@@ -1968,14 +2031,29 @@ public abstract class ASTNode {
 			throw new UnsupportedOperationException("Operation only supported in JLS8 and later AST"); //$NON-NLS-1$
 		}
 	}
-	
+
+	/**
+     * Checks that this AST operation is not used when
+     * building JLS2, JLS3, JLS4 or JLS8 level ASTs.
+     * <p>
+     * Use this method to prevent access to new properties that have been added in JLS9.
+     * </p>
+     *
+	 * @exception UnsupportedOperationException if this operation is used below JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	final void unsupportedBelow9() {
+		if (this.ast.apiLevel < AST.JLS9) {
+			throw new UnsupportedOperationException("Operation only supported in JLS9 and later AST"); //$NON-NLS-1$
+		}
+	}
 	/**
      * Checks that this AST operation is only used when
      * building JLS2 level ASTs.
      * <p>
      * Use this method to prevent access to deprecated properties (deprecated in JLS3).
      * </p>
-     * 
+     *
 	 * @exception UnsupportedOperationException if this operation is used in an AST later than JLS2
 	 * @since 3.0
      */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index d902b9b..2e04d57 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -655,6 +659,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ExportsStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1052,6 +1073,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ModuleDeclaration node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(NameQualifiedType node) {
@@ -1111,6 +1149,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(OpensStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1192,6 +1247,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ProvidesStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1241,6 +1313,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(RequiresStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1637,6 +1726,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(UsesStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -2057,6 +2163,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ExportsStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(ExpressionMethodReference node) {
@@ -2348,6 +2467,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ModuleDeclaration node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(NameQualifiedType node) {
@@ -2398,6 +2530,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(OpensStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(PackageDeclaration node) {
 		// default implementation: do nothing
@@ -2471,6 +2616,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ProvidesStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(QualifiedName node) {
 		// default implementation: do nothing
@@ -2496,6 +2654,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(RequiresStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(ReturnStatement node) {
 		// default implementation: do nothing
@@ -2791,6 +2962,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(UsesStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(IntersectionType node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index f3d1ddc..a3a7c2a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -28,6 +32,8 @@ import org.eclipse.text.edits.TextEdit;
 
 /**
  * Java compilation unit AST node type. This is the type of the root of an AST.
+ * From JLS 9 onwards, this can contain a ModuleDeclation. To be noted that not
+ * all nodes make sense in all contexts.
  * <p>
  * The source range for this type of node is ordinarily the entire source file,
  * including leading and trailing whitespace and comments.
@@ -36,7 +42,7 @@ import org.eclipse.text.edits.TextEdit;
  * CompilationUnit:
  *    [ PackageDeclaration ]
  *        { ImportDeclaration }
- *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | <b>;</b> }
+ *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ModuleDeclaration <b>;</b> }
  * </pre>
  *
  * @since 2.0
@@ -72,6 +78,14 @@ public class CompilationUnit extends ASTNode {
 		new ChildPropertyDescriptor(CompilationUnit.class, "package", PackageDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
+	 * The "module" structural property of this node type (child type: {@link ModuleDeclaration}).
+	 *
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final ChildPropertyDescriptor MODULE_PROPERTY =
+		new ChildPropertyDescriptor(CompilationUnit.class, "module", ModuleDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -80,6 +94,14 @@ public class CompilationUnit extends ASTNode {
 	private static final List PROPERTY_DESCRIPTORS;
 
 	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 * @since 3.13 BETA_JAVA9
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	/**
 	 * The "types" structural property of this node type (element type: {@link AbstractTypeDeclaration}).
 	 *
 	 * @since 3.0
@@ -94,6 +116,14 @@ public class CompilationUnit extends ASTNode {
 		addProperty(IMPORTS_PROPERTY, properyList);
 		addProperty(TYPES_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
+
+		properyList = new ArrayList(5);
+		createPropertyList(CompilationUnit.class, properyList);
+		addProperty(PACKAGE_PROPERTY, properyList);
+		addProperty(IMPORTS_PROPERTY, properyList);
+		addProperty(TYPES_PROPERTY, properyList);
+		addProperty(MODULE_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
 	}
 
 	/**
@@ -108,7 +138,10 @@ public class CompilationUnit extends ASTNode {
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS;
+		if (apiLevel < AST.JLS9)
+			return PROPERTY_DESCRIPTORS;
+		else
+			return PROPERTY_DESCRIPTORS_9_0;
 	}
 
 	/**
@@ -168,10 +201,15 @@ public class CompilationUnit extends ASTNode {
 	private PackageDeclaration optionalPackageDeclaration = null;
 
 	/**
+	 * The module declaration, or <code>null</code> if none; initially
+	 * <code>null</code>.
+	 */
+	private ModuleDeclaration module = null;
+	/**
 	 * Problems reported by the compiler during parsing or name resolution.
 	 */
 	private IProblem[] problems = EMPTY_PROBLEMS;
-	
+
 	/**
 	 * Internal data used to perform statements recovery.
 	 */
@@ -207,6 +245,7 @@ public class CompilationUnit extends ASTNode {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
 			// visit children in normal left to right reading order
+			acceptChild(visitor, getModule());
 			acceptChild(visitor, getPackage());
 			acceptChildren(visitor, this.imports);
 			acceptChildren(visitor, this.types);
@@ -221,6 +260,7 @@ public class CompilationUnit extends ASTNode {
 		CompilationUnit result = new CompilationUnit(target);
 		// n.b do not copy line number table or messages
 		result.setSourceRange(getStartPosition(), getLength());
+		result.setModule((ModuleDeclaration) ASTNode.copySubtree(target, getModule()));
 		result.setPackage(
 			(PackageDeclaration) ASTNode.copySubtree(target, getPackage()));
 		result.imports().addAll(ASTNode.copySubtrees(target, imports()));
@@ -537,6 +577,17 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
+	 * Returns the node for the module declaration of this compilation
+	 * unit, or <code>null</code> if this compilation unit has a module
+	 *
+	 * @return the module declaration node, or <code>null</code> if none
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ModuleDeclaration getModule() {
+		return this.module;
+	}
+
+	/**
 	 * Returns the node for the package declaration of this compilation
 	 * unit, or <code>null</code> if this compilation unit is in the
 	 * default package.
@@ -716,6 +767,14 @@ public class CompilationUnit extends ASTNode {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == MODULE_PROPERTY) {
+			if (get) {
+				return getModule();
+			} else {
+				setModule((ModuleDeclaration) child);
+				return null;
+			}
+		}
 		if (property == PACKAGE_PROPERTY) {
 			if (get) {
 				return getPackage();
@@ -1000,6 +1059,26 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
+	 * Sets or clears the module declaration of this compilation unit
+	 * node to the given module declaration node.
+	 *
+	 * @param module the new module declaration node, or
+	 *   <code>null</code> if this compilation unit does not have a module
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void setModule(ModuleDeclaration module) {
+		ASTNode oldChild = this.module;
+		preReplaceChild(oldChild, module, PACKAGE_PROPERTY);
+		this.module = module;
+		postReplaceChild(oldChild, module, PACKAGE_PROPERTY);
+	}
+
+	/**
 	 * Sets or clears the package declaration of this compilation unit
 	 * node to the given package declaration node.
 	 *
@@ -1058,6 +1137,9 @@ public class CompilationUnit extends ASTNode {
 	 */
 	int treeSize() {
 		int size = memSize();
+		if (this.module != null) {
+			size += getModule().treeSize();
+		}
 		if (this.optionalPackageDeclaration != null) {
 			size += getPackage().treeSize();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
new file mode 100644
index 0000000..23dd1f1
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
@@ -0,0 +1,126 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Exports statement AST node type.
+ * <pre>
+ * ExportsStatement:
+ *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class ExportsStatement extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+			internalNamePropertyFactory(ExportsStatement.class);
+
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(ExportsStatement.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ExportsStatement.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an export statement owned by the
+	 * given AST. The export statement initially is a regular (non-targetted)
+	 * single package export for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ExportsStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return EXPORTS_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new ExportsStatement(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
new file mode 100644
index 0000000..a079175
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
@@ -0,0 +1,329 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Module declaration AST node type representing the module descriptor file
+ *
+ * <pre>
+ * ModuleDeclaration:
+ *  [ Javadoc ] { ExtendedModifier } <b>module</b> Name <b>{</b>
+ *        [ ExportsStatement | RequiresStatement | UsesStatement | ProvidesStatement ]
+ *  <b>}</b>
+ * </pre>
+ * <p>
+ * </p>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings("rawtypes")
+public class ModuleDeclaration extends ASTNode {
+
+	/**
+	 * The "javadoc" structural property of this node type (child type: {@link Javadoc}).
+	 */
+	public static final ChildPropertyDescriptor JAVADOC_PROPERTY =
+			new ChildPropertyDescriptor(ModuleDeclaration.class, "javadoc", Javadoc.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
+	 */
+	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
+			new ChildListPropertyDescriptor(ModuleDeclaration.class, "modifiers", IExtendedModifier.class, CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "name" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleStatement}).
+	 */
+	public static final ChildListPropertyDescriptor MODULE_STATEMENTS_PROPERTY =
+		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleStatement.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(5);
+		createPropertyList(ModuleDeclaration.class, properyList);
+		addProperty(JAVADOC_PROPERTY, properyList);
+		addProperty(MODIFIERS_PROPERTY, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULE_STATEMENTS_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The doc comment, or <code>null</code> if none.
+	 * Defaults to none.
+	 */
+	private Javadoc optionalDocComment = null;
+
+	/**
+	 * The extended modifiers (element type: {@link IExtendedModifier}).
+	 * defaults to an empty list
+	 * (see constructor).
+	 *
+	 */
+	private ASTNode.NodeList modifiers = null;
+
+	/**
+	 * The referenced module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Name name = null;
+
+	/**
+	 * The list of statements (element type: {@link ModuleStatement}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_STATEMENTS_PROPERTY);
+
+	ModuleDeclaration(AST ast) {
+		super(ast);
+		unsupportedBelow9();
+		this.modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == JAVADOC_PROPERTY) {
+			if (get) {
+				return getJavadoc();
+			} else {
+				setJavadoc((Javadoc) child);
+				return null;
+			}
+		}
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == MODIFIERS_PROPERTY) {
+			return modifiers();
+		}
+		if (property == MODULE_STATEMENTS_PROPERTY) {
+			return moduleStatements();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	int getNodeType0() {
+		return MODULE_DECLARATION;
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	ASTNode clone0(AST target) {
+		ModuleDeclaration result = new ModuleDeclaration(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setJavadoc((Javadoc) ASTNode.copySubtree(target, getJavadoc()));
+		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+		result.setName((SimpleName) getName().clone(target));
+		result.moduleStatements().addAll(ASTNode.copySubtrees(target, moduleStatements()));
+		return result;
+	}
+
+	@Override
+	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			// visit children in normal left to right reading order
+			acceptChild(visitor, getJavadoc());
+			acceptChildren(visitor, this.modifiers);
+			acceptChild(visitor, getName());
+			acceptChildren(visitor, this.moduleStatements);
+		}
+		visitor.endVisit(this);
+
+	}
+	/**
+	 * Returns the doc comment node.
+	 *
+	 * @return the doc comment node, or <code>null</code> if none
+	 */
+	public Javadoc getJavadoc() {
+		return this.optionalDocComment;
+	}
+
+	/**
+	 * Sets or clears the doc comment node.
+	 *
+	 * @param docComment the doc comment node, or <code>null</code> if none
+	 * @exception IllegalArgumentException if the doc comment string is invalid
+	 */
+	public void setJavadoc(Javadoc docComment) {
+		ChildPropertyDescriptor p = JAVADOC_PROPERTY;
+		ASTNode oldChild = this.optionalDocComment;
+		preReplaceChild(oldChild, docComment, p);
+		this.optionalDocComment = docComment;
+		postReplaceChild(oldChild, docComment, p);
+	}
+
+	/**
+	 * Returns the modifiers explicitly specified on this declaration.
+	 * <p>
+	 *  this method is a convenience method that
+	 * computes these flags from {@link #modifiers()}.
+	 * </p>
+	 *
+	 * @return the bit-wise "or" of <code>Modifier</code> constants
+	 * @see Modifier
+	 */
+	public int getModifiers() {
+		// convenience method -
+		// performance could be improved by caching computed flags
+		// but this would require tracking changes to this.modifiers
+		int computedmodifierFlags = Modifier.NONE;
+		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
+			Object x = it.next();
+			if (x instanceof Modifier) {
+				computedmodifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
+			}
+		}
+		return computedmodifierFlags;
+	}
+
+	/**
+	 * Returns the name of this module declaration.
+	 *
+	 * @return the module name
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the module name in to the given name.
+	 *
+	 * @param name the new module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of modifiers and annotations
+	 * of this declaration.
+	 *
+	 * @return the live list of modifiers and annotations
+	 *    (element type: {@link IExtendedModifier})
+	 */
+	public List modifiers() {
+		return this.modifiers;
+	}
+
+	/**
+	 * Returns the live list of statements in this module. Adding and
+	 * removing nodes from this list affects this node dynamically.
+	 * All nodes in this list must be <code>Statement</code>s;
+	 * attempts to add any other type of node will trigger an
+	 * exception.
+	 *
+	 * @return the live list of statements in this module declaration
+	 *    (element type: {@link ModuleStatement})
+	 */
+	public List moduleStatements() {
+		return this.moduleStatements;
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 4 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return	memSize()
+			+ (this.optionalDocComment == null ? 0 : getJavadoc().treeSize())
+			+ this.modifiers.listSize()
+			+ (this.name == null ? 0 : getName().treeSize())
+			+ this.moduleStatements.listSize();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
new file mode 100644
index 0000000..4dae45a
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
@@ -0,0 +1,207 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.List;
+
+/**
+ * Abstract base class of AST nodes that represent exports and opens statements.
+ *
+ * <pre>
+ * ModuleStatement: [ {@link ExportsStatement} |
+ *    {@link OpensStatement} ]
+ * </pre>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @since 3.13 BETA_JAVA9
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public abstract class ModulePackageAccess extends ModuleStatement {
+
+	/**
+	 * The package name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	protected Name name = null;
+
+	/**
+	 * The target modules
+	 * (element type: {@link Name}).
+	 * Defaults to an empty list. (see constructor)
+	 */
+	protected ASTNode.NodeList modules = null;
+
+	/**
+	 * Returns structural property descriptor for the "modules" property
+	 * of this node (element type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	abstract ChildListPropertyDescriptor internalModulesProperty();
+
+	/**
+	 * Returns structural property descriptor for the "name" property
+	 * of this node (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	abstract ChildPropertyDescriptor internalNameProperty();
+
+	/**
+	 * Returns structural property descriptor for the "name" property
+	 * of this node (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	public final ChildPropertyDescriptor getNameProperty() {
+		return internalNameProperty();
+	}
+
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "name" property declared on the given concrete node type (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildPropertyDescriptor internalNamePropertyFactory(Class nodeClass) {
+		return new ChildPropertyDescriptor(nodeClass, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	}
+
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "modules" property declared on the given concrete node type (element type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildListPropertyDescriptor internalModulesPropertyFactory(Class nodeClass) {
+		return new ChildListPropertyDescriptor(nodeClass, "modules", Name.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	}
+
+	/**
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ModulePackageAccess(AST ast) {
+		super(ast);
+		this.modules = new ASTNode.NodeList(internalModulesProperty());
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == internalNameProperty()) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == internalModulesProperty()) {
+			return modules();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	/**
+	 * Returns the name of the package
+	 *
+	 * @return the package name node
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					ChildPropertyDescriptor p = internalNameProperty();
+					postLazyInit(this.name, p);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the name of the package to the given name.
+	 *
+	 * @param name the new  package name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		ChildPropertyDescriptor p = internalNameProperty();
+		preReplaceChild(oldChild, name, p);
+		this.name = name;
+		postReplaceChild(oldChild, name, p);
+	}
+
+	/**
+	 * Returns the live ordered list of target modules for this
+	 * statement.
+	 *
+	 * @return the live list of target modules
+	 *    (element type: {@link Name})
+	 */
+	public List modules() {
+		return this.modules;
+	}
+
+	protected ASTNode cloneHelper(AST target, ModulePackageAccess result) {
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setName((Name) getName().clone(target));
+		result.modules().addAll(ASTNode.copySubtrees(target, modules()));
+		return result;
+	}
+
+	protected void acceptVisitChildren(boolean visitChildren, ASTVisitor visitor) {
+		if (visitChildren) {
+			acceptChild(visitor, getName());
+			acceptChildren(visitor, this.modules);
+		}
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.name == null ? 0 : getName().treeSize())
+			+ this.modules.listSize();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
new file mode 100644
index 0000000..97e2514
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+/**
+ * Abstract base class of AST nodes that represent module statements.
+ * There are many kinds of module statements.
+ *
+ * <pre>
+ * ModuleStatement: [ {@link ExportsStatement} |
+ *    {@link RequiresStatement} |
+ *    {@link UsesStatement} |
+ *    {@link ProvidesStatement} ]
+ * </pre>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @since 3.13 BETA_JAVA9
+ */
+public abstract class ModuleStatement extends ASTNode {
+
+	ModuleStatement(AST ast) {
+		super(ast);
+		unsupportedBelow9();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
new file mode 100644
index 0000000..ed137ac
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
@@ -0,0 +1,125 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * opens statement AST node type.
+ * <pre>
+ * OpensStatement:
+ *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class OpensStatement extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		internalNamePropertyFactory(OpensStatement.class);
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(OpensStatement.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(OpensStatement.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an opens statement owned by the
+	 * given AST. The open statement initially is a regular (non-targetted)
+	 * single package open for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	OpensStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return OPENS_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new OpensStatement(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
new file mode 100644
index 0000000..2c7da2b
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides statement AST node type.
+ * <pre>
+ * ProvidesStatement:
+ *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class ProvidesStatement extends ModuleStatement {
+
+	/**
+	 * The "interface type" structural property of this node type (child type: {@link Type}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(ProvidesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "implementation type" structural property of this node type (element type: {@link Type}).
+	 */
+	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
+			new ChildListPropertyDescriptor(ProvidesStatement.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ProvidesStatement.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		addProperty(IMPLEMENTATIONS_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The interface name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * The implementation names
+	 * (element type: {@link Name}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList implementations =
+		new ASTNode.NodeList(IMPLEMENTATIONS_PROPERTY);
+
+	/**
+	 * Creates a new AST node for an provides statement owned by the
+	 * given AST. The provides statement initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ProvidesStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == IMPLEMENTATIONS_PROPERTY) {
+			return implementations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return PROVIDES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		ProvidesStatement result = new ProvidesStatement(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		result.implementations().addAll(ASTNode.copySubtrees(target, implementations()));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+			acceptChildren(visitor, this.implementations);
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type name in this statement
+	 *
+	 * @return the type name
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type =this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the target module name in exports declaration to the given name.
+	 *
+	 * @param type the new target module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of implementations for the interface in this provides statement.
+	 *
+	 * @return the live list of implementations for the interface
+	 *    (element type: {@link Name})
+	 */
+	public List implementations() {
+		return this.implementations;
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize())
+			+ this.implementations.listSize();
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
new file mode 100644
index 0000000..abebef4
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
@@ -0,0 +1,251 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Requires statement AST node type.
+ * <pre>
+ * RequiresStatement:
+ *     <b>requires</b> { ExtendedModifier } Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class RequiresStatement extends ModuleStatement {
+
+	/**
+	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
+	 */
+	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
+		new ChildListPropertyDescriptor(RequiresStatement.class, "modifiers", IExtendedModifier.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The module structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(RequiresStatement.class, "name", Name.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List propertyList = new ArrayList(3);
+		createPropertyList(RequiresStatement.class, propertyList);
+		addProperty(MODIFIERS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The extended modifiers (element type: {@link IExtendedModifier}).
+	 * defaults to an empty list
+	 */
+	private ASTNode.NodeList modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
+
+	/**
+	 * The referenced module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Name name = null;
+
+	/**
+	 * Creates a new AST node for an requires statement owned by the
+	 * given AST. The requires statement initially is a regular (no modifiers)
+	 * requires for an unspecified, but legal, Java module name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	RequiresStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == MODIFIERS_PROPERTY) {
+			return modifiers();
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return REQUIRES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		RequiresStatement result = new RequiresStatement(target);
+		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+		result.setName((Name) getName().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChildren(visitor, this.modifiers);
+			acceptChild(visitor, getName());
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * Returns the live ordered list of modifiers
+	 * of this declaration.
+	 * <p>
+	 * Note that the not all modifiers are legal.
+	 * </p>
+	 *
+	 * @return the live list of modifiers
+	 *    (element type: {@link IExtendedModifier})
+	 */
+	public List modifiers() {
+		return this.modifiers;
+	}
+
+	/**
+	 * Returns the modifiers explicitly specified on this declaration.
+	 * <p>
+	 * this method is a convenience method that
+	 * computes these flags from <code>modifiers()</code>.
+	 * </p>
+	 *
+	 * @return the bit-wise or of <code>Modifier</code> constants
+	 * @see Modifier
+	 */
+	public int getModifiers() {
+		// do not cache - performance could be improved by caching computed flags
+		// but this would require tracking changes to this.modifiers
+		int computedModifierFlags = Modifier.NONE;
+		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
+			Object x = it.next();
+			if (x instanceof Modifier) {
+				computedModifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
+			}
+		}
+		return computedModifierFlags;
+	}
+
+	/**
+	 * Returns the module name referenced by this declaration.
+	 *
+	 * @return the module referenced
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the module name in requires statement to the given name.
+	 *
+	 * @param name the new module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
+			+ (this.name == null ? 0 : getName().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
new file mode 100644
index 0000000..d94c3cb
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
@@ -0,0 +1,188 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Uses statement AST node type.
+ * <pre>
+ * UsesStatement:
+ *     <b>uses</b> Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings("rawtypes")
+public class UsesStatement extends ModuleStatement {
+
+	/**
+	 * The "type" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(UsesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(2);
+		createPropertyList(UsesStatement.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * Creates a new AST node for an uses statement owned by the
+	 * given AST. The uses statement initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	UsesStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return USES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		UsesStatement result = new UsesStatement(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type in this statement
+	 *
+	 * @return the type
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type = this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the type in uses statement
+	 *
+	 * @param type the new type in uses
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 1 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 1d816cb..88aa9e3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -207,11 +207,24 @@ public class NaiveASTFlattener extends ASTVisitor {
 		}
 	}
 
+	private void printTypes(List<Type> types, String prefix) {
+		if (types.size() > 0) {
+			this.buffer.append(" " + prefix + " ");//$NON-NLS-1$ //$NON-NLS-2$
+			Type type = types.get(0);
+			type.accept(this);
+			for (int i = 1, l = types.size(); i < l; ++i) {
+				this.buffer.append(","); //$NON-NLS-1$
+				type = types.get(0);
+				type.accept(this);
+			}
+		}
+	}
+
 	/**
 	 * reference node helper function that is common to all
 	 * the difference reference nodes.
-	 * 
-	 * @param typeArguments list of type arguments 
+	 *
+	 * @param typeArguments list of type arguments
 	 */
 	private void visitReferenceTypeArguments(List typeArguments) {
 		this.buffer.append("::");//$NON-NLS-1$
@@ -744,9 +757,14 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ExportsStatement node) {
+		return visit(node, "exports"); //$NON-NLS-1$
+	}
+
 	/*
 	 * @see ASTVisitor#visit(ExpressionMethodReference)
-	 * 
+	 *
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1207,6 +1225,32 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ModuleDeclaration node) {
+		printModifiers(node.modifiers());
+		this.buffer.append("module"); //$NON-NLS-1$
+		this.buffer.append(" "); //$NON-NLS-1$
+		node.getName().accept(this);
+		this.buffer.append(" {\n"); //$NON-NLS-1$
+		this.indent++;
+		for (ModuleStatement stmt : (List<ModuleStatement>)node.moduleStatements()) {
+			stmt.accept(this);
+		}
+		this.indent--;
+		this.buffer.append("}"); //$NON-NLS-1$
+		return false;
+	}
+
+	private boolean visit(ModulePackageAccess node, String keyword) {
+		printIndent();
+		this.buffer.append(keyword);
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getName().accept(this);
+		printTypes(node.modules(), "to"); //$NON-NLS-1$
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(NameQualifiedType)
 	 * @since 3.10
@@ -1254,6 +1298,11 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(OpensStatement node) {
+		return visit(node, "opens"); //$NON-NLS-1$
+	}
+
 	/*
 	 * @see ASTVisitor#visit(PackageDeclaration)
 	 */
@@ -1330,6 +1379,17 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ProvidesStatement node) {
+		printIndent();
+		this.buffer.append("provides");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getType().accept(this);
+		printTypes(node.implementations(), "with"); //$NON-NLS-1$
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(QualifiedName)
 	 */
@@ -1352,6 +1412,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(RequiresStatement node) {
+		printIndent();
+		this.buffer.append("requires");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getName().accept(this);
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(ReturnStatement)
 	 */
@@ -1851,6 +1921,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(UsesStatement node) {
+		printIndent();
+		this.buffer.append("uses");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getType().accept(this);
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
commit 122497a51cb174b2d7497c5e397e8863b22e637a
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Wed Dec 21 11:05:01 2016 +0530

    Revert "Fix for bug 496123 Fix for bug 496123 Fix for bug 496123 [9] DOM AST for ModuleDeclaration in module-info.java - conversion part"
    
    This reverts commit efbb87073d9dbcb7374efd4fcb6785889c57a494.

2	45	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
2	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
4	14	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
0	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
1	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
1	80	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
45	154	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
2	157	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
2	80	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
0	184	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
4	86	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
0	126	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
0	329	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
0	207	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
0	36	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
0	125	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
0	224	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
0	251	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
0	188	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
3	83	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index c3dde4f..c5220c2 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -130,50 +130,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			checkSourceRange(fieldAccess, "this.y2", contents);
 			expr = resources.get(5);
 			VariableDeclarationExpression variableDeclarationExpression = (VariableDeclarationExpression) expr;
-			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);
+			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);			
 	}
-	public void testBug496123_0001() throws JavaModelException {
-		this.workingCopies = new ICompilationUnit[1];
-		String content =  "module first {"
-				+ "  requires second;\n"
-				+ "  exports pack11 to third, fourth;\n"
-				+ "  uses NewType;\n"
-				+ "  provides pack22.I22 with pack11.packinternal.Z11;\n"
-				+ "}";
-		this.workingCopies[0] = getWorkingCopy(
-				"/Converter9/src/module-info.java", content);
-		
-		CompilationUnit unit = (CompilationUnit) runConversion(AST.JLS9, this.workingCopies[0], false/*no bindings*/);
-		ModuleDeclaration moduleDecl = unit.getModule();
-		
-		checkSourceRange(moduleDecl, content, content);
-		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
-		assertTrue(stmts.size() > 0);
-		
-		RequiresStatement req = (RequiresStatement) stmts.get(0);
-		checkSourceRange(req, "requires second;", content);
-		
-		ExportsStatement exp = (ExportsStatement) stmts.get(1);
-		checkSourceRange(exp, "exports pack11 to third, fourth;", content);
-		checkSourceRange(exp.getName(), "pack11", content);
-		List<Name> modules = exp.modules();
-		assertTrue(modules.size() == 2);
-		checkSourceRange(modules.get(0), "third", content);
-		checkSourceRange(modules.get(1), "fourth", content);
-		
-		UsesStatement u = (UsesStatement) stmts.get(2);
-		checkSourceRange(u, "uses NewType;", content);
-		Type type = u.getType();
-		checkSourceRange(type, "NewType", content);
-		
-		ProvidesStatement p = (ProvidesStatement) stmts.get(3);
-		checkSourceRange(p, "provides pack22.I22 with pack11.packinternal.Z11;", content);
-		type = p.getType();
-		checkSourceRange(type, "pack22.I22", content);
-		List<Type> impls = p.implementations();
-		assertTrue(impls.size() > 0);
-		type = impls.get(0);
-		checkSourceRange(type, "pack11.packinternal.Z11", content);		
-	}
-// Add new tests here 
+
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index 29fa62f..3909178 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2016 IBM Corporation and others.
+ * Copyright (c) 2004, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -373,7 +369,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 98, hi); // last known one
+		assertEquals("Wrong last known type", 92, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 5c481ef..4830f26 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -8851,20 +8847,14 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			ASTNode.CREATION_REFERENCE,
 			ASTNode.EXPRESSION_METHOD_REFERENCE,
 			ASTNode.SUPER_METHOD_REFERENCE,
-			ASTNode.TYPE_METHOD_REFERENCE,
-			ASTNode.MODULE_DECLARATION,
-			ASTNode.EXPORTS_STATEMENT,
-			ASTNode.REQUIRES_STATEMENT,
-			ASTNode.USES_STATEMENT,
-			ASTNode.PROVIDES_STATEMENT,
-			ASTNode.OPENS_STATEMENT
+			ASTNode.TYPE_METHOD_REFERENCE
 		};
-
+		
 		// assert that nodeType values are correct:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			assertSame(i + 1, nodeTypes[i]);
 		}
-
+		
 		// test nodeClassForType:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			int nodeType = nodeTypes[i];
@@ -8872,7 +8862,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			try {
 				node = this.ast.createInstance(nodeType);
 			} catch (IllegalArgumentException e) {
-				if (this.API_LEVEL < AST.JLS9 && e.getCause() instanceof UnsupportedOperationException) {
+				if (this.API_LEVEL < getJLS8() && e.getCause() instanceof UnsupportedOperationException) {
 					continue;
 				} else {
 					throw new AssertionFailedError("missing node type: " + nodeType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
index aedd896..ab16c1b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
@@ -48,12 +48,6 @@ public final class CharOperation {
 	 */
 	public static final char[] ALL_PREFIX = new char[] {'*'};
 
-	/**
-	 * Constant for comma
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final char[] COMMA_SEPARATOR = new char[] {','};
-
 /**
  * Answers a new array with appending the suffix character at the end of the array.
  * <br>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index 77a7ad8..a4133ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
@@ -203,8 +199,7 @@ public class Scanner implements TerminalTokens {
 	private VanguardParser vanguardParser;
 	ConflictedParser activeParser = null;
 	private boolean consumingEllipsisAnnotations = false;
-	public boolean fakeInModule = false;
-
+	
 	public static final int RoundBracket = 0;
 	public static final int SquareBracket = 1;
 	public static final int CurlyBracket = 2;
@@ -2536,7 +2531,6 @@ final char[] optimizedCurrentTokenSource6() {
 	return table[this.newEntry6 = max] = r; //(r = new char[] {c0, c1, c2, c3, c4, c5});
 }
 private boolean isInModuleDeclaration() {
-	if (this.fakeInModule) return true;
 	return this.activeParser != null ? this.activeParser.isParsingModuleDeclaration() : false;
 }
 private void parseTags() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 34f4984..9948fdc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -239,10 +239,6 @@ public class Util implements SuffixConstants {
 	public static final String LINE_SEPARATOR = System.getProperty("line.separator"); //$NON-NLS-1$
 
 	public static final String EMPTY_STRING = new String(CharOperation.NO_CHAR);
-	/**
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final String COMMA_SEPARATOR = new String(CharOperation.COMMA_SEPARATOR);
 	public static final int[] EMPTY_INT_ARRAY= new int[0];
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index ca977c9..4232757 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1504,23 +1504,10 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented exports statement
-	 * node for an unspecified, but legal, name; no target modules
-	 *
-	 * @return a new unparented exports statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public ExportsStatement newExportsStatement() {
-		ExportsStatement result = new ExportsStatement(this);
-		return result;
-	}
-
-	/**
 	 * Creates an unparented expression method reference node owned by this AST.
 	 * By default, the expression and method name are unspecified (but legal),
 	 * and there are no type arguments.
-	 *
+	 * 
 	 * @return a new unparented expression method reference expression node
 	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
 	 * @since 3.10
@@ -1937,20 +1924,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented module declaration
-	 * node for an unspecified, but legal, name; no modifiers; no javadoc;
-	 * and an empty list of statements.
-	 *
-	 * @return a new unparented module declaration node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public ModuleDeclaration newModuleDeclaration() {
-		ModuleDeclaration result = new ModuleDeclaration(this);
-		return result;
-	}
-
-	/**
 	 * Creates and returns a new unparented name node for the given name.
 	 * The name string must consist of 1 or more name segments separated
 	 * by single dots '.'. Returns a {@link QualifiedName} if the name has
@@ -2114,19 +2087,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented opens statement
-	 * node for an unspecified, but legal, name; no target modules
-	 *
-	 * @return a new unparented opens statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public OpensStatement newOpensStatement() {
-		OpensStatement result = new OpensStatement(this);
-		return result;
-	}
-
-	/**
 	 * Creates an unparented package declaration node owned by this AST.
 	 * The package declaration initially declares a package with an
 	 * unspecified name.
@@ -2210,19 +2170,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented provides statement
-	 * node for an unspecified, but legal, type; no target types
-	 *
-	 * @return a new unparented provides statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public ProvidesStatement newProvidesStatement() {
-		ProvidesStatement result = new ProvidesStatement(this);
-		return result;
-	}
-
-	/**
 	 * Creates and returns a new unparented qualified name node for the given
 	 * qualifier and simple name child node.
 	 *
@@ -2269,19 +2216,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented requires statement
-	 * node for an unspecified, but legal, name;
-	 *
-	 * @return a new unparented requires statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public RequiresStatement newRequiresStatement() {
-		RequiresStatement result = new RequiresStatement(this);
-		return result;
-	}
-
-	/**
 	 * Creates a new unparented return statement node owned by this AST.
 	 * By default, the return statement has no expression.
 	 *
@@ -2649,19 +2583,6 @@ public final class AST {
 	}
 
 	/**
-	 * Creates and returns a new unparented uses statement
-	 * node for an unspecified, but legal, name;
-	 *
-	 * @return a new unparented uses statement node
-	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public UsesStatement newUsesStatement() {
-		UsesStatement result = new UsesStatement(this);
-		return result;
-	}
-
-	/**
 	 * Creates a new unparented intersection type node owned by this AST.
 	 * By default, the intersection type has no types.
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index e2049a0..c20728c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -17,13 +17,11 @@
 
 package org.eclipse.jdt.core.dom;
 
-import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.TreeSet;
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
@@ -44,7 +42,6 @@ import org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
-import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
@@ -1383,15 +1380,12 @@ class ASTConverter {
 					if (type == null) {
 						compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
 					} else {
-						if (type instanceof ModuleDeclaration)
-							compilationUnit.setModule((ModuleDeclaration) type);
-						else
-							compilationUnit.types().add(type);
+						compilationUnit.types().add(type);
 					}
 				}
 			}
 			compilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);
-
+	
 			int problemLength = unit.compilationResult.problemCount;
 			if (problemLength != 0) {
 				CategorizedProblem[] resizedProblems = null;
@@ -1690,24 +1684,6 @@ class ASTConverter {
 		return newStatement;
 	}
 
-	private ModulePackageAccess getPackageVisibilityStatement(
-			org.eclipse.jdt.internal.compiler.ast.PackageVisibilityStatement pvsStmt, ModulePackageAccess stmt) {
-		int sourceEnd = pvsStmt.declarationSourceEnd;
-		if (pvsStmt.declarationEnd > sourceEnd) sourceEnd = pvsStmt.declarationEnd; // TODO: working around a compiler issue
-		stmt.setName(getUpdatedSimpleName(pvsStmt.pkgName, pvsStmt.pkgRef.sourceStart, pvsStmt.pkgRef.sourceEnd));
-		int tmp = sourceEnd;
-		if (pvsStmt.targets != null && pvsStmt.targets.length > 0) {
-			List<Name> modules = stmt.modules();
-			for (ModuleReference moduleRef : pvsStmt.getTargetedModules()) {
-				modules.add(getUpdatedSimpleName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd));
-				if (tmp < moduleRef.sourceEnd) tmp = moduleRef.sourceEnd;
-			}
-		}
-		if (tmp > sourceEnd) sourceEnd = tmp;
-		stmt.setSourceRange(pvsStmt.declarationSourceStart, sourceEnd - pvsStmt.declarationSourceStart + 1);			
-		return stmt;
-	}
-
 	public Expression convert(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		if ((expression.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) != 0) {
 			return convertToParenthesizedExpression(expression);
@@ -2029,50 +2005,54 @@ class ASTConverter {
 		return literal;
 	}
 
-	interface IGetJavaDoc {
-		Javadoc getJavaDoc();
-	}
-	interface ISetJavaDoc {
-		void setJavadoc(Javadoc javadoc);
-	}
-	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, IGetJavaDoc getJ, ISetJavaDoc setJ) {
-		if (getJ.getJavaDoc() == null) {
-			Javadoc docComment = convert(javadoc);
-			if (docComment != null) 
-				setJ.setJavadoc(docComment);
-		}
-	}
-	private Javadoc convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc) {
-		Javadoc docComment = null;
-		if (javadoc != null) {
-			if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
-				this.commentMapper = new DefaultCommentMapper(this.commentsTable);
-			}
-			Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
-			if (comment != null && comment.isDocComment() && comment.getParent() == null) {
-				docComment = (Javadoc) comment;
-				if (this.resolveBindings) {
-					recordNodes(docComment, javadoc);
-					// resolve member and method references binding
-					Iterator tags = docComment.tags().listIterator();
-					while (tags.hasNext()) {
-						recordNodes(javadoc, (TagElement) tags.next());
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
+		if (bodyDeclaration.getJavadoc() == null) {
+			if (javadoc != null) {
+				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
+					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
+				}
+				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
+				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
+					Javadoc docComment = (Javadoc) comment;
+					if (this.resolveBindings) {
+						recordNodes(docComment, javadoc);
+						// resolve member and method references binding
+						Iterator tags = docComment.tags().listIterator();
+						while (tags.hasNext()) {
+							recordNodes(javadoc, (TagElement) tags.next());
+						}
 					}
+					bodyDeclaration.setJavadoc(docComment);
 				}
 			}
 		}
-		return docComment;
-	}
-	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
-		convert(javadoc, bodyDeclaration::getJavadoc, bodyDeclaration::setJavadoc);
-	}
-	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, ModuleDeclaration moduleDeclaration) {
-		convert(javadoc, moduleDeclaration::getJavadoc, moduleDeclaration::setJavadoc);
 	}
 
 	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, PackageDeclaration packageDeclaration) {
-		if (this.ast.apiLevel == AST.JLS2_INTERNAL) return;
-		convert(javadoc, packageDeclaration::getJavadoc, packageDeclaration::setJavadoc);
+		switch(this.ast.apiLevel) {
+			case AST.JLS2_INTERNAL :
+				return;
+		}
+		if (packageDeclaration.getJavadoc() == null) {
+			if (javadoc != null) {
+				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
+					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
+				}
+				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
+				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
+					Javadoc docComment = (Javadoc) comment;
+					if (this.resolveBindings) {
+						recordNodes(docComment, javadoc);
+						// resolve member and method references binding
+						Iterator tags = docComment.tags().listIterator();
+						while (tags.hasNext()) {
+							recordNodes(javadoc, (TagElement) tags.next());
+						}
+					}
+					packageDeclaration.setJavadoc(docComment);
+				}
+			}
+		}
 	}
 
 	public LabeledStatement convert(org.eclipse.jdt.internal.compiler.ast.LabeledStatement statement) {
@@ -2956,8 +2936,6 @@ class ASTConverter {
 				} else {
 					return convertToAnnotationDeclaration(typeDeclaration);
 				}
-			case org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.MODULE_DECL :
-				return convertToModuleDeclaration(typeDeclaration);
 		}
 
 		checkCanceled();
@@ -3275,81 +3253,6 @@ class ASTConverter {
 		return fieldDeclaration;
 	}
 
-	public ModuleDeclaration convertToModuleDeclaration(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
-		checkCanceled();
-		if (this.scanner.sourceLevel < ClassFileConstants.JDK9) return null;
-		org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) typeDeclaration;
-		ModuleDeclaration moduleDecl = this.ast.newModuleDeclaration();
-		convert(moduleDeclaration.javadoc, moduleDecl);
-		setModifiers(moduleDecl, moduleDeclaration);
-		SimpleName moduleName = getUpdatedSimpleName(moduleDeclaration.moduleName, moduleDeclaration.sourceStart, moduleDeclaration.sourceEnd);
-		moduleDecl.setName(moduleName);
-		moduleDecl.setSourceRange(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd - moduleDeclaration.declarationSourceStart + 1);
-
-		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
-		TreeSet<ModuleStatement> tSet = new TreeSet<> (new Comparator() {
-			public int compare(Object o1, Object o2) {
-				int p1 = ((ModuleStatement) o1).getStartPosition();
-				int p2 = ((ModuleStatement) o2).getStartPosition();
-				return p1 < p2 ? -1 : p1 == p2 ? 0 : 1;
-			}
-		});
-		for (int i = 0; i < moduleDeclaration.exportsCount; ++i) {
-			tSet.add(getPackageVisibilityStatement(moduleDeclaration.exports[i], new ExportsStatement(this.ast)));
-		}
-		for (int i = 0; i < moduleDeclaration.opensCount; ++i) {
-			tSet.add(getPackageVisibilityStatement(moduleDeclaration.opens[i], new OpensStatement(this.ast)));
-		}
-		for (int i = 0; i < moduleDeclaration.requiresCount; ++i) {
-			org.eclipse.jdt.internal.compiler.ast.RequiresStatement req = moduleDeclaration.requires[i];
-			ModuleReference moduleRef = req.module;
-			RequiresStatement stmt = new RequiresStatement(this.ast);
-			SimpleName name = getUpdatedSimpleName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd);
-			stmt.setName(name);
-
-			addModifierToRequires(req, req.isTransitive(), Modifier.ModifierKeyword.TRANSIENT_KEYWORD, stmt);
-			addModifierToRequires(req, req.isStatic(), Modifier.ModifierKeyword.STATIC_KEYWORD, stmt);
-			stmt.setSourceRange(req.declarationSourceStart, req.declarationEnd - req.declarationSourceStart + 1);			
-			tSet.add(stmt);
-		}
-		for (int i = 0; i < moduleDeclaration.usesCount; ++i) {
-			org.eclipse.jdt.internal.compiler.ast.UsesStatement usesStatement = moduleDeclaration.uses[i];
-			UsesStatement stmt = new UsesStatement(this.ast);
-			TypeReference usesRef = usesStatement.serviceInterface;
-			stmt.setType(convertType(usesRef));
-			stmt.setSourceRange(usesStatement.declarationSourceStart, usesStatement.declarationSourceEnd - usesStatement.declarationSourceStart + 1);			
-			tSet.add(stmt);
-		}
-		for (int i = 0; i < moduleDeclaration.servicesCount; ++i) {
-			org.eclipse.jdt.internal.compiler.ast.ProvidesStatement pStmt = moduleDeclaration.services[i];
-			ProvidesStatement stmt = new ProvidesStatement(this.ast);
-			stmt.setType(convertType(pStmt.serviceInterface));
-			TypeReference[] impls = pStmt.implementations;
-			for (TypeReference impl : impls) {
-				stmt.implementations().add(convertType(impl));
-			}
-			stmt.setSourceRange(pStmt.declarationSourceStart, pStmt.declarationEnd - pStmt.declarationSourceStart + 1);			
-			tSet.add(stmt);
-		}
-		// The javadoc comment is now got from 	list store in compilation unit declaration
-		if (this.resolveBindings) {
-			recordNodes(moduleDecl, moduleDeclaration);
-			recordNodes(moduleName, moduleDeclaration);
-			// moduleDecl.resolveBinding(); TODO: Implement resolveBinding
-		}
-		stmts.addAll(tSet);
-		return moduleDecl;
-	}
-
-	private void addModifierToRequires(org.eclipse.jdt.internal.compiler.ast.RequiresStatement req, boolean flag, Modifier.ModifierKeyword keyword,
-			RequiresStatement stmt) {
-		if (flag) {
-			Modifier modifier = createModifier(keyword);
-			modifier.setSourceRange(req.modifiersSourceStart, keyword.toString().length());
-			stmt.modifiers().add(modifier);
-		}
-	}
-
 	public ParenthesizedExpression convertToParenthesizedExpression(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		final ParenthesizedExpression parenthesizedExpression = new ParenthesizedExpression(this.ast);
 		if (this.resolveBindings) {
@@ -4369,12 +4272,7 @@ class ASTConverter {
 		}
 		return false;
 	}
-	private SimpleName getUpdatedSimpleName(char[] s, int sourceStart, int sourceEnd) {
-		SimpleName name = new SimpleName(this.ast);
-		name.setIdentifier(new String(s));
-		name.setSourceRange(sourceStart, sourceEnd - sourceStart  + 1);
-		return name;
-	}
+
 	private void lookupForScopes() {
 		if (this.pendingNameScopeResolution != null) {
 			for (Iterator iterator = this.pendingNameScopeResolution.iterator(); iterator.hasNext(); ) {
@@ -5126,9 +5024,6 @@ class ASTConverter {
 	 * @param bodyDeclaration
 	 */
 	protected void setModifiers(BodyDeclaration bodyDeclaration, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
-		setModifiers(bodyDeclaration.modifiers(), annotations, modifiersEnd);
-	}
-	protected void setModifiers(List modifiers, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
 		this.scanner.tokenizeWhiteSpace = false;
 		try {
 			int token;
@@ -5189,7 +5084,7 @@ class ASTConverter {
 						break;
 				}
 				if (modifier != null) {
-					modifiers.add(modifier);
+					bodyDeclaration.modifiers().add(modifier);
 				}
 			}
 		} catch(InvalidInputException e) {
@@ -5269,10 +5164,6 @@ class ASTConverter {
 		}
 	}
 
-	protected void setModifiers(ModuleDeclaration moduleDecl, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
-		this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
-		this.setModifiers(moduleDecl.modifiers(), typeDeclaration.annotations, typeDeclaration.sourceStart);
-	}
 	/**
 	 * @param variableDecl
 	 * @param argument
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index d0552d2..070bb52 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -619,8 +615,7 @@ public class ASTMatcher {
 		}
 		CompilationUnit o = (CompilationUnit) other;
 		return (
-			safeSubtreeMatch(node.getModule(), o.getModule())
-				&& safeSubtreeMatch(node.getPackage(), o.getPackage())
+			safeSubtreeMatch(node.getPackage(), o.getPackage())
 				&& safeSubtreeListMatch(node.imports(), o.imports())
 				&& safeSubtreeListMatch(node.types(), o.types()));
 	}
@@ -892,31 +887,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean match(ExportsStatement node, Object other) {
-		if (!(other instanceof ExportsStatement)) {
-			return false;
-		}
-		ExportsStatement o = (ExportsStatement) other;
-		return (
-			safeSubtreeMatch(node.getName(), o.getName())
-				&& safeSubtreeListMatch(node.modules(), o.modules()));
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(ExpressionMethodReference node, Object other) {
@@ -1583,32 +1553,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean match(ModuleDeclaration node, Object other) {
-		if (!(other instanceof ModuleDeclaration)) {
-			return false;
-		}
-		ModuleDeclaration o = (ModuleDeclaration) other;
-		return (safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
-				&& safeSubtreeListMatch(node.modifiers(), o.modifiers())
-				&& safeSubtreeMatch(node.getName(), o.getName())
-				&& safeSubtreeListMatch(node.moduleStatements(), o.moduleStatements()));
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(NameQualifiedType node, Object other) {
@@ -1701,31 +1645,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean match(OpensStatement node, Object other) {
-		if (!(other instanceof OpensStatement)) {
-			return false;
-		}
-		OpensStatement o = (OpensStatement) other;
-		return (
-			safeSubtreeMatch(node.getName(), o.getName())
-				&& safeSubtreeListMatch(node.modules(), o.modules()));
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(PackageDeclaration node, Object other) {
 		if (!(other instanceof PackageDeclaration)) {
@@ -1874,32 +1793,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.13 BETA_JAVA9
-
-	 */
-	public boolean match(ProvidesStatement node, Object other) {
-		if (!(other instanceof ProvidesStatement)) {
-			return false;
-		}
-		ProvidesStatement o = (ProvidesStatement) other;
-		return (
-				safeSubtreeMatch(node.getType(), o.getType())
-				&& safeSubtreeListMatch(node.implementations(), o.implementations()));
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(QualifiedName node, Object other) {
 		if (!(other instanceof QualifiedName)) {
@@ -1949,31 +1842,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 *
-	 *   @since 3.13 BETA_JAVA9
-	 */
-	public boolean match(RequiresStatement node, Object other) {
-		if (!(other instanceof RequiresStatement)) {
-			return false;
-		}
-		RequiresStatement o = (RequiresStatement) other;
-		return safeSubtreeListMatch(node.modifiers(), o.modifiers())
-				&& safeSubtreeMatch(node.getName(), o.getName());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(ReturnStatement node, Object other) {
 		if (!(other instanceof ReturnStatement)) {
@@ -2597,29 +2465,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean match(UsesStatement node, Object other) {
-		if (!(other instanceof UnionType)) {
-			return false;
-		}
-		UsesStatement o = (UsesStatement) other;
-		return safeSubtreeMatch(node.getType(), o.getType());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(VariableDeclarationExpression node, Object other) {
 		if (!(other instanceof VariableDeclarationExpression)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index b91d7ca..a665aed 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -901,53 +897,6 @@ public abstract class ASTNode {
 	public static final int TYPE_METHOD_REFERENCE = 92;
 
 	/**
-	 * Node type constant indicating a node of type
-	 * <code>ModuleDeclaration</code>.
-	 * @see ModuleDeclaration
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int MODULE_DECLARATION = 93;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>ExportsStatement</code>.
-	 * @see ExportsStatement
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int EXPORTS_STATEMENT = 94;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>RequiresStatement</code>.
-	 * @see RequiresStatement
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int REQUIRES_STATEMENT = 95;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>UsesStatement</code>.
-	 * @see UsesStatement
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int USES_STATEMENT = 96;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>ProvidesStatement</code>.
-	 * @see ProvidesStatement
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int PROVIDES_STATEMENT = 97;
-
-	/**
-	 * Node type constant indicating a node of type
-	 * <code>OpensStatement</code>.
-	 * @see OpensStatement
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final int OPENS_STATEMENT = 98;
-	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
@@ -1015,8 +964,6 @@ public abstract class ASTNode {
 				return EnumConstantDeclaration.class;
 			case ENUM_DECLARATION :
 				return EnumDeclaration.class;
-			case EXPORTS_STATEMENT :
-				return ExportsStatement.class;
 			case EXPRESSION_METHOD_REFERENCE :
 				return ExpressionMethodReference.class;
 			case EXPRESSION_STATEMENT :
@@ -1063,8 +1010,6 @@ public abstract class ASTNode {
 				return MethodRefParameter.class;
 			case MODIFIER :
 				return Modifier.class;
-			case MODULE_DECLARATION :
-				return ModuleDeclaration.class;
 			case NAME_QUALIFIED_TYPE :
 				return NameQualifiedType.class;
 			case NORMAL_ANNOTATION :
@@ -1073,8 +1018,6 @@ public abstract class ASTNode {
 				return NullLiteral.class;
 			case NUMBER_LITERAL :
 				return NumberLiteral.class;
-			case OPENS_STATEMENT :
-				return OpensStatement.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
 			case PARAMETERIZED_TYPE :
@@ -1087,14 +1030,10 @@ public abstract class ASTNode {
 				return PrefixExpression.class;
 			case PRIMITIVE_TYPE :
 				return PrimitiveType.class;
-			case PROVIDES_STATEMENT :
-				return ProvidesStatement.class;
 			case QUALIFIED_NAME :
 				return QualifiedName.class;
 			case QUALIFIED_TYPE :
 				return QualifiedType.class;
-			case REQUIRES_STATEMENT :
-				return RequiresStatement.class;
 			case RETURN_STATEMENT :
 				return ReturnStatement.class;
 			case SIMPLE_NAME :
@@ -1143,8 +1082,6 @@ public abstract class ASTNode {
 				return TypeParameter.class;
 			case UNION_TYPE :
 				return UnionType.class;
-			case USES_STATEMENT :
-				return UsesStatement.class;
 			case VARIABLE_DECLARATION_EXPRESSION :
 				return VariableDeclarationExpression.class;
 			case VARIABLE_DECLARATION_FRAGMENT :
@@ -2031,29 +1968,14 @@ public abstract class ASTNode {
 			throw new UnsupportedOperationException("Operation only supported in JLS8 and later AST"); //$NON-NLS-1$
 		}
 	}
-
-	/**
-     * Checks that this AST operation is not used when
-     * building JLS2, JLS3, JLS4 or JLS8 level ASTs.
-     * <p>
-     * Use this method to prevent access to new properties that have been added in JLS9.
-     * </p>
-     *
-	 * @exception UnsupportedOperationException if this operation is used below JLS9
-	 * @since 3.13 BETA_JAVA9
-	 */
-	final void unsupportedBelow9() {
-		if (this.ast.apiLevel < AST.JLS9) {
-			throw new UnsupportedOperationException("Operation only supported in JLS9 and later AST"); //$NON-NLS-1$
-		}
-	}
+	
 	/**
      * Checks that this AST operation is only used when
      * building JLS2 level ASTs.
      * <p>
      * Use this method to prevent access to deprecated properties (deprecated in JLS3).
      * </p>
-     *
+     * 
 	 * @exception UnsupportedOperationException if this operation is used in an AST later than JLS2
 	 * @since 3.0
      */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 2e04d57..d902b9b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -659,23 +655,6 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(ExportsStatement node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
-	 * Subclasses may re-implement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1073,23 +1052,6 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(ModuleDeclaration node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
-	 * Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(NameQualifiedType node) {
@@ -1149,23 +1111,6 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
-	 * Subclasses may re-implement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(OpensStatement node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1247,23 +1192,6 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
-	 * Subclasses may re-implement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(ProvidesStatement node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1313,23 +1241,6 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
-	 * Subclasses may re-implement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(RequiresStatement node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1726,23 +1637,6 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
-	 * Subclasses may re-implement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public boolean visit(UsesStatement node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -2163,19 +2057,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(ExportsStatement node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(ExpressionMethodReference node) {
@@ -2467,19 +2348,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(ModuleDeclaration node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(NameQualifiedType node) {
@@ -2530,19 +2398,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(OpensStatement node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 */
 	public void endVisit(PackageDeclaration node) {
 		// default implementation: do nothing
@@ -2616,19 +2471,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(ProvidesStatement node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 */
 	public void endVisit(QualifiedName node) {
 		// default implementation: do nothing
@@ -2654,19 +2496,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(RequiresStatement node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 */
 	public void endVisit(ReturnStatement node) {
 		// default implementation: do nothing
@@ -2962,19 +2791,6 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void endVisit(UsesStatement node) {
-		// default implementation: do nothing
-	}
-
-	/**
-	 * End of visit the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing. Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(IntersectionType node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index a3a7c2a..f3d1ddc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -32,8 +28,6 @@ import org.eclipse.text.edits.TextEdit;
 
 /**
  * Java compilation unit AST node type. This is the type of the root of an AST.
- * From JLS 9 onwards, this can contain a ModuleDeclation. To be noted that not
- * all nodes make sense in all contexts.
  * <p>
  * The source range for this type of node is ordinarily the entire source file,
  * including leading and trailing whitespace and comments.
@@ -42,7 +36,7 @@ import org.eclipse.text.edits.TextEdit;
  * CompilationUnit:
  *    [ PackageDeclaration ]
  *        { ImportDeclaration }
- *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ModuleDeclaration <b>;</b> }
+ *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | <b>;</b> }
  * </pre>
  *
  * @since 2.0
@@ -78,14 +72,6 @@ public class CompilationUnit extends ASTNode {
 		new ChildPropertyDescriptor(CompilationUnit.class, "package", PackageDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "module" structural property of this node type (child type: {@link ModuleDeclaration}).
-	 *
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public static final ChildPropertyDescriptor MODULE_PROPERTY =
-		new ChildPropertyDescriptor(CompilationUnit.class, "module", ModuleDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -94,14 +80,6 @@ public class CompilationUnit extends ASTNode {
 	private static final List PROPERTY_DESCRIPTORS;
 
 	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 * @since 3.13 BETA_JAVA9
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	/**
 	 * The "types" structural property of this node type (element type: {@link AbstractTypeDeclaration}).
 	 *
 	 * @since 3.0
@@ -116,14 +94,6 @@ public class CompilationUnit extends ASTNode {
 		addProperty(IMPORTS_PROPERTY, properyList);
 		addProperty(TYPES_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
-
-		properyList = new ArrayList(5);
-		createPropertyList(CompilationUnit.class, properyList);
-		addProperty(PACKAGE_PROPERTY, properyList);
-		addProperty(IMPORTS_PROPERTY, properyList);
-		addProperty(TYPES_PROPERTY, properyList);
-		addProperty(MODULE_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
 	}
 
 	/**
@@ -138,10 +108,7 @@ public class CompilationUnit extends ASTNode {
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
-		if (apiLevel < AST.JLS9)
-			return PROPERTY_DESCRIPTORS;
-		else
-			return PROPERTY_DESCRIPTORS_9_0;
+		return PROPERTY_DESCRIPTORS;
 	}
 
 	/**
@@ -201,15 +168,10 @@ public class CompilationUnit extends ASTNode {
 	private PackageDeclaration optionalPackageDeclaration = null;
 
 	/**
-	 * The module declaration, or <code>null</code> if none; initially
-	 * <code>null</code>.
-	 */
-	private ModuleDeclaration module = null;
-	/**
 	 * Problems reported by the compiler during parsing or name resolution.
 	 */
 	private IProblem[] problems = EMPTY_PROBLEMS;
-
+	
 	/**
 	 * Internal data used to perform statements recovery.
 	 */
@@ -245,7 +207,6 @@ public class CompilationUnit extends ASTNode {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
 			// visit children in normal left to right reading order
-			acceptChild(visitor, getModule());
 			acceptChild(visitor, getPackage());
 			acceptChildren(visitor, this.imports);
 			acceptChildren(visitor, this.types);
@@ -260,7 +221,6 @@ public class CompilationUnit extends ASTNode {
 		CompilationUnit result = new CompilationUnit(target);
 		// n.b do not copy line number table or messages
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setModule((ModuleDeclaration) ASTNode.copySubtree(target, getModule()));
 		result.setPackage(
 			(PackageDeclaration) ASTNode.copySubtree(target, getPackage()));
 		result.imports().addAll(ASTNode.copySubtrees(target, imports()));
@@ -577,17 +537,6 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
-	 * Returns the node for the module declaration of this compilation
-	 * unit, or <code>null</code> if this compilation unit has a module
-	 *
-	 * @return the module declaration node, or <code>null</code> if none
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public ModuleDeclaration getModule() {
-		return this.module;
-	}
-
-	/**
 	 * Returns the node for the package declaration of this compilation
 	 * unit, or <code>null</code> if this compilation unit is in the
 	 * default package.
@@ -767,14 +716,6 @@ public class CompilationUnit extends ASTNode {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == MODULE_PROPERTY) {
-			if (get) {
-				return getModule();
-			} else {
-				setModule((ModuleDeclaration) child);
-				return null;
-			}
-		}
 		if (property == PACKAGE_PROPERTY) {
 			if (get) {
 				return getPackage();
@@ -1059,26 +1000,6 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
-	 * Sets or clears the module declaration of this compilation unit
-	 * node to the given module declaration node.
-	 *
-	 * @param module the new module declaration node, or
-	 *   <code>null</code> if this compilation unit does not have a module
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public void setModule(ModuleDeclaration module) {
-		ASTNode oldChild = this.module;
-		preReplaceChild(oldChild, module, PACKAGE_PROPERTY);
-		this.module = module;
-		postReplaceChild(oldChild, module, PACKAGE_PROPERTY);
-	}
-
-	/**
 	 * Sets or clears the package declaration of this compilation unit
 	 * node to the given package declaration node.
 	 *
@@ -1137,9 +1058,6 @@ public class CompilationUnit extends ASTNode {
 	 */
 	int treeSize() {
 		int size = memSize();
-		if (this.module != null) {
-			size += getModule().treeSize();
-		}
 		if (this.optionalPackageDeclaration != null) {
 			size += getPackage().treeSize();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
deleted file mode 100644
index 23dd1f1..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Exports statement AST node type.
- * <pre>
- * ExportsStatement:
- *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes"})
-public class ExportsStatement extends ModulePackageAccess {
-
-	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-			internalNamePropertyFactory(ExportsStatement.class);
-
-	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
-	 */
-	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
-			internalModulesPropertyFactory(ExportsStatement.class);
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(ExportsStatement.class, properyList);
-		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULES_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * Creates a new AST node for an export statement owned by the
-	 * given AST. The export statement initially is a regular (non-targetted)
-	 * single package export for an unspecified, but legal, Java package name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	ExportsStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
-	}
-
-	@Override
-	final ChildListPropertyDescriptor internalModulesProperty() {
-		return MODULES_PROPERTY;
-	}
-
-	@Override
-	final int getNodeType0() {
-		return EXPORTS_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		return cloneHelper(target, new ExportsStatement(target));
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		acceptVisitChildren(visitChildren, visitor);
-		visitor.endVisit(this);
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
deleted file mode 100644
index a079175..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Module declaration AST node type representing the module descriptor file
- *
- * <pre>
- * ModuleDeclaration:
- *  [ Javadoc ] { ExtendedModifier } <b>module</b> Name <b>{</b>
- *        [ ExportsStatement | RequiresStatement | UsesStatement | ProvidesStatement ]
- *  <b>}</b>
- * </pre>
- * <p>
- * </p>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings("rawtypes")
-public class ModuleDeclaration extends ASTNode {
-
-	/**
-	 * The "javadoc" structural property of this node type (child type: {@link Javadoc}).
-	 */
-	public static final ChildPropertyDescriptor JAVADOC_PROPERTY =
-			new ChildPropertyDescriptor(ModuleDeclaration.class, "javadoc", Javadoc.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
-	 */
-	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
-			new ChildListPropertyDescriptor(ModuleDeclaration.class, "modifiers", IExtendedModifier.class, CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "name" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleStatement}).
-	 */
-	public static final ChildListPropertyDescriptor MODULE_STATEMENTS_PROPERTY =
-		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleStatement.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(5);
-		createPropertyList(ModuleDeclaration.class, properyList);
-		addProperty(JAVADOC_PROPERTY, properyList);
-		addProperty(MODIFIERS_PROPERTY, properyList);
-		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULE_STATEMENTS_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The doc comment, or <code>null</code> if none.
-	 * Defaults to none.
-	 */
-	private Javadoc optionalDocComment = null;
-
-	/**
-	 * The extended modifiers (element type: {@link IExtendedModifier}).
-	 * defaults to an empty list
-	 * (see constructor).
-	 *
-	 */
-	private ASTNode.NodeList modifiers = null;
-
-	/**
-	 * The referenced module name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Name name = null;
-
-	/**
-	 * The list of statements (element type: {@link ModuleStatement}).
-	 * Defaults to an empty list.
-	 */
-	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_STATEMENTS_PROPERTY);
-
-	ModuleDeclaration(AST ast) {
-		super(ast);
-		unsupportedBelow9();
-		this.modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == JAVADOC_PROPERTY) {
-			if (get) {
-				return getJavadoc();
-			} else {
-				setJavadoc((Javadoc) child);
-				return null;
-			}
-		}
-		if (property == NAME_PROPERTY) {
-			if (get) {
-				return getName();
-			} else {
-				setName((Name) child);
-				return null;
-			}
-		}
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	/* (omit javadoc for this method)
-	 * Method declared on ASTNode.
-	 */
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == MODIFIERS_PROPERTY) {
-			return modifiers();
-		}
-		if (property == MODULE_STATEMENTS_PROPERTY) {
-			return moduleStatements();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	@Override
-	int getNodeType0() {
-		return MODULE_DECLARATION;
-	}
-
-	@SuppressWarnings("unchecked")
-	@Override
-	ASTNode clone0(AST target) {
-		ModuleDeclaration result = new ModuleDeclaration(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setJavadoc((Javadoc) ASTNode.copySubtree(target, getJavadoc()));
-		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
-		result.setName((SimpleName) getName().clone(target));
-		result.moduleStatements().addAll(ASTNode.copySubtrees(target, moduleStatements()));
-		return result;
-	}
-
-	@Override
-	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			// visit children in normal left to right reading order
-			acceptChild(visitor, getJavadoc());
-			acceptChildren(visitor, this.modifiers);
-			acceptChild(visitor, getName());
-			acceptChildren(visitor, this.moduleStatements);
-		}
-		visitor.endVisit(this);
-
-	}
-	/**
-	 * Returns the doc comment node.
-	 *
-	 * @return the doc comment node, or <code>null</code> if none
-	 */
-	public Javadoc getJavadoc() {
-		return this.optionalDocComment;
-	}
-
-	/**
-	 * Sets or clears the doc comment node.
-	 *
-	 * @param docComment the doc comment node, or <code>null</code> if none
-	 * @exception IllegalArgumentException if the doc comment string is invalid
-	 */
-	public void setJavadoc(Javadoc docComment) {
-		ChildPropertyDescriptor p = JAVADOC_PROPERTY;
-		ASTNode oldChild = this.optionalDocComment;
-		preReplaceChild(oldChild, docComment, p);
-		this.optionalDocComment = docComment;
-		postReplaceChild(oldChild, docComment, p);
-	}
-
-	/**
-	 * Returns the modifiers explicitly specified on this declaration.
-	 * <p>
-	 *  this method is a convenience method that
-	 * computes these flags from {@link #modifiers()}.
-	 * </p>
-	 *
-	 * @return the bit-wise "or" of <code>Modifier</code> constants
-	 * @see Modifier
-	 */
-	public int getModifiers() {
-		// convenience method -
-		// performance could be improved by caching computed flags
-		// but this would require tracking changes to this.modifiers
-		int computedmodifierFlags = Modifier.NONE;
-		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
-			Object x = it.next();
-			if (x instanceof Modifier) {
-				computedmodifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
-			}
-		}
-		return computedmodifierFlags;
-	}
-
-	/**
-	 * Returns the name of this module declaration.
-	 *
-	 * @return the module name
-	 */
-	public Name getName()  {
-		if (this.name == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.name == null) {
-					preLazyInit();
-					this.name =this.ast.newQualifiedName(
-							new SimpleName(this.ast), new SimpleName(this.ast));
-					postLazyInit(this.name, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.name;
-	}
-
-	/**
-	 * Sets the module name in to the given name.
-	 *
-	 * @param name the new module name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setName(Name name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.name;
-		preReplaceChild(oldChild, name, NAME_PROPERTY);
-		this.name = name;
-		postReplaceChild(oldChild, name, NAME_PROPERTY);
-	}
-
-	/**
-	 * Returns the live ordered list of modifiers and annotations
-	 * of this declaration.
-	 *
-	 * @return the live list of modifiers and annotations
-	 *    (element type: {@link IExtendedModifier})
-	 */
-	public List modifiers() {
-		return this.modifiers;
-	}
-
-	/**
-	 * Returns the live list of statements in this module. Adding and
-	 * removing nodes from this list affects this node dynamically.
-	 * All nodes in this list must be <code>Statement</code>s;
-	 * attempts to add any other type of node will trigger an
-	 * exception.
-	 *
-	 * @return the live list of statements in this module declaration
-	 *    (element type: {@link ModuleStatement})
-	 */
-	public List moduleStatements() {
-		return this.moduleStatements;
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 4 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return	memSize()
-			+ (this.optionalDocComment == null ? 0 : getJavadoc().treeSize())
-			+ this.modifiers.listSize()
-			+ (this.name == null ? 0 : getName().treeSize())
-			+ this.moduleStatements.listSize();
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
deleted file mode 100644
index 4dae45a..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.List;
-
-/**
- * Abstract base class of AST nodes that represent exports and opens statements.
- *
- * <pre>
- * ModuleStatement: [ {@link ExportsStatement} |
- *    {@link OpensStatement} ]
- * </pre>
- *
- * @noextend This class is not intended to be subclassed by clients.
- * @since 3.13 BETA_JAVA9
- */
-@SuppressWarnings({"rawtypes", "unchecked"})
-public abstract class ModulePackageAccess extends ModuleStatement {
-
-	/**
-	 * The package name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	protected Name name = null;
-
-	/**
-	 * The target modules
-	 * (element type: {@link Name}).
-	 * Defaults to an empty list. (see constructor)
-	 */
-	protected ASTNode.NodeList modules = null;
-
-	/**
-	 * Returns structural property descriptor for the "modules" property
-	 * of this node (element type: {@link Name}).
-	 *
-	 * @return the property descriptor
-	 */
-	abstract ChildListPropertyDescriptor internalModulesProperty();
-
-	/**
-	 * Returns structural property descriptor for the "name" property
-	 * of this node (child type: {@link Name}).
-	 *
-	 * @return the property descriptor
-	 */
-	abstract ChildPropertyDescriptor internalNameProperty();
-
-	/**
-	 * Returns structural property descriptor for the "name" property
-	 * of this node (child type: {@link Name}).
-	 *
-	 * @return the property descriptor
-	 */
-	public final ChildPropertyDescriptor getNameProperty() {
-		return internalNameProperty();
-	}
-
-	/**
-	 * Creates and returns a structural property descriptor for the
-	 * "name" property declared on the given concrete node type (child type: {@link Name}).
-	 *
-	 * @return the property descriptor
-	 */
-	static final ChildPropertyDescriptor internalNamePropertyFactory(Class nodeClass) {
-		return new ChildPropertyDescriptor(nodeClass, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-	}
-
-	/**
-	 * Creates and returns a structural property descriptor for the
-	 * "modules" property declared on the given concrete node type (element type: {@link Name}).
-	 *
-	 * @return the property descriptor
-	 */
-	static final ChildListPropertyDescriptor internalModulesPropertyFactory(Class nodeClass) {
-		return new ChildListPropertyDescriptor(nodeClass, "modules", Name.class, NO_CYCLE_RISK); //$NON-NLS-1$
-	}
-
-	/**
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	ModulePackageAccess(AST ast) {
-		super(ast);
-		this.modules = new ASTNode.NodeList(internalModulesProperty());
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == internalNameProperty()) {
-			if (get) {
-				return getName();
-			} else {
-				setName((Name) child);
-				return null;
-			}
-		}
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == internalModulesProperty()) {
-			return modules();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	/**
-	 * Returns the name of the package
-	 *
-	 * @return the package name node
-	 */
-	public Name getName()  {
-		if (this.name == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.name == null) {
-					preLazyInit();
-					this.name =this.ast.newQualifiedName(
-							new SimpleName(this.ast), new SimpleName(this.ast));
-					ChildPropertyDescriptor p = internalNameProperty();
-					postLazyInit(this.name, p);
-				}
-			}
-		}
-		return this.name;
-	}
-
-	/**
-	 * Sets the name of the package to the given name.
-	 *
-	 * @param name the new  package name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setName(Name name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.name;
-		ChildPropertyDescriptor p = internalNameProperty();
-		preReplaceChild(oldChild, name, p);
-		this.name = name;
-		postReplaceChild(oldChild, name, p);
-	}
-
-	/**
-	 * Returns the live ordered list of target modules for this
-	 * statement.
-	 *
-	 * @return the live list of target modules
-	 *    (element type: {@link Name})
-	 */
-	public List modules() {
-		return this.modules;
-	}
-
-	protected ASTNode cloneHelper(AST target, ModulePackageAccess result) {
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setName((Name) getName().clone(target));
-		result.modules().addAll(ASTNode.copySubtrees(target, modules()));
-		return result;
-	}
-
-	protected void acceptVisitChildren(boolean visitChildren, ASTVisitor visitor) {
-		if (visitChildren) {
-			acceptChild(visitor, getName());
-			acceptChildren(visitor, this.modules);
-		}
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.name == null ? 0 : getName().treeSize())
-			+ this.modules.listSize();
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
deleted file mode 100644
index 97e2514..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-/**
- * Abstract base class of AST nodes that represent module statements.
- * There are many kinds of module statements.
- *
- * <pre>
- * ModuleStatement: [ {@link ExportsStatement} |
- *    {@link RequiresStatement} |
- *    {@link UsesStatement} |
- *    {@link ProvidesStatement} ]
- * </pre>
- *
- * @noextend This class is not intended to be subclassed by clients.
- * @since 3.13 BETA_JAVA9
- */
-public abstract class ModuleStatement extends ASTNode {
-
-	ModuleStatement(AST ast) {
-		super(ast);
-		unsupportedBelow9();
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
deleted file mode 100644
index ed137ac..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * opens statement AST node type.
- * <pre>
- * OpensStatement:
- *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes"})
-public class OpensStatement extends ModulePackageAccess {
-
-	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		internalNamePropertyFactory(OpensStatement.class);
-	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
-	 */
-	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
-			internalModulesPropertyFactory(OpensStatement.class);
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(OpensStatement.class, properyList);
-		addProperty(NAME_PROPERTY, properyList);
-		addProperty(MODULES_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * Creates a new AST node for an opens statement owned by the
-	 * given AST. The open statement initially is a regular (non-targetted)
-	 * single package open for an unspecified, but legal, Java package name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	OpensStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ChildPropertyDescriptor internalNameProperty() {
-		return NAME_PROPERTY;
-	}
-
-	@Override
-	final ChildListPropertyDescriptor internalModulesProperty() {
-		return MODULES_PROPERTY;
-	}
-
-	@Override
-	final int getNodeType0() {
-		return OPENS_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		return cloneHelper(target, new OpensStatement(target));
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		acceptVisitChildren(visitChildren, visitor);
-		visitor.endVisit(this);
-	}
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
deleted file mode 100644
index 2c7da2b..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Provides statement AST node type.
- * <pre>
- * ProvidesStatement:
- *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes", "unchecked"})
-public class ProvidesStatement extends ModuleStatement {
-
-	/**
-	 * The "interface type" structural property of this node type (child type: {@link Type}).
-	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(ProvidesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The "implementation type" structural property of this node type (element type: {@link Type}).
-	 */
-	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
-			new ChildListPropertyDescriptor(ProvidesStatement.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(3);
-		createPropertyList(ProvidesStatement.class, properyList);
-		addProperty(TYPE_PROPERTY, properyList);
-		addProperty(IMPLEMENTATIONS_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The interface name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Type type = null;
-
-	/**
-	 * The implementation names
-	 * (element type: {@link Name}).
-	 * Defaults to an empty list.
-	 */
-	private ASTNode.NodeList implementations =
-		new ASTNode.NodeList(IMPLEMENTATIONS_PROPERTY);
-
-	/**
-	 * Creates a new AST node for an provides statement owned by the
-	 * given AST. The provides statement initially is
-	 * for an unspecified, but legal, Java type name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	ProvidesStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == IMPLEMENTATIONS_PROPERTY) {
-			return implementations();
-		}
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return PROVIDES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		ProvidesStatement result = new ProvidesStatement(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setType((Type) getType().clone(target));
-		result.implementations().addAll(ASTNode.copySubtrees(target, implementations()));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChild(visitor, getType());
-			acceptChildren(visitor, this.implementations);
-		}
-		visitor.endVisit(this);
-	}
-
-
-	/**
-	 * Returns the type name in this statement
-	 *
-	 * @return the type name
-	 */
-	public Type getType()  {
-		if (this.type == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.type == null) {
-					preLazyInit();
-					this.type =this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.type, TYPE_PROPERTY);
-				}
-			}
-		}
-		return this.type;
-	}
-
-	/**
-	 * Sets the target module name in exports declaration to the given name.
-	 *
-	 * @param type the new target module name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setType(Type type) {
-		if (type == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.type;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.type = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
-	}
-
-	/**
-	 * Returns the live ordered list of implementations for the interface in this provides statement.
-	 *
-	 * @return the live list of implementations for the interface
-	 *    (element type: {@link Name})
-	 */
-	public List implementations() {
-		return this.implementations;
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.type == null ? 0 : getType().treeSize())
-			+ this.implementations.listSize();
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
deleted file mode 100644
index abebef4..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Requires statement AST node type.
- * <pre>
- * RequiresStatement:
- *     <b>requires</b> { ExtendedModifier } Name <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings({"rawtypes", "unchecked"})
-public class RequiresStatement extends ModuleStatement {
-
-	/**
-	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
-	 */
-	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
-		new ChildListPropertyDescriptor(RequiresStatement.class, "modifiers", IExtendedModifier.class, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * The module structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor NAME_PROPERTY =
-		new ChildPropertyDescriptor(RequiresStatement.class, "name", Name.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List propertyList = new ArrayList(3);
-		createPropertyList(RequiresStatement.class, propertyList);
-		addProperty(MODIFIERS_PROPERTY, propertyList);
-		addProperty(NAME_PROPERTY, propertyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(propertyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The extended modifiers (element type: {@link IExtendedModifier}).
-	 * defaults to an empty list
-	 */
-	private ASTNode.NodeList modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
-
-	/**
-	 * The referenced module name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Name name = null;
-
-	/**
-	 * Creates a new AST node for an requires statement owned by the
-	 * given AST. The requires statement initially is a regular (no modifiers)
-	 * requires for an unspecified, but legal, Java module name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	RequiresStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == NAME_PROPERTY) {
-			if (get) {
-				return getName();
-			} else {
-				setName((Name) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
-		if (property == MODIFIERS_PROPERTY) {
-			return modifiers();
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetChildListProperty(property);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return REQUIRES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		RequiresStatement result = new RequiresStatement(target);
-		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
-		result.setName((Name) getName().clone(target));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChildren(visitor, this.modifiers);
-			acceptChild(visitor, getName());
-		}
-		visitor.endVisit(this);
-	}
-
-	/**
-	 * Returns the live ordered list of modifiers
-	 * of this declaration.
-	 * <p>
-	 * Note that the not all modifiers are legal.
-	 * </p>
-	 *
-	 * @return the live list of modifiers
-	 *    (element type: {@link IExtendedModifier})
-	 */
-	public List modifiers() {
-		return this.modifiers;
-	}
-
-	/**
-	 * Returns the modifiers explicitly specified on this declaration.
-	 * <p>
-	 * this method is a convenience method that
-	 * computes these flags from <code>modifiers()</code>.
-	 * </p>
-	 *
-	 * @return the bit-wise or of <code>Modifier</code> constants
-	 * @see Modifier
-	 */
-	public int getModifiers() {
-		// do not cache - performance could be improved by caching computed flags
-		// but this would require tracking changes to this.modifiers
-		int computedModifierFlags = Modifier.NONE;
-		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
-			Object x = it.next();
-			if (x instanceof Modifier) {
-				computedModifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
-			}
-		}
-		return computedModifierFlags;
-	}
-
-	/**
-	 * Returns the module name referenced by this declaration.
-	 *
-	 * @return the module referenced
-	 */
-	public Name getName()  {
-		if (this.name == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.name == null) {
-					preLazyInit();
-					this.name =this.ast.newQualifiedName(
-							new SimpleName(this.ast), new SimpleName(this.ast));
-					postLazyInit(this.name, NAME_PROPERTY);
-				}
-			}
-		}
-		return this.name;
-	}
-
-	/**
-	 * Sets the module name in requires statement to the given name.
-	 *
-	 * @param name the new module name
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setName(Name name) {
-		if (name == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.name;
-		preReplaceChild(oldChild, name, NAME_PROPERTY);
-		this.name = name;
-		postReplaceChild(oldChild, name, NAME_PROPERTY);
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 2 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
-			+ (this.name == null ? 0 : getName().treeSize());
-	}
-
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
deleted file mode 100644
index d94c3cb..0000000
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.dom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Uses statement AST node type.
- * <pre>
- * UsesStatement:
- *     <b>uses</b> Name <b>;</b>
- * </pre>
- *
- * @since 3.13 BETA_JAVA9
- * @noinstantiate This class is not intended to be instantiated by clients.
- */
-@SuppressWarnings("rawtypes")
-public class UsesStatement extends ModuleStatement {
-
-	/**
-	 * The "type" structural property of this node type (child type: {@link Name}).
-	 */
-	public static final ChildPropertyDescriptor TYPE_PROPERTY =
-		new ChildPropertyDescriptor(UsesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
-
-	/**
-	 * A list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor}),
-	 * or null if uninitialized.
-	 */
-	private static final List PROPERTY_DESCRIPTORS_9_0;
-
-	static {
-		List properyList = new ArrayList(2);
-		createPropertyList(UsesStatement.class, properyList);
-		addProperty(TYPE_PROPERTY, properyList);
-		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
-	}
-
-	/**
-	 * Returns a list of structural property descriptors for this node type.
-	 * Clients must not modify the result.
-	 *
-	 * @param apiLevel the API level; one of the
-	 * <code>AST.JLS*</code> constants
-
-	 * @return a list of property descriptors (element type:
-	 * {@link StructuralPropertyDescriptor})
-	 */
-	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS_9_0;
-	}
-
-	/**
-	 * The module name; lazily initialized; defaults to a unspecified,
-	 * legal Java identifier.
-	 */
-	private Type type = null;
-
-	/**
-	 * Creates a new AST node for an uses statement owned by the
-	 * given AST. The uses statement initially is
-	 * for an unspecified, but legal, Java type name.
-	 * <p>
-	 * N.B. This constructor is package-private; all subclasses must be
-	 * declared in the same package; clients are unable to declare
-	 * additional subclasses.
-	 * </p>
-	 *
-	 * @param ast the AST that is to own this node
-	 */
-	UsesStatement(AST ast) {
-		super(ast);
-	}
-
-	@Override
-	final List internalStructuralPropertiesForType(int apiLevel) {
-		return propertyDescriptors(apiLevel);
-	}
-
-	@Override
-	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
-		if (property == TYPE_PROPERTY) {
-			if (get) {
-				return getType();
-			} else {
-				setType((Type) child);
-				return null;
-			}
-		}
-
-		// allow default implementation to flag the error
-		return super.internalGetSetChildProperty(property, get, child);
-	}
-
-	@Override
-	final int getNodeType0() {
-		return USES_STATEMENT;
-	}
-
-	@Override
-	ASTNode clone0(AST target) {
-		UsesStatement result = new UsesStatement(target);
-		result.setSourceRange(getStartPosition(), getLength());
-		result.setType((Type) getType().clone(target));
-		return result;
-	}
-
-	@Override
-	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
-		// dispatch to correct overloaded match method
-		return matcher.match(this, other);
-	}
-
-	@Override
-	void accept0(ASTVisitor visitor) {
-		boolean visitChildren = visitor.visit(this);
-		if (visitChildren) {
-			acceptChild(visitor, getType());
-		}
-		visitor.endVisit(this);
-	}
-
-
-	/**
-	 * Returns the type in this statement
-	 *
-	 * @return the type
-	 */
-	public Type getType()  {
-		if (this.type == null) {
-			// lazy init must be thread-safe for readers
-			synchronized (this) {
-				if (this.type == null) {
-					preLazyInit();
-					this.type = this.ast.newPrimitiveType(PrimitiveType.INT);
-					postLazyInit(this.type, TYPE_PROPERTY);
-				}
-			}
-		}
-		return this.type;
-	}
-
-	/**
-	 * Sets the type in uses statement
-	 *
-	 * @param type the new type in uses
-	 * @exception IllegalArgumentException if:
-	 * <ul>
-	 * <li>the node belongs to a different AST</li>
-	 * <li>the node already has a parent</li>
-	 * </ul>
-	 */
-	public void setType(Type type) {
-		if (type == null) {
-			throw new IllegalArgumentException();
-		}
-		ASTNode oldChild = this.type;
-		preReplaceChild(oldChild, type, TYPE_PROPERTY);
-		this.type = type;
-		postReplaceChild(oldChild, type, TYPE_PROPERTY);
-	}
-
-	@Override
-	int memSize() {
-		return BASE_NODE_SIZE + 1 * 4;
-	}
-
-	@Override
-	int treeSize() {
-		return
-			memSize()
-			+ (this.type == null ? 0 : getType().treeSize());
-	}
-
-}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 88aa9e3..1d816cb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -207,24 +207,11 @@ public class NaiveASTFlattener extends ASTVisitor {
 		}
 	}
 
-	private void printTypes(List<Type> types, String prefix) {
-		if (types.size() > 0) {
-			this.buffer.append(" " + prefix + " ");//$NON-NLS-1$ //$NON-NLS-2$
-			Type type = types.get(0);
-			type.accept(this);
-			for (int i = 1, l = types.size(); i < l; ++i) {
-				this.buffer.append(","); //$NON-NLS-1$
-				type = types.get(0);
-				type.accept(this);
-			}
-		}
-	}
-
 	/**
 	 * reference node helper function that is common to all
 	 * the difference reference nodes.
-	 *
-	 * @param typeArguments list of type arguments
+	 * 
+	 * @param typeArguments list of type arguments 
 	 */
 	private void visitReferenceTypeArguments(List typeArguments) {
 		this.buffer.append("::");//$NON-NLS-1$
@@ -757,14 +744,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(ExportsStatement node) {
-		return visit(node, "exports"); //$NON-NLS-1$
-	}
-
 	/*
 	 * @see ASTVisitor#visit(ExpressionMethodReference)
-	 *
+	 * 
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1225,32 +1207,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(ModuleDeclaration node) {
-		printModifiers(node.modifiers());
-		this.buffer.append("module"); //$NON-NLS-1$
-		this.buffer.append(" "); //$NON-NLS-1$
-		node.getName().accept(this);
-		this.buffer.append(" {\n"); //$NON-NLS-1$
-		this.indent++;
-		for (ModuleStatement stmt : (List<ModuleStatement>)node.moduleStatements()) {
-			stmt.accept(this);
-		}
-		this.indent--;
-		this.buffer.append("}"); //$NON-NLS-1$
-		return false;
-	}
-
-	private boolean visit(ModulePackageAccess node, String keyword) {
-		printIndent();
-		this.buffer.append(keyword);
-		this.buffer.append(" ");//$NON-NLS-1$
-		node.getName().accept(this);
-		printTypes(node.modules(), "to"); //$NON-NLS-1$
-		this.buffer.append(";\n");//$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(NameQualifiedType)
 	 * @since 3.10
@@ -1298,11 +1254,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(OpensStatement node) {
-		return visit(node, "opens"); //$NON-NLS-1$
-	}
-
 	/*
 	 * @see ASTVisitor#visit(PackageDeclaration)
 	 */
@@ -1379,17 +1330,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(ProvidesStatement node) {
-		printIndent();
-		this.buffer.append("provides");//$NON-NLS-1$
-		this.buffer.append(" ");//$NON-NLS-1$
-		node.getType().accept(this);
-		printTypes(node.implementations(), "with"); //$NON-NLS-1$
-		this.buffer.append(";\n");//$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(QualifiedName)
 	 */
@@ -1412,16 +1352,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(RequiresStatement node) {
-		printIndent();
-		this.buffer.append("requires");//$NON-NLS-1$
-		this.buffer.append(" ");//$NON-NLS-1$
-		node.getName().accept(this);
-		this.buffer.append(";\n");//$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(ReturnStatement)
 	 */
@@ -1921,16 +1851,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
-	@Override
-	public boolean visit(UsesStatement node) {
-		printIndent();
-		this.buffer.append("uses");//$NON-NLS-1$
-		this.buffer.append(" ");//$NON-NLS-1$
-		node.getType().accept(this);
-		this.buffer.append(";\n");//$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
commit af85a90374c262057daf6363bb015406bf214326
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Wed Dec 21 17:35:56 2016 +0530

    Fix for bug 496123 Fix for bug 496123 [9] DOM AST for ModuleDeclaration
    in module-info.java - conversion part

45	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
14	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
80	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
157	45	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
157	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
80	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
184	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
86	4	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
126	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
329	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
207	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
36	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
125	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
224	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
251	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
188	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
83	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index c5220c2..c3dde4f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -130,7 +130,50 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			checkSourceRange(fieldAccess, "this.y2", contents);
 			expr = resources.get(5);
 			VariableDeclarationExpression variableDeclarationExpression = (VariableDeclarationExpression) expr;
-			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);			
+			checkSourceRange(variableDeclarationExpression, "Y y4 = new Y()", contents);
 	}
-
+	public void testBug496123_0001() throws JavaModelException {
+		this.workingCopies = new ICompilationUnit[1];
+		String content =  "module first {"
+				+ "  requires second;\n"
+				+ "  exports pack11 to third, fourth;\n"
+				+ "  uses NewType;\n"
+				+ "  provides pack22.I22 with pack11.packinternal.Z11;\n"
+				+ "}";
+		this.workingCopies[0] = getWorkingCopy(
+				"/Converter9/src/module-info.java", content);
+		
+		CompilationUnit unit = (CompilationUnit) runConversion(AST.JLS9, this.workingCopies[0], false/*no bindings*/);
+		ModuleDeclaration moduleDecl = unit.getModule();
+		
+		checkSourceRange(moduleDecl, content, content);
+		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		assertTrue(stmts.size() > 0);
+		
+		RequiresStatement req = (RequiresStatement) stmts.get(0);
+		checkSourceRange(req, "requires second;", content);
+		
+		ExportsStatement exp = (ExportsStatement) stmts.get(1);
+		checkSourceRange(exp, "exports pack11 to third, fourth;", content);
+		checkSourceRange(exp.getName(), "pack11", content);
+		List<Name> modules = exp.modules();
+		assertTrue(modules.size() == 2);
+		checkSourceRange(modules.get(0), "third", content);
+		checkSourceRange(modules.get(1), "fourth", content);
+		
+		UsesStatement u = (UsesStatement) stmts.get(2);
+		checkSourceRange(u, "uses NewType;", content);
+		Type type = u.getType();
+		checkSourceRange(type, "NewType", content);
+		
+		ProvidesStatement p = (ProvidesStatement) stmts.get(3);
+		checkSourceRange(p, "provides pack22.I22 with pack11.packinternal.Z11;", content);
+		type = p.getType();
+		checkSourceRange(type, "pack22.I22", content);
+		List<Type> impls = p.implementations();
+		assertTrue(impls.size() > 0);
+		type = impls.get(0);
+		checkSourceRange(type, "pack11.packinternal.Z11", content);		
+	}
+// Add new tests here 
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index 3909178..29fa62f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2015 IBM Corporation and others.
+ * Copyright (c) 2004, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -369,7 +373,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 92, hi); // last known one
+		assertEquals("Wrong last known type", 98, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 4830f26..5c481ef 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -8847,14 +8851,20 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			ASTNode.CREATION_REFERENCE,
 			ASTNode.EXPRESSION_METHOD_REFERENCE,
 			ASTNode.SUPER_METHOD_REFERENCE,
-			ASTNode.TYPE_METHOD_REFERENCE
+			ASTNode.TYPE_METHOD_REFERENCE,
+			ASTNode.MODULE_DECLARATION,
+			ASTNode.EXPORTS_STATEMENT,
+			ASTNode.REQUIRES_STATEMENT,
+			ASTNode.USES_STATEMENT,
+			ASTNode.PROVIDES_STATEMENT,
+			ASTNode.OPENS_STATEMENT
 		};
-		
+
 		// assert that nodeType values are correct:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			assertSame(i + 1, nodeTypes[i]);
 		}
-		
+
 		// test nodeClassForType:
 		for (int i= 0; i < nodeTypes.length; i++) {
 			int nodeType = nodeTypes[i];
@@ -8862,7 +8872,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			try {
 				node = this.ast.createInstance(nodeType);
 			} catch (IllegalArgumentException e) {
-				if (this.API_LEVEL < getJLS8() && e.getCause() instanceof UnsupportedOperationException) {
+				if (this.API_LEVEL < AST.JLS9 && e.getCause() instanceof UnsupportedOperationException) {
 					continue;
 				} else {
 					throw new AssertionFailedError("missing node type: " + nodeType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
index ab16c1b..aedd896 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java
@@ -48,6 +48,12 @@ public final class CharOperation {
 	 */
 	public static final char[] ALL_PREFIX = new char[] {'*'};
 
+	/**
+	 * Constant for comma
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final char[] COMMA_SEPARATOR = new char[] {','};
+
 /**
  * Answers a new array with appending the suffix character at the end of the array.
  * <br>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 9948fdc..34f4984 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -239,6 +239,10 @@ public class Util implements SuffixConstants {
 	public static final String LINE_SEPARATOR = System.getProperty("line.separator"); //$NON-NLS-1$
 
 	public static final String EMPTY_STRING = new String(CharOperation.NO_CHAR);
+	/**
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final String COMMA_SEPARATOR = new String(CharOperation.COMMA_SEPARATOR);
 	public static final int[] EMPTY_INT_ARRAY= new int[0];
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 4232757..ca977c9 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -1504,10 +1504,23 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented exports statement
+	 * node for an unspecified, but legal, name; no target modules
+	 *
+	 * @return a new unparented exports statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ExportsStatement newExportsStatement() {
+		ExportsStatement result = new ExportsStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates an unparented expression method reference node owned by this AST.
 	 * By default, the expression and method name are unspecified (but legal),
 	 * and there are no type arguments.
-	 * 
+	 *
 	 * @return a new unparented expression method reference expression node
 	 * @exception UnsupportedOperationException if this operation is used in a JLS2, JLS3 or JLS4 AST
 	 * @since 3.10
@@ -1924,6 +1937,20 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented module declaration
+	 * node for an unspecified, but legal, name; no modifiers; no javadoc;
+	 * and an empty list of statements.
+	 *
+	 * @return a new unparented module declaration node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ModuleDeclaration newModuleDeclaration() {
+		ModuleDeclaration result = new ModuleDeclaration(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented name node for the given name.
 	 * The name string must consist of 1 or more name segments separated
 	 * by single dots '.'. Returns a {@link QualifiedName} if the name has
@@ -2087,6 +2114,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented opens statement
+	 * node for an unspecified, but legal, name; no target modules
+	 *
+	 * @return a new unparented opens statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public OpensStatement newOpensStatement() {
+		OpensStatement result = new OpensStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates an unparented package declaration node owned by this AST.
 	 * The package declaration initially declares a package with an
 	 * unspecified name.
@@ -2170,6 +2210,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented provides statement
+	 * node for an unspecified, but legal, type; no target types
+	 *
+	 * @return a new unparented provides statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ProvidesStatement newProvidesStatement() {
+		ProvidesStatement result = new ProvidesStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates and returns a new unparented qualified name node for the given
 	 * qualifier and simple name child node.
 	 *
@@ -2216,6 +2269,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented requires statement
+	 * node for an unspecified, but legal, name;
+	 *
+	 * @return a new unparented requires statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public RequiresStatement newRequiresStatement() {
+		RequiresStatement result = new RequiresStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates a new unparented return statement node owned by this AST.
 	 * By default, the return statement has no expression.
 	 *
@@ -2583,6 +2649,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates and returns a new unparented uses statement
+	 * node for an unspecified, but legal, name;
+	 *
+	 * @return a new unparented uses statement node
+	 * @exception UnsupportedOperationException if this operation is used in level less than JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public UsesStatement newUsesStatement() {
+		UsesStatement result = new UsesStatement(this);
+		return result;
+	}
+
+	/**
 	 * Creates a new unparented intersection type node owned by this AST.
 	 * By default, the intersection type has no types.
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index c20728c..1f21c4f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -17,11 +17,13 @@
 
 package org.eclipse.jdt.core.dom;
 
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
@@ -42,6 +44,7 @@ import org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
@@ -1380,12 +1383,15 @@ class ASTConverter {
 					if (type == null) {
 						compilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);
 					} else {
-						compilationUnit.types().add(type);
+						if (type instanceof ModuleDeclaration)
+							compilationUnit.setModule((ModuleDeclaration) type);
+						else
+							compilationUnit.types().add(type);
 					}
 				}
 			}
 			compilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);
-	
+
 			int problemLength = unit.compilationResult.problemCount;
 			if (problemLength != 0) {
 				CategorizedProblem[] resizedProblems = null;
@@ -1684,6 +1690,24 @@ class ASTConverter {
 		return newStatement;
 	}
 
+	private ModulePackageAccess getPackageVisibilityStatement(
+			org.eclipse.jdt.internal.compiler.ast.PackageVisibilityStatement pvsStmt, ModulePackageAccess stmt) {
+		int sourceEnd = pvsStmt.declarationSourceEnd;
+		if (pvsStmt.declarationEnd > sourceEnd) sourceEnd = pvsStmt.declarationEnd; // TODO: working around a compiler issue
+		stmt.setName(getUpdatedName(pvsStmt.pkgName, pvsStmt.pkgRef.sourceStart, pvsStmt.pkgRef.sourceEnd));
+		int tmp = sourceEnd;
+		if (pvsStmt.targets != null && pvsStmt.targets.length > 0) {
+			List<Name> modules = stmt.modules();
+			for (ModuleReference moduleRef : pvsStmt.getTargetedModules()) {
+				modules.add(getUpdatedName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd));
+				if (tmp < moduleRef.sourceEnd) tmp = moduleRef.sourceEnd;
+			}
+		}
+		if (tmp > sourceEnd) sourceEnd = tmp;
+		stmt.setSourceRange(pvsStmt.declarationSourceStart, sourceEnd - pvsStmt.declarationSourceStart + 1);			
+		return stmt;
+	}
+
 	public Expression convert(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		if ((expression.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) != 0) {
 			return convertToParenthesizedExpression(expression);
@@ -2005,54 +2029,50 @@ class ASTConverter {
 		return literal;
 	}
 
-	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
-		if (bodyDeclaration.getJavadoc() == null) {
-			if (javadoc != null) {
-				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
-					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
-				}
-				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
-				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
-					Javadoc docComment = (Javadoc) comment;
-					if (this.resolveBindings) {
-						recordNodes(docComment, javadoc);
-						// resolve member and method references binding
-						Iterator tags = docComment.tags().listIterator();
-						while (tags.hasNext()) {
-							recordNodes(javadoc, (TagElement) tags.next());
-						}
+	interface IGetJavaDoc {
+		Javadoc getJavaDoc();
+	}
+	interface ISetJavaDoc {
+		void setJavadoc(Javadoc javadoc);
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, IGetJavaDoc getJ, ISetJavaDoc setJ) {
+		if (getJ.getJavaDoc() == null) {
+			Javadoc docComment = convert(javadoc);
+			if (docComment != null) 
+				setJ.setJavadoc(docComment);
+		}
+	}
+	private Javadoc convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc) {
+		Javadoc docComment = null;
+		if (javadoc != null) {
+			if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
+				this.commentMapper = new DefaultCommentMapper(this.commentsTable);
+			}
+			Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
+			if (comment != null && comment.isDocComment() && comment.getParent() == null) {
+				docComment = (Javadoc) comment;
+				if (this.resolveBindings) {
+					recordNodes(docComment, javadoc);
+					// resolve member and method references binding
+					Iterator tags = docComment.tags().listIterator();
+					while (tags.hasNext()) {
+						recordNodes(javadoc, (TagElement) tags.next());
 					}
-					bodyDeclaration.setJavadoc(docComment);
 				}
 			}
 		}
+		return docComment;
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, BodyDeclaration bodyDeclaration) {
+		convert(javadoc, bodyDeclaration::getJavadoc, bodyDeclaration::setJavadoc);
+	}
+	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, ModuleDeclaration moduleDeclaration) {
+		convert(javadoc, moduleDeclaration::getJavadoc, moduleDeclaration::setJavadoc);
 	}
 
 	public void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, PackageDeclaration packageDeclaration) {
-		switch(this.ast.apiLevel) {
-			case AST.JLS2_INTERNAL :
-				return;
-		}
-		if (packageDeclaration.getJavadoc() == null) {
-			if (javadoc != null) {
-				if (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {
-					this.commentMapper = new DefaultCommentMapper(this.commentsTable);
-				}
-				Comment comment = this.commentMapper.getComment(javadoc.sourceStart);
-				if (comment != null && comment.isDocComment() && comment.getParent() == null) {
-					Javadoc docComment = (Javadoc) comment;
-					if (this.resolveBindings) {
-						recordNodes(docComment, javadoc);
-						// resolve member and method references binding
-						Iterator tags = docComment.tags().listIterator();
-						while (tags.hasNext()) {
-							recordNodes(javadoc, (TagElement) tags.next());
-						}
-					}
-					packageDeclaration.setJavadoc(docComment);
-				}
-			}
-		}
+		if (this.ast.apiLevel == AST.JLS2_INTERNAL) return;
+		convert(javadoc, packageDeclaration::getJavadoc, packageDeclaration::setJavadoc);
 	}
 
 	public LabeledStatement convert(org.eclipse.jdt.internal.compiler.ast.LabeledStatement statement) {
@@ -2936,6 +2956,12 @@ class ASTConverter {
 				} else {
 					return convertToAnnotationDeclaration(typeDeclaration);
 				}
+			case org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.MODULE_DECL :
+				if (this.ast.apiLevel < AST.JLS9) {
+					return null;
+				} else {
+					return convertToModuleDeclaration(typeDeclaration);
+				}
 		}
 
 		checkCanceled();
@@ -3253,6 +3279,81 @@ class ASTConverter {
 		return fieldDeclaration;
 	}
 
+	public ModuleDeclaration convertToModuleDeclaration(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
+		checkCanceled();
+		if (this.scanner.sourceLevel < ClassFileConstants.JDK9) return null;
+		org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) typeDeclaration;
+		ModuleDeclaration moduleDecl = this.ast.newModuleDeclaration();
+		convert(moduleDeclaration.javadoc, moduleDecl);
+		setModifiers(moduleDecl, moduleDeclaration);
+		Name moduleName = getUpdatedName(moduleDeclaration.moduleName, moduleDeclaration.sourceStart, moduleDeclaration.sourceEnd);
+		moduleDecl.setName(moduleName);
+		moduleDecl.setSourceRange(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd - moduleDeclaration.declarationSourceStart + 1);
+
+		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
+		TreeSet<ModuleStatement> tSet = new TreeSet<> (new Comparator() {
+			public int compare(Object o1, Object o2) {
+				int p1 = ((ModuleStatement) o1).getStartPosition();
+				int p2 = ((ModuleStatement) o2).getStartPosition();
+				return p1 < p2 ? -1 : p1 == p2 ? 0 : 1;
+			}
+		});
+		for (int i = 0; i < moduleDeclaration.exportsCount; ++i) {
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.exports[i], new ExportsStatement(this.ast)));
+		}
+		for (int i = 0; i < moduleDeclaration.opensCount; ++i) {
+			tSet.add(getPackageVisibilityStatement(moduleDeclaration.opens[i], new OpensStatement(this.ast)));
+		}
+		for (int i = 0; i < moduleDeclaration.requiresCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.RequiresStatement req = moduleDeclaration.requires[i];
+			ModuleReference moduleRef = req.module;
+			RequiresStatement stmt = new RequiresStatement(this.ast);
+			Name name = getUpdatedName(moduleRef.moduleName, moduleRef.sourceStart, moduleRef.sourceEnd);
+			stmt.setName(name);
+
+			addModifierToRequires(req, req.isTransitive(), Modifier.ModifierKeyword.TRANSIENT_KEYWORD, stmt);
+			addModifierToRequires(req, req.isStatic(), Modifier.ModifierKeyword.STATIC_KEYWORD, stmt);
+			stmt.setSourceRange(req.declarationSourceStart, req.declarationEnd - req.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		for (int i = 0; i < moduleDeclaration.usesCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.UsesStatement usesStatement = moduleDeclaration.uses[i];
+			UsesStatement stmt = new UsesStatement(this.ast);
+			TypeReference usesRef = usesStatement.serviceInterface;
+			stmt.setType(convertType(usesRef));
+			stmt.setSourceRange(usesStatement.declarationSourceStart, usesStatement.declarationSourceEnd - usesStatement.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		for (int i = 0; i < moduleDeclaration.servicesCount; ++i) {
+			org.eclipse.jdt.internal.compiler.ast.ProvidesStatement pStmt = moduleDeclaration.services[i];
+			ProvidesStatement stmt = new ProvidesStatement(this.ast);
+			stmt.setType(convertType(pStmt.serviceInterface));
+			TypeReference[] impls = pStmt.implementations;
+			for (TypeReference impl : impls) {
+				stmt.implementations().add(convertType(impl));
+			}
+			stmt.setSourceRange(pStmt.declarationSourceStart, pStmt.declarationEnd - pStmt.declarationSourceStart + 1);			
+			tSet.add(stmt);
+		}
+		// The javadoc comment is now got from 	list store in compilation unit declaration
+		if (this.resolveBindings) {
+			recordNodes(moduleDecl, moduleDeclaration);
+			recordNodes(moduleName, moduleDeclaration);
+			// moduleDecl.resolveBinding(); TODO: Implement resolveBinding
+		}
+		stmts.addAll(tSet);
+		return moduleDecl;
+	}
+
+	private void addModifierToRequires(org.eclipse.jdt.internal.compiler.ast.RequiresStatement req, boolean flag, Modifier.ModifierKeyword keyword,
+			RequiresStatement stmt) {
+		if (flag) {
+			Modifier modifier = createModifier(keyword);
+			modifier.setSourceRange(req.modifiersSourceStart, keyword.toString().length());
+			stmt.modifiers().add(modifier);
+		}
+	}
+
 	public ParenthesizedExpression convertToParenthesizedExpression(org.eclipse.jdt.internal.compiler.ast.Expression expression) {
 		final ParenthesizedExpression parenthesizedExpression = new ParenthesizedExpression(this.ast);
 		if (this.resolveBindings) {
@@ -4272,7 +4373,11 @@ class ASTConverter {
 		}
 		return false;
 	}
-
+	private Name getUpdatedName(char[] s, int sourceStart, int sourceEnd) {
+		Name name = this.ast.newName(new String(s));
+		name.setSourceRange(sourceStart, sourceEnd - sourceStart  + 1);
+		return name;
+	}
 	private void lookupForScopes() {
 		if (this.pendingNameScopeResolution != null) {
 			for (Iterator iterator = this.pendingNameScopeResolution.iterator(); iterator.hasNext(); ) {
@@ -5024,6 +5129,9 @@ class ASTConverter {
 	 * @param bodyDeclaration
 	 */
 	protected void setModifiers(BodyDeclaration bodyDeclaration, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
+		setModifiers(bodyDeclaration.modifiers(), annotations, modifiersEnd);
+	}
+	protected void setModifiers(List modifiers, org.eclipse.jdt.internal.compiler.ast.Annotation[] annotations, int modifiersEnd) {
 		this.scanner.tokenizeWhiteSpace = false;
 		try {
 			int token;
@@ -5084,7 +5192,7 @@ class ASTConverter {
 						break;
 				}
 				if (modifier != null) {
-					bodyDeclaration.modifiers().add(modifier);
+					modifiers.add(modifier);
 				}
 			}
 		} catch(InvalidInputException e) {
@@ -5164,6 +5272,10 @@ class ASTConverter {
 		}
 	}
 
+	protected void setModifiers(ModuleDeclaration moduleDecl, org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration) {
+		this.scanner.resetTo(typeDeclaration.declarationSourceStart, typeDeclaration.sourceStart);
+		this.setModifiers(moduleDecl.modifiers(), typeDeclaration.annotations, typeDeclaration.sourceStart);
+	}
 	/**
 	 * @param variableDecl
 	 * @param argument
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 070bb52..d0552d2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -615,7 +619,8 @@ public class ASTMatcher {
 		}
 		CompilationUnit o = (CompilationUnit) other;
 		return (
-			safeSubtreeMatch(node.getPackage(), o.getPackage())
+			safeSubtreeMatch(node.getModule(), o.getModule())
+				&& safeSubtreeMatch(node.getPackage(), o.getPackage())
 				&& safeSubtreeListMatch(node.imports(), o.imports())
 				&& safeSubtreeListMatch(node.types(), o.types()));
 	}
@@ -887,6 +892,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(ExportsStatement node, Object other) {
+		if (!(other instanceof ExportsStatement)) {
+			return false;
+		}
+		ExportsStatement o = (ExportsStatement) other;
+		return (
+			safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.modules(), o.modules()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(ExpressionMethodReference node, Object other) {
@@ -1553,6 +1583,32 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(ModuleDeclaration node, Object other) {
+		if (!(other instanceof ModuleDeclaration)) {
+			return false;
+		}
+		ModuleDeclaration o = (ModuleDeclaration) other;
+		return (safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
+				&& safeSubtreeListMatch(node.modifiers(), o.modifiers())
+				&& safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.moduleStatements(), o.moduleStatements()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 * @since 3.10
 	 */
 	public boolean match(NameQualifiedType node, Object other) {
@@ -1645,6 +1701,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(OpensStatement node, Object other) {
+		if (!(other instanceof OpensStatement)) {
+			return false;
+		}
+		OpensStatement o = (OpensStatement) other;
+		return (
+			safeSubtreeMatch(node.getName(), o.getName())
+				&& safeSubtreeListMatch(node.modules(), o.modules()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(PackageDeclaration node, Object other) {
 		if (!(other instanceof PackageDeclaration)) {
@@ -1793,6 +1874,32 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+
+	 */
+	public boolean match(ProvidesStatement node, Object other) {
+		if (!(other instanceof ProvidesStatement)) {
+			return false;
+		}
+		ProvidesStatement o = (ProvidesStatement) other;
+		return (
+				safeSubtreeMatch(node.getType(), o.getType())
+				&& safeSubtreeListMatch(node.implementations(), o.implementations()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(QualifiedName node, Object other) {
 		if (!(other instanceof QualifiedName)) {
@@ -1842,6 +1949,31 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 *
+	 *   @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(RequiresStatement node, Object other) {
+		if (!(other instanceof RequiresStatement)) {
+			return false;
+		}
+		RequiresStatement o = (RequiresStatement) other;
+		return safeSubtreeListMatch(node.modifiers(), o.modifiers())
+				&& safeSubtreeMatch(node.getName(), o.getName());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(ReturnStatement node, Object other) {
 		if (!(other instanceof ReturnStatement)) {
@@ -2465,6 +2597,29 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean match(UsesStatement node, Object other) {
+		if (!(other instanceof UnionType)) {
+			return false;
+		}
+		UsesStatement o = (UsesStatement) other;
+		return safeSubtreeMatch(node.getType(), o.getType());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(VariableDeclarationExpression node, Object other) {
 		if (!(other instanceof VariableDeclarationExpression)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index a665aed..b91d7ca 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -897,6 +901,53 @@ public abstract class ASTNode {
 	public static final int TYPE_METHOD_REFERENCE = 92;
 
 	/**
+	 * Node type constant indicating a node of type
+	 * <code>ModuleDeclaration</code>.
+	 * @see ModuleDeclaration
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int MODULE_DECLARATION = 93;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>ExportsStatement</code>.
+	 * @see ExportsStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int EXPORTS_STATEMENT = 94;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>RequiresStatement</code>.
+	 * @see RequiresStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int REQUIRES_STATEMENT = 95;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>UsesStatement</code>.
+	 * @see UsesStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int USES_STATEMENT = 96;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>ProvidesStatement</code>.
+	 * @see ProvidesStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int PROVIDES_STATEMENT = 97;
+
+	/**
+	 * Node type constant indicating a node of type
+	 * <code>OpensStatement</code>.
+	 * @see OpensStatement
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int OPENS_STATEMENT = 98;
+	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
@@ -964,6 +1015,8 @@ public abstract class ASTNode {
 				return EnumConstantDeclaration.class;
 			case ENUM_DECLARATION :
 				return EnumDeclaration.class;
+			case EXPORTS_STATEMENT :
+				return ExportsStatement.class;
 			case EXPRESSION_METHOD_REFERENCE :
 				return ExpressionMethodReference.class;
 			case EXPRESSION_STATEMENT :
@@ -1010,6 +1063,8 @@ public abstract class ASTNode {
 				return MethodRefParameter.class;
 			case MODIFIER :
 				return Modifier.class;
+			case MODULE_DECLARATION :
+				return ModuleDeclaration.class;
 			case NAME_QUALIFIED_TYPE :
 				return NameQualifiedType.class;
 			case NORMAL_ANNOTATION :
@@ -1018,6 +1073,8 @@ public abstract class ASTNode {
 				return NullLiteral.class;
 			case NUMBER_LITERAL :
 				return NumberLiteral.class;
+			case OPENS_STATEMENT :
+				return OpensStatement.class;
 			case PACKAGE_DECLARATION :
 				return PackageDeclaration.class;
 			case PARAMETERIZED_TYPE :
@@ -1030,10 +1087,14 @@ public abstract class ASTNode {
 				return PrefixExpression.class;
 			case PRIMITIVE_TYPE :
 				return PrimitiveType.class;
+			case PROVIDES_STATEMENT :
+				return ProvidesStatement.class;
 			case QUALIFIED_NAME :
 				return QualifiedName.class;
 			case QUALIFIED_TYPE :
 				return QualifiedType.class;
+			case REQUIRES_STATEMENT :
+				return RequiresStatement.class;
 			case RETURN_STATEMENT :
 				return ReturnStatement.class;
 			case SIMPLE_NAME :
@@ -1082,6 +1143,8 @@ public abstract class ASTNode {
 				return TypeParameter.class;
 			case UNION_TYPE :
 				return UnionType.class;
+			case USES_STATEMENT :
+				return UsesStatement.class;
 			case VARIABLE_DECLARATION_EXPRESSION :
 				return VariableDeclarationExpression.class;
 			case VARIABLE_DECLARATION_FRAGMENT :
@@ -1968,14 +2031,29 @@ public abstract class ASTNode {
 			throw new UnsupportedOperationException("Operation only supported in JLS8 and later AST"); //$NON-NLS-1$
 		}
 	}
-	
+
+	/**
+     * Checks that this AST operation is not used when
+     * building JLS2, JLS3, JLS4 or JLS8 level ASTs.
+     * <p>
+     * Use this method to prevent access to new properties that have been added in JLS9.
+     * </p>
+     *
+	 * @exception UnsupportedOperationException if this operation is used below JLS9
+	 * @since 3.13 BETA_JAVA9
+	 */
+	final void unsupportedBelow9() {
+		if (this.ast.apiLevel < AST.JLS9) {
+			throw new UnsupportedOperationException("Operation only supported in JLS9 and later AST"); //$NON-NLS-1$
+		}
+	}
 	/**
      * Checks that this AST operation is only used when
      * building JLS2 level ASTs.
      * <p>
      * Use this method to prevent access to deprecated properties (deprecated in JLS3).
      * </p>
-     * 
+     *
 	 * @exception UnsupportedOperationException if this operation is used in an AST later than JLS2
 	 * @since 3.0
      */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index d902b9b..2e04d57 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -655,6 +659,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ExportsStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1052,6 +1073,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ModuleDeclaration node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 * @since 3.10
 	 */
 	public boolean visit(NameQualifiedType node) {
@@ -1111,6 +1149,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(OpensStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1192,6 +1247,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(ProvidesStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1241,6 +1313,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(RequiresStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -1637,6 +1726,23 @@ public abstract class ASTVisitor {
 	 * Visits the given type-specific AST node.
 	 * <p>
 	 * The default implementation does nothing and return true.
+	 * Subclasses may re-implement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public boolean visit(UsesStatement node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
 	 * Subclasses may reimplement.
 	 * </p>
 	 *
@@ -2057,6 +2163,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ExportsStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(ExpressionMethodReference node) {
@@ -2348,6 +2467,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ModuleDeclaration node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(NameQualifiedType node) {
@@ -2398,6 +2530,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(OpensStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(PackageDeclaration node) {
 		// default implementation: do nothing
@@ -2471,6 +2616,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(ProvidesStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(QualifiedName node) {
 		// default implementation: do nothing
@@ -2496,6 +2654,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(RequiresStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(ReturnStatement node) {
 		// default implementation: do nothing
@@ -2791,6 +2962,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void endVisit(UsesStatement node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 * @since 3.10
 	 */
 	public void endVisit(IntersectionType node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index f3d1ddc..a3a7c2a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -28,6 +32,8 @@ import org.eclipse.text.edits.TextEdit;
 
 /**
  * Java compilation unit AST node type. This is the type of the root of an AST.
+ * From JLS 9 onwards, this can contain a ModuleDeclation. To be noted that not
+ * all nodes make sense in all contexts.
  * <p>
  * The source range for this type of node is ordinarily the entire source file,
  * including leading and trailing whitespace and comments.
@@ -36,7 +42,7 @@ import org.eclipse.text.edits.TextEdit;
  * CompilationUnit:
  *    [ PackageDeclaration ]
  *        { ImportDeclaration }
- *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | <b>;</b> }
+ *        { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ModuleDeclaration <b>;</b> }
  * </pre>
  *
  * @since 2.0
@@ -72,6 +78,14 @@ public class CompilationUnit extends ASTNode {
 		new ChildPropertyDescriptor(CompilationUnit.class, "package", PackageDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
+	 * The "module" structural property of this node type (child type: {@link ModuleDeclaration}).
+	 *
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final ChildPropertyDescriptor MODULE_PROPERTY =
+		new ChildPropertyDescriptor(CompilationUnit.class, "module", ModuleDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
 	 * A list of property descriptors (element type:
 	 * {@link StructuralPropertyDescriptor}),
 	 * or null if uninitialized.
@@ -80,6 +94,14 @@ public class CompilationUnit extends ASTNode {
 	private static final List PROPERTY_DESCRIPTORS;
 
 	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 * @since 3.13 BETA_JAVA9
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	/**
 	 * The "types" structural property of this node type (element type: {@link AbstractTypeDeclaration}).
 	 *
 	 * @since 3.0
@@ -94,6 +116,14 @@ public class CompilationUnit extends ASTNode {
 		addProperty(IMPORTS_PROPERTY, properyList);
 		addProperty(TYPES_PROPERTY, properyList);
 		PROPERTY_DESCRIPTORS = reapPropertyList(properyList);
+
+		properyList = new ArrayList(5);
+		createPropertyList(CompilationUnit.class, properyList);
+		addProperty(PACKAGE_PROPERTY, properyList);
+		addProperty(IMPORTS_PROPERTY, properyList);
+		addProperty(TYPES_PROPERTY, properyList);
+		addProperty(MODULE_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
 	}
 
 	/**
@@ -108,7 +138,10 @@ public class CompilationUnit extends ASTNode {
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
-		return PROPERTY_DESCRIPTORS;
+		if (apiLevel < AST.JLS9)
+			return PROPERTY_DESCRIPTORS;
+		else
+			return PROPERTY_DESCRIPTORS_9_0;
 	}
 
 	/**
@@ -168,10 +201,15 @@ public class CompilationUnit extends ASTNode {
 	private PackageDeclaration optionalPackageDeclaration = null;
 
 	/**
+	 * The module declaration, or <code>null</code> if none; initially
+	 * <code>null</code>.
+	 */
+	private ModuleDeclaration module = null;
+	/**
 	 * Problems reported by the compiler during parsing or name resolution.
 	 */
 	private IProblem[] problems = EMPTY_PROBLEMS;
-	
+
 	/**
 	 * Internal data used to perform statements recovery.
 	 */
@@ -207,6 +245,7 @@ public class CompilationUnit extends ASTNode {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
 			// visit children in normal left to right reading order
+			acceptChild(visitor, getModule());
 			acceptChild(visitor, getPackage());
 			acceptChildren(visitor, this.imports);
 			acceptChildren(visitor, this.types);
@@ -221,6 +260,7 @@ public class CompilationUnit extends ASTNode {
 		CompilationUnit result = new CompilationUnit(target);
 		// n.b do not copy line number table or messages
 		result.setSourceRange(getStartPosition(), getLength());
+		result.setModule((ModuleDeclaration) ASTNode.copySubtree(target, getModule()));
 		result.setPackage(
 			(PackageDeclaration) ASTNode.copySubtree(target, getPackage()));
 		result.imports().addAll(ASTNode.copySubtrees(target, imports()));
@@ -537,6 +577,17 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
+	 * Returns the node for the module declaration of this compilation
+	 * unit, or <code>null</code> if this compilation unit has a module
+	 *
+	 * @return the module declaration node, or <code>null</code> if none
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public ModuleDeclaration getModule() {
+		return this.module;
+	}
+
+	/**
 	 * Returns the node for the package declaration of this compilation
 	 * unit, or <code>null</code> if this compilation unit is in the
 	 * default package.
@@ -716,6 +767,14 @@ public class CompilationUnit extends ASTNode {
 	 * Method declared on ASTNode.
 	 */
 	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == MODULE_PROPERTY) {
+			if (get) {
+				return getModule();
+			} else {
+				setModule((ModuleDeclaration) child);
+				return null;
+			}
+		}
 		if (property == PACKAGE_PROPERTY) {
 			if (get) {
 				return getPackage();
@@ -1000,6 +1059,26 @@ public class CompilationUnit extends ASTNode {
 	}
 
 	/**
+	 * Sets or clears the module declaration of this compilation unit
+	 * node to the given module declaration node.
+	 *
+	 * @param module the new module declaration node, or
+	 *   <code>null</code> if this compilation unit does not have a module
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public void setModule(ModuleDeclaration module) {
+		ASTNode oldChild = this.module;
+		preReplaceChild(oldChild, module, PACKAGE_PROPERTY);
+		this.module = module;
+		postReplaceChild(oldChild, module, PACKAGE_PROPERTY);
+	}
+
+	/**
 	 * Sets or clears the package declaration of this compilation unit
 	 * node to the given package declaration node.
 	 *
@@ -1058,6 +1137,9 @@ public class CompilationUnit extends ASTNode {
 	 */
 	int treeSize() {
 		int size = memSize();
+		if (this.module != null) {
+			size += getModule().treeSize();
+		}
 		if (this.optionalPackageDeclaration != null) {
 			size += getPackage().treeSize();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
new file mode 100644
index 0000000..23dd1f1
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsStatement.java
@@ -0,0 +1,126 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Exports statement AST node type.
+ * <pre>
+ * ExportsStatement:
+ *     <b>exports</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class ExportsStatement extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+			internalNamePropertyFactory(ExportsStatement.class);
+
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(ExportsStatement.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ExportsStatement.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an export statement owned by the
+	 * given AST. The export statement initially is a regular (non-targetted)
+	 * single package export for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ExportsStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return EXPORTS_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new ExportsStatement(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
new file mode 100644
index 0000000..a079175
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
@@ -0,0 +1,329 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Module declaration AST node type representing the module descriptor file
+ *
+ * <pre>
+ * ModuleDeclaration:
+ *  [ Javadoc ] { ExtendedModifier } <b>module</b> Name <b>{</b>
+ *        [ ExportsStatement | RequiresStatement | UsesStatement | ProvidesStatement ]
+ *  <b>}</b>
+ * </pre>
+ * <p>
+ * </p>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings("rawtypes")
+public class ModuleDeclaration extends ASTNode {
+
+	/**
+	 * The "javadoc" structural property of this node type (child type: {@link Javadoc}).
+	 */
+	public static final ChildPropertyDescriptor JAVADOC_PROPERTY =
+			new ChildPropertyDescriptor(ModuleDeclaration.class, "javadoc", Javadoc.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
+	 */
+	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
+			new ChildListPropertyDescriptor(ModuleDeclaration.class, "modifiers", IExtendedModifier.class, CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "name" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(ModuleDeclaration.class, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "moduleStatements" structural property of this node type (element type: {@link ModuleStatement}).
+	 */
+	public static final ChildListPropertyDescriptor MODULE_STATEMENTS_PROPERTY =
+		new ChildListPropertyDescriptor(ModuleDeclaration.class, "moduleStatements", ModuleStatement.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(5);
+		createPropertyList(ModuleDeclaration.class, properyList);
+		addProperty(JAVADOC_PROPERTY, properyList);
+		addProperty(MODIFIERS_PROPERTY, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULE_STATEMENTS_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The doc comment, or <code>null</code> if none.
+	 * Defaults to none.
+	 */
+	private Javadoc optionalDocComment = null;
+
+	/**
+	 * The extended modifiers (element type: {@link IExtendedModifier}).
+	 * defaults to an empty list
+	 * (see constructor).
+	 *
+	 */
+	private ASTNode.NodeList modifiers = null;
+
+	/**
+	 * The referenced module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Name name = null;
+
+	/**
+	 * The list of statements (element type: {@link ModuleStatement}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList moduleStatements = new ASTNode.NodeList(MODULE_STATEMENTS_PROPERTY);
+
+	ModuleDeclaration(AST ast) {
+		super(ast);
+		unsupportedBelow9();
+		this.modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == JAVADOC_PROPERTY) {
+			if (get) {
+				return getJavadoc();
+			} else {
+				setJavadoc((Javadoc) child);
+				return null;
+			}
+		}
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == MODIFIERS_PROPERTY) {
+			return modifiers();
+		}
+		if (property == MODULE_STATEMENTS_PROPERTY) {
+			return moduleStatements();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	int getNodeType0() {
+		return MODULE_DECLARATION;
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	ASTNode clone0(AST target) {
+		ModuleDeclaration result = new ModuleDeclaration(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setJavadoc((Javadoc) ASTNode.copySubtree(target, getJavadoc()));
+		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+		result.setName((SimpleName) getName().clone(target));
+		result.moduleStatements().addAll(ASTNode.copySubtrees(target, moduleStatements()));
+		return result;
+	}
+
+	@Override
+	boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			// visit children in normal left to right reading order
+			acceptChild(visitor, getJavadoc());
+			acceptChildren(visitor, this.modifiers);
+			acceptChild(visitor, getName());
+			acceptChildren(visitor, this.moduleStatements);
+		}
+		visitor.endVisit(this);
+
+	}
+	/**
+	 * Returns the doc comment node.
+	 *
+	 * @return the doc comment node, or <code>null</code> if none
+	 */
+	public Javadoc getJavadoc() {
+		return this.optionalDocComment;
+	}
+
+	/**
+	 * Sets or clears the doc comment node.
+	 *
+	 * @param docComment the doc comment node, or <code>null</code> if none
+	 * @exception IllegalArgumentException if the doc comment string is invalid
+	 */
+	public void setJavadoc(Javadoc docComment) {
+		ChildPropertyDescriptor p = JAVADOC_PROPERTY;
+		ASTNode oldChild = this.optionalDocComment;
+		preReplaceChild(oldChild, docComment, p);
+		this.optionalDocComment = docComment;
+		postReplaceChild(oldChild, docComment, p);
+	}
+
+	/**
+	 * Returns the modifiers explicitly specified on this declaration.
+	 * <p>
+	 *  this method is a convenience method that
+	 * computes these flags from {@link #modifiers()}.
+	 * </p>
+	 *
+	 * @return the bit-wise "or" of <code>Modifier</code> constants
+	 * @see Modifier
+	 */
+	public int getModifiers() {
+		// convenience method -
+		// performance could be improved by caching computed flags
+		// but this would require tracking changes to this.modifiers
+		int computedmodifierFlags = Modifier.NONE;
+		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
+			Object x = it.next();
+			if (x instanceof Modifier) {
+				computedmodifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
+			}
+		}
+		return computedmodifierFlags;
+	}
+
+	/**
+	 * Returns the name of this module declaration.
+	 *
+	 * @return the module name
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the module name in to the given name.
+	 *
+	 * @param name the new module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of modifiers and annotations
+	 * of this declaration.
+	 *
+	 * @return the live list of modifiers and annotations
+	 *    (element type: {@link IExtendedModifier})
+	 */
+	public List modifiers() {
+		return this.modifiers;
+	}
+
+	/**
+	 * Returns the live list of statements in this module. Adding and
+	 * removing nodes from this list affects this node dynamically.
+	 * All nodes in this list must be <code>Statement</code>s;
+	 * attempts to add any other type of node will trigger an
+	 * exception.
+	 *
+	 * @return the live list of statements in this module declaration
+	 *    (element type: {@link ModuleStatement})
+	 */
+	public List moduleStatements() {
+		return this.moduleStatements;
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 4 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return	memSize()
+			+ (this.optionalDocComment == null ? 0 : getJavadoc().treeSize())
+			+ this.modifiers.listSize()
+			+ (this.name == null ? 0 : getName().treeSize())
+			+ this.moduleStatements.listSize();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
new file mode 100644
index 0000000..4dae45a
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModulePackageAccess.java
@@ -0,0 +1,207 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.List;
+
+/**
+ * Abstract base class of AST nodes that represent exports and opens statements.
+ *
+ * <pre>
+ * ModuleStatement: [ {@link ExportsStatement} |
+ *    {@link OpensStatement} ]
+ * </pre>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @since 3.13 BETA_JAVA9
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public abstract class ModulePackageAccess extends ModuleStatement {
+
+	/**
+	 * The package name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	protected Name name = null;
+
+	/**
+	 * The target modules
+	 * (element type: {@link Name}).
+	 * Defaults to an empty list. (see constructor)
+	 */
+	protected ASTNode.NodeList modules = null;
+
+	/**
+	 * Returns structural property descriptor for the "modules" property
+	 * of this node (element type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	abstract ChildListPropertyDescriptor internalModulesProperty();
+
+	/**
+	 * Returns structural property descriptor for the "name" property
+	 * of this node (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	abstract ChildPropertyDescriptor internalNameProperty();
+
+	/**
+	 * Returns structural property descriptor for the "name" property
+	 * of this node (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	public final ChildPropertyDescriptor getNameProperty() {
+		return internalNameProperty();
+	}
+
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "name" property declared on the given concrete node type (child type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildPropertyDescriptor internalNamePropertyFactory(Class nodeClass) {
+		return new ChildPropertyDescriptor(nodeClass, "name", Name.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+	}
+
+	/**
+	 * Creates and returns a structural property descriptor for the
+	 * "modules" property declared on the given concrete node type (element type: {@link Name}).
+	 *
+	 * @return the property descriptor
+	 */
+	static final ChildListPropertyDescriptor internalModulesPropertyFactory(Class nodeClass) {
+		return new ChildListPropertyDescriptor(nodeClass, "modules", Name.class, NO_CYCLE_RISK); //$NON-NLS-1$
+	}
+
+	/**
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ModulePackageAccess(AST ast) {
+		super(ast);
+		this.modules = new ASTNode.NodeList(internalModulesProperty());
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == internalNameProperty()) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == internalModulesProperty()) {
+			return modules();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	/**
+	 * Returns the name of the package
+	 *
+	 * @return the package name node
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					ChildPropertyDescriptor p = internalNameProperty();
+					postLazyInit(this.name, p);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the name of the package to the given name.
+	 *
+	 * @param name the new  package name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		ChildPropertyDescriptor p = internalNameProperty();
+		preReplaceChild(oldChild, name, p);
+		this.name = name;
+		postReplaceChild(oldChild, name, p);
+	}
+
+	/**
+	 * Returns the live ordered list of target modules for this
+	 * statement.
+	 *
+	 * @return the live list of target modules
+	 *    (element type: {@link Name})
+	 */
+	public List modules() {
+		return this.modules;
+	}
+
+	protected ASTNode cloneHelper(AST target, ModulePackageAccess result) {
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setName((Name) getName().clone(target));
+		result.modules().addAll(ASTNode.copySubtrees(target, modules()));
+		return result;
+	}
+
+	protected void acceptVisitChildren(boolean visitChildren, ASTVisitor visitor) {
+		if (visitChildren) {
+			acceptChild(visitor, getName());
+			acceptChildren(visitor, this.modules);
+		}
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.name == null ? 0 : getName().treeSize())
+			+ this.modules.listSize();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
new file mode 100644
index 0000000..97e2514
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleStatement.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+/**
+ * Abstract base class of AST nodes that represent module statements.
+ * There are many kinds of module statements.
+ *
+ * <pre>
+ * ModuleStatement: [ {@link ExportsStatement} |
+ *    {@link RequiresStatement} |
+ *    {@link UsesStatement} |
+ *    {@link ProvidesStatement} ]
+ * </pre>
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @since 3.13 BETA_JAVA9
+ */
+public abstract class ModuleStatement extends ASTNode {
+
+	ModuleStatement(AST ast) {
+		super(ast);
+		unsupportedBelow9();
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
new file mode 100644
index 0000000..ed137ac
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensStatement.java
@@ -0,0 +1,125 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * opens statement AST node type.
+ * <pre>
+ * OpensStatement:
+ *     <b>opens</b> PackageName [ <b>to</b>  ModuleName {<b>,</b> ModuleName } ] <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes"})
+public class OpensStatement extends ModulePackageAccess {
+
+	/**
+	 * The "package" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		internalNamePropertyFactory(OpensStatement.class);
+	/**
+	 * The "target" structural property of this node type (element type: {@link Name}).
+	 */
+	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
+			internalModulesPropertyFactory(OpensStatement.class);
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(OpensStatement.class, properyList);
+		addProperty(NAME_PROPERTY, properyList);
+		addProperty(MODULES_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * Creates a new AST node for an opens statement owned by the
+	 * given AST. The open statement initially is a regular (non-targetted)
+	 * single package open for an unspecified, but legal, Java package name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	OpensStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ChildPropertyDescriptor internalNameProperty() {
+		return NAME_PROPERTY;
+	}
+
+	@Override
+	final ChildListPropertyDescriptor internalModulesProperty() {
+		return MODULES_PROPERTY;
+	}
+
+	@Override
+	final int getNodeType0() {
+		return OPENS_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		return cloneHelper(target, new OpensStatement(target));
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		acceptVisitChildren(visitChildren, visitor);
+		visitor.endVisit(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
new file mode 100644
index 0000000..2c7da2b
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ProvidesStatement.java
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides statement AST node type.
+ * <pre>
+ * ProvidesStatement:
+ *     <b>provides</b> Name <b>with</b> Name {<b>,</b> Name } <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class ProvidesStatement extends ModuleStatement {
+
+	/**
+	 * The "interface type" structural property of this node type (child type: {@link Type}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(ProvidesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The "implementation type" structural property of this node type (element type: {@link Type}).
+	 */
+	public static final ChildListPropertyDescriptor IMPLEMENTATIONS_PROPERTY =
+			new ChildListPropertyDescriptor(ProvidesStatement.class, "implementationType", Type.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(3);
+		createPropertyList(ProvidesStatement.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		addProperty(IMPLEMENTATIONS_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The interface name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * The implementation names
+	 * (element type: {@link Name}).
+	 * Defaults to an empty list.
+	 */
+	private ASTNode.NodeList implementations =
+		new ASTNode.NodeList(IMPLEMENTATIONS_PROPERTY);
+
+	/**
+	 * Creates a new AST node for an provides statement owned by the
+	 * given AST. The provides statement initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	ProvidesStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == IMPLEMENTATIONS_PROPERTY) {
+			return implementations();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return PROVIDES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		ProvidesStatement result = new ProvidesStatement(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		result.implementations().addAll(ASTNode.copySubtrees(target, implementations()));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+			acceptChildren(visitor, this.implementations);
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type name in this statement
+	 *
+	 * @return the type name
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type =this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the target module name in exports declaration to the given name.
+	 *
+	 * @param type the new target module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	/**
+	 * Returns the live ordered list of implementations for the interface in this provides statement.
+	 *
+	 * @return the live list of implementations for the interface
+	 *    (element type: {@link Name})
+	 */
+	public List implementations() {
+		return this.implementations;
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize())
+			+ this.implementations.listSize();
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
new file mode 100644
index 0000000..abebef4
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RequiresStatement.java
@@ -0,0 +1,251 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Requires statement AST node type.
+ * <pre>
+ * RequiresStatement:
+ *     <b>requires</b> { ExtendedModifier } Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings({"rawtypes", "unchecked"})
+public class RequiresStatement extends ModuleStatement {
+
+	/**
+	 * The "modifiers" structural property of this node type (element type: {@link IExtendedModifier}).
+	 */
+	public static final ChildListPropertyDescriptor MODIFIERS_PROPERTY =
+		new ChildListPropertyDescriptor(RequiresStatement.class, "modifiers", IExtendedModifier.class, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * The module structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor NAME_PROPERTY =
+		new ChildPropertyDescriptor(RequiresStatement.class, "name", Name.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List propertyList = new ArrayList(3);
+		createPropertyList(RequiresStatement.class, propertyList);
+		addProperty(MODIFIERS_PROPERTY, propertyList);
+		addProperty(NAME_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The extended modifiers (element type: {@link IExtendedModifier}).
+	 * defaults to an empty list
+	 */
+	private ASTNode.NodeList modifiers = new ASTNode.NodeList(MODIFIERS_PROPERTY);
+
+	/**
+	 * The referenced module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Name name = null;
+
+	/**
+	 * Creates a new AST node for an requires statement owned by the
+	 * given AST. The requires statement initially is a regular (no modifiers)
+	 * requires for an unspecified, but legal, Java module name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	RequiresStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == NAME_PROPERTY) {
+			if (get) {
+				return getName();
+			} else {
+				setName((Name) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == MODIFIERS_PROPERTY) {
+			return modifiers();
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return REQUIRES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		RequiresStatement result = new RequiresStatement(target);
+		result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+		result.setName((Name) getName().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChildren(visitor, this.modifiers);
+			acceptChild(visitor, getName());
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * Returns the live ordered list of modifiers
+	 * of this declaration.
+	 * <p>
+	 * Note that the not all modifiers are legal.
+	 * </p>
+	 *
+	 * @return the live list of modifiers
+	 *    (element type: {@link IExtendedModifier})
+	 */
+	public List modifiers() {
+		return this.modifiers;
+	}
+
+	/**
+	 * Returns the modifiers explicitly specified on this declaration.
+	 * <p>
+	 * this method is a convenience method that
+	 * computes these flags from <code>modifiers()</code>.
+	 * </p>
+	 *
+	 * @return the bit-wise or of <code>Modifier</code> constants
+	 * @see Modifier
+	 */
+	public int getModifiers() {
+		// do not cache - performance could be improved by caching computed flags
+		// but this would require tracking changes to this.modifiers
+		int computedModifierFlags = Modifier.NONE;
+		for (Iterator it = modifiers().iterator(); it.hasNext(); ) {
+			Object x = it.next();
+			if (x instanceof Modifier) {
+				computedModifierFlags |= ((Modifier) x).getKeyword().toFlagValue();
+			}
+		}
+		return computedModifierFlags;
+	}
+
+	/**
+	 * Returns the module name referenced by this declaration.
+	 *
+	 * @return the module referenced
+	 */
+	public Name getName()  {
+		if (this.name == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.name == null) {
+					preLazyInit();
+					this.name =this.ast.newQualifiedName(
+							new SimpleName(this.ast), new SimpleName(this.ast));
+					postLazyInit(this.name, NAME_PROPERTY);
+				}
+			}
+		}
+		return this.name;
+	}
+
+	/**
+	 * Sets the module name in requires statement to the given name.
+	 *
+	 * @param name the new module name
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setName(Name name) {
+		if (name == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.name;
+		preReplaceChild(oldChild, name, NAME_PROPERTY);
+		this.name = name;
+		postReplaceChild(oldChild, name, NAME_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 2 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.modifiers == null ? 0 : this.modifiers.listSize())
+			+ (this.name == null ? 0 : getName().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
new file mode 100644
index 0000000..d94c3cb
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/UsesStatement.java
@@ -0,0 +1,188 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Uses statement AST node type.
+ * <pre>
+ * UsesStatement:
+ *     <b>uses</b> Name <b>;</b>
+ * </pre>
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+@SuppressWarnings("rawtypes")
+public class UsesStatement extends ModuleStatement {
+
+	/**
+	 * The "type" structural property of this node type (child type: {@link Name}).
+	 */
+	public static final ChildPropertyDescriptor TYPE_PROPERTY =
+		new ChildPropertyDescriptor(UsesStatement.class, "type", Type.class, MANDATORY, NO_CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_9_0;
+
+	static {
+		List properyList = new ArrayList(2);
+		createPropertyList(UsesStatement.class, properyList);
+		addProperty(TYPE_PROPERTY, properyList);
+		PROPERTY_DESCRIPTORS_9_0 = reapPropertyList(properyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_9_0;
+	}
+
+	/**
+	 * The module name; lazily initialized; defaults to a unspecified,
+	 * legal Java identifier.
+	 */
+	private Type type = null;
+
+	/**
+	 * Creates a new AST node for an uses statement owned by the
+	 * given AST. The uses statement initially is
+	 * for an unspecified, but legal, Java type name.
+	 * <p>
+	 * N.B. This constructor is package-private; all subclasses must be
+	 * declared in the same package; clients are unable to declare
+	 * additional subclasses.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	UsesStatement(AST ast) {
+		super(ast);
+	}
+
+	@Override
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	@Override
+	final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property, boolean get, ASTNode child) {
+		if (property == TYPE_PROPERTY) {
+			if (get) {
+				return getType();
+			} else {
+				setType((Type) child);
+				return null;
+			}
+		}
+
+		// allow default implementation to flag the error
+		return super.internalGetSetChildProperty(property, get, child);
+	}
+
+	@Override
+	final int getNodeType0() {
+		return USES_STATEMENT;
+	}
+
+	@Override
+	ASTNode clone0(AST target) {
+		UsesStatement result = new UsesStatement(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.setType((Type) getType().clone(target));
+		return result;
+	}
+
+	@Override
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	@Override
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			acceptChild(visitor, getType());
+		}
+		visitor.endVisit(this);
+	}
+
+
+	/**
+	 * Returns the type in this statement
+	 *
+	 * @return the type
+	 */
+	public Type getType()  {
+		if (this.type == null) {
+			// lazy init must be thread-safe for readers
+			synchronized (this) {
+				if (this.type == null) {
+					preLazyInit();
+					this.type = this.ast.newPrimitiveType(PrimitiveType.INT);
+					postLazyInit(this.type, TYPE_PROPERTY);
+				}
+			}
+		}
+		return this.type;
+	}
+
+	/**
+	 * Sets the type in uses statement
+	 *
+	 * @param type the new type in uses
+	 * @exception IllegalArgumentException if:
+	 * <ul>
+	 * <li>the node belongs to a different AST</li>
+	 * <li>the node already has a parent</li>
+	 * </ul>
+	 */
+	public void setType(Type type) {
+		if (type == null) {
+			throw new IllegalArgumentException();
+		}
+		ASTNode oldChild = this.type;
+		preReplaceChild(oldChild, type, TYPE_PROPERTY);
+		this.type = type;
+		postReplaceChild(oldChild, type, TYPE_PROPERTY);
+	}
+
+	@Override
+	int memSize() {
+		return BASE_NODE_SIZE + 1 * 4;
+	}
+
+	@Override
+	int treeSize() {
+		return
+			memSize()
+			+ (this.type == null ? 0 : getType().treeSize());
+	}
+
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 1d816cb..88aa9e3 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -207,11 +207,24 @@ public class NaiveASTFlattener extends ASTVisitor {
 		}
 	}
 
+	private void printTypes(List<Type> types, String prefix) {
+		if (types.size() > 0) {
+			this.buffer.append(" " + prefix + " ");//$NON-NLS-1$ //$NON-NLS-2$
+			Type type = types.get(0);
+			type.accept(this);
+			for (int i = 1, l = types.size(); i < l; ++i) {
+				this.buffer.append(","); //$NON-NLS-1$
+				type = types.get(0);
+				type.accept(this);
+			}
+		}
+	}
+
 	/**
 	 * reference node helper function that is common to all
 	 * the difference reference nodes.
-	 * 
-	 * @param typeArguments list of type arguments 
+	 *
+	 * @param typeArguments list of type arguments
 	 */
 	private void visitReferenceTypeArguments(List typeArguments) {
 		this.buffer.append("::");//$NON-NLS-1$
@@ -744,9 +757,14 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ExportsStatement node) {
+		return visit(node, "exports"); //$NON-NLS-1$
+	}
+
 	/*
 	 * @see ASTVisitor#visit(ExpressionMethodReference)
-	 * 
+	 *
 	 * @since 3.10
 	 */
 	public boolean visit(ExpressionMethodReference node) {
@@ -1207,6 +1225,32 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ModuleDeclaration node) {
+		printModifiers(node.modifiers());
+		this.buffer.append("module"); //$NON-NLS-1$
+		this.buffer.append(" "); //$NON-NLS-1$
+		node.getName().accept(this);
+		this.buffer.append(" {\n"); //$NON-NLS-1$
+		this.indent++;
+		for (ModuleStatement stmt : (List<ModuleStatement>)node.moduleStatements()) {
+			stmt.accept(this);
+		}
+		this.indent--;
+		this.buffer.append("}"); //$NON-NLS-1$
+		return false;
+	}
+
+	private boolean visit(ModulePackageAccess node, String keyword) {
+		printIndent();
+		this.buffer.append(keyword);
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getName().accept(this);
+		printTypes(node.modules(), "to"); //$NON-NLS-1$
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(NameQualifiedType)
 	 * @since 3.10
@@ -1254,6 +1298,11 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(OpensStatement node) {
+		return visit(node, "opens"); //$NON-NLS-1$
+	}
+
 	/*
 	 * @see ASTVisitor#visit(PackageDeclaration)
 	 */
@@ -1330,6 +1379,17 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(ProvidesStatement node) {
+		printIndent();
+		this.buffer.append("provides");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getType().accept(this);
+		printTypes(node.implementations(), "with"); //$NON-NLS-1$
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(QualifiedName)
 	 */
@@ -1352,6 +1412,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(RequiresStatement node) {
+		printIndent();
+		this.buffer.append("requires");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getName().accept(this);
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(ReturnStatement)
 	 */
@@ -1851,6 +1921,16 @@ public class NaiveASTFlattener extends ASTVisitor {
 		return false;
 	}
 
+	@Override
+	public boolean visit(UsesStatement node) {
+		printIndent();
+		this.buffer.append("uses");//$NON-NLS-1$
+		this.buffer.append(" ");//$NON-NLS-1$
+		node.getType().accept(this);
+		this.buffer.append(";\n");//$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
commit 6fc0c47689dec84064c5b42d9db82174e5902a9a
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Thu Dec 22 15:35:43 2016 +0530

    cleanup for bug 496123 [9] DOM AST for ModuleDeclaration in
    module-info.java
    
    Change-Id: I0ce0547313000b3399616509a22fd22958570ac0

13	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/dom/StandAloneASTParserTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
7	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
8	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeAnnotationsConverterTest.java
7	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
1	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
5	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
8	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ImportRewriteTest.java
7	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
10	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
1	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/dom/StandAloneASTParserTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/dom/StandAloneASTParserTest.java
index 30b9c3f..b074c59 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/dom/StandAloneASTParserTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/dom/StandAloneASTParserTest.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -53,7 +57,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 		super(name);
 	}
 	
-	private static final int JLS_LATEST = AST.JLS9;
+	private static final int AST_JLS_LATEST = AST.JLS9;
 
 	public ASTNode runConversion(
 			int astLevel,
@@ -83,7 +87,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 				"		System.out.println(length);\n" + 
 				"	}\n" + 
 				"}";
-		ASTNode node = runConversion(JLS_LATEST, contents, true, true, true, "p/X.java");
+		ASTNode node = runConversion(AST_JLS_LATEST, contents, true, true, true, "p/X.java");
 		assertTrue("Should be a compilation unit", node instanceof CompilationUnit);
 		CompilationUnit unit = (CompilationUnit) node;
 		List types = unit.types();
@@ -116,7 +120,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 	}
 
 	public void test2() {
-		ASTParser parser = ASTParser.newParser(JLS_LATEST);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		parser.setEnvironment(null, null, null, true);
 		parser.setResolveBindings(true);
 		parser.setStatementsRecovery(true);
@@ -145,7 +149,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 
 	public void test3() throws IOException {
 		File rootDir = new File(System.getProperty("java.io.tmpdir"));
-		ASTParser parser = ASTParser.newParser(JLS_LATEST);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		parser.setEnvironment(null, null, null, true);
 		parser.setResolveBindings(true);
 		parser.setStatementsRecovery(true);
@@ -235,7 +239,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 	}
 
 	public void test4() {
-		ASTParser parser = ASTParser.newParser(JLS_LATEST);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		try {
 			parser.setEnvironment(null, null, new String[] {"UTF-8"}, true);
 			assertTrue("Should have failed", false);
@@ -245,7 +249,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 	}
 
 	public void test5() {
-		ASTParser parser = ASTParser.newParser(JLS_LATEST);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		try {
 			parser.setEnvironment(null, new String[] {}, new String[] {"UTF-8"}, true);
 			assertTrue("Should have failed", false);
@@ -256,7 +260,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 
 	public void test6() throws IOException {
 		File rootDir = new File(System.getProperty("java.io.tmpdir"));
-		ASTParser parser = ASTParser.newParser(JLS_LATEST);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		parser.setEnvironment(null, null, null, true);
 		parser.setResolveBindings(true);
 		parser.setStatementsRecovery(true);
@@ -579,7 +583,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 		}
 
 		try {
-			ASTParser parser = ASTParser.newParser(JLS_LATEST);
+			ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 			parser.setKind(ASTParser.K_COMPILATION_UNIT);
 			parser.setCompilerOptions(JavaCore.getOptions());
 			parser.createASTs(
@@ -602,7 +606,7 @@ public class StandAloneASTParserTest extends AbstractRegressionTest {
 				"}\n";
 		Map<String, String> options = JavaCore.getOptions();
 		JavaCore.setComplianceOptions(JavaCore.VERSION_1_7, options);
-		ASTParser parser = ASTParser.newParser(AST.JLS9);
+		ASTParser parser = ASTParser.newParser(AST_JLS_LATEST);
 		parser.setCompilerOptions(options);
 		parser.setKind(ASTParser.K_COMPILATION_UNIT);
 		parser.setSource(source.toCharArray());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index c3dde4f..9d727d4 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -30,7 +30,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 
 	public void setUpSuite() throws Exception {
 		super.setUpSuite();
-		this.ast = AST.newAST(AST.JLS9);
+		this.ast = AST.newAST(AST_INTERNAL_JLS9);
 	}
 
 	public ASTConverter9Test(String name) {
@@ -143,7 +143,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 		this.workingCopies[0] = getWorkingCopy(
 				"/Converter9/src/module-info.java", content);
 		
-		CompilationUnit unit = (CompilationUnit) runConversion(AST.JLS9, this.workingCopies[0], false/*no bindings*/);
+		CompilationUnit unit = (CompilationUnit) runConversion(AST_INTERNAL_JLS9, this.workingCopies[0], false/*no bindings*/);
 		ModuleDeclaration moduleDecl = unit.getModule();
 		
 		checkSourceRange(moduleDecl, content, content);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index 5c481ef..e8d7a0d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -41,7 +41,12 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 	 * @deprecated
 	 */
 	/*package*/ static final int JLS3_INTERNAL = AST.JLS3;
-	
+	/**
+	 * Internal synonym for constant AST.JSL9
+	 * to alleviate deprecation warnings once AST.JLS9 is deprecated in future.
+	 */
+	protected static final int AST_INTERNAL_JLS9 = AST.JLS9;
+
 	class CheckPositionsMatcher extends ASTMatcher {
 
 		public CheckPositionsMatcher() {
@@ -8872,7 +8877,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			try {
 				node = this.ast.createInstance(nodeType);
 			} catch (IllegalArgumentException e) {
-				if (this.API_LEVEL < AST.JLS9 && e.getCause() instanceof UnsupportedOperationException) {
+				if (this.API_LEVEL < AST_INTERNAL_JLS9 && e.getCause() instanceof UnsupportedOperationException) {
 					continue;
 				} else {
 					throw new AssertionFailedError("missing node type: " + nodeType);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
index 564c977..2ffcae1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/AbstractASTTests.java
@@ -79,6 +79,12 @@ public class AbstractASTTests extends ModifyingResourceTests implements DefaultM
 	 * @deprecated
 	 */
 	/*package*/ static final int AST_INTERNAL_JLS4 = AST.JLS4;
+	/**
+	 * Internal synonym for deprecated constant AST.JSL8
+	 * to alleviate deprecation warnings.
+	 * @deprecated
+	 */
+	/*package*/ static final int AST_INTERNAL_JLS8 = AST.JLS8;
 	public static final int astInternalJLS2() {
 		return AST_INTERNAL_JLS2;
 	}
@@ -483,17 +489,14 @@ public class AbstractASTTests extends ModifyingResourceTests implements DefaultM
 			return new ASTNode[] {unit};
 		return nodes;
 	}
-	/**
-	 * @deprecated references deprecated old AST level
-	 */
 	protected ASTNode[] buildASTs(String newContents, ICompilationUnit cu, boolean reportErrors, boolean enableStatementRecovery, boolean bindingRecovery) throws JavaModelException {
 		String option = cu.getJavaProject().getOption(JavaCore.COMPILER_COMPLIANCE, true);
 		long jdkLevel = CompilerOptions.versionToJdkLevel(option);
 		int JLSLevel = AST_INTERNAL_JLS3;
 		if (jdkLevel >= ClassFileConstants.JDK9) {
-			JLSLevel = AST.JLS9;			
+			JLSLevel = AST_INTERNAL_JLS9;			
 		} else if (jdkLevel >= ClassFileConstants.JDK1_8) {
-			JLSLevel = AST.JLS8;
+			JLSLevel = AST_INTERNAL_JLS8;
 		} else if (jdkLevel >= ClassFileConstants.JDK1_7) {
 			JLSLevel = AST_INTERNAL_JLS4;
 		}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeAnnotationsConverterTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeAnnotationsConverterTest.java
index 35284aa..557217c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeAnnotationsConverterTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeAnnotationsConverterTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -23,7 +27,7 @@ public class TypeAnnotationsConverterTest extends ConverterTestSetup {
 
 	public void setUpSuite() throws Exception {
 		super.setUpSuite();
-		this.ast = AST.newAST(AST.JLS9);
+		this.ast = AST.newAST(AST_INTERNAL_JLS9);
 	}
 
 	public TypeAnnotationsConverterTest(String name) {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 0dd28ac..4a40d8e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -28,6 +28,7 @@ import org.eclipse.core.runtime.jobs.Job;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.search.*;
@@ -72,6 +73,12 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 	protected boolean displayName = false;
 	protected String endChar = ",";
 
+	/**
+	 * Internal synonym for constant AST.JSL9
+	 * to alleviate deprecation warnings once AST.JLS9 is deprecated in future.
+	 */
+	protected static final int AST_INTERNAL_JLS9 = AST.JLS9;
+
 	public static class BasicProblemRequestor implements IProblemRequestor {
 		public void acceptProblem(IProblem problem) {}
 		public void beginReporting() {}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
index 5776150..15454c7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompilationUnitTests.java
@@ -49,7 +49,6 @@ public CompilationUnitTests(String name) {
  * @deprecated
  */
 /*package*/ static final int JLS3_INTERNAL = AST.JLS3;
-/*package*/ static final int JLS9_INTERNAL = AST.JLS9;
 
 public void setUpSuite() throws Exception {
 	super.setUpSuite();
@@ -2597,7 +2596,7 @@ public void testBug495598_001() throws CoreException {
 				"public class X {}\n");
 		ICompilationUnit cuD = getCompilationUnit("/P/src/X.java");
 		
-		ASTParser parser = ASTParser.newParser(JLS9_INTERNAL);
+		ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 		parser.setProject(this.testProject);
 		parser.setSource(cuD);
 		parser.setResolveBindings(true);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
index 958e666..7892136 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaProjectTests.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - inconsistent initialization of classpath container backed by external class folder, see https://bugs.eclipse.org/320618
@@ -58,7 +62,6 @@ import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.WorkingCopyOwner;
-import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTNode;
 import org.eclipse.jdt.core.dom.ASTParser;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -2633,7 +2636,7 @@ public void testBug351697() throws Exception {
 		proj.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
 
 		try {
-			ASTParser parser= ASTParser.newParser(AST.JLS9);
+			ASTParser parser= ASTParser.newParser(AST_INTERNAL_JLS9);
 			parser.setSource(unit);
 			parser.setResolveBindings(true);
 			ASTNode node = parser.createAST(null);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
index 593ae48..2f839fc 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
  *******************************************************************************/
@@ -33,7 +37,6 @@ import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.IProblem;
-import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTParser;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.MarkerAnnotation;
@@ -288,7 +291,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 					"Buildpath problem: the type invalid, which is configured as a null annotation type, cannot be resolved\n" +
 					"----------\n");
 
-			ASTParser parser = ASTParser.newParser(AST.JLS9);
+			ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 			parser.setProject(p);
 			parser.setResolveBindings(true);
 			parser.setSource(unit);
@@ -351,7 +354,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			assertEquals("Should have no markers", 0, markers.length);
 
 			// Challenge CompilationUnitResolver:
-			ASTParser parser = ASTParser.newParser(AST.JLS9);
+			ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 			parser.setProject(p);
 			parser.setResolveBindings(true);
 			parser.setSource(unit);
@@ -422,7 +425,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			assertEquals("Unexpected marker path", "/P/p1/C1.java", markers[0].getResource().getFullPath().toString());
 
 			// Challenge CompilationUnitResolver:
-			ASTParser parser = ASTParser.newParser(AST.JLS9);
+			ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 			parser.setProject(p);
 			parser.setResolveBindings(true);
 			parser.setSource(unit);
@@ -475,7 +478,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			final ICompilationUnit unit = getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
 			assertNoProblem(c1SourceString.toCharArray(), unit);
 
-			ASTParser parser = ASTParser.newParser(AST.JLS9);
+			ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 			parser.setProject(p);
 			parser.setResolveBindings(true);
 			parser.setSource(unit);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
index 0ccf485..b08b3ab 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java
@@ -5055,7 +5055,7 @@ public class ASTRewritingStatementsTest extends ASTRewritingTest {
 	 * @deprecated
 	 */
 	protected ChildListPropertyDescriptor getResourcesProperty() {
-		return this.apiLevel < AST.JLS9 ? TryStatement.RESOURCES_PROPERTY : TryStatement.RESOURCES2_PROPERTY;
+		return this.apiLevel < AST_INTERNAL_JLS9 ? TryStatement.RESOURCES_PROPERTY : TryStatement.RESOURCES2_PROPERTY;
 	}
 
 	public void testTryStatementWithResources2_since_4() throws Exception {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ImportRewriteTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ImportRewriteTest.java
index 4e49950..8650f05 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ImportRewriteTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ImportRewriteTest.java
@@ -4929,7 +4929,7 @@ public class ImportRewriteTest extends AbstractJavaModelTests {
 				"}\n";
 		ICompilationUnit cu = pack1.createCompilationUnit("X.java", contents, false, null);
 
-		ASTParser parser = ASTParser.newParser(AST.JLS9);
+		ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 		parser.setSource(cu);
 		parser.setResolveBindings(true);
 		parser.setStatementsRecovery(true);
@@ -4954,7 +4954,7 @@ public class ImportRewriteTest extends AbstractJavaModelTests {
 				"}\n";
 		ICompilationUnit cu = pack1.createCompilationUnit("X.java", contents, false, null);
 
-		ASTParser parser = ASTParser.newParser(AST.JLS9);
+		ASTParser parser = ASTParser.newParser(AST_INTERNAL_JLS9);
 		parser.setSource(cu);
 		parser.setResolveBindings(true);
 		parser.setStatementsRecovery(true);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index f1c9a93..a90205e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -216,6 +216,13 @@ public final class AST {
 	 */
 	public static final int JLS9 = 9;
 
+	/**
+	 * Internal synonym for {@link #JLS9}. Use to alleviate
+	 * deprecation warnings once JLS9 is deprecated
+	 * @since 3.13 BETA_JAVA9
+	 */
+	/*package*/ static final int JLS9_INTERNAL = JLS9;
+
 	/*
 	 * Must not collide with a value for ICompilationUnit constants
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index 1f21c4f..837582d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -2957,7 +2957,7 @@ class ASTConverter {
 					return convertToAnnotationDeclaration(typeDeclaration);
 				}
 			case org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.MODULE_DECL :
-				if (this.ast.apiLevel < AST.JLS9) {
+				if (this.ast.apiLevel < AST.JLS9_INTERNAL) {
 					return null;
 				} else {
 					return convertToModuleDeclaration(typeDeclaration);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index d0552d2..6eaac1d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -619,7 +619,7 @@ public class ASTMatcher {
 		}
 		CompilationUnit o = (CompilationUnit) other;
 		return (
-			safeSubtreeMatch(node.getModule(), o.getModule())
+			(node.getAST().apiLevel >= AST.JLS9_INTERNAL ? safeSubtreeMatch(node.getModule(), o.getModule()) : true)
 				&& safeSubtreeMatch(node.getPackage(), o.getPackage())
 				&& safeSubtreeListMatch(node.imports(), o.imports())
 				&& safeSubtreeListMatch(node.types(), o.types()));
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index b91d7ca..d1afb65 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -2043,7 +2043,7 @@ public abstract class ASTNode {
 	 * @since 3.13 BETA_JAVA9
 	 */
 	final void unsupportedBelow9() {
-		if (this.ast.apiLevel < AST.JLS9) {
+		if (this.ast.apiLevel < AST.JLS9_INTERNAL) {
 			throw new UnsupportedOperationException("Operation only supported in JLS9 and later AST"); //$NON-NLS-1$
 		}
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
index 5bf7a0d..2de8224 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java
@@ -231,7 +231,7 @@ public class ASTParser {
 			case AST.JLS3_INTERNAL:
 			case AST.JLS4_INTERNAL:
 			case AST.JLS8_INTERNAL:
-			case AST.JLS9:
+			case AST.JLS9_INTERNAL:
 				break;
 			default:
 				throw new IllegalArgumentException();
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index a3a7c2a..69f3bcb 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -78,7 +78,7 @@ public class CompilationUnit extends ASTNode {
 		new ChildPropertyDescriptor(CompilationUnit.class, "package", PackageDeclaration.class, OPTIONAL, NO_CYCLE_RISK); //$NON-NLS-1$
 
 	/**
-	 * The "module" structural property of this node type (child type: {@link ModuleDeclaration}).
+	 * The "module" structural property of this node type (child type: {@link ModuleDeclaration}) (added in JLS9 API).
 	 *
 	 * @since 3.13 BETA_JAVA9
 	 */
@@ -138,7 +138,7 @@ public class CompilationUnit extends ASTNode {
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
-		if (apiLevel < AST.JLS9)
+		if (apiLevel < AST.JLS9_INTERNAL)
 			return PROPERTY_DESCRIPTORS;
 		else
 			return PROPERTY_DESCRIPTORS_9_0;
@@ -245,7 +245,9 @@ public class CompilationUnit extends ASTNode {
 		boolean visitChildren = visitor.visit(this);
 		if (visitChildren) {
 			// visit children in normal left to right reading order
-			acceptChild(visitor, getModule());
+			if (this.ast.apiLevel >= AST.JLS9_INTERNAL) {
+				acceptChild(visitor, getModule());
+			}
 			acceptChild(visitor, getPackage());
 			acceptChildren(visitor, this.imports);
 			acceptChildren(visitor, this.types);
@@ -260,7 +262,9 @@ public class CompilationUnit extends ASTNode {
 		CompilationUnit result = new CompilationUnit(target);
 		// n.b do not copy line number table or messages
 		result.setSourceRange(getStartPosition(), getLength());
-		result.setModule((ModuleDeclaration) ASTNode.copySubtree(target, getModule()));
+		if (this.ast.apiLevel >= AST.JLS9_INTERNAL) {
+			result.setModule((ModuleDeclaration) ASTNode.copySubtree(target, getModule()));
+		}
 		result.setPackage(
 			(PackageDeclaration) ASTNode.copySubtree(target, getPackage()));
 		result.imports().addAll(ASTNode.copySubtrees(target, imports()));
@@ -578,12 +582,13 @@ public class CompilationUnit extends ASTNode {
 
 	/**
 	 * Returns the node for the module declaration of this compilation
-	 * unit, or <code>null</code> if this compilation unit has a module
+	 * unit, or <code>null</code> if this compilation unit is not a module info.
 	 *
 	 * @return the module declaration node, or <code>null</code> if none
 	 * @since 3.13 BETA_JAVA9
 	 */
 	public ModuleDeclaration getModule() {
+		unsupportedBelow9();
 		return this.module;
 	}
 
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
index 00f990d..cf65b03 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TryStatement.java
@@ -189,7 +189,7 @@ public class TryStatement extends Statement {
 	 */
 	TryStatement(AST ast) {
 		super(ast);
-		if (ast.apiLevel >= AST.JLS9) {
+		if (ast.apiLevel >= AST.JLS9_INTERNAL) {
 			this.resources = new ASTNode.NodeList(RESOURCES2_PROPERTY);
 		} else if (ast.apiLevel >= AST.JLS4_INTERNAL) {
 			this.resources = new ASTNode.NodeList(RESOURCES_PROPERTY);
commit ebf389c546a7c64148f587d16534b486b1817000
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Jun 26 20:06:51 2017 +0200

    Bug 496123: [9] DOM AST for ModuleDeclaration in module-info.java

2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
index e97823b..ec27242 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ExportsDirective.java
@@ -32,13 +32,13 @@ import java.util.List;
 public class ExportsDirective extends ModulePackageAccess {
 
 	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
+	 * The "name" structural property of this node type (child type: {@link Name}).
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
 			internalNamePropertyFactory(ExportsDirective.class);
 
 	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
+	 * The "modules" structural property of this node type (element type: {@link Name}).
 	 */
 	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
 			internalModulesPropertyFactory(ExportsDirective.class);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
index e246d0c..e5994bc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/OpensDirective.java
@@ -32,12 +32,12 @@ import java.util.List;
 public class OpensDirective extends ModulePackageAccess {
 
 	/**
-	 * The "package" structural property of this node type (child type: {@link Name}).
+	 * The "name" structural property of this node type (child type: {@link Name}).
 	 */
 	public static final ChildPropertyDescriptor NAME_PROPERTY =
 		internalNamePropertyFactory(OpensDirective.class);
 	/**
-	 * The "target" structural property of this node type (element type: {@link Name}).
+	 * The "modules" structural property of this node type (element type: {@link Name}).
 	 */
 	public static final ChildListPropertyDescriptor MODULES_PROPERTY =
 			internalModulesPropertyFactory(OpensDirective.class);
commit ea16f411f282b2c37767bb1cec9df7aaae2594fe
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Tue Jun 27 20:07:58 2017 +0200

    Bug 496123: [9] DOM AST for ModuleDeclaration in module-info.java
    
    - missing UnsupportedOperationException < JLS9
    - missing update in NaiveASTFlattener

2	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
8	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
index 9fb0d77..c219a6b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnit.java
@@ -1082,9 +1082,11 @@ public class CompilationUnit extends ASTNode {
 	 * <li>the node belongs to a different AST</li>
 	 * <li>the node already has a parent</li>
 	 * </ul>
+	 * @exception UnsupportedOperationException if this operation is used below JLS9
 	 * @since 3.13 BETA_JAVA9
 	 */
 	public void setModule(ModuleDeclaration module) {
+		unsupportedBelow9();
 		ASTNode oldChild = this.module;
 		preReplaceChild(oldChild, module, MODULE_PROPERTY);
 		this.module = module;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index c3f0dbb..05dbccf 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -74,7 +74,9 @@ public class NaiveASTFlattener extends ASTVisitor {
 	 * @since 3.13 BETA_JAVA9
 	 */
 	private static final int JLS8 = AST.JLS8;
-	
+
+	private static final int JLS9 = AST.JLS9;
+
 	/**
 	 * The string buffer into which the serialized representation of the AST is
 	 * written.
@@ -559,6 +561,11 @@ public class NaiveASTFlattener extends ASTVisitor {
 	 * @see ASTVisitor#visit(CompilationUnit)
 	 */
 	public boolean visit(CompilationUnit node) {
+		if (node.getAST().apiLevel() >= JLS9) {
+			if (node.getModule() != null) {
+				node.getModule().accept(this);
+			}
+		}
 		if (node.getPackage() != null) {
 			node.getPackage().accept(this);
 		}
