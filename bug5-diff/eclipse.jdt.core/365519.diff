commit 45457c087850a9bcb1e2d528c971be662d0a4e96
Author: Stephan Herrmann <sherrmann>
Date:   Sat Jan 14 23:17:43 2012 +0100

    HEAD - Fixed Bug 365519 - editorial cleanup after bug 186342 and bug
    365387

64	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
24	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
8	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
4	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
7	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
14	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
10	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
index aa4d472..5e591cc 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
@@ -1,12 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     IBM Corporation - initial API and implementation
+ *		IBM Corporation - initial API and implementation
+ *		Stephan Herrmann - Contribution for Bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -15,6 +16,7 @@ import java.util.Map;
 
 import junit.framework.Test;
 
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.ToolFactory;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
@@ -6517,6 +6519,66 @@ public void test180() {
 		"",
 		null);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=289892
+// in interaction with null annotations
+// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=365519#c4 item (6) 
+public void test180a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+	this.runConformTest(
+		new String[] {
+			"p/package-info.java",
+			"@p.Annot(state=p.MyEnum.BROKEN)\n" + 
+			"package p;",
+			"p/Annot.java",
+			"package p;\n" + 
+			"@Annot(state=MyEnum.KO)\n" + 
+			"public @interface Annot {\n" + 
+			"	MyEnum state() default MyEnum.KO;\n" + 
+			"}",
+			"p/MyEnum.java",
+			"package p;\n" + 
+			"@Annot(state=MyEnum.KO)\n" + 
+			"public enum MyEnum {\n" + 
+			"	WORKS, OK, KO, BROKEN, ;\n" + 
+			"}",
+			"test180/package-info.java",
+			"@p.Annot(state=p.MyEnum.OK)\n" + 
+			"package test180;",
+			"test180/Test.java",
+			"package test180;\n" +
+			"import p.MyEnum;\n" + 
+			"import p.Annot;\n" + 
+			"@Annot(state=MyEnum.OK)\n" + 
+			"public class Test {}",
+		},
+		"",
+		null,
+		true,
+		null,
+		options,
+		null
+	);
+	options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_Process_Annotations, CompilerOptions.ENABLED);
+	this.runConformTest(
+		false,
+		new String[] {
+			"X.java",
+			"import test180.Test;\n" +
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		System.out.println(Test.class);\n" + 
+			"	}\n" + 
+			"}"
+		},
+		null,
+		options,
+		"",
+		"class test180.Test",
+		"",
+		null);
+}
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=300133
 public void test181() {
 	this.runConformTest(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 0a8af6b..2e13dc6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -704,6 +704,30 @@ public void test_nonnull_argument_002() {
 			"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 			"----------\n");
 }
+// a method of a local class has a non-null parameter, client passes potential null (msg send)
+public void test_nonnull_parameter_014() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"B.java",
+			"class B {\n" +
+			"    void bar () {\n" +
+			"        class Local {\n" +
+			"            void callMe(@org.eclipse.jdt.annotation.NonNull Object o){\n" +
+			"            }\n" +
+			"        }\n" +
+			"        Local l = new Local();\n" +
+			"        l.callMe(getNull());\n" +
+			"    }\n" +
+			"    @org.eclipse.jdt.annotation.Nullable Object getNull() { return null; }" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in B.java (at line 8)\n" + 
+		"	l.callMe(getNull());\n" + 
+		"	         ^^^^^^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" + 
+		"----------\n");
+}
 // assigning potential null to a nonnull local variable
 public void test_nonnull_local_001() {
 	runNegativeTest(
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 717243b..70d29fb 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.8.0 - %date% - 3.8.0 M5
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=368435">368435</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=365519">365519</a>
+editorial cleanup after bug 186342 and bug 365387
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=368435">368435</a>
 [compiler] NPE while compile a method with unused local
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=361963">361963</a>
 Stack overflow when trying to code complete a generic list
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 4cedddc..5aae1c7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *     							bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -258,8 +259,6 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 
 	// for annotation reference, signal if annotation was created from a default:
 	public static final int IsSynthetic = ASTNode.Bit7;
-	// for name reference within a memberValuePair of an annotation:
-	public static final int IsMemberValueReference = ASTNode.Bit15;
 
 	public ASTNode() {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 7a7a506..a996cff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 367203 - [compiler][null] detect assigning null to nonnull argument
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -74,15 +75,15 @@ public abstract class AbstractMethodDeclaration
 	}
 
 	/**
-	 * Materialize a null annotation that has been added from the current default,
+	 * Materialize a non-null annotation that has been added from the current default,
 	 * in order to ensure that this annotation will be generated into the .class file, too.
 	 */
-	public void addNullnessAnnotation(ReferenceBinding annotationBinding) {
+	public void addNonNullAnnotation(ReferenceBinding annotationBinding) {
 		this.annotations = addAnnotation(this, this.annotations, annotationBinding);
 	}
 
 	/**
-	 * Materialize a null parameter annotation that has been added from the current default,
+	 * Materialize a non-null parameter annotation that has been added from the current default,
 	 * in order to ensure that this annotation will be generated into the .class file, too.
 	 */
 	public void addParameterNonNullAnnotation(Argument argument, ReferenceBinding annotationBinding) {
@@ -497,7 +498,7 @@ public abstract class AbstractMethodDeclaration
 			bindThrownExceptions();
 			resolveJavadoc();
 			resolveAnnotations(this.scope, this.annotations, this.binding);
-			validateAnnotations();
+			validateNullAnnotations();
 			resolveStatements();
 			// check @Deprecated annotation presence
 			if (this.binding != null
@@ -562,10 +563,11 @@ public abstract class AbstractMethodDeclaration
 	    return null;
 	}
 
-	void validateAnnotations() {
+	void validateNullAnnotations() {
 		// null annotations on parameters?
 		if (this.binding != null && this.binding.parameterNonNullness != null) {
-			for (int i=0; i<this.binding.parameters.length; i++) {
+			int length = this.binding.parameters.length;
+			for (int i=0; i<length; i++) {
 				if (this.binding.parameterNonNullness[i] != null) {
 					long nullAnnotationTagBit =  this.binding.parameterNonNullness[i].booleanValue()
 							? TagBits.AnnotationNonNull : TagBits.AnnotationNullable;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index 8b5f9e1..9c4eb4b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -34,7 +36,7 @@ public class Argument extends LocalDeclaration {
 	public void createBinding(MethodScope scope, TypeBinding typeBinding) {
 		if (this.binding == null) {
 			// for default constructors and fake implementation of abstract methods 
-			this.binding = new LocalVariableBinding(this, typeBinding, this.modifiers, true);
+			this.binding = new LocalVariableBinding(this, typeBinding, this.modifiers, true /*isArgument*/);
 		} else if (!this.binding.type.isValidBinding()) {
 			AbstractMethodDeclaration methodDecl = scope.referenceMethod();
 			if (methodDecl != null) {
@@ -72,7 +74,6 @@ public class Argument extends LocalDeclaration {
 			}
 		}
 		scope.addLocalVariable(this.binding);
-		//true stand for argument instead of just local
 		this.binding.useFlag = used ? LocalVariableBinding.USED : LocalVariableBinding.UNUSED;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index e521d40..9763111 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -26,7 +26,7 @@ public class EqualExpression extends BinaryExpression {
 	private void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {
 		int rightStatus = this.right.nullStatus(flowInfo);
 		int leftStatus = this.left.nullStatus(flowInfo);
-		// check if either method is annotated @NonNull and compared to null:
+		// check if either is a method annotated @NonNull and compared to null:
 		if (leftStatus == FlowInfo.NON_NULL && rightStatus == FlowInfo.NULL) {
 			if (this.left instanceof MessageSend) { 
 				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index dac029c..a8788f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -187,7 +187,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if ((this.modifiers & ClassFileConstants.AccFinal)!= 0 && this.initialization == null) {
 			this.modifiers |= ExtraCompilerModifiers.AccBlankFinal;
 		}
-		this.binding = new LocalVariableBinding(this, variableType, this.modifiers, false);
+		this.binding = new LocalVariableBinding(this, variableType, this.modifiers, false /*isArgument*/);
 		scope.addLocalVariable(this.binding);
 		this.binding.setConstant(Constant.NotAConstant);
 		// allow to recursivelly target the binding....
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
index 0902e21..e0f7cfb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -42,9 +44,6 @@ public class MemberValuePair extends ASTNode {
 		if (value instanceof ArrayInitializer) {
 			value.bits |= IsAnnotationDefaultValue;
 		}
-		if (value instanceof NameReference) {
-			value.bits |= IsMemberValueReference;
-		}
 	}
 
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 6cbc638..f430f68 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -311,8 +312,8 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	    return this.typeParameters;
 	}
 	
-	void validateAnnotations() {
-		super.validateAnnotations();
+	void validateNullAnnotations() {
+		super.validateNullAnnotations();
 		// null-annotations on the return type?
 		if (this.binding != null)
 			this.scope.validateNullAnnotation(this.binding.tagBits, this.returnType, this.annotations);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 330cafd..a9f98e2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -965,7 +966,7 @@ public TypeBinding resolveType(BlockScope scope) {
 							&& methodScope.lastVisibleFieldID >= 0
 							&& fieldBinding.id >= methodScope.lastVisibleFieldID
 							&& (!fieldBinding.isStatic() || methodScope.isStatic)) {
-						if ((this.bits & IsMemberValueReference) != 0 && fieldBinding.id == methodScope.lastVisibleFieldID) {
+						if (methodScope.insideTypeAnnotation && fieldBinding.id == methodScope.lastVisibleFieldID) {
 							// false alarm, location is NOT a field initializer but the value in a memberValuePair
 						} else {
 							scope.problemReporter().forwardReference(this, this.indexOfFirstFieldBinding-1, fieldBinding);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 18a1bc1..6a446b0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -13,6 +13,7 @@
  *     							bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365835 - [compiler][null] inconsistent error reporting.
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -140,7 +141,9 @@ void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int n
 			methodBinding = scope.methodScope().referenceMethod().binding;
 			tagBits = methodBinding.tagBits;
 		} catch (NullPointerException npe) {
-			return;
+			// chain of references in try-block has several potential nulls;
+			// any null means we cannot perform the following check
+			return;			
 		}
 		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
 			flowContext.recordNullityMismatch(scope, this.expression, nullStatus, methodBinding.returnType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index d148222..12b5edc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -36,6 +38,7 @@ public class FinallyFlowContext extends FlowContext {
 	Expression[] nullReferences;
 	int[] nullCheckTypes;
 	int nullCount;
+	// see also the related field FlowContext#expectedTypes
 
 	public FinallyFlowContext(FlowContext parent, ASTNode associatedNode) {
 		super(parent, associatedNode);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 38295c8..cfab201 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - contributions for
  *     							bug 336428 - [compiler][null] bogus warning "redundant null check" in condition of do {} while() loop
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -51,6 +52,7 @@ public class LoopingFlowContext extends SwitchFlowContext {
 	Expression[] nullReferences;
 	int[] nullCheckTypes;
 	int nullCount;
+	// see also the related field FlowContext#expectedTypes
 
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
 	static private class EscapingExceptionCatchSite {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 6ee7e1b..189497d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 367203 - [compiler][null] detect assigning null to nonnull argument
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -453,10 +454,11 @@ protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
 	if (this.parameterNonNullness == null)
 		this.parameterNonNullness = new Boolean[this.parameters.length];
 	AbstractMethodDeclaration sourceMethod = sourceMethod();
-	for (int i = 0; i < this.parameterNonNullness.length; i++) {
+	boolean added = false;
+	int length = this.parameterNonNullness.length;
+	for (int i = 0; i < length; i++) {
 		if (this.parameters[i].isBaseType())
 			continue;
-		boolean added = false;
 		if (this.parameterNonNullness[i] == null) {
 			added = true;
 			this.parameterNonNullness[i] = Boolean.TRUE;
@@ -468,16 +470,16 @@ protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
 		} else if (this.parameterNonNullness[i].booleanValue()) {
 			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
 		}
-		if (added)
-			this.tagBits |= TagBits.HasParameterAnnotations;
 	}
+	if (added)
+		this.tagBits |= TagBits.HasParameterAnnotations;
 	if (   this.returnType != null
 		&& !this.returnType.isBaseType()
 		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
 	{
 		this.tagBits |= TagBits.AnnotationNonNull;
 		if (sourceMethod != null)
-			sourceMethod.addNullnessAnnotation((ReferenceBinding)annotationBinding);
+			sourceMethod.addNonNullAnnotation((ReferenceBinding)annotationBinding);
 	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
 		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index c7e6932..bdfee22 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -145,7 +147,7 @@ boolean canSkipInheritedMethods(MethodBinding one, MethodBinding two) {
 }
 void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods) {
 	super.checkConcreteInheritedMethod(concreteMethod, abstractMethods);
-
+	boolean analyseNullAnnotations = this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled;
 	for (int i = 0, l = abstractMethods.length; i < l; i++) {
 		MethodBinding abstractMethod = abstractMethods[i];
 		if (concreteMethod.isVarargs() != abstractMethod.isVarargs())
@@ -166,7 +168,7 @@ void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[]
 				|| this.type.superclass.erasure().findSuperTypeOriginatingFrom(originalInherited.declaringClass) == null)
 					this.type.addSyntheticBridgeMethod(originalInherited, concreteMethod.original());
 		}
-		if (!concreteMethod.isStatic() && !abstractMethod.isStatic())
+		if (analyseNullAnnotations && !concreteMethod.isStatic() && !abstractMethod.isStatic())
 			checkNullSpecInheritance(concreteMethod, abstractMethod);
 	}
 }
@@ -368,12 +370,15 @@ boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMetho
 void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)
 {
 	super.checkAgainstInheritedMethods(currentMethod, methods, length, allInheritedMethods);
-	for (int i = length; --i >= 0;)
-		if (!currentMethod.isStatic() && !methods[i].isStatic())
-			checkNullSpecInheritance(currentMethod, methods[i]);
+	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+		for (int i = length; --i >= 0;)
+			if (!currentMethod.isStatic() && !methods[i].isStatic())
+				checkNullSpecInheritance(currentMethod, methods[i]);
+	}
 }
 
 void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+	// precondition: caller has checked whether annotation-based null analysis is enabled.
 	long inheritedBits = inheritedMethod.tagBits;
 	long currentBits = currentMethod.tagBits;
 	AbstractMethodDeclaration srcMethod = null;
@@ -399,7 +404,8 @@ void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inherit
 	if (inheritedMethod.parameterNonNullness != null) {
 		// inherited method has null-annotations, check compatibility:
 
-		for (int i = 0; i < inheritedMethod.parameterNonNullness.length; i++) {
+		int length = inheritedMethod.parameterNonNullness.length;
+		for (int i = 0; i < length; i++) {
 			Argument currentArgument = currentArguments == null ? null : currentArguments[i];
 
 			Boolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];
@@ -416,7 +422,7 @@ void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inherit
 						annotationName = this.environment.getNullableAnnotationName();
 					}
 					if (currentArgument != null) {
-						this.type.scope.problemReporter().parameterLackingNonNullAnnotation(
+						this.type.scope.problemReporter().parameterLackingNullAnnotation(
 								currentArgument,
 								inheritedMethod.declaringClass,
 								needNonNull,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 330d65e..0a5394c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contributions for
+ *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -65,8 +67,9 @@ void addType(ReferenceBinding element) {
 	if (this.knownTypes == null)
 		this.knownTypes = new HashtableOfType(25);
 	this.knownTypes.put(element.compoundName[element.compoundName.length - 1], element);
-	if (element.isAnnotationType() || element instanceof UnresolvedReferenceBinding) // unresolved types don't yet have the modifiers set
-		checkIfNullAnnotationType(element);
+	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
+		if (element.isAnnotationType() || element instanceof UnresolvedReferenceBinding) // unresolved types don't yet have the modifiers set
+			checkIfNullAnnotationType(element);
 }
 
 void clearMissingTagBit() {
@@ -253,9 +256,10 @@ void checkIfNullAnnotationPackage() {
 }
 
 private boolean isPackageOfQualifiedTypeName(char[][] packageName, char[][] typeName) {
-	if (typeName == null || typeName.length -1 != packageName.length)
+	int length;
+	if (typeName == null || (length = packageName.length) != typeName.length -1)
 		return false;
-	for (int i=0; i<packageName.length; i++)
+	for (int i=0; i<length; i++)
 		if (!CharOperation.equals(packageName[i], typeName[i]))
 			return false;
 	return true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 8e57afb..ca750d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -376,6 +377,8 @@ public char[] computeGenericTypeSignature(TypeVariableBinding[] typeVariables) {
 }
 
 public void computeId() {
+	// note that more (configurable) ids are assigned from PackageBinding#checkIfNullAnnotationType() 
+
 	// try to avoid multiple checks against a package/type name
 	switch (this.compoundName.length) {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index b5ea0a6..c7ad46f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365836 - [compiler][null] Incomplete propagation of null defaults.
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1525,7 +1526,7 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 				if (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
 					method.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
 				newParameters[i] = parameterType;
-				arg.binding = new LocalVariableBinding(arg, parameterType, arg.modifiers, true);
+				arg.binding = new LocalVariableBinding(arg, parameterType, arg.modifiers, true /*isArgument*/);
 			}
 		}
 		// only assign parameters if no problems are found
@@ -1626,7 +1627,7 @@ private void createArgumentBindings(MethodBinding method) {
 	}
 }
 private void evaluateNullAnnotations(long annotationTagBits) {
-	if (this.nullnessDefaultInitialized > 0)
+	if (this.nullnessDefaultInitialized > 0 || !this.scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled)
 		return;
 	this.nullnessDefaultInitialized = 1;
 	// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 68f7326..49bac9d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -13,6 +13,7 @@
  *  	   						bug 338303 - Warning about Redundant assignment conflicts with definite assignment
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -8156,7 +8157,7 @@ public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBi
 			argument.type.sourceEnd);
 	}
 }
-public void parameterLackingNonNullAnnotation(Argument argument, ReferenceBinding declaringClass, boolean needNonNull, char[][] inheritedAnnotationName) {
+public void parameterLackingNullAnnotation(Argument argument, ReferenceBinding declaringClass, boolean needNonNull, char[][] inheritedAnnotationName) {
 	this.handle(
 		needNonNull ? IProblem.ParameterLackingNonNullAnnotation : IProblem.ParameterLackingNullableAnnotation, 
 		new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
@@ -8267,7 +8268,8 @@ private int findAnnotationSourceStart(Annotation[] annotations, int startFallbac
 	int sourceStart = startFallback;
 	if (annotations != null) {
 		// should have a @NonNull/@Nullable annotation, search for it:
-		for (int j=0; j<annotations.length; j++) {
+		int length = annotations.length;
+		for (int j=0; j<length; j++) {
 			if (annotations[j].resolvedType != null && annotations[j].resolvedType.id == typeId) {
 				sourceStart = annotations[j].sourceStart;
 				break;
