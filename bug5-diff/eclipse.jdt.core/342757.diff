commit ce73e795e17fb13da77192ae5025c50ccc7665fe
Author: Olivier Thomann <oliviert>
Date:   Thu Apr 14 17:22:48 2011 +0000

    HEAD - Fixed bug 342757: ArrayIndexOutOfBoundsException in MethodInfoWithParameterAnnotations.getParameterAnnotations when generating method info for an inner class constructor with annotated parameter

1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
46	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassFileTests.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
16	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
580	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
29	30	org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
21	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
22	382	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index d7a32ac..05b9769 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -789,7 +789,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 		assertEquals("Unexpected annotations", expected, actual);
 	}
 
-	private void appendAnnotation(StringBuffer buffer, IAnnotation annotation) throws JavaModelException {
+	protected void appendAnnotation(StringBuffer buffer, IAnnotation annotation) throws JavaModelException {
 		buffer.append('@');
 		buffer.append(annotation.getElementName());
 		IMemberValuePair[] members = annotation.getMemberValuePairs();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassFileTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassFileTests.java
index 773d552..feec85f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassFileTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClassFileTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -207,7 +207,21 @@ public void setUpSuite() throws Exception {
 		"import java.lang.annotation.Retention;\n" +
 		"import java.lang.annotation.RetentionPolicy;\n" + 
 		"@Retention(value = RetentionPolicy.CLASS)\n" + 
-		"public @interface MyAnnotation3 {}"
+		"public @interface MyAnnotation3 {}",
+		"test342757/X.java",
+		"package test342757;\n" +
+		"public class X {\n" + 
+		"	class B {\n" + 
+		"		public B(@Deprecated @Annot String s) {}\n" + 
+		"		public void foo(@Deprecated @Annot int j) {}\n" + 
+		"	}\n" + 
+		"}",
+		"test342757/Annot.java",
+		"package test342757;\n" +
+		"import java.lang.annotation.Retention;\n" + 
+		"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+		"@Retention(CLASS)\n" + 
+		"@interface Annot {}",
 	};
 	addLibrary(javaProject, "lib.jar", "libsrc.zip", pathAndContents, JavaCore.VERSION_1_5);
 	this.jarRoot = javaProject.getPackageFragmentRoot(getFile("/P/lib.jar"));
@@ -516,6 +530,36 @@ public void testAnnotations25() throws JavaModelException {
 }
 
 /*
+ * https://bugs.eclipse.org/bugs/show_bug.cgi?id=342757
+ */
+public void testAnnotations26() throws JavaModelException {
+	IType type = this.jarRoot.getPackageFragment("test342757").getClassFile("X$B.class").getType();
+	IMethod[] methods = type.getMethods();
+	String expected =
+			"@test342757.Annot\n" + 
+			"@java.lang.Deprecated\n" + 
+			"@test342757.Annot\n" + 
+			"@java.lang.Deprecated\n";
+	StringBuffer buffer = new StringBuffer();
+	for (int i = 0, max = methods.length; i < max; i++) {
+		ILocalVariable[] parameters = methods[i].getParameters();
+		for (int j = 0, max2 = parameters.length; j < max2; j++) {
+			IAnnotation[] annotations = parameters[j].getAnnotations();
+			for (int n = 0; n < annotations.length; n++) {
+				IAnnotation annotation = annotations[n];
+				appendAnnotation(buffer, annotation);
+				buffer.append("\n");
+			}
+		}
+	}
+	String actual = buffer.toString();
+	if (!expected.equals(actual)) {
+		System.out.println(displayString(actual, 2) + this.endChar);
+	}
+	assertEquals("Unexpected annotations", expected, actual);
+}
+
+/*
  * Ensures that no exception is thrown for a .class file name with a dot
  * (regression test for bug 114140 assertion failed when opening a class file not not the classpath)
  */
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 6a342f2..23358ff 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -51,7 +51,9 @@ Eclipse SDK 3.7M7 - %date% - 3.7.0 M7
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=340691">340691</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=342757">342757</a>
+ArrayIndexOutOfBoundsException in MethodInfoWithParameterAnnotations.getParameterAnnotations when generating method info for an inner class constructor with annotated parameter
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=340691">340691</a>
 Syntax error leads to ClassCastException in ASTConverter
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=342671">342671</a>
 ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
index fbb568b..9d871b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
@@ -1,23 +1,36 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2011 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *    tyeung@bea.com - initial API and implementation
+ *    tyeung@bea.com  - initial API and implementation
+ *    IBM Corporation - fix for bug 342757
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 class MethodInfoWithParameterAnnotations extends MethodInfoWithAnnotations {
 	private AnnotationInfo[][] parameterAnnotations;
 
 MethodInfoWithParameterAnnotations(MethodInfo methodInfo, AnnotationInfo[] annotations, AnnotationInfo[][] parameterAnnotations) {
 	super(methodInfo, annotations);
-	this.parameterAnnotations = parameterAnnotations;
+	if (methodInfo.isConstructor()) {
+		int parametersCount = Util.getParameterCount(methodInfo.getMethodDescriptor());
+		if (parameterAnnotations.length < parametersCount) {
+			AnnotationInfo[][] temp = new AnnotationInfo[parametersCount][];
+			System.arraycopy(parameterAnnotations, 0, temp, 1, parameterAnnotations.length);
+			this.parameterAnnotations = temp;
+		} else {
+			this.parameterAnnotations = parameterAnnotations;
+		}
+	} else {
+		this.parameterAnnotations = parameterAnnotations;
+	}
 }
 
 public IBinaryAnnotation[] getParameterAnnotations(int index) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 00096af..7625765 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -46,6 +46,180 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 
 public class Util implements SuffixConstants {
 
+	/**
+	 * Character constant indicating the primitive type boolean in a signature.
+	 * Value is <code>'Z'</code>.
+	 */
+	public static final char C_BOOLEAN 		= 'Z';
+
+	/**
+	 * Character constant indicating the primitive type byte in a signature.
+	 * Value is <code>'B'</code>.
+	 */
+	public static final char C_BYTE 		= 'B';
+
+	/**
+	 * Character constant indicating the primitive type char in a signature.
+	 * Value is <code>'C'</code>.
+	 */
+	public static final char C_CHAR 		= 'C';
+
+	/**
+	 * Character constant indicating the primitive type double in a signature.
+	 * Value is <code>'D'</code>.
+	 */
+	public static final char C_DOUBLE 		= 'D';
+
+	/**
+	 * Character constant indicating the primitive type float in a signature.
+	 * Value is <code>'F'</code>.
+	 */
+	public static final char C_FLOAT 		= 'F';
+
+	/**
+	 * Character constant indicating the primitive type int in a signature.
+	 * Value is <code>'I'</code>.
+	 */
+	public static final char C_INT 			= 'I';
+
+	/**
+	 * Character constant indicating the semicolon in a signature.
+	 * Value is <code>';'</code>.
+	 */
+	public static final char C_SEMICOLON 			= ';';
+
+	/**
+	 * Character constant indicating the colon in a signature.
+	 * Value is <code>':'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_COLON 			= ':';
+
+	/**
+	 * Character constant indicating the primitive type long in a signature.
+	 * Value is <code>'J'</code>.
+	 */
+	public static final char C_LONG			= 'J';
+
+	/**
+	 * Character constant indicating the primitive type short in a signature.
+	 * Value is <code>'S'</code>.
+	 */
+	public static final char C_SHORT		= 'S';
+
+	/**
+	 * Character constant indicating result type void in a signature.
+	 * Value is <code>'V'</code>.
+	 */
+	public static final char C_VOID			= 'V';
+
+	/**
+	 * Character constant indicating the start of a resolved type variable in a
+	 * signature. Value is <code>'T'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_TYPE_VARIABLE	= 'T';
+
+	/**
+	 * Character constant indicating an unbound wildcard type argument
+	 * in a signature.
+	 * Value is <code>'*'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_STAR	= '*';
+
+	/**
+	 * Character constant indicating an exception in a signature.
+	 * Value is <code>'^'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_EXCEPTION_START	= '^';
+
+	/**
+	 * Character constant indicating a bound wildcard type argument
+	 * in a signature with extends clause.
+	 * Value is <code>'+'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_EXTENDS	= '+';
+
+	/**
+	 * Character constant indicating a bound wildcard type argument
+	 * in a signature with super clause.
+	 * Value is <code>'-'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_SUPER	= '-';
+
+	/**
+	 * Character constant indicating the dot in a signature.
+	 * Value is <code>'.'</code>.
+	 */
+	public static final char C_DOT			= '.';
+
+	/**
+	 * Character constant indicating the dollar in a signature.
+	 * Value is <code>'$'</code>.
+	 */
+	public static final char C_DOLLAR			= '$';
+
+	/**
+	 * Character constant indicating an array type in a signature.
+	 * Value is <code>'['</code>.
+	 */
+	public static final char C_ARRAY		= '[';
+
+	/**
+	 * Character constant indicating the start of a resolved, named type in a
+	 * signature. Value is <code>'L'</code>.
+	 */
+	public static final char C_RESOLVED		= 'L';
+
+	/**
+	 * Character constant indicating the start of an unresolved, named type in a
+	 * signature. Value is <code>'Q'</code>.
+	 */
+	public static final char C_UNRESOLVED	= 'Q';
+
+	/**
+	 * Character constant indicating the end of a named type in a signature.
+	 * Value is <code>';'</code>.
+	 */
+	public static final char C_NAME_END		= ';';
+
+	/**
+	 * Character constant indicating the start of a parameter type list in a
+	 * signature. Value is <code>'('</code>.
+	 */
+	public static final char C_PARAM_START	= '(';
+
+	/**
+	 * Character constant indicating the end of a parameter type list in a
+	 * signature. Value is <code>')'</code>.
+	 */
+	public static final char C_PARAM_END	= ')';
+
+	/**
+	 * Character constant indicating the start of a formal type parameter
+	 * (or type argument) list in a signature. Value is <code>'&lt;'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_GENERIC_START	= '<';
+
+	/**
+	 * Character constant indicating the end of a generic type list in a
+	 * signature. Value is <code>'&gt;'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_GENERIC_END	= '>';
+
+	/**
+	 * Character constant indicating a capture of a wildcard type in a
+	 * signature. Value is <code>'!'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_CAPTURE	= '!';
+
 	public interface Displayable {
 		String displayString(Object o);
 	}
@@ -977,4 +1151,409 @@ public class Util implements SuffixConstants {
 			}
 		}
 	}
+	public static int getParameterCount(char[] methodSignature) {
+		try {
+			int count = 0;
+			int i = CharOperation.indexOf(C_PARAM_START, methodSignature);
+			if (i < 0) {
+				throw new IllegalArgumentException();
+			} else {
+				i++;
+			}
+			for (;;) {
+				if (methodSignature[i] == C_PARAM_END) {
+					return count;
+				}
+				int e= Util.scanTypeSignature(methodSignature, i);
+				if (e < 0) {
+					throw new IllegalArgumentException();
+				} else {
+					i = e + 1;
+				}
+				count++;
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for a type signature starting at the given index
+	 * and returns the index of the last character.
+	 * <pre>
+	 * TypeSignature:
+	 *  |  BaseTypeSignature
+	 *  |  ArrayTypeSignature
+	 *  |  ClassTypeSignature
+	 *  |  TypeVariableSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type signature
+	 */
+	public static int scanTypeSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case C_ARRAY :
+				return scanArrayTypeSignature(string, start);
+			case C_RESOLVED :
+			case C_UNRESOLVED :
+				return scanClassTypeSignature(string, start);
+			case C_TYPE_VARIABLE :
+				return scanTypeVariableSignature(string, start);
+			case C_BOOLEAN :
+			case C_BYTE :
+			case C_CHAR :
+			case C_DOUBLE :
+			case C_FLOAT :
+			case C_INT :
+			case C_LONG :
+			case C_SHORT :
+			case C_VOID :
+				return scanBaseTypeSignature(string, start);
+			case C_CAPTURE :
+				return scanCaptureTypeSignature(string, start);
+			case C_EXTENDS:
+			case C_SUPER:
+			case C_STAR:
+				return scanTypeBoundSignature(string, start);
+			default :
+				throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for a base type signature starting at the given index
+	 * and returns the index of the last character.
+	 * <pre>
+	 * BaseTypeSignature:
+	 *     <b>B</b> | <b>C</b> | <b>D</b> | <b>F</b> | <b>I</b>
+	 *   | <b>J</b> | <b>S</b> | <b>V</b> | <b>Z</b>
+	 * </pre>
+	 * Note that although the base type "V" is only allowed in method return types,
+	 * there is no syntactic ambiguity. This method will accept them anywhere
+	 * without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a base type signature
+	 */
+	public static int scanBaseTypeSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if ("BCDFIJSVZ".indexOf(c) >= 0) { //$NON-NLS-1$
+			return start;
+		} else {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for an array type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * ArrayTypeSignature:
+	 *     <b>[</b> TypeSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an array type signature
+	 */
+	public static int scanArrayTypeSignature(char[] string, int start) {
+		int length = string.length;
+		// need a minimum 2 char
+		if (start >= length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_ARRAY) {
+			throw new IllegalArgumentException();
+		}
+	
+		c = string[++start];
+		while(c == C_ARRAY) {
+			// need a minimum 2 char
+			if (start >= length - 1) {
+				throw new IllegalArgumentException();
+			}
+			c = string[++start];
+		}
+		return scanTypeSignature(string, start);
+	}
+
+	/**
+	 * Scans the given string for a capture of a wildcard type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * CaptureTypeSignature:
+	 *     <b>!</b> TypeBoundSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a capture type signature
+	 */
+	public static int scanCaptureTypeSignature(char[] string, int start) {
+		// need a minimum 2 char
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_CAPTURE) {
+			throw new IllegalArgumentException();
+		}
+		return scanTypeBoundSignature(string, start + 1);
+	}
+
+	/**
+	 * Scans the given string for a type variable signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeVariableSignature:
+	 *     <b>T</b> Identifier <b>;</b>
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type variable signature
+	 */
+	public static int scanTypeVariableSignature(char[] string, int start) {
+		// need a minimum 3 chars "Tx;"
+		if (start >= string.length - 2) {
+			throw new IllegalArgumentException();
+		}
+		// must start in "T"
+		char c = string[start];
+		if (c != C_TYPE_VARIABLE) {
+			throw new IllegalArgumentException();
+		}
+		int id = scanIdentifier(string, start + 1);
+		c = string[id + 1];
+		if (c == C_SEMICOLON) {
+			return id + 1;
+		} else {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for an identifier starting at the given
+	 * index and returns the index of the last character.
+	 * Stop characters are: ";", ":", "&lt;", "&gt;", "/", ".".
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an identifier
+	 */
+	public static int scanIdentifier(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		int p = start;
+		while (true) {
+			char c = string[p];
+			if (c == '<' || c == '>' || c == ':' || c == ';' || c == '.' || c == '/') {
+				return p - 1;
+			}
+			p++;
+			if (p == string.length) {
+				return p - 1;
+			}
+		}
+	}
+
+	/**
+	 * Scans the given string for a class type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * ClassTypeSignature:
+	 *     { <b>L</b> | <b>Q</b> } Identifier
+	 *           { { <b>/</b> | <b>.</b> Identifier [ <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b> ] }
+	 *           <b>;</b>
+	 * </pre>
+	 * Note that although all "/"-identifiers most come before "."-identifiers,
+	 * there is no syntactic ambiguity. This method will accept them without
+	 * complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a class type signature
+	 */
+	public static int scanClassTypeSignature(char[] string, int start) {
+		// need a minimum 3 chars "Lx;"
+		if (start >= string.length - 2) {
+			throw new IllegalArgumentException();
+		}
+		// must start in "L" or "Q"
+		char c = string[start];
+		if (c != C_RESOLVED && c != C_UNRESOLVED) {
+			return -1;
+		}
+		int p = start + 1;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			if (c == C_SEMICOLON) {
+				// all done
+				return p;
+			} else if (c == C_GENERIC_START) {
+				int e = scanTypeArgumentSignatures(string, p);
+				p = e;
+			} else if (c == C_DOT || c == '/') {
+				int id = scanIdentifier(string, p + 1);
+				p = id;
+			}
+			p++;
+		}
+	}
+
+	/**
+	 * Scans the given string for a type bound signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeBoundSignature:
+	 *     <b>[-+]</b> TypeSignature <b>;</b>
+	 *     <b>*</b></b>
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type variable signature
+	 */
+	public static int scanTypeBoundSignature(char[] string, int start) {
+		// need a minimum 1 char for wildcard
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case C_STAR :
+				return start;
+			case C_SUPER :
+			case C_EXTENDS :
+				// need a minimum 3 chars "+[I"
+				if (start >= string.length - 2) {
+					throw new IllegalArgumentException();
+				}
+				break;
+			default :
+				// must start in "+/-"
+					throw new IllegalArgumentException();
+	
+		}
+		c = string[++start];
+		switch (c) {
+			case C_CAPTURE :
+				return scanCaptureTypeSignature(string, start);
+			case C_SUPER :
+			case C_EXTENDS :
+				return scanTypeBoundSignature(string, start);
+			case C_RESOLVED :
+			case C_UNRESOLVED :
+				return scanClassTypeSignature(string, start);
+			case C_TYPE_VARIABLE :
+				return scanTypeVariableSignature(string, start);
+			case C_ARRAY :
+				return scanArrayTypeSignature(string, start);
+			case C_STAR:
+				return start;
+			default:
+				throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for a list of type argument signatures starting at
+	 * the given index and returns the index of the last character.
+	 * <pre>
+	 * TypeArgumentSignatures:
+	 *     <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b>
+	 * </pre>
+	 * Note that although there is supposed to be at least one type argument, there
+	 * is no syntactic ambiguity if there are none. This method will accept zero
+	 * type argument signatures without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a list of type arguments
+	 * signatures
+	 */
+	public static int scanTypeArgumentSignatures(char[] string, int start) {
+		// need a minimum 2 char "<>"
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_GENERIC_START) {
+			throw new IllegalArgumentException();
+		}
+		int p = start + 1;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			if (c == C_GENERIC_END) {
+				return p;
+			}
+			int e = scanTypeArgumentSignature(string, p);
+			p = e + 1;
+		}
+	}
+
+	/**
+	 * Scans the given string for a type argument signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeArgumentSignature:
+	 *     <b>&#42;</b>
+	 *  |  <b>+</b> TypeSignature
+	 *  |  <b>-</b> TypeSignature
+	 *  |  TypeSignature
+	 * </pre>
+	 * Note that although base types are not allowed in type arguments, there is
+	 * no syntactic ambiguity. This method will accept them without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type argument signature
+	 */
+	public static int scanTypeArgumentSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case C_STAR :
+				return start;
+			case C_EXTENDS :
+			case C_SUPER :
+				return scanTypeBoundSignature(string, start);
+			default :
+				return scanTypeSignature(string, start);
+		}
+	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java
index 15f1723..e078282 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,8 +15,7 @@ import java.util.ArrayList;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
-import org.eclipse.jdt.internal.core.util.Util;
-
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
  * Provides methods for encoding and decoding type and method signature strings.
@@ -149,75 +148,75 @@ public final class Signature {
 	 * Character constant indicating the primitive type boolean in a signature.
 	 * Value is <code>'Z'</code>.
 	 */
-	public static final char C_BOOLEAN 		= 'Z';
+	public static final char C_BOOLEAN = org.eclipse.jdt.internal.compiler.util.Util.C_BOOLEAN;
 
 	/**
 	 * Character constant indicating the primitive type byte in a signature.
 	 * Value is <code>'B'</code>.
 	 */
-	public static final char C_BYTE 		= 'B';
+	public static final char C_BYTE = org.eclipse.jdt.internal.compiler.util.Util.C_BYTE;
 
 	/**
 	 * Character constant indicating the primitive type char in a signature.
 	 * Value is <code>'C'</code>.
 	 */
-	public static final char C_CHAR 		= 'C';
+	public static final char C_CHAR = org.eclipse.jdt.internal.compiler.util.Util.C_CHAR;
 
 	/**
 	 * Character constant indicating the primitive type double in a signature.
 	 * Value is <code>'D'</code>.
 	 */
-	public static final char C_DOUBLE 		= 'D';
+	public static final char C_DOUBLE = org.eclipse.jdt.internal.compiler.util.Util.C_DOUBLE;
 
 	/**
 	 * Character constant indicating the primitive type float in a signature.
 	 * Value is <code>'F'</code>.
 	 */
-	public static final char C_FLOAT 		= 'F';
+	public static final char C_FLOAT = org.eclipse.jdt.internal.compiler.util.Util.C_FLOAT;
 
 	/**
 	 * Character constant indicating the primitive type int in a signature.
 	 * Value is <code>'I'</code>.
 	 */
-	public static final char C_INT 			= 'I';
+	public static final char C_INT = org.eclipse.jdt.internal.compiler.util.Util.C_INT;
 
 	/**
 	 * Character constant indicating the semicolon in a signature.
 	 * Value is <code>';'</code>.
 	 */
-	public static final char C_SEMICOLON 			= ';';
+	public static final char C_SEMICOLON = org.eclipse.jdt.internal.compiler.util.Util.C_SEMICOLON;
 
 	/**
 	 * Character constant indicating the colon in a signature.
 	 * Value is <code>':'</code>.
 	 * @since 3.0
 	 */
-	public static final char C_COLON 			= ':';
+	public static final char C_COLON = org.eclipse.jdt.internal.compiler.util.Util.C_COLON;
 
 	/**
 	 * Character constant indicating the primitive type long in a signature.
 	 * Value is <code>'J'</code>.
 	 */
-	public static final char C_LONG			= 'J';
+	public static final char C_LONG = org.eclipse.jdt.internal.compiler.util.Util.C_LONG;
 
 	/**
 	 * Character constant indicating the primitive type short in a signature.
 	 * Value is <code>'S'</code>.
 	 */
-	public static final char C_SHORT		= 'S';
+	public static final char C_SHORT = org.eclipse.jdt.internal.compiler.util.Util.C_SHORT;
 
 	/**
 	 * Character constant indicating result type void in a signature.
 	 * Value is <code>'V'</code>.
 	 */
-	public static final char C_VOID			= 'V';
+	public static final char C_VOID = org.eclipse.jdt.internal.compiler.util.Util.C_VOID;
 
 	/**
 	 * Character constant indicating the start of a resolved type variable in a
 	 * signature. Value is <code>'T'</code>.
 	 * @since 3.0
 	 */
-	public static final char C_TYPE_VARIABLE	= 'T';
+	public static final char C_TYPE_VARIABLE = org.eclipse.jdt.internal.compiler.util.Util.C_TYPE_VARIABLE;
 
 	/**
 	 * Character constant indicating an unbound wildcard type argument
@@ -225,14 +224,14 @@ public final class Signature {
 	 * Value is <code>'*'</code>.
 	 * @since 3.0
 	 */
-	public static final char C_STAR	= '*';
+	public static final char C_STAR = org.eclipse.jdt.internal.compiler.util.Util.C_STAR;
 
 	/**
 	 * Character constant indicating an exception in a signature.
 	 * Value is <code>'^'</code>.
 	 * @since 3.1
 	 */
-	public static final char C_EXCEPTION_START	= '^';
+	public static final char C_EXCEPTION_START = org.eclipse.jdt.internal.compiler.util.Util.C_EXCEPTION_START;
 
 	/**
 	 * Character constant indicating a bound wildcard type argument
@@ -240,7 +239,7 @@ public final class Signature {
 	 * Value is <code>'+'</code>.
 	 * @since 3.1
 	 */
-	public static final char C_EXTENDS	= '+';
+	public static final char C_EXTENDS = org.eclipse.jdt.internal.compiler.util.Util.C_EXTENDS;
 
 	/**
 	 * Character constant indicating a bound wildcard type argument
@@ -248,76 +247,76 @@ public final class Signature {
 	 * Value is <code>'-'</code>.
 	 * @since 3.1
 	 */
-	public static final char C_SUPER	= '-';
+	public static final char C_SUPER = org.eclipse.jdt.internal.compiler.util.Util.C_SUPER;
 
 	/**
 	 * Character constant indicating the dot in a signature.
 	 * Value is <code>'.'</code>.
 	 */
-	public static final char C_DOT			= '.';
+	public static final char C_DOT = org.eclipse.jdt.internal.compiler.util.Util.C_DOT;
 
 	/**
 	 * Character constant indicating the dollar in a signature.
 	 * Value is <code>'$'</code>.
 	 */
-	public static final char C_DOLLAR			= '$';
+	public static final char C_DOLLAR = org.eclipse.jdt.internal.compiler.util.Util.C_DOLLAR;
 
 	/**
 	 * Character constant indicating an array type in a signature.
 	 * Value is <code>'['</code>.
 	 */
-	public static final char C_ARRAY		= '[';
+	public static final char C_ARRAY = org.eclipse.jdt.internal.compiler.util.Util.C_ARRAY;
 
 	/**
 	 * Character constant indicating the start of a resolved, named type in a
 	 * signature. Value is <code>'L'</code>.
 	 */
-	public static final char C_RESOLVED		= 'L';
+	public static final char C_RESOLVED = org.eclipse.jdt.internal.compiler.util.Util.C_RESOLVED;
 
 	/**
 	 * Character constant indicating the start of an unresolved, named type in a
 	 * signature. Value is <code>'Q'</code>.
 	 */
-	public static final char C_UNRESOLVED	= 'Q';
+	public static final char C_UNRESOLVED = org.eclipse.jdt.internal.compiler.util.Util.C_UNRESOLVED;
 
 	/**
 	 * Character constant indicating the end of a named type in a signature.
 	 * Value is <code>';'</code>.
 	 */
-	public static final char C_NAME_END		= ';';
+	public static final char C_NAME_END = org.eclipse.jdt.internal.compiler.util.Util.C_NAME_END;
 
 	/**
 	 * Character constant indicating the start of a parameter type list in a
 	 * signature. Value is <code>'('</code>.
 	 */
-	public static final char C_PARAM_START	= '(';
+	public static final char C_PARAM_START = org.eclipse.jdt.internal.compiler.util.Util.C_PARAM_START;
 
 	/**
 	 * Character constant indicating the end of a parameter type list in a
 	 * signature. Value is <code>')'</code>.
 	 */
-	public static final char C_PARAM_END	= ')';
+	public static final char C_PARAM_END = org.eclipse.jdt.internal.compiler.util.Util.C_PARAM_END;
 
 	/**
 	 * Character constant indicating the start of a formal type parameter
 	 * (or type argument) list in a signature. Value is <code>'&lt;'</code>.
 	 * @since 3.0
 	 */
-	public static final char C_GENERIC_START	= '<';
+	public static final char C_GENERIC_START = org.eclipse.jdt.internal.compiler.util.Util.C_GENERIC_START;
 
 	/**
 	 * Character constant indicating the end of a generic type list in a
 	 * signature. Value is <code>'&gt;'</code>.
 	 * @since 3.0
 	 */
-	public static final char C_GENERIC_END	= '>';
+	public static final char C_GENERIC_END = org.eclipse.jdt.internal.compiler.util.Util.C_GENERIC_END;
 
 	/**
 	 * Character constant indicating a capture of a wildcard type in a
 	 * signature. Value is <code>'!'</code>.
 	 * @since 3.1
 	 */
-	public static final char C_CAPTURE	= '!';
+	public static final char C_CAPTURE =  org.eclipse.jdt.internal.compiler.util.Util.C_CAPTURE;
 
 	/**
 	 * String constant for the signature of the primitive type boolean.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
index ef32aad..5219750 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -510,7 +510,7 @@ public String getSuperclassTypeSignature() throws JavaModelException {
 			index++;
 		}
 		int start = index;
-		index = Util.scanClassTypeSignature(genericSignature, start) + 1;
+		index = org.eclipse.jdt.internal.compiler.util.Util.scanClassTypeSignature(genericSignature, start) + 1;
 		char[] superclassSig = CharOperation.subarray(genericSignature, start, index);
 		return new String(ClassFile.translatedName(superclassSig));
 	} else {
@@ -596,10 +596,10 @@ public String[] getSuperInterfaceTypeSignatures() throws JavaModelException {
 			index++;
 		}
 		// skip superclass
-		index = Util.scanClassTypeSignature(genericSignature, index) + 1;
+		index = org.eclipse.jdt.internal.compiler.util.Util.scanClassTypeSignature(genericSignature, index) + 1;
 		while (index  < signatureLength) {
 			int start = index;
-			index = Util.scanClassTypeSignature(genericSignature, start) + 1;
+			index = org.eclipse.jdt.internal.compiler.util.Util.scanClassTypeSignature(genericSignature, start) + 1;
 			char[] interfaceSig = CharOperation.subarray(genericSignature, start, index);
 			interfaces.add(new String(ClassFile.translatedName(interfaceSig)));
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index e4df0b0..c54fd73 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -546,11 +546,25 @@ public class Disassembler extends ClassFileBytesDisassembler {
 				IRuntimeInvisibleParameterAnnotationsAttribute attribute = (IRuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute;
 				invisibleParameterAnnotations = attribute.getParameterAnnotations();
 				length = invisibleParameterAnnotations.length;
+				if (length > 0) {
+					int parameterNamesLength = parameterNames.length;
+					if (length < parameterNamesLength) {
+						System.arraycopy(invisibleParameterAnnotations, 0, (invisibleParameterAnnotations = new IParameterAnnotation[parameterNamesLength]), 1, length);
+						length = parameterNamesLength;
+					}
+				}
 			}
 			if (runtimeVisibleParameterAnnotationsAttribute != null) {
 				IRuntimeVisibleParameterAnnotationsAttribute attribute = (IRuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute;
 				visibleParameterAnnotations = attribute.getParameterAnnotations();
 				length = visibleParameterAnnotations.length;
+				if (length > 0) {
+					int parameterNamesLength = parameterNames.length;
+					if (length < parameterNamesLength) {
+						System.arraycopy(visibleParameterAnnotations, 0, (visibleParameterAnnotations = new IParameterAnnotation[parameterNamesLength]), 1, length);
+						length = parameterNamesLength;
+					}
+				}
 			}
 			int insertionPosition = CharOperation.indexOf('(', methodHeader) + 1;
 			int start = 0;
@@ -561,15 +575,15 @@ public class Disassembler extends ClassFileBytesDisassembler {
 					stringBuffer.append(' ');
 				}
 				int stringBufferSize = stringBuffer.length();
-				if (runtimeVisibleParameterAnnotationsAttribute != null) {
-					disassembleAsModifier((IRuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);
+				if (visibleParameterAnnotations != null) {
+					disassembleAsModifier(visibleParameterAnnotations, stringBuffer, i, lineSeparator, tabNumber, mode);
 				}
-				if (runtimeInvisibleParameterAnnotationsAttribute != null) {
+				if (invisibleParameterAnnotations != null) {
 					if (stringBuffer.length() != stringBufferSize) {
 						stringBuffer.append(' ');
 						stringBufferSize = stringBuffer.length();
 					}
-					disassembleAsModifier((IRuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);
+					disassembleAsModifier(invisibleParameterAnnotations, stringBuffer, i, lineSeparator, tabNumber, mode);
 				}
 				if (i == 0 && stringBuffer.length() != stringBufferSize) {
 					stringBuffer.append(' ');
@@ -1862,21 +1876,14 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		}
 	}
 
-	private void disassembleAsModifier(IRuntimeInvisibleParameterAnnotationsAttribute runtimeInvisibleParameterAnnotationsAttribute, StringBuffer buffer, int index, String lineSeparator, int tabNumber, int mode) {
-		IParameterAnnotation[] parameterAnnotations = runtimeInvisibleParameterAnnotationsAttribute.getParameterAnnotations();
-		if (parameterAnnotations.length > index) {
-			disassembleAsModifier(parameterAnnotations[index], buffer, lineSeparator, tabNumber + 1, mode);
-		}
-	}
-
-	private void disassembleAsModifier(IRuntimeVisibleParameterAnnotationsAttribute runtimeVisibleParameterAnnotationsAttribute, StringBuffer buffer, int index, String lineSeparator, int tabNumber, int mode) {
-		IParameterAnnotation[] parameterAnnotations = runtimeVisibleParameterAnnotationsAttribute.getParameterAnnotations();
+	private void disassembleAsModifier(IParameterAnnotation[] parameterAnnotations, StringBuffer buffer, int index, String lineSeparator, int tabNumber, int mode) {
 		if (parameterAnnotations.length > index) {
 			disassembleAsModifier(parameterAnnotations[index], buffer, lineSeparator, tabNumber + 1, mode);
 		}
 	}
 
 	private void disassembleAsModifier(IParameterAnnotation parameterAnnotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		if (parameterAnnotation == null) return;
 		IAnnotation[] annotations = parameterAnnotation.getAnnotations();
 		for (int i = 0, max = annotations.length; i < max; i++) {
 			if (i > 0) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
index a937b25..71e15fc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
@@ -2172,6 +2172,26 @@ public class Util {
 	}
 
 	/**
+	 * Scans the given string for a type signature starting at the given index
+	 * and returns the index of the last character.
+	 * <pre>
+	 * TypeSignature:
+	 *  |  BaseTypeSignature
+	 *  |  ArrayTypeSignature
+	 *  |  ClassTypeSignature
+	 *  |  TypeVariableSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type signature
+	 */
+	public static int scanTypeSignature(char[] string, int start) {
+		// this method is used in jdt.debug
+		return org.eclipse.jdt.internal.compiler.util.Util.scanTypeSignature(string, start);
+	}
+	/**
 	 * Return a new array which is the split of the given string using the given divider. The given end
 	 * is exclusive and the given start is inclusive.
 	 * <br>
@@ -2541,7 +2561,7 @@ public class Util {
 				appendClassTypeSignature(string, start, buffer, compact);
 				break;
 			case Signature.C_TYPE_VARIABLE :
-				int e = Util.scanTypeVariableSignature(string, start);
+				int e = org.eclipse.jdt.internal.compiler.util.Util.scanTypeVariableSignature(string, start);
 				buffer.append(string, start + 1, e - start - 1);
 				break;
 			case Signature.C_BOOLEAN :
@@ -2721,386 +2741,6 @@ public class Util {
 	}
 
 	/**
-	 * Scans the given string for a type signature starting at the given index
-	 * and returns the index of the last character.
-	 * <pre>
-	 * TypeSignature:
-	 *  |  BaseTypeSignature
-	 *  |  ArrayTypeSignature
-	 *  |  ClassTypeSignature
-	 *  |  TypeVariableSignature
-	 * </pre>
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a type signature
-	 */
-	public static int scanTypeSignature(char[] string, int start) {
-		// need a minimum 1 char
-		if (start >= string.length) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		switch (c) {
-			case Signature.C_ARRAY :
-				return scanArrayTypeSignature(string, start);
-			case Signature.C_RESOLVED :
-			case Signature.C_UNRESOLVED :
-				return scanClassTypeSignature(string, start);
-			case Signature.C_TYPE_VARIABLE :
-				return scanTypeVariableSignature(string, start);
-			case Signature.C_BOOLEAN :
-			case Signature.C_BYTE :
-			case Signature.C_CHAR :
-			case Signature.C_DOUBLE :
-			case Signature.C_FLOAT :
-			case Signature.C_INT :
-			case Signature.C_LONG :
-			case Signature.C_SHORT :
-			case Signature.C_VOID :
-				return scanBaseTypeSignature(string, start);
-			case Signature.C_CAPTURE :
-				return scanCaptureTypeSignature(string, start);
-			case Signature.C_EXTENDS:
-			case Signature.C_SUPER:
-			case Signature.C_STAR:
-				return scanTypeBoundSignature(string, start);
-			default :
-				throw new IllegalArgumentException();
-		}
-	}
-
-	/**
-	 * Scans the given string for a base type signature starting at the given index
-	 * and returns the index of the last character.
-	 * <pre>
-	 * BaseTypeSignature:
-	 *     <b>B</b> | <b>C</b> | <b>D</b> | <b>F</b> | <b>I</b>
-	 *   | <b>J</b> | <b>S</b> | <b>V</b> | <b>Z</b>
-	 * </pre>
-	 * Note that although the base type "V" is only allowed in method return types,
-	 * there is no syntactic ambiguity. This method will accept them anywhere
-	 * without complaint.
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a base type signature
-	 */
-	public static int scanBaseTypeSignature(char[] string, int start) {
-		// need a minimum 1 char
-		if (start >= string.length) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		if ("BCDFIJSVZ".indexOf(c) >= 0) { //$NON-NLS-1$
-			return start;
-		} else {
-			throw new IllegalArgumentException();
-		}
-	}
-
-	/**
-	 * Scans the given string for an array type signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * ArrayTypeSignature:
-	 *     <b>[</b> TypeSignature
-	 * </pre>
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not an array type signature
-	 */
-	public static int scanArrayTypeSignature(char[] string, int start) {
-		int length = string.length;
-		// need a minimum 2 char
-		if (start >= length - 1) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		if (c != Signature.C_ARRAY) {
-			throw new IllegalArgumentException();
-		}
-
-		c = string[++start];
-		while(c == Signature.C_ARRAY) {
-			// need a minimum 2 char
-			if (start >= length - 1) {
-				throw new IllegalArgumentException();
-			}
-			c = string[++start];
-		}
-		return scanTypeSignature(string, start);
-	}
-
-	/**
-	 * Scans the given string for a capture of a wildcard type signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * CaptureTypeSignature:
-	 *     <b>!</b> TypeBoundSignature
-	 * </pre>
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a capture type signature
-	 */
-	public static int scanCaptureTypeSignature(char[] string, int start) {
-		// need a minimum 2 char
-		if (start >= string.length - 1) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		if (c != Signature.C_CAPTURE) {
-			throw new IllegalArgumentException();
-		}
-		return scanTypeBoundSignature(string, start + 1);
-	}
-
-	/**
-	 * Scans the given string for a type variable signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * TypeVariableSignature:
-	 *     <b>T</b> Identifier <b>;</b>
-	 * </pre>
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a type variable signature
-	 */
-	public static int scanTypeVariableSignature(char[] string, int start) {
-		// need a minimum 3 chars "Tx;"
-		if (start >= string.length - 2) {
-			throw new IllegalArgumentException();
-		}
-		// must start in "T"
-		char c = string[start];
-		if (c != Signature.C_TYPE_VARIABLE) {
-			throw new IllegalArgumentException();
-		}
-		int id = scanIdentifier(string, start + 1);
-		c = string[id + 1];
-		if (c == Signature.C_SEMICOLON) {
-			return id + 1;
-		} else {
-			throw new IllegalArgumentException();
-		}
-	}
-
-	/**
-	 * Scans the given string for an identifier starting at the given
-	 * index and returns the index of the last character.
-	 * Stop characters are: ";", ":", "&lt;", "&gt;", "/", ".".
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not an identifier
-	 */
-	public static int scanIdentifier(char[] string, int start) {
-		// need a minimum 1 char
-		if (start >= string.length) {
-			throw new IllegalArgumentException();
-		}
-		int p = start;
-		while (true) {
-			char c = string[p];
-			if (c == '<' || c == '>' || c == ':' || c == ';' || c == '.' || c == '/') {
-				return p - 1;
-			}
-			p++;
-			if (p == string.length) {
-				return p - 1;
-			}
-		}
-	}
-
-	/**
-	 * Scans the given string for a class type signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * ClassTypeSignature:
-	 *     { <b>L</b> | <b>Q</b> } Identifier
-	 *           { { <b>/</b> | <b>.</b> Identifier [ <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b> ] }
-	 *           <b>;</b>
-	 * </pre>
-	 * Note that although all "/"-identifiers most come before "."-identifiers,
-	 * there is no syntactic ambiguity. This method will accept them without
-	 * complaint.
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a class type signature
-	 */
-	public static int scanClassTypeSignature(char[] string, int start) {
-		// need a minimum 3 chars "Lx;"
-		if (start >= string.length - 2) {
-			throw new IllegalArgumentException();
-		}
-		// must start in "L" or "Q"
-		char c = string[start];
-		if (c != Signature.C_RESOLVED && c != Signature.C_UNRESOLVED) {
-			return -1;
-		}
-		int p = start + 1;
-		while (true) {
-			if (p >= string.length) {
-				throw new IllegalArgumentException();
-			}
-			c = string[p];
-			if (c == Signature.C_SEMICOLON) {
-				// all done
-				return p;
-			} else if (c == Signature.C_GENERIC_START) {
-				int e = scanTypeArgumentSignatures(string, p);
-				p = e;
-			} else if (c == Signature.C_DOT || c == '/') {
-				int id = scanIdentifier(string, p + 1);
-				p = id;
-			}
-			p++;
-		}
-	}
-
-	/**
-	 * Scans the given string for a type bound signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * TypeBoundSignature:
-	 *     <b>[-+]</b> TypeSignature <b>;</b>
-	 *     <b>*</b></b>
-	 * </pre>
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a type variable signature
-	 */
-	public static int scanTypeBoundSignature(char[] string, int start) {
-		// need a minimum 1 char for wildcard
-		if (start >= string.length) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		switch (c) {
-			case Signature.C_STAR :
-				return start;
-			case Signature.C_SUPER :
-			case Signature.C_EXTENDS :
-				// need a minimum 3 chars "+[I"
-				if (start >= string.length - 2) {
-					throw new IllegalArgumentException();
-				}
-				break;
-			default :
-				// must start in "+/-"
-					throw new IllegalArgumentException();
-
-		}
-		c = string[++start];
-		switch (c) {
-			case Signature.C_CAPTURE :
-				return scanCaptureTypeSignature(string, start);
-			case Signature.C_SUPER :
-			case Signature.C_EXTENDS :
-				return scanTypeBoundSignature(string, start);
-			case Signature.C_RESOLVED :
-			case Signature.C_UNRESOLVED :
-				return scanClassTypeSignature(string, start);
-			case Signature.C_TYPE_VARIABLE :
-				return scanTypeVariableSignature(string, start);
-			case Signature.C_ARRAY :
-				return scanArrayTypeSignature(string, start);
-			case Signature.C_STAR:
-				return start;
-			default:
-				throw new IllegalArgumentException();
-		}
-	}
-
-	/**
-	 * Scans the given string for a list of type argument signatures starting at
-	 * the given index and returns the index of the last character.
-	 * <pre>
-	 * TypeArgumentSignatures:
-	 *     <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b>
-	 * </pre>
-	 * Note that although there is supposed to be at least one type argument, there
-	 * is no syntactic ambiguity if there are none. This method will accept zero
-	 * type argument signatures without complaint.
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a list of type arguments
-	 * signatures
-	 */
-	public static int scanTypeArgumentSignatures(char[] string, int start) {
-		// need a minimum 2 char "<>"
-		if (start >= string.length - 1) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		if (c != Signature.C_GENERIC_START) {
-			throw new IllegalArgumentException();
-		}
-		int p = start + 1;
-		while (true) {
-			if (p >= string.length) {
-				throw new IllegalArgumentException();
-			}
-			c = string[p];
-			if (c == Signature.C_GENERIC_END) {
-				return p;
-			}
-			int e = scanTypeArgumentSignature(string, p);
-			p = e + 1;
-		}
-	}
-
-	/**
-	 * Scans the given string for a type argument signature starting at the given
-	 * index and returns the index of the last character.
-	 * <pre>
-	 * TypeArgumentSignature:
-	 *     <b>&#42;</b>
-	 *  |  <b>+</b> TypeSignature
-	 *  |  <b>-</b> TypeSignature
-	 *  |  TypeSignature
-	 * </pre>
-	 * Note that although base types are not allowed in type arguments, there is
-	 * no syntactic ambiguity. This method will accept them without complaint.
-	 *
-	 * @param string the signature string
-	 * @param start the 0-based character index of the first character
-	 * @return the 0-based character index of the last character
-	 * @exception IllegalArgumentException if this is not a type argument signature
-	 */
-	public static int scanTypeArgumentSignature(char[] string, int start) {
-		// need a minimum 1 char
-		if (start >= string.length) {
-			throw new IllegalArgumentException();
-		}
-		char c = string[start];
-		switch (c) {
-			case Signature.C_STAR :
-				return start;
-			case Signature.C_EXTENDS :
-			case Signature.C_SUPER :
-				return scanTypeBoundSignature(string, start);
-			default :
-				return scanTypeSignature(string, start);
-		}
-	}
-
-	/**
 	 * Get all type arguments from an array of signatures.
 	 *
 	 * Example:
@@ -3400,7 +3040,7 @@ public class Util {
 				case Signature.C_RESOLVED :
 					return appendClassTypeSignatureForAnchor(string, start, buffer);
 				case Signature.C_TYPE_VARIABLE :
-					int e = Util.scanTypeVariableSignature(string, start);
+					int e = org.eclipse.jdt.internal.compiler.util.Util.scanTypeVariableSignature(string, start);
 					buffer.append(string, start + 1, e - start - 1);
 					return e;
 				case Signature.C_BOOLEAN :
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
index 95e17b2..9c7538e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/BinaryIndexer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -798,7 +798,7 @@ public class BinaryIndexer extends AbstractIndexer implements SuffixConstants {
 		if (descriptor[0] != '(') return descriptor;
 		if (descriptor[1] != ')') {
 			// remove the first synthetic parameter
-			int start = Util.scanTypeSignature(descriptor, 1) + 1;
+			int start = org.eclipse.jdt.internal.compiler.util.Util.scanTypeSignature(descriptor, 1) + 1;
 			int length = descriptor.length - start;
 			char[] signature = new char[length + 1];
 			signature[0] = descriptor[0];
