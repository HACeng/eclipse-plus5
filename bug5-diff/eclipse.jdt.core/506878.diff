commit 04ca4c9cd4a2f15abd74d1eb904bcd80b765934d
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Nov 24 21:31:31 2016 +0530

    Bug 506878 - [9] Provide means to support automatic modules

106	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
295	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
0	52	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BinaryModule.java
3	4	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
7	19	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
7	12	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
12	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
2	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
10	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
6	6	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
73	68	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
0	286	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/SourceModule.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
0	46	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
11	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
0	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IMultiModuleEntry.java
19	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
51	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
110	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfModule.java
16	2	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
9	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
14	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
5	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
228	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
14	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
22	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
6	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
27	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
0	40	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/Module.java
29	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
8	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
0	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
6	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 437567f..d49d639 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -19,6 +19,7 @@ import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.util.Util;
 
 import junit.framework.Test;
@@ -26,7 +27,7 @@ import junit.framework.Test;
 public class ModuleCompilationTests extends BatchCompilerTest {
 
 	static {
-//		 TESTS_NAMES = new String[] { "test022" };
+//		 TESTS_NAMES = new String[] { "test034" };
 		// TESTS_NUMBERS = new int[] { 1 };
 		// TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -1407,4 +1408,108 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			"",
 			false);
 	}
+	/**
+	 * Test that a module can't access types/packages in a plain Jar put in classpath
+	 */
+	public void test033() {
+		File libDir = new File(LIB_DIR);
+		Util.delete(libDir); // make sure we recycle the libs
+ 		libDir.mkdirs();
+		try {
+			Util.createJar(
+				new String[] {
+					"a/A.java",
+					"package a;\n" +
+					"public class A {\n" +
+					"}"
+				},
+				LIB_DIR + "/lib1.jar",
+				JavaCore.VERSION_9);
+		} catch (IOException e) {
+			// ignore
+		}
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X extends a.A {\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append(LIB_DIR).append(File.separator).append("lib1.jar").append(File.pathSeparator).append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"");
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/X.java (at line 2)\n" + 
+				"	public class X extends a.A {\n" + 
+				"	                       ^\n" + 
+				"a cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
+	/**
+	 * Test that a module can access types/packages in a plain Jar put in modulepath,
+	 * this upgrading it to an automatic module
+	 */
+	public void test034() {
+		File libDir = new File(LIB_DIR);
+		Util.delete(libDir); // make sure we recycle the libs
+ 		libDir.mkdirs();
+		try {
+			Util.createJar(
+				new String[] {
+					"a/A.java",
+					"package a;\n" +
+					"public class A {\n" +
+					"}"
+				},
+				LIB_DIR + "/lib1.jar",
+				JavaCore.VERSION_9);
+		} catch (IOException e) {
+			// ignore
+		}
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X extends a.A {\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString()).append("\" ")
+			.append("-mp \"")
+			.append(LIB_DIR).append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"");
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
new file mode 100644
index 0000000..54708ce
--- /dev/null
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
@@ -0,0 +1,295 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.batch;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ExportReference;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
+
+public class BasicModule implements IModule {
+	static class ModuleReferenceImpl implements IModule.IModuleReference {
+		char[] name;
+		boolean isPublic = false;
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+		@Override
+		public boolean isPublic() {
+			return this.isPublic;
+		}
+		public boolean equals(Object o) {
+			if (this == o) 
+				return true;
+			if (!(o instanceof IModule.IModuleReference))
+				return false;
+			IModule.IModuleReference mod = (IModule.IModuleReference) o;
+			if (this.isPublic != mod.isPublic())
+				return false;
+			return CharOperation.equals(this.name, mod.name());
+		}
+		@Override
+		public int hashCode() {
+			return this.name.hashCode();
+		}
+	}
+	static class PackageExport implements IModule.IPackageExport {
+		char[] pack;
+		char[][] exportedTo;
+		@Override
+		public char[] name() {
+			return this.pack;
+		}
+
+		@Override
+		public char[][] exportedTo() {
+			return this.exportedTo;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append(this.pack);
+			if (this.exportedTo != null) {
+				for (char[] cs : this.exportedTo) {
+					buffer.append(cs);
+				}
+			}
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+	static class Service implements IModule.IService {
+		char[] provides;
+		char[] with;
+		@Override
+		public char[] name() {
+			return this.provides;
+		}
+
+		@Override
+		public char[] with() {
+			return this.with;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append("provides"); //$NON-NLS-1$
+			buffer.append(this.provides);
+			buffer.append(" with "); //$NON-NLS-1$
+			buffer.append(this.with);
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+	private static PackageExport createPackageExport(ExportReference[] refs, int i) {
+		ExportReference ref = refs[i];
+		PackageExport exp = new PackageExport();
+		exp.pack = CharOperation.concatWith(ref.tokens, '.');
+		ModuleReference[] imp = ref.targets;
+		if (imp != null) {
+			exp.exportedTo = new char[imp.length][];
+			for(int j = 0; j < imp.length; j++) {
+				exp.exportedTo = imp[j].tokens;
+			}
+		}
+		return exp;
+	}
+	private static Service createService(TypeReference service, TypeReference with) {
+		Service ser = new Service();
+		ser.provides = CharOperation.concatWith(service.getTypeName(), '.');
+		ser.with = CharOperation.concatWith(with.getTypeName(), '.');
+		return ser;
+	}
+
+	boolean isAutomodule;
+	char[] name;
+	IModule.IModuleReference[] requires;
+	IModule.IPackageExport[] exports;
+	char[][] uses;
+	Service[] provides;
+	IModulePathEntry root;
+	public BasicModule(ModuleDeclaration descriptor, IModulePathEntry root) {
+		this.name = descriptor.moduleName;
+		this.root = root;
+		if (descriptor.requiresCount > 0) {
+			ModuleReference[] refs = descriptor.requires;
+			this.requires = new ModuleReferenceImpl[refs.length];
+			for (int i = 0; i < refs.length; i++) {
+				ModuleReferenceImpl ref = new ModuleReferenceImpl();
+				ref.name = CharOperation.concatWith(refs[i].tokens, '.');
+				ref.isPublic = refs[i].isPublic();
+				this.requires[i] = ref;
+			}
+		} else {
+			this.requires = new ModuleReferenceImpl[0];
+		}
+		if (descriptor.exportsCount > 0) {
+			ExportReference[] refs = descriptor.exports;
+			this.exports = new PackageExport[refs.length];
+			for (int i = 0; i < refs.length; i++) {
+				PackageExport exp = createPackageExport(refs, i);
+				this.exports[i] = exp;
+			}
+		} else {
+			this.exports = new PackageExport[0];
+		}
+		if (descriptor.usesCount > 0) {
+			TypeReference[] u = descriptor.uses;
+			this.uses = new char[u.length][];
+			for(int i = 0; i < u.length; i++) {
+				this.uses[i] = CharOperation.concatWith(u[i].getTypeName(), '.');
+			}
+		}
+		if (descriptor.servicesCount > 0) {
+			TypeReference[] services = descriptor.interfaces;
+			TypeReference[] with = descriptor.implementations;
+			this.provides = new Service[descriptor.servicesCount];
+			for (int i = 0; i < descriptor.servicesCount; i++) {
+				this.provides[i] = createService(services[i], with[i]);
+			}
+		}
+		this.isAutomodule = false; // Just to be explicit
+	}
+	public BasicModule(char[] name, Classpath root, boolean isAuto) {
+		this.name = name;
+		this.root = root;
+		this.exports = IModule.NO_EXPORTS;
+		this.requires = IModule.NO_MODULE_REFS;
+		this.isAutomodule = isAuto;
+	}
+	@Override
+	public char[] name() {
+		return this.name;
+	}
+	@Override
+	public IModule.IModuleReference[] requires() {
+		return this.requires;
+	}
+	@Override
+	public IModule.IPackageExport[] exports() {
+		return this.exports;
+	}
+	@Override
+	public char[][] uses() {
+		return this.uses;
+	}
+	@Override
+	public IService[] provides() {
+		return this.provides();
+	}
+	@Override
+	public boolean isAutomatic() {
+		return this.isAutomodule;
+	}
+	public void addReads(char[] modName) {
+		Predicate<char[]> shouldAdd = m -> {
+			return Stream.of(this.requires).map(ref -> ref.name()).noneMatch(n -> CharOperation.equals(modName, n));
+		};
+		if (shouldAdd.test(modName)) {
+			int len = this.requires.length;
+			this.requires = Arrays.copyOf(this.requires, len + 1);
+			ModuleReferenceImpl info = new ModuleReferenceImpl();
+			info.name = modName;
+			this.requires[len] = info;
+		}		
+	}
+	public void addExports(IModule.IPackageExport[] toAdd) {
+		Predicate<char[]> shouldAdd = m -> {
+			return Stream.of(this.exports).map(ref -> ((PackageExport) ref).pack).noneMatch(n -> CharOperation.equals(m, n));
+		};
+		Collection<IPackageExport> merged = Stream.concat(Stream.of(this.exports), Stream.of(toAdd)
+				.filter(e -> shouldAdd.test(e.name()))
+				.map(e -> {
+					PackageExport exp = new PackageExport();
+					exp.pack = ((PackageExport )e).name();
+					exp.exportedTo = ((PackageExport )e).exportedTo();
+					return exp;
+				}))
+			.collect(
+				ArrayList::new,
+				ArrayList::add,
+				ArrayList::addAll);
+		this.exports = merged.toArray(new PackageExport[merged.size()]);
+	}
+	public boolean equals(Object o) {
+		if (this == o)
+			return true;
+		if (!(o instanceof IModule))
+			return false;
+		IModule mod = (IModule) o;
+		if (!CharOperation.equals(this.name, mod.name()))
+			return false;
+		return Arrays.equals(this.requires, mod.requires());
+	}
+	@Override
+	public int hashCode() {
+		int result = 17;
+		int c = this.name.hashCode();
+		result = 31 * result + c;
+		c =  Arrays.hashCode(this.requires);
+		result = 31 * result + c;
+		return result;
+	}
+	public String toString() {
+		StringBuffer buffer = new StringBuffer(getClass().getName());
+		toStringContent(buffer);
+		return buffer.toString();
+	}
+	protected void toStringContent(StringBuffer buffer) {
+		buffer.append("\nmodule "); //$NON-NLS-1$
+		buffer.append(this.name).append(' ');
+		buffer.append('{').append('\n');
+		if (this.requires != null) {
+			for(int i = 0; i < this.requires.length; i++) {
+				buffer.append("\trequires "); //$NON-NLS-1$
+				if (this.requires[i].isPublic()) {
+					buffer.append(" public "); //$NON-NLS-1$
+				}
+				buffer.append(this.requires[i].name());
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.exports != null) {
+			buffer.append('\n');
+			for(int i = 0; i < this.exports.length; i++) {
+				buffer.append("\texports "); //$NON-NLS-1$
+				buffer.append(this.exports[i].toString());
+			}
+		}
+		if (this.uses != null) {
+			buffer.append('\n');
+			for (char[] cs : this.uses) {
+				buffer.append(cs);
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.provides != null) {
+			buffer.append('\n');
+			for(Service ser : this.provides) {
+				buffer.append(ser.toString());
+			}
+		}
+		buffer.append('\n').append('}').toString();
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BinaryModule.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BinaryModule.java
deleted file mode 100644
index b6a27f5..0000000
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BinaryModule.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.batch;
-
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
-import org.eclipse.jdt.internal.compiler.env.IModule;
-
-public class BinaryModule implements IModule {
-
-	public IModule declaration;
-	public BinaryModule(ClassFileReader moduleInfoClass) {
-		this.declaration = moduleInfoClass.getModuleDeclaration();
-	}
-	@Override
-	public char[] name() {
-		//
-		return this.declaration.name();
-	}
-
-	@Override
-	public IModuleReference[] requires() {
-		return this.declaration.requires();
-	}
-	@Override
-	public IPackageExport[] exports() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	@Override
-	public char[][] uses() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	@Override
-	public IService[] provides() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index 912013a..89daa4a 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -56,7 +56,6 @@ private int mode; // ability to only consider one kind of files (source vs. bina
 private String encoding; // only useful if referenced in the source path
 private Hashtable<String, Hashtable<String, String>> packageSecondaryTypes = null;
 Map options;
-private IModule module;
 
 ClasspathDirectory(File directory, String encoding, int mode,
 		AccessRuleSet accessRuleSet, String destinationPath, Map options) {
@@ -74,9 +73,6 @@ ClasspathDirectory(File directory, String encoding, int mode,
 	this.directoryCache = new Hashtable(11);
 	this.encoding = encoding;
 }
-public void acceptModule(IModule mod) {
-	this.module = mod;
-}
 String[] directoryList(String qualifiedPackageName) {
 	String[] dirList = (String[]) this.directoryCache.get(qualifiedPackageName);
 	if (dirList == this.missingPackageHolder) return null; // package exists in another classpath directory or jar
@@ -309,6 +305,9 @@ public int getMode() {
 	return this.mode;
 }
 public IModule getModule() {
+	if (this.isAutoModule && this.module == null) {
+		return this.module = new BasicModule(this.path.toCharArray(), this, true);
+	}
 	return this.module;
 }
 @Override
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index e56f94e..74905b2 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -37,7 +37,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
@@ -56,7 +55,6 @@ protected ZipFile annotationZipFile;
 protected boolean closeZipFileAtEnd;
 private Set<String> packageCache;
 protected List<String> annotationPaths;
-protected IModule module;
 
 public ClasspathJar(File file, boolean closeZipFileAtEnd,
 		AccessRuleSet accessRuleSet, String destinationPath) {
@@ -91,7 +89,8 @@ public List fetchLinkedJars(FileSystem.ClasspathSectionProblemReporter problemRe
 				int lastSeparator = directoryPath.lastIndexOf(File.separatorChar);
 				directoryPath = directoryPath.substring(0, lastSeparator + 1); // potentially empty (see bug 214731)
 				while (calledFilesIterator.hasNext()) {
-					result.add(new ClasspathJar(new File(directoryPath + (String) calledFilesIterator.next()), this.closeZipFileAtEnd, this.accessRuleSet, this.destinationPath));
+						result.add(new ClasspathJar(new File(directoryPath + (String) calledFilesIterator.next()),
+								this.closeZipFileAtEnd, this.accessRuleSet, this.destinationPath));
 				}
 			}
 		}
@@ -199,12 +198,9 @@ public void initialize() throws IOException {
 		this.zipFile = new ZipFile(this.file);
 	}
 }
-public void acceptModule(IModule mod) {
-	this.module = mod;
-}
 void acceptModule(ClassFileReader reader) {
 	if (reader != null) {
-		this.module = reader.getModuleDeclaration();
+		acceptModule(reader.getModuleDeclaration());
 	}
 }
 void acceptModule(byte[] content) {
@@ -212,7 +208,7 @@ void acceptModule(byte[] content) {
 		return;
 	ClassFileReader reader = null;
 	try {
-		reader = new ClassFileReader(content, IModuleLocation.MODULE_INFO_CLASS.toCharArray(), null);
+		reader = new ClassFileReader(content, IModuleEnvironment.MODULE_INFO_CLASS.toCharArray(), null);
 	} catch (ClassFormatException e) {
 		e.printStackTrace();
 	}
@@ -298,19 +294,11 @@ public int getMode() {
 }
 
 public IModule getModule() {
+	if (this.isAutoModule && this.module == null) {
+		return this.module = new BasicModule(this.file.getName().toCharArray(), this, true);
+	}
 	return this.module;
 }
-//@Override
-//public boolean servesModule(IModule mod) {
-//	if (!this.isJrt) {
-//		return super.servesModule(mod);
-//	}
-//	if (mod == null) 
-//		return false;
-//	if (mod == ModuleEnvironment.UNNAMED_MODULE)
-//		return true;
-//	return ModulesCache.containsKey(new String(mod.name()));
-//}
 @Override
 public ITypeLookup typeLookup() {
 	return this::findClass;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
index b9d2b63..b841a9a 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
@@ -37,7 +37,6 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.env.IMultiModuleEntry;
 import org.eclipse.jdt.internal.compiler.env.IMultiModulePackageLookup;
 import org.eclipse.jdt.internal.compiler.env.IMultiModuleTypeLookup;
@@ -81,8 +80,8 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 	public List fetchLinkedJars(FileSystem.ClasspathSectionProblemReporter problemReporter) {
 		return null;
 	}
-	public boolean isPackage(String qualifiedPackageName, Optional<char[]> module) {
-		return JRTUtil.isPackage(this.file, qualifiedPackageName, module);
+	public boolean isPackage(String qualifiedPackageName, Optional<char[]> mod) {
+		return JRTUtil.isPackage(this.file, qualifiedPackageName, mod);
 	}
 	public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String qualifiedBinaryFileName) {
 		return findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName, false, Optional.empty());
@@ -221,7 +220,7 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 					@Override
 					public FileVisitResult visitModule(Path mod) throws IOException {
 						try {
-							ClasspathJrt.this.acceptModule(JRTUtil.getClassfileContent(ClasspathJrt.this.file, IModuleLocation.MODULE_INFO_CLASS, mod.toString()));
+							ClasspathJrt.this.acceptModule(JRTUtil.getClassfileContent(ClasspathJrt.this.file, IModuleEnvironment.MODULE_INFO_CLASS, mod.toString()));
 						} catch (ClassFormatException e) {
 							e.printStackTrace();
 						}
@@ -251,7 +250,7 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 			return;
 		ClassFileReader reader = null;
 		try {
-			reader = new ClassFileReader(content, IModuleLocation.MODULE_INFO_CLASS.toCharArray(), null);
+			reader = new ClassFileReader(content, IModuleEnvironment.MODULE_INFO_CLASS.toCharArray(), null);
 		} catch (ClassFormatException e) {
 			e.printStackTrace();
 		}
@@ -378,26 +377,22 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 		return ModulesCache.containsKey(new String(mod));
 	}
 
-	@Override
-	public void acceptModule(IModule module) {
-		// do nothing
-	}
 
 	@Override
-	public IModuleEnvironment getLookupEnvironmentFor(IModule module) {
+	public IModuleEnvironment getLookupEnvironmentFor(IModule mod) {
 		// 
 		return new IModuleEnvironment() {
 			
 			@Override
 			public ITypeLookup typeLookup() {
 				//
-				return servesModule(module.name()) ? typeLookupForModule(module.name()) : ITypeLookup.Dummy;
+				return servesModule(mod.name()) ? typeLookupForModule(mod.name()) : ITypeLookup.Dummy;
 			}
 			
 			@Override
 			public IPackageLookup packageLookup() {
 				//
-				return servesModule(module.name()) ? pkgLookupForModule(module.name()) : IPackageLookup.Dummy;
+				return servesModule(mod.name()) ? pkgLookupForModule(mod.name()) : IPackageLookup.Dummy;
 			}
 		};
 	}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
index 4fd907d..e381857 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
@@ -19,6 +19,7 @@ import java.io.File;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 
 public abstract class ClasspathLocation implements FileSystem.Classpath,
@@ -30,6 +31,8 @@ public abstract class ClasspathLocation implements FileSystem.Classpath,
 	String path;
 	char[] normalizedPath;
 	public AccessRuleSet accessRuleSet;
+	IModule module;
+	protected boolean isAutoModule;
 
 	public String destinationPath;
 		// destination path for compilation units that are reached through this
@@ -107,4 +110,13 @@ public abstract class ClasspathLocation implements FileSystem.Classpath,
 	public String getDestinationPath() {
 		return this.destinationPath;
 	}
+	
+	public void acceptModule(IModule mod) {
+		this.module = mod;
+		this.isAutoModule = mod.isAutomatic();
+	}
+	@Override
+	public boolean isAutomaticModule() {
+		return this.isAutoModule;
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
index d561cb1..efefe89 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
@@ -18,7 +18,7 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 
 public class FileFinder {
 
@@ -48,7 +48,7 @@ private static void find0(File f, String pattern, List<String> collector) {
 				if (name.endsWith(pattern)) {
 					// NOTE: This handles only the lower case name. Check with the spec about
 					// Naming of the module descriptor before making this code code insensitive.
-					if (name.endsWith(IModuleLocation.MODULE_INFO_JAVA)) {
+					if (name.endsWith(IModuleEnvironment.MODULE_INFO_JAVA)) {
 						collector.add(0, current.getAbsolutePath());
 					} else {
 						collector.add(current.getAbsolutePath());
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index 1cca9a5..cb470d7 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -508,4 +508,14 @@ private NameEnvironmentAnswer internalFindClass(String qualifiedTypeName, char[]
 				.map(lookup -> lookup.findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName, asBinaryOnly))
 				.orElse(null);
 }
+@Override
+public IModule[] getAllAutomaticModules() {
+	Set<IModule> set = new HashSet<>();
+	for (int i = 0, l = this.classpaths.length; i < l; i++) {
+		if (this.classpaths[i].isAutomaticModule()) {
+			set.add(this.classpaths[i].getModule());
+		}
+	}
+	return set.toArray(new IModule[set.size()]);
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 0ab0035..d9c6890 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -90,7 +90,7 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.CompilerStats;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
@@ -3005,15 +3005,15 @@ private Parser getNewParser() {
 }
 private IModule extractModuleDesc(String fileName, Parser parser) {
 	IModule mod = null;
-	if (fileName.toLowerCase().endsWith(IModuleLocation.MODULE_INFO_JAVA)) {
+	if (fileName.toLowerCase().endsWith(IModuleEnvironment.MODULE_INFO_JAVA)) {
 		
 		ICompilationUnit cu = new CompilationUnit(null, fileName, null);
 		CompilationResult compilationResult = new CompilationResult(cu, 0, 1, 10);
 		CompilationUnitDeclaration unit = parser.parse(cu, compilationResult);
 		if (unit.isModuleInfo() && unit.moduleDeclaration != null) {
-			mod = new SourceModule(unit.moduleDeclaration, null);
+			mod = new BasicModule(unit.moduleDeclaration, null);
 		}
-	} else if (fileName.toLowerCase().endsWith(IModuleLocation.MODULE_INFO_CLASS)) {
+	} else if (fileName.toLowerCase().endsWith(IModuleEnvironment.MODULE_INFO_CLASS)) {
 		try {
 			ClassFileReader reader = ClassFileReader.read(fileName); // Check the absolute path?
 			mod = reader.getModuleDeclaration();
@@ -3329,7 +3329,7 @@ protected ArrayList handleModulepath(String arg) {
 			File dir = new File(paths[i]);
 			if (dir.isDirectory()) {
 			modulePaths =
-					(ArrayList) ModuleFinder.findModules(dir, null, getNewParser(), this.options, false);
+					(ArrayList) ModuleFinder.findModules(dir, null, getNewParser(), this.options, true);
 			}
 		}
 	}
@@ -3361,7 +3361,7 @@ protected ArrayList handleModuleSourcepath(String arg) {
 				// 2. Iterator each module in case of directory for source files and add to this.fileNames
 
 				modulePaths =
-						(ArrayList) ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, true);
+						(ArrayList) ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, false);
 				for (Object obj : modulePaths) {
 					Classpath classpath = (Classpath) obj;
 					File modLocation = new File(classpath.getPath());
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
index 44e89f7..311b9a9 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -26,19 +26,19 @@ import java.util.zip.ZipFile;
 
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.batch.BasicModule.PackageExport;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ModuleFinder {
 
-	protected static List<FileSystem.Classpath> findModules(File f, String destinationPath, Parser parser, Map<String, String> options, boolean sourceOnly) {
+	protected static List<FileSystem.Classpath> findModules(File f, String destinationPath, Parser parser, Map<String, String> options, boolean isModulepath) {
 		List<FileSystem.Classpath> collector = new ArrayList<>();
 		if (f.isDirectory()) {
 			File[] files = f.listFiles();
@@ -48,7 +48,7 @@ public class ModuleFinder {
 				FileSystem.Classpath modulePath = FileSystem.getClasspath(
 						file.getAbsolutePath(),
 						null,
-						sourceOnly,
+						!isModulepath,
 						null,
 						destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
 						options);
@@ -59,8 +59,8 @@ public class ModuleFinder {
 						String[] list = file.list(new FilenameFilter() {
 							@Override
 							public boolean accept(File dir, String name) {
-								if (dir == file && (name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_CLASS)
-										|| name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_JAVA))) {
+								if (dir == file && (name.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_CLASS)
+										|| name.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_JAVA))) {
 									return true;
 								}
 								return false;
@@ -69,10 +69,10 @@ public class ModuleFinder {
 						if (list.length > 0) {
 							String fileName = list[0];
 							switch (fileName) {
-								case IModuleLocation.MODULE_INFO_CLASS:
+								case IModuleEnvironment.MODULE_INFO_CLASS:
 									module = ModuleFinder.extractModuleFromClass(new File(file, fileName), modulePath);
 									break;
-								case IModuleLocation.MODULE_INFO_JAVA:
+								case IModuleEnvironment.MODULE_INFO_JAVA:
 									module = ModuleFinder.extractModuleFromSource(new File(file, fileName), parser, modulePath);
 									break;
 							}
@@ -80,20 +80,13 @@ public class ModuleFinder {
 					} else if (isJar(file)) {
 						module = extractModuleFromJar(file, modulePath);
 					}
+					if (isModulepath && module == null) {
+						 // The name includes the file's extension, but it shouldn't matter.
+						module = new BasicModule(file.getName().toCharArray(), modulePath, true);
+					}
 					if (module != null)
 						modulePath.acceptModule(module);
 				}
-//				FileSystem.Classpath modulePath = FileSystem.getClasspath(
-//						file.getAbsolutePath(),
-//						null,
-//						sourceOnly,
-//						null,
-//						destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
-//						options);
-//				if (modulePath != null)
-//					collector.add(modulePath);
-//				if (module != null)
-//					modulePath.acceptModule(module);
 			}
 		}
 		return collector;
@@ -155,58 +148,70 @@ public class ModuleFinder {
 		while (tokenizer.hasMoreTokens()) {
 			targets.add(tokenizer.nextToken("=,")); //$NON-NLS-1$
 		}
-		PackageExport export = new PackageExport(pack.toCharArray());
+		BasicModule.PackageExport export = new PackageExport();
+		export.pack = pack.toCharArray();
 		export.exportedTo = new char[targets.size()][];
 		for(int i = 0; i < export.exportedTo.length; i++) {
 			export.exportedTo[i] = targets.get(i).toCharArray();
 		}
-		return new Module(source.toCharArray(), export);
-	}
-
-	static class PackageExport implements IPackageExport {
-		char[] name;
-		char[][] exportedTo;
-		PackageExport(char[] name) {
-			this.name = name;
-		}
-		@Override
-		public char[] name() {
-			return this.name;
-		}
-		@Override
-		public char[][] exportedTo() {
-			return this.exportedTo;
-		}
-	}
-	
-	static class Module implements IModule {
-		char[] name;
-		IPackageExport[] export;
-		Module(char[] name, IPackageExport export) {
-			this.name = name;
-			this.export = new IPackageExport[]{export};
-		}
-		@Override
-		public char[] name() {
-			return this.name;
-		}
-		@Override
-		public IModuleReference[] requires() {
-			return null;
-		}
-		@Override
-		public IPackageExport[] exports() {
-			return this.export;
-		}
-		@Override
-		public char[][] uses() {
-			return null;
-		}
-		@Override
-		public IService[] provides() {
-			return null;
-		}
+		BasicModule module = new BasicModule(source.toCharArray(), null, false);
+		module.exports = new IModule.IPackageExport[]{export};
+		return module;
 	}
+//
+//	static class PackageExport implements IPackageExport {
+//		char[] name;
+//		char[][] exportedTo;
+//		PackageExport(char[] name) {
+//			this.name = name;
+//		}
+//		@Override
+//		public char[] name() {
+//			return this.name;
+//		}
+//		@Override
+//		public char[][] exportedTo() {
+//			return this.exportedTo;
+//		}
+//	}
+//	
+//	static class Module implements IModule {
+//		char[] name;
+//		IPackageExport[] export;
+//		boolean isAuto;
+//		Module(char[] name, IPackageExport export, boolean isAuto) {
+//			this.name = name;
+//			this.export = new IPackageExport[]{export};
+//			this.isAuto = isAuto;
+//		}
+//		@Override
+//		public char[] name() {
+//			return this.name;
+//		}
+//		@Override
+//		public IModuleReference[] requires() {
+//			return null;
+//		}
+//		@Override
+//		public IPackageExport[] exports() {
+//			return this.export;
+//		}
+//		@Override
+//		public char[][] uses() {
+//			return null;
+//		}
+//		@Override
+//		public IService[] provides() {
+//			return null;
+//		}
+//		@Override
+//		public void setAutomatic(boolean isAuto) {
+//			this.isAuto = isAuto;
+//		}
+//		public boolean isAutomatic() {
+//			return this.isAuto;
+//		}
+//	}
 	
 	private static boolean isJar(File file) {
 		int format = Util.archiveFormat(file.getAbsolutePath());
@@ -216,7 +221,7 @@ public class ModuleFinder {
 		ZipFile zipFile = null;
 		try {
 			zipFile = new ZipFile(file);
-			ClassFileReader reader = ClassFileReader.read(zipFile, IModuleLocation.MODULE_INFO_CLASS);
+			ClassFileReader reader = ClassFileReader.read(zipFile, IModuleEnvironment.MODULE_INFO_CLASS);
 			IModule module = getModule(reader);
 			if (module != null) {
 				return reader.getModuleDeclaration();
@@ -260,7 +265,7 @@ public class ModuleFinder {
 		CompilationResult compilationResult = new CompilationResult(cu, 0, 1, 10);
 		CompilationUnitDeclaration unit = parser.parse(cu, compilationResult);
 		if (unit.isModuleInfo() && unit.moduleDeclaration != null) {
-			return new SourceModule(unit.moduleDeclaration, pathEntry);
+			return new BasicModule(unit.moduleDeclaration, pathEntry);
 		}
 		return null;
 	}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/SourceModule.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/SourceModule.java
deleted file mode 100644
index d6c332b..0000000
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/SourceModule.java
+++ /dev/null
@@ -1,286 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.batch;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.ExportReference;
-import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
-import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
-import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
-
-public class SourceModule implements IModule {
-	static class ModuleReferenceImpl implements IModule.IModuleReference {
-		char[] name;
-		boolean isPublic = false;
-		@Override
-		public char[] name() {
-			return this.name;
-		}
-		@Override
-		public boolean isPublic() {
-			return this.isPublic;
-		}
-		public boolean equals(Object o) {
-			if (this == o) 
-				return true;
-			if (!(o instanceof IModule.IModuleReference))
-				return false;
-			IModule.IModuleReference mod = (IModule.IModuleReference) o;
-			if (this.isPublic != mod.isPublic())
-				return false;
-			return CharOperation.equals(this.name, mod.name());
-		}
-		@Override
-		public int hashCode() {
-			return this.name.hashCode();
-		}
-	}
-	static class PackageExport implements IModule.IPackageExport {
-		char[] pack;
-		char[][] exportedTo;
-		@Override
-		public char[] name() {
-			return this.pack;
-		}
-
-		@Override
-		public char[][] exportedTo() {
-			return this.exportedTo;
-		}
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append(this.pack);
-			if (this.exportedTo != null) {
-				for (char[] cs : this.exportedTo) {
-					buffer.append(cs);
-				}
-			}
-			buffer.append(';');
-			return buffer.toString();
-		}
-	}
-	static class Service implements IModule.IService {
-		char[] provides;
-		char[] with;
-		@Override
-		public char[] name() {
-			return this.provides;
-		}
-
-		@Override
-		public char[] with() {
-			return this.with;
-		}
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append("provides"); //$NON-NLS-1$
-			buffer.append(this.provides);
-			buffer.append(" with "); //$NON-NLS-1$
-			buffer.append(this.with);
-			buffer.append(';');
-			return buffer.toString();
-		}
-	}
-	private static PackageExport createPackageExport(ExportReference[] refs, int i) {
-		ExportReference ref = refs[i];
-		PackageExport exp = new PackageExport();
-		exp.pack = CharOperation.concatWith(ref.tokens, '.');
-		ModuleReference[] imp = ref.targets;
-		if (imp != null) {
-			exp.exportedTo = new char[imp.length][];
-			for(int j = 0; j < imp.length; j++) {
-				exp.exportedTo = imp[j].tokens;
-			}
-		}
-		return exp;
-	}
-	private static Service createService(TypeReference service, TypeReference with) {
-		Service ser = new Service();
-		ser.provides = CharOperation.concatWith(service.getTypeName(), '.');
-		ser.with = CharOperation.concatWith(with.getTypeName(), '.');
-		return ser;
-	}
-
-	char[] name;
-	ModuleReferenceImpl[] requires;
-	PackageExport[] exports;
-	char[][] uses;
-	Service[] provides;
-	IModulePathEntry root;
-
-	public SourceModule(ModuleDeclaration descriptor, Classpath root) {
-		this.name = descriptor.moduleName;
-		this.root = root;
-		if (descriptor.requiresCount > 0) {
-			ModuleReference[] refs = descriptor.requires;
-			this.requires = new ModuleReferenceImpl[refs.length];
-			for (int i = 0; i < refs.length; i++) {
-				this.requires[i] = new ModuleReferenceImpl();
-				this.requires[i].name = CharOperation.concatWith(refs[i].tokens, '.');
-				this.requires[i].isPublic = refs[i].isPublic();
-			}
-		} else {
-			this.requires = new ModuleReferenceImpl[0];
-		}
-		if (descriptor.exportsCount > 0) {
-			ExportReference[] refs = descriptor.exports;
-			this.exports = new PackageExport[refs.length];
-			for (int i = 0; i < refs.length; i++) {
-				PackageExport exp = createPackageExport(refs, i);
-				this.exports[i] = exp;
-			}
-		} else {
-			this.exports = new PackageExport[0];
-		}
-		if (descriptor.usesCount > 0) {
-			TypeReference[] u = descriptor.uses;
-			this.uses = new char[u.length][];
-			for(int i = 0; i < u.length; i++) {
-				this.uses[i] = CharOperation.concatWith(u[i].getTypeName(), '.');
-			}
-		}
-		if (descriptor.servicesCount > 0) {
-			TypeReference[] services = descriptor.interfaces;
-			TypeReference[] with = descriptor.implementations;
-			this.provides = new Service[descriptor.servicesCount];
-			for (int i = 0; i < descriptor.servicesCount; i++) {
-				this.provides[i] = createService(services[i], with[i]);
-			}
-		}
-		
-	}
-	@Override
-	public char[] name() {
-		return this.name;
-	}
-	@Override
-	public IModule.IModuleReference[] requires() {
-		return this.requires;
-	}
-	@Override
-	public IModule.IPackageExport[] exports() {
-		return this.exports;
-	}
-	@Override
-	public char[][] uses() {
-		return this.uses;
-	}
-	@Override
-	public IService[] provides() {
-		return this.provides();
-	}
-	public void addReads(char[] modName) {
-		Predicate<char[]> shouldAdd = m -> {
-			return Stream.of(this.requires).map(ref -> ref.name()).noneMatch(n -> CharOperation.equals(modName, n));
-		};
-		if (shouldAdd.test(modName)) {
-			int len = this.requires.length;
-			this.requires = Arrays.copyOf(this.requires, len + 1);
-			ModuleReferenceImpl info = this.requires[len] = new ModuleReferenceImpl();
-			info.name = modName;
-		}		
-	}
-	public void addExports(IModule.IPackageExport[] toAdd) {
-		Predicate<char[]> shouldAdd = m -> {
-			return Stream.of(this.exports).map(ref -> ref.pack).noneMatch(n -> CharOperation.equals(m, n));
-		};
-		Collection<PackageExport> merged = Stream.concat(Stream.of(this.exports), Stream.of(toAdd)
-				.filter(e -> shouldAdd.test(e.name()))
-				.map(e -> {
-					PackageExport exp = new PackageExport();
-					exp.pack = e.name();
-					exp.exportedTo = e.exportedTo();
-					return exp;
-				}))
-			.collect(
-				ArrayList::new,
-				ArrayList::add,
-				ArrayList::addAll);
-		this.exports = merged.toArray(new PackageExport[merged.size()]);
-	}
-	public IModuleEnvironment getLookupEnvironment() {
-		return this.root == null ? null : this.root.getLookupEnvironmentFor(this);
-	}
-	public boolean equals(Object o) {
-		if (this == o)
-			return true;
-		if (!(o instanceof IModule))
-			return false;
-		IModule mod = (IModule) o;
-		if (!CharOperation.equals(this.name, mod.name()))
-			return false;
-		return Arrays.equals(this.requires, mod.requires());
-	}
-	@Override
-	public int hashCode() {
-		int result = 17;
-		int c = this.name.hashCode();
-		result = 31 * result + c;
-		c =  Arrays.hashCode(this.requires);
-		result = 31 * result + c;
-		return result;
-	}
-	public String toString() {
-		StringBuffer buffer = new StringBuffer(getClass().getName());
-		toStringContent(buffer);
-		return buffer.toString();
-	}
-	protected void toStringContent(StringBuffer buffer) {
-		buffer.append("\nmodule "); //$NON-NLS-1$
-		buffer.append(this.name).append(' ');
-		buffer.append('{').append('\n');
-		if (this.requires != null) {
-			for(int i = 0; i < this.requires.length; i++) {
-				buffer.append("\trequires "); //$NON-NLS-1$
-				if (this.requires[i].isPublic) {
-					buffer.append(" public "); //$NON-NLS-1$
-				}
-				buffer.append(this.requires[i].name);
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.exports != null) {
-			buffer.append('\n');
-			for(int i = 0; i < this.exports.length; i++) {
-				buffer.append("\texports "); //$NON-NLS-1$
-				buffer.append(this.exports[i].toString());
-			}
-		}
-		if (this.uses != null) {
-			buffer.append('\n');
-			for (char[] cs : this.uses) {
-				buffer.append(cs);
-				buffer.append(';').append('\n');
-			}
-		}
-		if (this.provides != null) {
-			buffer.append('\n');
-			for(Service ser : this.provides) {
-				buffer.append(ser.toString());
-			}
-		}
-		buffer.append('\n').append('}').toString();
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
index ba08592..3214c17 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
@@ -15,6 +15,11 @@
 package org.eclipse.jdt.internal.compiler.env;
 
 public interface IModule {
+
+	public static IModuleReference[] NO_MODULE_REFS = new IModuleReference[0];
+	public static IPackageExport[] NO_EXPORTS = new IPackageExport[0];
+	public static IModule[] NO_MODULES = new IModule[0];
+
 	public char[] name();
 
 	public IModuleReference[] requires();
@@ -47,4 +52,8 @@ public interface IModule {
 	public default void addExports(IPackageExport[] exports) {
 		// do nothing, would throwing an exception be better?
 	}
+
+	public default boolean isAutomatic() {
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
index 137c8ac..56e5bd3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
@@ -34,4 +34,5 @@ public interface IModuleAwareNameEnvironment extends INameEnvironment {
 	boolean isPackage(char[][] parentPackageName, char[] packageName, IModuleContext moduleContext);
 	IModule getModule(char[] moduleName);
 	IModuleEnvironment getModuleEnvironmentFor(char[] moduleName);
+	IModule[] getAllAutomaticModules();
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
index b210a55..8fb006c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
@@ -23,6 +23,9 @@ package org.eclipse.jdt.internal.compiler.env;
  * @see IModulePathEntry#getLookupEnvironmentFor(IModule)
  */
 public interface IModuleEnvironment {
+	String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
+	String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
+
 	/**
 	 * A way to lookup types in a module
 	 * 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
deleted file mode 100644
index c0b5dba..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.env;
-
-/**
- * Represents a location within the INameEnvironment that may contain a module. A module
- * location could contain a module either in the form of module-info.java or module-info.class.
- */
-public interface IModuleLocation {
-
-	public static final String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
-	public static final String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
-
-	/**
-	 * Find class with the given type name and qualified package name from the given module. Clients can also use
-	 * servesModule() before invoking this for performance implications.
-	 *
-	 * @param typeName
-	 * @param qualifiedPackageName
-	 * @param qualifiedBinaryFileName
-	 * @param mod
-	 * @return a NameEnvironmentAnswer
-	 */
-	public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName, IModule mod);
-	public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName, boolean asBinaryOnly, IModule mod);
-	public boolean isPackage(String qualifiedPackageName);
-	public IModule getModule(char[] moduleName);
-	/**
-	 * Tells the client whether or not this module location serves the given module.
-	 * @param module
-	 * @return whether the given module is found in this module location.
-	 */
-	public boolean servesModule(IModule module);
-}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
index ff894f1..1e9372f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
@@ -29,7 +29,9 @@ public interface IModulePathEntry {
 	 * 
 	 * @return The module that this entry contributes or null
 	 */
-	IModule getModule();
+	default IModule getModule() {
+		return null;
+	}
 	
 	/**
 	 * Get the module named name from this entry. May be null
@@ -70,4 +72,12 @@ public interface IModulePathEntry {
 	 * does not know any such module
 	 */
 	IModuleEnvironment getLookupEnvironmentFor(IModule module);
+	/**
+	 * Specifies whether this entry represents an automatic module.
+	 * 
+	 * @return true if this is an automatic module, false otherwise
+	 */
+	public default boolean isAutomaticModule() {
+		return false;
+	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IMultiModuleEntry.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IMultiModuleEntry.java
index 260f1f8..7c6d5ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IMultiModuleEntry.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IMultiModuleEntry.java
@@ -21,9 +21,6 @@ package org.eclipse.jdt.internal.compiler.env;
  */
 public interface IMultiModuleEntry extends IModulePathEntry {
 
-	default IModule getModule() {
-		return null;
-	}
 	/**
 	 * Get the module named name that this entry contributes to the module path 
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index fe421b7..b68de6d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -58,7 +58,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
-import org.eclipse.jdt.internal.compiler.util.HashtableOfObject;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfModule;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfPackage;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
@@ -97,7 +97,8 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	private SimpleLookupTable uniqueGetClassMethodBinding; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=300734
 
 	// key is a string with the module name value is a module binding
-	private HashtableOfObject knownModules;
+	HashtableOfModule knownModules;
+	HashtableOfModule autoModules;
 
 	public CompilationUnitDeclaration unitBeingCompleted = null; // only set while completing units
 	public Object missingClassFileLocation = null; // only set when resolving certain references, to help locating problems
@@ -148,17 +149,27 @@ public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOpt
 	this.classFilePool = ClassFilePool.newInstance();
 	this.typesBeingConnected = new HashSet<>();
 	this.typeSystem = this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.globalOptions.storeAnnotations ? new AnnotatableTypeSystem(this) : new TypeSystem(this);
-	this.knownModules = new HashtableOfObject(5);
+	this.knownModules = new HashtableOfModule(5);
+	this.autoModules = new HashtableOfModule(5);
 	this.UnNamedModule = new ModuleBinding.UnNamedModule(this);
+	initAutomaticModules();
 }
 
 public ReferenceBinding askForType(char[][] compoundName) {
 	return askForType(compoundName, null);
 }
+private void initAutomaticModules() {
+	if (this.nameEnvironment instanceof IModuleAwareNameEnvironment) {
+		IModule[] mods = ((IModuleAwareNameEnvironment) this.nameEnvironment).getAllAutomaticModules();
+		for (IModule iModule : mods) {
+			this.autoModules.put(iModule.name(), new ModuleBinding(iModule, this));
+		}
+	}
+}
 public ModuleBinding getModule(char[] name) {
 	if (name == null || name.length == 0 || CharOperation.equals(name, ModuleEnvironment.UNNAMED))
 		return this.UnNamedModule;
-	ModuleBinding module = (ModuleBinding) this.knownModules.get(name);
+	ModuleBinding module = this.knownModules.get(name);
 	if (module == null) {
 		if (this.nameEnvironment instanceof IModuleAwareNameEnvironment) {
 			IModule mod = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModule(name);
@@ -220,8 +231,10 @@ ReferenceBinding askForType(PackageBinding packageBinding, char[] name, char[] m
 	NameEnvironmentAnswer answer = null;
 	if (this.nameEnvironment instanceof IModuleAwareNameEnvironment) {
 		ModuleBinding module = getModule(mod);
-		if (module != null)
-			answer = ((IModuleAwareNameEnvironment)this.nameEnvironment).findType(name, packageBinding.compoundName, module.getDependencyClosureContext());
+		if (module != null) {
+				answer = ((IModuleAwareNameEnvironment) this.nameEnvironment).findType(name,
+						packageBinding.compoundName, module.getDependencyClosureContext());
+		}
 	} else {
 		answer = this.nameEnvironment.findType(name, packageBinding.compoundName);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index f16f37e..7893773 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -18,6 +18,7 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -26,10 +27,10 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IModuleContext;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModule.IModuleReference;
 import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
-import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfPackage;
 import org.eclipse.jdt.internal.compiler.util.JRTUtil;
@@ -68,19 +69,18 @@ public class ModuleBinding extends Binding {
 	public LookupEnvironment environment;
 	public int tagBits;
 	private ModuleBinding[] requiredModules = null;
+	private boolean isAuto;
 	
 	HashtableOfPackage declaredPackages;
 	HashtableOfPackage exportedPackages;
 
 	public static ModuleBinding[] NO_REQUIRES = new ModuleBinding[0];
-	public static IModuleReference[] NO_MODULE_REFS = new IModuleReference[0];
-	public static IPackageExport[] NO_EXPORTS = new IPackageExport[0];
 
 	ModuleBinding(LookupEnvironment env) {
 		this.moduleName = ModuleEnvironment.UNNAMED;
 		this.environment = env;
-		this.requires = NO_MODULE_REFS;
-		this.exports = NO_EXPORTS;
+		this.requires = IModule.NO_MODULE_REFS;
+		this.exports = IModule.NO_EXPORTS;
 		this.declaredPackages = new HashtableOfPackage(0);
 		this.exportedPackages = new HashtableOfPackage(0);
 	}
@@ -89,16 +89,17 @@ public class ModuleBinding extends Binding {
 		IModule decl = module;
 		this.requires = decl.requires();
 		if (this.requires == null)
-			this.requires = NO_MODULE_REFS;
+			this.requires = IModule.NO_MODULE_REFS;
 		this.exports = decl.exports();
 		if (this.exports == null)
-			this.exports = NO_EXPORTS;
+			this.exports = IModule.NO_EXPORTS;
 		this.environment = environment;
 		this.uses = Binding.NO_TYPES;
 		this.services = Binding.NO_TYPES;
 		this.implementations = Binding.NO_TYPES;
 		this.declaredPackages = new HashtableOfPackage(5);
 		this.exportedPackages = new HashtableOfPackage(5);
+		this.isAuto = module.isAutomatic();
 	}
 
 	private Stream<ModuleBinding> getRequiredModules(boolean implicitOnly) {
@@ -183,6 +184,10 @@ public class ModuleBinding extends Binding {
 		return this.requiredModules = allRequires.size() > 0 ? allRequires.toArray(new ModuleBinding[allRequires.size()]) : NO_REQUIRES;
 	}
 
+	private Stream<ModuleBinding> getAllAutomaticModules() {
+		return Stream.of(this.environment.autoModules.valueTable).filter(m -> m != null);
+	}
+
 	public char[] name() {
 		return this.moduleName;
 	}
@@ -202,6 +207,8 @@ public class ModuleBinding extends Binding {
 	public boolean isPackageExportedTo(PackageBinding pkg, ModuleBinding client) {
 		PackageBinding resolved = getExportedPackage(pkg.readableName());
 		if (resolved == pkg) {
+			if (this.isAuto)
+				return true;
 			Predicate<IPackageExport> isTargeted = e -> e.exportedTo() != null;
 			Predicate<IPackageExport> isExportedTo = e -> 
 				Stream.of(e.exportedTo()).map(ref -> this.environment.getModule(ref)).filter(m -> m != null).anyMatch(client::equals);
@@ -222,7 +229,7 @@ public class ModuleBinding extends Binding {
 		if (declaresPackage(null, name)) {
 			return new PackageBinding(name, this.environment);
 		} else {
-			return Stream.of(getAllRequiredModules()).sorted((m1, m2) -> m1.requires.length - m2.requires.length)
+			PackageBinding pack = Stream.of(getAllRequiredModules()).sorted((m1, m2) -> m1.requires.length - m2.requires.length)
 					.map(m -> {
 						PackageBinding binding = m.getExportedPackage(name);
 						if (binding != null && m.isPackageExportedTo(binding, this)) {
@@ -231,6 +238,19 @@ public class ModuleBinding extends Binding {
 						return null;
 					})
 			.filter(p -> p != null).findFirst().orElse(null);
+			if (pack != null || this.isAuto) {
+				return pack;
+			}
+			// This will only work if the automatic modules already have all their packages loaded,
+			// remember there's no module-info
+			return getAllAutomaticModules().
+					map(new Function<ModuleBinding, PackageBinding>() {
+						@Override
+						public PackageBinding apply(ModuleBinding m) {
+							return m.getTopLevelPackage(name);
+						}
+					}).
+						filter(p -> p != null).findFirst().orElse(null);
 		}
 	}
 	// Given parent is declared in this module, see if there is sub package named name declared in this module
@@ -342,7 +362,7 @@ public class ModuleBinding extends Binding {
 		}
 		if (binding == null) {
 			char[] qualifiedPackageName = CharOperation.concatWith(parentPackageName, packageName, '.');
-			return Stream.of(getAllRequiredModules())
+			PackageBinding pack = Stream.of(getAllRequiredModules())
 					.map(m -> {
 						PackageBinding p = m.getExportedPackage(qualifiedPackageName);
 						if (p != null && m.isPackageExportedTo(p, this)) {
@@ -351,6 +371,15 @@ public class ModuleBinding extends Binding {
 						return null;
 					})
 			.filter(p -> p != null).findFirst().orElse(null);
+
+			if (pack != null || this.isAuto) {
+				return pack;
+			}
+			// This will only work if the automatic modules already have all their packages loaded,
+			// remember there's no module-info
+			return getAllAutomaticModules().filter(mod -> (mod.isAuto)).
+					map(m -> m.getPackage(parentPackageName, packageName)).
+						filter(p -> p != null).findFirst().orElse(null);
 		}
 		return binding;
 	}
@@ -364,7 +393,10 @@ public class ModuleBinding extends Binding {
 	 * @return True, if the package is visible to this module, false otherwise
 	 */
 	public boolean canSee(PackageBinding pkg) {
-		return declaresPackage(pkg) || Stream.of(getAllRequiredModules()).anyMatch(dep -> dep.isPackageExportedTo(pkg, this));
+		ModuleBinding[] mods = getAllRequiredModules();
+		return declaresPackage(pkg) || 
+			Stream.of(mods).anyMatch(dep -> dep.isPackageExportedTo(pkg, ModuleBinding.this)) || 
+				getAllAutomaticModules().anyMatch(dep -> dep.declaresPackage(pkg));
 	}
 	public boolean dependsOn(ModuleBinding other) {
  		if (other == this)
@@ -379,8 +411,15 @@ public class ModuleBinding extends Binding {
  	}
  	// A context including this module and all it's required modules
  	public IModuleContext getDependencyClosureContext() {
- 		ModuleBinding[] deps = getAllRequiredModules();
- 		return getModuleLookupContext().includeAll(Stream.of(deps).map(m -> m.getModuleLookupContext()));
+ 		Stream<ModuleBinding> stream = null;
+ 		if (this.isAuto) {
+ 			stream = getAllAutomaticModules();
+ 		} else {
+ 			stream = Stream.of(getAllRequiredModules());
+ 		}
+		return getModuleLookupContext().includeAll(stream.map(m -> m.getModuleLookupContext()))
+			.includeAll(getAllAutomaticModules().
+					map(m -> m.getModuleLookupContext()));
  	}
  	// A context that includes the entire module graph starting from this module
  	public IModuleContext getModuleGraphContext() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index 6666a36..0024120 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -22,7 +22,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IModuleContext;
 import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.JRTUtil;
 
@@ -73,7 +73,7 @@ public abstract class ModuleEnvironment implements IModuleAwareNameEnvironment {
 	public static IModule[] UNNAMED_MODULE_ARRAY = new IModule[]{UNNAMED_MODULE};
 
 	private HashMap<String, IModule> modulesCache = null;
-	private static HashMap<IModuleLocation, IModule> ModuleLocationMap = new HashMap<>();
+	private static HashMap<IModuleEnvironment, IModule> ModuleLocationMap = new HashMap<>();
 	
 	public ModuleEnvironment() {
 		this.modulesCache = new HashMap<>();
@@ -207,7 +207,7 @@ public abstract class ModuleEnvironment implements IModuleAwareNameEnvironment {
 	 *
 	 * @param mod the module to be stored in memory
 	 */
-	public void acceptModule(IModule mod, IModuleLocation location) {
+	public void acceptModule(IModule mod, IModuleEnvironment location) {
 		IModule existing = ModuleEnvironment.ModuleLocationMap.get(location);
 		if (existing != null) {
 			if (existing.equals(mod))
@@ -222,7 +222,7 @@ public abstract class ModuleEnvironment implements IModuleAwareNameEnvironment {
 	}
 
 	//@Override
-	public IModule getModule(IModuleLocation location) {
+	public IModule getModule(IModuleEnvironment location) {
 		IModule module = ModuleEnvironment.ModuleLocationMap.get(location);
 		if (module == null) 
 			return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfModule.java
new file mode 100644
index 0000000..1bd6eb2
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfModule.java
@@ -0,0 +1,110 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.util;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
+
+public final class HashtableOfModule {
+	// to avoid using Enumerations, walk the individual tables skipping nulls
+	public char[] keyTable[];
+	public ModuleBinding valueTable[];
+
+	public int elementSize; // number of elements in the table
+	int threshold;
+	public HashtableOfModule() {
+		this(3); // usually not very large
+	}
+	public HashtableOfModule(int size) {
+		this.elementSize = 0;
+		this.threshold = size; // size represents the expected number of elements
+		int extraRoom = (int) (size * 1.75f);
+		if (this.threshold == extraRoom)
+			extraRoom++;
+		this.keyTable = new char[extraRoom][];
+		this.valueTable = new ModuleBinding[extraRoom];
+	}
+	public boolean containsKey(char[] key) {
+		int length = this.keyTable.length,
+				index = CharOperation.hashCode(key) % length;
+		int keyLength = key.length;
+		char[] currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.length == keyLength && CharOperation.equals(currentKey, key))
+				return true;
+			if (++index == length) {
+				index = 0;
+			}
+		}
+		return false;
+	}
+	public ModuleBinding get(char[] key) {
+		int length = this.keyTable.length,
+				index = CharOperation.hashCode(key) % length;
+		int keyLength = key.length;
+		char[] currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.length == keyLength && CharOperation.equals(currentKey, key))
+				return this.valueTable[index];
+			if (++index == length) {
+				index = 0;
+			}
+		}
+		return null;
+	}
+	public ModuleBinding put(char[] key, ModuleBinding value) {
+		int length = this.keyTable.length,
+				index = CharOperation.hashCode(key) % length;
+		int keyLength = key.length;
+		char[] currentKey;
+		while ((currentKey = this.keyTable[index]) != null) {
+			if (currentKey.length == keyLength && CharOperation.equals(currentKey, key))
+				return this.valueTable[index] = value;
+			if (++index == length) {
+				index = 0;
+			}
+		}
+		this.keyTable[index] = key;
+		this.valueTable[index] = value;
+
+		// assumes the threshold is never equal to the size of the table
+		if (++this.elementSize > this.threshold)
+			rehash();
+		return value;
+	}
+	private void rehash() {
+		HashtableOfModule newHashtable = new HashtableOfModule(this.elementSize * 2); // double the number of expected elements
+		char[] currentKey;
+		for (int i = this.keyTable.length; --i >= 0;)
+			if ((currentKey = this.keyTable[i]) != null)
+				newHashtable.put(currentKey, this.valueTable[i]);
+
+		this.keyTable = newHashtable.keyTable;
+		this.valueTable = newHashtable.valueTable;
+		this.threshold = newHashtable.threshold;
+	}
+	public int size() {
+		return this.elementSize;
+	}
+	public String toString() {
+		String s = ""; //$NON-NLS-1$
+		ModuleBinding pkg;
+		for (int i = 0, length = this.valueTable.length; i < length; i++)
+			if ((pkg = this.valueTable[i]) != null)
+				s += pkg.toString() + "\n"; //$NON-NLS-1$
+		return s;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
index 9bab66c..3da4369 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 IBM Corporation and others.
+ * Copyright (c) 2005, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -113,6 +117,16 @@ public interface IClasspathAttribute {
 	 * @since 3.2
 	 */
 	String OPTIONAL = "optional"; //$NON-NLS-1$
+	/**
+	 * Constant for the name of automatic module. The possible values
+	 * for this attribute are <code>"true"</code> or <code>"false"</code>.
+	 * When not present, <code>"false"</code> is assumed.
+	 * If the value of this attribute is <code>"true"</code>, the classpath entry
+	 * is considered to be an automatic module.
+	 *
+	 * @since 3.13 BETA_JAVA9
+	 */
+	String AUTOMATIC_MODULE = "module"; //$NON-NLS-1$
 
 	/**
 	 * Constant for the name of the external annotation path attribute. 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
index 7d1df25..c23fae8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -136,6 +140,10 @@ public class ClasspathChange {
 							continue; // null and not-null
 						}						
 					}
+					if (((ClasspathEntry) entry).isAutomaticModule() !=
+							((ClasspathEntry) other).isAutomaticModule()) {
+						continue nextEntry;
+					}
 					return i;
 			}
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index 08acbd6..ae0a018 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
@@ -1393,6 +1397,14 @@ public class ClasspathEntry implements IClasspathEntry {
 		}
 		return false;
 	}
+	public boolean isAutomaticModule() {
+		for (int i = 0, length = this.extraAttributes.length; i < length; i++) {
+			IClasspathAttribute attribute = this.extraAttributes[i];
+			if (IClasspathAttribute.AUTOMATIC_MODULE.equals(attribute.getName()) && "true".equals(attribute.getValue())) //$NON-NLS-1$
+				return true;
+		}
+		return false;
+	}
 
 	public String getSourceAttachmentEncoding() {
 		for (int i = 0, length = this.extraAttributes.length; i < length; i++) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
index 4b101b1..48a54bc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
@@ -58,4 +58,8 @@ public class ProjectEntry implements IModulePathEntry {
 			return this.project;
 		return null;
 	}
+	@Override
+	public boolean isAutomaticModule() {
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index f837706..3da3eb4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -807,4 +807,9 @@ public class SearchableEnvironment
 		// 
 		return isPackage(parentPackageName, packageName, IModuleContext.UNNAMED_MODULE_CONTEXT);
 	}
+
+	@Override
+	public IModule[] getAllAutomaticModules() {
+		return new IModule[0];
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
new file mode 100644
index 0000000..bdd5418
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BasicModule.java
@@ -0,0 +1,228 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.builder;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+
+public class BasicModule implements IModule {
+	static class ModuleReferenceImpl implements IModule.IModuleReference {
+		char[] name;
+		boolean isPublic = false;
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+		@Override
+		public boolean isPublic() {
+			return this.isPublic;
+		}
+		public boolean equals(Object o) {
+			if (this == o) 
+				return true;
+			if (!(o instanceof IModule.IModuleReference))
+				return false;
+			IModule.IModuleReference mod = (IModule.IModuleReference) o;
+			if (this.isPublic != mod.isPublic())
+				return false;
+			return CharOperation.equals(this.name, mod.name());
+		}
+		@Override
+		public int hashCode() {
+			return this.name.hashCode();
+		}
+	}
+	static class PackageExport implements IModule.IPackageExport {
+		char[] pack;
+		char[][] exportedTo;
+		@Override
+		public char[] name() {
+			return this.pack;
+		}
+
+		@Override
+		public char[][] exportedTo() {
+			return this.exportedTo;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append(this.pack);
+			if (this.exportedTo != null) {
+				for (char[] cs : this.exportedTo) {
+					buffer.append(cs);
+				}
+			}
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+	static class Service implements IModule.IService {
+		char[] provides;
+		char[] with;
+		@Override
+		public char[] name() {
+			return this.provides;
+		}
+
+		@Override
+		public char[] with() {
+			return this.with;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append("provides"); //$NON-NLS-1$
+			buffer.append(this.provides);
+			buffer.append(" with "); //$NON-NLS-1$
+			buffer.append(this.with);
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+
+	char[] name;
+	IModule.IModuleReference[] requires;
+	IModule.IPackageExport[] exports;
+	char[][] uses;
+	Service[] provides;
+	ClasspathLocation root;
+	boolean isAutomodule;
+	public BasicModule(char[] name, ClasspathLocation root, boolean isAutomodule) {
+		this.name = name;
+		this.root = root;
+		this.exports = IModule.NO_EXPORTS;
+		this.requires = IModule.NO_MODULE_REFS;
+		this.isAutomodule = isAutomodule;
+	}
+	@Override
+	public char[] name() {
+		return this.name;
+	}
+	@Override
+	public IModule.IModuleReference[] requires() {
+		return this.requires;
+	}
+	@Override
+	public IModule.IPackageExport[] exports() {
+		return this.exports;
+	}
+	@Override
+	public char[][] uses() {
+		return this.uses;
+	}
+	@Override
+	public IService[] provides() {
+		return this.provides();
+	}
+	@Override
+	public boolean isAutomatic() {
+		return this.root.isAutomaticModule();
+	}
+	public void addReads(char[] modName) {
+		Predicate<char[]> shouldAdd = m -> {
+			return Stream.of(this.requires).map(ref -> ref.name()).noneMatch(n -> CharOperation.equals(modName, n));
+		};
+		if (shouldAdd.test(modName)) {
+			int len = this.requires.length;
+			this.requires = Arrays.copyOf(this.requires, len + 1);
+			ModuleReferenceImpl info = new ModuleReferenceImpl();
+			info.name = modName;
+			this.requires[len] = info;
+		}		
+	}
+	public void addExports(IModule.IPackageExport[] toAdd) {
+		Predicate<char[]> shouldAdd = m -> {
+			return Stream.of(this.exports).map(ref -> ((PackageExport) ref).pack).noneMatch(n -> CharOperation.equals(m, n));
+		};
+		Collection<IPackageExport> merged = Stream.concat(Stream.of(this.exports), Stream.of(toAdd)
+				.filter(e -> shouldAdd.test(((PackageExport )e).name()))
+				.map(e -> {
+					PackageExport exp = new PackageExport();
+					exp.pack = ((PackageExport )e).name();
+					exp.exportedTo = ((PackageExport )e).exportedTo();
+					return exp;
+				}))
+			.collect(
+				ArrayList::new,
+				ArrayList::add,
+				ArrayList::addAll);
+		this.exports = merged.toArray(new PackageExport[merged.size()]);
+	}
+	public boolean equals(Object o) {
+		if (this == o)
+			return true;
+		if (!(o instanceof IModule))
+			return false;
+		IModule mod = (IModule) o;
+		if (!CharOperation.equals(this.name, mod.name()))
+			return false;
+		return Arrays.equals(this.requires, mod.requires());
+	}
+	@Override
+	public int hashCode() {
+		int result = 17;
+		int c = this.name.hashCode();
+		result = 31 * result + c;
+		c =  Arrays.hashCode(this.requires);
+		result = 31 * result + c;
+		return result;
+	}
+	public String toString() {
+		StringBuffer buffer = new StringBuffer(getClass().getName());
+		toStringContent(buffer);
+		return buffer.toString();
+	}
+	protected void toStringContent(StringBuffer buffer) {
+		buffer.append("\nmodule "); //$NON-NLS-1$
+		buffer.append(this.name).append(' ');
+		buffer.append('{').append('\n');
+		if (this.requires != null) {
+			for(int i = 0; i < this.requires.length; i++) {
+				buffer.append("\trequires "); //$NON-NLS-1$
+				if (this.requires[i].isPublic()) {
+					buffer.append(" public "); //$NON-NLS-1$
+				}
+				buffer.append(this.requires[i].name());
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.exports != null) {
+			buffer.append('\n');
+			for(int i = 0; i < this.exports.length; i++) {
+				buffer.append("\texports "); //$NON-NLS-1$
+				buffer.append(this.exports[i].toString());
+			}
+		}
+		if (this.uses != null) {
+			buffer.append('\n');
+			for (char[] cs : this.uses) {
+				buffer.append(cs);
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.provides != null) {
+			buffer.append('\n');
+			for(Service ser : this.provides) {
+				buffer.append(ser.toString());
+			}
+		}
+		buffer.append('\n').append('}').toString();
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index 025e5a4..95d1242 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -27,8 +27,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.env.IModule;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
@@ -48,9 +47,8 @@ AccessRuleSet accessRuleSet;
 ZipFile annotationZipFile;
 String externalAnnotationPath;
 INameEnvironment env;
-IModule module;
 
-ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
+ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
 	this.binaryFolder = binaryFolder;
 	this.isOutputFolder = isOutputFolder || binaryFolder.getProjectRelativePath().isEmpty(); // if binaryFolder == project, then treat it as an outputFolder
 	this.directoryCache = new SimpleLookupTable(5);
@@ -58,6 +56,14 @@ ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSe
 	this.env = env;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toOSString();
+	if (isAutomodule) {
+		setAutomaticModule();
+	}
+}
+
+void setAutomaticModule() {
+	this.isAutoModule = true;
+	acceptModule(new BasicModule(this.binaryFolder.getName().toCharArray(), this, true));
 }
 
 public void cleanup() {
@@ -81,9 +87,10 @@ ClasspathDirectory initializeModule() {
 				String name = m.getName();
 				// Note: Look only inside the default package.
 				if (m.getType() == IResource.FILE && org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(name)) {
-					if (name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_CLASS)) {
+					if (name.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_CLASS)) {
 						try {
 							this.acceptModule( Util.newClassFileReader(m));
+							this.isAutoModule = false;
 						} catch (ClassFormatException | IOException e) {
 							// TODO BETA_JAVA9 Auto-generated catch block
 							e.printStackTrace();
@@ -114,14 +121,6 @@ String[] directoryList(String qualifiedPackageName) {
 				if (m.getType() == IResource.FILE && org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(name)) {
 					// add exclusion pattern check here if we want to hide .class files
 					dirList[index++] = name;
-					if (name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_CLASS)) {
-						try {
-							this.acceptModule( Util.newClassFileReader(m));
-						} catch (ClassFormatException | IOException e) {
-							// TODO BETA_JAVA9 Auto-generated catch block
-							e.printStackTrace();
-						}
-					}
 				}
 			}
 			if (index < dirList.length)
@@ -137,7 +136,7 @@ String[] directoryList(String qualifiedPackageName) {
 }
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-		this.module = classfile.getModuleDeclaration();
+		acceptModule(classfile.getModuleDeclaration());
 	}
 }
 boolean doesFileExist(String fileName, String qualifiedPackageName, String qualifiedFullName) {
@@ -251,4 +250,5 @@ public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageN
 	// 
 	return findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName, false);
 }
+
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 10d3cbb..95aa6de 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -34,7 +34,6 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
@@ -62,7 +61,6 @@ static class PackageCacheEntry {
 
 private static SimpleLookupTable PackageCache = new SimpleLookupTable();
 INameEnvironment env = null;
-IModule module = null;
 
 protected static void addToPackageSet(SimpleSet packageSet, String fileName, boolean endsWithSep) {
 	int last = endsWithSep ? fileName.length() : fileName.lastIndexOf('/');
@@ -95,7 +93,7 @@ static SimpleSet findPackageSet(final ClasspathJar jar) {
 		int folderEnd = fileName.lastIndexOf('/');
 		folderEnd += 1;
 		String className = fileName.substring(folderEnd, fileName.length());
-		if (className.equalsIgnoreCase(IModuleLocation.MODULE_INFO_CLASS)) {
+		if (className.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_CLASS)) {
 			modInfo = fileName;
 		}
 		addToPackageSet(packageSet, fileName, false);
@@ -104,6 +102,7 @@ static SimpleSet findPackageSet(final ClasspathJar jar) {
 	if (modInfo != null) {
 		try {
 			jar.acceptModule(ClassFileReader.read(jar.zipFile, modInfo));
+			jar.isAutoModule = false; // TODO: check with spec on what the behavior should be
 		} catch (ClassFormatException | IOException e) {
 			// TODO BETA_JAVA9 Auto-generated catch block
 			e.printStackTrace();
@@ -113,10 +112,7 @@ static SimpleSet findPackageSet(final ClasspathJar jar) {
 }
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-//		if ((this.module = classfile.getModuleDeclaration()) != null) {
-//			this.env.acceptModule(this.module, this);
-//		}
-		this.module = classfile.getModuleDeclaration();
+		acceptModule(classfile.getModuleDeclaration());
 	}
 }
 
@@ -131,7 +127,7 @@ private SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
 String externalAnnotationPath;
 
-ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
+ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
 	this.resource = resource;
 	try {
 		java.net.URI location = resource.getLocationURI();
@@ -149,9 +145,11 @@ ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotati
 	this.accessRuleSet = accessRuleSet;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
+	if (isAutomodule)
+		setAutomaticModule();
 }
 
-ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
+ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
 	this.zipFilename = zipFilename;
 	this.lastModified = lastModified;
 	this.zipFile = null;
@@ -160,18 +158,26 @@ ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet,
 	this.env = env;
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
+	if (isAutomodule)
+		setAutomaticModule();
 }
 
-public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
-	this(zipFile.getName(), accessRuleSet, externalAnnotationPath, env);
+public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
+	this(zipFile.getName(), accessRuleSet, externalAnnotationPath, env, isAutomodule);
 	this.zipFile = zipFile;
 }
 
-public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
-	this(fileName, 0, accessRuleSet, externalAnnotationPath, env);
+public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
+	this(fileName, 0, accessRuleSet, externalAnnotationPath, env, isAutomodule);
 	if (externalAnnotationPath != null)
 		this.externalAnnotationPath = externalAnnotationPath.toString();
+	if (isAutomodule)
+		setAutomaticModule();
+}
 
+void setAutomaticModule() {
+	this.isAutoModule = true;
+	acceptModule(new BasicModule(this.zipFilename.toCharArray(), this, true));
 }
 
 public void cleanup() {
@@ -201,7 +207,9 @@ public boolean equals(Object o) {
 	if (this.accessRuleSet != jar.accessRuleSet)
 		if (this.accessRuleSet == null || !this.accessRuleSet.equals(jar.accessRuleSet))
 			return false;
-	return this.zipFilename.equals(jar.zipFilename) && lastModified() == jar.lastModified();
+	return this.zipFilename.equals(jar.zipFilename) 
+			&& lastModified() == jar.lastModified()
+			&& this.isAutoModule == jar.isAutoModule;
 }
 
 public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName, boolean asBinaryOnly) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index b4fdd92..fb65af5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -35,7 +35,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
-import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.env.IMultiModuleEntry;
 import org.eclipse.jdt.internal.compiler.env.IMultiModulePackageLookup;
 import org.eclipse.jdt.internal.compiler.env.IMultiModuleTypeLookup;
@@ -107,7 +106,7 @@ static HashMap<String, SimpleSet> findPackagesInModules(final ClasspathJrt jrt)
 			public FileVisitResult visitModule(Path mod) throws IOException {
 				String name = mod.toString();
 				try {
-					jrt.acceptModule(JRTUtil.getClassfileContent(imageFile, IModuleLocation.MODULE_INFO_CLASS, name));
+					jrt.acceptModule(JRTUtil.getClassfileContent(imageFile, IModuleEnvironment.MODULE_INFO_CLASS, name));
 				} catch (ClassFormatException e) {
 					e.printStackTrace();
 				}
@@ -150,7 +149,7 @@ public static void loadModules(final ClasspathJrt jrt) {
 				@Override
 				public FileVisitResult visitModule(Path mod) throws IOException {
 					try {
-						jrt.acceptModule(JRTUtil.getClassfileContent(imageFile, IModuleLocation.MODULE_INFO_CLASS, mod.toString()));
+						jrt.acceptModule(JRTUtil.getClassfileContent(imageFile, IModuleEnvironment.MODULE_INFO_CLASS, mod.toString()));
 					} catch (ClassFormatException e) {
 						e.printStackTrace();
 					}
@@ -171,7 +170,7 @@ void acceptModule(byte[] content) {
 		return;
 	ClassFileReader reader = null;
 	try {
-		reader = new ClassFileReader(content, IModuleLocation.MODULE_INFO_CLASS.toCharArray(), null);
+		reader = new ClassFileReader(content, IModuleEnvironment.MODULE_INFO_CLASS.toCharArray(), null);
 	} catch (ClassFormatException e) {
 		e.printStackTrace();
 	}
@@ -302,20 +301,20 @@ public IModuleEnvironment getLookupEnvironment() {
 	return this;
 }
 @Override
-public IModuleEnvironment getLookupEnvironmentFor(IModule module) {
+public IModuleEnvironment getLookupEnvironmentFor(IModule mod) {
 	// 
 	return new IModuleEnvironment() {
 		
 		@Override
 		public ITypeLookup typeLookup() {
 			//
-			return servesModule(module.name()) ? ClasspathJrt.this.typeLookupForModule.apply(module.name()) : ITypeLookup.Dummy;
+			return servesModule(mod.name()) ? ClasspathJrt.this.typeLookupForModule.apply(mod.name()) : ITypeLookup.Dummy;
 		}
 		
 		@Override
 		public IPackageLookup packageLookup() {
 			//
-			return servesModule(module.name()) ? ClasspathJrt.this.pkgLookupForModule.apply(module.name()) : IPackageLookup.Dummy;
+			return servesModule(mod.name()) ? ClasspathJrt.this.pkgLookupForModule.apply(mod.name()) : IPackageLookup.Dummy;
 		}
 	};
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index 50076f6..f4ca97c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -28,6 +28,8 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public abstract class ClasspathLocation implements IModuleEnvironment {
 
+	protected boolean isAutoModule;
+	protected IModule module;
 	abstract public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName);
 	abstract public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName, boolean asBinaryOnly);
 	abstract public boolean isPackage(String qualifiedPackageName);
@@ -44,28 +46,29 @@ public abstract class ClasspathLocation implements IModuleEnvironment {
 		return new ClasspathMultiDirectory(sourceFolder, outputFolder, inclusionPatterns, exclusionPatterns,
 				ignoreOptionalProblems, env);
 	}
-public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
-	return new ClasspathDirectory(binaryFolder, isOutputFolder, accessRuleSet, externalAnnotationPath, env);
+public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean autoModule) {
+	return new ClasspathDirectory(binaryFolder, isOutputFolder, accessRuleSet, externalAnnotationPath, env, autoModule);
 }
 
 static ClasspathLocation forLibrary(String libraryPathname, 
 										long lastModified, 
 										AccessRuleSet accessRuleSet, 
 										IPath annotationsPath,
-										INameEnvironment env) {
+										INameEnvironment env,
+										boolean autoModule) {
 	return Util.isJrt(libraryPathname) ?
 			new ClasspathJrt(libraryPathname, annotationsPath, env) :
-			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env);
+			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env, autoModule);
 }
 
 public static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath,
-											INameEnvironment env) {
-	return forLibrary(libraryPathname, 0, accessRuleSet, annotationsPath, env);
+											INameEnvironment env, boolean autoModule) {
+	return forLibrary(libraryPathname, 0, accessRuleSet, annotationsPath, env, autoModule);
 }
 
 static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet, IPath annotationsPath,
-										INameEnvironment env) {
-	return new ClasspathJar(library, accessRuleSet, annotationsPath, env);
+										INameEnvironment env, boolean autoModule) {
+	return new ClasspathJar(library, accessRuleSet, annotationsPath, env, autoModule);
 }
 
 public abstract IPath getProjectRelativePath();
@@ -83,4 +86,20 @@ public void reset() {
 
 public abstract String debugPathString();
 
+void acceptModule(IModule mod) {
+	if (mod != null) {
+		this.module = mod;
+	}
+}
+public IModule getModule() {
+	return this.module;
+}
+/**
+ * Specifies whether this entry represents an automatic module.
+ * 
+ * @return true if this is an automatic module, false otherwise
+ */
+public boolean isAutomaticModule() {
+	return this.isAutoModule;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
index c90bdfd..4278164 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
@@ -34,7 +34,7 @@ boolean hasIndependentOutputFolder; // if output folder is not equal to any of t
 public boolean ignoreOptionalProblems;
 
 ClasspathMultiDirectory(IContainer sourceFolder, IContainer binaryFolder, char[][] inclusionPatterns, char[][] exclusionPatterns, boolean ignoreOptionalProblems, INameEnvironment env) {
-	super(binaryFolder, true, null, null, env);
+	super(binaryFolder, true, null, null, env, false /* source never an automatic module*/);
 
 	this.sourceFolder = sourceFolder;
 	this.inclusionPatterns = inclusionPatterns;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/Module.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/Module.java
deleted file mode 100644
index e877852..0000000
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/Module.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-//package org.eclipse.jdt.internal.core.builder;
-//
-//import org.eclipse.jdt.internal.compiler.env.IModule;
-//import org.eclipse.jdt.internal.compiler.env.IModuleDeclaration;
-//import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
-//
-//public class Module implements IModule {
-//	public IModulePathEntry entry;
-//	public IModuleDeclaration declaration;
-//
-//	public Module(IModulePathEntry entry, IModuleDeclaration declaration) {
-//		this.entry = entry;
-//		this.declaration = declaration;
-//	}
-//
-//	@Override
-//	public char[] name() {
-//		//
-//		return this.declaration.name();
-//	}
-//	@Override
-//	public IModuleDeclaration getDeclaration() {
-//		// 
-//		return this.declaration;
-//	}
-//}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index 2ac5481..d64e66d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -163,7 +163,7 @@ private void computeClasspathLocations(
 							: (IContainer) root.getFolder(prereqOutputPath);
 						if (binaryFolder.exists() && !seen.contains(binaryFolder)) {
 							seen.add(binaryFolder);
-							ClasspathLocation bLocation = ClasspathLocation.forBinaryFolder(binaryFolder, true, entry.getAccessRuleSet(), externalAnnotationPath, this);
+							ClasspathLocation bLocation = ClasspathLocation.forBinaryFolder(binaryFolder, true, entry.getAccessRuleSet(), externalAnnotationPath, this, entry.isAutomaticModule());
 							bLocations.add(bLocation);
 							projectLocations.add(bLocation);
 							if (binaryLocationsPerProject != null) { // normal builder mode
@@ -197,14 +197,14 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath, this);
+						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
 					} else if (resource instanceof IContainer) {
 						AccessRuleSet accessRuleSet =
 							(JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, true))
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forBinaryFolder((IContainer) target, false, accessRuleSet, externalAnnotationPath, this);	 // is library folder not output folder
+						bLocation = ClasspathLocation.forBinaryFolder((IContainer) target, false, accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());	 // is library folder not output folder
 					}
 					bLocations.add(bLocation);
 					// TODO: Ideally we need to do something like mapToModulePathEntry using the path and if it is indeed
@@ -230,7 +230,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath, this);
+					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
 					bLocations.add(bLocation);
 					// TODO: Ideally we need to do something like mapToModulePathEntry using the path and if it is indeed
 					// a module path entry, then add the corresponding entry here, but that would need the target platform
@@ -346,10 +346,19 @@ private NameEnvironmentAnswer findClass(String qualifiedTypeName, char[] typeNam
 				.reduce(ITypeLookup::chain)
 				.map(t -> t.findClass(binaryFileName, qPackageName, qBinaryFileName)).orElse(null);
 	}
-	return moduleContext.getEnvironment().map(env -> env.typeLookup())
+	NameEnvironmentAnswer answer = moduleContext.getEnvironment().map(env -> env.typeLookup())
 				.reduce(ITypeLookup::chain)
 				.map(lookup -> lookup.findClass(binaryFileName, qPackageName, qBinaryFileName))
 				.orElse(null);
+	if (answer != null)
+		return answer;
+	
+	return Stream.of(this.modulePathEntries).filter(mod ->
+				(mod instanceof ClasspathLocation && ((ClasspathLocation) mod).isAutoModule))
+			.map(p -> p.getLookupEnvironment().typeLookup())
+			.reduce(ITypeLookup::chain)
+			.map(t -> t.findClass(binaryFileName, qPackageName, qBinaryFileName)).orElse(null);
+
 }
 
 public NameEnvironmentAnswer findType(char[][] compoundName) {
@@ -442,4 +451,19 @@ public IModuleEnvironment getModuleEnvironmentFor(char[] moduleName) {
 	}
 	return null;
 }
+@Override
+public IModule[] getAllAutomaticModules() {
+	if (this.modulePathEntries == null)
+		return IModule.NO_MODULES;
+	Set<IModule> set = new HashSet<>();
+	for (int i = 0, l = this.modulePathEntries.length; i < l; i++) {
+		if (this.modulePathEntries[i] instanceof ClasspathLocation) {
+			if (((ClasspathLocation) this.modulePathEntries[i]).isAutoModule) {
+				set.add(this.modulePathEntries[i].getModule());
+			}
+		}
+	}
+	return set.toArray(new IModule[set.size()]);
+}
+
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index a18515f..1eadf51 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -275,13 +275,16 @@ static State read(IProject project, DataInputStream in) throws IOException {
 				IContainer outputFolder = path.segmentCount() == 1
 					? (IContainer) root.getProject(path.toString())
 					: (IContainer) root.getFolder(path);
-				newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(), readRestriction(in), new Path(in.readUTF()), newState.environment);
+					newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(),
+							readRestriction(in), new Path(in.readUTF()), newState.environment, in.readBoolean());
 				break;
 			case EXTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), new Path(in.readUTF()), newState.environment);
+					newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(),
+							readRestriction(in), new Path(in.readUTF()), newState.environment, in.readBoolean());
 				break;
 			case INTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), new Path(in.readUTF()), newState.environment);
+					newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())),
+							readRestriction(in), new Path(in.readUTF()), newState.environment, in.readBoolean());
 		}
 	}
 
@@ -462,6 +465,7 @@ void write(DataOutputStream out) throws IOException {
 			out.writeBoolean(cd.isOutputFolder);
 			writeRestriction(cd.accessRuleSet, out);
 			out.writeUTF(cd.externalAnnotationPath != null ? cd.externalAnnotationPath : ""); //$NON-NLS-1$
+			out.writeBoolean(cd.isAutomaticModule());
 		} else if (c instanceof ClasspathJar) {
 			ClasspathJar jar = (ClasspathJar) c;
 			if (jar.resource == null) {
@@ -474,6 +478,7 @@ void write(DataOutputStream out) throws IOException {
 			}
 			writeRestriction(jar.accessRuleSet, out);
 			out.writeUTF(jar.externalAnnotationPath != null ? jar.externalAnnotationPath : ""); //$NON-NLS-1$
+			out.writeBoolean(jar.isAutomaticModule());
 		} else {
 			ClasspathJrt jrt = (ClasspathJrt) c;
 			out.writeByte(EXTERNAL_JAR);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
index 1e73cfa..1f6e87e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
@@ -26,7 +26,6 @@ import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
@@ -44,7 +43,6 @@ public class ClasspathSourceDirectory extends ClasspathLocation {
 	SimpleLookupTable missingPackageHolder = new SimpleLookupTable();
 	char[][] fullExclusionPatternChars;
 	char[][] fulInclusionPatternChars;
-	IModule module = null;
 
 ClasspathSourceDirectory(IContainer sourceFolder, char[][] fullExclusionPatternChars, char[][] fulInclusionPatternChars) {
 	this.sourceFolder = sourceFolder;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 57a7806..7ea3c33 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -109,7 +109,7 @@ private LinkedHashSet<ClasspathLocation> computeClasspathLocations(JavaProject j
 	return locations;
 }
 
-private ClasspathLocation mapToClassPathLocation( JavaModelManager manager, PackageFragmentRoot root) {
+private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, PackageFragmentRoot root) {
 	ClasspathLocation cp = null;
 	IPath path = root.getPath();
 	try {
@@ -118,7 +118,10 @@ private ClasspathLocation mapToClassPathLocation( JavaModelManager manager, Pack
 			cp = JavaModelManager.isJrt(path) ? 
 					new ClasspathJrt(path.toOSString(), 
 							ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true), this) :
-			new ClasspathJar(manager.getZipFile(path), rawClasspathEntry.getAccessRuleSet(), ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true), this);
+						new ClasspathJar(manager.getZipFile(path), rawClasspathEntry.getAccessRuleSet(),
+								ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry,
+										((IJavaProject) root.getParent()).getProject(), true),
+								this, rawClasspathEntry.isAutomaticModule());
 		} else {
 			Object target = JavaModel.getTarget(path, true);
 			if (target != null) {
@@ -127,7 +130,7 @@ private ClasspathLocation mapToClassPathLocation( JavaModelManager manager, Pack
 				} else {
 					ClasspathEntry rawClasspathEntry = (ClasspathEntry) root.getRawClasspathEntry();
 					cp = ClasspathLocation.forBinaryFolder((IContainer) target, false, rawClasspathEntry.getAccessRuleSet(), 
-							ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true), this);
+							ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true), this, rawClasspathEntry.isAutomaticModule());
 				}
 			}
 		}
commit d5754530cfb724106e94c36adc5d9f821553ee05
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Nov 28 20:40:44 2016 +0530

    Bug 506878 - [9] Provide means to support automatic modules
    
    Fixing issues reported in comment #8 and #16
    
    Change-Id: Ic817cfc38830736ee0e7552c1c462e6bad442eb3

60	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
1	5	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
2	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
2	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
11	57	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
16	44	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
34	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
287	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
11	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index d49d639..9ec7271 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -27,7 +27,7 @@ import junit.framework.Test;
 public class ModuleCompilationTests extends BatchCompilerTest {
 
 	static {
-//		 TESTS_NAMES = new String[] { "test034" };
+//		 TESTS_NAMES = new String[] { "test035" };
 		// TESTS_NUMBERS = new int[] { 1 };
 		// TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -1463,8 +1463,8 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 				false);
 	}
 	/**
-	 * Test that a module can access types/packages in a plain Jar put in modulepath,
-	 * this upgrading it to an automatic module
+	 * Test that a module can't access types/packages in a plain Jar put in modulepath
+	 * but not explicitly added to the "requires" clause
 	 */
 	public void test034() {
 		File libDir = new File(LIB_DIR);
@@ -1506,6 +1506,63 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append("-mp \"")
 			.append(LIB_DIR).append("\" ")
 			.append(" -modulesourcepath " + "\"" + directory + "\"");
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/X.java (at line 2)\n" + 
+				"	public class X extends a.A {\n" + 
+				"	                       ^\n" + 
+				"a cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
+	/**
+	 * Test that a module can access types/packages in a plain Jar put in modulepath
+	 * and explicitly added to the "requires" clause
+	 */
+	public void test035() {
+		File libDir = new File(LIB_DIR);
+		Util.delete(libDir); // make sure we recycle the libs
+ 		libDir.mkdirs();
+		try {
+			Util.createJar(
+				new String[] {
+					"a/A.java",
+					"package a;\n" +
+					"public class A {\n" +
+					"}"
+				},
+				LIB_DIR + "/lib1.jar",
+				JavaCore.VERSION_9);
+		} catch (IOException e) {
+			// ignore
+		}
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires java.sql;\n" +
+						"	requires lib1;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X extends a.A {\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString()).append("\" ")
+			.append("-mp \"")
+			.append(LIB_DIR).append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"");
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
 				"",
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
index 54708ce..9cef79d 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/BasicModule.java
@@ -25,7 +25,6 @@ import org.eclipse.jdt.internal.compiler.ast.ExportReference;
 import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
 
@@ -128,10 +127,8 @@ public class BasicModule implements IModule {
 	IModule.IPackageExport[] exports;
 	char[][] uses;
 	Service[] provides;
-	IModulePathEntry root;
 	public BasicModule(ModuleDeclaration descriptor, IModulePathEntry root) {
 		this.name = descriptor.moduleName;
-		this.root = root;
 		if (descriptor.requiresCount > 0) {
 			ModuleReference[] refs = descriptor.requires;
 			this.requires = new ModuleReferenceImpl[refs.length];
@@ -171,9 +168,8 @@ public class BasicModule implements IModule {
 		}
 		this.isAutomodule = false; // Just to be explicit
 	}
-	public BasicModule(char[] name, Classpath root, boolean isAuto) {
+	public BasicModule(char[] name, boolean isAuto) {
 		this.name = name;
-		this.root = root;
 		this.exports = IModule.NO_EXPORTS;
 		this.requires = IModule.NO_MODULE_REFS;
 		this.isAutomodule = isAuto;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index 89daa4a..10c78ff 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -33,6 +33,7 @@ import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment.AutoModule;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
@@ -306,7 +307,7 @@ public int getMode() {
 }
 public IModule getModule() {
 	if (this.isAutoModule && this.module == null) {
-		return this.module = new BasicModule(this.path.toCharArray(), this, true);
+		return this.module = new AutoModule(this.path.toCharArray());
 	}
 	return this.module;
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index 74905b2..38da694 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -42,6 +42,7 @@ import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment.AutoModule;
 import org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.compiler.util.Util;
@@ -295,7 +296,7 @@ public int getMode() {
 
 public IModule getModule() {
 	if (this.isAutoModule && this.module == null) {
-		return this.module = new BasicModule(this.file.getName().toCharArray(), this, true);
+		return this.module = new AutoModule(this.file.getName().toCharArray());
 	}
 	return this.module;
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
index 311b9a9..de5d01a 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -33,6 +33,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -82,7 +83,7 @@ public class ModuleFinder {
 					}
 					if (isModulepath && module == null) {
 						 // The name includes the file's extension, but it shouldn't matter.
-						module = new BasicModule(file.getName().toCharArray(), modulePath, true);
+						module = new ModuleEnvironment.AutoModule(getFileName(file).toCharArray());
 					}
 					if (module != null)
 						modulePath.acceptModule(module);
@@ -91,6 +92,13 @@ public class ModuleFinder {
 		}
 		return collector;
 	}
+	private static String getFileName(File file) {
+		String name = file.getName();
+		int index = name.lastIndexOf('.');
+		if (index == -1)
+			return name;
+		return name.substring(0, index);
+	}
 	/**
 	 * Extracts the single reads clause from the given
 	 * command line option (--add-reads). The result is a String[] with two
@@ -154,65 +162,11 @@ public class ModuleFinder {
 		for(int i = 0; i < export.exportedTo.length; i++) {
 			export.exportedTo[i] = targets.get(i).toCharArray();
 		}
-		BasicModule module = new BasicModule(source.toCharArray(), null, false);
+		BasicModule module = new BasicModule(source.toCharArray(), false);
 		module.exports = new IModule.IPackageExport[]{export};
 		return module;
 	}
-//
-//	static class PackageExport implements IPackageExport {
-//		char[] name;
-//		char[][] exportedTo;
-//		PackageExport(char[] name) {
-//			this.name = name;
-//		}
-//		@Override
-//		public char[] name() {
-//			return this.name;
-//		}
-//		@Override
-//		public char[][] exportedTo() {
-//			return this.exportedTo;
-//		}
-//	}
-//	
-//	static class Module implements IModule {
-//		char[] name;
-//		IPackageExport[] export;
-//		boolean isAuto;
-//		Module(char[] name, IPackageExport export, boolean isAuto) {
-//			this.name = name;
-//			this.export = new IPackageExport[]{export};
-//			this.isAuto = isAuto;
-//		}
-//		@Override
-//		public char[] name() {
-//			return this.name;
-//		}
-//		@Override
-//		public IModuleReference[] requires() {
-//			return null;
-//		}
-//		@Override
-//		public IPackageExport[] exports() {
-//			return this.export;
-//		}
-//		@Override
-//		public char[][] uses() {
-//			return null;
-//		}
-//		@Override
-//		public IService[] provides() {
-//			return null;
-//		}
-//		@Override
-//		public void setAutomatic(boolean isAuto) {
-//			this.isAuto = isAuto;
-//		}
-//		public boolean isAutomatic() {
-//			return this.isAuto;
-//		}
-//	}
-	
+
 	private static boolean isJar(File file) {
 		int format = Util.archiveFormat(file.getAbsolutePath());
 		return format >= Util.ZIP_FILE;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
index 3214c17..008b0f4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
@@ -18,6 +18,8 @@ public interface IModule {
 
 	public static IModuleReference[] NO_MODULE_REFS = new IModuleReference[0];
 	public static IPackageExport[] NO_EXPORTS = new IPackageExport[0];
+	public static char[][] NO_USES = new char[0][];
+	public static IService[] NO_PROVIDES = new IService[0];
 	public static IModule[] NO_MODULES = new IModule[0];
 
 	public char[] name();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index b68de6d..6fe2296 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -162,7 +162,10 @@ private void initAutomaticModules() {
 	if (this.nameEnvironment instanceof IModuleAwareNameEnvironment) {
 		IModule[] mods = ((IModuleAwareNameEnvironment) this.nameEnvironment).getAllAutomaticModules();
 		for (IModule iModule : mods) {
-			this.autoModules.put(iModule.name(), new ModuleBinding(iModule, this));
+			if (this.knownModules.get(iModule.name()) != null) {
+				continue; // TODO: ideally we want to report an error.
+			}
+			this.knownModules.put(iModule.name(), new ModuleBinding(iModule, this));
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index 7893773..fd01214 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -18,7 +18,6 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
-import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -184,10 +183,6 @@ public class ModuleBinding extends Binding {
 		return this.requiredModules = allRequires.size() > 0 ? allRequires.toArray(new ModuleBinding[allRequires.size()]) : NO_REQUIRES;
 	}
 
-	private Stream<ModuleBinding> getAllAutomaticModules() {
-		return Stream.of(this.environment.autoModules.valueTable).filter(m -> m != null);
-	}
-
 	public char[] name() {
 		return this.moduleName;
 	}
@@ -207,8 +202,6 @@ public class ModuleBinding extends Binding {
 	public boolean isPackageExportedTo(PackageBinding pkg, ModuleBinding client) {
 		PackageBinding resolved = getExportedPackage(pkg.readableName());
 		if (resolved == pkg) {
-			if (this.isAuto)
-				return true;
 			Predicate<IPackageExport> isTargeted = e -> e.exportedTo() != null;
 			Predicate<IPackageExport> isExportedTo = e -> 
 				Stream.of(e.exportedTo()).map(ref -> this.environment.getModule(ref)).filter(m -> m != null).anyMatch(client::equals);
@@ -229,8 +222,11 @@ public class ModuleBinding extends Binding {
 		if (declaresPackage(null, name)) {
 			return new PackageBinding(name, this.environment);
 		} else {
-			PackageBinding pack = Stream.of(getAllRequiredModules()).sorted((m1, m2) -> m1.requires.length - m2.requires.length)
+			return Stream.of(getAllRequiredModules()).sorted((m1, m2) -> m1.requires.length - m2.requires.length)
 					.map(m -> {
+						if (m.isAuto) {
+							return m.getTopLevelPackage(name);
+						}
 						PackageBinding binding = m.getExportedPackage(name);
 						if (binding != null && m.isPackageExportedTo(binding, this)) {
 							return m.declaredPackages.get(name);
@@ -238,19 +234,6 @@ public class ModuleBinding extends Binding {
 						return null;
 					})
 			.filter(p -> p != null).findFirst().orElse(null);
-			if (pack != null || this.isAuto) {
-				return pack;
-			}
-			// This will only work if the automatic modules already have all their packages loaded,
-			// remember there's no module-info
-			return getAllAutomaticModules().
-					map(new Function<ModuleBinding, PackageBinding>() {
-						@Override
-						public PackageBinding apply(ModuleBinding m) {
-							return m.getTopLevelPackage(name);
-						}
-					}).
-						filter(p -> p != null).findFirst().orElse(null);
 		}
 	}
 	// Given parent is declared in this module, see if there is sub package named name declared in this module
@@ -362,8 +345,11 @@ public class ModuleBinding extends Binding {
 		}
 		if (binding == null) {
 			char[] qualifiedPackageName = CharOperation.concatWith(parentPackageName, packageName, '.');
-			PackageBinding pack = Stream.of(getAllRequiredModules())
+			return Stream.of(getAllRequiredModules())
 					.map(m -> {
+						if (m.isAuto) {
+							return m.getPackage(parentPackageName, packageName);
+						}
 						PackageBinding p = m.getExportedPackage(qualifiedPackageName);
 						if (p != null && m.isPackageExportedTo(p, this)) {
 							return m.declaredPackages.get(qualifiedPackageName);
@@ -371,15 +357,6 @@ public class ModuleBinding extends Binding {
 						return null;
 					})
 			.filter(p -> p != null).findFirst().orElse(null);
-
-			if (pack != null || this.isAuto) {
-				return pack;
-			}
-			// This will only work if the automatic modules already have all their packages loaded,
-			// remember there's no module-info
-			return getAllAutomaticModules().filter(mod -> (mod.isAuto)).
-					map(m -> m.getPackage(parentPackageName, packageName)).
-						filter(p -> p != null).findFirst().orElse(null);
 		}
 		return binding;
 	}
@@ -393,10 +370,10 @@ public class ModuleBinding extends Binding {
 	 * @return True, if the package is visible to this module, false otherwise
 	 */
 	public boolean canSee(PackageBinding pkg) {
-		ModuleBinding[] mods = getAllRequiredModules();
-		return declaresPackage(pkg) || 
-			Stream.of(mods).anyMatch(dep -> dep.isPackageExportedTo(pkg, ModuleBinding.this)) || 
-				getAllAutomaticModules().anyMatch(dep -> dep.declaresPackage(pkg));
+		return declaresPackage(pkg) || Stream.of(getAllRequiredModules()).anyMatch(
+				dep -> (dep.isAuto && dep.declaresPackage(pkg)) ||
+						dep.isPackageExportedTo(pkg, ModuleBinding.this)
+		);
 	}
 	public boolean dependsOn(ModuleBinding other) {
  		if (other == this)
@@ -411,15 +388,10 @@ public class ModuleBinding extends Binding {
  	}
  	// A context including this module and all it's required modules
  	public IModuleContext getDependencyClosureContext() {
- 		Stream<ModuleBinding> stream = null;
- 		if (this.isAuto) {
- 			stream = getAllAutomaticModules();
- 		} else {
- 			stream = Stream.of(getAllRequiredModules());
- 		}
-		return getModuleLookupContext().includeAll(stream.map(m -> m.getModuleLookupContext()))
-			.includeAll(getAllAutomaticModules().
-					map(m -> m.getModuleLookupContext()));
+ 		if (this.isAuto)
+ 			return IModuleContext.UNNAMED_MODULE_CONTEXT;
+ 		ModuleBinding[] deps = getAllRequiredModules();
+ 		return getModuleLookupContext().includeAll(Stream.of(deps).map(m -> m.getModuleLookupContext()));
  	}
  	// A context that includes the entire module graph starting from this module
  	public IModuleContext getModuleGraphContext() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index 0024120..a92ef7c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -70,6 +70,40 @@ public abstract class ModuleEnvironment implements IModuleAwareNameEnvironment {
 		}
 
 	};
+	public static final class AutoModule implements IModule {
+		char[] name;
+		public AutoModule(char[] name) {
+			this.name = name;
+		}
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+
+		@Override
+		public IModuleReference[] requires() {
+			return IModule.NO_MODULE_REFS;
+		}
+
+		@Override
+		public IPackageExport[] exports() {
+			return IModule.NO_EXPORTS;
+		}
+
+		@Override
+		public char[][] uses() {
+			return IModule.NO_USES;
+		}
+
+		@Override
+		public IService[] provides() {
+			return IModule.NO_PROVIDES;
+		}
+
+		public boolean isAutomatic() {
+			return true;
+		}
+	}
 	public static IModule[] UNNAMED_MODULE_ARRAY = new IModule[]{UNNAMED_MODULE};
 
 	private HashMap<String, IModule> modulesCache = null;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
index e103ed6..a570ca9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
@@ -256,7 +256,7 @@ protected SourceType createTypeHandle(JavaElement parent, TypeInfo typeInfo) {
 	String nameString= new String(typeInfo.name);
 	return new SourceType(parent, nameString);
 }
-protected SourceModule createModuldHandle(JavaElement parent, ModuleInfo modInfo) {
+protected SourceModule createModuleHandle(JavaElement parent, ModuleInfo modInfo) {
 	String nameString= new String(modInfo.moduleName);
 	return new org.eclipse.jdt.internal.core.SourceModule(parent, nameString);
 }
@@ -508,7 +508,7 @@ public void enterType(TypeInfo typeInfo) {
 	JavaElement parentHandle= (JavaElement) this.handleStack.peek();
 	JavaElement handle = null;
 	if (typeInfo instanceof ModuleInfo) {
-		handle = createModuldHandle(parentHandle, (ModuleInfo) typeInfo);
+		handle = createModuleHandle(parentHandle, (ModuleInfo) typeInfo);
 	} else {
 		handle = createTypeHandle(parentHandle, typeInfo);
 		 //NB: occurenceCount is computed in resolveDuplicates
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 6b78acc..721eee6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -20,17 +20,23 @@ import java.util.*;
 import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.jobs.ISchedulingRule;
+import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IField;
 import org.eclipse.jdt.core.IInitializer;
 import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaModel;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
+import org.eclipse.jdt.core.IOpenable;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.ISourceRange;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -71,6 +77,265 @@ import org.eclipse.jdt.internal.core.util.Util;
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class NameLookup implements SuffixConstants {
+	private final class AutoModule implements IModuleDescription {
+		String modName = null;
+		public AutoModule(String name) {
+			this.modName = name;
+		}
+		
+		@Override
+		public boolean hasChildren() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public IJavaElement[] getChildren() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public void rename(String name, boolean replace, IProgressMonitor monitor) throws JavaModelException {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void move(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
+				IProgressMonitor monitor) throws JavaModelException {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void delete(boolean force, IProgressMonitor monitor) throws JavaModelException {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void copy(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
+				IProgressMonitor monitor) throws JavaModelException {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public ISourceRange getSourceRange() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public String getSource() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public ISourceRange getNameRange() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public <T> T getAdapter(Class<T> adapter) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public boolean isStructureKnown() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public boolean isReadOnly() {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public IResource getUnderlyingResource() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public ISchedulingRule getSchedulingRule() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IResource getResource() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IJavaElement getPrimaryElement() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IPath getPath() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IJavaElement getParent() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IOpenable getOpenable() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IJavaProject getJavaProject() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IJavaModel getJavaModel() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public String getHandleIdentifier() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public int getElementType() {
+			return IJavaElement.JAVA_MODULE;
+		}
+
+		@Override
+		public String getElementName() {
+			return this.modName;
+		}
+
+		@Override
+		public IResource getCorrespondingResource() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public String getAttachedJavadoc(IProgressMonitor monitor) throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IJavaElement getAncestor(int ancestorType) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public boolean exists() {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public boolean isBinary() {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public ITypeRoot getTypeRoot() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IType getType(String name, int occurrenceCount) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public int getOccurrenceCount() {
+			// TODO Auto-generated method stub
+			return 0;
+		}
+
+		@Override
+		public ISourceRange getJavadocRange() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public int getFlags() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return 0;
+		}
+
+		@Override
+		public IType getDeclaringType() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public ICompilationUnit getCompilationUnit() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IClassFile getClassFile() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public String[] getCategories() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public String[] getUsedServices() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IModuleReference[] getRequiredModules() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IProvidedService[] getProvidedServices() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public IPackageExport[] getExportedPackages() throws JavaModelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+	}
+
 	public static class Answer {
 		public IType type;
 		public IModuleDescription module;
@@ -874,9 +1139,11 @@ public class NameLookup implements SuffixConstants {
 				if (moduleDesc instanceof BinaryModule) {
 					ClassFileReader info = (ClassFileReader)((BinaryModule) moduleDesc).getElementInfo();
 					return info.getModuleDeclaration();
-				} else {
+				} else if (moduleDesc instanceof SourceModule) {
 					ModuleDescriptionInfo info = (ModuleDescriptionInfo)((SourceModule) moduleDesc).getElementInfo();
 					return info;
+				} else {
+					return new ModuleEnvironment.AutoModule(moduleDesc.getElementName().toCharArray());
 				}
 			} catch (JavaModelException e) {
 				// TODO Auto-generated catch block
@@ -889,6 +1156,13 @@ public class NameLookup implements SuffixConstants {
 	private IModuleDescription getModule(PackageFragmentRoot root) {
 		return root.getModuleDescription();
 	}
+	public IModule getModuleDescriptionInfo(PackageFragmentRoot root) {
+		IModuleDescription desc = getModule(root);
+		if (desc != null) {
+			return getModuleDescriptionInfo(desc);
+		}
+		return null;
+	}
 	private AccessRestriction getViolatedRestriction(String typeName, String packageName, ClasspathEntry entry, AccessRestriction accessRestriction) {
 		AccessRuleSet accessRuleSet = entry.getAccessRuleSet();
 		if (accessRuleSet != null) {
@@ -1282,8 +1556,19 @@ public class NameLookup implements SuffixConstants {
 				}
 			}
 			module = getModule((PackageFragmentRoot) root);
-			if (module != null && prefixMatcher.matches(name, module.getElementName().toCharArray()))
+			if (module != null) {
+				if (prefixMatcher.matches(name, module.getElementName().toCharArray()))
 				requestor.acceptModule(module);
+			} else {
+				String modName = root.getPath().removeFileExtension().lastSegment();
+				if (CharOperation.equals(modName.toCharArray(), name)) {
+					// ^^^ Only complete matches, at this point, as we don't propose automatic module names.
+					ClasspathEntry entry = (ClasspathEntry) this.rootToResolvedEntries.get(root);
+					if (entry != null && entry.isAutomaticModule()) {
+						requestor.acceptModule(new AutoModule(modName));
+					}
+				}
+			}
 		}
 	}
 	public IModuleEnvironment getModuleEnvironmentFor(char[] moduleName) throws JavaModelException {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index 95d1242..9d297d9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -32,6 +32,7 @@ import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment.AutoModule;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -63,7 +64,7 @@ ClasspathDirectory(IContainer binaryFolder, boolean isOutputFolder, AccessRuleSe
 
 void setAutomaticModule() {
 	this.isAutoModule = true;
-	acceptModule(new BasicModule(this.binaryFolder.getName().toCharArray(), this, true));
+	acceptModule(new AutoModule(this.binaryFolder.getName().toCharArray()));
 }
 
 public void cleanup() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 95aa6de..709443b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -39,6 +39,7 @@ import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.IPackageLookup;
 import org.eclipse.jdt.internal.compiler.env.ITypeLookup;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment.AutoModule;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
@@ -177,9 +178,17 @@ public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath external
 
 void setAutomaticModule() {
 	this.isAutoModule = true;
-	acceptModule(new BasicModule(this.zipFilename.toCharArray(), this, true));
+	acceptModule(new AutoModule(getFileName(this.zipFilename).toCharArray()));
+}
+private static String getFileName(String name) {
+	int index = name.lastIndexOf('.');
+	if (index != -1)
+		name = name.substring(0, index);
+	index = name.lastIndexOf(File.separatorChar);
+	if (index == -1)
+		return name;
+	return name.substring(index + 1);
 }
-
 public void cleanup() {
 	if (this.closeZipFileAtEnd) {
 		if (this.zipFile != null) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index d64e66d..0d34afe 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -230,7 +230,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
+					ClasspathLocation bLocation = ClasspathLocation.forLibrary(path.toOSString(), accessRuleSet, externalAnnotationPath, this, entry.isAutomaticModule());
 					bLocations.add(bLocation);
 					// TODO: Ideally we need to do something like mapToModulePathEntry using the path and if it is indeed
 					// a module path entry, then add the corresponding entry here, but that would need the target platform
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 1eadf51..dfd21e6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -53,7 +53,7 @@ private long previousStructuralBuildTime;
 private StringSet structurallyChangedTypes;
 public static int MaxStructurallyChangedTypes = 100; // keep track of ? structurally changed types, otherwise consider all to be changed
 
-public static final byte VERSION = 0x001D;
+public static final byte VERSION = 0x001E;
 
 static final byte SOURCE_FOLDER = 1;
 static final byte BINARY_FOLDER = 2;
commit 3184220bef1ebbc9aa3ea889c738525a0c119015
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Dec 12 18:03:40 2016 +0530

    Bug 506878  - [9] Provide means to support automatic modules
    
    Fixing issue with JRT based JRE.

4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index dfd21e6..4bc15a6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -24,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.AccessRule;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
+import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.internal.core.ClasspathAccessRule;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 
@@ -279,8 +280,9 @@ static State read(IProject project, DataInputStream in) throws IOException {
 							readRestriction(in), new Path(in.readUTF()), newState.environment, in.readBoolean());
 				break;
 			case EXTERNAL_JAR :
-					newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(),
-							readRestriction(in), new Path(in.readUTF()), newState.environment, in.readBoolean());
+				String jarPath = in.readUTF();
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(jarPath, in.readLong(),
+							readRestriction(in), new Path(in.readUTF()), newState.environment, Util.isJrt(jarPath) ? false : in.readBoolean());
 				break;
 			case INTERNAL_JAR :
 					newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())),
commit 21f45d706b6cb2001366627cff8369bc49de0024
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Feb 17 11:41:16 2017 +0530

    Bug 506878 -[9] Provide means to support automatic modules
    
    Fix to ensure the opened Zip files in ClasspathJar are closed upon
    cleanup.
    
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 6fffe1b..700928e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -176,6 +176,7 @@ ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet,
 public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
 	this(zipFile.getName(), accessRuleSet, externalAnnotationPath, env, isAutomodule);
 	this.zipFile = zipFile;
+	this.closeZipFileAtEnd = true;
 }
 
 public ClasspathJar(String fileName, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env, boolean isAutomodule) {
commit 384406e565fbbb36059741c6098302d4d6ad5a97
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Sep 2 22:42:35 2017 +0200

    Bug 506878: [9] Provide means to support automatic modules
    
    Change-Id: Ib32757374aad189432d127eb1f037c659be89c08

41	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
170	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
1	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
13	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
7	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
28	14	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
25	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/AutomaticModuleNaming.java
53	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
0	60	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AutoModule.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
3	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
20	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
14	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
74	256	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
5	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
13	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
14	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
5	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
2	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
2	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index dc62a95..418ba55 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -3066,4 +3066,45 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			false,
 			OUTPUT_DIR + File.separator + out);
 	}
+	public void testAutoModule1() throws Exception {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+
+		String[] sources = {
+			"p/a/X.java",
+			"package p.a;\n" +
+			"public class X {}\n;"
+		};
+		String jarPath = OUTPUT_DIR + File.separator + "lib-x.jar";
+		Util.createJar(sources, jarPath, "1.8");
+		
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires lib.x;\n" + // lib.x is derived from lib-x.jar
+						"}");
+		writeFileCollecting(files, moduleLoc+File.separator+"q", "X.java", 
+						"package q;\n" +
+						"public class X {\n" +
+						"	p.a.X f;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" --module-path " + "\"" + jarPath + "\"");
+
+		runConformModuleTest(files, 
+			buffer,
+			"",
+			"",
+			false,
+			OUTPUT_DIR + File.separator + out);
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 7db8351..8fe6843 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -4960,12 +4960,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"Cycle exists in module dependencies, Module mod.one requires itself via mod.two",
 					markers);
 			markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			sortMarkers(markers);
 			assertMarkers("Unexpected markers in mod.two", 
-					"Cycle exists in module dependencies, Module mod.two requires itself via mod.one\n" + 
 					"The import org cannot be resolved\n" + // cannot use cyclic requires 
+					"Cycle exists in module dependencies, Module mod.two requires itself via mod.one\n" + 
 					"World cannot be resolved to a type",
 					markers);
-	
+
 			this.workingCopies = new ICompilationUnit[1];
 			this.workingCopies[0] = getCompilationUnit("/mod.two/src/module-info.java").getWorkingCopy(this.wcOwner, null);
 			this.problemRequestor.initialize(src[1].toCharArray());
@@ -4973,7 +4974,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			assertNotNull("Could not reconcile", unit);
 		} finally {
 			this.deleteProject("mod.one");
-			this.deleteProject("org.two");
+			this.deleteProject("mod.two");
 		}
 	}
 	public void testBug521346() throws CoreException, IOException {
@@ -5003,6 +5004,172 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				deleteProject(javaProject);
 		}
 	}
+	public void testAutoModule1() throws Exception {
+		if (!isJRE9) return;
+		IJavaProject javaProject = null;
+		try {
+			String[] sources = {
+				"p/a/X.java",
+				"package p.a;\n" +
+				"public class X {}\n;"
+			};
+			String outputDirectory = Util.getOutputDirectory();
+	
+			String jarPath = outputDirectory + File.separator + "lib-x.jar";
+			Util.createJar(sources, jarPath, "1.8");
+			
+			javaProject = createJava9Project("mod.one", new String[] {"src"});
+			IClasspathAttribute[] attributes = { JavaCore.newClasspathAttribute(IClasspathAttribute.MODULE, "true") };
+			addClasspathEntry(javaProject, JavaCore.newLibraryEntry(new Path(jarPath), null, null, null, attributes, false));
+
+			String srcMod =
+				"module mod.one { \n" +
+				"	requires lib.x;\n" + // lib.x is derived from lib-x.jar
+				"}";
+			createFile("/mod.one/src/module-info.java", 
+				srcMod);
+			createFolder("mod.one/src/q");
+			String srcX =
+				"package q;\n" +
+				"public class X {\n" +
+				"	p.a.X f;\n" +
+				"}";
+			createFile("/mod.one/src/q/X.java", srcX);
+			
+			this.problemRequestor.initialize(srcMod.toCharArray());
+			getWorkingCopy("/mod.one/module-info.java", srcMod, true);
+			assertProblems("module-info should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			this.problemRequestor.initialize(srcX.toCharArray());
+			getWorkingCopy("/mod.one/src/q/X.java", srcX, true);
+			assertProblems("X should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			javaProject.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			assertNoErrors();
+		} finally {
+			if (javaProject != null)
+				deleteProject(javaProject);
+		}
+	}
+	public void testAutoModule2() throws Exception {
+		if (!isJRE9) return;
+		IJavaProject javaProject = null;
+		try {
+			String[] sources = {
+				"p/a/X.java",
+				"package p.a;\n" +
+				"public class X {}\n;",
+			};
+			String[] mfSource = {
+				"META-INF/MANIFEST.MF",
+				"Manifest-Version: 1.0\n" + 
+				"Automatic-Module-Name: org.eclipse.lib.x\n"
+			};
+			String outputDirectory = Util.getOutputDirectory();
+
+			String jarPath = outputDirectory + File.separator + "lib-x.jar";
+			Util.createJar(sources, mfSource, jarPath, "1.8");
+			
+			javaProject = createJava9Project("mod.one", new String[] {"src"});
+			IClasspathAttribute[] attributes = { JavaCore.newClasspathAttribute(IClasspathAttribute.MODULE, "true") };
+			addClasspathEntry(javaProject, JavaCore.newLibraryEntry(new Path(jarPath), null, null, null, attributes, false));
+
+			String srcMod =
+				"module mod.one { \n" +
+				"	requires org.eclipse.lib.x;\n" + // from jar attribute
+				"}";
+			createFile("/mod.one/src/module-info.java", 
+				srcMod);
+			createFolder("mod.one/src/q");
+			String srcX =
+				"package q;\n" +
+				"public class X {\n" +
+				"	p.a.X f;\n" +
+				"}";
+			createFile("/mod.one/src/q/X.java", srcX);
+
+			this.problemRequestor.initialize(srcMod.toCharArray());
+			getWorkingCopy("/mod.one/module-info.java", srcMod, true);
+			assertProblems("module-info should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			this.problemRequestor.initialize(srcX.toCharArray());
+			getWorkingCopy("/mod.one/src/q/X.java", srcX, true);
+			assertProblems("X should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			javaProject.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			assertNoErrors();
+		} finally {
+			if (javaProject != null)
+				deleteProject(javaProject);
+		}
+	}
+	public void _testAutoModule3() throws Exception {
+		if (!isJRE9) return;
+		IJavaProject javaProject = null, auto = null;
+		try {
+			auto = createJava9Project("auto", new String[] {"src"});
+			createFolder("auto/src/p/a");
+			createFile("auto/src/p/a/X.java",
+				"package p.a;\n" +
+				"public class X {}\n;");
+			createFolder("auto/META-INF");
+			createFile("auto/META-INF/MANIFEST.MF",
+				"Manifest-Version: 1.0\n" + 
+				"Automatic-Module-Name: org.eclipse.lib.x\n");
+
+			javaProject = createJava9Project("mod.one", new String[] {"src"});
+			IClasspathAttribute[] attributes = { JavaCore.newClasspathAttribute(IClasspathAttribute.MODULE, "true") };
+			addClasspathEntry(javaProject, JavaCore.newProjectEntry(auto.getPath(), null, false, attributes, false));
+
+			String srcMod =
+				"module mod.one { \n" +
+				"	requires org.eclipse.lib.x;\n" + // from manifest attribute
+				"}";
+			createFile("/mod.one/src/module-info.java", 
+				srcMod);
+			createFolder("mod.one/src/q");
+			String srcX =
+				"package q;\n" +
+				"public class X {\n" +
+				"	p.a.X f;\n" +
+				"}";
+			createFile("/mod.one/src/q/X.java", srcX);
+
+			this.problemRequestor.initialize(srcMod.toCharArray());
+			getWorkingCopy("/mod.one/module-info.java", srcMod, true);
+			assertProblems("module-info should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			this.problemRequestor.initialize(srcX.toCharArray());
+			getWorkingCopy("/mod.one/src/q/X.java", srcX, true);
+			assertProblems("X should have no problems",
+					"----------\n" + 
+					"----------\n",
+					this.problemRequestor);
+
+			javaProject.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			assertNoErrors();
+		} finally {
+			if (javaProject != null)
+				deleteProject(javaProject);
+			if (auto != null)
+				deleteProject(auto);
+		}
+	}
 	protected void assertNoErrors() throws CoreException {
 		for (IProject p : getWorkspace().getRoot().getProjects()) {
 			int maxSeverity = p.findMaxProblemSeverity(null, true, IResource.DEPTH_INFINITE);
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index d93af4b..42de3ea 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -30,7 +30,6 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
@@ -328,7 +327,7 @@ public int getMode() {
 }
 public IModule getModule() {
 	if (this.isAutoModule && this.module == null) {
-		return this.module = new AutoModule(this.path.toCharArray());
+		return this.module = IModule.createAutomatic(this.path, false, null/*no manifest*/);
 	}
 	return this.module;
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index ad66038..c6a543a 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -26,6 +26,7 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.jar.Manifest;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
@@ -39,7 +40,7 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
@@ -69,7 +70,7 @@ public List<Classpath> fetchLinkedJars(FileSystem.ClasspathSectionProblemReporte
 	try {
 		initialize();
 		ArrayList<Classpath> result = new ArrayList<>();
-		ZipEntry manifest = this.zipFile.getEntry("META-INF/MANIFEST.MF"); //$NON-NLS-1$
+		ZipEntry manifest = this.zipFile.getEntry(TypeConstants.META_INF_MANIFEST_MF);
 		if (manifest != null) { // non-null implies regular file
 			inputStream = this.zipFile.getInputStream(manifest);
 			ManifestAnalyzer analyzer = new ManifestAnalyzer();
@@ -301,7 +302,16 @@ public int getMode() {
 
 public IModule getModule() {
 	if (this.isAutoModule && this.module == null) {
-		return this.module = new AutoModule(this.file.getName().toCharArray());
+		Manifest manifest = null;
+		try {
+			initialize();
+			ZipEntry entry = this.zipFile.getEntry(TypeConstants.META_INF_MANIFEST_MF);
+			if (entry != null)
+				manifest = new Manifest(this.zipFile.getInputStream(entry));
+		} catch (IOException e) {
+			// no usable manifest 
+		}
+		return this.module = IModule.createAutomatic(this.file.getName(), true, manifest);
 	}
 	return this.module;
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 19e40e1..97ab977 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3446,10 +3446,14 @@ protected ArrayList<FileSystem.Classpath> handleModulepath(String arg) {
 	ArrayList<Classpath> result = new ArrayList<>();
 	if ((modulePaths != null && modulePaths.size() > 0)) {
 		for (String path : modulePaths) {
-			File dir = new File(path);
-			if (dir.isDirectory()) {
+			File file = new File(path);
+			if (file.isDirectory()) {
 				result =
-					(ArrayList<Classpath>) ModuleFinder.findModules(dir, null, getNewParser(), this.options, true);
+					(ArrayList<Classpath>) ModuleFinder.findModules(file, null, getNewParser(), this.options, true);
+			} else {
+				Classpath modulePath = ModuleFinder.findModule(file, null, getNewParser(), this.options, true);
+				if (modulePath != null)
+					result.add(modulePath);
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
index c53af85..80cb270 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -22,6 +22,8 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
 import java.util.zip.ZipFile;
 
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -32,7 +34,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.PackageExportImpl;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -45,21 +46,26 @@ public class ModuleFinder {
 			if (files == null) 
 				return Collections.EMPTY_LIST;
 			for (final File file : files) {
-				FileSystem.Classpath modulePath = FileSystem.getClasspath(
-						file.getAbsolutePath(),
-						null,
-						!isModulepath,
-						null,
-						destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
-						options);
-				if (modulePath != null) {
+				Classpath modulePath = findModule(file, destinationPath, parser, options, isModulepath);
+				if (modulePath != null)
 					collector.add(modulePath);
-					scanForModule(modulePath, file, parser, isModulepath);
-				}
 			}
 		}
 		return collector;
 	}
+	protected static FileSystem.Classpath findModule(final File file, String destinationPath, Parser parser, Map<String, String> options, boolean isModulepath) {
+		FileSystem.Classpath modulePath = FileSystem.getClasspath(
+				file.getAbsolutePath(),
+				null,
+				!isModulepath,
+				null,
+				destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
+				options);
+		if (modulePath != null) {
+			scanForModule(modulePath, file, parser, isModulepath);
+		}
+		return modulePath;
+	}
 	protected static IModule scanForModule(FileSystem.Classpath modulePath, final File file, Parser parser, boolean isModulepath) {
 		IModule module = null;
 		if (file.isDirectory()) {
@@ -87,14 +93,22 @@ public class ModuleFinder {
 		} else if (isJar(file)) {
 			module = extractModuleFromJar(file, modulePath);
 		}
-		if (isModulepath && module == null) {
-			 // The name includes the file's extension, but it shouldn't matter.
-			module = new AutoModule(getFileName(file).toCharArray());
+		if (isModulepath && module == null && !(modulePath instanceof ClasspathJrt)) {
+			module = IModule.createAutomatic(getFileName(file), file.isFile(), getManifest(file));
 		}
 		if (module != null)
 			modulePath.acceptModule(module);
 		return module;
 	}
+	private static Manifest getManifest(File file) {
+		if (!isJar(file))
+			return null;
+		try (JarFile jar = new JarFile(file)) {
+			return jar.getManifest();
+		} catch (IOException e) {
+			return null;
+		}
+	}
 	private static String getFileName(File file) {
 		String name = file.getName();
 		int index = name.lastIndexOf('.');
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/AutomaticModuleNaming.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/AutomaticModuleNaming.java
index 63ba2d8..765c0a1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/AutomaticModuleNaming.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/AutomaticModuleNaming.java
@@ -16,8 +16,11 @@ import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
 public class AutomaticModuleNaming {
-	/*
-	 * Determine the automatic module name as specified in {@link <a href=
+
+	private static final String AUTOMATIC_MODULE_NAME = "Automatic-Module-Name"; //$NON-NLS-1$
+
+	/**
+	 * Determine the automatic module name of a given jar as specified in {@link <a href=
 	 * "http://download.java.net/java/jdk9/docs/api/java/lang/module/ModuleFinder.html#of-java.nio.file.Path...-">
 	 * ModuleFinder.of</a>}
 	 */
@@ -27,7 +30,7 @@ public class AutomaticModuleNaming {
 		try (JarFile jar = new JarFile(jarFileName)) {
 			Manifest manifest = jar.getManifest();
 			if (manifest != null) {
-				String automaticModuleName = manifest.getMainAttributes().getValue("Automatic-Module-Name"); //$NON-NLS-1$
+				String automaticModuleName = manifest.getMainAttributes().getValue(AUTOMATIC_MODULE_NAME);
 				if (automaticModuleName != null) {
 					return automaticModuleName.toCharArray();
 				}
@@ -40,6 +43,25 @@ public class AutomaticModuleNaming {
 	}
 
 	/**
+	 * Determine the automatic module name of a given jar or project as specified in {@link <a href=
+	 * "http://download.java.net/java/jdk9/docs/api/java/lang/module/ModuleFinder.html#of-java.nio.file.Path...-">
+	 * ModuleFinder.of</a>}
+	 * @param fileName names either a jar file or a java project in the workspace
+	 * @param isFile <code>true</code> indicates that fileName denotes a file, <code>false</code> must be used for projects
+	 * @param manifest representation of the META-INF/MANIFEST.MF entry within the given source (jar or project), or <code>null</code>
+	 * @return the derived module name or <code>null</code>
+	 */
+	public static char[] determineAutomaticModuleName(final String fileName, boolean isFile, Manifest manifest) {
+		if (manifest != null) {
+			String automaticModuleName = manifest.getMainAttributes().getValue(AUTOMATIC_MODULE_NAME);
+			if (automaticModuleName != null) {
+				return automaticModuleName.toCharArray();
+			}
+		}
+		return determineAutomaticModuleNameFromFileName(fileName, true, isFile);
+	}
+
+	/**
 	 * Determine the automatic module name if no "Automatic-Module-Name" was found in the Manifest, as specified in
 	 * {@link <a href=
 	 * "http://download.java.net/java/jdk9/docs/api/java/lang/module/ModuleFinder.html#of-java.nio.file.Path...-">ModuleFinder.of</a>}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
index 996d22d..dd37c12 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
@@ -14,6 +14,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
+import java.util.jar.Manifest;
+
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
 public interface IModule {
@@ -82,4 +84,55 @@ public interface IModule {
 		return false;
 	}
 	public abstract boolean isOpen();
+
+
+	public static IModule createAutomatic(char[] moduleName) {
+		final class AutoModule implements IModule {
+			char[] name;
+			public AutoModule(char[] name) {
+				this.name = name;
+			}
+			@Override
+			public char[] name() {
+				return this.name;
+			}
+			
+			@Override
+			public IModuleReference[] requires() {
+				return IModule.NO_MODULE_REFS;
+			}
+			
+			@Override
+			public IPackageExport[] exports() {
+				return IModule.NO_EXPORTS;
+			}
+			
+			@Override
+			public char[][] uses() {
+				return IModule.NO_USES;
+			}
+			
+			@Override
+			public IService[] provides() {
+				return IModule.NO_PROVIDES;
+			}
+			
+			@Override
+			public IPackageExport[] opens() {
+				return NO_OPENS;
+			}
+			
+			public boolean isAutomatic() {
+				return true;
+			}
+			public boolean isOpen() {
+				return false;
+			}
+		}
+		return new AutoModule(moduleName);
+	}
+
+	public static IModule createAutomatic(String fileName, boolean isFile, Manifest manifest) {
+		return createAutomatic(AutomaticModuleNaming.determineAutomaticModuleName(fileName, isFile, manifest));
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AutoModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AutoModule.java
deleted file mode 100644
index c051adc..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AutoModule.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2017 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.lookup;
-
-import org.eclipse.jdt.internal.compiler.env.IModule;
-
-public final class AutoModule implements IModule {
-	char[] name;
-	public AutoModule(char[] name) {
-		this.name = name;
-	}
-	@Override
-	public char[] name() {
-		return this.name;
-	}
-
-	@Override
-	public IModuleReference[] requires() {
-		return IModule.NO_MODULE_REFS;
-	}
-
-	@Override
-	public IPackageExport[] exports() {
-		return IModule.NO_EXPORTS;
-	}
-
-	@Override
-	public char[][] uses() {
-		return IModule.NO_USES;
-	}
-
-	@Override
-	public IService[] provides() {
-		return IModule.NO_PROVIDES;
-	}
-
-	@Override
-	public IPackageExport[] opens() {
-		return NO_OPENS;
-	}
-
-	public boolean isAutomatic() {
-		return true;
-	}
-	public boolean isOpen() {
-		return false;
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 202ecb6..4e167e4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -479,4 +479,5 @@ public interface TypeConstants {
 	public static final String MODULE_INFO_CLASS_NAME_STRING = "module-info.class"; //$NON-NLS-1$
 	// java.base module name
 	char[] JAVA_BASE = "java.base".toCharArray(); //$NON-NLS-1$
+	String META_INF_MANIFEST_MF = "META-INF/MANIFEST.MF"; //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
index c23fae8..c8155ae 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
@@ -140,8 +140,8 @@ public class ClasspathChange {
 							continue; // null and not-null
 						}						
 					}
-					if (((ClasspathEntry) entry).isAutomaticModule() !=
-							((ClasspathEntry) other).isAutomaticModule()) {
+					if (((ClasspathEntry) entry).isModular() !=
+							((ClasspathEntry) other).isModular()) {
 						continue nextEntry;
 					}
 					return i;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index 17cc2e3..1c70a88 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -68,6 +68,7 @@ import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRule;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer;
 import org.eclipse.jdt.internal.core.nd.IReader;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
@@ -1004,7 +1005,7 @@ public class ClasspathEntry implements IClasspathEntry {
 		JavaModelManager manager = JavaModelManager.getJavaModelManager();
 		try {
 			zip = manager.getZipFile(jarPath);
-			ZipEntry manifest = zip.getEntry("META-INF/MANIFEST.MF"); //$NON-NLS-1$
+			ZipEntry manifest = zip.getEntry(TypeConstants.META_INF_MANIFEST_MF);
 			if (manifest == null) {
 				return null;
 			}
@@ -1438,7 +1439,7 @@ public class ClasspathEntry implements IClasspathEntry {
 		}
 		return false;
 	}
-	public boolean isAutomaticModule() {
+	public boolean isModular() {
 		for (int i = 0, length = this.extraAttributes.length; i < length; i++) {
 			IClasspathAttribute attribute = this.extraAttributes[i];
 			if (IClasspathAttribute.MODULE.equals(attribute.getName()) && "true".equals(attribute.getValue())) //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 8d78557..a31bc13 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -14,9 +14,11 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
+import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.jar.Manifest;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
 import java.util.zip.ZipFile;
@@ -31,6 +33,7 @@ import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.nd.IReader;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
@@ -375,6 +378,23 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		}
 		return null;
 	}
+
+	@Override
+	public Manifest getManifest() {
+		ZipFile jar = null;
+		try {
+			jar = getJar();
+			ZipEntry mfEntry = jar.getEntry(TypeConstants.META_INF_MANIFEST_MF);
+			if (mfEntry != null)
+				return new Manifest(jar.getInputStream(mfEntry));
+		} catch (CoreException | IOException e) {
+			// must do without manifest
+		} finally {
+			JavaModelManager.getJavaModelManager().closeZipFile(jar);
+		}
+		return null;
+	}
+
 //	@Override
 //	public boolean isModule() {
 //	 	try {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index a4cf456..f257c69 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -29,6 +29,7 @@ import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.jar.Manifest;
 import java.util.stream.Collectors;
 
 import javax.xml.parsers.DocumentBuilder;
@@ -3386,4 +3387,17 @@ public class JavaProject
 		}
 		info.setModule(module);
 	}
+
+	public Manifest getManifest() {
+		IFile file = getProject().getFile(new Path(TypeConstants.META_INF_MANIFEST_MF));
+		if (file.exists()) {
+			try (InputStream contents = file.getContents()) {
+				return new Manifest(contents);
+			} catch (IOException | CoreException e) {
+				// unusable manifest
+			}
+		}
+		return null;
+	}
+
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index d44121f..e9c2aec 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -17,28 +17,25 @@ package org.eclipse.jdt.internal.core;
 
 import java.io.File;
 import java.util.*;
+import java.util.function.Function;
+import java.util.jar.Manifest;
+
 import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.Path;
-import org.eclipse.core.runtime.jobs.ISchedulingRule;
-import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IField;
 import org.eclipse.jdt.core.IInitializer;
 import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IJavaModel;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IModuleDescription;
-import org.eclipse.jdt.core.IOpenable;
 import org.eclipse.jdt.core.IOrdinaryClassFile;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
-import org.eclipse.jdt.core.ISourceRange;
 import org.eclipse.jdt.core.IType;
-import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -46,6 +43,7 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
+import org.eclipse.jdt.internal.compiler.env.AutomaticModuleNaming;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
@@ -74,238 +72,22 @@ import org.eclipse.jdt.internal.core.util.Util;
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class NameLookup implements SuffixConstants {
-	private final class AutoModule implements IModuleDescription {
-		String modName = null;
-		public AutoModule(String name) {
-			this.modName = name;
-		}
-		
-		@Override
-		public boolean hasChildren() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return false;
-		}
 
-		@Override
-		public IJavaElement[] getChildren() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public void rename(String name, boolean replace, IProgressMonitor monitor) throws JavaModelException {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public void move(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
-				IProgressMonitor monitor) throws JavaModelException {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public void delete(boolean force, IProgressMonitor monitor) throws JavaModelException {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public void copy(IJavaElement container, IJavaElement sibling, String rename, boolean replace,
-				IProgressMonitor monitor) throws JavaModelException {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public ISourceRange getSourceRange() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public String getSource() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public ISourceRange getNameRange() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public <T> T getAdapter(Class<T> adapter) {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public boolean isStructureKnown() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return false;
-		}
-
-		@Override
-		public boolean isReadOnly() {
-			// TODO Auto-generated method stub
-			return false;
-		}
-
-		@Override
-		public IResource getUnderlyingResource() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public ISchedulingRule getSchedulingRule() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IResource getResource() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IJavaElement getPrimaryElement() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IPath getPath() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IJavaElement getParent() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IOpenable getOpenable() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IJavaProject getJavaProject() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IJavaModel getJavaModel() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public String getHandleIdentifier() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public int getElementType() {
-			return IJavaElement.JAVA_MODULE;
-		}
-
-		@Override
-		public String getElementName() {
-			return this.modName;
-		}
-
-		@Override
-		public IResource getCorrespondingResource() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public String getAttachedJavadoc(IProgressMonitor monitor) throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IJavaElement getAncestor(int ancestorType) {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public boolean exists() {
-			// TODO Auto-generated method stub
-			return false;
-		}
-
-		@Override
-		public boolean isBinary() {
-			// TODO Auto-generated method stub
-			return false;
-		}
-
-		@Override
-		public ITypeRoot getTypeRoot() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public IType getType(String name, int occurrenceCount) {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public int getOccurrenceCount() {
-			// TODO Auto-generated method stub
-			return 0;
-		}
-
-		@Override
-		public ISourceRange getJavadocRange() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public int getFlags() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return 0;
-		}
-
-		@Override
-		public IType getDeclaringType() {
-			// TODO Auto-generated method stub
-			return null;
-		}
-
-		@Override
-		public ICompilationUnit getCompilationUnit() {
-			// TODO Auto-generated method stub
-			return null;
-		}
+	/**
+	 * Handle for an automatic module.
+	 *
+	 * <p>Note, that by definition this is mostly a fake, only {@link #getElementName()} provides a useful value.</p>
+	 */
+	private static class AutoModule extends AbstractModule {
 
-		@Override
-		public IClassFile getClassFile() {
-			// TODO Auto-generated method stub
-			return null;
+		public AutoModule(JavaElement parent, String name) {
+			super(parent, name);
 		}
 
 		@Override
-		public String[] getCategories() throws JavaModelException {
-			// TODO Auto-generated method stub
-			return null;
+		protected void toStringContent(StringBuffer buffer, String lineDelimiter) throws JavaModelException {
+			buffer.append("automatic module "); //$NON-NLS-1$
+			buffer.append(this.name);
 		}
 	}
 
@@ -450,7 +232,9 @@ public class NameLookup implements SuffixConstants {
 	 * Reverse map from root path to corresponding resolved CP entry
 	 * (so as to be able to figure inclusion/exclusion rules)
 	 */
-	protected Map rootToResolvedEntries;
+	protected Map<IPackageFragmentRoot,IClasspathEntry> rootToResolvedEntries;
+
+	protected Map<IPackageFragmentRoot,IModuleDescription> rootToModule;
 
 	/**
 	 * A map from package handles to a map from type name to an IType or an IType[].
@@ -474,6 +258,7 @@ public class NameLookup implements SuffixConstants {
 			Util.verbose(" -> working copy size: " + (workingCopies == null ? 0 : workingCopies.length));  //$NON-NLS-1$
 			start = System.currentTimeMillis();
 		}
+		this.rootToModule = new HashMap<>();
 		this.packageFragmentRoots = packageFragmentRoots;
 		if (workingCopies == null) {
 			this.packageFragments = packageFragments;
@@ -1027,7 +812,8 @@ public class NameLookup implements SuffixConstants {
 						accessRestriction = getViolatedRestriction(typeName, packageName, entry, accessRestriction);
 					}
 				}
-				Answer answer = new Answer(type, accessRestriction, entry, getModule(root));
+				Answer answer = new Answer(type, accessRestriction, entry,
+										getModuleDescription(root, this.rootToModule, this.rootToResolvedEntries::get));
 				if (!answer.ignoreIfBetter()) {
 					if (answer.isBetter(suggestedAnswer))
 						return answer;
@@ -1094,7 +880,7 @@ public class NameLookup implements SuffixConstants {
 				} else if (moduleDesc instanceof SourceModule) {
 					return (ModuleDescriptionInfo)((SourceModule) moduleDesc).getElementInfo();
 				} else {
-					return new org.eclipse.jdt.internal.compiler.lookup.AutoModule(moduleDesc.getElementName().toCharArray());
+					return IModule.createAutomatic(moduleDesc.getElementName().toCharArray());
 				}
 			} catch (JavaModelException e) {
 				// TODO Auto-generated catch block
@@ -1105,11 +891,47 @@ public class NameLookup implements SuffixConstants {
 		return null;
 	}
 
-	private IModuleDescription getModule(PackageFragmentRoot root) {
-		return root.getModuleDescription();
+	/** Internal utility, which is able to answer explicit and automatic modules. */
+	static IModuleDescription getModuleDescription(IPackageFragmentRoot root, Map<IPackageFragmentRoot,IModuleDescription> cache, Function<IPackageFragmentRoot,IClasspathEntry> rootToEntry) {
+		IModuleDescription module = cache.get(root);
+		if (module != null)
+			return module;
+		try {
+			if (root.getKind() == IPackageFragmentRoot.K_SOURCE)
+				module = root.getJavaProject().getModuleDescription(); // from any root in this project
+			else
+				module = root.getModuleDescription();
+		} catch (JavaModelException e) {
+			return null;
+		}
+		if (module == null) {
+			// 2nd attempt: try automatic module:
+			IClasspathEntry classpathEntry = rootToEntry.apply(root);
+			if (classpathEntry instanceof ClasspathEntry) {
+				if (((ClasspathEntry) classpathEntry).isModular()) {
+					// modular but no module-info implies this is an automatic module
+					Manifest manifest = null;
+					switch (classpathEntry.getEntryKind()) {
+						case IClasspathEntry.CPE_LIBRARY:
+							manifest = ((PackageFragmentRoot) root).getManifest();
+							break;
+						case IClasspathEntry.CPE_PROJECT:
+							JavaProject javaProject = (JavaProject) root.getJavaModel().getJavaProject(classpathEntry.getPath().lastSegment());
+							manifest = javaProject.getManifest();
+							break;
+					}
+					char[] moduleName = AutomaticModuleNaming.determineAutomaticModuleName(root.getElementName(), root.isArchive(), manifest);
+					module = new AutoModule((JavaElement) root, String.valueOf(moduleName));
+				}
+			}
+		}
+		if (module != null)
+			cache.put(root, module);
+		return module;
 	}
+
 	public IModule getModuleDescriptionInfo(PackageFragmentRoot root) {
-		IModuleDescription desc = getModule(root);
+		IModuleDescription desc = getModuleDescription(root, this.rootToModule, this.rootToResolvedEntries::get);
 		if (desc != null) {
 			return getModuleDescriptionInfo(desc);
 		}
@@ -1274,7 +1096,10 @@ public class NameLookup implements SuffixConstants {
 			case IJavaElement.JAVA_PROJECT:
 				try {
 					IJavaElement element = ((IJavaProject) moduleContext).findElement(new Path(String.join("/", pkgName))); //$NON-NLS-1$
-					return element instanceof IPackageFragment;
+					if (element instanceof IPackageFragment) {
+						IPackageFragmentRoot root = (IPackageFragmentRoot) element.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+						return root.getKind() == IPackageFragmentRoot.K_SOURCE;
+					}
 				} catch (JavaModelException e) {
 					return false;
 				}
@@ -1418,7 +1243,7 @@ public class NameLookup implements SuffixConstants {
 
 	@FunctionalInterface
 	interface IPrefixMatcherCharArray { // note the reversal in the order of params wrt to the string version.
-		boolean matches(char[] prefix, char[] name);
+		boolean matches(char[] prefix, char[] name, boolean isCaseSensitive);
 	}
 	/**
 	 * Notifies the given requestor of all package fragments with the
@@ -1493,8 +1318,11 @@ public class NameLookup implements SuffixConstants {
 	}
 	public void seekModule(char[] name, boolean prefixMatch, IJavaElementRequestor requestor) {
 
-		IPrefixMatcherCharArray prefixMatcher = prefixMatch ? CharOperation.equals(name, CharOperation.ALL_PREFIX) ?
-				(x, y) -> true : CharOperation::prefixEquals : CharOperation :: equals;
+		IPrefixMatcherCharArray prefixMatcher = prefixMatch 
+				? CharOperation.equals(name, CharOperation.ALL_PREFIX) 
+						? (x, y, isCaseSensitive) -> true
+						: CharOperation::prefixEquals
+				: CharOperation::equals;
 
 		int count= this.packageFragmentRoots.length;
 		for (int i= 0; i < count; i++) {
@@ -1503,23 +1331,13 @@ public class NameLookup implements SuffixConstants {
 			IPackageFragmentRoot root= this.packageFragmentRoots[i];
 			IModuleDescription module = null;
 			if (root instanceof JrtPackageFragmentRoot) {
-				if (!prefixMatcher.matches(name, root.getElementName().toCharArray())) {
+				if (!prefixMatcher.matches(name, root.getElementName().toCharArray(), false)) {
 					continue;
 				}
 			}
-			module = getModule((PackageFragmentRoot) root);
-			if (module != null) {
-				if (prefixMatcher.matches(name, module.getElementName().toCharArray()))
+			module = getModuleDescription(root, this.rootToModule, this.rootToResolvedEntries::get);
+			if (module != null && prefixMatcher.matches(name, module.getElementName().toCharArray(), false)) {
 				requestor.acceptModule(module);
-			} else {
-				String modName = root.getPath().removeFileExtension().lastSegment();
-				if (CharOperation.equals(modName.toCharArray(), name)) {
-					//            ^^^^^^ Only complete matches, at this point, as we don't propose automatic module names.
-					ClasspathEntry entry = (ClasspathEntry) this.rootToResolvedEntries.get(root);
-					if (entry != null && entry.isAutomaticModule()) {
-						requestor.acceptModule(new AutoModule(modName));
-					}
-				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index ec3ead3..61665bd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -17,6 +17,7 @@ package org.eclipse.jdt.internal.core;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Map;
+import java.util.jar.Manifest;
 
 import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.*;
@@ -895,4 +896,8 @@ public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName
 	}
 	return false;
 }
+/** Convenience lookup, though currently only JarPackageFragmentRoot is searched for a manifest. */
+public Manifest getManifest() {
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index 4ebe57c..a9a1e06 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -17,6 +17,7 @@ package org.eclipse.jdt.internal.core;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.function.Function;
 
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
@@ -66,6 +67,7 @@ public class SearchableEnvironment
 	private Map<String,IJavaElement> knownModuleLocations; // null indicates: not using JPMS
 
 	private ModuleUpdater moduleUpdater;
+	private Map<IPackageFragmentRoot,IModuleDescription> rootToModule;
 
 	/**
 	 * Creates a SearchableEnvironment on the given project
@@ -849,14 +851,19 @@ public class SearchableEnvironment
 				throw new IllegalArgumentException("Unexpected LookupStrategy "+strategy); //$NON-NLS-1$
 		}
 	}
+
 	private IModuleDescription getModuleDescription(IPackageFragmentRoot root) {
-		if (root instanceof JarPackageFragmentRoot)
-			return root.getModuleDescription();
-		try {
-			return root.getJavaProject().getModuleDescription();
-		} catch (JavaModelException e) {
-			return null;
+		if (this.rootToModule == null) {
+			this.rootToModule = new HashMap<>();
 		}
+		Function<IPackageFragmentRoot, IClasspathEntry> rootToEntry = r -> {
+			try {
+				return ((JavaProject) root.getJavaProject()).getClasspathEntryFor(root.getPath());
+			} catch (JavaModelException e) {
+				return null;
+			}
+		};
+		return NameLookup.getModuleDescription(root, this.rootToModule, rootToEntry);
 	}
 
 	private IJavaElement findModuleContext(char[] moduleName) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 26db3cb..12a6323 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -21,6 +21,7 @@ import java.io.File;
 import java.io.IOException;
 import java.util.Date;
 import java.util.Enumeration;
+import java.util.jar.Manifest;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
@@ -35,6 +36,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
@@ -108,7 +110,7 @@ IModule initializeModule() {
 	ZipFile file = null;
 	try {
 		file = new ZipFile(this.zipFilename);
-		ClassFileReader classfile = ClassFileReader.read(file, IModule.MODULE_INFO_CLASS);
+		ClassFileReader classfile = ClassFileReader.read(file, IModule.MODULE_INFO_CLASS); // FIXME: use jar cache
 		if (classfile != null) {
 			mod = classfile.getModuleDeclaration();
 		}
@@ -334,4 +336,15 @@ public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageN
 	// 
 	return findClass(typeName, qualifiedPackageName, moduleName, qualifiedBinaryFileName, false);
 }
+public Manifest getManifest() {
+	scanContent(); // ensure zipFile is initialized
+	ZipEntry entry = this.zipFile.getEntry(TypeConstants.META_INF_MANIFEST_MF);
+	try {
+		if (entry != null)
+			return new Manifest(this.zipFile.getInputStream(entry));
+	} catch (IOException e) {
+		// cannot use manifest
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
index 0d10a6f..6924d0d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
@@ -17,10 +17,8 @@ package org.eclipse.jdt.internal.core.builder;
 
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.env.AutomaticModuleNaming;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModulePathEntry;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 
 /**
  * Represents a project on the module path.
@@ -60,12 +58,13 @@ public class ModulePathEntry implements IModulePathEntry {
 	public boolean isAutomaticModule() {
 		return this.isAutomaticModule;
 	}
-	public static char[] getAutomaticModuleName(ClasspathLocation location) {
+	public static IModule getAutomaticModule(ClasspathLocation location) {
 		if (location instanceof ClasspathJar) {
-			return AutomaticModuleNaming.determineAutomaticModuleName(((ClasspathJar) location).zipFilename);
+			ClasspathJar classpathJar = (ClasspathJar) location;
+			return IModule.createAutomatic(classpathJar.zipFilename, true, classpathJar.getManifest());
 		}
 		if (location instanceof ClasspathDirectory) {
-			return ((ClasspathDirectory) location).binaryFolder.getName().toCharArray();
+			return IModule.createAutomatic(((ClasspathDirectory) location).binaryFolder.getName(), false, null);
 		}
 		return null;
 	}
@@ -80,7 +79,7 @@ public class ModulePathEntry implements IModulePathEntry {
 			this.module = mod;
 			this.isAutomaticModule = false;
 		} else {
-			this.module = new AutoModule(getAutomaticModuleName(location));
+			this.module = getAutomaticModule(location);
 			this.isAutomaticModule = true;
 		}
 		location.setModule(this.module);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index cde743c..78f8e0d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -28,7 +28,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.lookup.AutoModule;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
@@ -202,7 +201,7 @@ private void computeClasspathLocations(
 						// do nothing, probably a non module project
 					}
 					if (info == null)
-						info = new AutoModule(prereqJavaProject.getElementName().toCharArray());
+						info = IModule.createAutomatic(prereqJavaProject.getElementName(), false, prereqJavaProject.getManifest());
 					ModulePathEntry projectEntry = new ModulePathEntry(prereqJavaProject.getPath(), info,
 							projectLocations.toArray(new ClasspathLocation[projectLocations.size()]));
 					moduleEntries.put(String.valueOf(info.name()), projectEntry);
@@ -330,7 +329,7 @@ private void computeClasspathLocations(
 }
 
 protected boolean isOnModulePath(ClasspathEntry entry) {
-	return entry.isAutomaticModule();
+	return entry.isModular();
 }
 
 public void cleanup() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index df12fb7..80918fb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -62,6 +62,7 @@ import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
 import org.eclipse.jdt.internal.core.JavaElementDelta;
@@ -746,7 +747,7 @@ public final class Indexer {
 								}
 								resourceFile.addZipEntry(fileName);
 
-								if (fileName.equals("META-INF/MANIFEST.MF")) { //$NON-NLS-1$
+								if (fileName.equals(TypeConstants.META_INF_MANIFEST_MF)) {
 									try (InputStream inputStream = zipFile.getInputStream(member)) {
 										char[] chars = getInputStreamAsCharArray(inputStream, -1, UTF_8);
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 93198b6..da0eb13 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -167,7 +167,7 @@ private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, Packa
 						new ClasspathJar(manager.getZipFile(path), rawClasspathEntry.getAccessRuleSet(),
 								ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry,
 										((IJavaProject) root.getParent()).getProject(), true),
-								rawClasspathEntry.isAutomaticModule());
+								rawClasspathEntry.isModular());
 		} else {
 			Object target = JavaModel.getTarget(path, true);
 			if (target != null) {
@@ -177,7 +177,7 @@ private ClasspathLocation mapToClassPathLocation(JavaModelManager manager, Packa
 					ClasspathEntry rawClasspathEntry = (ClasspathEntry) root.getRawClasspathEntry();
 					cp = ClasspathLocation.forBinaryFolder((IContainer) target, false, rawClasspathEntry.getAccessRuleSet(),
 														ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true),
-														rawClasspathEntry.isAutomaticModule());
+														rawClasspathEntry.isModular());
 				}
 			}
 		}
