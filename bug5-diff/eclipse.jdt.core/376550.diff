commit 5903b5532387cc7ed73791cbff2d52e4ceee6d52
Author: Ayushman Jain <ajain>
Date:   Mon May 14 13:26:16 2012 +0530

    Fixed bug 376550: "Method can be static" warning on method that accesses
    instance field in inner class

762	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
14	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
14	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
37	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
index 3b4db37..00e1784 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7188,4 +7188,765 @@ public void test360164() {
 		// javac options
 		JavacTestOptions.SKIP_UNTIL_FRAMEWORK_FIX /* javac test options */);
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// SingleNameReference, assignment of instance field inside a local class method
+public void test376550_1a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"	int i = 1;\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			void method1() {\n" + // can't be static
+				"				i = 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// SingleNameReference, assignment of instance field of local class inside a local class method
+public void test376550_1b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"	int i = 1;\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			void method2() {\n" +  // can't be static
+				"				i2 = 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// LocalDeclaration with type as a type variable binding
+public void test376550_2a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local<K>{\n" +
+				"			void method2() {\n" +  // can't be static
+				"				K k;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X<T> can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// LocalDeclaration with type as a type variable binding
+public void test376550_2b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local<K>{\n" +
+				"			void method2() {\n" +  // can't be static
+				"				T t;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// MessageSend, calling outer class method inside a local class method
+public void test376550_3a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local<K>{\n" +
+				"			void lower() {}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				upper1();\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// MessageSend, calling local class method inside a local class method
+public void test376550_3b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   public void upper1(){}\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local<K>{\n" +
+				"			void lower() {}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				lower();\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X<T> can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// Local class instance field is an argument in messageSend in local class method
+public void test376550_4a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local<K>{\n" +
+				"			int i2 = 1;\n" +
+				"			void lower(int i) {}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				lower(i2);\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X<T> can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// Outerclass instance field is an argument in messageSend in local class method
+public void test376550_4b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X<T> {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local<K>{\n" +
+				"			int i2 = 1;\n" +
+				"			void lower(int i) {}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				lower(i1);\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameReference, accessing local class instance field
+public void test376550_5a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			void method2() {\n" +  // can't be static
+				"				Local.this.i2 = 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+//QualifiedNameReference, accessing outer class instance field
+public void test376550_5b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			void method2() {\n" +  // can't be static
+				"				X.this.i1 = 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef.analyseCode()
+public void test376550_6a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			boolean method2() {\n" +  // can't be static
+				"				return Local.this.i2 == 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef.analyseCode()
+public void test376550_6b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   int i1 = 1;\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			int i2 = 1;\n" +
+				"			boolean method2() {\n" +  // can't be static
+				"				return X.this.i1 == 1;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedAllocationExpression, allocating an anonymous type without an enclosing instance of parent type
+// anon. type is declared in local class
+public void test376550_7a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   abstract class AbsUp{}\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			abstract class AbsLow{}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				new AbsLow(){};\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedAllocationExpression, allocating an anonymous type without an enclosing instance of parent type
+// anon. type is declared in outer class
+public void test376550_7b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   abstract class AbsUp{}\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			abstract  class AbsLow{}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				new AbsUp(){};\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// FieldRef, from object of a class in outer class
+public void test376550_8a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   class AbsUp{ int a;}\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			class AbsLow{  int a;}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				int abc = new AbsLow().a;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+//FieldRef, from object of a class in local class
+public void test376550_8b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   class AbsUp{ int a;}\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			class AbsLow{  int a;}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				int abc = new AbsUp().a;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef, accessing a field from local class field
+public void test376550_9a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   X xup;\n" +
+				"	int i = 1;\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			X xdown;\n" +
+				"			class AbsLow{  int a;}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				int abc = xdown.i;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef, accessing a field from local class field
+public void test376550_9b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   X xup;\n" +
+				"	int i = 1;\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			X xdown;\n" +
+				"			class AbsLow{  int a;}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				int abc = xup.i;\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef, accessing a field from local class field
+public void test376550_10a() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   X xup;\n" +
+				"	int i = 1;\n" +
+				"   public void foo(){\n" + // can be static
+				"   	class Local{\n" +
+				"			X xdown;\n" +
+				"			void calc(int i1){}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				calc(xdown.i);\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	public void foo(){\n" + 
+		"	            ^^^^^\n" + 
+		"The method foo() from the type X can potentially be declared as static\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// QualifiedNameRef, accessing a field from local class field
+public void test376550_10b() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"public class X {\n" +
+				"   X xup;\n" +
+				"	int i = 1;\n" +
+				"   public void foo(){\n" + // can't be static
+				"   	class Local{\n" +
+				"			X xdown;\n" +
+				"			void calc(int i1){}\n" +
+				"			void method2() {\n" +  // can't be static
+				"				calc(xup.i);\n" +
+				"			}\n" +
+				"		}\n" +
+				"	}\n" +
+				"}"
+		},
+		"",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+// bug test case
+public void test376550_11() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"import java.util.ArrayList;\n" +
+				"import java.util.Collection;\n" +
+				"public class X {\n" +
+				"   private Object o = new Object();\n" +
+				"   public final Collection<Object> go() {\n" + // can't be static
+				"   	return new ArrayList<Object>() {\n" +
+				"			{ add(o);}\n" +
+				"		};\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 6)\n" + 
+		"	return new ArrayList<Object>() {\n" + 
+		"	           ^^^^^^^^^^^^^^^^^^^\n" + 
+		"The serializable class  does not declare a static final serialVersionUID field of type long\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 7)\n" + 
+		"	{ add(o);}\n" + 
+		"	      ^\n" + 
+		"Read access to enclosing field X.o is emulated by a synthetic accessor method\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+public void test376550_12() {
+	if (this.complianceLevel < ClassFileConstants.JDK1_5)
+		return;
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
+	this.runNegativeTest(
+		new String[] {
+				"X.java", 
+				"import java.util.ArrayList;\n" +
+				"import java.util.Collection;\n" +
+				"public class X<E> {\n" +
+				"   private Object o = new Object();\n" +
+				"   public final <E1> Collection<E1> go() {\n" + // CAN be static
+				"   	return new ArrayList<E1>() {\n" +
+				"			{ E1 e;}\n" +
+				"		};\n" +
+				"	}\n" +
+				"}"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	public final <E1> Collection<E1> go() {\n" + 
+		"	                                 ^^^^\n" + 
+		"The method go() from the type X<E> can be declared as static\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 6)\n" + 
+		"	return new ArrayList<E1>() {\n" + 
+		"	           ^^^^^^^^^^^^^^^\n" + 
+		"The serializable class  does not declare a static final serialVersionUID field of type long\n" + 
+		"----------\n",
+		null /* no extra class libraries */,
+		true /* flush output directory */,
+		compilerOptions /* custom options */
+	);
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index fa65474..b4f7143 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -21,7 +21,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Compiler for Java(TM)
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.C52, 3.8.0 RC1
+compiler.version = 0.C53, 3.8.0
 compiler.copyright = Copyright IBM Corp 2000, 2012. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index e5edeb4..df5f492 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -42,11 +42,24 @@
 	</td>
   </tr>
 </table>
+<a name="v_C53"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java development tools core</h1>
+Eclipse SDK 3.8.0 - %date% - 3.8.0 RC1
+<br>Project org.eclipse.jdt.core v_C53
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C53">cvs</a>).
+<h2>What's new in this drop</h2>
+
+<h3>Problem Reports Fixed</h3>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550">376550</a>
+&quot;Method can be static&quot; warning on method that accesses instance field in inner class
+
 <a name="v_C52"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java development tools core</h1>
-Eclipse SDK 3.8.0 - May 11, 2012 - 3.8.0 RC1
+Eclipse SDK 3.8.0 - May 11, 2012
 <br>
 <h2>What's new in this drop</h2>
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index d79c747..613003b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -90,7 +90,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.binding.declaringClass.isMemberType() && !this.binding.declaringClass.isStatic()) {
 		// allocating a non-static member type without an enclosing instance of parent type
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335845
-		currentScope.resetEnclosingMethodStaticFlag();
+		currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass.enclosingType());
 	}
 	manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index 66f16b6..855d700 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -111,12 +111,12 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 	if (!this.binding.isStatic()) {
 		if (this.receiver.isThis()) {
-			currentScope.resetEnclosingMethodStaticFlag();
+			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
 	} else if (this.receiver.isThis()) {
 		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
 			// explicit this, not allowed in static context
-			currentScope.resetEnclosingMethodStaticFlag();
+			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
 	}
 	return flowInfo;
@@ -133,7 +133,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 		if (this.receiver.isThis()) {
-			currentScope.resetEnclosingMethodStaticFlag();
+			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
 	} else if (this.receiver.isThis()) {
 		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 3916d6c..d7824c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -47,13 +47,21 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.bits |= ASTNode.IsLocalDeclarationReachable; // only set if actually reached
 	}
 	if (this.binding != null && this.type.resolvedType instanceof TypeVariableBinding) {
+		TypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.type.resolvedType;
 		MethodScope methodScope= this.binding.declaringScope.methodScope();
+		if (methodScope != null && methodScope.referenceContext instanceof TypeDeclaration) {
+			// initialization scope
+			methodScope = methodScope.enclosingMethodScope();
+		}
 		AbstractMethodDeclaration methodDeclaration = methodScope.referenceMethod();
-		if (methodDeclaration != null && ((methodDeclaration.bits & ASTNode.CanBeStatic) != 0) && methodDeclaration.binding != null) {
+		if (methodDeclaration != null && methodDeclaration.binding != null) {
 			TypeVariableBinding[] typeVariables = methodDeclaration.binding.typeVariables();
 			if (typeVariables == Binding.NO_TYPE_VARIABLES) {
 				// Method declares no type variables.
-				currentScope.resetEnclosingMethodStaticFlag();
+				if (typeVariableBinding.declaringElement instanceof TypeBinding)
+					currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
+				else
+					currentScope.resetEnclosingMethodStaticFlag();
 			} else {
 				// to check whether the resolved type for this is declared by enclosing method as a type variable
 				boolean usesEnclosingTypeVar = false; 
@@ -65,7 +73,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				}
 				if (!usesEnclosingTypeVar) {
 					// uses a type variable not declared by enclosing method
-					currentScope.resetEnclosingMethodStaticFlag();
+					if (typeVariableBinding.declaringElement instanceof TypeBinding)
+						currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
+					else
+						currentScope.resetEnclosingMethodStaticFlag();
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index c8bfc23..44f5bc4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -86,7 +86,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 		if (this.receiver.isThis()) {
 			// accessing non-static method without an object
-			currentScope.resetEnclosingMethodStaticFlag();
+			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
 	} else if (this.receiver.isThis()) {
 		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index ca10adb..a89b0be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -67,7 +67,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		} else {
 			if (this.binding.declaringClass.superclass().isMemberType() && !this.binding.declaringClass.superclass().isStatic()) {
 				// creating an anonymous type of a non-static member type without an enclosing instance of parent type
-				currentScope.resetEnclosingMethodStaticFlag();
+				currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass.superclass().enclosingType());
 			}
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 1277227..da5acae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -86,7 +86,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				}
 			}
 			if (!lastFieldBinding.isStatic()) {
-				currentScope.resetEnclosingMethodStaticFlag();
+				currentScope.resetDeclaringClassMethodStaticFlag(lastFieldBinding.declaringClass);
 			}
 			break;
 		case Binding.LOCAL :
@@ -195,7 +195,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				}
 			}
 			if (!fieldBinding.isStatic()) {
-				currentScope.resetEnclosingMethodStaticFlag();
+				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
 			}
 			break;
 		case Binding.LOCAL : // reading a local variable
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index d625d5b..a848aee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -73,7 +73,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				}
 				if (!fieldBinding.isStatic()) {
 					// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-					currentScope.resetEnclosingMethodStaticFlag();
+					currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
 				}
 				manageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);
 				break;
@@ -121,7 +121,7 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			}
 			if (!fieldBinding.isStatic()) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetEnclosingMethodStaticFlag();
+				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
 			}
 			break;
 		case Binding.LOCAL : // assigning to a local variable
@@ -174,7 +174,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			}
 			if (!fieldBinding.isStatic()) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetEnclosingMethodStaticFlag();
+				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
 			}
 			break;
 		case Binding.LOCAL : // reading a local variable
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index 699f630..3dee6e2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -957,16 +957,49 @@ public String toString(int tab) {
 	return s;
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
+/**
+ * This method is used to reset the CanBeStatic the enclosing method of the current block
+ */
 public void resetEnclosingMethodStaticFlag() {
 	MethodScope methodScope = methodScope();
+	if (methodScope != null) {
+		if (methodScope.referenceContext instanceof MethodDeclaration) {
+			MethodDeclaration methodDeclaration = (MethodDeclaration) methodScope.referenceContext;
+			methodDeclaration.bits &= ~ASTNode.CanBeStatic;
+		} else if (methodScope.referenceContext instanceof TypeDeclaration) {
+			// anonymous type, find enclosing method
+			methodScope = methodScope.enclosingMethodScope();
+			if (methodScope != null && methodScope.referenceContext instanceof MethodDeclaration) {
+				MethodDeclaration methodDeclaration = (MethodDeclaration) methodScope.referenceContext;
+				methodDeclaration.bits &= ~ASTNode.CanBeStatic;
+			}
+		}
+	}
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=376550
+/**
+ * This method is used to reset the CanBeStatic on all enclosing methods until the method 
+ * belonging to the declaringClass
+ * @param declaringClass
+ */
+public void resetDeclaringClassMethodStaticFlag(TypeBinding declaringClass) {
+	MethodScope methodScope = methodScope();
+	if (methodScope != null && methodScope.referenceContext instanceof TypeDeclaration) {
+		// anonymous type, find enclosing method
+		methodScope = methodScope.enclosingMethodScope();
+	}
 	while (methodScope != null && methodScope.referenceContext instanceof MethodDeclaration) {
-		MethodDeclaration methodDeclaration= (MethodDeclaration) methodScope.referenceContext;
+		MethodDeclaration methodDeclaration = (MethodDeclaration) methodScope.referenceContext;
 		methodDeclaration.bits &= ~ASTNode.CanBeStatic;
 		ClassScope enclosingClassScope = methodScope.enclosingClassScope();
 		if (enclosingClassScope != null) {
-			methodScope = enclosingClassScope.methodScope();
-		} else {
-			break;
+			TypeDeclaration type = enclosingClassScope.referenceContext;
+			if (type.binding != null && declaringClass != null && type.binding != declaringClass.original()) {
+				methodScope = enclosingClassScope.enclosingMethodScope();
+			} else {
+				break;
+			}
 		}
 	}
 }
